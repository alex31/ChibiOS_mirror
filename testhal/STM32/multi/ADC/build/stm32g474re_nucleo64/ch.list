
build/stm32g474re_nucleo64/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002b9 	.word	0x080002b9
 8000008:	080002bb 	.word	0x080002bb
 800000c:	080002bb 	.word	0x080002bb
 8000010:	080002bb 	.word	0x080002bb
 8000014:	080002bb 	.word	0x080002bb
 8000018:	080002bb 	.word	0x080002bb
 800001c:	080002bb 	.word	0x080002bb
 8000020:	080002bb 	.word	0x080002bb
 8000024:	080002bb 	.word	0x080002bb
 8000028:	080002bb 	.word	0x080002bb
 800002c:	08004f61 	.word	0x08004f61
 8000030:	080002bb 	.word	0x080002bb
 8000034:	080002bb 	.word	0x080002bb
 8000038:	080002bb 	.word	0x080002bb
 800003c:	080002bb 	.word	0x080002bb
 8000040:	080002bb 	.word	0x080002bb
 8000044:	080002bb 	.word	0x080002bb
 8000048:	080002bb 	.word	0x080002bb
 800004c:	080002bb 	.word	0x080002bb
 8000050:	080002bb 	.word	0x080002bb
 8000054:	080002bb 	.word	0x080002bb
 8000058:	080002bb 	.word	0x080002bb
 800005c:	080002bb 	.word	0x080002bb
 8000060:	080002bb 	.word	0x080002bb
 8000064:	080002bb 	.word	0x080002bb
 8000068:	080002bb 	.word	0x080002bb
 800006c:	08001d61 	.word	0x08001d61
 8000070:	08001d81 	.word	0x08001d81
 8000074:	08001da1 	.word	0x08001da1
 8000078:	08001dc1 	.word	0x08001dc1
 800007c:	08001de1 	.word	0x08001de1
 8000080:	08001e01 	.word	0x08001e01
 8000084:	08001e21 	.word	0x08001e21
 8000088:	08001711 	.word	0x08001711
 800008c:	080002bb 	.word	0x080002bb
 8000090:	080002bb 	.word	0x080002bb
 8000094:	080002bb 	.word	0x080002bb
 8000098:	080002bb 	.word	0x080002bb
 800009c:	080002bb 	.word	0x080002bb
 80000a0:	080002bb 	.word	0x080002bb
 80000a4:	080002bb 	.word	0x080002bb
 80000a8:	080002bb 	.word	0x080002bb
 80000ac:	080002bb 	.word	0x080002bb
 80000b0:	08000dd1 	.word	0x08000dd1
 80000b4:	080002bb 	.word	0x080002bb
 80000b8:	08000e11 	.word	0x08000e11
 80000bc:	080002bb 	.word	0x080002bb
 80000c0:	080002bb 	.word	0x080002bb
 80000c4:	080002bb 	.word	0x080002bb
 80000c8:	080002bb 	.word	0x080002bb
 80000cc:	080002bb 	.word	0x080002bb
 80000d0:	080002bb 	.word	0x080002bb
 80000d4:	080002bb 	.word	0x080002bb
 80000d8:	080002bb 	.word	0x080002bb
 80000dc:	080002bb 	.word	0x080002bb
 80000e0:	080002bb 	.word	0x080002bb
 80000e4:	080002bb 	.word	0x080002bb
 80000e8:	080002bb 	.word	0x080002bb
 80000ec:	080002bb 	.word	0x080002bb
 80000f0:	080002bb 	.word	0x080002bb
 80000f4:	080002bb 	.word	0x080002bb
 80000f8:	080002bb 	.word	0x080002bb
 80000fc:	08001761 	.word	0x08001761
 8000100:	080002bb 	.word	0x080002bb
 8000104:	080002bb 	.word	0x080002bb
 8000108:	080002bb 	.word	0x080002bb
 800010c:	080002bb 	.word	0x080002bb
 8000110:	080002bb 	.word	0x080002bb
 8000114:	080002bb 	.word	0x080002bb
 8000118:	080002bb 	.word	0x080002bb
 800011c:	080002bb 	.word	0x080002bb
 8000120:	08001e61 	.word	0x08001e61
 8000124:	08001e81 	.word	0x08001e81
 8000128:	08001ea1 	.word	0x08001ea1
 800012c:	08001ec1 	.word	0x08001ec1
 8000130:	08001ee1 	.word	0x08001ee1
 8000134:	080017a1 	.word	0x080017a1
 8000138:	080002bb 	.word	0x080002bb
 800013c:	080002bb 	.word	0x080002bb
 8000140:	080002bb 	.word	0x080002bb
 8000144:	080002bb 	.word	0x080002bb
 8000148:	080002bb 	.word	0x080002bb
 800014c:	080002bb 	.word	0x080002bb
 8000150:	080002bb 	.word	0x080002bb
 8000154:	080002bb 	.word	0x080002bb
 8000158:	080002bb 	.word	0x080002bb
 800015c:	080002bb 	.word	0x080002bb
 8000160:	080002bb 	.word	0x080002bb
 8000164:	080002bb 	.word	0x080002bb
 8000168:	080002bb 	.word	0x080002bb
 800016c:	080002bb 	.word	0x080002bb
 8000170:	080002bb 	.word	0x080002bb
 8000174:	080002bb 	.word	0x080002bb
 8000178:	080002bb 	.word	0x080002bb
 800017c:	080002bb 	.word	0x080002bb
 8000180:	080002bb 	.word	0x080002bb
 8000184:	080002bb 	.word	0x080002bb
 8000188:	080002bb 	.word	0x080002bb
 800018c:	080002bb 	.word	0x080002bb
 8000190:	080002bb 	.word	0x080002bb
 8000194:	080002bb 	.word	0x080002bb
 8000198:	080002bb 	.word	0x080002bb
 800019c:	080002bb 	.word	0x080002bb
 80001a0:	080002bb 	.word	0x080002bb
 80001a4:	080002bb 	.word	0x080002bb
 80001a8:	080002bb 	.word	0x080002bb
 80001ac:	080002bb 	.word	0x080002bb
 80001b0:	080002bb 	.word	0x080002bb
 80001b4:	080002bb 	.word	0x080002bb
 80001b8:	080002bb 	.word	0x080002bb
 80001bc:	080002bb 	.word	0x080002bb
 80001c0:	08001e41 	.word	0x08001e41
 80001c4:	08001f01 	.word	0x08001f01
 80001c8:	08001f21 	.word	0x08001f21
 80001cc:	08001f41 	.word	0x08001f41
 80001d0:	080002bb 	.word	0x080002bb
 80001d4:	080002bb 	.word	0x080002bb
 80001d8:	080002bb 	.word	0x080002bb
 80001dc:	080002bb 	.word	0x080002bb

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4826      	ldr	r0, [pc, #152]	@ (800027c <endfiniloop+0x6>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4825      	ldr	r0, [pc, #148]	@ (8000280 <endfiniloop+0xa>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80001ee:	4825      	ldr	r0, [pc, #148]	@ (8000284 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 80001f0:	4925      	ldr	r1, [pc, #148]	@ (8000288 <endfiniloop+0x12>)
                str     r0, [r1]
 80001f2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001f4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001f6:	f380 8814 	msr	CONTROL, r0
                isb
 80001fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001fe:	f000 f87f 	bl	8000300 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000202:	f002 faed 	bl	80027e0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000206:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800020a:	4920      	ldr	r1, [pc, #128]	@ (800028c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800020c:	4a1b      	ldr	r2, [pc, #108]	@ (800027c <endfiniloop+0x6>)

0800020e <msloop>:
msloop:
                cmp     r1, r2
 800020e:	4291      	cmp	r1, r2
                itt     lo
 8000210:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000212:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000216:	e7fa      	bcc.n	800020e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000218:	491d      	ldr	r1, [pc, #116]	@ (8000290 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800021a:	4a19      	ldr	r2, [pc, #100]	@ (8000280 <endfiniloop+0xa>)

0800021c <psloop>:
psloop:
                cmp     r1, r2
 800021c:	4291      	cmp	r1, r2
                itt     lo
 800021e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000220:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000224:	e7fa      	bcc.n	800021c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000226:	491b      	ldr	r1, [pc, #108]	@ (8000294 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000228:	4a1b      	ldr	r2, [pc, #108]	@ (8000298 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800022a:	4b1c      	ldr	r3, [pc, #112]	@ (800029c <endfiniloop+0x26>)

0800022c <dloop>:
dloop:
                cmp     r2, r3
 800022c:	429a      	cmp	r2, r3
                ittt    lo
 800022e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000230:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000234:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000238:	e7f8      	bcc.n	800022c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800023a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800023c:	4918      	ldr	r1, [pc, #96]	@ (80002a0 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800023e:	4a19      	ldr	r2, [pc, #100]	@ (80002a4 <endfiniloop+0x2e>)

08000240 <bloop>:
bloop:
                cmp     r1, r2
 8000240:	4291      	cmp	r1, r2
                itt     lo
 8000242:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000244:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000248:	e7fa      	bcc.n	8000240 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800024a:	f000 f871 	bl	8000330 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800024e:	f000 f85f 	bl	8000310 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000252:	4c15      	ldr	r4, [pc, #84]	@ (80002a8 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000254:	4d15      	ldr	r5, [pc, #84]	@ (80002ac <endfiniloop+0x36>)

08000256 <initloop>:
initloop:
                cmp     r4, r5
 8000256:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000258:	da03      	bge.n	8000262 <endinitloop>
                ldr     r1, [r4], #4
 800025a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800025e:	4788      	blx	r1
                b       initloop
 8000260:	e7f9      	b.n	8000256 <initloop>

08000262 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000262:	f004 ff85 	bl	8005170 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000266:	4c12      	ldr	r4, [pc, #72]	@ (80002b0 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000268:	4d12      	ldr	r5, [pc, #72]	@ (80002b4 <endfiniloop+0x3e>)

0800026a <finiloop>:
finiloop:
                cmp     r4, r5
 800026a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800026c:	da03      	bge.n	8000276 <endfiniloop>
                ldr     r1, [r4], #4
 800026e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000272:	4788      	blx	r1
                b       finiloop
 8000274:	e7f9      	b.n	800026a <finiloop>

08000276 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000276:	f000 b853 	b.w	8000320 <__default_exit>
 800027a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800027c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000280:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000284:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000288:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800028c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000290:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000294:	080058e8 	.word	0x080058e8
                ldr     r2, =__data_base__
 8000298:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800029c:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 80002a0:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 80002a4:	20000e38 	.word	0x20000e38
                ldr     r4, =__init_array_base__
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002b0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002b4:	080001e0 	.word	0x080001e0

080002b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002b8:	e792      	b.n	80001e0 <_crt0_entry>

080002ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ba:	f000 f800 	bl	80002be <_unhandled_exception>

080002be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002be:	e7fe      	b.n	80002be <_unhandled_exception>

080002c0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002c4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002c8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ca:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002d0 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002d0:	f002 fbde 	bl	8002a90 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002d4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002d6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002da:	4628      	mov	r0, r5
                blx     r4
 80002dc:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002de:	2000      	movs	r0, #0
                bl      chThdExit
 80002e0:	f003 ff06 	bl	80040f0 <chThdExit>

080002e4 <.zombies>:
.zombies:       b       .zombies
 80002e4:	e7fe      	b.n	80002e4 <.zombies>

080002e6 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 80002e6:	f002 fbab 	bl	8002a40 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 80002ea:	f003 fb49 	bl	8003980 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002ee:	f002 fbcf 	bl	8002a90 <__dbg_check_unlock>

080002f2 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002f2:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002f4:	e7fe      	b.n	80002f4 <__port_exit_from_isr+0x2>
	...

08000300 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000300:	bf00      	nop
 8000302:	4770      	bx	lr
	...

08000310 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000310:	bf00      	nop
 8000312:	4770      	bx	lr
	...

08000320 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
     asm volatile ("nop");
 8000320:	bf00      	nop
 8000322:	e7fd      	b.n	8000320 <__default_exit>
	...

08000330 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000330:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000332:	4b17      	ldr	r3, [pc, #92]	@ (8000390 <__init_ram_areas+0x60>)
 8000334:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000336:	9b03      	ldr	r3, [sp, #12]
 8000338:	681b      	ldr	r3, [r3, #0]
 800033a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800033c:	9b03      	ldr	r3, [sp, #12]
 800033e:	685b      	ldr	r3, [r3, #4]
 8000340:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000342:	e009      	b.n	8000358 <__init_ram_areas+0x28>
      *p = *tp;
 8000344:	9b02      	ldr	r3, [sp, #8]
 8000346:	681a      	ldr	r2, [r3, #0]
 8000348:	9b01      	ldr	r3, [sp, #4]
 800034a:	601a      	str	r2, [r3, #0]
      p++;
 800034c:	9b01      	ldr	r3, [sp, #4]
 800034e:	3304      	adds	r3, #4
 8000350:	9301      	str	r3, [sp, #4]
      tp++;
 8000352:	9b02      	ldr	r3, [sp, #8]
 8000354:	3304      	adds	r3, #4
 8000356:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8000358:	9b03      	ldr	r3, [sp, #12]
 800035a:	689b      	ldr	r3, [r3, #8]
 800035c:	9a01      	ldr	r2, [sp, #4]
 800035e:	429a      	cmp	r2, r3
 8000360:	d3f0      	bcc.n	8000344 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000362:	e005      	b.n	8000370 <__init_ram_areas+0x40>
      *p = 0;
 8000364:	9b01      	ldr	r3, [sp, #4]
 8000366:	2200      	movs	r2, #0
 8000368:	601a      	str	r2, [r3, #0]
      p++;
 800036a:	9b01      	ldr	r3, [sp, #4]
 800036c:	3304      	adds	r3, #4
 800036e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8000370:	9b03      	ldr	r3, [sp, #12]
 8000372:	68db      	ldr	r3, [r3, #12]
 8000374:	9a01      	ldr	r2, [sp, #4]
 8000376:	429a      	cmp	r2, r3
 8000378:	d3f4      	bcc.n	8000364 <__init_ram_areas+0x34>
    }
    rap++;
 800037a:	9b03      	ldr	r3, [sp, #12]
 800037c:	3310      	adds	r3, #16
 800037e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000380:	9b03      	ldr	r3, [sp, #12]
 8000382:	4a04      	ldr	r2, [pc, #16]	@ (8000394 <__init_ram_areas+0x64>)
 8000384:	4293      	cmp	r3, r2
 8000386:	d3d6      	bcc.n	8000336 <__init_ram_areas+0x6>
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8000388:	bf00      	nop
 800038a:	bf00      	nop
 800038c:	b004      	add	sp, #16
 800038e:	4770      	bx	lr
 8000390:	08005220 	.word	0x08005220
 8000394:	080052a0 	.word	0x080052a0
	...

080003a0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 80003a0:	bf00      	nop
 80003a2:	4770      	bx	lr
	...

080003b0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80003b0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 80003b2:	f7ff fff5 	bl	80003a0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 80003b6:	f000 ff0b 	bl	80011d0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 80003ba:	f001 ff39 	bl	8002230 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 80003be:	f000 f927 	bl	8000610 <adcInit>
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 80003c2:	f000 faed 	bl	80009a0 <gptInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 80003c6:	f002 fa13 	bl	80027f0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80003ca:	f000 f851 	bl	8000470 <stInit>
#endif
}
 80003ce:	bf00      	nop
 80003d0:	bd08      	pop	{r3, pc}
 80003d2:	bf00      	nop
	...

080003e0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80003e0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003e4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
}
 80003e6:	4618      	mov	r0, r3
 80003e8:	4770      	bx	lr
 80003ea:	bf00      	nop
 80003ec:	0000      	movs	r0, r0
	...

080003f0 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 80003f0:	b082      	sub	sp, #8
 80003f2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003f4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80003f8:	9b01      	ldr	r3, [sp, #4]
 80003fa:	6353      	str	r3, [r2, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 80003fc:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000400:	2200      	movs	r2, #0
 8000402:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000404:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000408:	2202      	movs	r2, #2
 800040a:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 800040c:	bf00      	nop
 800040e:	b002      	add	sp, #8
 8000410:	4770      	bx	lr
 8000412:	bf00      	nop
	...

08000420 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8000420:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000424:	2200      	movs	r2, #0
 8000426:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 8000428:	bf00      	nop
 800042a:	4770      	bx	lr
 800042c:	0000      	movs	r0, r0
	...

08000430 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 8000430:	b082      	sub	sp, #8
 8000432:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000434:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000438:	9b01      	ldr	r3, [sp, #4]
 800043a:	6353      	str	r3, [r2, #52]	@ 0x34
}
 800043c:	bf00      	nop
 800043e:	b002      	add	sp, #8
 8000440:	4770      	bx	lr
 8000442:	bf00      	nop
	...

08000450 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000450:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000454:	68db      	ldr	r3, [r3, #12]
 8000456:	f003 0302 	and.w	r3, r3, #2
 800045a:	2b00      	cmp	r3, #0
 800045c:	bf14      	ite	ne
 800045e:	2301      	movne	r3, #1
 8000460:	2300      	moveq	r3, #0
 8000462:	b2db      	uxtb	r3, r3
}
 8000464:	4618      	mov	r0, r3
 8000466:	4770      	bx	lr
	...

08000470 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000470:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 8000472:	f001 ffd5 	bl	8002420 <st_lld_init>
}
 8000476:	bf00      	nop
 8000478:	bd08      	pop	{r3, pc}
 800047a:	bf00      	nop
 800047c:	0000      	movs	r0, r0
	...

08000480 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 8000480:	b508      	push	{r3, lr}

  return st_lld_get_counter();
 8000482:	f7ff ffad 	bl	80003e0 <st_lld_get_counter>
 8000486:	4603      	mov	r3, r0
}
 8000488:	4618      	mov	r0, r3
 800048a:	bd08      	pop	{r3, pc}
 800048c:	0000      	movs	r0, r0
	...

08000490 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000490:	b500      	push	{lr}
 8000492:	b083      	sub	sp, #12
 8000494:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000496:	f000 f833 	bl	8000500 <stIsAlarmActive>
 800049a:	4603      	mov	r3, r0
 800049c:	2b00      	cmp	r3, #0
 800049e:	d002      	beq.n	80004a6 <stStartAlarm+0x16>
 80004a0:	4804      	ldr	r0, [pc, #16]	@ (80004b4 <stStartAlarm+0x24>)
 80004a2:	f002 fa45 	bl	8002930 <chSysHalt>

  st_lld_start_alarm(abstime);
 80004a6:	9801      	ldr	r0, [sp, #4]
 80004a8:	f7ff ffa2 	bl	80003f0 <st_lld_start_alarm>
}
 80004ac:	bf00      	nop
 80004ae:	b003      	add	sp, #12
 80004b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80004b4:	080052a0 	.word	0x080052a0
	...

080004c0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 80004c0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 80004c2:	f7ff ffad 	bl	8000420 <st_lld_stop_alarm>
}
 80004c6:	bf00      	nop
 80004c8:	bd08      	pop	{r3, pc}
 80004ca:	bf00      	nop
 80004cc:	0000      	movs	r0, r0
	...

080004d0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80004d0:	b500      	push	{lr}
 80004d2:	b083      	sub	sp, #12
 80004d4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80004d6:	f000 f813 	bl	8000500 <stIsAlarmActive>
 80004da:	4603      	mov	r3, r0
 80004dc:	f083 0301 	eor.w	r3, r3, #1
 80004e0:	b2db      	uxtb	r3, r3
 80004e2:	2b00      	cmp	r3, #0
 80004e4:	d002      	beq.n	80004ec <stSetAlarm+0x1c>
 80004e6:	4805      	ldr	r0, [pc, #20]	@ (80004fc <stSetAlarm+0x2c>)
 80004e8:	f002 fa22 	bl	8002930 <chSysHalt>

  st_lld_set_alarm(abstime);
 80004ec:	9801      	ldr	r0, [sp, #4]
 80004ee:	f7ff ff9f 	bl	8000430 <st_lld_set_alarm>
}
 80004f2:	bf00      	nop
 80004f4:	b003      	add	sp, #12
 80004f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80004fa:	bf00      	nop
 80004fc:	080052b0 	.word	0x080052b0

08000500 <stIsAlarmActive>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @api
 */
bool stIsAlarmActive(void) {
 8000500:	b508      	push	{r3, lr}

  return st_lld_is_alarm_active();
 8000502:	f7ff ffa5 	bl	8000450 <st_lld_is_alarm_active>
 8000506:	4603      	mov	r3, r0
}
 8000508:	4618      	mov	r0, r3
 800050a:	bd08      	pop	{r3, pc}
 800050c:	0000      	movs	r0, r0
	...

08000510 <chSysLock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 8000510:	b500      	push	{lr}
 8000512:	b083      	sub	sp, #12
 8000514:	2330      	movs	r3, #48	@ 0x30
 8000516:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000518:	9b01      	ldr	r3, [sp, #4]
 800051a:	f383 8811 	msr	BASEPRI, r3
}
 800051e:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000520:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 8000522:	f002 fa8d 	bl	8002a40 <__dbg_check_lock>
}
 8000526:	bf00      	nop
 8000528:	b003      	add	sp, #12
 800052a:	f85d fb04 	ldr.w	pc, [sp], #4
 800052e:	bf00      	nop

08000530 <chSysUnlock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000530:	b500      	push	{lr}
 8000532:	b083      	sub	sp, #12

  __dbg_check_unlock();
 8000534:	f002 faac 	bl	8002a90 <__dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000538:	4b12      	ldr	r3, [pc, #72]	@ (8000584 <chSysUnlock.lto_priv.2+0x54>)
 800053a:	681b      	ldr	r3, [r3, #0]
 800053c:	4a11      	ldr	r2, [pc, #68]	@ (8000584 <chSysUnlock.lto_priv.2+0x54>)
 800053e:	4293      	cmp	r3, r2
 8000540:	bf14      	ite	ne
 8000542:	2301      	movne	r3, #1
 8000544:	2300      	moveq	r3, #0
 8000546:	b2db      	uxtb	r3, r3
 8000548:	2b00      	cmp	r3, #0
 800054a:	d00f      	beq.n	800056c <chSysUnlock.lto_priv.2+0x3c>
 800054c:	4b0d      	ldr	r3, [pc, #52]	@ (8000584 <chSysUnlock.lto_priv.2+0x54>)
 800054e:	68db      	ldr	r3, [r3, #12]
 8000550:	689a      	ldr	r2, [r3, #8]
 8000552:	4b0c      	ldr	r3, [pc, #48]	@ (8000584 <chSysUnlock.lto_priv.2+0x54>)
 8000554:	681b      	ldr	r3, [r3, #0]
 8000556:	689b      	ldr	r3, [r3, #8]
 8000558:	429a      	cmp	r2, r3
 800055a:	bf34      	ite	cc
 800055c:	2301      	movcc	r3, #1
 800055e:	2300      	movcs	r3, #0
 8000560:	b2db      	uxtb	r3, r3
 8000562:	2b00      	cmp	r3, #0
 8000564:	d002      	beq.n	800056c <chSysUnlock.lto_priv.2+0x3c>
 8000566:	4808      	ldr	r0, [pc, #32]	@ (8000588 <chSysUnlock.lto_priv.2+0x58>)
 8000568:	f002 f9e2 	bl	8002930 <chSysHalt>
 800056c:	2300      	movs	r3, #0
 800056e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000570:	9b01      	ldr	r3, [sp, #4]
 8000572:	f383 8811 	msr	BASEPRI, r3
}
 8000576:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000578:	bf00      	nop
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 800057a:	bf00      	nop
 800057c:	b003      	add	sp, #12
 800057e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000582:	bf00      	nop
 8000584:	20000988 	.word	0x20000988
 8000588:	080052c8 	.word	0x080052c8
 800058c:	00000000 	.word	0x00000000

08000590 <osalSysLock.lto_priv.2>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000590:	b508      	push	{r3, lr}

  chSysLock();
 8000592:	f7ff ffbd 	bl	8000510 <chSysLock.lto_priv.2>
}
 8000596:	bf00      	nop
 8000598:	bd08      	pop	{r3, pc}
 800059a:	bf00      	nop
 800059c:	0000      	movs	r0, r0
	...

080005a0 <osalSysUnlock.lto_priv.2>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80005a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80005a2:	f7ff ffc5 	bl	8000530 <chSysUnlock.lto_priv.2>
}
 80005a6:	bf00      	nop
 80005a8:	bd08      	pop	{r3, pc}
 80005aa:	bf00      	nop
 80005ac:	0000      	movs	r0, r0
	...

080005b0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80005b0:	b500      	push	{lr}
 80005b2:	b083      	sub	sp, #12
 80005b4:	9001      	str	r0, [sp, #4]

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 80005b6:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 80005ba:	9801      	ldr	r0, [sp, #4]
 80005bc:	f003 fe00 	bl	80041c0 <chThdSuspendTimeoutS>
 80005c0:	4603      	mov	r3, r0
}
 80005c2:	4618      	mov	r0, r3
 80005c4:	b003      	add	sp, #12
 80005c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80005ca:	bf00      	nop
 80005cc:	0000      	movs	r0, r0
	...

080005d0 <osalThreadResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 80005d0:	b500      	push	{lr}
 80005d2:	b083      	sub	sp, #12
 80005d4:	9001      	str	r0, [sp, #4]
 80005d6:	9100      	str	r1, [sp, #0]

  chThdResumeS(trp, msg);
 80005d8:	9900      	ldr	r1, [sp, #0]
 80005da:	9801      	ldr	r0, [sp, #4]
 80005dc:	f003 fe48 	bl	8004270 <chThdResumeS>
}
 80005e0:	bf00      	nop
 80005e2:	b003      	add	sp, #12
 80005e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080005f0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80005f0:	b500      	push	{lr}
 80005f2:	b083      	sub	sp, #12
 80005f4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80005f6:	9801      	ldr	r0, [sp, #4]
 80005f8:	f004 f86a 	bl	80046d0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80005fc:	bf00      	nop
 80005fe:	b003      	add	sp, #12
 8000600:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000610 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 8000610:	b508      	push	{r3, lr}

  adc_lld_init();
 8000612:	f001 f8e5 	bl	80017e0 <adc_lld_init>
}
 8000616:	bf00      	nop
 8000618:	bd08      	pop	{r3, pc}
 800061a:	bf00      	nop
 800061c:	0000      	movs	r0, r0
	...

08000620 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 8000620:	b500      	push	{lr}
 8000622:	b083      	sub	sp, #12
 8000624:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 8000626:	9b01      	ldr	r3, [sp, #4]
 8000628:	2201      	movs	r2, #1
 800062a:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 800062c:	9b01      	ldr	r3, [sp, #4]
 800062e:	2200      	movs	r2, #0
 8000630:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 8000632:	9b01      	ldr	r3, [sp, #4]
 8000634:	2200      	movs	r2, #0
 8000636:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 8000638:	9b01      	ldr	r3, [sp, #4]
 800063a:	2200      	movs	r2, #0
 800063c:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 800063e:	9b01      	ldr	r3, [sp, #4]
 8000640:	2200      	movs	r2, #0
 8000642:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8000644:	9b01      	ldr	r3, [sp, #4]
 8000646:	2200      	movs	r2, #0
 8000648:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 800064a:	9b01      	ldr	r3, [sp, #4]
 800064c:	3318      	adds	r3, #24
 800064e:	4618      	mov	r0, r3
 8000650:	f7ff ffce 	bl	80005f0 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 8000654:	bf00      	nop
 8000656:	b003      	add	sp, #12
 8000658:	f85d fb04 	ldr.w	pc, [sp], #4
 800065c:	0000      	movs	r0, r0
	...

08000660 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8000660:	b500      	push	{lr}
 8000662:	b085      	sub	sp, #20
 8000664:	9001      	str	r0, [sp, #4]
 8000666:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(adcp != NULL);
 8000668:	9b01      	ldr	r3, [sp, #4]
 800066a:	2b00      	cmp	r3, #0
 800066c:	bf0c      	ite	eq
 800066e:	2301      	moveq	r3, #1
 8000670:	2300      	movne	r3, #0
 8000672:	b2db      	uxtb	r3, r3
 8000674:	2b00      	cmp	r3, #0
 8000676:	d002      	beq.n	800067e <adcStart+0x1e>
 8000678:	4819      	ldr	r0, [pc, #100]	@ (80006e0 <adcStart+0x80>)
 800067a:	f002 f959 	bl	8002930 <chSysHalt>

  osalSysLock();
 800067e:	f7ff ff87 	bl	8000590 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 8000682:	9b01      	ldr	r3, [sp, #4]
 8000684:	781b      	ldrb	r3, [r3, #0]
 8000686:	2b01      	cmp	r3, #1
 8000688:	bf14      	ite	ne
 800068a:	2301      	movne	r3, #1
 800068c:	2300      	moveq	r3, #0
 800068e:	b2db      	uxtb	r3, r3
 8000690:	2b00      	cmp	r3, #0
 8000692:	d00b      	beq.n	80006ac <adcStart+0x4c>
 8000694:	9b01      	ldr	r3, [sp, #4]
 8000696:	781b      	ldrb	r3, [r3, #0]
 8000698:	2b02      	cmp	r3, #2
 800069a:	bf14      	ite	ne
 800069c:	2301      	movne	r3, #1
 800069e:	2300      	moveq	r3, #0
 80006a0:	b2db      	uxtb	r3, r3
 80006a2:	2b00      	cmp	r3, #0
 80006a4:	d002      	beq.n	80006ac <adcStart+0x4c>
 80006a6:	480e      	ldr	r0, [pc, #56]	@ (80006e0 <adcStart+0x80>)
 80006a8:	f002 f942 	bl	8002930 <chSysHalt>
                "invalid state");
  adcp->config = config;
 80006ac:	9b01      	ldr	r3, [sp, #4]
 80006ae:	9a00      	ldr	r2, [sp, #0]
 80006b0:	605a      	str	r2, [r3, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
#else
  adc_lld_start(adcp);
 80006b2:	9801      	ldr	r0, [sp, #4]
 80006b4:	f001 f95c 	bl	8001970 <adc_lld_start>
  msg = HAL_RET_SUCCESS;
 80006b8:	2300      	movs	r3, #0
 80006ba:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 80006bc:	9b03      	ldr	r3, [sp, #12]
 80006be:	2b00      	cmp	r3, #0
 80006c0:	d103      	bne.n	80006ca <adcStart+0x6a>
    adcp->state = ADC_READY;
 80006c2:	9b01      	ldr	r3, [sp, #4]
 80006c4:	2202      	movs	r2, #2
 80006c6:	701a      	strb	r2, [r3, #0]
 80006c8:	e002      	b.n	80006d0 <adcStart+0x70>
  }
  else {
    adcp->state = ADC_STOP;
 80006ca:	9b01      	ldr	r3, [sp, #4]
 80006cc:	2201      	movs	r2, #1
 80006ce:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 80006d0:	f7ff ff66 	bl	80005a0 <osalSysUnlock.lto_priv.2>

  return msg;
 80006d4:	9b03      	ldr	r3, [sp, #12]
}
 80006d6:	4618      	mov	r0, r3
 80006d8:	b005      	add	sp, #20
 80006da:	f85d fb04 	ldr.w	pc, [sp], #4
 80006de:	bf00      	nop
 80006e0:	080052bc 	.word	0x080052bc
	...

080006f0 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 80006f0:	b500      	push	{lr}
 80006f2:	b085      	sub	sp, #20
 80006f4:	9003      	str	r0, [sp, #12]
 80006f6:	9102      	str	r1, [sp, #8]
 80006f8:	9201      	str	r2, [sp, #4]
 80006fa:	9300      	str	r3, [sp, #0]

  osalSysLock();
 80006fc:	f7ff ff48 	bl	8000590 <osalSysLock.lto_priv.2>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000700:	9b00      	ldr	r3, [sp, #0]
 8000702:	9a01      	ldr	r2, [sp, #4]
 8000704:	9902      	ldr	r1, [sp, #8]
 8000706:	9803      	ldr	r0, [sp, #12]
 8000708:	f000 f80a 	bl	8000720 <adcStartConversionI>
  osalSysUnlock();
 800070c:	f7ff ff48 	bl	80005a0 <osalSysUnlock.lto_priv.2>
}
 8000710:	bf00      	nop
 8000712:	b005      	add	sp, #20
 8000714:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000720 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
 8000720:	b500      	push	{lr}
 8000722:	b085      	sub	sp, #20
 8000724:	9003      	str	r0, [sp, #12]
 8000726:	9102      	str	r1, [sp, #8]
 8000728:	9201      	str	r2, [sp, #4]
 800072a:	9300      	str	r3, [sp, #0]

  osalDbgCheckClassI();
 800072c:	f002 faa0 	bl	8002c70 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
 8000730:	9b03      	ldr	r3, [sp, #12]
 8000732:	2b00      	cmp	r3, #0
 8000734:	bf0c      	ite	eq
 8000736:	2301      	moveq	r3, #1
 8000738:	2300      	movne	r3, #0
 800073a:	b2db      	uxtb	r3, r3
 800073c:	2b00      	cmp	r3, #0
 800073e:	d107      	bne.n	8000750 <adcStartConversionI+0x30>
 8000740:	9b02      	ldr	r3, [sp, #8]
 8000742:	2b00      	cmp	r3, #0
 8000744:	bf0c      	ite	eq
 8000746:	2301      	moveq	r3, #1
 8000748:	2300      	movne	r3, #0
 800074a:	b2db      	uxtb	r3, r3
 800074c:	2b00      	cmp	r3, #0
 800074e:	d001      	beq.n	8000754 <adcStartConversionI+0x34>
 8000750:	2301      	movs	r3, #1
 8000752:	e000      	b.n	8000756 <adcStartConversionI+0x36>
 8000754:	2300      	movs	r3, #0
 8000756:	2b00      	cmp	r3, #0
 8000758:	d107      	bne.n	800076a <adcStartConversionI+0x4a>
 800075a:	9b01      	ldr	r3, [sp, #4]
 800075c:	2b00      	cmp	r3, #0
 800075e:	bf0c      	ite	eq
 8000760:	2301      	moveq	r3, #1
 8000762:	2300      	movne	r3, #0
 8000764:	b2db      	uxtb	r3, r3
 8000766:	2b00      	cmp	r3, #0
 8000768:	d001      	beq.n	800076e <adcStartConversionI+0x4e>
 800076a:	2301      	movs	r3, #1
 800076c:	e000      	b.n	8000770 <adcStartConversionI+0x50>
 800076e:	2300      	movs	r3, #0
 8000770:	2b00      	cmp	r3, #0
 8000772:	d107      	bne.n	8000784 <adcStartConversionI+0x64>
 8000774:	9b00      	ldr	r3, [sp, #0]
 8000776:	2b00      	cmp	r3, #0
 8000778:	bf0c      	ite	eq
 800077a:	2301      	moveq	r3, #1
 800077c:	2300      	movne	r3, #0
 800077e:	b2db      	uxtb	r3, r3
 8000780:	2b00      	cmp	r3, #0
 8000782:	d001      	beq.n	8000788 <adcStartConversionI+0x68>
 8000784:	2301      	movs	r3, #1
 8000786:	e000      	b.n	800078a <adcStartConversionI+0x6a>
 8000788:	2300      	movs	r3, #0
 800078a:	2b00      	cmp	r3, #0
 800078c:	d111      	bne.n	80007b2 <adcStartConversionI+0x92>
 800078e:	9b00      	ldr	r3, [sp, #0]
 8000790:	2b01      	cmp	r3, #1
 8000792:	bf14      	ite	ne
 8000794:	2301      	movne	r3, #1
 8000796:	2300      	moveq	r3, #0
 8000798:	b2db      	uxtb	r3, r3
 800079a:	2b00      	cmp	r3, #0
 800079c:	d006      	beq.n	80007ac <adcStartConversionI+0x8c>
 800079e:	9b00      	ldr	r3, [sp, #0]
 80007a0:	f003 0301 	and.w	r3, r3, #1
 80007a4:	2b00      	cmp	r3, #0
 80007a6:	d001      	beq.n	80007ac <adcStartConversionI+0x8c>
 80007a8:	2301      	movs	r3, #1
 80007aa:	e000      	b.n	80007ae <adcStartConversionI+0x8e>
 80007ac:	2300      	movs	r3, #0
 80007ae:	2b00      	cmp	r3, #0
 80007b0:	d002      	beq.n	80007b8 <adcStartConversionI+0x98>
 80007b2:	4815      	ldr	r0, [pc, #84]	@ (8000808 <adcStartConversionI+0xe8>)
 80007b4:	f002 f8bc 	bl	8002930 <chSysHalt>
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
 80007b8:	9b03      	ldr	r3, [sp, #12]
 80007ba:	781b      	ldrb	r3, [r3, #0]
 80007bc:	2b02      	cmp	r3, #2
 80007be:	bf14      	ite	ne
 80007c0:	2301      	movne	r3, #1
 80007c2:	2300      	moveq	r3, #0
 80007c4:	b2db      	uxtb	r3, r3
 80007c6:	2b00      	cmp	r3, #0
 80007c8:	d00b      	beq.n	80007e2 <adcStartConversionI+0xc2>
 80007ca:	9b03      	ldr	r3, [sp, #12]
 80007cc:	781b      	ldrb	r3, [r3, #0]
 80007ce:	2b05      	cmp	r3, #5
 80007d0:	bf14      	ite	ne
 80007d2:	2301      	movne	r3, #1
 80007d4:	2300      	moveq	r3, #0
 80007d6:	b2db      	uxtb	r3, r3
 80007d8:	2b00      	cmp	r3, #0
 80007da:	d002      	beq.n	80007e2 <adcStartConversionI+0xc2>
 80007dc:	480a      	ldr	r0, [pc, #40]	@ (8000808 <adcStartConversionI+0xe8>)
 80007de:	f002 f8a7 	bl	8002930 <chSysHalt>
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 80007e2:	9b03      	ldr	r3, [sp, #12]
 80007e4:	9a01      	ldr	r2, [sp, #4]
 80007e6:	609a      	str	r2, [r3, #8]
  adcp->depth    = depth;
 80007e8:	9b03      	ldr	r3, [sp, #12]
 80007ea:	9a00      	ldr	r2, [sp, #0]
 80007ec:	60da      	str	r2, [r3, #12]
  adcp->grpp     = grpp;
 80007ee:	9b03      	ldr	r3, [sp, #12]
 80007f0:	9a02      	ldr	r2, [sp, #8]
 80007f2:	611a      	str	r2, [r3, #16]
  adcp->state    = ADC_ACTIVE;
 80007f4:	9b03      	ldr	r3, [sp, #12]
 80007f6:	2203      	movs	r2, #3
 80007f8:	701a      	strb	r2, [r3, #0]
  adc_lld_start_conversion(adcp);
 80007fa:	9803      	ldr	r0, [sp, #12]
 80007fc:	f001 f9c8 	bl	8001b90 <adc_lld_start_conversion>
}
 8000800:	bf00      	nop
 8000802:	b005      	add	sp, #20
 8000804:	f85d fb04 	ldr.w	pc, [sp], #4
 8000808:	080052d4 	.word	0x080052d4
 800080c:	00000000 	.word	0x00000000

08000810 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
 8000810:	b500      	push	{lr}
 8000812:	b083      	sub	sp, #12
 8000814:	9001      	str	r0, [sp, #4]

  osalDbgCheck(adcp != NULL);
 8000816:	9b01      	ldr	r3, [sp, #4]
 8000818:	2b00      	cmp	r3, #0
 800081a:	bf0c      	ite	eq
 800081c:	2301      	moveq	r3, #1
 800081e:	2300      	movne	r3, #0
 8000820:	b2db      	uxtb	r3, r3
 8000822:	2b00      	cmp	r3, #0
 8000824:	d002      	beq.n	800082c <adcStopConversion+0x1c>
 8000826:	481a      	ldr	r0, [pc, #104]	@ (8000890 <adcStopConversion+0x80>)
 8000828:	f002 f882 	bl	8002930 <chSysHalt>

  osalSysLock();
 800082c:	f7ff feb0 	bl	8000590 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_READY) || (adcp->state == ADC_ACTIVE),
 8000830:	9b01      	ldr	r3, [sp, #4]
 8000832:	781b      	ldrb	r3, [r3, #0]
 8000834:	2b02      	cmp	r3, #2
 8000836:	bf14      	ite	ne
 8000838:	2301      	movne	r3, #1
 800083a:	2300      	moveq	r3, #0
 800083c:	b2db      	uxtb	r3, r3
 800083e:	2b00      	cmp	r3, #0
 8000840:	d00b      	beq.n	800085a <adcStopConversion+0x4a>
 8000842:	9b01      	ldr	r3, [sp, #4]
 8000844:	781b      	ldrb	r3, [r3, #0]
 8000846:	2b03      	cmp	r3, #3
 8000848:	bf14      	ite	ne
 800084a:	2301      	movne	r3, #1
 800084c:	2300      	moveq	r3, #0
 800084e:	b2db      	uxtb	r3, r3
 8000850:	2b00      	cmp	r3, #0
 8000852:	d002      	beq.n	800085a <adcStopConversion+0x4a>
 8000854:	480e      	ldr	r0, [pc, #56]	@ (8000890 <adcStopConversion+0x80>)
 8000856:	f002 f86b 	bl	8002930 <chSysHalt>
                "invalid state");
  if (adcp->state != ADC_READY) {
 800085a:	9b01      	ldr	r3, [sp, #4]
 800085c:	781b      	ldrb	r3, [r3, #0]
 800085e:	2b02      	cmp	r3, #2
 8000860:	d00f      	beq.n	8000882 <adcStopConversion+0x72>
    adc_lld_stop_conversion(adcp);
 8000862:	9801      	ldr	r0, [sp, #4]
 8000864:	f001 fa3c 	bl	8001ce0 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
 8000868:	9b01      	ldr	r3, [sp, #4]
 800086a:	2200      	movs	r2, #0
 800086c:	611a      	str	r2, [r3, #16]
    adcp->state = ADC_READY;
 800086e:	9b01      	ldr	r3, [sp, #4]
 8000870:	2202      	movs	r2, #2
 8000872:	701a      	strb	r2, [r3, #0]
    _adc_reset_s(adcp);
 8000874:	9b01      	ldr	r3, [sp, #4]
 8000876:	3314      	adds	r3, #20
 8000878:	f06f 0101 	mvn.w	r1, #1
 800087c:	4618      	mov	r0, r3
 800087e:	f7ff fea7 	bl	80005d0 <osalThreadResumeS>
  }
  osalSysUnlock();
 8000882:	f7ff fe8d 	bl	80005a0 <osalSysUnlock.lto_priv.2>
}
 8000886:	bf00      	nop
 8000888:	b003      	add	sp, #12
 800088a:	f85d fb04 	ldr.w	pc, [sp], #4
 800088e:	bf00      	nop
 8000890:	080052e8 	.word	0x080052e8
	...

080008a0 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 80008a0:	b500      	push	{lr}
 80008a2:	b087      	sub	sp, #28
 80008a4:	9003      	str	r0, [sp, #12]
 80008a6:	9102      	str	r1, [sp, #8]
 80008a8:	9201      	str	r2, [sp, #4]
 80008aa:	9300      	str	r3, [sp, #0]
  msg_t msg;

  osalSysLock();
 80008ac:	f7ff fe70 	bl	8000590 <osalSysLock.lto_priv.2>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
 80008b0:	9b03      	ldr	r3, [sp, #12]
 80008b2:	695b      	ldr	r3, [r3, #20]
 80008b4:	2b00      	cmp	r3, #0
 80008b6:	bf14      	ite	ne
 80008b8:	2301      	movne	r3, #1
 80008ba:	2300      	moveq	r3, #0
 80008bc:	b2db      	uxtb	r3, r3
 80008be:	2b00      	cmp	r3, #0
 80008c0:	d002      	beq.n	80008c8 <adcConvert+0x28>
 80008c2:	480b      	ldr	r0, [pc, #44]	@ (80008f0 <adcConvert+0x50>)
 80008c4:	f002 f834 	bl	8002930 <chSysHalt>
  adcStartConversionI(adcp, grpp, samples, depth);
 80008c8:	9b00      	ldr	r3, [sp, #0]
 80008ca:	9a01      	ldr	r2, [sp, #4]
 80008cc:	9902      	ldr	r1, [sp, #8]
 80008ce:	9803      	ldr	r0, [sp, #12]
 80008d0:	f7ff ff26 	bl	8000720 <adcStartConversionI>
  msg = osalThreadSuspendS(&adcp->thread);
 80008d4:	9b03      	ldr	r3, [sp, #12]
 80008d6:	3314      	adds	r3, #20
 80008d8:	4618      	mov	r0, r3
 80008da:	f7ff fe69 	bl	80005b0 <osalThreadSuspendS>
 80008de:	9005      	str	r0, [sp, #20]
  osalSysUnlock();
 80008e0:	f7ff fe5e 	bl	80005a0 <osalSysUnlock.lto_priv.2>
  return msg;
 80008e4:	9b05      	ldr	r3, [sp, #20]
}
 80008e6:	4618      	mov	r0, r3
 80008e8:	b007      	add	sp, #28
 80008ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80008ee:	bf00      	nop
 80008f0:	080052fc 	.word	0x080052fc
	...

08000900 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
 8000900:	b500      	push	{lr}
 8000902:	b083      	sub	sp, #12
 8000904:	2330      	movs	r3, #48	@ 0x30
 8000906:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000908:	9b01      	ldr	r3, [sp, #4]
 800090a:	f383 8811 	msr	BASEPRI, r3
}
 800090e:	bf00      	nop
}
 8000910:	bf00      	nop
  __dbg_check_lock();
 8000912:	f002 f895 	bl	8002a40 <__dbg_check_lock>
}
 8000916:	bf00      	nop
 8000918:	b003      	add	sp, #12
 800091a:	f85d fb04 	ldr.w	pc, [sp], #4
 800091e:	bf00      	nop

08000920 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
 8000920:	b500      	push	{lr}
 8000922:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8000924:	f002 f8b4 	bl	8002a90 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000928:	4b12      	ldr	r3, [pc, #72]	@ (8000974 <chSysUnlock.lto_priv.3+0x54>)
 800092a:	681b      	ldr	r3, [r3, #0]
 800092c:	4a11      	ldr	r2, [pc, #68]	@ (8000974 <chSysUnlock.lto_priv.3+0x54>)
 800092e:	4293      	cmp	r3, r2
 8000930:	bf14      	ite	ne
 8000932:	2301      	movne	r3, #1
 8000934:	2300      	moveq	r3, #0
 8000936:	b2db      	uxtb	r3, r3
 8000938:	2b00      	cmp	r3, #0
 800093a:	d00f      	beq.n	800095c <chSysUnlock.lto_priv.3+0x3c>
 800093c:	4b0d      	ldr	r3, [pc, #52]	@ (8000974 <chSysUnlock.lto_priv.3+0x54>)
 800093e:	68db      	ldr	r3, [r3, #12]
 8000940:	689a      	ldr	r2, [r3, #8]
 8000942:	4b0c      	ldr	r3, [pc, #48]	@ (8000974 <chSysUnlock.lto_priv.3+0x54>)
 8000944:	681b      	ldr	r3, [r3, #0]
 8000946:	689b      	ldr	r3, [r3, #8]
 8000948:	429a      	cmp	r2, r3
 800094a:	bf34      	ite	cc
 800094c:	2301      	movcc	r3, #1
 800094e:	2300      	movcs	r3, #0
 8000950:	b2db      	uxtb	r3, r3
 8000952:	2b00      	cmp	r3, #0
 8000954:	d002      	beq.n	800095c <chSysUnlock.lto_priv.3+0x3c>
 8000956:	4808      	ldr	r0, [pc, #32]	@ (8000978 <chSysUnlock.lto_priv.3+0x58>)
 8000958:	f001 ffea 	bl	8002930 <chSysHalt>
 800095c:	2300      	movs	r3, #0
 800095e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000960:	9b01      	ldr	r3, [sp, #4]
 8000962:	f383 8811 	msr	BASEPRI, r3
}
 8000966:	bf00      	nop
}
 8000968:	bf00      	nop
}
 800096a:	bf00      	nop
 800096c:	b003      	add	sp, #12
 800096e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000972:	bf00      	nop
 8000974:	20000988 	.word	0x20000988
 8000978:	08005314 	.word	0x08005314
 800097c:	00000000 	.word	0x00000000

08000980 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
 8000980:	b508      	push	{r3, lr}
  chSysLock();
 8000982:	f7ff ffbd 	bl	8000900 <chSysLock.lto_priv.3>
}
 8000986:	bf00      	nop
 8000988:	bd08      	pop	{r3, pc}
 800098a:	bf00      	nop
 800098c:	0000      	movs	r0, r0
	...

08000990 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
 8000990:	b508      	push	{r3, lr}
  chSysUnlock();
 8000992:	f7ff ffc5 	bl	8000920 <chSysUnlock.lto_priv.3>
}
 8000996:	bf00      	nop
 8000998:	bd08      	pop	{r3, pc}
 800099a:	bf00      	nop
 800099c:	0000      	movs	r0, r0
	...

080009a0 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 80009a0:	b508      	push	{r3, lr}

  gpt_lld_init();
 80009a2:	f001 fda5 	bl	80024f0 <gpt_lld_init>
}
 80009a6:	bf00      	nop
 80009a8:	bd08      	pop	{r3, pc}
 80009aa:	bf00      	nop
 80009ac:	0000      	movs	r0, r0
	...

080009b0 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 80009b0:	b082      	sub	sp, #8
 80009b2:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 80009b4:	9b01      	ldr	r3, [sp, #4]
 80009b6:	2201      	movs	r2, #1
 80009b8:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 80009ba:	9b01      	ldr	r3, [sp, #4]
 80009bc:	2200      	movs	r2, #0
 80009be:	605a      	str	r2, [r3, #4]
}
 80009c0:	bf00      	nop
 80009c2:	b002      	add	sp, #8
 80009c4:	4770      	bx	lr
 80009c6:	bf00      	nop
	...

080009d0 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 80009d0:	b500      	push	{lr}
 80009d2:	b085      	sub	sp, #20
 80009d4:	9001      	str	r0, [sp, #4]
 80009d6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 80009d8:	9b01      	ldr	r3, [sp, #4]
 80009da:	2b00      	cmp	r3, #0
 80009dc:	bf0c      	ite	eq
 80009de:	2301      	moveq	r3, #1
 80009e0:	2300      	movne	r3, #0
 80009e2:	b2db      	uxtb	r3, r3
 80009e4:	2b00      	cmp	r3, #0
 80009e6:	d107      	bne.n	80009f8 <gptStart+0x28>
 80009e8:	9b00      	ldr	r3, [sp, #0]
 80009ea:	2b00      	cmp	r3, #0
 80009ec:	bf0c      	ite	eq
 80009ee:	2301      	moveq	r3, #1
 80009f0:	2300      	movne	r3, #0
 80009f2:	b2db      	uxtb	r3, r3
 80009f4:	2b00      	cmp	r3, #0
 80009f6:	d002      	beq.n	80009fe <gptStart+0x2e>
 80009f8:	4819      	ldr	r0, [pc, #100]	@ (8000a60 <gptStart+0x90>)
 80009fa:	f001 ff99 	bl	8002930 <chSysHalt>

  osalSysLock();
 80009fe:	f7ff ffbf 	bl	8000980 <osalSysLock.lto_priv.3>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
 8000a02:	9b01      	ldr	r3, [sp, #4]
 8000a04:	781b      	ldrb	r3, [r3, #0]
 8000a06:	2b01      	cmp	r3, #1
 8000a08:	bf14      	ite	ne
 8000a0a:	2301      	movne	r3, #1
 8000a0c:	2300      	moveq	r3, #0
 8000a0e:	b2db      	uxtb	r3, r3
 8000a10:	2b00      	cmp	r3, #0
 8000a12:	d00b      	beq.n	8000a2c <gptStart+0x5c>
 8000a14:	9b01      	ldr	r3, [sp, #4]
 8000a16:	781b      	ldrb	r3, [r3, #0]
 8000a18:	2b02      	cmp	r3, #2
 8000a1a:	bf14      	ite	ne
 8000a1c:	2301      	movne	r3, #1
 8000a1e:	2300      	moveq	r3, #0
 8000a20:	b2db      	uxtb	r3, r3
 8000a22:	2b00      	cmp	r3, #0
 8000a24:	d002      	beq.n	8000a2c <gptStart+0x5c>
 8000a26:	480e      	ldr	r0, [pc, #56]	@ (8000a60 <gptStart+0x90>)
 8000a28:	f001 ff82 	bl	8002930 <chSysHalt>
              "invalid state");

  gptp->config = config;
 8000a2c:	9b01      	ldr	r3, [sp, #4]
 8000a2e:	9a00      	ldr	r2, [sp, #0]
 8000a30:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 8000a32:	9801      	ldr	r0, [sp, #4]
 8000a34:	f001 fd6c 	bl	8002510 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 8000a38:	2300      	movs	r3, #0
 8000a3a:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 8000a3c:	9b03      	ldr	r3, [sp, #12]
 8000a3e:	2b00      	cmp	r3, #0
 8000a40:	d103      	bne.n	8000a4a <gptStart+0x7a>
    gptp->state = GPT_READY;
 8000a42:	9b01      	ldr	r3, [sp, #4]
 8000a44:	2202      	movs	r2, #2
 8000a46:	701a      	strb	r2, [r3, #0]
 8000a48:	e002      	b.n	8000a50 <gptStart+0x80>
  }
  else {
    gptp->state = GPT_STOP;
 8000a4a:	9b01      	ldr	r3, [sp, #4]
 8000a4c:	2201      	movs	r2, #1
 8000a4e:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000a50:	f7ff ff9e 	bl	8000990 <osalSysUnlock.lto_priv.3>

  return msg;
 8000a54:	9b03      	ldr	r3, [sp, #12]
}
 8000a56:	4618      	mov	r0, r3
 8000a58:	b005      	add	sp, #20
 8000a5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a5e:	bf00      	nop
 8000a60:	08005308 	.word	0x08005308
	...

08000a70 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 8000a70:	b500      	push	{lr}
 8000a72:	b083      	sub	sp, #12
 8000a74:	9001      	str	r0, [sp, #4]
 8000a76:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8000a78:	f7ff ff82 	bl	8000980 <osalSysLock.lto_priv.3>
  gptStartContinuousI(gptp, interval);
 8000a7c:	9900      	ldr	r1, [sp, #0]
 8000a7e:	9801      	ldr	r0, [sp, #4]
 8000a80:	f000 f806 	bl	8000a90 <gptStartContinuousI>
  osalSysUnlock();
 8000a84:	f7ff ff84 	bl	8000990 <osalSysUnlock.lto_priv.3>
}
 8000a88:	bf00      	nop
 8000a8a:	b003      	add	sp, #12
 8000a8c:	f85d fb04 	ldr.w	pc, [sp], #4

08000a90 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 8000a90:	b500      	push	{lr}
 8000a92:	b083      	sub	sp, #12
 8000a94:	9001      	str	r0, [sp, #4]
 8000a96:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8000a98:	f002 f8ea 	bl	8002c70 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000a9c:	9b01      	ldr	r3, [sp, #4]
 8000a9e:	2b00      	cmp	r3, #0
 8000aa0:	bf0c      	ite	eq
 8000aa2:	2301      	moveq	r3, #1
 8000aa4:	2300      	movne	r3, #0
 8000aa6:	b2db      	uxtb	r3, r3
 8000aa8:	2b00      	cmp	r3, #0
 8000aaa:	d002      	beq.n	8000ab2 <gptStartContinuousI+0x22>
 8000aac:	480c      	ldr	r0, [pc, #48]	@ (8000ae0 <gptStartContinuousI+0x50>)
 8000aae:	f001 ff3f 	bl	8002930 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
 8000ab2:	9b01      	ldr	r3, [sp, #4]
 8000ab4:	781b      	ldrb	r3, [r3, #0]
 8000ab6:	2b02      	cmp	r3, #2
 8000ab8:	bf14      	ite	ne
 8000aba:	2301      	movne	r3, #1
 8000abc:	2300      	moveq	r3, #0
 8000abe:	b2db      	uxtb	r3, r3
 8000ac0:	2b00      	cmp	r3, #0
 8000ac2:	d002      	beq.n	8000aca <gptStartContinuousI+0x3a>
 8000ac4:	4806      	ldr	r0, [pc, #24]	@ (8000ae0 <gptStartContinuousI+0x50>)
 8000ac6:	f001 ff33 	bl	8002930 <chSysHalt>
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000aca:	9b01      	ldr	r3, [sp, #4]
 8000acc:	2203      	movs	r2, #3
 8000ace:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 8000ad0:	9900      	ldr	r1, [sp, #0]
 8000ad2:	9801      	ldr	r0, [sp, #4]
 8000ad4:	f001 fd94 	bl	8002600 <gpt_lld_start_timer>
}
 8000ad8:	bf00      	nop
 8000ada:	b003      	add	sp, #12
 8000adc:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ae0:	08005320 	.word	0x08005320
	...

08000af0 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000af0:	b500      	push	{lr}
 8000af2:	b083      	sub	sp, #12
 8000af4:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8000af6:	f7ff ff43 	bl	8000980 <osalSysLock.lto_priv.3>
  gptStopTimerI(gptp);
 8000afa:	9801      	ldr	r0, [sp, #4]
 8000afc:	f000 f808 	bl	8000b10 <gptStopTimerI>
  osalSysUnlock();
 8000b00:	f7ff ff46 	bl	8000990 <osalSysUnlock.lto_priv.3>
}
 8000b04:	bf00      	nop
 8000b06:	b003      	add	sp, #12
 8000b08:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b0c:	0000      	movs	r0, r0
	...

08000b10 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000b10:	b500      	push	{lr}
 8000b12:	b083      	sub	sp, #12
 8000b14:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8000b16:	f002 f8ab 	bl	8002c70 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000b1a:	9b01      	ldr	r3, [sp, #4]
 8000b1c:	2b00      	cmp	r3, #0
 8000b1e:	bf0c      	ite	eq
 8000b20:	2301      	moveq	r3, #1
 8000b22:	2300      	movne	r3, #0
 8000b24:	b2db      	uxtb	r3, r3
 8000b26:	2b00      	cmp	r3, #0
 8000b28:	d002      	beq.n	8000b30 <gptStopTimerI+0x20>
 8000b2a:	4818      	ldr	r0, [pc, #96]	@ (8000b8c <gptStopTimerI+0x7c>)
 8000b2c:	f001 ff00 	bl	8002930 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
 8000b30:	9b01      	ldr	r3, [sp, #4]
 8000b32:	781b      	ldrb	r3, [r3, #0]
 8000b34:	2b02      	cmp	r3, #2
 8000b36:	bf14      	ite	ne
 8000b38:	2301      	movne	r3, #1
 8000b3a:	2300      	moveq	r3, #0
 8000b3c:	b2db      	uxtb	r3, r3
 8000b3e:	2b00      	cmp	r3, #0
 8000b40:	d00a      	beq.n	8000b58 <gptStopTimerI+0x48>
 8000b42:	9b01      	ldr	r3, [sp, #4]
 8000b44:	781b      	ldrb	r3, [r3, #0]
 8000b46:	2b03      	cmp	r3, #3
 8000b48:	bf14      	ite	ne
 8000b4a:	2301      	movne	r3, #1
 8000b4c:	2300      	moveq	r3, #0
 8000b4e:	b2db      	uxtb	r3, r3
 8000b50:	2b00      	cmp	r3, #0
 8000b52:	d001      	beq.n	8000b58 <gptStopTimerI+0x48>
 8000b54:	2301      	movs	r3, #1
 8000b56:	e000      	b.n	8000b5a <gptStopTimerI+0x4a>
 8000b58:	2300      	movs	r3, #0
 8000b5a:	2b00      	cmp	r3, #0
 8000b5c:	d00b      	beq.n	8000b76 <gptStopTimerI+0x66>
 8000b5e:	9b01      	ldr	r3, [sp, #4]
 8000b60:	781b      	ldrb	r3, [r3, #0]
 8000b62:	2b04      	cmp	r3, #4
 8000b64:	bf14      	ite	ne
 8000b66:	2301      	movne	r3, #1
 8000b68:	2300      	moveq	r3, #0
 8000b6a:	b2db      	uxtb	r3, r3
 8000b6c:	2b00      	cmp	r3, #0
 8000b6e:	d002      	beq.n	8000b76 <gptStopTimerI+0x66>
 8000b70:	4806      	ldr	r0, [pc, #24]	@ (8000b8c <gptStopTimerI+0x7c>)
 8000b72:	f001 fedd 	bl	8002930 <chSysHalt>
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000b76:	9b01      	ldr	r3, [sp, #4]
 8000b78:	2202      	movs	r2, #2
 8000b7a:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000b7c:	9801      	ldr	r0, [sp, #4]
 8000b7e:	f001 fd67 	bl	8002650 <gpt_lld_stop_timer>
}
 8000b82:	bf00      	nop
 8000b84:	b003      	add	sp, #12
 8000b86:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b8a:	bf00      	nop
 8000b8c:	08005334 	.word	0x08005334

08000b90 <nvicInit>:
/*===========================================================================*/

/**
 * @brief   NVIC clearing and initialization.
 */
void nvicInit(void) {
 8000b90:	b082      	sub	sp, #8
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
#else
  uint32_t n = SCnSCB->ICTR;
 8000b92:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8000b96:	685b      	ldr	r3, [r3, #4]
 8000b98:	9300      	str	r3, [sp, #0]
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 8000b9a:	2300      	movs	r3, #0
 8000b9c:	9301      	str	r3, [sp, #4]
 8000b9e:	e010      	b.n	8000bc2 <nvicInit+0x32>
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8000ba0:	4a0c      	ldr	r2, [pc, #48]	@ (8000bd4 <nvicInit+0x44>)
 8000ba2:	9b01      	ldr	r3, [sp, #4]
 8000ba4:	3320      	adds	r3, #32
 8000ba6:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8000baa:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 8000bae:	4a09      	ldr	r2, [pc, #36]	@ (8000bd4 <nvicInit+0x44>)
 8000bb0:	9b01      	ldr	r3, [sp, #4]
 8000bb2:	3360      	adds	r3, #96	@ 0x60
 8000bb4:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8000bb8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  for (uint32_t i = 0U; i <= n; i++) {
 8000bbc:	9b01      	ldr	r3, [sp, #4]
 8000bbe:	3301      	adds	r3, #1
 8000bc0:	9301      	str	r3, [sp, #4]
 8000bc2:	9a01      	ldr	r2, [sp, #4]
 8000bc4:	9b00      	ldr	r3, [sp, #0]
 8000bc6:	429a      	cmp	r2, r3
 8000bc8:	d9ea      	bls.n	8000ba0 <nvicInit+0x10>
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
    NVIC->__ITNS[i] = 0xFFFFFFFFU;
#endif
  }
}
 8000bca:	bf00      	nop
 8000bcc:	bf00      	nop
 8000bce:	b002      	add	sp, #8
 8000bd0:	4770      	bx	lr
 8000bd2:	bf00      	nop
 8000bd4:	e000e100 	.word	0xe000e100
	...

08000be0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000be0:	b082      	sub	sp, #8
 8000be2:	9001      	str	r0, [sp, #4]
 8000be4:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8000be6:	9b00      	ldr	r3, [sp, #0]
 8000be8:	b2db      	uxtb	r3, r3
 8000bea:	4a11      	ldr	r2, [pc, #68]	@ (8000c30 <nvicEnableVector+0x50>)
 8000bec:	011b      	lsls	r3, r3, #4
 8000bee:	b2d9      	uxtb	r1, r3
 8000bf0:	9b01      	ldr	r3, [sp, #4]
 8000bf2:	4413      	add	r3, r2
 8000bf4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8000bf8:	460a      	mov	r2, r1
 8000bfa:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000bfc:	9b01      	ldr	r3, [sp, #4]
 8000bfe:	f003 021f 	and.w	r2, r3, #31
 8000c02:	490b      	ldr	r1, [pc, #44]	@ (8000c30 <nvicEnableVector+0x50>)
 8000c04:	9b01      	ldr	r3, [sp, #4]
 8000c06:	095b      	lsrs	r3, r3, #5
 8000c08:	2001      	movs	r0, #1
 8000c0a:	fa00 f202 	lsl.w	r2, r0, r2
 8000c0e:	3360      	adds	r3, #96	@ 0x60
 8000c10:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000c14:	9b01      	ldr	r3, [sp, #4]
 8000c16:	f003 021f 	and.w	r2, r3, #31
 8000c1a:	4905      	ldr	r1, [pc, #20]	@ (8000c30 <nvicEnableVector+0x50>)
 8000c1c:	9b01      	ldr	r3, [sp, #4]
 8000c1e:	095b      	lsrs	r3, r3, #5
 8000c20:	2001      	movs	r0, #1
 8000c22:	fa00 f202 	lsl.w	r2, r0, r2
 8000c26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000c2a:	bf00      	nop
 8000c2c:	b002      	add	sp, #8
 8000c2e:	4770      	bx	lr
 8000c30:	e000e100 	.word	0xe000e100
	...

08000c40 <exti0_irq_init>:

static inline void exti0_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
 8000c40:	bf00      	nop
 8000c42:	4770      	bx	lr
	...

08000c50 <exti1_irq_init>:

static inline void exti1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
 8000c50:	bf00      	nop
 8000c52:	4770      	bx	lr
	...

08000c60 <exti2_irq_init>:

static inline void exti2_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
 8000c60:	bf00      	nop
 8000c62:	4770      	bx	lr
	...

08000c70 <exti3_irq_init>:

static inline void exti3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
 8000c70:	bf00      	nop
 8000c72:	4770      	bx	lr
	...

08000c80 <exti4_irq_init>:

static inline void exti4_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
 8000c80:	bf00      	nop
 8000c82:	4770      	bx	lr
	...

08000c90 <exti5_9_irq_init>:

static inline void exti5_9_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
 8000c90:	bf00      	nop
 8000c92:	4770      	bx	lr
	...

08000ca0 <exti10_15_irq_init>:

static inline void exti10_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
 8000ca0:	bf00      	nop
 8000ca2:	4770      	bx	lr
	...

08000cb0 <exti16_exti40_exti41_irq_init>:
static inline void exti16_exti40_exti41_irq_init(void) {
#if defined(STM32_EXTI16_IS_USED) || defined(STM32_EXTI40_IS_USED) ||       \
    defined(STM32_EXTI41_IS_USED)
  nvicEnableVector(STM32_EXTI164041_NUMBER, STM32_IRQ_EXTI164041_PRIORITY);
#endif
}
 8000cb0:	bf00      	nop
 8000cb2:	4770      	bx	lr
	...

08000cc0 <exti17_irq_init>:

static inline void exti17_irq_init(void) {
#if defined(STM32_EXTI17_IS_USED)
  nvicEnableVector(STM32_EXTI17_NUMBER, STM32_IRQ_EXTI17_PRIORITY);
#endif
}
 8000cc0:	bf00      	nop
 8000cc2:	4770      	bx	lr
	...

08000cd0 <exti18_irq_init>:

static inline void exti18_irq_init(void) {
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
 8000cd0:	bf00      	nop
 8000cd2:	4770      	bx	lr
	...

08000ce0 <exti19_irq_init>:

static inline void exti19_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
 8000ce0:	bf00      	nop
 8000ce2:	4770      	bx	lr
	...

08000cf0 <exti21_exti22_exti29_irq_init>:
static inline void exti21_exti22_exti29_irq_init(void) {
#if defined(STM32_EXTI21_IS_USED) || defined(STM32_EXTI22_IS_USED) ||       \
    defined(STM32_EXTI29_IS_USED)
  nvicEnableVector(STM32_EXTI212229_NUMBER, STM32_IRQ_EXTI212229_PRIORITY);
#endif
}
 8000cf0:	bf00      	nop
 8000cf2:	4770      	bx	lr
	...

08000d00 <exti30_32_irq_init>:
static inline void exti30_32_irq_init(void) {
#if defined(STM32_EXTI30_IS_USED) || defined(STM32_EXTI31_IS_USED) ||       \
    defined(STM32_EXTI32_IS_USED)
  nvicEnableVector(STM32_EXTI30_32_NUMBER, STM32_IRQ_EXTI30_32_PRIORITY);
#endif
}
 8000d00:	bf00      	nop
 8000d02:	4770      	bx	lr
	...

08000d10 <exti33_irq_init>:

static inline void exti33_irq_init(void) {
#if defined(STM32_EXTI33_IS_USED)
  nvicEnableVector(STM32_EXTI33_NUMBER, STM32_IRQ_EXTI33_PRIORITY);
#endif
}
 8000d10:	bf00      	nop
 8000d12:	4770      	bx	lr
	...

08000d20 <fdcan1_irq_init>:

static inline void fdcan1_irq_init(void) {
#if STM32_FDCAN1_IS_USED
  nvicEnableVector(STM32_FDCAN1_IT0_NUMBER, STM32_IRQ_FDCAN1_PRIORITY);
#endif
}
 8000d20:	bf00      	nop
 8000d22:	4770      	bx	lr
	...

08000d30 <fdcan2_irq_init>:

static inline void fdcan2_irq_init(void) {
#if STM32_FDCAN2_IS_USED
  nvicEnableVector(STM32_FDCAN2_IT0_NUMBER, STM32_IRQ_FDCAN2_PRIORITY);
#endif
}
 8000d30:	bf00      	nop
 8000d32:	4770      	bx	lr
	...

08000d40 <fdcan3_irq_init>:

static inline void fdcan3_irq_init(void) {
#if STM32_FDCAN3_IS_USED
  nvicEnableVector(STM32_FDCAN3_IT0_NUMBER, STM32_IRQ_FDCAN3_PRIORITY);
#endif
}
 8000d40:	bf00      	nop
 8000d42:	4770      	bx	lr
	...

08000d50 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000d50:	bf00      	nop
 8000d52:	4770      	bx	lr
	...

08000d60 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000d60:	bf00      	nop
 8000d62:	4770      	bx	lr
	...

08000d70 <usart3_irq_init>:

static inline void usart3_irq_init(void) {
#if defined(STM32_USART3_IS_USED)
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
#endif
}
 8000d70:	bf00      	nop
 8000d72:	4770      	bx	lr
	...

08000d80 <uart4_irq_init>:

static inline void uart4_irq_init(void) {
#if defined(STM32_UART4_IS_USED)
  nvicEnableVector(STM32_UART4_NUMBER, STM32_IRQ_UART4_PRIORITY);
#endif
}
 8000d80:	bf00      	nop
 8000d82:	4770      	bx	lr
	...

08000d90 <uart5_irq_init>:

static inline void uart5_irq_init(void) {
#if defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_IRQ_UART5_PRIORITY);
#endif
}
 8000d90:	bf00      	nop
 8000d92:	4770      	bx	lr
	...

08000da0 <lpuart1_irq_init>:

static inline void lpuart1_irq_init(void) {
#if defined(STM32_LPUART1_IS_USED)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_IRQ_LPUART1_PRIORITY);
#endif
}
 8000da0:	bf00      	nop
 8000da2:	4770      	bx	lr
	...

08000db0 <tim1_tim15_tim16_tim17_irq_init>:
#endif
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_CC_NUMBER,
                   STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8000db0:	bf00      	nop
 8000db2:	4770      	bx	lr
	...

08000dc0 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8000dc0:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8000dc2:	2107      	movs	r1, #7
 8000dc4:	201c      	movs	r0, #28
 8000dc6:	f7ff ff0b 	bl	8000be0 <nvicEnableVector>
#endif
}
 8000dca:	bf00      	nop
 8000dcc:	bd08      	pop	{r3, pc}
 8000dce:	bf00      	nop

08000dd0 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000dd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000dd2:	f001 fed5 	bl	8002b80 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000dd6:	f001 fb63 	bl	80024a0 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000dda:	f001 ff09 	bl	8002bf0 <__dbg_check_leave_isr>
 8000dde:	f004 f90f 	bl	8005000 <__port_irq_epilogue>
}
 8000de2:	bf00      	nop
 8000de4:	bd08      	pop	{r3, pc}
 8000de6:	bf00      	nop
	...

08000df0 <tim3_irq_init>:

static inline void tim3_irq_init(void) {
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
 8000df0:	bf00      	nop
 8000df2:	4770      	bx	lr
	...

08000e00 <tim4_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim4_irq_init(void) {
 8000e00:	b508      	push	{r3, lr}
#if defined(STM32_TIM4_IS_USED)
  nvicEnableVector(STM32_TIM4_NUMBER, STM32_IRQ_TIM4_PRIORITY);
 8000e02:	2107      	movs	r1, #7
 8000e04:	201e      	movs	r0, #30
 8000e06:	f7ff feeb 	bl	8000be0 <nvicEnableVector>
#endif
}
 8000e0a:	bf00      	nop
 8000e0c:	bd08      	pop	{r3, pc}
 8000e0e:	bf00      	nop

08000e10 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8000e10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000e12:	f001 feb5 	bl	8002b80 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM4
  gpt_lld_serve_interrupt(&GPTD4);
 8000e16:	4804      	ldr	r0, [pc, #16]	@ (8000e28 <VectorB8+0x18>)
 8000e18:	f001 fc32 	bl	8002680 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM4
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000e1c:	f001 fee8 	bl	8002bf0 <__dbg_check_leave_isr>
 8000e20:	f004 f8ee 	bl	8005000 <__port_irq_epilogue>
}
 8000e24:	bf00      	nop
 8000e26:	bd08      	pop	{r3, pc}
 8000e28:	2000096c 	.word	0x2000096c
 8000e2c:	00000000 	.word	0x00000000

08000e30 <tim5_irq_init>:

static inline void tim5_irq_init(void) {
#if defined(STM32_TIM5_IS_USED)
  nvicEnableVector(STM32_TIM5_NUMBER, STM32_IRQ_TIM5_PRIORITY);
#endif
}
 8000e30:	bf00      	nop
 8000e32:	4770      	bx	lr
	...

08000e40 <tim6_irq_init>:

static inline void tim6_irq_init(void) {
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
#endif
}
 8000e40:	bf00      	nop
 8000e42:	4770      	bx	lr
	...

08000e50 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 8000e50:	bf00      	nop
 8000e52:	4770      	bx	lr
	...

08000e60 <tim8_irq_init>:
static inline void tim8_irq_init(void) {
#if defined(STM32_TIM8_IS_USED)
  nvicEnableVector(STM32_TIM8_UP_NUMBER, STM32_IRQ_TIM8_UP_PRIORITY);
  nvicEnableVector(STM32_TIM8_CC_NUMBER, STM32_IRQ_TIM8_CC_PRIORITY);
#endif
}
 8000e60:	bf00      	nop
 8000e62:	4770      	bx	lr
	...

08000e70 <tim20_irq_init>:
static inline void tim20_irq_init(void) {
#if defined(STM32_TIM20_IS_USED)
  nvicEnableVector(STM32_TIM20_UP_NUMBER, STM32_IRQ_TIM20_UP_PRIORITY);
  nvicEnableVector(STM32_TIM20_CC_NUMBER, STM32_IRQ_TIM20_CC_PRIORITY);
#endif
}
 8000e70:	bf00      	nop
 8000e72:	4770      	bx	lr
	...

08000e80 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000e80:	b508      	push	{r3, lr}

  exti0_irq_init();
 8000e82:	f7ff fedd 	bl	8000c40 <exti0_irq_init>
  exti1_irq_init();
 8000e86:	f7ff fee3 	bl	8000c50 <exti1_irq_init>
  exti2_irq_init();
 8000e8a:	f7ff fee9 	bl	8000c60 <exti2_irq_init>
  exti3_irq_init();
 8000e8e:	f7ff feef 	bl	8000c70 <exti3_irq_init>
  exti4_irq_init();
 8000e92:	f7ff fef5 	bl	8000c80 <exti4_irq_init>
  exti5_9_irq_init();
 8000e96:	f7ff fefb 	bl	8000c90 <exti5_9_irq_init>
  exti10_15_irq_init();
 8000e9a:	f7ff ff01 	bl	8000ca0 <exti10_15_irq_init>
  exti16_exti40_exti41_irq_init();
 8000e9e:	f7ff ff07 	bl	8000cb0 <exti16_exti40_exti41_irq_init>
  exti17_irq_init();
 8000ea2:	f7ff ff0d 	bl	8000cc0 <exti17_irq_init>
  exti18_irq_init();
 8000ea6:	f7ff ff13 	bl	8000cd0 <exti18_irq_init>
  exti19_irq_init();
 8000eaa:	f7ff ff19 	bl	8000ce0 <exti19_irq_init>
  exti21_exti22_exti29_irq_init();
 8000eae:	f7ff ff1f 	bl	8000cf0 <exti21_exti22_exti29_irq_init>
  exti30_32_irq_init();
 8000eb2:	f7ff ff25 	bl	8000d00 <exti30_32_irq_init>
  exti33_irq_init();
 8000eb6:	f7ff ff2b 	bl	8000d10 <exti33_irq_init>

  fdcan1_irq_init();
 8000eba:	f7ff ff31 	bl	8000d20 <fdcan1_irq_init>
  fdcan2_irq_init();
 8000ebe:	f7ff ff37 	bl	8000d30 <fdcan2_irq_init>
  fdcan3_irq_init();
 8000ec2:	f7ff ff3d 	bl	8000d40 <fdcan3_irq_init>

  tim1_tim15_tim16_tim17_irq_init();
 8000ec6:	f7ff ff73 	bl	8000db0 <tim1_tim15_tim16_tim17_irq_init>
  tim2_irq_init();
 8000eca:	f7ff ff79 	bl	8000dc0 <tim2_irq_init>
  tim3_irq_init();
 8000ece:	f7ff ff8f 	bl	8000df0 <tim3_irq_init>
  tim4_irq_init();
 8000ed2:	f7ff ff95 	bl	8000e00 <tim4_irq_init>
  tim5_irq_init();
 8000ed6:	f7ff ffab 	bl	8000e30 <tim5_irq_init>
  tim6_irq_init();
 8000eda:	f7ff ffb1 	bl	8000e40 <tim6_irq_init>
  tim7_irq_init();
 8000ede:	f7ff ffb7 	bl	8000e50 <tim7_irq_init>
  tim8_irq_init();
 8000ee2:	f7ff ffbd 	bl	8000e60 <tim8_irq_init>
  tim20_irq_init();
 8000ee6:	f7ff ffc3 	bl	8000e70 <tim20_irq_init>

  usart1_irq_init();
 8000eea:	f7ff ff31 	bl	8000d50 <usart1_irq_init>
  usart2_irq_init();
 8000eee:	f7ff ff37 	bl	8000d60 <usart2_irq_init>
  usart3_irq_init();
 8000ef2:	f7ff ff3d 	bl	8000d70 <usart3_irq_init>
  uart4_irq_init();
 8000ef6:	f7ff ff43 	bl	8000d80 <uart4_irq_init>
  uart5_irq_init();
 8000efa:	f7ff ff49 	bl	8000d90 <uart5_irq_init>
  lpuart1_irq_init();
 8000efe:	f7ff ff4f 	bl	8000da0 <lpuart1_irq_init>
}
 8000f02:	bf00      	nop
 8000f04:	bd08      	pop	{r3, pc}
 8000f06:	bf00      	nop
	...

08000f10 <lse_init>:
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN;
 8000f10:	4b09      	ldr	r3, [pc, #36]	@ (8000f38 <lse_init+0x28>)
 8000f12:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000f16:	4a08      	ldr	r2, [pc, #32]	@ (8000f38 <lse_init+0x28>)
 8000f18:	f043 0319 	orr.w	r3, r3, #25
 8000f1c:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  while ((RCC->BDCR & (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) !=
 8000f20:	bf00      	nop
 8000f22:	4b05      	ldr	r3, [pc, #20]	@ (8000f38 <lse_init+0x28>)
 8000f24:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000f28:	f003 0302 	and.w	r3, r3, #2
 8000f2c:	2b02      	cmp	r3, #2
 8000f2e:	d1f8      	bne.n	8000f22 <lse_init+0x12>
         (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) {
  }
#endif
#endif
}
 8000f30:	bf00      	nop
 8000f32:	bf00      	nop
 8000f34:	4770      	bx	lr
 8000f36:	bf00      	nop
 8000f38:	40021000 	.word	0x40021000
 8000f3c:	00000000 	.word	0x00000000

08000f40 <lsi_init>:
  /* LSI activation.*/
  RCC->CSR |= STM32_LSIPRE | RCC_CSR_LSION;
  while ((RCC->BDCR & RCC_CSR_LSIRDY) == 0U) {
  }
#endif
}
 8000f40:	bf00      	nop
 8000f42:	4770      	bx	lr
	...

08000f50 <hsi16_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void hsi16_enable(void) {

  RCC->CR |= RCC_CR_HSION;
 8000f50:	4b07      	ldr	r3, [pc, #28]	@ (8000f70 <hsi16_enable+0x20>)
 8000f52:	681b      	ldr	r3, [r3, #0]
 8000f54:	4a06      	ldr	r2, [pc, #24]	@ (8000f70 <hsi16_enable+0x20>)
 8000f56:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000f5a:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0U) {
 8000f5c:	bf00      	nop
 8000f5e:	4b04      	ldr	r3, [pc, #16]	@ (8000f70 <hsi16_enable+0x20>)
 8000f60:	681b      	ldr	r3, [r3, #0]
 8000f62:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8000f66:	2b00      	cmp	r3, #0
 8000f68:	d0f9      	beq.n	8000f5e <hsi16_enable+0xe>
    /* Waiting for HSI16 activation.*/
  }
}
 8000f6a:	bf00      	nop
 8000f6c:	bf00      	nop
 8000f6e:	4770      	bx	lr
 8000f70:	40021000 	.word	0x40021000
	...

08000f80 <hsi16_init>:
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI) {
    /* Wait until HSI is selected.*/
  }
}

__STATIC_INLINE void hsi16_init(void) {
 8000f80:	b508      	push	{r3, lr}

#if STM32_HSI16_ENABLED
  /* HSI activation.*/
  hsi16_enable();
 8000f82:	f7ff ffe5 	bl	8000f50 <hsi16_enable>
#endif
}
 8000f86:	bf00      	nop
 8000f88:	bd08      	pop	{r3, pc}
 8000f8a:	bf00      	nop
 8000f8c:	0000      	movs	r0, r0
	...

08000f90 <hsi48_enable>:

#if STM32_RCC_HAS_HSI48 == TRUE
#if defined(RCC_CRRCR_HSI48ON)
__STATIC_INLINE void hsi48_enable(void) {

  RCC->CRRCR |= RCC_CRRCR_HSI48ON;
 8000f90:	4b09      	ldr	r3, [pc, #36]	@ (8000fb8 <hsi48_enable+0x28>)
 8000f92:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8000f96:	4a08      	ldr	r2, [pc, #32]	@ (8000fb8 <hsi48_enable+0x28>)
 8000f98:	f043 0301 	orr.w	r3, r3, #1
 8000f9c:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98
  while ((RCC->CRRCR & RCC_CRRCR_HSI48RDY) == 0U) {
 8000fa0:	bf00      	nop
 8000fa2:	4b05      	ldr	r3, [pc, #20]	@ (8000fb8 <hsi48_enable+0x28>)
 8000fa4:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8000fa8:	f003 0302 	and.w	r3, r3, #2
 8000fac:	2b00      	cmp	r3, #0
 8000fae:	d0f8      	beq.n	8000fa2 <hsi48_enable+0x12>
    /* Waiting for HSI48 activation.*/
  }
}
 8000fb0:	bf00      	nop
 8000fb2:	bf00      	nop
 8000fb4:	4770      	bx	lr
 8000fb6:	bf00      	nop
 8000fb8:	40021000 	.word	0x40021000
 8000fbc:	00000000 	.word	0x00000000

08000fc0 <hsi48_init>:
  RCC->CR &= ~RCC_CR_HSI48ON;
}
#endif /* defined(RCC_CR_HSI48ON) */
#endif /* STM32_RCC_HAS_HSI48 == TRUE */

__STATIC_INLINE void hsi48_init(void) {
 8000fc0:	b508      	push	{r3, lr}

#if STM32_HSI48_ENABLED
  /* HSI activation.*/
  hsi48_enable();
 8000fc2:	f7ff ffe5 	bl	8000f90 <hsi48_enable>
#endif
}
 8000fc6:	bf00      	nop
 8000fc8:	bd08      	pop	{r3, pc}
 8000fca:	bf00      	nop
 8000fcc:	0000      	movs	r0, r0
	...

08000fd0 <hse_enable>:

#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass case.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  RCC->CR |= RCC_CR_HSEON;
 8000fd0:	4b07      	ldr	r3, [pc, #28]	@ (8000ff0 <hse_enable+0x20>)
 8000fd2:	681b      	ldr	r3, [r3, #0]
 8000fd4:	4a06      	ldr	r2, [pc, #24]	@ (8000ff0 <hse_enable+0x20>)
 8000fd6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8000fda:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0U) {
 8000fdc:	bf00      	nop
 8000fde:	4b04      	ldr	r3, [pc, #16]	@ (8000ff0 <hse_enable+0x20>)
 8000fe0:	681b      	ldr	r3, [r3, #0]
 8000fe2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8000fe6:	2b00      	cmp	r3, #0
 8000fe8:	d0f9      	beq.n	8000fde <hse_enable+0xe>
    /* Waiting for HSE activation.*/
  }
#endif
}
 8000fea:	bf00      	nop
 8000fec:	bf00      	nop
 8000fee:	4770      	bx	lr
 8000ff0:	40021000 	.word	0x40021000
	...

08001000 <hse_init>:
__STATIC_INLINE void hse_disable(void) {

  RCC->CR &= ~RCC_CR_HSEON;
}

__STATIC_INLINE void hse_init(void) {
 8001000:	b508      	push	{r3, lr}

#if STM32_HSE_ENABLED
  hse_enable();
 8001002:	f7ff ffe5 	bl	8000fd0 <hse_enable>
#endif
}
 8001006:	bf00      	nop
 8001008:	bd08      	pop	{r3, pc}
 800100a:	bf00      	nop
 800100c:	0000      	movs	r0, r0
	...

08001010 <pll_not_locked>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE bool pll_not_locked(void) {

  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8001010:	4b05      	ldr	r3, [pc, #20]	@ (8001028 <pll_not_locked+0x18>)
 8001012:	681b      	ldr	r3, [r3, #0]
 8001014:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8001018:	2b00      	cmp	r3, #0
 800101a:	bf0c      	ite	eq
 800101c:	2301      	moveq	r3, #1
 800101e:	2300      	movne	r3, #0
 8001020:	b2db      	uxtb	r3, r3
}
 8001022:	4618      	mov	r0, r3
 8001024:	4770      	bx	lr
 8001026:	bf00      	nop
 8001028:	40021000 	.word	0x40021000
 800102c:	00000000 	.word	0x00000000

08001030 <pll_wait_lock>:

__STATIC_INLINE void pll_wait_lock(void) {
 8001030:	b508      	push	{r3, lr}

  while (pll_not_locked()) {
 8001032:	bf00      	nop
 8001034:	f7ff ffec 	bl	8001010 <pll_not_locked>
 8001038:	4603      	mov	r3, r0
 800103a:	2b00      	cmp	r3, #0
 800103c:	d1fa      	bne.n	8001034 <pll_wait_lock+0x4>
    /* Waiting for PLL lock.*/
  }
}
 800103e:	bf00      	nop
 8001040:	bf00      	nop
 8001042:	bd08      	pop	{r3, pc}
	...

08001050 <pll_init>:

#endif /* STM32_RCC_HAS_PLL */

__STATIC_INLINE void pll_init(void) {
 8001050:	b508      	push	{r3, lr}

#if STM32_RCC_HAS_PLL
#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLPDIV | STM32_PLLR   |
 8001052:	4b06      	ldr	r3, [pc, #24]	@ (800106c <pll_init+0x1c>)
 8001054:	4a06      	ldr	r2, [pc, #24]	@ (8001070 <pll_init+0x20>)
 8001056:	60da      	str	r2, [r3, #12]
                 STM32_PLLREN  | STM32_PLLQ   |
                 STM32_PLLQEN  | STM32_PLLP   |
                 STM32_PLLPEN  | STM32_PLLN   |
                 STM32_PLLM    | STM32_PLLSRC;
  RCC->CR |= RCC_CR_PLLON;
 8001058:	4b04      	ldr	r3, [pc, #16]	@ (800106c <pll_init+0x1c>)
 800105a:	681b      	ldr	r3, [r3, #0]
 800105c:	4a03      	ldr	r2, [pc, #12]	@ (800106c <pll_init+0x1c>)
 800105e:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001062:	6013      	str	r3, [r2, #0]

  pll_wait_lock();
 8001064:	f7ff ffe4 	bl	8001030 <pll_wait_lock>
#endif
#endif
}
 8001068:	bf00      	nop
 800106a:	bd08      	pop	{r3, pc}
 800106c:	40021000 	.word	0x40021000
 8001070:	19615553 	.word	0x19615553
	...

08001080 <bd_init>:
/*===========================================================================*/

/**
 * @brief   Initializes the backup domain.
 */
__STATIC_INLINE void bd_init(void) {
 8001080:	b082      	sub	sp, #8
  uint32_t bdcr;

  /* Current settings.*/
  bdcr = RCC->BDCR;
 8001082:	4b07      	ldr	r3, [pc, #28]	@ (80010a0 <bd_init+0x20>)
 8001084:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8001088:	9301      	str	r3, [sp, #4]
    bdcr |= RCC_BDCR_RTCEN;
  }
#endif

  /* Selectors.*/
  bdcr &= ~(STM32_RTCSEL_MASK | STM32_LSCOSEL_MASK);
 800108a:	9b01      	ldr	r3, [sp, #4]
 800108c:	f023 2303 	bic.w	r3, r3, #50332416	@ 0x3000300
 8001090:	9301      	str	r3, [sp, #4]
  bdcr |= STM32_RTCSEL | STM32_LSCOSEL;

  /* Final settings.*/
  RCC->BDCR = bdcr;
 8001092:	4a03      	ldr	r2, [pc, #12]	@ (80010a0 <bd_init+0x20>)
 8001094:	9b01      	ldr	r3, [sp, #4]
 8001096:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
}
 800109a:	bf00      	nop
 800109c:	b002      	add	sp, #8
 800109e:	4770      	bx	lr
 80010a0:	40021000 	.word	0x40021000
	...

080010b0 <bd_reset>:
 *          of the whole BKP domain.
 */
__STATIC_INLINE void bd_reset(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80010b0:	4b08      	ldr	r3, [pc, #32]	@ (80010d4 <bd_reset+0x24>)
 80010b2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80010b6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 80010ba:	2b00      	cmp	r3, #0
 80010bc:	d008      	beq.n	80010d0 <bd_reset+0x20>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80010be:	4b05      	ldr	r3, [pc, #20]	@ (80010d4 <bd_reset+0x24>)
 80010c0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 80010c4:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    RCC->BDCR = 0U;
 80010c8:	4b02      	ldr	r3, [pc, #8]	@ (80010d4 <bd_reset+0x24>)
 80010ca:	2200      	movs	r2, #0
 80010cc:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  }
}
 80010d0:	bf00      	nop
 80010d2:	4770      	bx	lr
 80010d4:	40021000 	.word	0x40021000
	...

080010e0 <flash_set_acr>:
/**
 * @brief   Safe setting of flash ACR register.
 *
 * @param[in] acr       value for the ACR register
 */
__STATIC_INLINE void flash_set_acr(uint32_t acr) {
 80010e0:	b082      	sub	sp, #8
 80010e2:	9001      	str	r0, [sp, #4]

  FLASH->ACR = acr;
 80010e4:	4a07      	ldr	r2, [pc, #28]	@ (8001104 <flash_set_acr+0x24>)
 80010e6:	9b01      	ldr	r3, [sp, #4]
 80010e8:	6013      	str	r3, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) != (acr & FLASH_ACR_LATENCY_Msk)) {
 80010ea:	bf00      	nop
 80010ec:	4b05      	ldr	r3, [pc, #20]	@ (8001104 <flash_set_acr+0x24>)
 80010ee:	681a      	ldr	r2, [r3, #0]
 80010f0:	9b01      	ldr	r3, [sp, #4]
 80010f2:	4053      	eors	r3, r2
 80010f4:	f003 030f 	and.w	r3, r3, #15
 80010f8:	2b00      	cmp	r3, #0
 80010fa:	d1f7      	bne.n	80010ec <flash_set_acr+0xc>
    /* Waiting for flash wait states setup.*/
  }
}
 80010fc:	bf00      	nop
 80010fe:	bf00      	nop
 8001100:	b002      	add	sp, #8
 8001102:	4770      	bx	lr
 8001104:	40022000 	.word	0x40022000
	...

08001110 <hal_lld_set_static_pwr>:
 * @note    CR1, CR2 and CR5 are not initialized inside this function.
 */
__STATIC_INLINE void hal_lld_set_static_pwr(void) {

  /* PWR clock enabled.*/
  rccEnablePWRInterface(false);
 8001110:	4b20      	ldr	r3, [pc, #128]	@ (8001194 <hal_lld_set_static_pwr+0x84>)
 8001112:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8001114:	4a1f      	ldr	r2, [pc, #124]	@ (8001194 <hal_lld_set_static_pwr+0x84>)
 8001116:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800111a:	6593      	str	r3, [r2, #88]	@ 0x58
 800111c:	4b1d      	ldr	r3, [pc, #116]	@ (8001194 <hal_lld_set_static_pwr+0x84>)
 800111e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8001120:	4a1c      	ldr	r2, [pc, #112]	@ (8001194 <hal_lld_set_static_pwr+0x84>)
 8001122:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8001126:	6793      	str	r3, [r2, #120]	@ 0x78
 8001128:	4b1a      	ldr	r3, [pc, #104]	@ (8001194 <hal_lld_set_static_pwr+0x84>)
 800112a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78

  /* Static PWR configurations.*/
  PWR->CR3   = STM32_PWR_CR3;
 800112c:	4b1a      	ldr	r3, [pc, #104]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 800112e:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8001132:	609a      	str	r2, [r3, #8]
  PWR->CR4   = STM32_PWR_CR4;
 8001134:	4b18      	ldr	r3, [pc, #96]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001136:	2200      	movs	r2, #0
 8001138:	60da      	str	r2, [r3, #12]
  PWR->PUCRA = STM32_PWR_PUCRA;
 800113a:	4b17      	ldr	r3, [pc, #92]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 800113c:	2200      	movs	r2, #0
 800113e:	621a      	str	r2, [r3, #32]
  PWR->PDCRA = STM32_PWR_PDCRA;
 8001140:	4b15      	ldr	r3, [pc, #84]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001142:	2200      	movs	r2, #0
 8001144:	625a      	str	r2, [r3, #36]	@ 0x24
  PWR->PUCRB = STM32_PWR_PUCRB;
 8001146:	4b14      	ldr	r3, [pc, #80]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001148:	2200      	movs	r2, #0
 800114a:	629a      	str	r2, [r3, #40]	@ 0x28
  PWR->PDCRB = STM32_PWR_PDCRB;
 800114c:	4b12      	ldr	r3, [pc, #72]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 800114e:	2200      	movs	r2, #0
 8001150:	62da      	str	r2, [r3, #44]	@ 0x2c
  PWR->PUCRC = STM32_PWR_PUCRC;
 8001152:	4b11      	ldr	r3, [pc, #68]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001154:	2200      	movs	r2, #0
 8001156:	631a      	str	r2, [r3, #48]	@ 0x30
  PWR->PDCRC = STM32_PWR_PDCRC;
 8001158:	4b0f      	ldr	r3, [pc, #60]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 800115a:	2200      	movs	r2, #0
 800115c:	635a      	str	r2, [r3, #52]	@ 0x34
#if STM32_HAS_GPIOD
  PWR->PUCRD = STM32_PWR_PUCRD;
 800115e:	4b0e      	ldr	r3, [pc, #56]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001160:	2200      	movs	r2, #0
 8001162:	639a      	str	r2, [r3, #56]	@ 0x38
  PWR->PDCRD = STM32_PWR_PDCRD;
 8001164:	4b0c      	ldr	r3, [pc, #48]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001166:	2200      	movs	r2, #0
 8001168:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if STM32_HAS_GPIOE
  PWR->PUCRE = STM32_PWR_PUCRE;
 800116a:	4b0b      	ldr	r3, [pc, #44]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 800116c:	2200      	movs	r2, #0
 800116e:	641a      	str	r2, [r3, #64]	@ 0x40
  PWR->PDCRE = STM32_PWR_PDCRE;
 8001170:	4b09      	ldr	r3, [pc, #36]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001172:	2200      	movs	r2, #0
 8001174:	645a      	str	r2, [r3, #68]	@ 0x44
#endif
#if STM32_HAS_GPIOF
  PWR->PUCRF = STM32_PWR_PUCRF;
 8001176:	4b08      	ldr	r3, [pc, #32]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001178:	2200      	movs	r2, #0
 800117a:	649a      	str	r2, [r3, #72]	@ 0x48
  PWR->PDCRF = STM32_PWR_PDCRF;
 800117c:	4b06      	ldr	r3, [pc, #24]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 800117e:	2200      	movs	r2, #0
 8001180:	64da      	str	r2, [r3, #76]	@ 0x4c
#endif
#if STM32_HAS_GPIOG
  PWR->PUCRG = STM32_PWR_PUCRG;
 8001182:	4b05      	ldr	r3, [pc, #20]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 8001184:	2200      	movs	r2, #0
 8001186:	651a      	str	r2, [r3, #80]	@ 0x50
  PWR->PDCRG = STM32_PWR_PDCRG;
 8001188:	4b03      	ldr	r3, [pc, #12]	@ (8001198 <hal_lld_set_static_pwr+0x88>)
 800118a:	2200      	movs	r2, #0
 800118c:	655a      	str	r2, [r3, #84]	@ 0x54
#endif
#if STM32_HAS_GPIOI
  PWR->PUCRI = STM32_PWR_PUCRI;
  PWR->PDCRI = STM32_PWR_PDCRI;
#endif
}
 800118e:	bf00      	nop
 8001190:	4770      	bx	lr
 8001192:	bf00      	nop
 8001194:	40021000 	.word	0x40021000
 8001198:	40007000 	.word	0x40007000
 800119c:	00000000 	.word	0x00000000

080011a0 <hal_lld_set_static_clocks>:
 * @brief   Initializes static muxes and dividers.
 */
__STATIC_INLINE void hal_lld_set_static_clocks(void) {

  /* Clock-related settings (dividers, MCO etc).*/
  RCC->CFGR   = STM32_MCOPRE | STM32_MCOSEL | STM32_PPRE2 | STM32_PPRE1 |
 80011a0:	4b06      	ldr	r3, [pc, #24]	@ (80011bc <hal_lld_set_static_clocks+0x1c>)
 80011a2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80011a6:	609a      	str	r2, [r3, #8]
                STM32_HPRE;

  /* CCIPR registers initialization, note.*/
  RCC->CCIPR  = STM32_ADC345SEL  | STM32_ADC12SEL   | STM32_CLK48SEL   |
 80011a8:	4b04      	ldr	r3, [pc, #16]	@ (80011bc <hal_lld_set_static_clocks+0x1c>)
 80011aa:	4a05      	ldr	r2, [pc, #20]	@ (80011c0 <hal_lld_set_static_clocks+0x20>)
 80011ac:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                STM32_FDCANSEL   | STM32_I2S23SEL   | STM32_SAI1SEL    |
                STM32_LPTIM1SEL  | STM32_I2C3SEL    | STM32_I2C2SEL    |
                STM32_I2C1SEL    | STM32_LPUART1SEL | STM32_UART5SEL   |
                STM32_UART4SEL   | STM32_USART3SEL  | STM32_USART2SEL  |
                STM32_USART1SEL;
  RCC->CCIPR2 = STM32_QSPISEL    | STM32_I2C4SEL;
 80011b0:	4b02      	ldr	r3, [pc, #8]	@ (80011bc <hal_lld_set_static_clocks+0x1c>)
 80011b2:	2200      	movs	r2, #0
 80011b4:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
}
 80011b8:	bf00      	nop
 80011ba:	4770      	bx	lr
 80011bc:	40021000 	.word	0x40021000
 80011c0:	50000155 	.word	0x50000155
	...

080011d0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80011d0:	b508      	push	{r3, lr}

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80011d2:	f000 fec5 	bl	8001f60 <dmaInit>
#endif

  /* NVIC initialization.*/
  nvicInit();
 80011d6:	f7ff fcdb 	bl	8000b90 <nvicInit>

  /* IRQ subsystem initialization.*/
  irqInit();
 80011da:	f7ff fe51 	bl	8000e80 <irqInit>
}
 80011de:	bf00      	nop
 80011e0:	bd08      	pop	{r3, pc}
 80011e2:	bf00      	nop
	...

080011f0 <stm32_clock_init>:
  bd_init();
#endif /* STM32_NO_INIT */
}

#else /* !defined(HAL_LLD_USE_CLOCK_MANAGEMENT) */
void stm32_clock_init(void) {
 80011f0:	b508      	push	{r3, lr}
#if !STM32_NO_INIT

  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~0);
 80011f2:	4b4d      	ldr	r3, [pc, #308]	@ (8001328 <stm32_clock_init+0x138>)
 80011f4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80011f6:	4b4c      	ldr	r3, [pc, #304]	@ (8001328 <stm32_clock_init+0x138>)
 80011f8:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80011fc:	629a      	str	r2, [r3, #40]	@ 0x28
 80011fe:	4b4a      	ldr	r3, [pc, #296]	@ (8001328 <stm32_clock_init+0x138>)
 8001200:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001202:	4b49      	ldr	r3, [pc, #292]	@ (8001328 <stm32_clock_init+0x138>)
 8001204:	2200      	movs	r2, #0
 8001206:	629a      	str	r2, [r3, #40]	@ 0x28
 8001208:	4b47      	ldr	r3, [pc, #284]	@ (8001328 <stm32_clock_init+0x138>)
 800120a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 800120c:	4b46      	ldr	r3, [pc, #280]	@ (8001328 <stm32_clock_init+0x138>)
 800120e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001210:	4a45      	ldr	r2, [pc, #276]	@ (8001328 <stm32_clock_init+0x138>)
 8001212:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8001216:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001218:	4b43      	ldr	r3, [pc, #268]	@ (8001328 <stm32_clock_init+0x138>)
 800121a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800121c:	4a42      	ldr	r2, [pc, #264]	@ (8001328 <stm32_clock_init+0x138>)
 800121e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8001222:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001224:	4b40      	ldr	r3, [pc, #256]	@ (8001328 <stm32_clock_init+0x138>)
 8001226:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccResetAHB3(~0);
 8001228:	4b3f      	ldr	r3, [pc, #252]	@ (8001328 <stm32_clock_init+0x138>)
 800122a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800122c:	4b3e      	ldr	r3, [pc, #248]	@ (8001328 <stm32_clock_init+0x138>)
 800122e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001232:	631a      	str	r2, [r3, #48]	@ 0x30
 8001234:	4b3c      	ldr	r3, [pc, #240]	@ (8001328 <stm32_clock_init+0x138>)
 8001236:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001238:	4b3b      	ldr	r3, [pc, #236]	@ (8001328 <stm32_clock_init+0x138>)
 800123a:	2200      	movs	r2, #0
 800123c:	631a      	str	r2, [r3, #48]	@ 0x30
 800123e:	4b3a      	ldr	r3, [pc, #232]	@ (8001328 <stm32_clock_init+0x138>)
 8001240:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
  rccResetAPB1R1(~0);
 8001242:	4b39      	ldr	r3, [pc, #228]	@ (8001328 <stm32_clock_init+0x138>)
 8001244:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001246:	4b38      	ldr	r3, [pc, #224]	@ (8001328 <stm32_clock_init+0x138>)
 8001248:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800124c:	639a      	str	r2, [r3, #56]	@ 0x38
 800124e:	4b36      	ldr	r3, [pc, #216]	@ (8001328 <stm32_clock_init+0x138>)
 8001250:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001252:	4b35      	ldr	r3, [pc, #212]	@ (8001328 <stm32_clock_init+0x138>)
 8001254:	2200      	movs	r2, #0
 8001256:	639a      	str	r2, [r3, #56]	@ 0x38
 8001258:	4b33      	ldr	r3, [pc, #204]	@ (8001328 <stm32_clock_init+0x138>)
 800125a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
  rccResetAPB1R2(~0);
 800125c:	4b32      	ldr	r3, [pc, #200]	@ (8001328 <stm32_clock_init+0x138>)
 800125e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001260:	4b31      	ldr	r3, [pc, #196]	@ (8001328 <stm32_clock_init+0x138>)
 8001262:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001266:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001268:	4b2f      	ldr	r3, [pc, #188]	@ (8001328 <stm32_clock_init+0x138>)
 800126a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800126c:	4b2e      	ldr	r3, [pc, #184]	@ (8001328 <stm32_clock_init+0x138>)
 800126e:	2200      	movs	r2, #0
 8001270:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001272:	4b2d      	ldr	r3, [pc, #180]	@ (8001328 <stm32_clock_init+0x138>)
 8001274:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  rccResetAPB2(~0);
 8001276:	4b2c      	ldr	r3, [pc, #176]	@ (8001328 <stm32_clock_init+0x138>)
 8001278:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800127a:	4b2b      	ldr	r3, [pc, #172]	@ (8001328 <stm32_clock_init+0x138>)
 800127c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001280:	641a      	str	r2, [r3, #64]	@ 0x40
 8001282:	4b29      	ldr	r3, [pc, #164]	@ (8001328 <stm32_clock_init+0x138>)
 8001284:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001286:	4b28      	ldr	r3, [pc, #160]	@ (8001328 <stm32_clock_init+0x138>)
 8001288:	2200      	movs	r2, #0
 800128a:	641a      	str	r2, [r3, #64]	@ 0x40
 800128c:	4b26      	ldr	r3, [pc, #152]	@ (8001328 <stm32_clock_init+0x138>)
 800128e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, false);
 8001290:	4b25      	ldr	r3, [pc, #148]	@ (8001328 <stm32_clock_init+0x138>)
 8001292:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8001294:	4a24      	ldr	r2, [pc, #144]	@ (8001328 <stm32_clock_init+0x138>)
 8001296:	f043 0301 	orr.w	r3, r3, #1
 800129a:	6613      	str	r3, [r2, #96]	@ 0x60
 800129c:	4b22      	ldr	r3, [pc, #136]	@ (8001328 <stm32_clock_init+0x138>)
 800129e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 80012a2:	4a21      	ldr	r2, [pc, #132]	@ (8001328 <stm32_clock_init+0x138>)
 80012a4:	f023 0301 	bic.w	r3, r3, #1
 80012a8:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 80012ac:	4b1e      	ldr	r3, [pc, #120]	@ (8001328 <stm32_clock_init+0x138>)
 80012ae:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
#if (HAL_USE_RTC == TRUE) && defined(RCC_APB1ENR1_RTCAPBEN)
  rccEnableAPB1R1(RCC_APB1ENR1_RTCAPBEN, true)
#endif

  /* Static PWR configurations.*/
  hal_lld_set_static_pwr();
 80012b2:	f7ff ff2d 	bl	8001110 <hal_lld_set_static_pwr>

  /* Additional PWR configurations.*/
  PWR->CR2 = STM32_PWR_CR2;
 80012b6:	4b1d      	ldr	r3, [pc, #116]	@ (800132c <stm32_clock_init+0x13c>)
 80012b8:	2200      	movs	r2, #0
 80012ba:	605a      	str	r2, [r3, #4]
  PWR->CR5 = STM32_CR5BITS;
 80012bc:	4b1b      	ldr	r3, [pc, #108]	@ (800132c <stm32_clock_init+0x13c>)
 80012be:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80012c2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  /* Core voltage setup, backup domain made accessible.*/
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 80012c6:	4b19      	ldr	r3, [pc, #100]	@ (800132c <stm32_clock_init+0x13c>)
 80012c8:	f44f 7240 	mov.w	r2, #768	@ 0x300
 80012cc:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 80012ce:	bf00      	nop
 80012d0:	4b16      	ldr	r3, [pc, #88]	@ (800132c <stm32_clock_init+0x13c>)
 80012d2:	695b      	ldr	r3, [r3, #20]
 80012d4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80012d8:	2b00      	cmp	r3, #0
 80012da:	d1f9      	bne.n	80012d0 <stm32_clock_init+0xe0>
    ;                                       /* stable.                      */

  /* Backup domain reset.*/
  bd_reset();
 80012dc:	f7ff fee8 	bl	80010b0 <bd_reset>

  /* Clocks setup.*/
  lse_init();
 80012e0:	f7ff fe16 	bl	8000f10 <lse_init>
  lsi_init();
 80012e4:	f7ff fe2c 	bl	8000f40 <lsi_init>
  hsi16_init();
 80012e8:	f7ff fe4a 	bl	8000f80 <hsi16_init>
  hsi48_init();
 80012ec:	f7ff fe68 	bl	8000fc0 <hsi48_init>
  hse_init();
 80012f0:	f7ff fe86 	bl	8001000 <hse_init>

  /* Backup domain initializations.*/
  bd_init();
 80012f4:	f7ff fec4 	bl	8001080 <bd_init>

  /* PLLs activation, if required.*/
  pll_init();
 80012f8:	f7ff feaa 	bl	8001050 <pll_init>

  /* Static clocks setup.*/
  hal_lld_set_static_clocks();
 80012fc:	f7ff ff50 	bl	80011a0 <hal_lld_set_static_clocks>

  /* Set flash WS's for SYSCLK source.*/
  flash_set_acr(FLASH_ACR_DBG_SWEN | FLASH_ACR_DCEN | FLASH_ACR_ICEN   |
 8001300:	480b      	ldr	r0, [pc, #44]	@ (8001330 <stm32_clock_init+0x140>)
 8001302:	f7ff feed 	bl	80010e0 <flash_set_acr>
                FLASH_ACR_PRFTEN   | STM32_FLASHBITS);

  /* Switching to the configured SYSCLK source if it is different from HSI16.*/
#if STM32_SW != STM32_SW_HSI16
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001306:	4b08      	ldr	r3, [pc, #32]	@ (8001328 <stm32_clock_init+0x138>)
 8001308:	689b      	ldr	r3, [r3, #8]
 800130a:	4a07      	ldr	r2, [pc, #28]	@ (8001328 <stm32_clock_init+0x138>)
 800130c:	f043 0303 	orr.w	r3, r3, #3
 8001310:	6093      	str	r3, [r2, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001312:	bf00      	nop
 8001314:	4b04      	ldr	r3, [pc, #16]	@ (8001328 <stm32_clock_init+0x138>)
 8001316:	689b      	ldr	r3, [r3, #8]
 8001318:	f003 030c 	and.w	r3, r3, #12
 800131c:	2b0c      	cmp	r3, #12
 800131e:	d1f9      	bne.n	8001314 <stm32_clock_init+0x124>
    ;
#endif

#endif /* STM32_NO_INIT */
}
 8001320:	bf00      	nop
 8001322:	bf00      	nop
 8001324:	bd08      	pop	{r3, pc}
 8001326:	bf00      	nop
 8001328:	40021000 	.word	0x40021000
 800132c:	40007000 	.word	0x40007000
 8001330:	00040704 	.word	0x00040704
	...

08001340 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001340:	b500      	push	{lr}
 8001342:	b083      	sub	sp, #12
 8001344:	2330      	movs	r3, #48	@ 0x30
 8001346:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001348:	9b01      	ldr	r3, [sp, #4]
 800134a:	f383 8811 	msr	BASEPRI, r3
}
 800134e:	bf00      	nop
}
 8001350:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 8001352:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 8001354:	f001 fbc4 	bl	8002ae0 <__dbg_check_lock_from_isr>
}
 8001358:	bf00      	nop
 800135a:	b003      	add	sp, #12
 800135c:	f85d fb04 	ldr.w	pc, [sp], #4

08001360 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001360:	b500      	push	{lr}
 8001362:	b083      	sub	sp, #12

  __dbg_check_unlock_from_isr();
 8001364:	f001 fbe4 	bl	8002b30 <__dbg_check_unlock_from_isr>
 8001368:	2300      	movs	r3, #0
 800136a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800136c:	9b01      	ldr	r3, [sp, #4]
 800136e:	f383 8811 	msr	BASEPRI, r3
}
 8001372:	bf00      	nop
}
 8001374:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 8001376:	bf00      	nop
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 8001378:	bf00      	nop
 800137a:	b003      	add	sp, #12
 800137c:	f85d fb04 	ldr.w	pc, [sp], #4

08001380 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 8001380:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8001382:	f7ff ffdd 	bl	8001340 <chSysLockFromISR.lto_priv.0>
}
 8001386:	bf00      	nop
 8001388:	bd08      	pop	{r3, pc}
 800138a:	bf00      	nop
 800138c:	0000      	movs	r0, r0
	...

08001390 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 8001390:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8001392:	f7ff ffe5 	bl	8001360 <chSysUnlockFromISR.lto_priv.0>
}
 8001396:	bf00      	nop
 8001398:	bd08      	pop	{r3, pc}
 800139a:	bf00      	nop
 800139c:	0000      	movs	r0, r0
	...

080013a0 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 80013a0:	b500      	push	{lr}
 80013a2:	b083      	sub	sp, #12
 80013a4:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 80013a6:	9801      	ldr	r0, [sp, #4]
 80013a8:	f001 fb1a 	bl	80029e0 <chSysPolledDelayX>
}
 80013ac:	bf00      	nop
 80013ae:	b003      	add	sp, #12
 80013b0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080013c0 <osalThreadResumeI.lto_priv.1>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80013c0:	b500      	push	{lr}
 80013c2:	b083      	sub	sp, #12
 80013c4:	9001      	str	r0, [sp, #4]
 80013c6:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 80013c8:	9900      	ldr	r1, [sp, #0]
 80013ca:	9801      	ldr	r0, [sp, #4]
 80013cc:	f002 ff28 	bl	8004220 <chThdResumeI>
}
 80013d0:	bf00      	nop
 80013d2:	b003      	add	sp, #12
 80013d4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080013e0 <adc_lld_vreg_on>:
/**
 * @brief   Enables the ADC voltage regulator.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {
 80013e0:	b500      	push	{lr}
 80013e2:	b083      	sub	sp, #12
 80013e4:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR = 0;   /* See RM.*/
 80013e6:	9b01      	ldr	r3, [sp, #4]
 80013e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013ea:	2200      	movs	r2, #0
 80013ec:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN;
 80013ee:	9b01      	ldr	r3, [sp, #4]
 80013f0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013f2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80013f6:	609a      	str	r2, [r3, #8]
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR = STM32_ADC_CR_ADVREGEN;
#endif
  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 80013f8:	f640 5048 	movw	r0, #3400	@ 0xd48
 80013fc:	f7ff ffd0 	bl	80013a0 <osalSysPolledDelayX>
}
 8001400:	bf00      	nop
 8001402:	b003      	add	sp, #12
 8001404:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001410 <adc_lld_calibrate>:
/**
 * @brief   Calibrates an ADC unit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_calibrate(ADCDriver *adcp) {
 8001410:	b500      	push	{lr}
 8001412:	b083      	sub	sp, #12
 8001414:	9001      	str	r0, [sp, #4]

  osalDbgAssert(adcp->adcm->CR == STM32_ADC_CR_ADVREGEN, "invalid register state");
 8001416:	9b01      	ldr	r3, [sp, #4]
 8001418:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800141a:	689b      	ldr	r3, [r3, #8]
 800141c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8001420:	bf14      	ite	ne
 8001422:	2301      	movne	r3, #1
 8001424:	2300      	moveq	r3, #0
 8001426:	b2db      	uxtb	r3, r3
 8001428:	2b00      	cmp	r3, #0
 800142a:	d002      	beq.n	8001432 <adc_lld_calibrate+0x22>
 800142c:	4817      	ldr	r0, [pc, #92]	@ (800148c <adc_lld_calibrate+0x7c>)
 800142e:	f001 fa7f 	bl	8002930 <chSysHalt>

  /* Differential calibration for master ADC.*/
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCALDIF;
 8001432:	9b01      	ldr	r3, [sp, #4]
 8001434:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001436:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 800143a:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCALDIF | ADC_CR_ADCAL;
 800143c:	9b01      	ldr	r3, [sp, #4]
 800143e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001440:	f04f 4250 	mov.w	r2, #3489660928	@ 0xd0000000
 8001444:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 8001446:	bf00      	nop
 8001448:	9b01      	ldr	r3, [sp, #4]
 800144a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800144c:	689b      	ldr	r3, [r3, #8]
 800144e:	2b00      	cmp	r3, #0
 8001450:	dbfa      	blt.n	8001448 <adc_lld_calibrate+0x38>
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 8001452:	f640 5048 	movw	r0, #3400	@ 0xd48
 8001456:	f7ff ffa3 	bl	80013a0 <osalSysPolledDelayX>

  /* Single-ended calibration for master ADC.*/
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN;
 800145a:	9b01      	ldr	r3, [sp, #4]
 800145c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800145e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8001462:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCAL;
 8001464:	9b01      	ldr	r3, [sp, #4]
 8001466:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001468:	f04f 4210 	mov.w	r2, #2415919104	@ 0x90000000
 800146c:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 800146e:	bf00      	nop
 8001470:	9b01      	ldr	r3, [sp, #4]
 8001472:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001474:	689b      	ldr	r3, [r3, #8]
 8001476:	2b00      	cmp	r3, #0
 8001478:	dbfa      	blt.n	8001470 <adc_lld_calibrate+0x60>
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 800147a:	f640 5048 	movw	r0, #3400	@ 0xd48
 800147e:	f7ff ff8f 	bl	80013a0 <osalSysPolledDelayX>
  while ((adcp->adcs->CR & ADC_CR_ADCAL) != 0)
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
#endif
}
 8001482:	bf00      	nop
 8001484:	b003      	add	sp, #12
 8001486:	f85d fb04 	ldr.w	pc, [sp], #4
 800148a:	bf00      	nop
 800148c:	08005348 	.word	0x08005348

08001490 <adc_lld_analog_on>:
/**
 * @brief   Enables the ADC analog circuit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_analog_on(ADCDriver *adcp) {
 8001490:	b082      	sub	sp, #8
 8001492:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR |= ADC_CR_ADEN;
 8001494:	9b01      	ldr	r3, [sp, #4]
 8001496:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001498:	689a      	ldr	r2, [r3, #8]
 800149a:	9b01      	ldr	r3, [sp, #4]
 800149c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800149e:	f042 0201 	orr.w	r2, r2, #1
 80014a2:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRDY) == 0)
 80014a4:	bf00      	nop
 80014a6:	9b01      	ldr	r3, [sp, #4]
 80014a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014aa:	681b      	ldr	r3, [r3, #0]
 80014ac:	f003 0301 	and.w	r3, r3, #1
 80014b0:	2b00      	cmp	r3, #0
 80014b2:	d0f8      	beq.n	80014a6 <adc_lld_analog_on+0x16>
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR |= ADC_CR_ADEN;
  while ((adcp->adcs->ISR & ADC_ISR_ADRDY) == 0)
    ;
#endif
}
 80014b4:	bf00      	nop
 80014b6:	bf00      	nop
 80014b8:	b002      	add	sp, #8
 80014ba:	4770      	bx	lr
 80014bc:	0000      	movs	r0, r0
	...

080014c0 <adc_lld_stop_adc>:
/**
 * @brief   Stops an ongoing conversion, if any.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_stop_adc(ADCDriver *adcp) {
 80014c0:	b082      	sub	sp, #8
 80014c2:	9001      	str	r0, [sp, #4]

  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 80014c4:	9b01      	ldr	r3, [sp, #4]
 80014c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014c8:	689b      	ldr	r3, [r3, #8]
 80014ca:	f003 0304 	and.w	r3, r3, #4
 80014ce:	2b00      	cmp	r3, #0
 80014d0:	d013      	beq.n	80014fa <adc_lld_stop_adc+0x3a>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 80014d2:	9b01      	ldr	r3, [sp, #4]
 80014d4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014d6:	689a      	ldr	r2, [r3, #8]
 80014d8:	9b01      	ldr	r3, [sp, #4]
 80014da:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014dc:	f042 0210 	orr.w	r2, r2, #16
 80014e0:	609a      	str	r2, [r3, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 80014e2:	bf00      	nop
 80014e4:	9b01      	ldr	r3, [sp, #4]
 80014e6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014e8:	689b      	ldr	r3, [r3, #8]
 80014ea:	f003 0310 	and.w	r3, r3, #16
 80014ee:	2b00      	cmp	r3, #0
 80014f0:	d1f8      	bne.n	80014e4 <adc_lld_stop_adc+0x24>
      ;
    adcp->adcm->IER = 0;
 80014f2:	9b01      	ldr	r3, [sp, #4]
 80014f4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014f6:	2200      	movs	r2, #0
 80014f8:	605a      	str	r2, [r3, #4]
  }
}
 80014fa:	bf00      	nop
 80014fc:	b002      	add	sp, #8
 80014fe:	4770      	bx	lr

08001500 <adc_lld_serve_dma_interrupt>:
 * @brief   ADC DMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001500:	b500      	push	{lr}
 8001502:	b083      	sub	sp, #12
 8001504:	9001      	str	r0, [sp, #4]
 8001506:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001508:	9b00      	ldr	r3, [sp, #0]
 800150a:	f003 0308 	and.w	r3, r3, #8
 800150e:	2b00      	cmp	r3, #0
 8001510:	d02d      	beq.n	800156e <adc_lld_serve_dma_interrupt+0x6e>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8001512:	9801      	ldr	r0, [sp, #4]
 8001514:	f000 fbe4 	bl	8001ce0 <adc_lld_stop_conversion>
 8001518:	9b01      	ldr	r3, [sp, #4]
 800151a:	691b      	ldr	r3, [r3, #16]
 800151c:	689b      	ldr	r3, [r3, #8]
 800151e:	2b00      	cmp	r3, #0
 8001520:	d013      	beq.n	800154a <adc_lld_serve_dma_interrupt+0x4a>
 8001522:	9b01      	ldr	r3, [sp, #4]
 8001524:	2205      	movs	r2, #5
 8001526:	701a      	strb	r2, [r3, #0]
 8001528:	9b01      	ldr	r3, [sp, #4]
 800152a:	691b      	ldr	r3, [r3, #16]
 800152c:	689b      	ldr	r3, [r3, #8]
 800152e:	2101      	movs	r1, #1
 8001530:	9801      	ldr	r0, [sp, #4]
 8001532:	4798      	blx	r3
 8001534:	9b01      	ldr	r3, [sp, #4]
 8001536:	781b      	ldrb	r3, [r3, #0]
 8001538:	2b05      	cmp	r3, #5
 800153a:	d10c      	bne.n	8001556 <adc_lld_serve_dma_interrupt+0x56>
 800153c:	9b01      	ldr	r3, [sp, #4]
 800153e:	2202      	movs	r2, #2
 8001540:	701a      	strb	r2, [r3, #0]
 8001542:	9b01      	ldr	r3, [sp, #4]
 8001544:	2200      	movs	r2, #0
 8001546:	611a      	str	r2, [r3, #16]
 8001548:	e005      	b.n	8001556 <adc_lld_serve_dma_interrupt+0x56>
 800154a:	9b01      	ldr	r3, [sp, #4]
 800154c:	2202      	movs	r2, #2
 800154e:	701a      	strb	r2, [r3, #0]
 8001550:	9b01      	ldr	r3, [sp, #4]
 8001552:	2200      	movs	r2, #0
 8001554:	611a      	str	r2, [r3, #16]
 8001556:	f7ff ff13 	bl	8001380 <osalSysLockFromISR.lto_priv.0>
 800155a:	9b01      	ldr	r3, [sp, #4]
 800155c:	3314      	adds	r3, #20
 800155e:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8001562:	4618      	mov	r0, r3
 8001564:	f7ff ff2c 	bl	80013c0 <osalThreadResumeI.lto_priv.1>
 8001568:	f7ff ff12 	bl	8001390 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800156c:	e05d      	b.n	800162a <adc_lld_serve_dma_interrupt+0x12a>
    if (adcp->grpp != NULL) {
 800156e:	9b01      	ldr	r3, [sp, #4]
 8001570:	691b      	ldr	r3, [r3, #16]
 8001572:	2b00      	cmp	r3, #0
 8001574:	d059      	beq.n	800162a <adc_lld_serve_dma_interrupt+0x12a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8001576:	9b00      	ldr	r3, [sp, #0]
 8001578:	f003 0302 	and.w	r3, r3, #2
 800157c:	2b00      	cmp	r3, #0
 800157e:	d045      	beq.n	800160c <adc_lld_serve_dma_interrupt+0x10c>
        _adc_isr_full_code(adcp);
 8001580:	9b01      	ldr	r3, [sp, #4]
 8001582:	691b      	ldr	r3, [r3, #16]
 8001584:	781b      	ldrb	r3, [r3, #0]
 8001586:	2b00      	cmp	r3, #0
 8001588:	d014      	beq.n	80015b4 <adc_lld_serve_dma_interrupt+0xb4>
 800158a:	9b01      	ldr	r3, [sp, #4]
 800158c:	691b      	ldr	r3, [r3, #16]
 800158e:	685b      	ldr	r3, [r3, #4]
 8001590:	2b00      	cmp	r3, #0
 8001592:	d04a      	beq.n	800162a <adc_lld_serve_dma_interrupt+0x12a>
 8001594:	9b01      	ldr	r3, [sp, #4]
 8001596:	2204      	movs	r2, #4
 8001598:	701a      	strb	r2, [r3, #0]
 800159a:	9b01      	ldr	r3, [sp, #4]
 800159c:	691b      	ldr	r3, [r3, #16]
 800159e:	685b      	ldr	r3, [r3, #4]
 80015a0:	9801      	ldr	r0, [sp, #4]
 80015a2:	4798      	blx	r3
 80015a4:	9b01      	ldr	r3, [sp, #4]
 80015a6:	781b      	ldrb	r3, [r3, #0]
 80015a8:	2b04      	cmp	r3, #4
 80015aa:	d13e      	bne.n	800162a <adc_lld_serve_dma_interrupt+0x12a>
 80015ac:	9b01      	ldr	r3, [sp, #4]
 80015ae:	2203      	movs	r2, #3
 80015b0:	701a      	strb	r2, [r3, #0]
}
 80015b2:	e03a      	b.n	800162a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_full_code(adcp);
 80015b4:	9801      	ldr	r0, [sp, #4]
 80015b6:	f000 fb93 	bl	8001ce0 <adc_lld_stop_conversion>
 80015ba:	9b01      	ldr	r3, [sp, #4]
 80015bc:	691b      	ldr	r3, [r3, #16]
 80015be:	685b      	ldr	r3, [r3, #4]
 80015c0:	2b00      	cmp	r3, #0
 80015c2:	d012      	beq.n	80015ea <adc_lld_serve_dma_interrupt+0xea>
 80015c4:	9b01      	ldr	r3, [sp, #4]
 80015c6:	2204      	movs	r2, #4
 80015c8:	701a      	strb	r2, [r3, #0]
 80015ca:	9b01      	ldr	r3, [sp, #4]
 80015cc:	691b      	ldr	r3, [r3, #16]
 80015ce:	685b      	ldr	r3, [r3, #4]
 80015d0:	9801      	ldr	r0, [sp, #4]
 80015d2:	4798      	blx	r3
 80015d4:	9b01      	ldr	r3, [sp, #4]
 80015d6:	781b      	ldrb	r3, [r3, #0]
 80015d8:	2b04      	cmp	r3, #4
 80015da:	d10c      	bne.n	80015f6 <adc_lld_serve_dma_interrupt+0xf6>
 80015dc:	9b01      	ldr	r3, [sp, #4]
 80015de:	2202      	movs	r2, #2
 80015e0:	701a      	strb	r2, [r3, #0]
 80015e2:	9b01      	ldr	r3, [sp, #4]
 80015e4:	2200      	movs	r2, #0
 80015e6:	611a      	str	r2, [r3, #16]
 80015e8:	e005      	b.n	80015f6 <adc_lld_serve_dma_interrupt+0xf6>
 80015ea:	9b01      	ldr	r3, [sp, #4]
 80015ec:	2202      	movs	r2, #2
 80015ee:	701a      	strb	r2, [r3, #0]
 80015f0:	9b01      	ldr	r3, [sp, #4]
 80015f2:	2200      	movs	r2, #0
 80015f4:	611a      	str	r2, [r3, #16]
 80015f6:	f7ff fec3 	bl	8001380 <osalSysLockFromISR.lto_priv.0>
 80015fa:	9b01      	ldr	r3, [sp, #4]
 80015fc:	3314      	adds	r3, #20
 80015fe:	2100      	movs	r1, #0
 8001600:	4618      	mov	r0, r3
 8001602:	f7ff fedd 	bl	80013c0 <osalThreadResumeI.lto_priv.1>
 8001606:	f7ff fec3 	bl	8001390 <osalSysUnlockFromISR.lto_priv.0>
}
 800160a:	e00e      	b.n	800162a <adc_lld_serve_dma_interrupt+0x12a>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 800160c:	9b00      	ldr	r3, [sp, #0]
 800160e:	f003 0304 	and.w	r3, r3, #4
 8001612:	2b00      	cmp	r3, #0
 8001614:	d009      	beq.n	800162a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_half_code(adcp);
 8001616:	9b01      	ldr	r3, [sp, #4]
 8001618:	691b      	ldr	r3, [r3, #16]
 800161a:	685b      	ldr	r3, [r3, #4]
 800161c:	2b00      	cmp	r3, #0
 800161e:	d004      	beq.n	800162a <adc_lld_serve_dma_interrupt+0x12a>
 8001620:	9b01      	ldr	r3, [sp, #4]
 8001622:	691b      	ldr	r3, [r3, #16]
 8001624:	685b      	ldr	r3, [r3, #4]
 8001626:	9801      	ldr	r0, [sp, #4]
 8001628:	4798      	blx	r3
}
 800162a:	bf00      	nop
 800162c:	b003      	add	sp, #12
 800162e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001632:	bf00      	nop
	...

08001640 <adc_lld_serve_interrupt>:
 * @brief   ADC IRQ service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] isr       content of the ISR register
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 8001640:	b500      	push	{lr}
 8001642:	b085      	sub	sp, #20
 8001644:	9001      	str	r0, [sp, #4]
 8001646:	9100      	str	r1, [sp, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8001648:	9b01      	ldr	r3, [sp, #4]
 800164a:	691b      	ldr	r3, [r3, #16]
 800164c:	2b00      	cmp	r3, #0
 800164e:	d059      	beq.n	8001704 <adc_lld_serve_interrupt+0xc4>
    adcerror_t emask = 0U;
 8001650:	2300      	movs	r3, #0
 8001652:	9303      	str	r3, [sp, #12]

    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the state is checked too.*/
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8001654:	9b00      	ldr	r3, [sp, #0]
 8001656:	f003 0310 	and.w	r3, r3, #16
 800165a:	2b00      	cmp	r3, #0
 800165c:	d007      	beq.n	800166e <adc_lld_serve_interrupt+0x2e>
 800165e:	9b01      	ldr	r3, [sp, #4]
 8001660:	781b      	ldrb	r3, [r3, #0]
 8001662:	2b03      	cmp	r3, #3
 8001664:	d103      	bne.n	800166e <adc_lld_serve_interrupt+0x2e>
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
 8001666:	9b03      	ldr	r3, [sp, #12]
 8001668:	f043 0302 	orr.w	r3, r3, #2
 800166c:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD1) {
 800166e:	9b00      	ldr	r3, [sp, #0]
 8001670:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8001674:	2b00      	cmp	r3, #0
 8001676:	d003      	beq.n	8001680 <adc_lld_serve_interrupt+0x40>
      /* Analog watchdog 1 error.*/
      emask |= ADC_ERR_AWD1;
 8001678:	9b03      	ldr	r3, [sp, #12]
 800167a:	f043 0304 	orr.w	r3, r3, #4
 800167e:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD2) {
 8001680:	9b00      	ldr	r3, [sp, #0]
 8001682:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8001686:	2b00      	cmp	r3, #0
 8001688:	d003      	beq.n	8001692 <adc_lld_serve_interrupt+0x52>
      /* Analog watchdog 2 error.*/
      emask |= ADC_ERR_AWD2;
 800168a:	9b03      	ldr	r3, [sp, #12]
 800168c:	f043 0308 	orr.w	r3, r3, #8
 8001690:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD3) {
 8001692:	9b00      	ldr	r3, [sp, #0]
 8001694:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8001698:	2b00      	cmp	r3, #0
 800169a:	d003      	beq.n	80016a4 <adc_lld_serve_interrupt+0x64>
      /* Analog watchdog 3 error.*/
      emask |= ADC_ERR_AWD3;
 800169c:	9b03      	ldr	r3, [sp, #12]
 800169e:	f043 0310 	orr.w	r3, r3, #16
 80016a2:	9303      	str	r3, [sp, #12]
    }
    if (emask != 0U) {
 80016a4:	9b03      	ldr	r3, [sp, #12]
 80016a6:	2b00      	cmp	r3, #0
 80016a8:	d02c      	beq.n	8001704 <adc_lld_serve_interrupt+0xc4>
      _adc_isr_error_code(adcp, emask);
 80016aa:	9801      	ldr	r0, [sp, #4]
 80016ac:	f000 fb18 	bl	8001ce0 <adc_lld_stop_conversion>
 80016b0:	9b01      	ldr	r3, [sp, #4]
 80016b2:	691b      	ldr	r3, [r3, #16]
 80016b4:	689b      	ldr	r3, [r3, #8]
 80016b6:	2b00      	cmp	r3, #0
 80016b8:	d013      	beq.n	80016e2 <adc_lld_serve_interrupt+0xa2>
 80016ba:	9b01      	ldr	r3, [sp, #4]
 80016bc:	2205      	movs	r2, #5
 80016be:	701a      	strb	r2, [r3, #0]
 80016c0:	9b01      	ldr	r3, [sp, #4]
 80016c2:	691b      	ldr	r3, [r3, #16]
 80016c4:	689b      	ldr	r3, [r3, #8]
 80016c6:	9903      	ldr	r1, [sp, #12]
 80016c8:	9801      	ldr	r0, [sp, #4]
 80016ca:	4798      	blx	r3
 80016cc:	9b01      	ldr	r3, [sp, #4]
 80016ce:	781b      	ldrb	r3, [r3, #0]
 80016d0:	2b05      	cmp	r3, #5
 80016d2:	d10c      	bne.n	80016ee <adc_lld_serve_interrupt+0xae>
 80016d4:	9b01      	ldr	r3, [sp, #4]
 80016d6:	2202      	movs	r2, #2
 80016d8:	701a      	strb	r2, [r3, #0]
 80016da:	9b01      	ldr	r3, [sp, #4]
 80016dc:	2200      	movs	r2, #0
 80016de:	611a      	str	r2, [r3, #16]
 80016e0:	e005      	b.n	80016ee <adc_lld_serve_interrupt+0xae>
 80016e2:	9b01      	ldr	r3, [sp, #4]
 80016e4:	2202      	movs	r2, #2
 80016e6:	701a      	strb	r2, [r3, #0]
 80016e8:	9b01      	ldr	r3, [sp, #4]
 80016ea:	2200      	movs	r2, #0
 80016ec:	611a      	str	r2, [r3, #16]
 80016ee:	f7ff fe47 	bl	8001380 <osalSysLockFromISR.lto_priv.0>
 80016f2:	9b01      	ldr	r3, [sp, #4]
 80016f4:	3314      	adds	r3, #20
 80016f6:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 80016fa:	4618      	mov	r0, r3
 80016fc:	f7ff fe60 	bl	80013c0 <osalThreadResumeI.lto_priv.1>
 8001700:	f7ff fe46 	bl	8001390 <osalSysUnlockFromISR.lto_priv.0>
    }
  }
}
 8001704:	bf00      	nop
 8001706:	b005      	add	sp, #20
 8001708:	f85d fb04 	ldr.w	pc, [sp], #4
 800170c:	0000      	movs	r0, r0
	...

08001710 <Vector88>:
/**
 * @brief   ADC1/ADC2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8001710:	b500      	push	{lr}
 8001712:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 8001714:	f001 fa34 	bl	8002b80 <__dbg_check_enter_isr>
  adc_lld_serve_interrupt(&ADCD1, isr);

#else /* !STM32_ADC_DUAL_MODE */

#if STM32_ADC_USE_ADC1
  isr  = ADC1->ISR;
 8001718:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
 800171c:	681b      	ldr	r3, [r3, #0]
 800171e:	9301      	str	r3, [sp, #4]
  ADC1->ISR = isr;
 8001720:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 8001724:	9b01      	ldr	r3, [sp, #4]
 8001726:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD1, isr);
 8001728:	9901      	ldr	r1, [sp, #4]
 800172a:	480a      	ldr	r0, [pc, #40]	@ (8001754 <Vector88+0x44>)
 800172c:	f7ff ff88 	bl	8001640 <adc_lld_serve_interrupt>
#endif

#if STM32_ADC_USE_ADC2
  isr  = ADC2->ISR;
 8001730:	4b09      	ldr	r3, [pc, #36]	@ (8001758 <Vector88+0x48>)
 8001732:	681b      	ldr	r3, [r3, #0]
 8001734:	9301      	str	r3, [sp, #4]
  ADC2->ISR = isr;
 8001736:	4a08      	ldr	r2, [pc, #32]	@ (8001758 <Vector88+0x48>)
 8001738:	9b01      	ldr	r3, [sp, #4]
 800173a:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC2_IRQ_HOOK)
  STM32_ADC_ADC2_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD2, isr);
 800173c:	9901      	ldr	r1, [sp, #4]
 800173e:	4807      	ldr	r0, [pc, #28]	@ (800175c <Vector88+0x4c>)
 8001740:	f7ff ff7e 	bl	8001640 <adc_lld_serve_interrupt>
#endif

#endif /* !STM32_ADC_DUAL_MODE */

  OSAL_IRQ_EPILOGUE();
 8001744:	f001 fa54 	bl	8002bf0 <__dbg_check_leave_isr>
 8001748:	f003 fc5a 	bl	8005000 <__port_irq_epilogue>
}
 800174c:	bf00      	nop
 800174e:	b003      	add	sp, #12
 8001750:	f85d fb04 	ldr.w	pc, [sp], #4
 8001754:	20000800 	.word	0x20000800
 8001758:	50000100 	.word	0x50000100
 800175c:	20000838 	.word	0x20000838

08001760 <VectorFC>:
/**
 * @brief   ADC3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC3_HANDLER) {
 8001760:	b500      	push	{lr}
 8001762:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 8001764:	f001 fa0c 	bl	8002b80 <__dbg_check_enter_isr>

  isr  = ADC3->ISR;
 8001768:	4b08      	ldr	r3, [pc, #32]	@ (800178c <VectorFC+0x2c>)
 800176a:	681b      	ldr	r3, [r3, #0]
 800176c:	9301      	str	r3, [sp, #4]
  ADC3->ISR = isr;
 800176e:	4a07      	ldr	r2, [pc, #28]	@ (800178c <VectorFC+0x2c>)
 8001770:	9b01      	ldr	r3, [sp, #4]
 8001772:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC3_IRQ_HOOK)
  STM32_ADC_ADC3_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD3, isr);
 8001774:	9901      	ldr	r1, [sp, #4]
 8001776:	4806      	ldr	r0, [pc, #24]	@ (8001790 <VectorFC+0x30>)
 8001778:	f7ff ff62 	bl	8001640 <adc_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800177c:	f001 fa38 	bl	8002bf0 <__dbg_check_leave_isr>
 8001780:	f003 fc3e 	bl	8005000 <__port_irq_epilogue>
}
 8001784:	bf00      	nop
 8001786:	b003      	add	sp, #12
 8001788:	f85d fb04 	ldr.w	pc, [sp], #4
 800178c:	50000400 	.word	0x50000400
 8001790:	20000870 	.word	0x20000870
	...

080017a0 <Vector134>:
/**
 * @brief   ADC4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC4_HANDLER) {
 80017a0:	b500      	push	{lr}
 80017a2:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 80017a4:	f001 f9ec 	bl	8002b80 <__dbg_check_enter_isr>

  isr  = ADC4->ISR;
 80017a8:	4b08      	ldr	r3, [pc, #32]	@ (80017cc <Vector134+0x2c>)
 80017aa:	681b      	ldr	r3, [r3, #0]
 80017ac:	9301      	str	r3, [sp, #4]
  ADC4->ISR = isr;
 80017ae:	4a07      	ldr	r2, [pc, #28]	@ (80017cc <Vector134+0x2c>)
 80017b0:	9b01      	ldr	r3, [sp, #4]
 80017b2:	6013      	str	r3, [r2, #0]

  adc_lld_serve_interrupt(&ADCD4, isr);
 80017b4:	9901      	ldr	r1, [sp, #4]
 80017b6:	4806      	ldr	r0, [pc, #24]	@ (80017d0 <Vector134+0x30>)
 80017b8:	f7ff ff42 	bl	8001640 <adc_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80017bc:	f001 fa18 	bl	8002bf0 <__dbg_check_leave_isr>
 80017c0:	f003 fc1e 	bl	8005000 <__port_irq_epilogue>
}
 80017c4:	bf00      	nop
 80017c6:	b003      	add	sp, #12
 80017c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80017cc:	50000500 	.word	0x50000500
 80017d0:	200008a8 	.word	0x200008a8
	...

080017e0 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 80017e0:	b508      	push	{r3, lr}

  clkmask = 0;
 80017e2:	4b57      	ldr	r3, [pc, #348]	@ (8001940 <adc_lld_init+0x160>)
 80017e4:	2200      	movs	r2, #0
 80017e6:	601a      	str	r2, [r3, #0]

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 80017e8:	4856      	ldr	r0, [pc, #344]	@ (8001944 <adc_lld_init+0x164>)
 80017ea:	f7fe ff19 	bl	8000620 <adcObjectInit>
#if defined(ADC1_2_COMMON)
  ADCD1.adcc = ADC1_2_COMMON;
#elif defined(ADC12_COMMON)
  ADCD1.adcc = ADC12_COMMON;
 80017ee:	4b55      	ldr	r3, [pc, #340]	@ (8001944 <adc_lld_init+0x164>)
 80017f0:	4a55      	ldr	r2, [pc, #340]	@ (8001948 <adc_lld_init+0x168>)
 80017f2:	62da      	str	r2, [r3, #44]	@ 0x2c
#elif defined(ADC123_COMMON)
  ADCD1.adcc = ADC123_COMMON;
#else
  ADCD1.adcc = ADC1_COMMON;
#endif
  ADCD1.adcm    = ADC1;
 80017f4:	4b53      	ldr	r3, [pc, #332]	@ (8001944 <adc_lld_init+0x164>)
 80017f6:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 80017fa:	629a      	str	r2, [r3, #40]	@ 0x28
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs    = ADC2;
#endif
  ADCD1.dmastp  = NULL;
 80017fc:	4b51      	ldr	r3, [pc, #324]	@ (8001944 <adc_lld_init+0x164>)
 80017fe:	2200      	movs	r2, #0
 8001800:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD1.dmamode = ADC_DMA_SIZE |
 8001802:	4b50      	ldr	r3, [pc, #320]	@ (8001944 <adc_lld_init+0x164>)
 8001804:	f242 528a 	movw	r2, #9610	@ 0x258a
 8001808:	635a      	str	r2, [r3, #52]	@ 0x34
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
  /* Driver initialization.*/
  adcObjectInit(&ADCD2);
 800180a:	4850      	ldr	r0, [pc, #320]	@ (800194c <adc_lld_init+0x16c>)
 800180c:	f7fe ff08 	bl	8000620 <adcObjectInit>
#if defined(ADC1_2_COMMON)
  ADCD2.adcc = ADC1_2_COMMON;
#elif defined(ADC12_COMMON)
  ADCD2.adcc = ADC12_COMMON;
 8001810:	4b4e      	ldr	r3, [pc, #312]	@ (800194c <adc_lld_init+0x16c>)
 8001812:	4a4d      	ldr	r2, [pc, #308]	@ (8001948 <adc_lld_init+0x168>)
 8001814:	62da      	str	r2, [r3, #44]	@ 0x2c
#elif defined(ADC123_COMMON)
  ADCD2.adcc = ADC123_COMMON;
#endif
  ADCD2.adcm    = ADC2;
 8001816:	4b4d      	ldr	r3, [pc, #308]	@ (800194c <adc_lld_init+0x16c>)
 8001818:	4a4d      	ldr	r2, [pc, #308]	@ (8001950 <adc_lld_init+0x170>)
 800181a:	629a      	str	r2, [r3, #40]	@ 0x28
  ADCD2.dmastp  = NULL;
 800181c:	4b4b      	ldr	r3, [pc, #300]	@ (800194c <adc_lld_init+0x16c>)
 800181e:	2200      	movs	r2, #0
 8001820:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD2.dmamode = ADC_DMA_SIZE |
 8001822:	4b4a      	ldr	r3, [pc, #296]	@ (800194c <adc_lld_init+0x16c>)
 8001824:	f242 528a 	movw	r2, #9610	@ 0x258a
 8001828:	635a      	str	r2, [r3, #52]	@ 0x34
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
 800182a:	484a      	ldr	r0, [pc, #296]	@ (8001954 <adc_lld_init+0x174>)
 800182c:	f7fe fef8 	bl	8000620 <adcObjectInit>
#if defined(ADC3_4_COMMON)
  ADCD3.adcc = ADC3_4_COMMON;
#elif defined(ADC345_COMMON)
  ADCD3.adcc = ADC345_COMMON;
 8001830:	4b48      	ldr	r3, [pc, #288]	@ (8001954 <adc_lld_init+0x174>)
 8001832:	4a49      	ldr	r2, [pc, #292]	@ (8001958 <adc_lld_init+0x178>)
 8001834:	62da      	str	r2, [r3, #44]	@ 0x2c
#elif defined(ADC123_COMMON)
  ADCD3.adcc = ADC123_COMMON;
#else
  ADCD3.adcc = ADC3_COMMON;
#endif
  ADCD3.adcm    = ADC3;
 8001836:	4b47      	ldr	r3, [pc, #284]	@ (8001954 <adc_lld_init+0x174>)
 8001838:	4a48      	ldr	r2, [pc, #288]	@ (800195c <adc_lld_init+0x17c>)
 800183a:	629a      	str	r2, [r3, #40]	@ 0x28
#if STM32_ADC_DUAL_MODE
  ADCD3.adcs    = ADC4;
#endif
  ADCD3.dmastp  = NULL;
 800183c:	4b45      	ldr	r3, [pc, #276]	@ (8001954 <adc_lld_init+0x174>)
 800183e:	2200      	movs	r2, #0
 8001840:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD3.dmamode = ADC_DMA_SIZE |
 8001842:	4b44      	ldr	r3, [pc, #272]	@ (8001954 <adc_lld_init+0x174>)
 8001844:	f242 528a 	movw	r2, #9610	@ 0x258a
 8001848:	635a      	str	r2, [r3, #52]	@ 0x34
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif /* STM32_ADC_USE_ADC3 */

#if STM32_ADC_USE_ADC4
  /* Driver initialization.*/
  adcObjectInit(&ADCD4);
 800184a:	4845      	ldr	r0, [pc, #276]	@ (8001960 <adc_lld_init+0x180>)
 800184c:	f7fe fee8 	bl	8000620 <adcObjectInit>
#if defined(ADC3_4_COMMON)
  ADCD4.adcc = ADC3_4_COMMON;
#elif defined(ADC345_COMMON)
  ADCD4.adcc = ADC345_COMMON;
 8001850:	4b43      	ldr	r3, [pc, #268]	@ (8001960 <adc_lld_init+0x180>)
 8001852:	4a41      	ldr	r2, [pc, #260]	@ (8001958 <adc_lld_init+0x178>)
 8001854:	62da      	str	r2, [r3, #44]	@ 0x2c
#endif
  ADCD4.adcm    = ADC4;
 8001856:	4b42      	ldr	r3, [pc, #264]	@ (8001960 <adc_lld_init+0x180>)
 8001858:	4a42      	ldr	r2, [pc, #264]	@ (8001964 <adc_lld_init+0x184>)
 800185a:	629a      	str	r2, [r3, #40]	@ 0x28
  ADCD4.dmastp  = NULL;
 800185c:	4b40      	ldr	r3, [pc, #256]	@ (8001960 <adc_lld_init+0x180>)
 800185e:	2200      	movs	r2, #0
 8001860:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD4.dmamode = ADC_DMA_SIZE |
 8001862:	4b3f      	ldr	r3, [pc, #252]	@ (8001960 <adc_lld_init+0x180>)
 8001864:	f242 528a 	movw	r2, #9610	@ 0x258a
 8001868:	635a      	str	r2, [r3, #52]	@ 0x34
  /* IRQs setup.*/
#if STM32_ADC_USE_ADC1 || STM32_ADC_USE_ADC2
#if defined(STM32_ADC_ADC1_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC1_IRQ_PRIORITY);
#elif defined(STM32_ADC_ADC12_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 800186a:	2105      	movs	r1, #5
 800186c:	2012      	movs	r0, #18
 800186e:	f7ff f9b7 	bl	8000be0 <nvicEnableVector>
#endif
#endif
#if STM32_ADC_USE_ADC3
  nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
 8001872:	2105      	movs	r1, #5
 8001874:	202f      	movs	r0, #47	@ 0x2f
 8001876:	f7ff f9b3 	bl	8000be0 <nvicEnableVector>
#if STM32_ADC_DUAL_MODE
  nvicEnableVector(STM32_ADC4_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
#endif
#endif
#if STM32_ADC_USE_ADC4
  nvicEnableVector(STM32_ADC4_NUMBER, STM32_ADC_ADC4_IRQ_PRIORITY);
 800187a:	2105      	movs	r1, #5
 800187c:	203d      	movs	r0, #61	@ 0x3d
 800187e:	f7ff f9af 	bl	8000be0 <nvicEnableVector>
  rccDisableADC123();
#endif

#if defined(STM32G4XX)
#if STM32_ADC_USE_ADC1 || STM32_ADC_USE_ADC2
  rccResetADC12();
 8001882:	4b39      	ldr	r3, [pc, #228]	@ (8001968 <adc_lld_init+0x188>)
 8001884:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001886:	4a38      	ldr	r2, [pc, #224]	@ (8001968 <adc_lld_init+0x188>)
 8001888:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800188c:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800188e:	4b36      	ldr	r3, [pc, #216]	@ (8001968 <adc_lld_init+0x188>)
 8001890:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001892:	4a35      	ldr	r2, [pc, #212]	@ (8001968 <adc_lld_init+0x188>)
 8001894:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 8001898:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800189a:	4b33      	ldr	r3, [pc, #204]	@ (8001968 <adc_lld_init+0x188>)
 800189c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableADC12(true);
 800189e:	4b32      	ldr	r3, [pc, #200]	@ (8001968 <adc_lld_init+0x188>)
 80018a0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80018a2:	4a31      	ldr	r2, [pc, #196]	@ (8001968 <adc_lld_init+0x188>)
 80018a4:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80018a8:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80018aa:	4b2f      	ldr	r3, [pc, #188]	@ (8001968 <adc_lld_init+0x188>)
 80018ac:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80018ae:	4a2e      	ldr	r2, [pc, #184]	@ (8001968 <adc_lld_init+0x188>)
 80018b0:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80018b4:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80018b6:	4b2c      	ldr	r3, [pc, #176]	@ (8001968 <adc_lld_init+0x188>)
 80018b8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
  ADC12_COMMON->CCR = STM32_ADC_ADC12_PRESC | STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_MDMA;
 80018ba:	4b23      	ldr	r3, [pc, #140]	@ (8001948 <adc_lld_init+0x168>)
 80018bc:	f44f 22e0 	mov.w	r2, #458752	@ 0x70000
 80018c0:	609a      	str	r2, [r3, #8]
  rccDisableADC12();
 80018c2:	4b29      	ldr	r3, [pc, #164]	@ (8001968 <adc_lld_init+0x188>)
 80018c4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80018c6:	4a28      	ldr	r2, [pc, #160]	@ (8001968 <adc_lld_init+0x188>)
 80018c8:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80018cc:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80018ce:	4b26      	ldr	r3, [pc, #152]	@ (8001968 <adc_lld_init+0x188>)
 80018d0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80018d2:	4a25      	ldr	r2, [pc, #148]	@ (8001968 <adc_lld_init+0x188>)
 80018d4:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80018d8:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80018da:	4b23      	ldr	r3, [pc, #140]	@ (8001968 <adc_lld_init+0x188>)
 80018dc:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
#if STM32_ADC_USE_ADC3 || STM32_ADC_USE_ADC4 || STM32_ADC_USE_ADC5
  rccEnableADC345(true);
 80018de:	4b22      	ldr	r3, [pc, #136]	@ (8001968 <adc_lld_init+0x188>)
 80018e0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80018e2:	4a21      	ldr	r2, [pc, #132]	@ (8001968 <adc_lld_init+0x188>)
 80018e4:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80018e8:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80018ea:	4b1f      	ldr	r3, [pc, #124]	@ (8001968 <adc_lld_init+0x188>)
 80018ec:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80018ee:	4a1e      	ldr	r2, [pc, #120]	@ (8001968 <adc_lld_init+0x188>)
 80018f0:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80018f4:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80018f6:	4b1c      	ldr	r3, [pc, #112]	@ (8001968 <adc_lld_init+0x188>)
 80018f8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
  rccResetADC345();
 80018fa:	4b1b      	ldr	r3, [pc, #108]	@ (8001968 <adc_lld_init+0x188>)
 80018fc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80018fe:	4a1a      	ldr	r2, [pc, #104]	@ (8001968 <adc_lld_init+0x188>)
 8001900:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001904:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001906:	4b18      	ldr	r3, [pc, #96]	@ (8001968 <adc_lld_init+0x188>)
 8001908:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800190a:	4a17      	ldr	r2, [pc, #92]	@ (8001968 <adc_lld_init+0x188>)
 800190c:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8001910:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001912:	4b15      	ldr	r3, [pc, #84]	@ (8001968 <adc_lld_init+0x188>)
 8001914:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  ADC345_COMMON->CCR = STM32_ADC_ADC345_PRESC | STM32_ADC_ADC345_CLOCK_MODE | ADC_DMA_MDMA;
 8001916:	4b10      	ldr	r3, [pc, #64]	@ (8001958 <adc_lld_init+0x178>)
 8001918:	f44f 22e0 	mov.w	r2, #458752	@ 0x70000
 800191c:	609a      	str	r2, [r3, #8]
  rccDisableADC345();
 800191e:	4b12      	ldr	r3, [pc, #72]	@ (8001968 <adc_lld_init+0x188>)
 8001920:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001922:	4a11      	ldr	r2, [pc, #68]	@ (8001968 <adc_lld_init+0x188>)
 8001924:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8001928:	64d3      	str	r3, [r2, #76]	@ 0x4c
 800192a:	4b0f      	ldr	r3, [pc, #60]	@ (8001968 <adc_lld_init+0x188>)
 800192c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800192e:	4a0e      	ldr	r2, [pc, #56]	@ (8001968 <adc_lld_init+0x188>)
 8001930:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8001934:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8001936:	4b0c      	ldr	r3, [pc, #48]	@ (8001968 <adc_lld_init+0x188>)
 8001938:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
  rccEnableADC1(true);
  ADC1_COMMON->CCR = STM32_ADC_ADC1_PRESC | STM32_ADC_ADC1_CLOCK_MODE;
  rccDisableADC1();
#endif
#endif
}
 800193a:	bf00      	nop
 800193c:	bd08      	pop	{r3, pc}
 800193e:	bf00      	nop
 8001940:	200008e0 	.word	0x200008e0
 8001944:	20000800 	.word	0x20000800
 8001948:	50000300 	.word	0x50000300
 800194c:	20000838 	.word	0x20000838
 8001950:	50000100 	.word	0x50000100
 8001954:	20000870 	.word	0x20000870
 8001958:	50000700 	.word	0x50000700
 800195c:	50000400 	.word	0x50000400
 8001960:	200008a8 	.word	0x200008a8
 8001964:	50000500 	.word	0x50000500
 8001968:	40021000 	.word	0x40021000
 800196c:	00000000 	.word	0x00000000

08001970 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8001970:	b500      	push	{lr}
 8001972:	b083      	sub	sp, #12
 8001974:	9001      	str	r0, [sp, #4]

  /* Handling the default configuration.*/
  if (adcp->config == NULL) {
 8001976:	9b01      	ldr	r3, [sp, #4]
 8001978:	685b      	ldr	r3, [r3, #4]
 800197a:	2b00      	cmp	r3, #0
 800197c:	d102      	bne.n	8001984 <adc_lld_start+0x14>
    adcp->config = &default_config;
 800197e:	9b01      	ldr	r3, [sp, #4]
 8001980:	4a77      	ldr	r2, [pc, #476]	@ (8001b60 <adc_lld_start+0x1f0>)
 8001982:	605a      	str	r2, [r3, #4]
  }

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8001984:	9b01      	ldr	r3, [sp, #4]
 8001986:	781b      	ldrb	r3, [r3, #0]
 8001988:	2b01      	cmp	r3, #1
 800198a:	f040 80e4 	bne.w	8001b56 <adc_lld_start+0x1e6>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800198e:	9b01      	ldr	r3, [sp, #4]
 8001990:	4a74      	ldr	r2, [pc, #464]	@ (8001b64 <adc_lld_start+0x1f4>)
 8001992:	4293      	cmp	r3, r2
 8001994:	d12e      	bne.n	80019f4 <adc_lld_start+0x84>

      osalDbgAssert(STM32_ADC1_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 8001996:	9b01      	ldr	r3, [sp, #4]
 8001998:	4a73      	ldr	r2, [pc, #460]	@ (8001b68 <adc_lld_start+0x1f8>)
 800199a:	2105      	movs	r1, #5
 800199c:	2010      	movs	r0, #16
 800199e:	f000 fb17 	bl	8001fd0 <dmaStreamAllocI>
 80019a2:	4602      	mov	r2, r0
 80019a4:	9b01      	ldr	r3, [sp, #4]
 80019a6:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 80019a8:	9b01      	ldr	r3, [sp, #4]
 80019aa:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019ac:	2b00      	cmp	r3, #0
 80019ae:	bf0c      	ite	eq
 80019b0:	2301      	moveq	r3, #1
 80019b2:	2300      	movne	r3, #0
 80019b4:	b2db      	uxtb	r3, r3
 80019b6:	2b00      	cmp	r3, #0
 80019b8:	d002      	beq.n	80019c0 <adc_lld_start+0x50>
 80019ba:	486c      	ldr	r0, [pc, #432]	@ (8001b6c <adc_lld_start+0x1fc>)
 80019bc:	f000 ffb8 	bl	8002930 <chSysHalt>

      clkmask |= (1 << 0);
 80019c0:	4b6b      	ldr	r3, [pc, #428]	@ (8001b70 <adc_lld_start+0x200>)
 80019c2:	681b      	ldr	r3, [r3, #0]
 80019c4:	f043 0301 	orr.w	r3, r3, #1
 80019c8:	4a69      	ldr	r2, [pc, #420]	@ (8001b70 <adc_lld_start+0x200>)
 80019ca:	6013      	str	r3, [r2, #0]
#if defined(STM32F3XX) || defined(STM32G4XX)
      rccEnableADC12(true);
 80019cc:	4b69      	ldr	r3, [pc, #420]	@ (8001b74 <adc_lld_start+0x204>)
 80019ce:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80019d0:	4a68      	ldr	r2, [pc, #416]	@ (8001b74 <adc_lld_start+0x204>)
 80019d2:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80019d6:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80019d8:	4b66      	ldr	r3, [pc, #408]	@ (8001b74 <adc_lld_start+0x204>)
 80019da:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80019dc:	4a65      	ldr	r2, [pc, #404]	@ (8001b74 <adc_lld_start+0x204>)
 80019de:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80019e2:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80019e4:	4b63      	ldr	r3, [pc, #396]	@ (8001b74 <adc_lld_start+0x204>)
 80019e6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
#if defined(STM32WBXX)
      rccEnableADC1(true);
#endif
#if STM32_DMA_SUPPORTS_DMAMUX
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC1);
 80019e8:	9b01      	ldr	r3, [sp, #4]
 80019ea:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019ec:	2105      	movs	r1, #5
 80019ee:	4618      	mov	r0, r3
 80019f0:	f000 fbfe 	bl	80021f0 <dmaSetRequestSource>
#endif
    }
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
    if (&ADCD2 == adcp) {
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	4a60      	ldr	r2, [pc, #384]	@ (8001b78 <adc_lld_start+0x208>)
 80019f8:	4293      	cmp	r3, r2
 80019fa:	d12e      	bne.n	8001a5a <adc_lld_start+0xea>

      osalDbgAssert(STM32_ADC2_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC2_DMA_STREAM,
 80019fc:	9b01      	ldr	r3, [sp, #4]
 80019fe:	4a5a      	ldr	r2, [pc, #360]	@ (8001b68 <adc_lld_start+0x1f8>)
 8001a00:	2105      	movs	r1, #5
 8001a02:	2010      	movs	r0, #16
 8001a04:	f000 fae4 	bl	8001fd0 <dmaStreamAllocI>
 8001a08:	4602      	mov	r2, r0
 8001a0a:	9b01      	ldr	r3, [sp, #4]
 8001a0c:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC2_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8001a0e:	9b01      	ldr	r3, [sp, #4]
 8001a10:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a12:	2b00      	cmp	r3, #0
 8001a14:	bf0c      	ite	eq
 8001a16:	2301      	moveq	r3, #1
 8001a18:	2300      	movne	r3, #0
 8001a1a:	b2db      	uxtb	r3, r3
 8001a1c:	2b00      	cmp	r3, #0
 8001a1e:	d002      	beq.n	8001a26 <adc_lld_start+0xb6>
 8001a20:	4852      	ldr	r0, [pc, #328]	@ (8001b6c <adc_lld_start+0x1fc>)
 8001a22:	f000 ff85 	bl	8002930 <chSysHalt>

      clkmask |= (1 << 1);
 8001a26:	4b52      	ldr	r3, [pc, #328]	@ (8001b70 <adc_lld_start+0x200>)
 8001a28:	681b      	ldr	r3, [r3, #0]
 8001a2a:	f043 0302 	orr.w	r3, r3, #2
 8001a2e:	4a50      	ldr	r2, [pc, #320]	@ (8001b70 <adc_lld_start+0x200>)
 8001a30:	6013      	str	r3, [r2, #0]
#if defined(STM32F3XX) || defined(STM32G4XX)
      rccEnableADC12(true);
 8001a32:	4b50      	ldr	r3, [pc, #320]	@ (8001b74 <adc_lld_start+0x204>)
 8001a34:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001a36:	4a4f      	ldr	r2, [pc, #316]	@ (8001b74 <adc_lld_start+0x204>)
 8001a38:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8001a3c:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8001a3e:	4b4d      	ldr	r3, [pc, #308]	@ (8001b74 <adc_lld_start+0x204>)
 8001a40:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8001a42:	4a4c      	ldr	r2, [pc, #304]	@ (8001b74 <adc_lld_start+0x204>)
 8001a44:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8001a48:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8001a4a:	4b4a      	ldr	r3, [pc, #296]	@ (8001b74 <adc_lld_start+0x204>)
 8001a4c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
#if defined(STM32L4XX) || defined(STM32L4XXP)
      rccEnableADC123(true);
#endif
#if STM32_DMA_SUPPORTS_DMAMUX
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC2);
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a52:	2124      	movs	r1, #36	@ 0x24
 8001a54:	4618      	mov	r0, r3
 8001a56:	f000 fbcb 	bl	80021f0 <dmaSetRequestSource>
#endif
    }
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
    if (&ADCD3 == adcp) {
 8001a5a:	9b01      	ldr	r3, [sp, #4]
 8001a5c:	4a47      	ldr	r2, [pc, #284]	@ (8001b7c <adc_lld_start+0x20c>)
 8001a5e:	4293      	cmp	r3, r2
 8001a60:	d12e      	bne.n	8001ac0 <adc_lld_start+0x150>

      osalDbgAssert(STM32_ADC3_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC3_DMA_STREAM,
 8001a62:	9b01      	ldr	r3, [sp, #4]
 8001a64:	4a40      	ldr	r2, [pc, #256]	@ (8001b68 <adc_lld_start+0x1f8>)
 8001a66:	2105      	movs	r1, #5
 8001a68:	2010      	movs	r0, #16
 8001a6a:	f000 fab1 	bl	8001fd0 <dmaStreamAllocI>
 8001a6e:	4602      	mov	r2, r0
 8001a70:	9b01      	ldr	r3, [sp, #4]
 8001a72:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC3_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8001a74:	9b01      	ldr	r3, [sp, #4]
 8001a76:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a78:	2b00      	cmp	r3, #0
 8001a7a:	bf0c      	ite	eq
 8001a7c:	2301      	moveq	r3, #1
 8001a7e:	2300      	movne	r3, #0
 8001a80:	b2db      	uxtb	r3, r3
 8001a82:	2b00      	cmp	r3, #0
 8001a84:	d002      	beq.n	8001a8c <adc_lld_start+0x11c>
 8001a86:	4839      	ldr	r0, [pc, #228]	@ (8001b6c <adc_lld_start+0x1fc>)
 8001a88:	f000 ff52 	bl	8002930 <chSysHalt>

      clkmask |= (1 << 2);
 8001a8c:	4b38      	ldr	r3, [pc, #224]	@ (8001b70 <adc_lld_start+0x200>)
 8001a8e:	681b      	ldr	r3, [r3, #0]
 8001a90:	f043 0304 	orr.w	r3, r3, #4
 8001a94:	4a36      	ldr	r2, [pc, #216]	@ (8001b70 <adc_lld_start+0x200>)
 8001a96:	6013      	str	r3, [r2, #0]
#endif
#if defined(STM32L4XX) || defined(STM32L4XXP)
      rccEnableADC123(true);
#endif
#if defined(STM32G4XX)
      rccEnableADC345(true);
 8001a98:	4b36      	ldr	r3, [pc, #216]	@ (8001b74 <adc_lld_start+0x204>)
 8001a9a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001a9c:	4a35      	ldr	r2, [pc, #212]	@ (8001b74 <adc_lld_start+0x204>)
 8001a9e:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001aa2:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8001aa4:	4b33      	ldr	r3, [pc, #204]	@ (8001b74 <adc_lld_start+0x204>)
 8001aa6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8001aa8:	4a32      	ldr	r2, [pc, #200]	@ (8001b74 <adc_lld_start+0x204>)
 8001aaa:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001aae:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8001ab0:	4b30      	ldr	r3, [pc, #192]	@ (8001b74 <adc_lld_start+0x204>)
 8001ab2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
#if STM32_DMA_SUPPORTS_DMAMUX
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC3);
 8001ab4:	9b01      	ldr	r3, [sp, #4]
 8001ab6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001ab8:	2125      	movs	r1, #37	@ 0x25
 8001aba:	4618      	mov	r0, r3
 8001abc:	f000 fb98 	bl	80021f0 <dmaSetRequestSource>
#endif
    }
#endif /* STM32_ADC_USE_ADC3 */

#if STM32_ADC_USE_ADC4
    if (&ADCD4 == adcp) {
 8001ac0:	9b01      	ldr	r3, [sp, #4]
 8001ac2:	4a2f      	ldr	r2, [pc, #188]	@ (8001b80 <adc_lld_start+0x210>)
 8001ac4:	4293      	cmp	r3, r2
 8001ac6:	d12e      	bne.n	8001b26 <adc_lld_start+0x1b6>

      osalDbgAssert(STM32_ADC4_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC4_DMA_STREAM,
 8001ac8:	9b01      	ldr	r3, [sp, #4]
 8001aca:	4a27      	ldr	r2, [pc, #156]	@ (8001b68 <adc_lld_start+0x1f8>)
 8001acc:	2105      	movs	r1, #5
 8001ace:	2010      	movs	r0, #16
 8001ad0:	f000 fa7e 	bl	8001fd0 <dmaStreamAllocI>
 8001ad4:	4602      	mov	r2, r0
 8001ad6:	9b01      	ldr	r3, [sp, #4]
 8001ad8:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC4_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8001ada:	9b01      	ldr	r3, [sp, #4]
 8001adc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001ade:	2b00      	cmp	r3, #0
 8001ae0:	bf0c      	ite	eq
 8001ae2:	2301      	moveq	r3, #1
 8001ae4:	2300      	movne	r3, #0
 8001ae6:	b2db      	uxtb	r3, r3
 8001ae8:	2b00      	cmp	r3, #0
 8001aea:	d002      	beq.n	8001af2 <adc_lld_start+0x182>
 8001aec:	481f      	ldr	r0, [pc, #124]	@ (8001b6c <adc_lld_start+0x1fc>)
 8001aee:	f000 ff1f 	bl	8002930 <chSysHalt>

      clkmask |= (1 << 3);
 8001af2:	4b1f      	ldr	r3, [pc, #124]	@ (8001b70 <adc_lld_start+0x200>)
 8001af4:	681b      	ldr	r3, [r3, #0]
 8001af6:	f043 0308 	orr.w	r3, r3, #8
 8001afa:	4a1d      	ldr	r2, [pc, #116]	@ (8001b70 <adc_lld_start+0x200>)
 8001afc:	6013      	str	r3, [r2, #0]
#endif
#if defined(STM32L4XX) || defined(STM32L4XXP)
      rccEnableADC123(true);
#endif
#if defined(STM32G4XX)
      rccEnableADC345(true);
 8001afe:	4b1d      	ldr	r3, [pc, #116]	@ (8001b74 <adc_lld_start+0x204>)
 8001b00:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001b02:	4a1c      	ldr	r2, [pc, #112]	@ (8001b74 <adc_lld_start+0x204>)
 8001b04:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001b08:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8001b0a:	4b1a      	ldr	r3, [pc, #104]	@ (8001b74 <adc_lld_start+0x204>)
 8001b0c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8001b0e:	4a19      	ldr	r2, [pc, #100]	@ (8001b74 <adc_lld_start+0x204>)
 8001b10:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001b14:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8001b16:	4b17      	ldr	r3, [pc, #92]	@ (8001b74 <adc_lld_start+0x204>)
 8001b18:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
#if STM32_DMA_SUPPORTS_DMAMUX
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC4);
 8001b1a:	9b01      	ldr	r3, [sp, #4]
 8001b1c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b1e:	2126      	movs	r1, #38	@ 0x26
 8001b20:	4618      	mov	r0, r3
 8001b22:	f000 fb65 	bl	80021f0 <dmaSetRequestSource>

    /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcc->CDR);
#else
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 8001b26:	9b01      	ldr	r3, [sp, #4]
 8001b28:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b2a:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 8001b2e:	9b01      	ldr	r3, [sp, #4]
 8001b30:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b32:	685b      	ldr	r3, [r3, #4]
 8001b34:	609a      	str	r2, [r3, #8]
    /* Differential channels setting.*/
#if STM32_ADC_DUAL_MODE
    adcp->adcm->DIFSEL = adcp->config->difsel;
    adcp->adcs->DIFSEL = adcp->config->difsel;
#else
    adcp->adcm->DIFSEL = adcp->config->difsel;
 8001b36:	9b01      	ldr	r3, [sp, #4]
 8001b38:	685a      	ldr	r2, [r3, #4]
 8001b3a:	9b01      	ldr	r3, [sp, #4]
 8001b3c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b3e:	6812      	ldr	r2, [r2, #0]
 8001b40:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
#endif

    /* Master ADC calibration.*/
    adc_lld_vreg_on(adcp);
 8001b44:	9801      	ldr	r0, [sp, #4]
 8001b46:	f7ff fc4b 	bl	80013e0 <adc_lld_vreg_on>
    adc_lld_calibrate(adcp);
 8001b4a:	9801      	ldr	r0, [sp, #4]
 8001b4c:	f7ff fc60 	bl	8001410 <adc_lld_calibrate>

    /* Master ADC enabled here in order to reduce conversions latencies.*/
    adc_lld_analog_on(adcp);
 8001b50:	9801      	ldr	r0, [sp, #4]
 8001b52:	f7ff fc9d 	bl	8001490 <adc_lld_analog_on>
  }
}
 8001b56:	bf00      	nop
 8001b58:	b003      	add	sp, #12
 8001b5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b5e:	bf00      	nop
 8001b60:	08005344 	.word	0x08005344
 8001b64:	20000800 	.word	0x20000800
 8001b68:	08001501 	.word	0x08001501
 8001b6c:	0800535c 	.word	0x0800535c
 8001b70:	200008e0 	.word	0x200008e0
 8001b74:	40021000 	.word	0x40021000
 8001b78:	20000838 	.word	0x20000838
 8001b7c:	20000870 	.word	0x20000870
 8001b80:	200008a8 	.word	0x200008a8
	...

08001b90 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 8001b90:	b086      	sub	sp, #24
 8001b92:	9001      	str	r0, [sp, #4]
  uint32_t dmamode, cfgr;
  const ADCConversionGroup *grpp = adcp->grpp;
 8001b94:	9b01      	ldr	r3, [sp, #4]
 8001b96:	691b      	ldr	r3, [r3, #16]
 8001b98:	9303      	str	r3, [sp, #12]

  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
 8001b9a:	9b01      	ldr	r3, [sp, #4]
 8001b9c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001b9e:	9305      	str	r3, [sp, #20]
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 8001ba0:	9b03      	ldr	r3, [sp, #12]
 8001ba2:	68db      	ldr	r3, [r3, #12]
 8001ba4:	f043 0301 	orr.w	r3, r3, #1
 8001ba8:	9304      	str	r3, [sp, #16]
  if (grpp->circular) {
 8001baa:	9b03      	ldr	r3, [sp, #12]
 8001bac:	781b      	ldrb	r3, [r3, #0]
 8001bae:	2b00      	cmp	r3, #0
 8001bb0:	d00f      	beq.n	8001bd2 <adc_lld_start_conversion+0x42>
    dmamode |= STM32_DMA_CR_CIRC;
 8001bb2:	9b05      	ldr	r3, [sp, #20]
 8001bb4:	f043 0320 	orr.w	r3, r3, #32
 8001bb8:	9305      	str	r3, [sp, #20]
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
#else
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
 8001bba:	9b04      	ldr	r3, [sp, #16]
 8001bbc:	f043 0302 	orr.w	r3, r3, #2
 8001bc0:	9304      	str	r3, [sp, #16]
#endif
    if (adcp->depth > 1) {
 8001bc2:	9b01      	ldr	r3, [sp, #4]
 8001bc4:	68db      	ldr	r3, [r3, #12]
 8001bc6:	2b01      	cmp	r3, #1
 8001bc8:	d903      	bls.n	8001bd2 <adc_lld_start_conversion+0x42>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      dmamode |= STM32_DMA_CR_HTIE;
 8001bca:	9b05      	ldr	r3, [sp, #20]
 8001bcc:	f043 0304 	orr.w	r3, r3, #4
 8001bd0:	9305      	str	r3, [sp, #20]
    }
  }

  /* DMA setup.*/
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8001bd2:	9b01      	ldr	r3, [sp, #4]
 8001bd4:	689a      	ldr	r2, [r3, #8]
 8001bd6:	9b01      	ldr	r3, [sp, #4]
 8001bd8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001bda:	685b      	ldr	r3, [r3, #4]
 8001bdc:	60da      	str	r2, [r3, #12]
#if STM32_ADC_DUAL_MODE
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels/2) *
                                            (uint32_t)adcp->depth);
#else
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8001bde:	9b03      	ldr	r3, [sp, #12]
 8001be0:	885b      	ldrh	r3, [r3, #2]
 8001be2:	4619      	mov	r1, r3
 8001be4:	9b01      	ldr	r3, [sp, #4]
 8001be6:	68da      	ldr	r2, [r3, #12]
 8001be8:	9b01      	ldr	r3, [sp, #4]
 8001bea:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001bec:	685b      	ldr	r3, [r3, #4]
 8001bee:	fb01 f202 	mul.w	r2, r1, r2
 8001bf2:	605a      	str	r2, [r3, #4]
                                            (uint32_t)adcp->depth);
#endif
  dmaStreamSetMode(adcp->dmastp, dmamode);
 8001bf4:	9b01      	ldr	r3, [sp, #4]
 8001bf6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001bf8:	685b      	ldr	r3, [r3, #4]
 8001bfa:	9a05      	ldr	r2, [sp, #20]
 8001bfc:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(adcp->dmastp);
 8001bfe:	9b01      	ldr	r3, [sp, #4]
 8001c00:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001c02:	685b      	ldr	r3, [r3, #4]
 8001c04:	681a      	ldr	r2, [r3, #0]
 8001c06:	9b01      	ldr	r3, [sp, #4]
 8001c08:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001c0a:	685b      	ldr	r3, [r3, #4]
 8001c0c:	f042 0201 	orr.w	r2, r2, #1
 8001c10:	601a      	str	r2, [r3, #0]

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8001c12:	9b01      	ldr	r3, [sp, #4]
 8001c14:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001c16:	9b01      	ldr	r3, [sp, #4]
 8001c18:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c1a:	6812      	ldr	r2, [r2, #0]
 8001c1c:	601a      	str	r2, [r3, #0]
  if (grpp->error_cb != NULL) {
 8001c1e:	9b03      	ldr	r3, [sp, #12]
 8001c20:	689b      	ldr	r3, [r3, #8]
 8001c22:	2b00      	cmp	r3, #0
 8001c24:	d01f      	beq.n	8001c66 <adc_lld_start_conversion+0xd6>
    adcp->adcm->IER    = ADC_IER_OVRIE | ADC_IER_AWD1IE
 8001c26:	9b01      	ldr	r3, [sp, #4]
 8001c28:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c2a:	f44f 7264 	mov.w	r2, #912	@ 0x390
 8001c2e:	605a      	str	r2, [r3, #4]
                                       | ADC_IER_AWD2IE
                                       | ADC_IER_AWD3IE;
    adcp->adcm->TR1    = grpp->tr1;
 8001c30:	9b01      	ldr	r3, [sp, #4]
 8001c32:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c34:	9a03      	ldr	r2, [sp, #12]
 8001c36:	6952      	ldr	r2, [r2, #20]
 8001c38:	621a      	str	r2, [r3, #32]
    adcp->adcm->TR2    = grpp->tr2;
 8001c3a:	9b01      	ldr	r3, [sp, #4]
 8001c3c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c3e:	9a03      	ldr	r2, [sp, #12]
 8001c40:	6992      	ldr	r2, [r2, #24]
 8001c42:	625a      	str	r2, [r3, #36]	@ 0x24
    adcp->adcm->TR3    = grpp->tr3;
 8001c44:	9b01      	ldr	r3, [sp, #4]
 8001c46:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c48:	9a03      	ldr	r2, [sp, #12]
 8001c4a:	69d2      	ldr	r2, [r2, #28]
 8001c4c:	629a      	str	r2, [r3, #40]	@ 0x28
    adcp->adcm->AWD2CR = grpp->awd2cr;
 8001c4e:	9b01      	ldr	r3, [sp, #4]
 8001c50:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c52:	9a03      	ldr	r2, [sp, #12]
 8001c54:	6a12      	ldr	r2, [r2, #32]
 8001c56:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    adcp->adcm->AWD3CR = grpp->awd3cr;
 8001c5a:	9b01      	ldr	r3, [sp, #4]
 8001c5c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c5e:	9a03      	ldr	r2, [sp, #12]
 8001c60:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8001c62:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
  adcp->adcs->SQR2  = grpp->ssqr[1];
  adcp->adcs->SQR3  = grpp->ssqr[2];
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
 8001c66:	9b01      	ldr	r3, [sp, #4]
 8001c68:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c6a:	9a03      	ldr	r2, [sp, #12]
 8001c6c:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8001c6e:	615a      	str	r2, [r3, #20]
  adcp->adcm->SMPR2 = grpp->smpr[1];
 8001c70:	9b01      	ldr	r3, [sp, #4]
 8001c72:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c74:	9a03      	ldr	r2, [sp, #12]
 8001c76:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8001c78:	619a      	str	r2, [r3, #24]
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8001c7a:	9b03      	ldr	r3, [sp, #12]
 8001c7c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001c7e:	9b03      	ldr	r3, [sp, #12]
 8001c80:	885b      	ldrh	r3, [r3, #2]
 8001c82:	3b01      	subs	r3, #1
 8001c84:	4619      	mov	r1, r3
 8001c86:	9b01      	ldr	r3, [sp, #4]
 8001c88:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c8a:	430a      	orrs	r2, r1
 8001c8c:	631a      	str	r2, [r3, #48]	@ 0x30
  adcp->adcm->SQR2  = grpp->sqr[1];
 8001c8e:	9b01      	ldr	r3, [sp, #4]
 8001c90:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c92:	9a03      	ldr	r2, [sp, #12]
 8001c94:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 8001c96:	635a      	str	r2, [r3, #52]	@ 0x34
  adcp->adcm->SQR3  = grpp->sqr[2];
 8001c98:	9b01      	ldr	r3, [sp, #4]
 8001c9a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c9c:	9a03      	ldr	r2, [sp, #12]
 8001c9e:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 8001ca0:	639a      	str	r2, [r3, #56]	@ 0x38
  adcp->adcm->SQR4  = grpp->sqr[3];
 8001ca2:	9b01      	ldr	r3, [sp, #4]
 8001ca4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ca6:	9a03      	ldr	r2, [sp, #12]
 8001ca8:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8001caa:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif /* !STM32_ADC_DUAL_MODE */

  /* ADC configuration.*/
  adcp->adcm->CFGR  = cfgr;
 8001cac:	9b01      	ldr	r3, [sp, #4]
 8001cae:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001cb0:	9a04      	ldr	r2, [sp, #16]
 8001cb2:	60da      	str	r2, [r3, #12]
#if (STM32_ADCV3_OVERSAMPLING == TRUE) || defined(__DOXYGEN__)
  adcp->adcm->CFGR2 = grpp->cfgr2;
 8001cb4:	9b01      	ldr	r3, [sp, #4]
 8001cb6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001cb8:	9a03      	ldr	r2, [sp, #12]
 8001cba:	6912      	ldr	r2, [r2, #16]
 8001cbc:	611a      	str	r2, [r3, #16]
#endif

  /* Starting conversion.*/
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 8001cbe:	9b01      	ldr	r3, [sp, #4]
 8001cc0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001cc2:	689a      	ldr	r2, [r3, #8]
 8001cc4:	9b01      	ldr	r3, [sp, #4]
 8001cc6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001cc8:	f042 0204 	orr.w	r2, r2, #4
 8001ccc:	609a      	str	r2, [r3, #8]
}
 8001cce:	bf00      	nop
 8001cd0:	b006      	add	sp, #24
 8001cd2:	4770      	bx	lr
	...

08001ce0 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8001ce0:	b500      	push	{lr}
 8001ce2:	b083      	sub	sp, #12
 8001ce4:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
 8001ce6:	9b01      	ldr	r3, [sp, #4]
 8001ce8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001cea:	685b      	ldr	r3, [r3, #4]
 8001cec:	681a      	ldr	r2, [r3, #0]
 8001cee:	9b01      	ldr	r3, [sp, #4]
 8001cf0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001cf2:	685b      	ldr	r3, [r3, #4]
 8001cf4:	f022 020f 	bic.w	r2, r2, #15
 8001cf8:	601a      	str	r2, [r3, #0]
 8001cfa:	9b01      	ldr	r3, [sp, #4]
 8001cfc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001cfe:	7c1b      	ldrb	r3, [r3, #16]
 8001d00:	461a      	mov	r2, r3
 8001d02:	230e      	movs	r3, #14
 8001d04:	fa03 f202 	lsl.w	r2, r3, r2
 8001d08:	9b01      	ldr	r3, [sp, #4]
 8001d0a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001d0c:	681b      	ldr	r3, [r3, #0]
 8001d0e:	605a      	str	r2, [r3, #4]
  adc_lld_stop_adc(adcp);
 8001d10:	9801      	ldr	r0, [sp, #4]
 8001d12:	f7ff fbd5 	bl	80014c0 <adc_lld_stop_adc>
}
 8001d16:	bf00      	nop
 8001d18:	b003      	add	sp, #12
 8001d1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d1e:	bf00      	nop

08001d20 <adcSTM32EnableVREF>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableVREF(ADCDriver *adcp) {
 8001d20:	b082      	sub	sp, #8
 8001d22:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_VREFEN;
 8001d24:	9b01      	ldr	r3, [sp, #4]
 8001d26:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d28:	689a      	ldr	r2, [r3, #8]
 8001d2a:	9b01      	ldr	r3, [sp, #4]
 8001d2c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d2e:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8001d32:	609a      	str	r2, [r3, #8]
}
 8001d34:	bf00      	nop
 8001d36:	b002      	add	sp, #8
 8001d38:	4770      	bx	lr
 8001d3a:	bf00      	nop
 8001d3c:	0000      	movs	r0, r0
	...

08001d40 <adcSTM32EnableTS>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {
 8001d40:	b082      	sub	sp, #8
 8001d42:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_TSEN;
 8001d44:	9b01      	ldr	r3, [sp, #4]
 8001d46:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d48:	689a      	ldr	r2, [r3, #8]
 8001d4a:	9b01      	ldr	r3, [sp, #4]
 8001d4c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d4e:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 8001d52:	609a      	str	r2, [r3, #8]
}
 8001d54:	bf00      	nop
 8001d56:	b002      	add	sp, #8
 8001d58:	4770      	bx	lr
 8001d5a:	bf00      	nop
 8001d5c:	0000      	movs	r0, r0
	...

08001d60 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001d60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d62:	f000 ff0d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8001d66:	4804      	ldr	r0, [pc, #16]	@ (8001d78 <Vector6C+0x18>)
 8001d68:	f000 fa02 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d6c:	f000 ff40 	bl	8002bf0 <__dbg_check_leave_isr>
 8001d70:	f003 f946 	bl	8005000 <__port_irq_epilogue>
}
 8001d74:	bf00      	nop
 8001d76:	bd08      	pop	{r3, pc}
 8001d78:	0800536c 	.word	0x0800536c
 8001d7c:	00000000 	.word	0x00000000

08001d80 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8001d80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d82:	f000 fefd 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8001d86:	4804      	ldr	r0, [pc, #16]	@ (8001d98 <Vector70+0x18>)
 8001d88:	f000 f9f2 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d8c:	f000 ff30 	bl	8002bf0 <__dbg_check_leave_isr>
 8001d90:	f003 f936 	bl	8005000 <__port_irq_epilogue>
}
 8001d94:	bf00      	nop
 8001d96:	bd08      	pop	{r3, pc}
 8001d98:	08005380 	.word	0x08005380
 8001d9c:	00000000 	.word	0x00000000

08001da0 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8001da0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001da2:	f000 feed 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8001da6:	4804      	ldr	r0, [pc, #16]	@ (8001db8 <Vector74+0x18>)
 8001da8:	f000 f9e2 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001dac:	f000 ff20 	bl	8002bf0 <__dbg_check_leave_isr>
 8001db0:	f003 f926 	bl	8005000 <__port_irq_epilogue>
}
 8001db4:	bf00      	nop
 8001db6:	bd08      	pop	{r3, pc}
 8001db8:	08005394 	.word	0x08005394
 8001dbc:	00000000 	.word	0x00000000

08001dc0 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001dc0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001dc2:	f000 fedd 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8001dc6:	4804      	ldr	r0, [pc, #16]	@ (8001dd8 <Vector78+0x18>)
 8001dc8:	f000 f9d2 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001dcc:	f000 ff10 	bl	8002bf0 <__dbg_check_leave_isr>
 8001dd0:	f003 f916 	bl	8005000 <__port_irq_epilogue>
}
 8001dd4:	bf00      	nop
 8001dd6:	bd08      	pop	{r3, pc}
 8001dd8:	080053a8 	.word	0x080053a8
 8001ddc:	00000000 	.word	0x00000000

08001de0 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8001de0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001de2:	f000 fecd 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8001de6:	4804      	ldr	r0, [pc, #16]	@ (8001df8 <Vector7C+0x18>)
 8001de8:	f000 f9c2 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001dec:	f000 ff00 	bl	8002bf0 <__dbg_check_leave_isr>
 8001df0:	f003 f906 	bl	8005000 <__port_irq_epilogue>
}
 8001df4:	bf00      	nop
 8001df6:	bd08      	pop	{r3, pc}
 8001df8:	080053bc 	.word	0x080053bc
 8001dfc:	00000000 	.word	0x00000000

08001e00 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8001e00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e02:	f000 febd 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8001e06:	4804      	ldr	r0, [pc, #16]	@ (8001e18 <Vector80+0x18>)
 8001e08:	f000 f9b2 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e0c:	f000 fef0 	bl	8002bf0 <__dbg_check_leave_isr>
 8001e10:	f003 f8f6 	bl	8005000 <__port_irq_epilogue>
}
 8001e14:	bf00      	nop
 8001e16:	bd08      	pop	{r3, pc}
 8001e18:	080053d0 	.word	0x080053d0
 8001e1c:	00000000 	.word	0x00000000

08001e20 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8001e20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e22:	f000 fead 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8001e26:	4804      	ldr	r0, [pc, #16]	@ (8001e38 <Vector84+0x18>)
 8001e28:	f000 f9a2 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e2c:	f000 fee0 	bl	8002bf0 <__dbg_check_leave_isr>
 8001e30:	f003 f8e6 	bl	8005000 <__port_irq_epilogue>
}
 8001e34:	bf00      	nop
 8001e36:	bd08      	pop	{r3, pc}
 8001e38:	080053e4 	.word	0x080053e4
 8001e3c:	00000000 	.word	0x00000000

08001e40 <Vector1C0>:
/**
 * @brief   DMA1 stream 8 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH8_HANDLER) {
 8001e40:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e42:	f000 fe9d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM8);
 8001e46:	4804      	ldr	r0, [pc, #16]	@ (8001e58 <Vector1C0+0x18>)
 8001e48:	f000 f992 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e4c:	f000 fed0 	bl	8002bf0 <__dbg_check_leave_isr>
 8001e50:	f003 f8d6 	bl	8005000 <__port_irq_epilogue>
}
 8001e54:	bf00      	nop
 8001e56:	bd08      	pop	{r3, pc}
 8001e58:	080053f8 	.word	0x080053f8
 8001e5c:	00000000 	.word	0x00000000

08001e60 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8001e60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e62:	f000 fe8d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8001e66:	4804      	ldr	r0, [pc, #16]	@ (8001e78 <Vector120+0x18>)
 8001e68:	f000 f982 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e6c:	f000 fec0 	bl	8002bf0 <__dbg_check_leave_isr>
 8001e70:	f003 f8c6 	bl	8005000 <__port_irq_epilogue>
}
 8001e74:	bf00      	nop
 8001e76:	bd08      	pop	{r3, pc}
 8001e78:	0800540c 	.word	0x0800540c
 8001e7c:	00000000 	.word	0x00000000

08001e80 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8001e80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e82:	f000 fe7d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8001e86:	4804      	ldr	r0, [pc, #16]	@ (8001e98 <Vector124+0x18>)
 8001e88:	f000 f972 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e8c:	f000 feb0 	bl	8002bf0 <__dbg_check_leave_isr>
 8001e90:	f003 f8b6 	bl	8005000 <__port_irq_epilogue>
}
 8001e94:	bf00      	nop
 8001e96:	bd08      	pop	{r3, pc}
 8001e98:	08005420 	.word	0x08005420
 8001e9c:	00000000 	.word	0x00000000

08001ea0 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8001ea0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001ea2:	f000 fe6d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8001ea6:	4804      	ldr	r0, [pc, #16]	@ (8001eb8 <Vector128+0x18>)
 8001ea8:	f000 f962 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001eac:	f000 fea0 	bl	8002bf0 <__dbg_check_leave_isr>
 8001eb0:	f003 f8a6 	bl	8005000 <__port_irq_epilogue>
}
 8001eb4:	bf00      	nop
 8001eb6:	bd08      	pop	{r3, pc}
 8001eb8:	08005434 	.word	0x08005434
 8001ebc:	00000000 	.word	0x00000000

08001ec0 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001ec0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001ec2:	f000 fe5d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8001ec6:	4804      	ldr	r0, [pc, #16]	@ (8001ed8 <Vector12C+0x18>)
 8001ec8:	f000 f952 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001ecc:	f000 fe90 	bl	8002bf0 <__dbg_check_leave_isr>
 8001ed0:	f003 f896 	bl	8005000 <__port_irq_epilogue>
}
 8001ed4:	bf00      	nop
 8001ed6:	bd08      	pop	{r3, pc}
 8001ed8:	08005448 	.word	0x08005448
 8001edc:	00000000 	.word	0x00000000

08001ee0 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001ee0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001ee2:	f000 fe4d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8001ee6:	4804      	ldr	r0, [pc, #16]	@ (8001ef8 <Vector130+0x18>)
 8001ee8:	f000 f942 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001eec:	f000 fe80 	bl	8002bf0 <__dbg_check_leave_isr>
 8001ef0:	f003 f886 	bl	8005000 <__port_irq_epilogue>
}
 8001ef4:	bf00      	nop
 8001ef6:	bd08      	pop	{r3, pc}
 8001ef8:	0800545c 	.word	0x0800545c
 8001efc:	00000000 	.word	0x00000000

08001f00 <Vector1C4>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8001f00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001f02:	f000 fe3d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8001f06:	4804      	ldr	r0, [pc, #16]	@ (8001f18 <Vector1C4+0x18>)
 8001f08:	f000 f932 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001f0c:	f000 fe70 	bl	8002bf0 <__dbg_check_leave_isr>
 8001f10:	f003 f876 	bl	8005000 <__port_irq_epilogue>
}
 8001f14:	bf00      	nop
 8001f16:	bd08      	pop	{r3, pc}
 8001f18:	08005470 	.word	0x08005470
 8001f1c:	00000000 	.word	0x00000000

08001f20 <Vector1C8>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8001f20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001f22:	f000 fe2d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 8001f26:	4804      	ldr	r0, [pc, #16]	@ (8001f38 <Vector1C8+0x18>)
 8001f28:	f000 f922 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001f2c:	f000 fe60 	bl	8002bf0 <__dbg_check_leave_isr>
 8001f30:	f003 f866 	bl	8005000 <__port_irq_epilogue>
}
 8001f34:	bf00      	nop
 8001f36:	bd08      	pop	{r3, pc}
 8001f38:	08005484 	.word	0x08005484
 8001f3c:	00000000 	.word	0x00000000

08001f40 <Vector1CC>:
/**
 * @brief   DMA2 stream 8 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH8_HANDLER) {
 8001f40:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001f42:	f000 fe1d 	bl	8002b80 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM8);
 8001f46:	4804      	ldr	r0, [pc, #16]	@ (8001f58 <Vector1CC+0x18>)
 8001f48:	f000 f912 	bl	8002170 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001f4c:	f000 fe50 	bl	8002bf0 <__dbg_check_leave_isr>
 8001f50:	f003 f856 	bl	8005000 <__port_irq_epilogue>
}
 8001f54:	bf00      	nop
 8001f56:	bd08      	pop	{r3, pc}
 8001f58:	08005498 	.word	0x08005498
 8001f5c:	00000000 	.word	0x00000000

08001f60 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8001f60:	b082      	sub	sp, #8
  int i;

  dma.allocated_mask = 0U;
 8001f62:	4b15      	ldr	r3, [pc, #84]	@ (8001fb8 <dmaInit+0x58>)
 8001f64:	2200      	movs	r2, #0
 8001f66:	601a      	str	r2, [r3, #0]
  dma.isr_mask       = 0U;
 8001f68:	4b13      	ldr	r3, [pc, #76]	@ (8001fb8 <dmaInit+0x58>)
 8001f6a:	2200      	movs	r2, #0
 8001f6c:	605a      	str	r2, [r3, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001f6e:	2300      	movs	r3, #0
 8001f70:	9301      	str	r3, [sp, #4]
 8001f72:	e013      	b.n	8001f9c <dmaInit+0x3c>
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001f74:	4911      	ldr	r1, [pc, #68]	@ (8001fbc <dmaInit+0x5c>)
 8001f76:	9a01      	ldr	r2, [sp, #4]
 8001f78:	4613      	mov	r3, r2
 8001f7a:	009b      	lsls	r3, r3, #2
 8001f7c:	4413      	add	r3, r2
 8001f7e:	009b      	lsls	r3, r3, #2
 8001f80:	440b      	add	r3, r1
 8001f82:	3304      	adds	r3, #4
 8001f84:	681b      	ldr	r3, [r3, #0]
 8001f86:	2200      	movs	r2, #0
 8001f88:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 8001f8a:	4a0b      	ldr	r2, [pc, #44]	@ (8001fb8 <dmaInit+0x58>)
 8001f8c:	9b01      	ldr	r3, [sp, #4]
 8001f8e:	3301      	adds	r3, #1
 8001f90:	2100      	movs	r1, #0
 8001f92:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001f96:	9b01      	ldr	r3, [sp, #4]
 8001f98:	3301      	adds	r3, #1
 8001f9a:	9301      	str	r3, [sp, #4]
 8001f9c:	9b01      	ldr	r3, [sp, #4]
 8001f9e:	2b0f      	cmp	r3, #15
 8001fa0:	dde8      	ble.n	8001f74 <dmaInit+0x14>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8001fa2:	4b07      	ldr	r3, [pc, #28]	@ (8001fc0 <dmaInit+0x60>)
 8001fa4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001fa8:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8001faa:	4b06      	ldr	r3, [pc, #24]	@ (8001fc4 <dmaInit+0x64>)
 8001fac:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001fb0:	605a      	str	r2, [r3, #4]
#endif
}
 8001fb2:	bf00      	nop
 8001fb4:	b002      	add	sp, #8
 8001fb6:	4770      	bx	lr
 8001fb8:	200008e4 	.word	0x200008e4
 8001fbc:	0800536c 	.word	0x0800536c
 8001fc0:	40020000 	.word	0x40020000
 8001fc4:	40020400 	.word	0x40020400
	...

08001fd0 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8001fd0:	b500      	push	{lr}
 8001fd2:	b08b      	sub	sp, #44	@ 0x2c
 8001fd4:	9003      	str	r0, [sp, #12]
 8001fd6:	9102      	str	r1, [sp, #8]
 8001fd8:	9201      	str	r2, [sp, #4]
 8001fda:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 8001fdc:	f000 fe48 	bl	8002c70 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 8001fe0:	9b03      	ldr	r3, [sp, #12]
 8001fe2:	2b0f      	cmp	r3, #15
 8001fe4:	d804      	bhi.n	8001ff0 <dmaStreamAllocI+0x20>
    startid = id;
 8001fe6:	9b03      	ldr	r3, [sp, #12]
 8001fe8:	9308      	str	r3, [sp, #32]
    endid   = id;
 8001fea:	9b03      	ldr	r3, [sp, #12]
 8001fec:	9307      	str	r3, [sp, #28]
 8001fee:	e01c      	b.n	800202a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA_SUPPORTS_DMAMUX == TRUE
  else if (id == STM32_DMA_STREAM_ID_ANY) {
 8001ff0:	9b03      	ldr	r3, [sp, #12]
 8001ff2:	2b10      	cmp	r3, #16
 8001ff4:	d104      	bne.n	8002000 <dmaStreamAllocI+0x30>
    startid = 0U;
 8001ff6:	2300      	movs	r3, #0
 8001ff8:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 8001ffa:	230f      	movs	r3, #15
 8001ffc:	9307      	str	r3, [sp, #28]
 8001ffe:	e014      	b.n	800202a <dmaStreamAllocI+0x5a>
  }
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA1) {
 8002000:	9b03      	ldr	r3, [sp, #12]
 8002002:	2b11      	cmp	r3, #17
 8002004:	d104      	bne.n	8002010 <dmaStreamAllocI+0x40>
    startid = 0U;
 8002006:	2300      	movs	r3, #0
 8002008:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA1_NUM_CHANNELS - 1U;
 800200a:	2307      	movs	r3, #7
 800200c:	9307      	str	r3, [sp, #28]
 800200e:	e00c      	b.n	800202a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA2) {
 8002010:	9b03      	ldr	r3, [sp, #12]
 8002012:	2b12      	cmp	r3, #18
 8002014:	d104      	bne.n	8002020 <dmaStreamAllocI+0x50>
    startid = STM32_DMA1_NUM_CHANNELS;
 8002016:	2308      	movs	r3, #8
 8002018:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 800201a:	230f      	movs	r3, #15
 800201c:	9307      	str	r3, [sp, #28]
 800201e:	e004      	b.n	800202a <dmaStreamAllocI+0x5a>
  }
#endif
#endif
  else {
    osalDbgCheck(false);
 8002020:	484f      	ldr	r0, [pc, #316]	@ (8002160 <dmaStreamAllocI+0x190>)
 8002022:	f000 fc85 	bl	8002930 <chSysHalt>
    return NULL;
 8002026:	2300      	movs	r3, #0
 8002028:	e095      	b.n	8002156 <dmaStreamAllocI+0x186>
  }

  for (i = startid; i <= endid; i++) {
 800202a:	9b08      	ldr	r3, [sp, #32]
 800202c:	9309      	str	r3, [sp, #36]	@ 0x24
 800202e:	e08c      	b.n	800214a <dmaStreamAllocI+0x17a>
    uint32_t mask = (1U << i);
 8002030:	2201      	movs	r2, #1
 8002032:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002034:	fa02 f303 	lsl.w	r3, r2, r3
 8002038:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 800203a:	4b4a      	ldr	r3, [pc, #296]	@ (8002164 <dmaStreamAllocI+0x194>)
 800203c:	681a      	ldr	r2, [r3, #0]
 800203e:	9b06      	ldr	r3, [sp, #24]
 8002040:	4013      	ands	r3, r2
 8002042:	2b00      	cmp	r3, #0
 8002044:	d17e      	bne.n	8002144 <dmaStreamAllocI+0x174>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8002046:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8002048:	4613      	mov	r3, r2
 800204a:	009b      	lsls	r3, r3, #2
 800204c:	4413      	add	r3, r2
 800204e:	009b      	lsls	r3, r3, #2
 8002050:	4a45      	ldr	r2, [pc, #276]	@ (8002168 <dmaStreamAllocI+0x198>)
 8002052:	4413      	add	r3, r2
 8002054:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8002056:	4943      	ldr	r1, [pc, #268]	@ (8002164 <dmaStreamAllocI+0x194>)
 8002058:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800205a:	3301      	adds	r3, #1
 800205c:	9a01      	ldr	r2, [sp, #4]
 800205e:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
      dma.streams[i].param = param;
 8002062:	4a40      	ldr	r2, [pc, #256]	@ (8002164 <dmaStreamAllocI+0x194>)
 8002064:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002066:	3301      	adds	r3, #1
 8002068:	00db      	lsls	r3, r3, #3
 800206a:	4413      	add	r3, r2
 800206c:	9a00      	ldr	r2, [sp, #0]
 800206e:	605a      	str	r2, [r3, #4]
      dma.allocated_mask  |= mask;
 8002070:	4b3c      	ldr	r3, [pc, #240]	@ (8002164 <dmaStreamAllocI+0x194>)
 8002072:	681a      	ldr	r2, [r3, #0]
 8002074:	9b06      	ldr	r3, [sp, #24]
 8002076:	4313      	orrs	r3, r2
 8002078:	4a3a      	ldr	r2, [pc, #232]	@ (8002164 <dmaStreamAllocI+0x194>)
 800207a:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 800207c:	9b06      	ldr	r3, [sp, #24]
 800207e:	b2db      	uxtb	r3, r3
 8002080:	2b00      	cmp	r3, #0
 8002082:	d00d      	beq.n	80020a0 <dmaStreamAllocI+0xd0>
        rccEnableDMA1(true);
 8002084:	4b39      	ldr	r3, [pc, #228]	@ (800216c <dmaStreamAllocI+0x19c>)
 8002086:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8002088:	4a38      	ldr	r2, [pc, #224]	@ (800216c <dmaStreamAllocI+0x19c>)
 800208a:	f043 0301 	orr.w	r3, r3, #1
 800208e:	6493      	str	r3, [r2, #72]	@ 0x48
 8002090:	4b36      	ldr	r3, [pc, #216]	@ (800216c <dmaStreamAllocI+0x19c>)
 8002092:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8002094:	4a35      	ldr	r2, [pc, #212]	@ (800216c <dmaStreamAllocI+0x19c>)
 8002096:	f043 0301 	orr.w	r3, r3, #1
 800209a:	6693      	str	r3, [r2, #104]	@ 0x68
 800209c:	4b33      	ldr	r3, [pc, #204]	@ (800216c <dmaStreamAllocI+0x19c>)
 800209e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#if STM32_DMA2_NUM_CHANNELS > 0
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 80020a0:	9b06      	ldr	r3, [sp, #24]
 80020a2:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
 80020a6:	2b00      	cmp	r3, #0
 80020a8:	d00d      	beq.n	80020c6 <dmaStreamAllocI+0xf6>
        rccEnableDMA2(true);
 80020aa:	4b30      	ldr	r3, [pc, #192]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020ac:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80020ae:	4a2f      	ldr	r2, [pc, #188]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020b0:	f043 0302 	orr.w	r3, r3, #2
 80020b4:	6493      	str	r3, [r2, #72]	@ 0x48
 80020b6:	4b2d      	ldr	r3, [pc, #180]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020b8:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80020ba:	4a2c      	ldr	r2, [pc, #176]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020bc:	f043 0302 	orr.w	r3, r3, #2
 80020c0:	6693      	str	r3, [r2, #104]	@ 0x68
 80020c2:	4b2a      	ldr	r3, [pc, #168]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020c4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

#if (STM32_DMA_SUPPORTS_DMAMUX == TRUE) && defined(rccEnableDMAMUX)
      /* Enabling DMAMUX if present.*/
      if (dma.allocated_mask != 0U) {
 80020c6:	4b27      	ldr	r3, [pc, #156]	@ (8002164 <dmaStreamAllocI+0x194>)
 80020c8:	681b      	ldr	r3, [r3, #0]
 80020ca:	2b00      	cmp	r3, #0
 80020cc:	d00d      	beq.n	80020ea <dmaStreamAllocI+0x11a>
        rccEnableDMAMUX(true);
 80020ce:	4b27      	ldr	r3, [pc, #156]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020d0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80020d2:	4a26      	ldr	r2, [pc, #152]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020d4:	f043 0304 	orr.w	r3, r3, #4
 80020d8:	6493      	str	r3, [r2, #72]	@ 0x48
 80020da:	4b24      	ldr	r3, [pc, #144]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020dc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80020de:	4a23      	ldr	r2, [pc, #140]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020e0:	f043 0304 	orr.w	r3, r3, #4
 80020e4:	6693      	str	r3, [r2, #104]	@ 0x68
 80020e6:	4b21      	ldr	r3, [pc, #132]	@ (800216c <dmaStreamAllocI+0x19c>)
 80020e8:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 80020ea:	9b01      	ldr	r3, [sp, #4]
 80020ec:	2b00      	cmp	r3, #0
 80020ee:	d012      	beq.n	8002116 <dmaStreamAllocI+0x146>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 80020f0:	4b1c      	ldr	r3, [pc, #112]	@ (8002164 <dmaStreamAllocI+0x194>)
 80020f2:	685a      	ldr	r2, [r3, #4]
 80020f4:	9b05      	ldr	r3, [sp, #20]
 80020f6:	689b      	ldr	r3, [r3, #8]
 80020f8:	4013      	ands	r3, r2
 80020fa:	2b00      	cmp	r3, #0
 80020fc:	d105      	bne.n	800210a <dmaStreamAllocI+0x13a>
          nvicEnableVector(dmastp->vector, priority);
 80020fe:	9b05      	ldr	r3, [sp, #20]
 8002100:	7c9b      	ldrb	r3, [r3, #18]
 8002102:	9902      	ldr	r1, [sp, #8]
 8002104:	4618      	mov	r0, r3
 8002106:	f7fe fd6b 	bl	8000be0 <nvicEnableVector>
        }
        dma.isr_mask |= mask;
 800210a:	4b16      	ldr	r3, [pc, #88]	@ (8002164 <dmaStreamAllocI+0x194>)
 800210c:	685a      	ldr	r2, [r3, #4]
 800210e:	9b06      	ldr	r3, [sp, #24]
 8002110:	4313      	orrs	r3, r2
 8002112:	4a14      	ldr	r2, [pc, #80]	@ (8002164 <dmaStreamAllocI+0x194>)
 8002114:	6053      	str	r3, [r2, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 8002116:	9b05      	ldr	r3, [sp, #20]
 8002118:	685b      	ldr	r3, [r3, #4]
 800211a:	681a      	ldr	r2, [r3, #0]
 800211c:	9b05      	ldr	r3, [sp, #20]
 800211e:	685b      	ldr	r3, [r3, #4]
 8002120:	f022 020f 	bic.w	r2, r2, #15
 8002124:	601a      	str	r2, [r3, #0]
 8002126:	9b05      	ldr	r3, [sp, #20]
 8002128:	7c1b      	ldrb	r3, [r3, #16]
 800212a:	461a      	mov	r2, r3
 800212c:	230e      	movs	r3, #14
 800212e:	fa03 f202 	lsl.w	r2, r3, r2
 8002132:	9b05      	ldr	r3, [sp, #20]
 8002134:	681b      	ldr	r3, [r3, #0]
 8002136:	605a      	str	r2, [r3, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8002138:	9b05      	ldr	r3, [sp, #20]
 800213a:	685b      	ldr	r3, [r3, #4]
 800213c:	2200      	movs	r2, #0
 800213e:	601a      	str	r2, [r3, #0]

      return dmastp;
 8002140:	9b05      	ldr	r3, [sp, #20]
 8002142:	e008      	b.n	8002156 <dmaStreamAllocI+0x186>
  for (i = startid; i <= endid; i++) {
 8002144:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002146:	3301      	adds	r3, #1
 8002148:	9309      	str	r3, [sp, #36]	@ 0x24
 800214a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800214c:	9b07      	ldr	r3, [sp, #28]
 800214e:	429a      	cmp	r2, r3
 8002150:	f67f af6e 	bls.w	8002030 <dmaStreamAllocI+0x60>
    }
  }

  return NULL;
 8002154:	2300      	movs	r3, #0
}
 8002156:	4618      	mov	r0, r3
 8002158:	b00b      	add	sp, #44	@ 0x2c
 800215a:	f85d fb04 	ldr.w	pc, [sp], #4
 800215e:	bf00      	nop
 8002160:	080054ac 	.word	0x080054ac
 8002164:	200008e4 	.word	0x200008e4
 8002168:	0800536c 	.word	0x0800536c
 800216c:	40021000 	.word	0x40021000

08002170 <dmaServeInterrupt>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
 8002170:	b500      	push	{lr}
 8002172:	b085      	sub	sp, #20
 8002174:	9001      	str	r0, [sp, #4]
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;
 8002176:	9b01      	ldr	r3, [sp, #4]
 8002178:	7c5b      	ldrb	r3, [r3, #17]
 800217a:	9303      	str	r3, [sp, #12]

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 800217c:	9b01      	ldr	r3, [sp, #4]
 800217e:	681b      	ldr	r3, [r3, #0]
 8002180:	681b      	ldr	r3, [r3, #0]
 8002182:	9a01      	ldr	r2, [sp, #4]
 8002184:	7c12      	ldrb	r2, [r2, #16]
 8002186:	40d3      	lsrs	r3, r2
 8002188:	f003 030e 	and.w	r3, r3, #14
 800218c:	9302      	str	r3, [sp, #8]
  if (flags & dmastp->channel->CCR) {
 800218e:	9b01      	ldr	r3, [sp, #4]
 8002190:	685b      	ldr	r3, [r3, #4]
 8002192:	681a      	ldr	r2, [r3, #0]
 8002194:	9b02      	ldr	r3, [sp, #8]
 8002196:	4013      	ands	r3, r2
 8002198:	2b00      	cmp	r3, #0
 800219a:	d01c      	beq.n	80021d6 <dmaServeInterrupt+0x66>
    dmastp->dma->IFCR = flags << dmastp->shift;
 800219c:	9b01      	ldr	r3, [sp, #4]
 800219e:	7c1b      	ldrb	r3, [r3, #16]
 80021a0:	4619      	mov	r1, r3
 80021a2:	9b01      	ldr	r3, [sp, #4]
 80021a4:	681b      	ldr	r3, [r3, #0]
 80021a6:	9a02      	ldr	r2, [sp, #8]
 80021a8:	408a      	lsls	r2, r1
 80021aa:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 80021ac:	4a0c      	ldr	r2, [pc, #48]	@ (80021e0 <dmaServeInterrupt+0x70>)
 80021ae:	9b03      	ldr	r3, [sp, #12]
 80021b0:	3301      	adds	r3, #1
 80021b2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80021b6:	2b00      	cmp	r3, #0
 80021b8:	d00d      	beq.n	80021d6 <dmaServeInterrupt+0x66>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 80021ba:	4a09      	ldr	r2, [pc, #36]	@ (80021e0 <dmaServeInterrupt+0x70>)
 80021bc:	9b03      	ldr	r3, [sp, #12]
 80021be:	3301      	adds	r3, #1
 80021c0:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 80021c4:	4906      	ldr	r1, [pc, #24]	@ (80021e0 <dmaServeInterrupt+0x70>)
 80021c6:	9b03      	ldr	r3, [sp, #12]
 80021c8:	3301      	adds	r3, #1
 80021ca:	00db      	lsls	r3, r3, #3
 80021cc:	440b      	add	r3, r1
 80021ce:	685b      	ldr	r3, [r3, #4]
 80021d0:	9902      	ldr	r1, [sp, #8]
 80021d2:	4618      	mov	r0, r3
 80021d4:	4790      	blx	r2
    }
  }
}
 80021d6:	bf00      	nop
 80021d8:	b005      	add	sp, #20
 80021da:	f85d fb04 	ldr.w	pc, [sp], #4
 80021de:	bf00      	nop
 80021e0:	200008e4 	.word	0x200008e4
	...

080021f0 <dmaSetRequestSource>:
 * @param[in] dmastp    pointer to a @p stm32_dma_stream_t structure
 * @param[in] per       peripheral identifier
 *
 * @special
 */
void dmaSetRequestSource(const stm32_dma_stream_t *dmastp, uint32_t per) {
 80021f0:	b500      	push	{lr}
 80021f2:	b083      	sub	sp, #12
 80021f4:	9001      	str	r0, [sp, #4]
 80021f6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(per < 256U);
 80021f8:	9b00      	ldr	r3, [sp, #0]
 80021fa:	2bff      	cmp	r3, #255	@ 0xff
 80021fc:	bf8c      	ite	hi
 80021fe:	2301      	movhi	r3, #1
 8002200:	2300      	movls	r3, #0
 8002202:	b2db      	uxtb	r3, r3
 8002204:	2b00      	cmp	r3, #0
 8002206:	d002      	beq.n	800220e <dmaSetRequestSource+0x1e>
 8002208:	4805      	ldr	r0, [pc, #20]	@ (8002220 <dmaSetRequestSource+0x30>)
 800220a:	f000 fb91 	bl	8002930 <chSysHalt>

  dmastp->mux->CCR = per;
 800220e:	9b01      	ldr	r3, [sp, #4]
 8002210:	68db      	ldr	r3, [r3, #12]
 8002212:	9a00      	ldr	r2, [sp, #0]
 8002214:	601a      	str	r2, [r3, #0]
}
 8002216:	bf00      	nop
 8002218:	b003      	add	sp, #12
 800221a:	f85d fb04 	ldr.w	pc, [sp], #4
 800221e:	bf00      	nop
 8002220:	080054bc 	.word	0x080054bc
	...

08002230 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8002230:	bf00      	nop
 8002232:	4770      	bx	lr
	...

08002240 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8002240:	b08e      	sub	sp, #56	@ 0x38
 8002242:	9003      	str	r0, [sp, #12]
 8002244:	9102      	str	r1, [sp, #8]
 8002246:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8002248:	9b01      	ldr	r3, [sp, #4]
 800224a:	f003 0303 	and.w	r3, r3, #3
 800224e:	930d      	str	r3, [sp, #52]	@ 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8002250:	9b01      	ldr	r3, [sp, #4]
 8002252:	089b      	lsrs	r3, r3, #2
 8002254:	f003 0301 	and.w	r3, r3, #1
 8002258:	930c      	str	r3, [sp, #48]	@ 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800225a:	9b01      	ldr	r3, [sp, #4]
 800225c:	08db      	lsrs	r3, r3, #3
 800225e:	f003 0303 	and.w	r3, r3, #3
 8002262:	930b      	str	r3, [sp, #44]	@ 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8002264:	9b01      	ldr	r3, [sp, #4]
 8002266:	095b      	lsrs	r3, r3, #5
 8002268:	f003 0303 	and.w	r3, r3, #3
 800226c:	930a      	str	r3, [sp, #40]	@ 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800226e:	9b01      	ldr	r3, [sp, #4]
 8002270:	09db      	lsrs	r3, r3, #7
 8002272:	f003 030f 	and.w	r3, r3, #15
 8002276:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8002278:	2300      	movs	r3, #0
 800227a:	9309      	str	r3, [sp, #36]	@ 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800227c:	9b02      	ldr	r3, [sp, #8]
 800227e:	f003 0301 	and.w	r3, r3, #1
 8002282:	2b00      	cmp	r3, #0
 8002284:	d079      	beq.n	800237a <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8002286:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002288:	f003 0307 	and.w	r3, r3, #7
 800228c:	009b      	lsls	r3, r3, #2
 800228e:	9a08      	ldr	r2, [sp, #32]
 8002290:	fa02 f303 	lsl.w	r3, r2, r3
 8002294:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8002296:	2201      	movs	r2, #1
 8002298:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800229a:	fa02 f303 	lsl.w	r3, r2, r3
 800229e:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 80022a0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80022a2:	005b      	lsls	r3, r3, #1
 80022a4:	2203      	movs	r2, #3
 80022a6:	fa02 f303 	lsl.w	r3, r2, r3
 80022aa:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 80022ac:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80022ae:	f003 0307 	and.w	r3, r3, #7
 80022b2:	009b      	lsls	r3, r3, #2
 80022b4:	220f      	movs	r2, #15
 80022b6:	fa02 f303 	lsl.w	r3, r2, r3
 80022ba:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80022bc:	9b03      	ldr	r3, [sp, #12]
 80022be:	685a      	ldr	r2, [r3, #4]
 80022c0:	9b06      	ldr	r3, [sp, #24]
 80022c2:	43db      	mvns	r3, r3
 80022c4:	401a      	ands	r2, r3
 80022c6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 80022c8:	431a      	orrs	r2, r3
 80022ca:	9b03      	ldr	r3, [sp, #12]
 80022cc:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80022ce:	9b03      	ldr	r3, [sp, #12]
 80022d0:	689a      	ldr	r2, [r3, #8]
 80022d2:	9b05      	ldr	r3, [sp, #20]
 80022d4:	43db      	mvns	r3, r3
 80022d6:	401a      	ands	r2, r3
 80022d8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80022da:	431a      	orrs	r2, r3
 80022dc:	9b03      	ldr	r3, [sp, #12]
 80022de:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80022e0:	9b03      	ldr	r3, [sp, #12]
 80022e2:	68da      	ldr	r2, [r3, #12]
 80022e4:	9b05      	ldr	r3, [sp, #20]
 80022e6:	43db      	mvns	r3, r3
 80022e8:	401a      	ands	r2, r3
 80022ea:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80022ec:	431a      	orrs	r2, r3
 80022ee:	9b03      	ldr	r3, [sp, #12]
 80022f0:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80022f2:	9b01      	ldr	r3, [sp, #4]
 80022f4:	f003 0303 	and.w	r3, r3, #3
 80022f8:	2b02      	cmp	r3, #2
 80022fa:	d11f      	bne.n	800233c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80022fc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80022fe:	2b07      	cmp	r3, #7
 8002300:	d809      	bhi.n	8002316 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8002302:	9b03      	ldr	r3, [sp, #12]
 8002304:	6a1a      	ldr	r2, [r3, #32]
 8002306:	9b04      	ldr	r3, [sp, #16]
 8002308:	43db      	mvns	r3, r3
 800230a:	401a      	ands	r2, r3
 800230c:	9b07      	ldr	r3, [sp, #28]
 800230e:	431a      	orrs	r2, r3
 8002310:	9b03      	ldr	r3, [sp, #12]
 8002312:	621a      	str	r2, [r3, #32]
 8002314:	e008      	b.n	8002328 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8002316:	9b03      	ldr	r3, [sp, #12]
 8002318:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800231a:	9b04      	ldr	r3, [sp, #16]
 800231c:	43db      	mvns	r3, r3
 800231e:	401a      	ands	r2, r3
 8002320:	9b07      	ldr	r3, [sp, #28]
 8002322:	431a      	orrs	r2, r3
 8002324:	9b03      	ldr	r3, [sp, #12]
 8002326:	625a      	str	r2, [r3, #36]	@ 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8002328:	9b03      	ldr	r3, [sp, #12]
 800232a:	681a      	ldr	r2, [r3, #0]
 800232c:	9b05      	ldr	r3, [sp, #20]
 800232e:	43db      	mvns	r3, r3
 8002330:	401a      	ands	r2, r3
 8002332:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8002334:	431a      	orrs	r2, r3
 8002336:	9b03      	ldr	r3, [sp, #12]
 8002338:	601a      	str	r2, [r3, #0]
 800233a:	e01e      	b.n	800237a <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800233c:	9b03      	ldr	r3, [sp, #12]
 800233e:	681a      	ldr	r2, [r3, #0]
 8002340:	9b05      	ldr	r3, [sp, #20]
 8002342:	43db      	mvns	r3, r3
 8002344:	401a      	ands	r2, r3
 8002346:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8002348:	431a      	orrs	r2, r3
 800234a:	9b03      	ldr	r3, [sp, #12]
 800234c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 800234e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002350:	2b07      	cmp	r3, #7
 8002352:	d809      	bhi.n	8002368 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8002354:	9b03      	ldr	r3, [sp, #12]
 8002356:	6a1a      	ldr	r2, [r3, #32]
 8002358:	9b04      	ldr	r3, [sp, #16]
 800235a:	43db      	mvns	r3, r3
 800235c:	401a      	ands	r2, r3
 800235e:	9b07      	ldr	r3, [sp, #28]
 8002360:	431a      	orrs	r2, r3
 8002362:	9b03      	ldr	r3, [sp, #12]
 8002364:	621a      	str	r2, [r3, #32]
 8002366:	e008      	b.n	800237a <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8002368:	9b03      	ldr	r3, [sp, #12]
 800236a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800236c:	9b04      	ldr	r3, [sp, #16]
 800236e:	43db      	mvns	r3, r3
 8002370:	401a      	ands	r2, r3
 8002372:	9b07      	ldr	r3, [sp, #28]
 8002374:	431a      	orrs	r2, r3
 8002376:	9b03      	ldr	r3, [sp, #12]
 8002378:	625a      	str	r2, [r3, #36]	@ 0x24
      }
    }
    mask >>= 1;
 800237a:	9b02      	ldr	r3, [sp, #8]
 800237c:	085b      	lsrs	r3, r3, #1
 800237e:	9302      	str	r3, [sp, #8]
    if (!mask)
 8002380:	9b02      	ldr	r3, [sp, #8]
 8002382:	2b00      	cmp	r3, #0
 8002384:	d00f      	beq.n	80023a6 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 8002386:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8002388:	005b      	lsls	r3, r3, #1
 800238a:	930c      	str	r3, [sp, #48]	@ 0x30
    ospeedr <<= 2;
 800238c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800238e:	009b      	lsls	r3, r3, #2
 8002390:	930b      	str	r3, [sp, #44]	@ 0x2c
    pupdr <<= 2;
 8002392:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002394:	009b      	lsls	r3, r3, #2
 8002396:	930a      	str	r3, [sp, #40]	@ 0x28
    moder <<= 2;
 8002398:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800239a:	009b      	lsls	r3, r3, #2
 800239c:	930d      	str	r3, [sp, #52]	@ 0x34
    bit++;
 800239e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80023a0:	3301      	adds	r3, #1
 80023a2:	9309      	str	r3, [sp, #36]	@ 0x24
    if ((mask & 1) != 0) {
 80023a4:	e76a      	b.n	800227c <_pal_lld_setgroupmode+0x3c>
      return;
 80023a6:	bf00      	nop
  }
}
 80023a8:	b00e      	add	sp, #56	@ 0x38
 80023aa:	4770      	bx	lr
 80023ac:	0000      	movs	r0, r0
	...

080023b0 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 80023b0:	b500      	push	{lr}
 80023b2:	b083      	sub	sp, #12
 80023b4:	2330      	movs	r3, #48	@ 0x30
 80023b6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80023b8:	9b01      	ldr	r3, [sp, #4]
 80023ba:	f383 8811 	msr	BASEPRI, r3
}
 80023be:	bf00      	nop
}
 80023c0:	bf00      	nop
}
 80023c2:	bf00      	nop
  __dbg_check_lock_from_isr();
 80023c4:	f000 fb8c 	bl	8002ae0 <__dbg_check_lock_from_isr>
}
 80023c8:	bf00      	nop
 80023ca:	b003      	add	sp, #12
 80023cc:	f85d fb04 	ldr.w	pc, [sp], #4

080023d0 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 80023d0:	b500      	push	{lr}
 80023d2:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 80023d4:	f000 fbac 	bl	8002b30 <__dbg_check_unlock_from_isr>
 80023d8:	2300      	movs	r3, #0
 80023da:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80023dc:	9b01      	ldr	r3, [sp, #4]
 80023de:	f383 8811 	msr	BASEPRI, r3
}
 80023e2:	bf00      	nop
}
 80023e4:	bf00      	nop
}
 80023e6:	bf00      	nop
}
 80023e8:	bf00      	nop
 80023ea:	b003      	add	sp, #12
 80023ec:	f85d fb04 	ldr.w	pc, [sp], #4

080023f0 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 80023f0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80023f2:	f7ff ffdd 	bl	80023b0 <chSysLockFromISR.lto_priv.1>
}
 80023f6:	bf00      	nop
 80023f8:	bd08      	pop	{r3, pc}
 80023fa:	bf00      	nop
 80023fc:	0000      	movs	r0, r0
	...

08002400 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 8002400:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002402:	f7ff ffe5 	bl	80023d0 <chSysUnlockFromISR.lto_priv.1>
}
 8002406:	bf00      	nop
 8002408:	bd08      	pop	{r3, pc}
 800240a:	bf00      	nop
 800240c:	0000      	movs	r0, r0
	...

08002410 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 8002410:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 8002412:	f000 fac5 	bl	80029a0 <chSysTimerHandlerI>
}
 8002416:	bf00      	nop
 8002418:	bd08      	pop	{r3, pc}
 800241a:	bf00      	nop
 800241c:	0000      	movs	r0, r0
	...

08002420 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002420:	4b1b      	ldr	r3, [pc, #108]	@ (8002490 <st_lld_init+0x70>)
 8002422:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002424:	4a1a      	ldr	r2, [pc, #104]	@ (8002490 <st_lld_init+0x70>)
 8002426:	f043 0301 	orr.w	r3, r3, #1
 800242a:	6593      	str	r3, [r2, #88]	@ 0x58
 800242c:	4b18      	ldr	r3, [pc, #96]	@ (8002490 <st_lld_init+0x70>)
 800242e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8002430:	4a17      	ldr	r2, [pc, #92]	@ (8002490 <st_lld_init+0x70>)
 8002432:	f043 0301 	orr.w	r3, r3, #1
 8002436:	6793      	str	r3, [r2, #120]	@ 0x78
 8002438:	4b15      	ldr	r3, [pc, #84]	@ (8002490 <st_lld_init+0x70>)
 800243a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800243c:	4b15      	ldr	r3, [pc, #84]	@ (8002494 <st_lld_init+0x74>)
 800243e:	689b      	ldr	r3, [r3, #8]
 8002440:	4a14      	ldr	r2, [pc, #80]	@ (8002494 <st_lld_init+0x74>)
 8002442:	f043 0301 	orr.w	r3, r3, #1
 8002446:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002448:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800244c:	f244 2267 	movw	r2, #16999	@ 0x4267
 8002450:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002452:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002456:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800245a:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800245c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002460:	2200      	movs	r2, #0
 8002462:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002464:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002468:	2200      	movs	r2, #0
 800246a:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 800246c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002470:	2200      	movs	r2, #0
 8002472:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002474:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002478:	2200      	movs	r2, #0
 800247a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800247c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002480:	2201      	movs	r2, #1
 8002482:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002484:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002488:	2201      	movs	r2, #1
 800248a:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800248c:	bf00      	nop
 800248e:	4770      	bx	lr
 8002490:	40021000 	.word	0x40021000
 8002494:	e0042000 	.word	0xe0042000
	...

080024a0 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 80024a0:	b500      	push	{lr}
 80024a2:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 80024a4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80024a8:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 80024aa:	9b01      	ldr	r3, [sp, #4]
 80024ac:	691b      	ldr	r3, [r3, #16]
 80024ae:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 80024b0:	9b01      	ldr	r3, [sp, #4]
 80024b2:	68db      	ldr	r3, [r3, #12]
 80024b4:	b2db      	uxtb	r3, r3
 80024b6:	9a00      	ldr	r2, [sp, #0]
 80024b8:	4013      	ands	r3, r2
 80024ba:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 80024bc:	9b00      	ldr	r3, [sp, #0]
 80024be:	43da      	mvns	r2, r3
 80024c0:	9b01      	ldr	r3, [sp, #4]
 80024c2:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 80024c4:	9b00      	ldr	r3, [sp, #0]
 80024c6:	f003 0302 	and.w	r3, r3, #2
 80024ca:	2b00      	cmp	r3, #0
 80024cc:	d005      	beq.n	80024da <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 80024ce:	f7ff ff8f 	bl	80023f0 <osalSysLockFromISR.lto_priv.1>
    osalOsTimerHandlerI();
 80024d2:	f7ff ff9d 	bl	8002410 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80024d6:	f7ff ff93 	bl	8002400 <osalSysUnlockFromISR.lto_priv.1>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 80024da:	bf00      	nop
 80024dc:	b003      	add	sp, #12
 80024de:	f85d fb04 	ldr.w	pc, [sp], #4
 80024e2:	bf00      	nop
	...

080024f0 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 80024f0:	b508      	push	{r3, lr}
  gptObjectInit(&GPTD3);
#endif

#if STM32_GPT_USE_TIM4
  /* Driver initialization.*/
  GPTD4.tim = STM32_TIM4;
 80024f2:	4b04      	ldr	r3, [pc, #16]	@ (8002504 <gpt_lld_init+0x14>)
 80024f4:	4a04      	ldr	r2, [pc, #16]	@ (8002508 <gpt_lld_init+0x18>)
 80024f6:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD4);
 80024f8:	4802      	ldr	r0, [pc, #8]	@ (8002504 <gpt_lld_init+0x14>)
 80024fa:	f7fe fa59 	bl	80009b0 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 80024fe:	bf00      	nop
 8002500:	bd08      	pop	{r3, pc}
 8002502:	bf00      	nop
 8002504:	2000096c 	.word	0x2000096c
 8002508:	40000800 	.word	0x40000800
 800250c:	00000000 	.word	0x00000000

08002510 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 8002510:	b500      	push	{lr}
 8002512:	b085      	sub	sp, #20
 8002514:	9001      	str	r0, [sp, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 8002516:	9b01      	ldr	r3, [sp, #4]
 8002518:	781b      	ldrb	r3, [r3, #0]
 800251a:	2b01      	cmp	r3, #1
 800251c:	d122      	bne.n	8002564 <gpt_lld_start+0x54>
#endif
    }
#endif

#if STM32_GPT_USE_TIM4
    if (&GPTD4 == gptp) {
 800251e:	9b01      	ldr	r3, [sp, #4]
 8002520:	4a30      	ldr	r2, [pc, #192]	@ (80025e4 <gpt_lld_start+0xd4>)
 8002522:	4293      	cmp	r3, r2
 8002524:	d11e      	bne.n	8002564 <gpt_lld_start+0x54>
      rccEnableTIM4(true);
 8002526:	4b30      	ldr	r3, [pc, #192]	@ (80025e8 <gpt_lld_start+0xd8>)
 8002528:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800252a:	4a2f      	ldr	r2, [pc, #188]	@ (80025e8 <gpt_lld_start+0xd8>)
 800252c:	f043 0304 	orr.w	r3, r3, #4
 8002530:	6593      	str	r3, [r2, #88]	@ 0x58
 8002532:	4b2d      	ldr	r3, [pc, #180]	@ (80025e8 <gpt_lld_start+0xd8>)
 8002534:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8002536:	4a2c      	ldr	r2, [pc, #176]	@ (80025e8 <gpt_lld_start+0xd8>)
 8002538:	f043 0304 	orr.w	r3, r3, #4
 800253c:	6793      	str	r3, [r2, #120]	@ 0x78
 800253e:	4b2a      	ldr	r3, [pc, #168]	@ (80025e8 <gpt_lld_start+0xd8>)
 8002540:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
      rccResetTIM4();
 8002542:	4b29      	ldr	r3, [pc, #164]	@ (80025e8 <gpt_lld_start+0xd8>)
 8002544:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002546:	4a28      	ldr	r2, [pc, #160]	@ (80025e8 <gpt_lld_start+0xd8>)
 8002548:	f043 0304 	orr.w	r3, r3, #4
 800254c:	6393      	str	r3, [r2, #56]	@ 0x38
 800254e:	4b26      	ldr	r3, [pc, #152]	@ (80025e8 <gpt_lld_start+0xd8>)
 8002550:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002552:	4a25      	ldr	r2, [pc, #148]	@ (80025e8 <gpt_lld_start+0xd8>)
 8002554:	f023 0304 	bic.w	r3, r3, #4
 8002558:	6393      	str	r3, [r2, #56]	@ 0x38
 800255a:	4b23      	ldr	r3, [pc, #140]	@ (80025e8 <gpt_lld_start+0xd8>)
 800255c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_GPT_TIM4_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM4CLK)
      gptp->clock = STM32_TIM4CLK;
#else
      gptp->clock = STM32_TIMCLK1;
 800255e:	9b01      	ldr	r3, [sp, #4]
 8002560:	4a22      	ldr	r2, [pc, #136]	@ (80025ec <gpt_lld_start+0xdc>)
 8002562:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8002564:	9b01      	ldr	r3, [sp, #4]
 8002566:	689a      	ldr	r2, [r3, #8]
 8002568:	9b01      	ldr	r3, [sp, #4]
 800256a:	685b      	ldr	r3, [r3, #4]
 800256c:	681b      	ldr	r3, [r3, #0]
 800256e:	fbb2 f3f3 	udiv	r3, r2, r3
 8002572:	b29b      	uxth	r3, r3
 8002574:	3b01      	subs	r3, #1
 8002576:	f8ad 300e 	strh.w	r3, [sp, #14]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
 800257a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800257e:	3301      	adds	r3, #1
 8002580:	461a      	mov	r2, r3
 8002582:	9b01      	ldr	r3, [sp, #4]
 8002584:	685b      	ldr	r3, [r3, #4]
 8002586:	681b      	ldr	r3, [r3, #0]
 8002588:	fb03 f202 	mul.w	r2, r3, r2
 800258c:	9b01      	ldr	r3, [sp, #4]
 800258e:	689b      	ldr	r3, [r3, #8]
 8002590:	429a      	cmp	r2, r3
 8002592:	bf14      	ite	ne
 8002594:	2301      	movne	r3, #1
 8002596:	2300      	moveq	r3, #0
 8002598:	b2db      	uxtb	r3, r3
 800259a:	2b00      	cmp	r3, #0
 800259c:	d002      	beq.n	80025a4 <gpt_lld_start+0x94>
 800259e:	4814      	ldr	r0, [pc, #80]	@ (80025f0 <gpt_lld_start+0xe0>)
 80025a0:	f000 f9c6 	bl	8002930 <chSysHalt>
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0U;                         /* Initially stopped.       */
 80025a4:	9b01      	ldr	r3, [sp, #4]
 80025a6:	68db      	ldr	r3, [r3, #12]
 80025a8:	2200      	movs	r2, #0
 80025aa:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 80025ac:	9b01      	ldr	r3, [sp, #4]
 80025ae:	685a      	ldr	r2, [r3, #4]
 80025b0:	9b01      	ldr	r3, [sp, #4]
 80025b2:	68db      	ldr	r3, [r3, #12]
 80025b4:	6892      	ldr	r2, [r2, #8]
 80025b6:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 80025b8:	9b01      	ldr	r3, [sp, #4]
 80025ba:	68db      	ldr	r3, [r3, #12]
 80025bc:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 80025c0:	629a      	str	r2, [r3, #40]	@ 0x28
  gptp->tim->SR   = 0U;                         /* Clear pending IRQs.      */
 80025c2:	9b01      	ldr	r3, [sp, #4]
 80025c4:	68db      	ldr	r3, [r3, #12]
 80025c6:	2200      	movs	r2, #0
 80025c8:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 80025ca:	9b01      	ldr	r3, [sp, #4]
 80025cc:	685b      	ldr	r3, [r3, #4]
 80025ce:	68da      	ldr	r2, [r3, #12]
 80025d0:	9b01      	ldr	r3, [sp, #4]
 80025d2:	68db      	ldr	r3, [r3, #12]
 80025d4:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 80025d8:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 80025da:	bf00      	nop
 80025dc:	b005      	add	sp, #20
 80025de:	f85d fb04 	ldr.w	pc, [sp], #4
 80025e2:	bf00      	nop
 80025e4:	2000096c 	.word	0x2000096c
 80025e8:	40021000 	.word	0x40021000
 80025ec:	0a21fe80 	.word	0x0a21fe80
 80025f0:	080054d0 	.word	0x080054d0
	...

08002600 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 8002600:	b082      	sub	sp, #8
 8002602:	9001      	str	r0, [sp, #4]
 8002604:	9100      	str	r1, [sp, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8002606:	9b01      	ldr	r3, [sp, #4]
 8002608:	68db      	ldr	r3, [r3, #12]
 800260a:	9a00      	ldr	r2, [sp, #0]
 800260c:	3a01      	subs	r2, #1
 800260e:	62da      	str	r2, [r3, #44]	@ 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 8002610:	9b01      	ldr	r3, [sp, #4]
 8002612:	68db      	ldr	r3, [r3, #12]
 8002614:	2201      	movs	r2, #1
 8002616:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0U;                          /* Reset counter.           */
 8002618:	9b01      	ldr	r3, [sp, #4]
 800261a:	68db      	ldr	r3, [r3, #12]
 800261c:	2200      	movs	r2, #0
 800261e:	625a      	str	r2, [r3, #36]	@ 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8002620:	9b01      	ldr	r3, [sp, #4]
 8002622:	68db      	ldr	r3, [r3, #12]
 8002624:	2200      	movs	r2, #0
 8002626:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8002628:	9b01      	ldr	r3, [sp, #4]
 800262a:	685b      	ldr	r3, [r3, #4]
 800262c:	685b      	ldr	r3, [r3, #4]
 800262e:	2b00      	cmp	r3, #0
 8002630:	d007      	beq.n	8002642 <gpt_lld_start_timer+0x42>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8002632:	9b01      	ldr	r3, [sp, #4]
 8002634:	68db      	ldr	r3, [r3, #12]
 8002636:	68da      	ldr	r2, [r3, #12]
 8002638:	9b01      	ldr	r3, [sp, #4]
 800263a:	68db      	ldr	r3, [r3, #12]
 800263c:	f042 0201 	orr.w	r2, r2, #1
 8002640:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8002642:	9b01      	ldr	r3, [sp, #4]
 8002644:	68db      	ldr	r3, [r3, #12]
 8002646:	2285      	movs	r2, #133	@ 0x85
 8002648:	601a      	str	r2, [r3, #0]
}
 800264a:	bf00      	nop
 800264c:	b002      	add	sp, #8
 800264e:	4770      	bx	lr

08002650 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 8002650:	b082      	sub	sp, #8
 8002652:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1 = 0U;                          /* Initially stopped.       */
 8002654:	9b01      	ldr	r3, [sp, #4]
 8002656:	68db      	ldr	r3, [r3, #12]
 8002658:	2200      	movs	r2, #0
 800265a:	601a      	str	r2, [r3, #0]
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 800265c:	9b01      	ldr	r3, [sp, #4]
 800265e:	68db      	ldr	r3, [r3, #12]
 8002660:	2200      	movs	r2, #0
 8002662:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8002664:	9b01      	ldr	r3, [sp, #4]
 8002666:	68db      	ldr	r3, [r3, #12]
 8002668:	68da      	ldr	r2, [r3, #12]
 800266a:	9b01      	ldr	r3, [sp, #4]
 800266c:	68db      	ldr	r3, [r3, #12]
 800266e:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002672:	60da      	str	r2, [r3, #12]
}
 8002674:	bf00      	nop
 8002676:	b002      	add	sp, #8
 8002678:	4770      	bx	lr
 800267a:	bf00      	nop
 800267c:	0000      	movs	r0, r0
	...

08002680 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 8002680:	b500      	push	{lr}
 8002682:	b085      	sub	sp, #20
 8002684:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 8002686:	9b01      	ldr	r3, [sp, #4]
 8002688:	68db      	ldr	r3, [r3, #12]
 800268a:	691b      	ldr	r3, [r3, #16]
 800268c:	9303      	str	r3, [sp, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800268e:	9b01      	ldr	r3, [sp, #4]
 8002690:	68db      	ldr	r3, [r3, #12]
 8002692:	68db      	ldr	r3, [r3, #12]
 8002694:	b2db      	uxtb	r3, r3
 8002696:	9a03      	ldr	r2, [sp, #12]
 8002698:	4013      	ands	r3, r2
 800269a:	9303      	str	r3, [sp, #12]
  gptp->tim->SR = ~sr;
 800269c:	9b01      	ldr	r3, [sp, #4]
 800269e:	68db      	ldr	r3, [r3, #12]
 80026a0:	9a03      	ldr	r2, [sp, #12]
 80026a2:	43d2      	mvns	r2, r2
 80026a4:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 80026a6:	9b03      	ldr	r3, [sp, #12]
 80026a8:	f003 0301 	and.w	r3, r3, #1
 80026ac:	2b00      	cmp	r3, #0
 80026ae:	d013      	beq.n	80026d8 <gpt_lld_serve_interrupt+0x58>
    _gpt_isr_invoke_cb(gptp);
 80026b0:	9b01      	ldr	r3, [sp, #4]
 80026b2:	781b      	ldrb	r3, [r3, #0]
 80026b4:	2b04      	cmp	r3, #4
 80026b6:	d105      	bne.n	80026c4 <gpt_lld_serve_interrupt+0x44>
 80026b8:	9b01      	ldr	r3, [sp, #4]
 80026ba:	2202      	movs	r2, #2
 80026bc:	701a      	strb	r2, [r3, #0]
 80026be:	9801      	ldr	r0, [sp, #4]
 80026c0:	f7ff ffc6 	bl	8002650 <gpt_lld_stop_timer>
 80026c4:	9b01      	ldr	r3, [sp, #4]
 80026c6:	685b      	ldr	r3, [r3, #4]
 80026c8:	685b      	ldr	r3, [r3, #4]
 80026ca:	2b00      	cmp	r3, #0
 80026cc:	d004      	beq.n	80026d8 <gpt_lld_serve_interrupt+0x58>
 80026ce:	9b01      	ldr	r3, [sp, #4]
 80026d0:	685b      	ldr	r3, [r3, #4]
 80026d2:	685b      	ldr	r3, [r3, #4]
 80026d4:	9801      	ldr	r0, [sp, #4]
 80026d6:	4798      	blx	r3
  }
}
 80026d8:	bf00      	nop
 80026da:	b005      	add	sp, #20
 80026dc:	f85d fb04 	ldr.w	pc, [sp], #4

080026e0 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 80026e0:	b082      	sub	sp, #8
 80026e2:	9001      	str	r0, [sp, #4]
 80026e4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 80026e6:	9b00      	ldr	r3, [sp, #0]
 80026e8:	685a      	ldr	r2, [r3, #4]
 80026ea:	9b01      	ldr	r3, [sp, #4]
 80026ec:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80026ee:	9b00      	ldr	r3, [sp, #0]
 80026f0:	689a      	ldr	r2, [r3, #8]
 80026f2:	9b01      	ldr	r3, [sp, #4]
 80026f4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80026f6:	9b00      	ldr	r3, [sp, #0]
 80026f8:	68da      	ldr	r2, [r3, #12]
 80026fa:	9b01      	ldr	r3, [sp, #4]
 80026fc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80026fe:	9b00      	ldr	r3, [sp, #0]
 8002700:	691a      	ldr	r2, [r3, #16]
 8002702:	9b01      	ldr	r3, [sp, #4]
 8002704:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8002706:	9b00      	ldr	r3, [sp, #0]
 8002708:	695a      	ldr	r2, [r3, #20]
 800270a:	9b01      	ldr	r3, [sp, #4]
 800270c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800270e:	9b00      	ldr	r3, [sp, #0]
 8002710:	699a      	ldr	r2, [r3, #24]
 8002712:	9b01      	ldr	r3, [sp, #4]
 8002714:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8002716:	9b00      	ldr	r3, [sp, #0]
 8002718:	681a      	ldr	r2, [r3, #0]
 800271a:	9b01      	ldr	r3, [sp, #4]
 800271c:	601a      	str	r2, [r3, #0]
}
 800271e:	bf00      	nop
 8002720:	b002      	add	sp, #8
 8002722:	4770      	bx	lr
	...

08002730 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8002730:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB2(STM32_GPIO_EN_MASK);
 8002732:	4b1d      	ldr	r3, [pc, #116]	@ (80027a8 <stm32_gpio_init+0x78>)
 8002734:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002736:	4a1c      	ldr	r2, [pc, #112]	@ (80027a8 <stm32_gpio_init+0x78>)
 8002738:	f043 037f 	orr.w	r3, r3, #127	@ 0x7f
 800273c:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800273e:	4b1a      	ldr	r3, [pc, #104]	@ (80027a8 <stm32_gpio_init+0x78>)
 8002740:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002742:	4a19      	ldr	r2, [pc, #100]	@ (80027a8 <stm32_gpio_init+0x78>)
 8002744:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8002748:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800274a:	4b17      	ldr	r3, [pc, #92]	@ (80027a8 <stm32_gpio_init+0x78>)
 800274c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 800274e:	4b16      	ldr	r3, [pc, #88]	@ (80027a8 <stm32_gpio_init+0x78>)
 8002750:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002752:	4a15      	ldr	r2, [pc, #84]	@ (80027a8 <stm32_gpio_init+0x78>)
 8002754:	f043 037f 	orr.w	r3, r3, #127	@ 0x7f
 8002758:	64d3      	str	r3, [r2, #76]	@ 0x4c
 800275a:	4b13      	ldr	r3, [pc, #76]	@ (80027a8 <stm32_gpio_init+0x78>)
 800275c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800275e:	4a12      	ldr	r2, [pc, #72]	@ (80027a8 <stm32_gpio_init+0x78>)
 8002760:	f043 037f 	orr.w	r3, r3, #127	@ 0x7f
 8002764:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8002766:	4b10      	ldr	r3, [pc, #64]	@ (80027a8 <stm32_gpio_init+0x78>)
 8002768:	6edb      	ldr	r3, [r3, #108]	@ 0x6c

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 800276a:	4910      	ldr	r1, [pc, #64]	@ (80027ac <stm32_gpio_init+0x7c>)
 800276c:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8002770:	f7ff ffb6 	bl	80026e0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8002774:	490e      	ldr	r1, [pc, #56]	@ (80027b0 <stm32_gpio_init+0x80>)
 8002776:	480f      	ldr	r0, [pc, #60]	@ (80027b4 <stm32_gpio_init+0x84>)
 8002778:	f7ff ffb2 	bl	80026e0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 800277c:	490e      	ldr	r1, [pc, #56]	@ (80027b8 <stm32_gpio_init+0x88>)
 800277e:	480f      	ldr	r0, [pc, #60]	@ (80027bc <stm32_gpio_init+0x8c>)
 8002780:	f7ff ffae 	bl	80026e0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8002784:	490e      	ldr	r1, [pc, #56]	@ (80027c0 <stm32_gpio_init+0x90>)
 8002786:	480f      	ldr	r0, [pc, #60]	@ (80027c4 <stm32_gpio_init+0x94>)
 8002788:	f7ff ffaa 	bl	80026e0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 800278c:	490e      	ldr	r1, [pc, #56]	@ (80027c8 <stm32_gpio_init+0x98>)
 800278e:	480f      	ldr	r0, [pc, #60]	@ (80027cc <stm32_gpio_init+0x9c>)
 8002790:	f7ff ffa6 	bl	80026e0 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 8002794:	490e      	ldr	r1, [pc, #56]	@ (80027d0 <stm32_gpio_init+0xa0>)
 8002796:	480f      	ldr	r0, [pc, #60]	@ (80027d4 <stm32_gpio_init+0xa4>)
 8002798:	f7ff ffa2 	bl	80026e0 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 800279c:	490e      	ldr	r1, [pc, #56]	@ (80027d8 <stm32_gpio_init+0xa8>)
 800279e:	480f      	ldr	r0, [pc, #60]	@ (80027dc <stm32_gpio_init+0xac>)
 80027a0:	f7ff ff9e 	bl	80026e0 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 80027a4:	bf00      	nop
 80027a6:	bd08      	pop	{r3, pc}
 80027a8:	40021000 	.word	0x40021000
 80027ac:	080054e0 	.word	0x080054e0
 80027b0:	080054fc 	.word	0x080054fc
 80027b4:	48000400 	.word	0x48000400
 80027b8:	08005518 	.word	0x08005518
 80027bc:	48000800 	.word	0x48000800
 80027c0:	08005534 	.word	0x08005534
 80027c4:	48000c00 	.word	0x48000c00
 80027c8:	08005550 	.word	0x08005550
 80027cc:	48001000 	.word	0x48001000
 80027d0:	0800556c 	.word	0x0800556c
 80027d4:	48001400 	.word	0x48001400
 80027d8:	08005588 	.word	0x08005588
 80027dc:	48001800 	.word	0x48001800

080027e0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80027e0:	b508      	push	{r3, lr}

  stm32_gpio_init();
 80027e2:	f7ff ffa5 	bl	8002730 <stm32_gpio_init>
  stm32_clock_init();
 80027e6:	f7fe fd03 	bl	80011f0 <stm32_clock_init>
}
 80027ea:	bf00      	nop
 80027ec:	bd08      	pop	{r3, pc}
 80027ee:	bf00      	nop

080027f0 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 80027f0:	bf00      	nop
 80027f2:	4770      	bx	lr
	...

08002800 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 8002800:	b500      	push	{lr}
 8002802:	b08b      	sub	sp, #44	@ 0x2c
 8002804:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8002806:	9b01      	ldr	r3, [sp, #4]
 8002808:	2200      	movs	r2, #0
 800280a:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 800280c:	ab02      	add	r3, sp, #8
 800280e:	4618      	mov	r0, r3
 8002810:	f001 fd8e 	bl	8004330 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 8002814:	2304      	movs	r3, #4
 8002816:	9309      	str	r3, [sp, #36]	@ 0x24
  do {
    chTMStartMeasurementX(&tm);
 8002818:	ab02      	add	r3, sp, #8
 800281a:	4618      	mov	r0, r3
 800281c:	f001 fda8 	bl	8004370 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8002820:	ab02      	add	r3, sp, #8
 8002822:	4618      	mov	r0, r3
 8002824:	f001 fdb4 	bl	8004390 <chTMStopMeasurementX>
    i--;
 8002828:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800282a:	3b01      	subs	r3, #1
 800282c:	9309      	str	r3, [sp, #36]	@ 0x24
  } while (i > 0U);
 800282e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002830:	2b00      	cmp	r3, #0
 8002832:	d1f1      	bne.n	8002818 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
 8002834:	9a02      	ldr	r2, [sp, #8]
 8002836:	9b01      	ldr	r3, [sp, #4]
 8002838:	601a      	str	r2, [r3, #0]
}
 800283a:	bf00      	nop
 800283c:	b00b      	add	sp, #44	@ 0x2c
 800283e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002842:	bf00      	nop
	...

08002850 <chSysUnlock.lto_priv.5>:
static inline void chSysUnlock(void) {
 8002850:	b500      	push	{lr}
 8002852:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8002854:	f000 f91c 	bl	8002a90 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8002858:	4b12      	ldr	r3, [pc, #72]	@ (80028a4 <chSysUnlock.lto_priv.5+0x54>)
 800285a:	681b      	ldr	r3, [r3, #0]
 800285c:	4a11      	ldr	r2, [pc, #68]	@ (80028a4 <chSysUnlock.lto_priv.5+0x54>)
 800285e:	4293      	cmp	r3, r2
 8002860:	bf14      	ite	ne
 8002862:	2301      	movne	r3, #1
 8002864:	2300      	moveq	r3, #0
 8002866:	b2db      	uxtb	r3, r3
 8002868:	2b00      	cmp	r3, #0
 800286a:	d00f      	beq.n	800288c <chSysUnlock.lto_priv.5+0x3c>
 800286c:	4b0d      	ldr	r3, [pc, #52]	@ (80028a4 <chSysUnlock.lto_priv.5+0x54>)
 800286e:	68db      	ldr	r3, [r3, #12]
 8002870:	689a      	ldr	r2, [r3, #8]
 8002872:	4b0c      	ldr	r3, [pc, #48]	@ (80028a4 <chSysUnlock.lto_priv.5+0x54>)
 8002874:	681b      	ldr	r3, [r3, #0]
 8002876:	689b      	ldr	r3, [r3, #8]
 8002878:	429a      	cmp	r2, r3
 800287a:	bf34      	ite	cc
 800287c:	2301      	movcc	r3, #1
 800287e:	2300      	movcs	r3, #0
 8002880:	b2db      	uxtb	r3, r3
 8002882:	2b00      	cmp	r3, #0
 8002884:	d002      	beq.n	800288c <chSysUnlock.lto_priv.5+0x3c>
 8002886:	4808      	ldr	r0, [pc, #32]	@ (80028a8 <chSysUnlock.lto_priv.5+0x58>)
 8002888:	f000 f852 	bl	8002930 <chSysHalt>
 800288c:	2300      	movs	r3, #0
 800288e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002890:	9b01      	ldr	r3, [sp, #4]
 8002892:	f383 8811 	msr	BASEPRI, r3
}
 8002896:	bf00      	nop
}
 8002898:	bf00      	nop
}
 800289a:	bf00      	nop
 800289c:	b003      	add	sp, #12
 800289e:	f85d fb04 	ldr.w	pc, [sp], #4
 80028a2:	bf00      	nop
 80028a4:	20000988 	.word	0x20000988
 80028a8:	08005620 	.word	0x08005620
 80028ac:	00000000 	.word	0x00000000

080028b0 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 80028b0:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 80028b2:	f002 f89d 	bl	80049f0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 80028b6:	f002 f90b 	bl	8004ad0 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 80028ba:	f002 fad1 	bl	8004e60 <__factory_init>
#endif
}
 80028be:	bf00      	nop
 80028c0:	bd08      	pop	{r3, pc}
 80028c2:	bf00      	nop
	...

080028d0 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 80028d0:	b500      	push	{lr}
 80028d2:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 80028d4:	4b11      	ldr	r3, [pc, #68]	@ (800291c <chSysInit+0x4c>)
 80028d6:	2201      	movs	r2, #1
 80028d8:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80028da:	2300      	movs	r3, #0
 80028dc:	9301      	str	r3, [sp, #4]
 80028de:	e008      	b.n	80028f2 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
 80028e0:	4a0e      	ldr	r2, [pc, #56]	@ (800291c <chSysInit+0x4c>)
 80028e2:	9b01      	ldr	r3, [sp, #4]
 80028e4:	009b      	lsls	r3, r3, #2
 80028e6:	4413      	add	r3, r2
 80028e8:	2200      	movs	r2, #0
 80028ea:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80028ec:	9b01      	ldr	r3, [sp, #4]
 80028ee:	3301      	adds	r3, #1
 80028f0:	9301      	str	r3, [sp, #4]
 80028f2:	9b01      	ldr	r3, [sp, #4]
 80028f4:	2b00      	cmp	r3, #0
 80028f6:	d0f3      	beq.n	80028e0 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 80028f8:	4809      	ldr	r0, [pc, #36]	@ (8002920 <chSysInit+0x50>)
 80028fa:	f7ff ff81 	bl	8002800 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 80028fe:	f7ff ffd7 	bl	80028b0 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 8002902:	4908      	ldr	r1, [pc, #32]	@ (8002924 <chSysInit+0x54>)
 8002904:	4808      	ldr	r0, [pc, #32]	@ (8002928 <chSysInit+0x58>)
 8002906:	f001 f8eb 	bl	8003ae0 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 800290a:	4b04      	ldr	r3, [pc, #16]	@ (800291c <chSysInit+0x4c>)
 800290c:	2202      	movs	r2, #2
 800290e:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 8002910:	f7ff ff9e 	bl	8002850 <chSysUnlock.lto_priv.5>
}
 8002914:	bf00      	nop
 8002916:	b003      	add	sp, #12
 8002918:	f85d fb04 	ldr.w	pc, [sp], #4
 800291c:	2000097c 	.word	0x2000097c
 8002920:	20000984 	.word	0x20000984
 8002924:	0800560c 	.word	0x0800560c
 8002928:	20000988 	.word	0x20000988
 800292c:	00000000 	.word	0x00000000

08002930 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002930:	b082      	sub	sp, #8
 8002932:	9001      	str	r0, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8002934:	b672      	cpsid	i
}
 8002936:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 8002938:	bf00      	nop

  /* Logging the event.*/
  __trace_halt(reason);

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 800293a:	4a04      	ldr	r2, [pc, #16]	@ (800294c <chSysHalt+0x1c>)
 800293c:	9b01      	ldr	r3, [sp, #4]
 800293e:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8002942:	4b03      	ldr	r3, [pc, #12]	@ (8002950 <chSysHalt+0x20>)
 8002944:	2203      	movs	r2, #3
 8002946:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
     asm volatile ("nop");
 8002948:	bf00      	nop
 800294a:	e7fd      	b.n	8002948 <chSysHalt+0x18>
 800294c:	20000988 	.word	0x20000988
 8002950:	2000097c 	.word	0x2000097c
	...

08002960 <chSysGetIdleThreadX>:
 *
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
 8002960:	b500      	push	{lr}
 8002962:	b083      	sub	sp, #12
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8002964:	4b09      	ldr	r3, [pc, #36]	@ (800298c <chSysGetIdleThreadX+0x2c>)
 8002966:	685b      	ldr	r3, [r3, #4]
 8002968:	9301      	str	r3, [sp, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 800296a:	9b01      	ldr	r3, [sp, #4]
 800296c:	689b      	ldr	r3, [r3, #8]
 800296e:	2b01      	cmp	r3, #1
 8002970:	bf14      	ite	ne
 8002972:	2301      	movne	r3, #1
 8002974:	2300      	moveq	r3, #0
 8002976:	b2db      	uxtb	r3, r3
 8002978:	2b00      	cmp	r3, #0
 800297a:	d002      	beq.n	8002982 <chSysGetIdleThreadX+0x22>
 800297c:	4804      	ldr	r0, [pc, #16]	@ (8002990 <chSysGetIdleThreadX+0x30>)
 800297e:	f7ff ffd7 	bl	8002930 <chSysHalt>

  return tp;
 8002982:	9b01      	ldr	r3, [sp, #4]
}
 8002984:	4618      	mov	r0, r3
 8002986:	b003      	add	sp, #12
 8002988:	f85d fb04 	ldr.w	pc, [sp], #4
 800298c:	20000988 	.word	0x20000988
 8002990:	0800562c 	.word	0x0800562c
	...

080029a0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80029a0:	b508      	push	{r3, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 80029a2:	f000 f965 	bl	8002c70 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 80029a6:	f000 fc83 	bl	80032b0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 80029aa:	bf00      	nop
 80029ac:	bd08      	pop	{r3, pc}
 80029ae:	bf00      	nop

080029b0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 80029b0:	b084      	sub	sp, #16
 80029b2:	9003      	str	r0, [sp, #12]
 80029b4:	9102      	str	r1, [sp, #8]
 80029b6:	9201      	str	r2, [sp, #4]

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 80029b8:	9a03      	ldr	r2, [sp, #12]
 80029ba:	9b02      	ldr	r3, [sp, #8]
 80029bc:	1ad2      	subs	r2, r2, r3
                ((rtcnt_t)end - (rtcnt_t)start));
 80029be:	9901      	ldr	r1, [sp, #4]
 80029c0:	9b02      	ldr	r3, [sp, #8]
 80029c2:	1acb      	subs	r3, r1, r3
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 80029c4:	429a      	cmp	r2, r3
 80029c6:	bf34      	ite	cc
 80029c8:	2301      	movcc	r3, #1
 80029ca:	2300      	movcs	r3, #0
 80029cc:	b2db      	uxtb	r3, r3
}
 80029ce:	4618      	mov	r0, r3
 80029d0:	b004      	add	sp, #16
 80029d2:	4770      	bx	lr
	...

080029e0 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 80029e0:	b500      	push	{lr}
 80029e2:	b085      	sub	sp, #20
 80029e4:	9001      	str	r0, [sp, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80029e6:	4b0b      	ldr	r3, [pc, #44]	@ (8002a14 <chSysPolledDelayX+0x34>)
 80029e8:	685b      	ldr	r3, [r3, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 80029ea:	9303      	str	r3, [sp, #12]
  rtcnt_t end  = start + cycles;
 80029ec:	9a03      	ldr	r2, [sp, #12]
 80029ee:	9b01      	ldr	r3, [sp, #4]
 80029f0:	4413      	add	r3, r2
 80029f2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80029f4:	bf00      	nop
 80029f6:	4b07      	ldr	r3, [pc, #28]	@ (8002a14 <chSysPolledDelayX+0x34>)
 80029f8:	685b      	ldr	r3, [r3, #4]
 80029fa:	9a02      	ldr	r2, [sp, #8]
 80029fc:	9903      	ldr	r1, [sp, #12]
 80029fe:	4618      	mov	r0, r3
 8002a00:	f7ff ffd6 	bl	80029b0 <chSysIsCounterWithinX>
 8002a04:	4603      	mov	r3, r0
 8002a06:	2b00      	cmp	r3, #0
 8002a08:	d1f5      	bne.n	80029f6 <chSysPolledDelayX+0x16>
  }
}
 8002a0a:	bf00      	nop
 8002a0c:	bf00      	nop
 8002a0e:	b005      	add	sp, #20
 8002a10:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a14:	e0001000 	.word	0xe0001000
	...

08002a20 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 8002a20:	b082      	sub	sp, #8
 8002a22:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8002a24:	4b04      	ldr	r3, [pc, #16]	@ (8002a38 <chRFCUCollectFaultsI+0x18>)
 8002a26:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8002a28:	9b01      	ldr	r3, [sp, #4]
 8002a2a:	4313      	orrs	r3, r2
 8002a2c:	4a02      	ldr	r2, [pc, #8]	@ (8002a38 <chRFCUCollectFaultsI+0x18>)
 8002a2e:	6353      	str	r3, [r2, #52]	@ 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8002a30:	bf00      	nop
 8002a32:	b002      	add	sp, #8
 8002a34:	4770      	bx	lr
 8002a36:	bf00      	nop
 8002a38:	20000988 	.word	0x20000988
 8002a3c:	00000000 	.word	0x00000000

08002a40 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 8002a40:	b500      	push	{lr}
 8002a42:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002a44:	4b10      	ldr	r3, [pc, #64]	@ (8002a88 <__dbg_check_lock+0x48>)
 8002a46:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002a48:	9b01      	ldr	r3, [sp, #4]
 8002a4a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a4e:	2b00      	cmp	r3, #0
 8002a50:	bf14      	ite	ne
 8002a52:	2301      	movne	r3, #1
 8002a54:	2300      	moveq	r3, #0
 8002a56:	b2db      	uxtb	r3, r3
 8002a58:	2b00      	cmp	r3, #0
 8002a5a:	d109      	bne.n	8002a70 <__dbg_check_lock+0x30>
 8002a5c:	9b01      	ldr	r3, [sp, #4]
 8002a5e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002a62:	2b00      	cmp	r3, #0
 8002a64:	bf14      	ite	ne
 8002a66:	2301      	movne	r3, #1
 8002a68:	2300      	moveq	r3, #0
 8002a6a:	b2db      	uxtb	r3, r3
 8002a6c:	2b00      	cmp	r3, #0
 8002a6e:	d002      	beq.n	8002a76 <__dbg_check_lock+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 8002a70:	4806      	ldr	r0, [pc, #24]	@ (8002a8c <__dbg_check_lock+0x4c>)
 8002a72:	f7ff ff5d 	bl	8002930 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002a76:	9b01      	ldr	r3, [sp, #4]
 8002a78:	2201      	movs	r2, #1
 8002a7a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 8002a7e:	bf00      	nop
 8002a80:	b003      	add	sp, #12
 8002a82:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a86:	bf00      	nop
 8002a88:	20000988 	.word	0x20000988
 8002a8c:	080055a8 	.word	0x080055a8

08002a90 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 8002a90:	b500      	push	{lr}
 8002a92:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002a94:	4b10      	ldr	r3, [pc, #64]	@ (8002ad8 <__dbg_check_unlock+0x48>)
 8002a96:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002a98:	9b01      	ldr	r3, [sp, #4]
 8002a9a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a9e:	2b00      	cmp	r3, #0
 8002aa0:	bf14      	ite	ne
 8002aa2:	2301      	movne	r3, #1
 8002aa4:	2300      	moveq	r3, #0
 8002aa6:	b2db      	uxtb	r3, r3
 8002aa8:	2b00      	cmp	r3, #0
 8002aaa:	d109      	bne.n	8002ac0 <__dbg_check_unlock+0x30>
 8002aac:	9b01      	ldr	r3, [sp, #4]
 8002aae:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002ab2:	2b00      	cmp	r3, #0
 8002ab4:	bfd4      	ite	le
 8002ab6:	2301      	movle	r3, #1
 8002ab8:	2300      	movgt	r3, #0
 8002aba:	b2db      	uxtb	r3, r3
 8002abc:	2b00      	cmp	r3, #0
 8002abe:	d002      	beq.n	8002ac6 <__dbg_check_unlock+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 8002ac0:	4806      	ldr	r0, [pc, #24]	@ (8002adc <__dbg_check_unlock+0x4c>)
 8002ac2:	f7ff ff35 	bl	8002930 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002ac6:	9b01      	ldr	r3, [sp, #4]
 8002ac8:	2200      	movs	r2, #0
 8002aca:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 8002ace:	bf00      	nop
 8002ad0:	b003      	add	sp, #12
 8002ad2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ad6:	bf00      	nop
 8002ad8:	20000988 	.word	0x20000988
 8002adc:	080055b0 	.word	0x080055b0

08002ae0 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 8002ae0:	b500      	push	{lr}
 8002ae2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002ae4:	4b10      	ldr	r3, [pc, #64]	@ (8002b28 <__dbg_check_lock_from_isr+0x48>)
 8002ae6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002ae8:	9b01      	ldr	r3, [sp, #4]
 8002aea:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002aee:	2b00      	cmp	r3, #0
 8002af0:	bfd4      	ite	le
 8002af2:	2301      	movle	r3, #1
 8002af4:	2300      	movgt	r3, #0
 8002af6:	b2db      	uxtb	r3, r3
 8002af8:	2b00      	cmp	r3, #0
 8002afa:	d109      	bne.n	8002b10 <__dbg_check_lock_from_isr+0x30>
 8002afc:	9b01      	ldr	r3, [sp, #4]
 8002afe:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002b02:	2b00      	cmp	r3, #0
 8002b04:	bf14      	ite	ne
 8002b06:	2301      	movne	r3, #1
 8002b08:	2300      	moveq	r3, #0
 8002b0a:	b2db      	uxtb	r3, r3
 8002b0c:	2b00      	cmp	r3, #0
 8002b0e:	d002      	beq.n	8002b16 <__dbg_check_lock_from_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 8002b10:	4806      	ldr	r0, [pc, #24]	@ (8002b2c <__dbg_check_lock_from_isr+0x4c>)
 8002b12:	f7ff ff0d 	bl	8002930 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002b16:	9b01      	ldr	r3, [sp, #4]
 8002b18:	2201      	movs	r2, #1
 8002b1a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 8002b1e:	bf00      	nop
 8002b20:	b003      	add	sp, #12
 8002b22:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b26:	bf00      	nop
 8002b28:	20000988 	.word	0x20000988
 8002b2c:	080055b8 	.word	0x080055b8

08002b30 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 8002b30:	b500      	push	{lr}
 8002b32:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002b34:	4b10      	ldr	r3, [pc, #64]	@ (8002b78 <__dbg_check_unlock_from_isr+0x48>)
 8002b36:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002b38:	9b01      	ldr	r3, [sp, #4]
 8002b3a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002b3e:	2b00      	cmp	r3, #0
 8002b40:	bfd4      	ite	le
 8002b42:	2301      	movle	r3, #1
 8002b44:	2300      	movgt	r3, #0
 8002b46:	b2db      	uxtb	r3, r3
 8002b48:	2b00      	cmp	r3, #0
 8002b4a:	d109      	bne.n	8002b60 <__dbg_check_unlock_from_isr+0x30>
 8002b4c:	9b01      	ldr	r3, [sp, #4]
 8002b4e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002b52:	2b00      	cmp	r3, #0
 8002b54:	bfd4      	ite	le
 8002b56:	2301      	movle	r3, #1
 8002b58:	2300      	movgt	r3, #0
 8002b5a:	b2db      	uxtb	r3, r3
 8002b5c:	2b00      	cmp	r3, #0
 8002b5e:	d002      	beq.n	8002b66 <__dbg_check_unlock_from_isr+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 8002b60:	4806      	ldr	r0, [pc, #24]	@ (8002b7c <__dbg_check_unlock_from_isr+0x4c>)
 8002b62:	f7ff fee5 	bl	8002930 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002b66:	9b01      	ldr	r3, [sp, #4]
 8002b68:	2200      	movs	r2, #0
 8002b6a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 8002b6e:	bf00      	nop
 8002b70:	b003      	add	sp, #12
 8002b72:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b76:	bf00      	nop
 8002b78:	20000988 	.word	0x20000988
 8002b7c:	080055c0 	.word	0x080055c0

08002b80 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 8002b80:	b500      	push	{lr}
 8002b82:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8002b84:	4b18      	ldr	r3, [pc, #96]	@ (8002be8 <__dbg_check_enter_isr+0x68>)
 8002b86:	9303      	str	r3, [sp, #12]
 8002b88:	2330      	movs	r3, #48	@ 0x30
 8002b8a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002b8c:	9b02      	ldr	r3, [sp, #8]
 8002b8e:	f383 8811 	msr	BASEPRI, r3
}
 8002b92:	bf00      	nop
}
 8002b94:	bf00      	nop
}
 8002b96:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002b98:	9b03      	ldr	r3, [sp, #12]
 8002b9a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002b9e:	0fdb      	lsrs	r3, r3, #31
 8002ba0:	b2db      	uxtb	r3, r3
 8002ba2:	2b00      	cmp	r3, #0
 8002ba4:	d109      	bne.n	8002bba <__dbg_check_enter_isr+0x3a>
 8002ba6:	9b03      	ldr	r3, [sp, #12]
 8002ba8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002bac:	2b00      	cmp	r3, #0
 8002bae:	bf14      	ite	ne
 8002bb0:	2301      	movne	r3, #1
 8002bb2:	2300      	moveq	r3, #0
 8002bb4:	b2db      	uxtb	r3, r3
 8002bb6:	2b00      	cmp	r3, #0
 8002bb8:	d002      	beq.n	8002bc0 <__dbg_check_enter_isr+0x40>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 8002bba:	480c      	ldr	r0, [pc, #48]	@ (8002bec <__dbg_check_enter_isr+0x6c>)
 8002bbc:	f7ff feb8 	bl	8002930 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 8002bc0:	9b03      	ldr	r3, [sp, #12]
 8002bc2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002bc6:	1c5a      	adds	r2, r3, #1
 8002bc8:	9b03      	ldr	r3, [sp, #12]
 8002bca:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8002bce:	2300      	movs	r3, #0
 8002bd0:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002bd2:	9b01      	ldr	r3, [sp, #4]
 8002bd4:	f383 8811 	msr	BASEPRI, r3
}
 8002bd8:	bf00      	nop
}
 8002bda:	bf00      	nop
}
 8002bdc:	bf00      	nop
  port_unlock_from_isr();
}
 8002bde:	bf00      	nop
 8002be0:	b005      	add	sp, #20
 8002be2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002be6:	bf00      	nop
 8002be8:	20000988 	.word	0x20000988
 8002bec:	080055c8 	.word	0x080055c8

08002bf0 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 8002bf0:	b500      	push	{lr}
 8002bf2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8002bf4:	4b19      	ldr	r3, [pc, #100]	@ (8002c5c <__dbg_check_leave_isr+0x6c>)
 8002bf6:	9303      	str	r3, [sp, #12]
 8002bf8:	2330      	movs	r3, #48	@ 0x30
 8002bfa:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002bfc:	9b02      	ldr	r3, [sp, #8]
 8002bfe:	f383 8811 	msr	BASEPRI, r3
}
 8002c02:	bf00      	nop
}
 8002c04:	bf00      	nop
}
 8002c06:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002c08:	9b03      	ldr	r3, [sp, #12]
 8002c0a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002c0e:	2b00      	cmp	r3, #0
 8002c10:	bfd4      	ite	le
 8002c12:	2301      	movle	r3, #1
 8002c14:	2300      	movgt	r3, #0
 8002c16:	b2db      	uxtb	r3, r3
 8002c18:	2b00      	cmp	r3, #0
 8002c1a:	d109      	bne.n	8002c30 <__dbg_check_leave_isr+0x40>
 8002c1c:	9b03      	ldr	r3, [sp, #12]
 8002c1e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002c22:	2b00      	cmp	r3, #0
 8002c24:	bf14      	ite	ne
 8002c26:	2301      	movne	r3, #1
 8002c28:	2300      	moveq	r3, #0
 8002c2a:	b2db      	uxtb	r3, r3
 8002c2c:	2b00      	cmp	r3, #0
 8002c2e:	d002      	beq.n	8002c36 <__dbg_check_leave_isr+0x46>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 8002c30:	480b      	ldr	r0, [pc, #44]	@ (8002c60 <__dbg_check_leave_isr+0x70>)
 8002c32:	f7ff fe7d 	bl	8002930 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 8002c36:	9b03      	ldr	r3, [sp, #12]
 8002c38:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002c3c:	1e5a      	subs	r2, r3, #1
 8002c3e:	9b03      	ldr	r3, [sp, #12]
 8002c40:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8002c44:	2300      	movs	r3, #0
 8002c46:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002c48:	9b01      	ldr	r3, [sp, #4]
 8002c4a:	f383 8811 	msr	BASEPRI, r3
}
 8002c4e:	bf00      	nop
}
 8002c50:	bf00      	nop
}
 8002c52:	bf00      	nop
  port_unlock_from_isr();
}
 8002c54:	bf00      	nop
 8002c56:	b005      	add	sp, #20
 8002c58:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c5c:	20000988 	.word	0x20000988
 8002c60:	080055d0 	.word	0x080055d0
	...

08002c70 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002c70:	b500      	push	{lr}
 8002c72:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002c74:	4b0c      	ldr	r3, [pc, #48]	@ (8002ca8 <chDbgCheckClassI+0x38>)
 8002c76:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002c78:	9b01      	ldr	r3, [sp, #4]
 8002c7a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002c7e:	0fdb      	lsrs	r3, r3, #31
 8002c80:	b2db      	uxtb	r3, r3
 8002c82:	2b00      	cmp	r3, #0
 8002c84:	d109      	bne.n	8002c9a <chDbgCheckClassI+0x2a>
 8002c86:	9b01      	ldr	r3, [sp, #4]
 8002c88:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002c8c:	2b00      	cmp	r3, #0
 8002c8e:	bfd4      	ite	le
 8002c90:	2301      	movle	r3, #1
 8002c92:	2300      	movgt	r3, #0
 8002c94:	b2db      	uxtb	r3, r3
 8002c96:	2b00      	cmp	r3, #0
 8002c98:	d002      	beq.n	8002ca0 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 8002c9a:	4804      	ldr	r0, [pc, #16]	@ (8002cac <chDbgCheckClassI+0x3c>)
 8002c9c:	f7ff fe48 	bl	8002930 <chSysHalt>
  }
}
 8002ca0:	bf00      	nop
 8002ca2:	b003      	add	sp, #12
 8002ca4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ca8:	20000988 	.word	0x20000988
 8002cac:	080055d8 	.word	0x080055d8

08002cb0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002cb0:	b500      	push	{lr}
 8002cb2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002cb4:	4b0e      	ldr	r3, [pc, #56]	@ (8002cf0 <chDbgCheckClassS+0x40>)
 8002cb6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002cb8:	9b01      	ldr	r3, [sp, #4]
 8002cba:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002cbe:	2b00      	cmp	r3, #0
 8002cc0:	bf14      	ite	ne
 8002cc2:	2301      	movne	r3, #1
 8002cc4:	2300      	moveq	r3, #0
 8002cc6:	b2db      	uxtb	r3, r3
 8002cc8:	2b00      	cmp	r3, #0
 8002cca:	d109      	bne.n	8002ce0 <chDbgCheckClassS+0x30>
 8002ccc:	9b01      	ldr	r3, [sp, #4]
 8002cce:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002cd2:	2b00      	cmp	r3, #0
 8002cd4:	bfd4      	ite	le
 8002cd6:	2301      	movle	r3, #1
 8002cd8:	2300      	movgt	r3, #0
 8002cda:	b2db      	uxtb	r3, r3
 8002cdc:	2b00      	cmp	r3, #0
 8002cde:	d002      	beq.n	8002ce6 <chDbgCheckClassS+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 8002ce0:	4804      	ldr	r0, [pc, #16]	@ (8002cf4 <chDbgCheckClassS+0x44>)
 8002ce2:	f7ff fe25 	bl	8002930 <chSysHalt>
  }
}
 8002ce6:	bf00      	nop
 8002ce8:	b003      	add	sp, #12
 8002cea:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cee:	bf00      	nop
 8002cf0:	20000988 	.word	0x20000988
 8002cf4:	080055e0 	.word	0x080055e0
	...

08002d00 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8002d00:	b082      	sub	sp, #8
 8002d02:	9001      	str	r0, [sp, #4]
 8002d04:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002d06:	9a01      	ldr	r2, [sp, #4]
 8002d08:	9b00      	ldr	r3, [sp, #0]
 8002d0a:	4413      	add	r3, r2
}
 8002d0c:	4618      	mov	r0, r3
 8002d0e:	b002      	add	sp, #8
 8002d10:	4770      	bx	lr
 8002d12:	bf00      	nop
	...

08002d20 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8002d20:	b082      	sub	sp, #8
 8002d22:	9001      	str	r0, [sp, #4]
 8002d24:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002d26:	9a00      	ldr	r2, [sp, #0]
 8002d28:	9b01      	ldr	r3, [sp, #4]
 8002d2a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8002d2c:	4618      	mov	r0, r3
 8002d2e:	b002      	add	sp, #8
 8002d30:	4770      	bx	lr
 8002d32:	bf00      	nop
	...

08002d40 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8002d40:	b082      	sub	sp, #8
 8002d42:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8002d44:	9b01      	ldr	r3, [sp, #4]
 8002d46:	681b      	ldr	r3, [r3, #0]
 8002d48:	9a01      	ldr	r2, [sp, #4]
 8002d4a:	429a      	cmp	r2, r3
 8002d4c:	bf0c      	ite	eq
 8002d4e:	2301      	moveq	r3, #1
 8002d50:	2300      	movne	r3, #0
 8002d52:	b2db      	uxtb	r3, r3
}
 8002d54:	4618      	mov	r0, r3
 8002d56:	b002      	add	sp, #8
 8002d58:	4770      	bx	lr
 8002d5a:	bf00      	nop
 8002d5c:	0000      	movs	r0, r0
	...

08002d60 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8002d60:	b082      	sub	sp, #8
 8002d62:	9001      	str	r0, [sp, #4]
 8002d64:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8002d66:	9b01      	ldr	r3, [sp, #4]
 8002d68:	681b      	ldr	r3, [r3, #0]
 8002d6a:	9a00      	ldr	r2, [sp, #0]
 8002d6c:	429a      	cmp	r2, r3
 8002d6e:	bf0c      	ite	eq
 8002d70:	2301      	moveq	r3, #1
 8002d72:	2300      	movne	r3, #0
 8002d74:	b2db      	uxtb	r3, r3
}
 8002d76:	4618      	mov	r0, r3
 8002d78:	b002      	add	sp, #8
 8002d7a:	4770      	bx	lr
 8002d7c:	0000      	movs	r0, r0
	...

08002d80 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 8002d80:	b084      	sub	sp, #16
 8002d82:	9003      	str	r0, [sp, #12]
 8002d84:	9102      	str	r1, [sp, #8]
 8002d86:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002d88:	9b02      	ldr	r3, [sp, #8]
 8002d8a:	9a01      	ldr	r2, [sp, #4]
 8002d8c:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 8002d8e:	9b02      	ldr	r3, [sp, #8]
 8002d90:	9a03      	ldr	r2, [sp, #12]
 8002d92:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8002d94:	9b02      	ldr	r3, [sp, #8]
 8002d96:	685b      	ldr	r3, [r3, #4]
 8002d98:	681a      	ldr	r2, [r3, #0]
 8002d9a:	9b02      	ldr	r3, [sp, #8]
 8002d9c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 8002d9e:	9b02      	ldr	r3, [sp, #8]
 8002da0:	681b      	ldr	r3, [r3, #0]
 8002da2:	9a02      	ldr	r2, [sp, #8]
 8002da4:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 8002da6:	9b03      	ldr	r3, [sp, #12]
 8002da8:	9a02      	ldr	r2, [sp, #8]
 8002daa:	601a      	str	r2, [r3, #0]
}
 8002dac:	bf00      	nop
 8002dae:	b004      	add	sp, #16
 8002db0:	4770      	bx	lr
 8002db2:	bf00      	nop
	...

08002dc0 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 8002dc0:	b084      	sub	sp, #16
 8002dc2:	9003      	str	r0, [sp, #12]
 8002dc4:	9102      	str	r1, [sp, #8]
 8002dc6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002dc8:	9b02      	ldr	r3, [sp, #8]
 8002dca:	9a01      	ldr	r2, [sp, #4]
 8002dcc:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 8002dce:	9b02      	ldr	r3, [sp, #8]
 8002dd0:	9a03      	ldr	r2, [sp, #12]
 8002dd2:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8002dd4:	9b02      	ldr	r3, [sp, #8]
 8002dd6:	681b      	ldr	r3, [r3, #0]
 8002dd8:	685a      	ldr	r2, [r3, #4]
 8002dda:	9b02      	ldr	r3, [sp, #8]
 8002ddc:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 8002dde:	9b02      	ldr	r3, [sp, #8]
 8002de0:	685b      	ldr	r3, [r3, #4]
 8002de2:	9a02      	ldr	r2, [sp, #8]
 8002de4:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 8002de6:	9b03      	ldr	r3, [sp, #12]
 8002de8:	9a02      	ldr	r2, [sp, #8]
 8002dea:	605a      	str	r2, [r3, #4]
}
 8002dec:	bf00      	nop
 8002dee:	b004      	add	sp, #16
 8002df0:	4770      	bx	lr
 8002df2:	bf00      	nop
	...

08002e00 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8002e00:	b500      	push	{lr}
 8002e02:	b087      	sub	sp, #28
 8002e04:	9003      	str	r0, [sp, #12]
 8002e06:	9102      	str	r1, [sp, #8]
 8002e08:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 8002e0a:	9b03      	ldr	r3, [sp, #12]
 8002e0c:	681b      	ldr	r3, [r3, #0]
 8002e0e:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002e10:	e013      	b.n	8002e3a <ch_dlist_insert+0x3a>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8002e12:	9a05      	ldr	r2, [sp, #20]
 8002e14:	9b02      	ldr	r3, [sp, #8]
 8002e16:	429a      	cmp	r2, r3
 8002e18:	bf0c      	ite	eq
 8002e1a:	2301      	moveq	r3, #1
 8002e1c:	2300      	movne	r3, #0
 8002e1e:	b2db      	uxtb	r3, r3
 8002e20:	2b00      	cmp	r3, #0
 8002e22:	d002      	beq.n	8002e2a <ch_dlist_insert+0x2a>
 8002e24:	4813      	ldr	r0, [pc, #76]	@ (8002e74 <ch_dlist_insert+0x74>)
 8002e26:	f7ff fd83 	bl	8002930 <chSysHalt>

    delta -= dlp->delta;
 8002e2a:	9b05      	ldr	r3, [sp, #20]
 8002e2c:	689b      	ldr	r3, [r3, #8]
 8002e2e:	9a01      	ldr	r2, [sp, #4]
 8002e30:	1ad3      	subs	r3, r2, r3
 8002e32:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 8002e34:	9b05      	ldr	r3, [sp, #20]
 8002e36:	681b      	ldr	r3, [r3, #0]
 8002e38:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002e3a:	9b05      	ldr	r3, [sp, #20]
 8002e3c:	689b      	ldr	r3, [r3, #8]
 8002e3e:	9a01      	ldr	r2, [sp, #4]
 8002e40:	429a      	cmp	r2, r3
 8002e42:	bf8c      	ite	hi
 8002e44:	2301      	movhi	r3, #1
 8002e46:	2300      	movls	r3, #0
 8002e48:	b2db      	uxtb	r3, r3
 8002e4a:	2b00      	cmp	r3, #0
 8002e4c:	d1e1      	bne.n	8002e12 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 8002e4e:	9a01      	ldr	r2, [sp, #4]
 8002e50:	9902      	ldr	r1, [sp, #8]
 8002e52:	9805      	ldr	r0, [sp, #20]
 8002e54:	f7ff ffb4 	bl	8002dc0 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8002e58:	9b05      	ldr	r3, [sp, #20]
 8002e5a:	689a      	ldr	r2, [r3, #8]
 8002e5c:	9b01      	ldr	r3, [sp, #4]
 8002e5e:	1ad2      	subs	r2, r2, r3
 8002e60:	9b05      	ldr	r3, [sp, #20]
 8002e62:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8002e64:	9b03      	ldr	r3, [sp, #12]
 8002e66:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8002e6a:	609a      	str	r2, [r3, #8]
}
 8002e6c:	bf00      	nop
 8002e6e:	b007      	add	sp, #28
 8002e70:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e74:	08005640 	.word	0x08005640
	...

08002e80 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8002e80:	b084      	sub	sp, #16
 8002e82:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8002e84:	9b01      	ldr	r3, [sp, #4]
 8002e86:	681b      	ldr	r3, [r3, #0]
 8002e88:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 8002e8a:	9b03      	ldr	r3, [sp, #12]
 8002e8c:	681a      	ldr	r2, [r3, #0]
 8002e8e:	9b01      	ldr	r3, [sp, #4]
 8002e90:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8002e92:	9b01      	ldr	r3, [sp, #4]
 8002e94:	681b      	ldr	r3, [r3, #0]
 8002e96:	9a01      	ldr	r2, [sp, #4]
 8002e98:	605a      	str	r2, [r3, #4]

  return dlp;
 8002e9a:	9b03      	ldr	r3, [sp, #12]
}
 8002e9c:	4618      	mov	r0, r3
 8002e9e:	b004      	add	sp, #16
 8002ea0:	4770      	bx	lr
 8002ea2:	bf00      	nop
	...

08002eb0 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 8002eb0:	b082      	sub	sp, #8
 8002eb2:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 8002eb4:	9b01      	ldr	r3, [sp, #4]
 8002eb6:	685b      	ldr	r3, [r3, #4]
 8002eb8:	9a01      	ldr	r2, [sp, #4]
 8002eba:	6812      	ldr	r2, [r2, #0]
 8002ebc:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 8002ebe:	9b01      	ldr	r3, [sp, #4]
 8002ec0:	681b      	ldr	r3, [r3, #0]
 8002ec2:	9a01      	ldr	r2, [sp, #4]
 8002ec4:	6852      	ldr	r2, [r2, #4]
 8002ec6:	605a      	str	r2, [r3, #4]

  return dlp;
 8002ec8:	9b01      	ldr	r3, [sp, #4]
}
 8002eca:	4618      	mov	r0, r3
 8002ecc:	b002      	add	sp, #8
 8002ece:	4770      	bx	lr

08002ed0 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8002ed0:	b500      	push	{lr}
 8002ed2:	b083      	sub	sp, #12
 8002ed4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8002ed6:	9801      	ldr	r0, [sp, #4]
 8002ed8:	f7fd fada 	bl	8000490 <stStartAlarm>
}
 8002edc:	bf00      	nop
 8002ede:	b003      	add	sp, #12
 8002ee0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002ef0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8002ef0:	b508      	push	{r3, lr}

  stStopAlarm();
 8002ef2:	f7fd fae5 	bl	80004c0 <stStopAlarm>
}
 8002ef6:	bf00      	nop
 8002ef8:	bd08      	pop	{r3, pc}
 8002efa:	bf00      	nop
 8002efc:	0000      	movs	r0, r0
	...

08002f00 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8002f00:	b500      	push	{lr}
 8002f02:	b083      	sub	sp, #12
 8002f04:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8002f06:	9801      	ldr	r0, [sp, #4]
 8002f08:	f7fd fae2 	bl	80004d0 <stSetAlarm>
}
 8002f0c:	bf00      	nop
 8002f0e:	b003      	add	sp, #12
 8002f10:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002f20 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002f20:	b508      	push	{r3, lr}

  return stGetCounter();
 8002f22:	f7fd faad 	bl	8000480 <stGetCounter>
 8002f26:	4603      	mov	r3, r0
}
 8002f28:	4618      	mov	r0, r3
 8002f2a:	bd08      	pop	{r3, pc}
 8002f2c:	0000      	movs	r0, r0
	...

08002f30 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 8002f30:	b500      	push	{lr}
 8002f32:	b083      	sub	sp, #12
 8002f34:	2330      	movs	r3, #48	@ 0x30
 8002f36:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002f38:	9b01      	ldr	r3, [sp, #4]
 8002f3a:	f383 8811 	msr	BASEPRI, r3
}
 8002f3e:	bf00      	nop
}
 8002f40:	bf00      	nop
}
 8002f42:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002f44:	f7ff fdcc 	bl	8002ae0 <__dbg_check_lock_from_isr>
}
 8002f48:	bf00      	nop
 8002f4a:	b003      	add	sp, #12
 8002f4c:	f85d fb04 	ldr.w	pc, [sp], #4

08002f50 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
 8002f50:	b500      	push	{lr}
 8002f52:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002f54:	f7ff fdec 	bl	8002b30 <__dbg_check_unlock_from_isr>
 8002f58:	2300      	movs	r3, #0
 8002f5a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002f5c:	9b01      	ldr	r3, [sp, #4]
 8002f5e:	f383 8811 	msr	BASEPRI, r3
}
 8002f62:	bf00      	nop
}
 8002f64:	bf00      	nop
}
 8002f66:	bf00      	nop
}
 8002f68:	bf00      	nop
 8002f6a:	b003      	add	sp, #12
 8002f6c:	f85d fb04 	ldr.w	pc, [sp], #4

08002f70 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002f70:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002f72:	f7ff ffd5 	bl	8002f20 <port_timer_get_time.lto_priv.0>
 8002f76:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002f78:	4618      	mov	r0, r3
 8002f7a:	bd08      	pop	{r3, pc}
 8002f7c:	0000      	movs	r0, r0
	...

08002f80 <chVTIsArmedI.lto_priv.0>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8002f80:	b500      	push	{lr}
 8002f82:	b083      	sub	sp, #12
 8002f84:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002f86:	f7ff fe73 	bl	8002c70 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 8002f8a:	9b01      	ldr	r3, [sp, #4]
 8002f8c:	681b      	ldr	r3, [r3, #0]
 8002f8e:	2b00      	cmp	r3, #0
 8002f90:	bf14      	ite	ne
 8002f92:	2301      	movne	r3, #1
 8002f94:	2300      	moveq	r3, #0
 8002f96:	b2db      	uxtb	r3, r3
}
 8002f98:	4618      	mov	r0, r3
 8002f9a:	b003      	add	sp, #12
 8002f9c:	f85d fb04 	ldr.w	pc, [sp], #4

08002fa0 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 8002fa0:	b500      	push	{lr}
 8002fa2:	b087      	sub	sp, #28
 8002fa4:	9001      	str	r0, [sp, #4]
 8002fa6:	9100      	str	r1, [sp, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002fa8:	2302      	movs	r3, #2
 8002faa:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 8002fac:	9a00      	ldr	r2, [sp, #0]
 8002fae:	9b05      	ldr	r3, [sp, #20]
 8002fb0:	429a      	cmp	r2, r3
 8002fb2:	d201      	bcs.n	8002fb8 <vt_set_alarm+0x18>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002fb4:	9b05      	ldr	r3, [sp, #20]
 8002fb6:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 8002fb8:	9900      	ldr	r1, [sp, #0]
 8002fba:	9801      	ldr	r0, [sp, #4]
 8002fbc:	f7ff fea0 	bl	8002d00 <chTimeAddX>
 8002fc0:	4603      	mov	r3, r0
 8002fc2:	4618      	mov	r0, r3
 8002fc4:	f7ff ff9c 	bl	8002f00 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002fc8:	f7ff ffd2 	bl	8002f70 <chVTGetSystemTimeX.lto_priv.0>
 8002fcc:	9004      	str	r0, [sp, #16]
    nowdelta = chTimeDiffX(now, newnow);
 8002fce:	9904      	ldr	r1, [sp, #16]
 8002fd0:	9801      	ldr	r0, [sp, #4]
 8002fd2:	f7ff fea5 	bl	8002d20 <chTimeDiffX.lto_priv.0>
 8002fd6:	9003      	str	r0, [sp, #12]
    if (likely(nowdelta < delay)) {
 8002fd8:	9a03      	ldr	r2, [sp, #12]
 8002fda:	9b00      	ldr	r3, [sp, #0]
 8002fdc:	429a      	cmp	r2, r3
 8002fde:	bf34      	ite	cc
 8002fe0:	2301      	movcc	r3, #1
 8002fe2:	2300      	movcs	r3, #0
 8002fe4:	b2db      	uxtb	r3, r3
 8002fe6:	2b00      	cmp	r3, #0
 8002fe8:	d107      	bne.n	8002ffa <vt_set_alarm+0x5a>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002fea:	9b05      	ldr	r3, [sp, #20]
 8002fec:	3301      	adds	r3, #1
 8002fee:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002ff0:	9b04      	ldr	r3, [sp, #16]
 8002ff2:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 8002ff4:	9b05      	ldr	r3, [sp, #20]
 8002ff6:	9300      	str	r3, [sp, #0]
  while (true) {
 8002ff8:	e7de      	b.n	8002fb8 <vt_set_alarm+0x18>
      break;
 8002ffa:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002ffc:	9b05      	ldr	r3, [sp, #20]
 8002ffe:	2b02      	cmp	r3, #2
 8003000:	d902      	bls.n	8003008 <vt_set_alarm+0x68>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8003002:	2001      	movs	r0, #1
 8003004:	f7ff fd0c 	bl	8002a20 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8003008:	bf00      	nop
 800300a:	b007      	add	sp, #28
 800300c:	f85d fb04 	ldr.w	pc, [sp], #4

08003010 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8003010:	b500      	push	{lr}
 8003012:	b087      	sub	sp, #28
 8003014:	9003      	str	r0, [sp, #12]
 8003016:	9102      	str	r1, [sp, #8]
 8003018:	9201      	str	r2, [sp, #4]
 800301a:	9300      	str	r3, [sp, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 800301c:	9b03      	ldr	r3, [sp, #12]
 800301e:	9a01      	ldr	r2, [sp, #4]
 8003020:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8003022:	9b03      	ldr	r3, [sp, #12]
 8003024:	9902      	ldr	r1, [sp, #8]
 8003026:	9a00      	ldr	r2, [sp, #0]
 8003028:	4618      	mov	r0, r3
 800302a:	f7ff fea9 	bl	8002d80 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800302e:	2302      	movs	r3, #2
 8003030:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8003032:	9a00      	ldr	r2, [sp, #0]
 8003034:	9b05      	ldr	r3, [sp, #20]
 8003036:	429a      	cmp	r2, r3
 8003038:	d201      	bcs.n	800303e <vt_insert_first+0x2e>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 800303a:	9b05      	ldr	r3, [sp, #20]
 800303c:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 800303e:	9b03      	ldr	r3, [sp, #12]
 8003040:	68db      	ldr	r3, [r3, #12]
 8003042:	9900      	ldr	r1, [sp, #0]
 8003044:	4618      	mov	r0, r3
 8003046:	f7ff fe5b 	bl	8002d00 <chTimeAddX>
 800304a:	4603      	mov	r3, r0
 800304c:	4618      	mov	r0, r3
 800304e:	f7ff ff3f 	bl	8002ed0 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8003052:	f7ff ff8d 	bl	8002f70 <chVTGetSystemTimeX.lto_priv.0>
 8003056:	9004      	str	r0, [sp, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8003058:	9904      	ldr	r1, [sp, #16]
 800305a:	9801      	ldr	r0, [sp, #4]
 800305c:	f7ff fe60 	bl	8002d20 <chTimeDiffX.lto_priv.0>
 8003060:	4602      	mov	r2, r0
 8003062:	9b00      	ldr	r3, [sp, #0]
 8003064:	4293      	cmp	r3, r2
 8003066:	bf8c      	ite	hi
 8003068:	2301      	movhi	r3, #1
 800306a:	2300      	movls	r3, #0
 800306c:	b2db      	uxtb	r3, r3
 800306e:	2b00      	cmp	r3, #0
 8003070:	d10f      	bne.n	8003092 <vt_insert_first+0x82>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8003072:	9b05      	ldr	r3, [sp, #20]
 8003074:	3301      	adds	r3, #1
 8003076:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8003078:	9905      	ldr	r1, [sp, #20]
 800307a:	9801      	ldr	r0, [sp, #4]
 800307c:	f7ff fe40 	bl	8002d00 <chTimeAddX>
 8003080:	4603      	mov	r3, r0
 8003082:	4618      	mov	r0, r3
 8003084:	f7ff ff3c 	bl	8002f00 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8003088:	9b04      	ldr	r3, [sp, #16]
 800308a:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 800308c:	9b05      	ldr	r3, [sp, #20]
 800308e:	9300      	str	r3, [sp, #0]
  while (true) {
 8003090:	e7df      	b.n	8003052 <vt_insert_first+0x42>
      break;
 8003092:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8003094:	9b05      	ldr	r3, [sp, #20]
 8003096:	2b02      	cmp	r3, #2
 8003098:	d902      	bls.n	80030a0 <vt_insert_first+0x90>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 800309a:	2001      	movs	r0, #1
 800309c:	f7ff fcc0 	bl	8002a20 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80030a0:	bf00      	nop
 80030a2:	b007      	add	sp, #28
 80030a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080030b0 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 80030b0:	b500      	push	{lr}
 80030b2:	b089      	sub	sp, #36	@ 0x24
 80030b4:	9003      	str	r0, [sp, #12]
 80030b6:	9102      	str	r1, [sp, #8]
 80030b8:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 80030ba:	f7ff ff59 	bl	8002f70 <chVTGetSystemTimeX.lto_priv.0>
 80030be:	9006      	str	r0, [sp, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 80030c0:	9b03      	ldr	r3, [sp, #12]
 80030c2:	4618      	mov	r0, r3
 80030c4:	f7ff fe3c 	bl	8002d40 <ch_dlist_isempty>
 80030c8:	4603      	mov	r3, r0
 80030ca:	2b00      	cmp	r3, #0
 80030cc:	d006      	beq.n	80030dc <vt_enqueue+0x2c>

      vt_insert_first(vtlp, vtp, now, delay);
 80030ce:	9b01      	ldr	r3, [sp, #4]
 80030d0:	9a06      	ldr	r2, [sp, #24]
 80030d2:	9902      	ldr	r1, [sp, #8]
 80030d4:	9803      	ldr	r0, [sp, #12]
 80030d6:	f7ff ff9b 	bl	8003010 <vt_insert_first>

      return;
 80030da:	e020      	b.n	800311e <vt_enqueue+0x6e>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80030dc:	9b03      	ldr	r3, [sp, #12]
 80030de:	68db      	ldr	r3, [r3, #12]
 80030e0:	9906      	ldr	r1, [sp, #24]
 80030e2:	4618      	mov	r0, r3
 80030e4:	f7ff fe1c 	bl	8002d20 <chTimeDiffX.lto_priv.0>
 80030e8:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
 80030ea:	9a05      	ldr	r2, [sp, #20]
 80030ec:	9b01      	ldr	r3, [sp, #4]
 80030ee:	4413      	add	r3, r2
 80030f0:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 80030f2:	9a07      	ldr	r2, [sp, #28]
 80030f4:	9b05      	ldr	r3, [sp, #20]
 80030f6:	429a      	cmp	r2, r3
 80030f8:	d201      	bcs.n	80030fe <vt_enqueue+0x4e>
      delta = delay;
 80030fa:	9b01      	ldr	r3, [sp, #4]
 80030fc:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 80030fe:	9b03      	ldr	r3, [sp, #12]
 8003100:	681b      	ldr	r3, [r3, #0]
 8003102:	689b      	ldr	r3, [r3, #8]
 8003104:	9a07      	ldr	r2, [sp, #28]
 8003106:	429a      	cmp	r2, r3
 8003108:	d203      	bcs.n	8003112 <vt_enqueue+0x62>

      vt_set_alarm(now, delay);
 800310a:	9901      	ldr	r1, [sp, #4]
 800310c:	9806      	ldr	r0, [sp, #24]
 800310e:	f7ff ff47 	bl	8002fa0 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003112:	9b03      	ldr	r3, [sp, #12]
 8003114:	9902      	ldr	r1, [sp, #8]
 8003116:	9a07      	ldr	r2, [sp, #28]
 8003118:	4618      	mov	r0, r3
 800311a:	f7ff fe71 	bl	8002e00 <ch_dlist_insert>
}
 800311e:	b009      	add	sp, #36	@ 0x24
 8003120:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003130 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8003130:	b500      	push	{lr}
 8003132:	b087      	sub	sp, #28
 8003134:	9003      	str	r0, [sp, #12]
 8003136:	9102      	str	r1, [sp, #8]
 8003138:	9201      	str	r2, [sp, #4]
 800313a:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 800313c:	4b1a      	ldr	r3, [pc, #104]	@ (80031a8 <chVTDoSetI+0x78>)
 800313e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8003140:	f7ff fd96 	bl	8002c70 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8003144:	9b03      	ldr	r3, [sp, #12]
 8003146:	2b00      	cmp	r3, #0
 8003148:	bf0c      	ite	eq
 800314a:	2301      	moveq	r3, #1
 800314c:	2300      	movne	r3, #0
 800314e:	b2db      	uxtb	r3, r3
 8003150:	2b00      	cmp	r3, #0
 8003152:	d107      	bne.n	8003164 <chVTDoSetI+0x34>
 8003154:	9b01      	ldr	r3, [sp, #4]
 8003156:	2b00      	cmp	r3, #0
 8003158:	bf0c      	ite	eq
 800315a:	2301      	moveq	r3, #1
 800315c:	2300      	movne	r3, #0
 800315e:	b2db      	uxtb	r3, r3
 8003160:	2b00      	cmp	r3, #0
 8003162:	d001      	beq.n	8003168 <chVTDoSetI+0x38>
 8003164:	2301      	movs	r3, #1
 8003166:	e000      	b.n	800316a <chVTDoSetI+0x3a>
 8003168:	2300      	movs	r3, #0
 800316a:	2b00      	cmp	r3, #0
 800316c:	d107      	bne.n	800317e <chVTDoSetI+0x4e>
 800316e:	9b02      	ldr	r3, [sp, #8]
 8003170:	2b00      	cmp	r3, #0
 8003172:	bf0c      	ite	eq
 8003174:	2301      	moveq	r3, #1
 8003176:	2300      	movne	r3, #0
 8003178:	b2db      	uxtb	r3, r3
 800317a:	2b00      	cmp	r3, #0
 800317c:	d002      	beq.n	8003184 <chVTDoSetI+0x54>
 800317e:	480b      	ldr	r0, [pc, #44]	@ (80031ac <chVTDoSetI+0x7c>)
 8003180:	f7ff fbd6 	bl	8002930 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8003184:	9b03      	ldr	r3, [sp, #12]
 8003186:	9a00      	ldr	r2, [sp, #0]
 8003188:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 800318a:	9b03      	ldr	r3, [sp, #12]
 800318c:	9a01      	ldr	r2, [sp, #4]
 800318e:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8003190:	9b03      	ldr	r3, [sp, #12]
 8003192:	2200      	movs	r2, #0
 8003194:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8003196:	9a02      	ldr	r2, [sp, #8]
 8003198:	9903      	ldr	r1, [sp, #12]
 800319a:	9805      	ldr	r0, [sp, #20]
 800319c:	f7ff ff88 	bl	80030b0 <vt_enqueue>
}
 80031a0:	bf00      	nop
 80031a2:	b007      	add	sp, #28
 80031a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80031a8:	20000998 	.word	0x20000998
 80031ac:	08005650 	.word	0x08005650

080031b0 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80031b0:	b500      	push	{lr}
 80031b2:	b087      	sub	sp, #28
 80031b4:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 80031b6:	4b3a      	ldr	r3, [pc, #232]	@ (80032a0 <chVTDoResetI+0xf0>)
 80031b8:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 80031ba:	f7ff fd59 	bl	8002c70 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 80031be:	9b01      	ldr	r3, [sp, #4]
 80031c0:	2b00      	cmp	r3, #0
 80031c2:	bf0c      	ite	eq
 80031c4:	2301      	moveq	r3, #1
 80031c6:	2300      	movne	r3, #0
 80031c8:	b2db      	uxtb	r3, r3
 80031ca:	2b00      	cmp	r3, #0
 80031cc:	d002      	beq.n	80031d4 <chVTDoResetI+0x24>
 80031ce:	4835      	ldr	r0, [pc, #212]	@ (80032a4 <chVTDoResetI+0xf4>)
 80031d0:	f7ff fbae 	bl	8002930 <chSysHalt>
  chDbgAssert(chVTIsArmedI(vtp), "timer not armed");
 80031d4:	9801      	ldr	r0, [sp, #4]
 80031d6:	f7ff fed3 	bl	8002f80 <chVTIsArmedI.lto_priv.0>
 80031da:	4603      	mov	r3, r0
 80031dc:	f083 0301 	eor.w	r3, r3, #1
 80031e0:	b2db      	uxtb	r3, r3
 80031e2:	2b00      	cmp	r3, #0
 80031e4:	d002      	beq.n	80031ec <chVTDoResetI+0x3c>
 80031e6:	482f      	ldr	r0, [pc, #188]	@ (80032a4 <chVTDoResetI+0xf4>)
 80031e8:	f7ff fba2 	bl	8002930 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 80031ec:	9b05      	ldr	r3, [sp, #20]
 80031ee:	9a01      	ldr	r2, [sp, #4]
 80031f0:	4611      	mov	r1, r2
 80031f2:	4618      	mov	r0, r3
 80031f4:	f7ff fdb4 	bl	8002d60 <ch_dlist_isfirst>
 80031f8:	4603      	mov	r3, r0
 80031fa:	f083 0301 	eor.w	r3, r3, #1
 80031fe:	b2db      	uxtb	r3, r3
 8003200:	2b00      	cmp	r3, #0
 8003202:	d014      	beq.n	800322e <chVTDoResetI+0x7e>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8003204:	9b01      	ldr	r3, [sp, #4]
 8003206:	4618      	mov	r0, r3
 8003208:	f7ff fe52 	bl	8002eb0 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 800320c:	9b01      	ldr	r3, [sp, #4]
 800320e:	681b      	ldr	r3, [r3, #0]
 8003210:	6899      	ldr	r1, [r3, #8]
 8003212:	9b01      	ldr	r3, [sp, #4]
 8003214:	689a      	ldr	r2, [r3, #8]
 8003216:	9b01      	ldr	r3, [sp, #4]
 8003218:	681b      	ldr	r3, [r3, #0]
 800321a:	440a      	add	r2, r1
 800321c:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 800321e:	9b01      	ldr	r3, [sp, #4]
 8003220:	2200      	movs	r2, #0
 8003222:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8003224:	9b05      	ldr	r3, [sp, #20]
 8003226:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800322a:	609a      	str	r2, [r3, #8]

    return;
 800322c:	e035      	b.n	800329a <chVTDoResetI+0xea>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 800322e:	9b05      	ldr	r3, [sp, #20]
 8003230:	4618      	mov	r0, r3
 8003232:	f7ff fe25 	bl	8002e80 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8003236:	9b01      	ldr	r3, [sp, #4]
 8003238:	2200      	movs	r2, #0
 800323a:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 800323c:	9b05      	ldr	r3, [sp, #20]
 800323e:	4618      	mov	r0, r3
 8003240:	f7ff fd7e 	bl	8002d40 <ch_dlist_isempty>
 8003244:	4603      	mov	r3, r0
 8003246:	2b00      	cmp	r3, #0
 8003248:	d002      	beq.n	8003250 <chVTDoResetI+0xa0>

    port_timer_stop_alarm();
 800324a:	f7ff fe51 	bl	8002ef0 <port_timer_stop_alarm>

    return;
 800324e:	e024      	b.n	800329a <chVTDoResetI+0xea>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8003250:	9b05      	ldr	r3, [sp, #20]
 8003252:	681b      	ldr	r3, [r3, #0]
 8003254:	6899      	ldr	r1, [r3, #8]
 8003256:	9b01      	ldr	r3, [sp, #4]
 8003258:	689a      	ldr	r2, [r3, #8]
 800325a:	9b05      	ldr	r3, [sp, #20]
 800325c:	681b      	ldr	r3, [r3, #0]
 800325e:	440a      	add	r2, r1
 8003260:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 8003262:	f7ff fe85 	bl	8002f70 <chVTGetSystemTimeX.lto_priv.0>
 8003266:	9004      	str	r0, [sp, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003268:	9b05      	ldr	r3, [sp, #20]
 800326a:	68db      	ldr	r3, [r3, #12]
 800326c:	9904      	ldr	r1, [sp, #16]
 800326e:	4618      	mov	r0, r3
 8003270:	f7ff fd56 	bl	8002d20 <chTimeDiffX.lto_priv.0>
 8003274:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8003276:	9b05      	ldr	r3, [sp, #20]
 8003278:	681b      	ldr	r3, [r3, #0]
 800327a:	689b      	ldr	r3, [r3, #8]
 800327c:	9a03      	ldr	r2, [sp, #12]
 800327e:	429a      	cmp	r2, r3
 8003280:	d20a      	bcs.n	8003298 <chVTDoResetI+0xe8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8003282:	9b05      	ldr	r3, [sp, #20]
 8003284:	681b      	ldr	r3, [r3, #0]
 8003286:	689a      	ldr	r2, [r3, #8]
 8003288:	9b03      	ldr	r3, [sp, #12]
 800328a:	1ad3      	subs	r3, r2, r3
 800328c:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 800328e:	9902      	ldr	r1, [sp, #8]
 8003290:	9804      	ldr	r0, [sp, #16]
 8003292:	f7ff fe85 	bl	8002fa0 <vt_set_alarm>
 8003296:	e000      	b.n	800329a <chVTDoResetI+0xea>
    return;
 8003298:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800329a:	b007      	add	sp, #28
 800329c:	f85d fb04 	ldr.w	pc, [sp], #4
 80032a0:	20000998 	.word	0x20000998
 80032a4:	0800565c 	.word	0x0800565c
	...

080032b0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 80032b0:	b500      	push	{lr}
 80032b2:	b089      	sub	sp, #36	@ 0x24
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 80032b4:	4b4f      	ldr	r3, [pc, #316]	@ (80033f4 <chVTDoTickI+0x144>)
 80032b6:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 80032b8:	f7ff fcda 	bl	8002c70 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 80032bc:	9b05      	ldr	r3, [sp, #20]
 80032be:	681b      	ldr	r3, [r3, #0]
 80032c0:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 80032c2:	f7ff fe55 	bl	8002f70 <chVTGetSystemTimeX.lto_priv.0>
 80032c6:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80032c8:	9b05      	ldr	r3, [sp, #20]
 80032ca:	68db      	ldr	r3, [r3, #12]
 80032cc:	9903      	ldr	r1, [sp, #12]
 80032ce:	4618      	mov	r0, r3
 80032d0:	f7ff fd26 	bl	8002d20 <chTimeDiffX.lto_priv.0>
 80032d4:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 80032d6:	9b04      	ldr	r3, [sp, #16]
 80032d8:	689b      	ldr	r3, [r3, #8]
 80032da:	9a02      	ldr	r2, [sp, #8]
 80032dc:	429a      	cmp	r2, r3
 80032de:	d369      	bcc.n	80033b4 <chVTDoTickI+0x104>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 80032e0:	9b05      	ldr	r3, [sp, #20]
 80032e2:	68da      	ldr	r2, [r3, #12]
 80032e4:	9b04      	ldr	r3, [sp, #16]
 80032e6:	689b      	ldr	r3, [r3, #8]
 80032e8:	4619      	mov	r1, r3
 80032ea:	4610      	mov	r0, r2
 80032ec:	f7ff fd08 	bl	8002d00 <chTimeAddX>
 80032f0:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
 80032f2:	9b05      	ldr	r3, [sp, #20]
 80032f4:	9a01      	ldr	r2, [sp, #4]
 80032f6:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 80032f8:	9b04      	ldr	r3, [sp, #16]
 80032fa:	4618      	mov	r0, r3
 80032fc:	f7ff fdd8 	bl	8002eb0 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8003300:	9b04      	ldr	r3, [sp, #16]
 8003302:	2200      	movs	r2, #0
 8003304:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003306:	9b05      	ldr	r3, [sp, #20]
 8003308:	4618      	mov	r0, r3
 800330a:	f7ff fd19 	bl	8002d40 <ch_dlist_isempty>
 800330e:	4603      	mov	r3, r0
 8003310:	2b00      	cmp	r3, #0
 8003312:	d001      	beq.n	8003318 <chVTDoTickI+0x68>
      port_timer_stop_alarm();
 8003314:	f7ff fdec 	bl	8002ef0 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 8003318:	f7ff fe1a 	bl	8002f50 <chSysUnlockFromISR.lto_priv.3>

    vtp->func(vtp, vtp->par);
 800331c:	9b04      	ldr	r3, [sp, #16]
 800331e:	68db      	ldr	r3, [r3, #12]
 8003320:	9a04      	ldr	r2, [sp, #16]
 8003322:	6912      	ldr	r2, [r2, #16]
 8003324:	4611      	mov	r1, r2
 8003326:	9804      	ldr	r0, [sp, #16]
 8003328:	4798      	blx	r3

    chSysLockFromISR();
 800332a:	f7ff fe01 	bl	8002f30 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 800332e:	9b04      	ldr	r3, [sp, #16]
 8003330:	695b      	ldr	r3, [r3, #20]
 8003332:	2b00      	cmp	r3, #0
 8003334:	bf14      	ite	ne
 8003336:	2301      	movne	r3, #1
 8003338:	2300      	moveq	r3, #0
 800333a:	b2db      	uxtb	r3, r3
 800333c:	2b00      	cmp	r3, #0
 800333e:	d0bd      	beq.n	80032bc <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8003340:	f7ff fe16 	bl	8002f70 <chVTGetSystemTimeX.lto_priv.0>
 8003344:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 8003346:	9903      	ldr	r1, [sp, #12]
 8003348:	9801      	ldr	r0, [sp, #4]
 800334a:	f7ff fce9 	bl	8002d20 <chTimeDiffX.lto_priv.0>
 800334e:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8003350:	9b04      	ldr	r3, [sp, #16]
 8003352:	695b      	ldr	r3, [r3, #20]
 8003354:	9a02      	ldr	r2, [sp, #8]
 8003356:	429a      	cmp	r2, r3
 8003358:	d908      	bls.n	800336c <chVTDoTickI+0xbc>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
 800335a:	4827      	ldr	r0, [pc, #156]	@ (80033f8 <chVTDoTickI+0x148>)
 800335c:	f7ff fae8 	bl	8002930 <chSysHalt>
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8003360:	2002      	movs	r0, #2
 8003362:	f7ff fb5d 	bl	8002a20 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8003366:	2300      	movs	r3, #0
 8003368:	9306      	str	r3, [sp, #24]
 800336a:	e004      	b.n	8003376 <chVTDoTickI+0xc6>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 800336c:	9b04      	ldr	r3, [sp, #16]
 800336e:	695a      	ldr	r2, [r3, #20]
 8003370:	9b02      	ldr	r3, [sp, #8]
 8003372:	1ad3      	subs	r3, r2, r3
 8003374:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8003376:	9b05      	ldr	r3, [sp, #20]
 8003378:	4618      	mov	r0, r3
 800337a:	f7ff fce1 	bl	8002d40 <ch_dlist_isempty>
 800337e:	4603      	mov	r3, r0
 8003380:	2b00      	cmp	r3, #0
 8003382:	d006      	beq.n	8003392 <chVTDoTickI+0xe2>

        vt_insert_first(vtlp, vtp, now, delay);
 8003384:	9b06      	ldr	r3, [sp, #24]
 8003386:	9a03      	ldr	r2, [sp, #12]
 8003388:	9904      	ldr	r1, [sp, #16]
 800338a:	9805      	ldr	r0, [sp, #20]
 800338c:	f7ff fe40 	bl	8003010 <vt_insert_first>

        return;
 8003390:	e02c      	b.n	80033ec <chVTDoTickI+0x13c>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8003392:	9a02      	ldr	r2, [sp, #8]
 8003394:	9b06      	ldr	r3, [sp, #24]
 8003396:	4413      	add	r3, r2
 8003398:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 800339a:	9a07      	ldr	r2, [sp, #28]
 800339c:	9b02      	ldr	r3, [sp, #8]
 800339e:	429a      	cmp	r2, r3
 80033a0:	d201      	bcs.n	80033a6 <chVTDoTickI+0xf6>
        delta = delay;
 80033a2:	9b06      	ldr	r3, [sp, #24]
 80033a4:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 80033a6:	9b05      	ldr	r3, [sp, #20]
 80033a8:	9904      	ldr	r1, [sp, #16]
 80033aa:	9a07      	ldr	r2, [sp, #28]
 80033ac:	4618      	mov	r0, r3
 80033ae:	f7ff fd27 	bl	8002e00 <ch_dlist_insert>
  while (true) {
 80033b2:	e783      	b.n	80032bc <chVTDoTickI+0xc>
      break;
 80033b4:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 80033b6:	9b05      	ldr	r3, [sp, #20]
 80033b8:	4618      	mov	r0, r3
 80033ba:	f7ff fcc1 	bl	8002d40 <ch_dlist_isempty>
 80033be:	4603      	mov	r3, r0
 80033c0:	2b00      	cmp	r3, #0
 80033c2:	d112      	bne.n	80033ea <chVTDoTickI+0x13a>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 80033c4:	9b05      	ldr	r3, [sp, #20]
 80033c6:	68da      	ldr	r2, [r3, #12]
 80033c8:	9b02      	ldr	r3, [sp, #8]
 80033ca:	441a      	add	r2, r3
 80033cc:	9b05      	ldr	r3, [sp, #20]
 80033ce:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 80033d0:	9b04      	ldr	r3, [sp, #16]
 80033d2:	689a      	ldr	r2, [r3, #8]
 80033d4:	9b02      	ldr	r3, [sp, #8]
 80033d6:	1ad2      	subs	r2, r2, r3
 80033d8:	9b04      	ldr	r3, [sp, #16]
 80033da:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 80033dc:	9b04      	ldr	r3, [sp, #16]
 80033de:	689b      	ldr	r3, [r3, #8]
 80033e0:	4619      	mov	r1, r3
 80033e2:	9803      	ldr	r0, [sp, #12]
 80033e4:	f7ff fddc 	bl	8002fa0 <vt_set_alarm>
 80033e8:	e000      	b.n	80033ec <chVTDoTickI+0x13c>
    return;
 80033ea:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80033ec:	b009      	add	sp, #36	@ 0x24
 80033ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80033f2:	bf00      	nop
 80033f4:	20000998 	.word	0x20000998
 80033f8:	0800566c 	.word	0x0800566c
 80033fc:	00000000 	.word	0x00000000

08003400 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003400:	b082      	sub	sp, #8
 8003402:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003404:	9b01      	ldr	r3, [sp, #4]
 8003406:	685b      	ldr	r3, [r3, #4]
 8003408:	9a01      	ldr	r2, [sp, #4]
 800340a:	6812      	ldr	r2, [r2, #0]
 800340c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800340e:	9b01      	ldr	r3, [sp, #4]
 8003410:	681b      	ldr	r3, [r3, #0]
 8003412:	9a01      	ldr	r2, [sp, #4]
 8003414:	6852      	ldr	r2, [r2, #4]
 8003416:	605a      	str	r2, [r3, #4]
  return p;
 8003418:	9b01      	ldr	r3, [sp, #4]
}
 800341a:	4618      	mov	r0, r3
 800341c:	b002      	add	sp, #8
 800341e:	4770      	bx	lr

08003420 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 8003420:	b084      	sub	sp, #16
 8003422:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 8003424:	9b01      	ldr	r3, [sp, #4]
 8003426:	681b      	ldr	r3, [r3, #0]
 8003428:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 800342a:	9b03      	ldr	r3, [sp, #12]
 800342c:	681a      	ldr	r2, [r3, #0]
 800342e:	9b01      	ldr	r3, [sp, #4]
 8003430:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 8003432:	9b01      	ldr	r3, [sp, #4]
 8003434:	681b      	ldr	r3, [r3, #0]
 8003436:	9a01      	ldr	r2, [sp, #4]
 8003438:	605a      	str	r2, [r3, #4]
  return p;
 800343a:	9b03      	ldr	r3, [sp, #12]
}
 800343c:	4618      	mov	r0, r3
 800343e:	b004      	add	sp, #16
 8003440:	4770      	bx	lr
 8003442:	bf00      	nop
	...

08003450 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8003450:	b082      	sub	sp, #8
 8003452:	9001      	str	r0, [sp, #4]
 8003454:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003456:	9b01      	ldr	r3, [sp, #4]
 8003458:	681b      	ldr	r3, [r3, #0]
 800345a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 800345c:	9b01      	ldr	r3, [sp, #4]
 800345e:	689a      	ldr	r2, [r3, #8]
 8003460:	9b00      	ldr	r3, [sp, #0]
 8003462:	689b      	ldr	r3, [r3, #8]
 8003464:	429a      	cmp	r2, r3
 8003466:	bf2c      	ite	cs
 8003468:	2301      	movcs	r3, #1
 800346a:	2300      	movcc	r3, #0
 800346c:	b2db      	uxtb	r3, r3
 800346e:	2b00      	cmp	r3, #0
 8003470:	d1f1      	bne.n	8003456 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8003472:	9b00      	ldr	r3, [sp, #0]
 8003474:	9a01      	ldr	r2, [sp, #4]
 8003476:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003478:	9b01      	ldr	r3, [sp, #4]
 800347a:	685a      	ldr	r2, [r3, #4]
 800347c:	9b00      	ldr	r3, [sp, #0]
 800347e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003480:	9b00      	ldr	r3, [sp, #0]
 8003482:	685b      	ldr	r3, [r3, #4]
 8003484:	9a00      	ldr	r2, [sp, #0]
 8003486:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003488:	9b01      	ldr	r3, [sp, #4]
 800348a:	9a00      	ldr	r2, [sp, #0]
 800348c:	605a      	str	r2, [r3, #4]
  return p;
 800348e:	9b00      	ldr	r3, [sp, #0]
}
 8003490:	4618      	mov	r0, r3
 8003492:	b002      	add	sp, #8
 8003494:	4770      	bx	lr
 8003496:	bf00      	nop
	...

080034a0 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 80034a0:	b082      	sub	sp, #8
 80034a2:	9001      	str	r0, [sp, #4]
 80034a4:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 80034a6:	9b01      	ldr	r3, [sp, #4]
 80034a8:	681b      	ldr	r3, [r3, #0]
 80034aa:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 80034ac:	9b01      	ldr	r3, [sp, #4]
 80034ae:	689a      	ldr	r2, [r3, #8]
 80034b0:	9b00      	ldr	r3, [sp, #0]
 80034b2:	689b      	ldr	r3, [r3, #8]
 80034b4:	429a      	cmp	r2, r3
 80034b6:	bf8c      	ite	hi
 80034b8:	2301      	movhi	r3, #1
 80034ba:	2300      	movls	r3, #0
 80034bc:	b2db      	uxtb	r3, r3
 80034be:	2b00      	cmp	r3, #0
 80034c0:	d1f1      	bne.n	80034a6 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 80034c2:	9b00      	ldr	r3, [sp, #0]
 80034c4:	9a01      	ldr	r2, [sp, #4]
 80034c6:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 80034c8:	9b01      	ldr	r3, [sp, #4]
 80034ca:	685a      	ldr	r2, [r3, #4]
 80034cc:	9b00      	ldr	r3, [sp, #0]
 80034ce:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 80034d0:	9b00      	ldr	r3, [sp, #0]
 80034d2:	685b      	ldr	r3, [r3, #4]
 80034d4:	9a00      	ldr	r2, [sp, #0]
 80034d6:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 80034d8:	9b01      	ldr	r3, [sp, #4]
 80034da:	9a00      	ldr	r2, [sp, #0]
 80034dc:	605a      	str	r2, [r3, #4]
  return p;
 80034de:	9b00      	ldr	r3, [sp, #0]
}
 80034e0:	4618      	mov	r0, r3
 80034e2:	b002      	add	sp, #8
 80034e4:	4770      	bx	lr
 80034e6:	bf00      	nop
	...

080034f0 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 80034f0:	b500      	push	{lr}
 80034f2:	b083      	sub	sp, #12
 80034f4:	2330      	movs	r3, #48	@ 0x30
 80034f6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80034f8:	9b01      	ldr	r3, [sp, #4]
 80034fa:	f383 8811 	msr	BASEPRI, r3
}
 80034fe:	bf00      	nop
}
 8003500:	bf00      	nop
}
 8003502:	bf00      	nop
  __dbg_check_lock_from_isr();
 8003504:	f7ff faec 	bl	8002ae0 <__dbg_check_lock_from_isr>
}
 8003508:	bf00      	nop
 800350a:	b003      	add	sp, #12
 800350c:	f85d fb04 	ldr.w	pc, [sp], #4

08003510 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 8003510:	b500      	push	{lr}
 8003512:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8003514:	f7ff fb0c 	bl	8002b30 <__dbg_check_unlock_from_isr>
 8003518:	2300      	movs	r3, #0
 800351a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800351c:	9b01      	ldr	r3, [sp, #4]
 800351e:	f383 8811 	msr	BASEPRI, r3
}
 8003522:	bf00      	nop
}
 8003524:	bf00      	nop
}
 8003526:	bf00      	nop
}
 8003528:	bf00      	nop
 800352a:	b003      	add	sp, #12
 800352c:	f85d fb04 	ldr.w	pc, [sp], #4

08003530 <chVTIsArmedI.lto_priv.1>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8003530:	b500      	push	{lr}
 8003532:	b083      	sub	sp, #12
 8003534:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8003536:	f7ff fb9b 	bl	8002c70 <chDbgCheckClassI>
  return (bool)(vtp->dlist.next != NULL);
 800353a:	9b01      	ldr	r3, [sp, #4]
 800353c:	681b      	ldr	r3, [r3, #0]
 800353e:	2b00      	cmp	r3, #0
 8003540:	bf14      	ite	ne
 8003542:	2301      	movne	r3, #1
 8003544:	2300      	moveq	r3, #0
 8003546:	b2db      	uxtb	r3, r3
}
 8003548:	4618      	mov	r0, r3
 800354a:	b003      	add	sp, #12
 800354c:	f85d fb04 	ldr.w	pc, [sp], #4

08003550 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8003550:	b500      	push	{lr}
 8003552:	b083      	sub	sp, #12
 8003554:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003556:	f7ff fb8b 	bl	8002c70 <chDbgCheckClassI>

  sp->cnt++;
 800355a:	9b01      	ldr	r3, [sp, #4]
 800355c:	689b      	ldr	r3, [r3, #8]
 800355e:	1c5a      	adds	r2, r3, #1
 8003560:	9b01      	ldr	r3, [sp, #4]
 8003562:	609a      	str	r2, [r3, #8]
}
 8003564:	bf00      	nop
 8003566:	b003      	add	sp, #12
 8003568:	f85d fb04 	ldr.w	pc, [sp], #4
 800356c:	0000      	movs	r0, r0
	...

08003570 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8003570:	b500      	push	{lr}
 8003572:	b083      	sub	sp, #12
 8003574:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003576:	9b01      	ldr	r3, [sp, #4]
 8003578:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800357c:	2b00      	cmp	r3, #0
 800357e:	bf0c      	ite	eq
 8003580:	2301      	moveq	r3, #1
 8003582:	2300      	movne	r3, #0
 8003584:	b2db      	uxtb	r3, r3
 8003586:	2b00      	cmp	r3, #0
 8003588:	d109      	bne.n	800359e <__sch_ready_behind+0x2e>
 800358a:	9b01      	ldr	r3, [sp, #4]
 800358c:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003590:	2b0f      	cmp	r3, #15
 8003592:	bf0c      	ite	eq
 8003594:	2301      	moveq	r3, #1
 8003596:	2300      	movne	r3, #0
 8003598:	b2db      	uxtb	r3, r3
 800359a:	2b00      	cmp	r3, #0
 800359c:	d002      	beq.n	80035a4 <__sch_ready_behind+0x34>
 800359e:	480a      	ldr	r0, [pc, #40]	@ (80035c8 <__sch_ready_behind+0x58>)
 80035a0:	f7ff f9c6 	bl	8002930 <chSysHalt>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80035a4:	9b01      	ldr	r3, [sp, #4]
 80035a6:	2200      	movs	r2, #0
 80035a8:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80035ac:	9b01      	ldr	r3, [sp, #4]
 80035ae:	699b      	ldr	r3, [r3, #24]
 80035b0:	461a      	mov	r2, r3
 80035b2:	9b01      	ldr	r3, [sp, #4]
 80035b4:	4619      	mov	r1, r3
 80035b6:	4610      	mov	r0, r2
 80035b8:	f7ff ff4a 	bl	8003450 <ch_pqueue_insert_behind>
 80035bc:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
 80035be:	4618      	mov	r0, r3
 80035c0:	b003      	add	sp, #12
 80035c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80035c6:	bf00      	nop
 80035c8:	08005678 	.word	0x08005678
 80035cc:	00000000 	.word	0x00000000

080035d0 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 80035d0:	b500      	push	{lr}
 80035d2:	b083      	sub	sp, #12
 80035d4:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 80035d6:	9b01      	ldr	r3, [sp, #4]
 80035d8:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 80035dc:	2b00      	cmp	r3, #0
 80035de:	bf0c      	ite	eq
 80035e0:	2301      	moveq	r3, #1
 80035e2:	2300      	movne	r3, #0
 80035e4:	b2db      	uxtb	r3, r3
 80035e6:	2b00      	cmp	r3, #0
 80035e8:	d109      	bne.n	80035fe <__sch_ready_ahead+0x2e>
 80035ea:	9b01      	ldr	r3, [sp, #4]
 80035ec:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 80035f0:	2b0f      	cmp	r3, #15
 80035f2:	bf0c      	ite	eq
 80035f4:	2301      	moveq	r3, #1
 80035f6:	2300      	movne	r3, #0
 80035f8:	b2db      	uxtb	r3, r3
 80035fa:	2b00      	cmp	r3, #0
 80035fc:	d002      	beq.n	8003604 <__sch_ready_ahead+0x34>
 80035fe:	480a      	ldr	r0, [pc, #40]	@ (8003628 <__sch_ready_ahead+0x58>)
 8003600:	f7ff f996 	bl	8002930 <chSysHalt>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003604:	9b01      	ldr	r3, [sp, #4]
 8003606:	2200      	movs	r2, #0
 8003608:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 800360c:	9b01      	ldr	r3, [sp, #4]
 800360e:	699b      	ldr	r3, [r3, #24]
 8003610:	461a      	mov	r2, r3
 8003612:	9b01      	ldr	r3, [sp, #4]
 8003614:	4619      	mov	r1, r3
 8003616:	4610      	mov	r0, r2
 8003618:	f7ff ff42 	bl	80034a0 <ch_pqueue_insert_ahead>
 800361c:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
 800361e:	4618      	mov	r0, r3
 8003620:	b003      	add	sp, #12
 8003622:	f85d fb04 	ldr.w	pc, [sp], #4
 8003626:	bf00      	nop
 8003628:	0800568c 	.word	0x0800568c
 800362c:	00000000 	.word	0x00000000

08003630 <__sch_reschedule_ahead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_ahead(void) {
 8003630:	b500      	push	{lr}
 8003632:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8003634:	4b0e      	ldr	r3, [pc, #56]	@ (8003670 <__sch_reschedule_ahead+0x40>)
 8003636:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 8003638:	9b03      	ldr	r3, [sp, #12]
 800363a:	68db      	ldr	r3, [r3, #12]
 800363c:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800363e:	9b03      	ldr	r3, [sp, #12]
 8003640:	4618      	mov	r0, r3
 8003642:	f7ff feed 	bl	8003420 <ch_pqueue_remove_highest>
 8003646:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 8003648:	9b01      	ldr	r3, [sp, #4]
 800364a:	2201      	movs	r2, #1
 800364c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8003650:	9b03      	ldr	r3, [sp, #12]
 8003652:	9a01      	ldr	r2, [sp, #4]
 8003654:	60da      	str	r2, [r3, #12]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = __sch_ready_ahead(otp);
 8003656:	9802      	ldr	r0, [sp, #8]
 8003658:	f7ff ffba 	bl	80035d0 <__sch_ready_ahead>
 800365c:	9002      	str	r0, [sp, #8]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800365e:	9902      	ldr	r1, [sp, #8]
 8003660:	9801      	ldr	r0, [sp, #4]
 8003662:	f7fc fe2d 	bl	80002c0 <__port_switch>
}
 8003666:	bf00      	nop
 8003668:	b005      	add	sp, #20
 800366a:	f85d fb04 	ldr.w	pc, [sp], #4
 800366e:	bf00      	nop
 8003670:	20000988 	.word	0x20000988
	...

08003680 <__sch_wakeup>:

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8003680:	b500      	push	{lr}
 8003682:	b085      	sub	sp, #20
 8003684:	9001      	str	r0, [sp, #4]
 8003686:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 8003688:	9b00      	ldr	r3, [sp, #0]
 800368a:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 800368c:	f7ff ff30 	bl	80034f0 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
 8003690:	9b03      	ldr	r3, [sp, #12]
 8003692:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003696:	2b0c      	cmp	r3, #12
 8003698:	d82e      	bhi.n	80036f8 <__sch_wakeup+0x78>
 800369a:	a201      	add	r2, pc, #4	@ (adr r2, 80036a0 <__sch_wakeup+0x20>)
 800369c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80036a0:	080036d5 	.word	0x080036d5
 80036a4:	080036f9 	.word	0x080036f9
 80036a8:	080036f9 	.word	0x080036f9
 80036ac:	080036db 	.word	0x080036db
 80036b0:	080036ef 	.word	0x080036ef
 80036b4:	080036e5 	.word	0x080036e5
 80036b8:	080036f9 	.word	0x080036f9
 80036bc:	080036ef 	.word	0x080036ef
 80036c0:	080036f9 	.word	0x080036f9
 80036c4:	080036f9 	.word	0x080036f9
 80036c8:	080036f9 	.word	0x080036f9
 80036cc:	080036f9 	.word	0x080036f9
 80036d0:	080036ef 	.word	0x080036ef
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 80036d4:	f7ff ff1c 	bl	8003510 <chSysUnlockFromISR.lto_priv.4>
    return;
 80036d8:	e019      	b.n	800370e <__sch_wakeup+0x8e>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80036da:	9b03      	ldr	r3, [sp, #12]
 80036dc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80036de:	2200      	movs	r2, #0
 80036e0:	601a      	str	r2, [r3, #0]
    break;
 80036e2:	e00a      	b.n	80036fa <__sch_wakeup+0x7a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80036e4:	9b03      	ldr	r3, [sp, #12]
 80036e6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80036e8:	4618      	mov	r0, r3
 80036ea:	f7ff ff31 	bl	8003550 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 80036ee:	9b03      	ldr	r3, [sp, #12]
 80036f0:	4618      	mov	r0, r3
 80036f2:	f7ff fe85 	bl	8003400 <ch_queue_dequeue.lto_priv.0>
    break;
 80036f6:	e000      	b.n	80036fa <__sch_wakeup+0x7a>
  default:
    /* Any other state, nothing to do.*/
    break;
 80036f8:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 80036fa:	9b03      	ldr	r3, [sp, #12]
 80036fc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003700:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 8003702:	9803      	ldr	r0, [sp, #12]
 8003704:	f7ff ff34 	bl	8003570 <__sch_ready_behind>
  chSysUnlockFromISR();
 8003708:	f7ff ff02 	bl	8003510 <chSysUnlockFromISR.lto_priv.4>

  return;
 800370c:	bf00      	nop
}
 800370e:	b005      	add	sp, #20
 8003710:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003720 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003720:	b500      	push	{lr}
 8003722:	b083      	sub	sp, #12
 8003724:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003726:	f7ff faa3 	bl	8002c70 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800372a:	9b01      	ldr	r3, [sp, #4]
 800372c:	2b00      	cmp	r3, #0
 800372e:	bf0c      	ite	eq
 8003730:	2301      	moveq	r3, #1
 8003732:	2300      	movne	r3, #0
 8003734:	b2db      	uxtb	r3, r3
 8003736:	2b00      	cmp	r3, #0
 8003738:	d002      	beq.n	8003740 <chSchReadyI+0x20>
 800373a:	4805      	ldr	r0, [pc, #20]	@ (8003750 <chSchReadyI+0x30>)
 800373c:	f7ff f8f8 	bl	8002930 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 8003740:	9801      	ldr	r0, [sp, #4]
 8003742:	f7ff ff15 	bl	8003570 <__sch_ready_behind>
 8003746:	4603      	mov	r3, r0
}
 8003748:	4618      	mov	r0, r3
 800374a:	b003      	add	sp, #12
 800374c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003750:	080056a0 	.word	0x080056a0
	...

08003760 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003760:	b500      	push	{lr}
 8003762:	b087      	sub	sp, #28
 8003764:	4603      	mov	r3, r0
 8003766:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
 800376a:	4b1d      	ldr	r3, [pc, #116]	@ (80037e0 <chSchGoSleepS+0x80>)
 800376c:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 800376e:	9b05      	ldr	r3, [sp, #20]
 8003770:	68db      	ldr	r3, [r3, #12]
 8003772:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  chDbgCheckClassS();
 8003774:	f7ff fa9c 	bl	8002cb0 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 8003778:	f7ff f8f2 	bl	8002960 <chSysGetIdleThreadX>
 800377c:	4602      	mov	r2, r0
 800377e:	9b04      	ldr	r3, [sp, #16]
 8003780:	4293      	cmp	r3, r2
 8003782:	bf0c      	ite	eq
 8003784:	2301      	moveq	r3, #1
 8003786:	2300      	movne	r3, #0
 8003788:	b2db      	uxtb	r3, r3
 800378a:	2b00      	cmp	r3, #0
 800378c:	d002      	beq.n	8003794 <chSchGoSleepS+0x34>
 800378e:	4815      	ldr	r0, [pc, #84]	@ (80037e4 <chSchGoSleepS+0x84>)
 8003790:	f7ff f8ce 	bl	8002930 <chSysHalt>
  chDbgAssert(otp->owner == oip, "invalid core");
 8003794:	9b04      	ldr	r3, [sp, #16]
 8003796:	699b      	ldr	r3, [r3, #24]
 8003798:	9a05      	ldr	r2, [sp, #20]
 800379a:	429a      	cmp	r2, r3
 800379c:	bf14      	ite	ne
 800379e:	2301      	movne	r3, #1
 80037a0:	2300      	moveq	r3, #0
 80037a2:	b2db      	uxtb	r3, r3
 80037a4:	2b00      	cmp	r3, #0
 80037a6:	d002      	beq.n	80037ae <chSchGoSleepS+0x4e>
 80037a8:	480e      	ldr	r0, [pc, #56]	@ (80037e4 <chSchGoSleepS+0x84>)
 80037aa:	f7ff f8c1 	bl	8002930 <chSysHalt>

  /* New state.*/
  otp->state = newstate;
 80037ae:	9b04      	ldr	r3, [sp, #16]
 80037b0:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80037b4:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 80037b8:	9b05      	ldr	r3, [sp, #20]
 80037ba:	4618      	mov	r0, r3
 80037bc:	f7ff fe30 	bl	8003420 <ch_pqueue_remove_highest>
 80037c0:	9003      	str	r0, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 80037c2:	9b03      	ldr	r3, [sp, #12]
 80037c4:	2201      	movs	r2, #1
 80037c6:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 80037ca:	9b05      	ldr	r3, [sp, #20]
 80037cc:	9a03      	ldr	r2, [sp, #12]
 80037ce:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80037d0:	9904      	ldr	r1, [sp, #16]
 80037d2:	9803      	ldr	r0, [sp, #12]
 80037d4:	f7fc fd74 	bl	80002c0 <__port_switch>
}
 80037d8:	bf00      	nop
 80037da:	b007      	add	sp, #28
 80037dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80037e0:	20000988 	.word	0x20000988
 80037e4:	080056ac 	.word	0x080056ac
	...

080037f0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80037f0:	b500      	push	{lr}
 80037f2:	b08b      	sub	sp, #44	@ 0x2c
 80037f4:	4603      	mov	r3, r0
 80037f6:	9100      	str	r1, [sp, #0]
 80037f8:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 80037fc:	4b15      	ldr	r3, [pc, #84]	@ (8003854 <chSchGoSleepTimeoutS+0x64>)
 80037fe:	68db      	ldr	r3, [r3, #12]
 8003800:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();
 8003802:	f7ff fa55 	bl	8002cb0 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 8003806:	9b00      	ldr	r3, [sp, #0]
 8003808:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 800380c:	d016      	beq.n	800383c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 800380e:	a803      	add	r0, sp, #12
 8003810:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003812:	4a11      	ldr	r2, [pc, #68]	@ (8003858 <chSchGoSleepTimeoutS+0x68>)
 8003814:	9900      	ldr	r1, [sp, #0]
 8003816:	f7ff fc8b 	bl	8003130 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800381a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800381e:	4618      	mov	r0, r3
 8003820:	f7ff ff9e 	bl	8003760 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8003824:	ab03      	add	r3, sp, #12
 8003826:	4618      	mov	r0, r3
 8003828:	f7ff fe82 	bl	8003530 <chVTIsArmedI.lto_priv.1>
 800382c:	4603      	mov	r3, r0
 800382e:	2b00      	cmp	r3, #0
 8003830:	d009      	beq.n	8003846 <chSchGoSleepTimeoutS+0x56>
      chVTDoResetI(&vt);
 8003832:	ab03      	add	r3, sp, #12
 8003834:	4618      	mov	r0, r3
 8003836:	f7ff fcbb 	bl	80031b0 <chVTDoResetI>
 800383a:	e004      	b.n	8003846 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
 800383c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003840:	4618      	mov	r0, r3
 8003842:	f7ff ff8d 	bl	8003760 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 8003846:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003848:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
}
 800384a:	4618      	mov	r0, r3
 800384c:	b00b      	add	sp, #44	@ 0x2c
 800384e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003852:	bf00      	nop
 8003854:	20000988 	.word	0x20000988
 8003858:	08003681 	.word	0x08003681
 800385c:	00000000 	.word	0x00000000

08003860 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003860:	b500      	push	{lr}
 8003862:	b085      	sub	sp, #20
 8003864:	9001      	str	r0, [sp, #4]
 8003866:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8003868:	4b22      	ldr	r3, [pc, #136]	@ (80038f4 <chSchWakeupS+0x94>)
 800386a:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 800386c:	9b03      	ldr	r3, [sp, #12]
 800386e:	68db      	ldr	r3, [r3, #12]
 8003870:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 8003872:	f7ff fa1d 	bl	8002cb0 <chDbgCheckClassS>

  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8003876:	9b03      	ldr	r3, [sp, #12]
 8003878:	681a      	ldr	r2, [r3, #0]
 800387a:	9b03      	ldr	r3, [sp, #12]
 800387c:	429a      	cmp	r2, r3
 800387e:	bf14      	ite	ne
 8003880:	2301      	movne	r3, #1
 8003882:	2300      	moveq	r3, #0
 8003884:	b2db      	uxtb	r3, r3
 8003886:	2b00      	cmp	r3, #0
 8003888:	d00f      	beq.n	80038aa <chSchWakeupS+0x4a>
 800388a:	9b03      	ldr	r3, [sp, #12]
 800388c:	68db      	ldr	r3, [r3, #12]
 800388e:	689a      	ldr	r2, [r3, #8]
 8003890:	9b03      	ldr	r3, [sp, #12]
 8003892:	681b      	ldr	r3, [r3, #0]
 8003894:	689b      	ldr	r3, [r3, #8]
 8003896:	429a      	cmp	r2, r3
 8003898:	bf34      	ite	cc
 800389a:	2301      	movcc	r3, #1
 800389c:	2300      	movcs	r3, #0
 800389e:	b2db      	uxtb	r3, r3
 80038a0:	2b00      	cmp	r3, #0
 80038a2:	d002      	beq.n	80038aa <chSchWakeupS+0x4a>
 80038a4:	4814      	ldr	r0, [pc, #80]	@ (80038f8 <chSchWakeupS+0x98>)
 80038a6:	f7ff f843 	bl	8002930 <chSysHalt>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80038aa:	9b01      	ldr	r3, [sp, #4]
 80038ac:	9a00      	ldr	r2, [sp, #0]
 80038ae:	629a      	str	r2, [r3, #40]	@ 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 80038b0:	9b01      	ldr	r3, [sp, #4]
 80038b2:	689a      	ldr	r2, [r3, #8]
 80038b4:	9b02      	ldr	r3, [sp, #8]
 80038b6:	689b      	ldr	r3, [r3, #8]
 80038b8:	429a      	cmp	r2, r3
 80038ba:	bf94      	ite	ls
 80038bc:	2301      	movls	r3, #1
 80038be:	2300      	movhi	r3, #0
 80038c0:	b2db      	uxtb	r3, r3
 80038c2:	2b00      	cmp	r3, #0
 80038c4:	d003      	beq.n	80038ce <chSchWakeupS+0x6e>
    (void) __sch_ready_behind(ntp);
 80038c6:	9801      	ldr	r0, [sp, #4]
 80038c8:	f7ff fe52 	bl	8003570 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 80038cc:	e00e      	b.n	80038ec <chSchWakeupS+0x8c>
    otp = __sch_ready_ahead(otp);
 80038ce:	9802      	ldr	r0, [sp, #8]
 80038d0:	f7ff fe7e 	bl	80035d0 <__sch_ready_ahead>
 80038d4:	9002      	str	r0, [sp, #8]
    ntp->state = CH_STATE_CURRENT;
 80038d6:	9b01      	ldr	r3, [sp, #4]
 80038d8:	2201      	movs	r2, #1
 80038da:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    __instance_set_currthread(oip, ntp);
 80038de:	9b03      	ldr	r3, [sp, #12]
 80038e0:	9a01      	ldr	r2, [sp, #4]
 80038e2:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 80038e4:	9902      	ldr	r1, [sp, #8]
 80038e6:	9801      	ldr	r0, [sp, #4]
 80038e8:	f7fc fcea 	bl	80002c0 <__port_switch>
}
 80038ec:	bf00      	nop
 80038ee:	b005      	add	sp, #20
 80038f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80038f4:	20000988 	.word	0x20000988
 80038f8:	080056bc 	.word	0x080056bc
 80038fc:	00000000 	.word	0x00000000

08003900 <chSchRescheduleS>:
 * @note    Only local threads are considered, other cores are signaled
 *          and perform a reschedule locally.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8003900:	b500      	push	{lr}
 8003902:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003904:	4b0c      	ldr	r3, [pc, #48]	@ (8003938 <chSchRescheduleS+0x38>)
 8003906:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
 8003908:	9b01      	ldr	r3, [sp, #4]
 800390a:	68db      	ldr	r3, [r3, #12]
 800390c:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();
 800390e:	f7ff f9cf 	bl	8002cb0 <chDbgCheckClassS>

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 8003912:	9b01      	ldr	r3, [sp, #4]
 8003914:	681b      	ldr	r3, [r3, #0]
 8003916:	689a      	ldr	r2, [r3, #8]
 8003918:	9b00      	ldr	r3, [sp, #0]
 800391a:	689b      	ldr	r3, [r3, #8]
 800391c:	429a      	cmp	r2, r3
 800391e:	bf8c      	ite	hi
 8003920:	2301      	movhi	r3, #1
 8003922:	2300      	movls	r3, #0
 8003924:	b2db      	uxtb	r3, r3
 8003926:	2b00      	cmp	r3, #0
 8003928:	d001      	beq.n	800392e <chSchRescheduleS+0x2e>
    __sch_reschedule_ahead();
 800392a:	f7ff fe81 	bl	8003630 <__sch_reschedule_ahead>
  }
}
 800392e:	bf00      	nop
 8003930:	b003      	add	sp, #12
 8003932:	f85d fb04 	ldr.w	pc, [sp], #4
 8003936:	bf00      	nop
 8003938:	20000988 	.word	0x20000988
 800393c:	00000000 	.word	0x00000000

08003940 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8003940:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 8003942:	4b0b      	ldr	r3, [pc, #44]	@ (8003970 <chSchIsPreemptionRequired+0x30>)
 8003944:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 8003946:	9b03      	ldr	r3, [sp, #12]
 8003948:	68db      	ldr	r3, [r3, #12]
 800394a:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 800394c:	9b03      	ldr	r3, [sp, #12]
 800394e:	681b      	ldr	r3, [r3, #0]
 8003950:	689b      	ldr	r3, [r3, #8]
 8003952:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8003954:	9b02      	ldr	r3, [sp, #8]
 8003956:	689b      	ldr	r3, [r3, #8]
 8003958:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800395a:	9a01      	ldr	r2, [sp, #4]
 800395c:	9b00      	ldr	r3, [sp, #0]
 800395e:	429a      	cmp	r2, r3
 8003960:	bf8c      	ite	hi
 8003962:	2301      	movhi	r3, #1
 8003964:	2300      	movls	r3, #0
 8003966:	b2db      	uxtb	r3, r3
#endif
}
 8003968:	4618      	mov	r0, r3
 800396a:	b004      	add	sp, #16
 800396c:	4770      	bx	lr
 800396e:	bf00      	nop
 8003970:	20000988 	.word	0x20000988
	...

08003980 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8003980:	b500      	push	{lr}
 8003982:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8003984:	4b0e      	ldr	r3, [pc, #56]	@ (80039c0 <chSchDoPreemption+0x40>)
 8003986:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 8003988:	9b03      	ldr	r3, [sp, #12]
 800398a:	68db      	ldr	r3, [r3, #12]
 800398c:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800398e:	9b03      	ldr	r3, [sp, #12]
 8003990:	4618      	mov	r0, r3
 8003992:	f7ff fd45 	bl	8003420 <ch_pqueue_remove_highest>
 8003996:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 8003998:	9b01      	ldr	r3, [sp, #4]
 800399a:	2201      	movs	r2, #1
 800399c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 80039a0:	9b03      	ldr	r3, [sp, #12]
 80039a2:	9a01      	ldr	r2, [sp, #4]
 80039a4:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 80039a6:	9802      	ldr	r0, [sp, #8]
 80039a8:	f7ff fe12 	bl	80035d0 <__sch_ready_ahead>
 80039ac:	9002      	str	r0, [sp, #8]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80039ae:	9902      	ldr	r1, [sp, #8]
 80039b0:	9801      	ldr	r0, [sp, #4]
 80039b2:	f7fc fc85 	bl	80002c0 <__port_switch>
}
 80039b6:	bf00      	nop
 80039b8:	b005      	add	sp, #20
 80039ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80039be:	bf00      	nop
 80039c0:	20000988 	.word	0x20000988
	...

080039d0 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 80039d0:	b082      	sub	sp, #8
 80039d2:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 80039d4:	9b01      	ldr	r3, [sp, #4]
 80039d6:	2200      	movs	r2, #0
 80039d8:	601a      	str	r2, [r3, #0]
}
 80039da:	bf00      	nop
 80039dc:	b002      	add	sp, #8
 80039de:	4770      	bx	lr

080039e0 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 80039e0:	b082      	sub	sp, #8
 80039e2:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 80039e4:	9b01      	ldr	r3, [sp, #4]
 80039e6:	2200      	movs	r2, #0
 80039e8:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 80039ea:	9b01      	ldr	r3, [sp, #4]
 80039ec:	2200      	movs	r2, #0
 80039ee:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 80039f0:	9b01      	ldr	r3, [sp, #4]
 80039f2:	2201      	movs	r2, #1
 80039f4:	609a      	str	r2, [r3, #8]
#endif
}
 80039f6:	bf00      	nop
 80039f8:	b002      	add	sp, #8
 80039fa:	4770      	bx	lr
 80039fc:	0000      	movs	r0, r0
	...

08003a00 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003a00:	b082      	sub	sp, #8
 8003a02:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8003a04:	9b01      	ldr	r3, [sp, #4]
 8003a06:	9a01      	ldr	r2, [sp, #4]
 8003a08:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8003a0a:	9b01      	ldr	r3, [sp, #4]
 8003a0c:	9a01      	ldr	r2, [sp, #4]
 8003a0e:	605a      	str	r2, [r3, #4]
}
 8003a10:	bf00      	nop
 8003a12:	b002      	add	sp, #8
 8003a14:	4770      	bx	lr
 8003a16:	bf00      	nop
	...

08003a20 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 8003a20:	b082      	sub	sp, #8
 8003a22:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 8003a24:	9b01      	ldr	r3, [sp, #4]
 8003a26:	9a01      	ldr	r2, [sp, #4]
 8003a28:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 8003a2a:	9b01      	ldr	r3, [sp, #4]
 8003a2c:	9a01      	ldr	r2, [sp, #4]
 8003a2e:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 8003a30:	9b01      	ldr	r3, [sp, #4]
 8003a32:	2200      	movs	r2, #0
 8003a34:	609a      	str	r2, [r3, #8]
}
 8003a36:	bf00      	nop
 8003a38:	b002      	add	sp, #8
 8003a3a:	4770      	bx	lr
 8003a3c:	0000      	movs	r0, r0
	...

08003a40 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 8003a40:	b082      	sub	sp, #8
 8003a42:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 8003a44:	9b01      	ldr	r3, [sp, #4]
 8003a46:	9a01      	ldr	r2, [sp, #4]
 8003a48:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 8003a4a:	9b01      	ldr	r3, [sp, #4]
 8003a4c:	9a01      	ldr	r2, [sp, #4]
 8003a4e:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 8003a50:	9b01      	ldr	r3, [sp, #4]
 8003a52:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003a56:	609a      	str	r2, [r3, #8]
}
 8003a58:	bf00      	nop
 8003a5a:	b002      	add	sp, #8
 8003a5c:	4770      	bx	lr
 8003a5e:	bf00      	nop

08003a60 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 8003a60:	b508      	push	{r3, lr}
  return stGetCounter();
 8003a62:	f7fc fd0d 	bl	8000480 <stGetCounter>
 8003a66:	4603      	mov	r3, r0
}
 8003a68:	4618      	mov	r0, r3
 8003a6a:	bd08      	pop	{r3, pc}
 8003a6c:	0000      	movs	r0, r0
	...

08003a70 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003a70:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8003a72:	f7ff fff5 	bl	8003a60 <port_timer_get_time.lto_priv.1>
 8003a76:	4603      	mov	r3, r0
}
 8003a78:	4618      	mov	r0, r3
 8003a7a:	bd08      	pop	{r3, pc}
 8003a7c:	0000      	movs	r0, r0
	...

08003a80 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 8003a80:	b530      	push	{r4, r5, lr}
 8003a82:	b083      	sub	sp, #12
 8003a84:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 8003a86:	9b01      	ldr	r3, [sp, #4]
 8003a88:	4618      	mov	r0, r3
 8003a8a:	f7ff ffd9 	bl	8003a40 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 8003a8e:	9b01      	ldr	r3, [sp, #4]
 8003a90:	2200      	movs	r2, #0
 8003a92:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003a94:	f7ff ffec 	bl	8003a70 <chVTGetSystemTimeX.lto_priv.1>
 8003a98:	4603      	mov	r3, r0
 8003a9a:	2200      	movs	r2, #0
 8003a9c:	461c      	mov	r4, r3
 8003a9e:	4615      	mov	r5, r2
 8003aa0:	9b01      	ldr	r3, [sp, #4]
 8003aa2:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 8003aa6:	bf00      	nop
 8003aa8:	b003      	add	sp, #12
 8003aaa:	bd30      	pop	{r4, r5, pc}
 8003aac:	0000      	movs	r0, r0
	...

08003ab0 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8003ab0:	b500      	push	{lr}
 8003ab2:	b083      	sub	sp, #12
 8003ab4:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 8003ab6:	9b01      	ldr	r3, [sp, #4]
 8003ab8:	4618      	mov	r0, r3
 8003aba:	f7ff ffa1 	bl	8003a00 <ch_queue_init.lto_priv.2>
}
 8003abe:	bf00      	nop
 8003ac0:	b003      	add	sp, #12
 8003ac2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ac6:	bf00      	nop
	...

08003ad0 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8003ad0:	b082      	sub	sp, #8
 8003ad2:	9001      	str	r0, [sp, #4]
}
 8003ad4:	bf00      	nop
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
    asm volatile ("nop");
 8003ad6:	bf00      	nop
    port_wait_for_interrupt();
 8003ad8:	bf00      	nop
 8003ada:	e7fb      	b.n	8003ad4 <__idle_thread+0x4>
 8003adc:	0000      	movs	r0, r0
	...

08003ae0 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8003ae0:	b500      	push	{lr}
 8003ae2:	b08b      	sub	sp, #44	@ 0x2c
 8003ae4:	9001      	str	r0, [sp, #4]
 8003ae6:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 8003ae8:	2300      	movs	r3, #0
 8003aea:	9309      	str	r3, [sp, #36]	@ 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 8003aec:	4a30      	ldr	r2, [pc, #192]	@ (8003bb0 <chInstanceObjectInit+0xd0>)
 8003aee:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003af0:	009b      	lsls	r3, r3, #2
 8003af2:	4413      	add	r3, r2
 8003af4:	685b      	ldr	r3, [r3, #4]
 8003af6:	2b00      	cmp	r3, #0
 8003af8:	bf14      	ite	ne
 8003afa:	2301      	movne	r3, #1
 8003afc:	2300      	moveq	r3, #0
 8003afe:	b2db      	uxtb	r3, r3
 8003b00:	2b00      	cmp	r3, #0
 8003b02:	d002      	beq.n	8003b0a <chInstanceObjectInit+0x2a>
 8003b04:	482b      	ldr	r0, [pc, #172]	@ (8003bb4 <chInstanceObjectInit+0xd4>)
 8003b06:	f7fe ff13 	bl	8002930 <chSysHalt>
  ch_system.instances[core_id] = oip;
 8003b0a:	4a29      	ldr	r2, [pc, #164]	@ (8003bb0 <chInstanceObjectInit+0xd0>)
 8003b0c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003b0e:	009b      	lsls	r3, r3, #2
 8003b10:	4413      	add	r3, r2
 8003b12:	9a01      	ldr	r2, [sp, #4]
 8003b14:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 8003b16:	9b01      	ldr	r3, [sp, #4]
 8003b18:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8003b1a:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 8003b1c:	9b01      	ldr	r3, [sp, #4]
 8003b1e:	9a00      	ldr	r2, [sp, #0]
 8003b20:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 8003b22:	9801      	ldr	r0, [sp, #4]
 8003b24:	f001 fa3c 	bl	8004fa0 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 8003b28:	9b01      	ldr	r3, [sp, #4]
 8003b2a:	4618      	mov	r0, r3
 8003b2c:	f7ff ff78 	bl	8003a20 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 8003b30:	9b01      	ldr	r3, [sp, #4]
 8003b32:	3328      	adds	r3, #40	@ 0x28
 8003b34:	4618      	mov	r0, r3
 8003b36:	f7ff ffbb 	bl	8003ab0 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 8003b3a:	9b01      	ldr	r3, [sp, #4]
 8003b3c:	3334      	adds	r3, #52	@ 0x34
 8003b3e:	4618      	mov	r0, r3
 8003b40:	f7ff ff46 	bl	80039d0 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8003b44:	9b01      	ldr	r3, [sp, #4]
 8003b46:	3310      	adds	r3, #16
 8003b48:	4618      	mov	r0, r3
 8003b4a:	f7ff ff99 	bl	8003a80 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 8003b4e:	9b01      	ldr	r3, [sp, #4]
 8003b50:	3384      	adds	r3, #132	@ 0x84
 8003b52:	4618      	mov	r0, r3
 8003b54:	f7ff ff44 	bl	80039e0 <__dbg_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8003b58:	9b01      	ldr	r3, [sp, #4]
 8003b5a:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 8003b5e:	2380      	movs	r3, #128	@ 0x80
 8003b60:	4a15      	ldr	r2, [pc, #84]	@ (8003bb8 <chInstanceObjectInit+0xd8>)
 8003b62:	9801      	ldr	r0, [sp, #4]
 8003b64:	f000 f8fc 	bl	8003d60 <__thd_object_init>
 8003b68:	4602      	mov	r2, r0
 8003b6a:	9b01      	ldr	r3, [sp, #4]
 8003b6c:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 8003b6e:	9b01      	ldr	r3, [sp, #4]
 8003b70:	68db      	ldr	r3, [r3, #12]
 8003b72:	9a00      	ldr	r2, [sp, #0]
 8003b74:	6852      	ldr	r2, [r2, #4]
 8003b76:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8003b78:	9b01      	ldr	r3, [sp, #4]
 8003b7a:	68db      	ldr	r3, [r3, #12]
 8003b7c:	2201      	movs	r2, #1
 8003b7e:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 8003b82:	4b0e      	ldr	r3, [pc, #56]	@ (8003bbc <chInstanceObjectInit+0xdc>)
 8003b84:	9303      	str	r3, [sp, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8003b86:	9b00      	ldr	r3, [sp, #0]
 8003b88:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 8003b8a:	9304      	str	r3, [sp, #16]
      .wend     = oicp->idlethread_end,
 8003b8c:	9b00      	ldr	r3, [sp, #0]
 8003b8e:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 8003b90:	9305      	str	r3, [sp, #20]
 8003b92:	2301      	movs	r3, #1
 8003b94:	9306      	str	r3, [sp, #24]
 8003b96:	4b0a      	ldr	r3, [pc, #40]	@ (8003bc0 <chInstanceObjectInit+0xe0>)
 8003b98:	9307      	str	r3, [sp, #28]
 8003b9a:	2300      	movs	r3, #0
 8003b9c:	9308      	str	r3, [sp, #32]
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 8003b9e:	ab03      	add	r3, sp, #12
 8003ba0:	4618      	mov	r0, r3
 8003ba2:	f000 f9ad 	bl	8003f00 <chThdCreateI>
  }
#endif
}
 8003ba6:	bf00      	nop
 8003ba8:	b00b      	add	sp, #44	@ 0x2c
 8003baa:	f85d fb04 	ldr.w	pc, [sp], #4
 8003bae:	bf00      	nop
 8003bb0:	2000097c 	.word	0x2000097c
 8003bb4:	080056cc 	.word	0x080056cc
 8003bb8:	0800577c 	.word	0x0800577c
 8003bbc:	080055e8 	.word	0x080055e8
 8003bc0:	08003ad1 	.word	0x08003ad1
	...

08003bd0 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 8003bd0:	b082      	sub	sp, #8
 8003bd2:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 8003bd4:	9b01      	ldr	r3, [sp, #4]
 8003bd6:	9a01      	ldr	r2, [sp, #4]
 8003bd8:	601a      	str	r2, [r3, #0]
}
 8003bda:	bf00      	nop
 8003bdc:	b002      	add	sp, #8
 8003bde:	4770      	bx	lr

08003be0 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 8003be0:	b082      	sub	sp, #8
 8003be2:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 8003be4:	9b01      	ldr	r3, [sp, #4]
 8003be6:	681b      	ldr	r3, [r3, #0]
 8003be8:	9a01      	ldr	r2, [sp, #4]
 8003bea:	429a      	cmp	r2, r3
 8003bec:	bf14      	ite	ne
 8003bee:	2301      	movne	r3, #1
 8003bf0:	2300      	moveq	r3, #0
 8003bf2:	b2db      	uxtb	r3, r3
}
 8003bf4:	4618      	mov	r0, r3
 8003bf6:	b002      	add	sp, #8
 8003bf8:	4770      	bx	lr
 8003bfa:	bf00      	nop
 8003bfc:	0000      	movs	r0, r0
	...

08003c00 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 8003c00:	b084      	sub	sp, #16
 8003c02:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 8003c04:	9b01      	ldr	r3, [sp, #4]
 8003c06:	681b      	ldr	r3, [r3, #0]
 8003c08:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 8003c0a:	9b03      	ldr	r3, [sp, #12]
 8003c0c:	681a      	ldr	r2, [r3, #0]
 8003c0e:	9b01      	ldr	r3, [sp, #4]
 8003c10:	601a      	str	r2, [r3, #0]
  return p;
 8003c12:	9b03      	ldr	r3, [sp, #12]
}
 8003c14:	4618      	mov	r0, r3
 8003c16:	b004      	add	sp, #16
 8003c18:	4770      	bx	lr
 8003c1a:	bf00      	nop
 8003c1c:	0000      	movs	r0, r0
	...

08003c20 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003c20:	b082      	sub	sp, #8
 8003c22:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8003c24:	9b01      	ldr	r3, [sp, #4]
 8003c26:	9a01      	ldr	r2, [sp, #4]
 8003c28:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8003c2a:	9b01      	ldr	r3, [sp, #4]
 8003c2c:	9a01      	ldr	r2, [sp, #4]
 8003c2e:	605a      	str	r2, [r3, #4]
}
 8003c30:	bf00      	nop
 8003c32:	b002      	add	sp, #8
 8003c34:	4770      	bx	lr
 8003c36:	bf00      	nop
	...

08003c40 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8003c40:	b082      	sub	sp, #8
 8003c42:	9001      	str	r0, [sp, #4]
 8003c44:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 8003c46:	9b00      	ldr	r3, [sp, #0]
 8003c48:	9a01      	ldr	r2, [sp, #4]
 8003c4a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 8003c4c:	9b01      	ldr	r3, [sp, #4]
 8003c4e:	685a      	ldr	r2, [r3, #4]
 8003c50:	9b00      	ldr	r3, [sp, #0]
 8003c52:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003c54:	9b00      	ldr	r3, [sp, #0]
 8003c56:	685b      	ldr	r3, [r3, #4]
 8003c58:	9a00      	ldr	r2, [sp, #0]
 8003c5a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 8003c5c:	9b01      	ldr	r3, [sp, #4]
 8003c5e:	9a00      	ldr	r2, [sp, #0]
 8003c60:	605a      	str	r2, [r3, #4]
}
 8003c62:	bf00      	nop
 8003c64:	b002      	add	sp, #8
 8003c66:	4770      	bx	lr
	...

08003c70 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003c70:	b082      	sub	sp, #8
 8003c72:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003c74:	9b01      	ldr	r3, [sp, #4]
 8003c76:	685b      	ldr	r3, [r3, #4]
 8003c78:	9a01      	ldr	r2, [sp, #4]
 8003c7a:	6812      	ldr	r2, [r2, #0]
 8003c7c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8003c7e:	9b01      	ldr	r3, [sp, #4]
 8003c80:	681b      	ldr	r3, [r3, #0]
 8003c82:	9a01      	ldr	r2, [sp, #4]
 8003c84:	6852      	ldr	r2, [r2, #4]
 8003c86:	605a      	str	r2, [r3, #4]
  return p;
 8003c88:	9b01      	ldr	r3, [sp, #4]
}
 8003c8a:	4618      	mov	r0, r3
 8003c8c:	b002      	add	sp, #8
 8003c8e:	4770      	bx	lr

08003c90 <chSysLock.lto_priv.6>:
static inline void chSysLock(void) {
 8003c90:	b500      	push	{lr}
 8003c92:	b083      	sub	sp, #12
 8003c94:	2330      	movs	r3, #48	@ 0x30
 8003c96:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003c98:	9b01      	ldr	r3, [sp, #4]
 8003c9a:	f383 8811 	msr	BASEPRI, r3
}
 8003c9e:	bf00      	nop
}
 8003ca0:	bf00      	nop
  __dbg_check_lock();
 8003ca2:	f7fe fecd 	bl	8002a40 <__dbg_check_lock>
}
 8003ca6:	bf00      	nop
 8003ca8:	b003      	add	sp, #12
 8003caa:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cae:	bf00      	nop

08003cb0 <chSysUnlock.lto_priv.6>:
static inline void chSysUnlock(void) {
 8003cb0:	b500      	push	{lr}
 8003cb2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8003cb4:	f7fe feec 	bl	8002a90 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003cb8:	4b12      	ldr	r3, [pc, #72]	@ (8003d04 <chSysUnlock.lto_priv.6+0x54>)
 8003cba:	681b      	ldr	r3, [r3, #0]
 8003cbc:	4a11      	ldr	r2, [pc, #68]	@ (8003d04 <chSysUnlock.lto_priv.6+0x54>)
 8003cbe:	4293      	cmp	r3, r2
 8003cc0:	bf14      	ite	ne
 8003cc2:	2301      	movne	r3, #1
 8003cc4:	2300      	moveq	r3, #0
 8003cc6:	b2db      	uxtb	r3, r3
 8003cc8:	2b00      	cmp	r3, #0
 8003cca:	d00f      	beq.n	8003cec <chSysUnlock.lto_priv.6+0x3c>
 8003ccc:	4b0d      	ldr	r3, [pc, #52]	@ (8003d04 <chSysUnlock.lto_priv.6+0x54>)
 8003cce:	68db      	ldr	r3, [r3, #12]
 8003cd0:	689a      	ldr	r2, [r3, #8]
 8003cd2:	4b0c      	ldr	r3, [pc, #48]	@ (8003d04 <chSysUnlock.lto_priv.6+0x54>)
 8003cd4:	681b      	ldr	r3, [r3, #0]
 8003cd6:	689b      	ldr	r3, [r3, #8]
 8003cd8:	429a      	cmp	r2, r3
 8003cda:	bf34      	ite	cc
 8003cdc:	2301      	movcc	r3, #1
 8003cde:	2300      	movcs	r3, #0
 8003ce0:	b2db      	uxtb	r3, r3
 8003ce2:	2b00      	cmp	r3, #0
 8003ce4:	d002      	beq.n	8003cec <chSysUnlock.lto_priv.6+0x3c>
 8003ce6:	4808      	ldr	r0, [pc, #32]	@ (8003d08 <chSysUnlock.lto_priv.6+0x58>)
 8003ce8:	f7fe fe22 	bl	8002930 <chSysHalt>
 8003cec:	2300      	movs	r3, #0
 8003cee:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003cf0:	9b01      	ldr	r3, [sp, #4]
 8003cf2:	f383 8811 	msr	BASEPRI, r3
}
 8003cf6:	bf00      	nop
}
 8003cf8:	bf00      	nop
}
 8003cfa:	bf00      	nop
 8003cfc:	b003      	add	sp, #12
 8003cfe:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d02:	bf00      	nop
 8003d04:	20000988 	.word	0x20000988
 8003d08:	080056fc 	.word	0x080056fc
 8003d0c:	00000000 	.word	0x00000000

08003d10 <chThdGetSelfX.lto_priv.0>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8003d10:	4b01      	ldr	r3, [pc, #4]	@ (8003d18 <chThdGetSelfX.lto_priv.0+0x8>)
 8003d12:	68db      	ldr	r3, [r3, #12]
}
 8003d14:	4618      	mov	r0, r3
 8003d16:	4770      	bx	lr
 8003d18:	20000988 	.word	0x20000988
 8003d1c:	00000000 	.word	0x00000000

08003d20 <chThdGetWorkingAreaX.lto_priv.0>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8003d20:	b082      	sub	sp, #8
 8003d22:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 8003d24:	9b01      	ldr	r3, [sp, #4]
 8003d26:	6a1b      	ldr	r3, [r3, #32]
}
 8003d28:	4618      	mov	r0, r3
 8003d2a:	b002      	add	sp, #8
 8003d2c:	4770      	bx	lr
 8003d2e:	bf00      	nop

08003d30 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 8003d30:	b500      	push	{lr}
 8003d32:	b083      	sub	sp, #12
 8003d34:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8003d36:	9b01      	ldr	r3, [sp, #4]
 8003d38:	2b00      	cmp	r3, #0
 8003d3a:	bf0c      	ite	eq
 8003d3c:	2301      	moveq	r3, #1
 8003d3e:	2300      	movne	r3, #0
 8003d40:	b2db      	uxtb	r3, r3
 8003d42:	2b00      	cmp	r3, #0
 8003d44:	d002      	beq.n	8003d4c <chThdSleepS+0x1c>
 8003d46:	4805      	ldr	r0, [pc, #20]	@ (8003d5c <chThdSleepS+0x2c>)
 8003d48:	f7fe fdf2 	bl	8002930 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8003d4c:	9901      	ldr	r1, [sp, #4]
 8003d4e:	2008      	movs	r0, #8
 8003d50:	f7ff fd4e 	bl	80037f0 <chSchGoSleepTimeoutS>
}
 8003d54:	bf00      	nop
 8003d56:	b003      	add	sp, #12
 8003d58:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d5c:	08005738 	.word	0x08005738

08003d60 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8003d60:	b500      	push	{lr}
 8003d62:	b085      	sub	sp, #20
 8003d64:	9003      	str	r0, [sp, #12]
 8003d66:	9102      	str	r1, [sp, #8]
 8003d68:	9201      	str	r2, [sp, #4]
 8003d6a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 8003d6c:	9b02      	ldr	r3, [sp, #8]
 8003d6e:	9a00      	ldr	r2, [sp, #0]
 8003d70:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8003d72:	9b02      	ldr	r3, [sp, #8]
 8003d74:	2202      	movs	r2, #2
 8003d76:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 8003d7a:	9b02      	ldr	r3, [sp, #8]
 8003d7c:	2200      	movs	r2, #0
 8003d7e:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  tp->owner             = oip;
 8003d82:	9b02      	ldr	r3, [sp, #8]
 8003d84:	9a03      	ldr	r2, [sp, #12]
 8003d86:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8003d88:	9b02      	ldr	r3, [sp, #8]
 8003d8a:	9a00      	ldr	r2, [sp, #0]
 8003d8c:	641a      	str	r2, [r3, #64]	@ 0x40
  tp->mtxlist           = NULL;
 8003d8e:	9b02      	ldr	r3, [sp, #8]
 8003d90:	2200      	movs	r2, #0
 8003d92:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8003d94:	9b02      	ldr	r3, [sp, #8]
 8003d96:	2200      	movs	r2, #0
 8003d98:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 8003d9a:	9b02      	ldr	r3, [sp, #8]
 8003d9c:	2201      	movs	r2, #1
 8003d9e:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
  tp->name              = name;
 8003da2:	9b02      	ldr	r3, [sp, #8]
 8003da4:	9a01      	ldr	r2, [sp, #4]
 8003da6:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 8003da8:	9b03      	ldr	r3, [sp, #12]
 8003daa:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 8003dae:	9b02      	ldr	r3, [sp, #8]
 8003db0:	3310      	adds	r3, #16
 8003db2:	4619      	mov	r1, r3
 8003db4:	4610      	mov	r0, r2
 8003db6:	f7ff ff43 	bl	8003c40 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 8003dba:	9b02      	ldr	r3, [sp, #8]
 8003dbc:	332c      	adds	r3, #44	@ 0x2c
 8003dbe:	4618      	mov	r0, r3
 8003dc0:	f7ff ff06 	bl	8003bd0 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8003dc4:	9b02      	ldr	r3, [sp, #8]
 8003dc6:	3330      	adds	r3, #48	@ 0x30
 8003dc8:	4618      	mov	r0, r3
 8003dca:	f7ff ff29 	bl	8003c20 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8003dce:	9b02      	ldr	r3, [sp, #8]
}
 8003dd0:	4618      	mov	r0, r3
 8003dd2:	b005      	add	sp, #20
 8003dd4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003de0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8003de0:	b500      	push	{lr}
 8003de2:	b085      	sub	sp, #20
 8003de4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8003de6:	f7fe ff43 	bl	8002c70 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8003dea:	9b01      	ldr	r3, [sp, #4]
 8003dec:	2b00      	cmp	r3, #0
 8003dee:	bf0c      	ite	eq
 8003df0:	2301      	moveq	r3, #1
 8003df2:	2300      	movne	r3, #0
 8003df4:	b2db      	uxtb	r3, r3
 8003df6:	2b00      	cmp	r3, #0
 8003df8:	d002      	beq.n	8003e00 <chThdCreateSuspendedI+0x20>
 8003dfa:	483d      	ldr	r0, [pc, #244]	@ (8003ef0 <chThdCreateSuspendedI+0x110>)
 8003dfc:	f7fe fd98 	bl	8002930 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8003e00:	9b01      	ldr	r3, [sp, #4]
 8003e02:	685b      	ldr	r3, [r3, #4]
 8003e04:	f003 0307 	and.w	r3, r3, #7
 8003e08:	2b00      	cmp	r3, #0
 8003e0a:	bf14      	ite	ne
 8003e0c:	2301      	movne	r3, #1
 8003e0e:	2300      	moveq	r3, #0
 8003e10:	b2db      	uxtb	r3, r3
 8003e12:	2b00      	cmp	r3, #0
 8003e14:	d10a      	bne.n	8003e2c <chThdCreateSuspendedI+0x4c>
 8003e16:	9b01      	ldr	r3, [sp, #4]
 8003e18:	689b      	ldr	r3, [r3, #8]
 8003e1a:	f003 0307 	and.w	r3, r3, #7
 8003e1e:	2b00      	cmp	r3, #0
 8003e20:	bf14      	ite	ne
 8003e22:	2301      	movne	r3, #1
 8003e24:	2300      	moveq	r3, #0
 8003e26:	b2db      	uxtb	r3, r3
 8003e28:	2b00      	cmp	r3, #0
 8003e2a:	d001      	beq.n	8003e30 <chThdCreateSuspendedI+0x50>
 8003e2c:	2301      	movs	r3, #1
 8003e2e:	e000      	b.n	8003e32 <chThdCreateSuspendedI+0x52>
 8003e30:	2300      	movs	r3, #0
 8003e32:	2b00      	cmp	r3, #0
 8003e34:	d10a      	bne.n	8003e4c <chThdCreateSuspendedI+0x6c>
 8003e36:	9b01      	ldr	r3, [sp, #4]
 8003e38:	689a      	ldr	r2, [r3, #8]
 8003e3a:	9b01      	ldr	r3, [sp, #4]
 8003e3c:	685b      	ldr	r3, [r3, #4]
 8003e3e:	429a      	cmp	r2, r3
 8003e40:	bf94      	ite	ls
 8003e42:	2301      	movls	r3, #1
 8003e44:	2300      	movhi	r3, #0
 8003e46:	b2db      	uxtb	r3, r3
 8003e48:	2b00      	cmp	r3, #0
 8003e4a:	d001      	beq.n	8003e50 <chThdCreateSuspendedI+0x70>
 8003e4c:	2301      	movs	r3, #1
 8003e4e:	e000      	b.n	8003e52 <chThdCreateSuspendedI+0x72>
 8003e50:	2300      	movs	r3, #0
 8003e52:	2b00      	cmp	r3, #0
 8003e54:	d10c      	bne.n	8003e70 <chThdCreateSuspendedI+0x90>
 8003e56:	9b01      	ldr	r3, [sp, #4]
 8003e58:	689b      	ldr	r3, [r3, #8]
 8003e5a:	461a      	mov	r2, r3
 8003e5c:	9b01      	ldr	r3, [sp, #4]
 8003e5e:	685b      	ldr	r3, [r3, #4]
 8003e60:	1ad3      	subs	r3, r2, r3
 8003e62:	2bef      	cmp	r3, #239	@ 0xef
 8003e64:	bf94      	ite	ls
 8003e66:	2301      	movls	r3, #1
 8003e68:	2300      	movhi	r3, #0
 8003e6a:	b2db      	uxtb	r3, r3
 8003e6c:	2b00      	cmp	r3, #0
 8003e6e:	d002      	beq.n	8003e76 <chThdCreateSuspendedI+0x96>
 8003e70:	481f      	ldr	r0, [pc, #124]	@ (8003ef0 <chThdCreateSuspendedI+0x110>)
 8003e72:	f7fe fd5d 	bl	8002930 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8003e76:	9b01      	ldr	r3, [sp, #4]
 8003e78:	68db      	ldr	r3, [r3, #12]
 8003e7a:	2bff      	cmp	r3, #255	@ 0xff
 8003e7c:	bf8c      	ite	hi
 8003e7e:	2301      	movhi	r3, #1
 8003e80:	2300      	movls	r3, #0
 8003e82:	b2db      	uxtb	r3, r3
 8003e84:	2b00      	cmp	r3, #0
 8003e86:	d108      	bne.n	8003e9a <chThdCreateSuspendedI+0xba>
 8003e88:	9b01      	ldr	r3, [sp, #4]
 8003e8a:	691b      	ldr	r3, [r3, #16]
 8003e8c:	2b00      	cmp	r3, #0
 8003e8e:	bf0c      	ite	eq
 8003e90:	2301      	moveq	r3, #1
 8003e92:	2300      	movne	r3, #0
 8003e94:	b2db      	uxtb	r3, r3
 8003e96:	2b00      	cmp	r3, #0
 8003e98:	d002      	beq.n	8003ea0 <chThdCreateSuspendedI+0xc0>
 8003e9a:	4815      	ldr	r0, [pc, #84]	@ (8003ef0 <chThdCreateSuspendedI+0x110>)
 8003e9c:	f7fe fd48 	bl	8002930 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 8003ea0:	9b01      	ldr	r3, [sp, #4]
 8003ea2:	689b      	ldr	r3, [r3, #8]
 8003ea4:	3b48      	subs	r3, #72	@ 0x48
 8003ea6:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8003ea8:	9b01      	ldr	r3, [sp, #4]
 8003eaa:	685a      	ldr	r2, [r3, #4]
 8003eac:	9b03      	ldr	r3, [sp, #12]
 8003eae:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003eb0:	9b03      	ldr	r3, [sp, #12]
 8003eb2:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8003eb6:	9b03      	ldr	r3, [sp, #12]
 8003eb8:	60da      	str	r2, [r3, #12]
 8003eba:	9b01      	ldr	r3, [sp, #4]
 8003ebc:	691a      	ldr	r2, [r3, #16]
 8003ebe:	9b03      	ldr	r3, [sp, #12]
 8003ec0:	68db      	ldr	r3, [r3, #12]
 8003ec2:	601a      	str	r2, [r3, #0]
 8003ec4:	9b01      	ldr	r3, [sp, #4]
 8003ec6:	695a      	ldr	r2, [r3, #20]
 8003ec8:	9b03      	ldr	r3, [sp, #12]
 8003eca:	68db      	ldr	r3, [r3, #12]
 8003ecc:	605a      	str	r2, [r3, #4]
 8003ece:	9b03      	ldr	r3, [sp, #12]
 8003ed0:	68db      	ldr	r3, [r3, #12]
 8003ed2:	4a08      	ldr	r2, [pc, #32]	@ (8003ef4 <chThdCreateSuspendedI+0x114>)
 8003ed4:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8003ed6:	9b01      	ldr	r3, [sp, #4]
 8003ed8:	681a      	ldr	r2, [r3, #0]
 8003eda:	9b01      	ldr	r3, [sp, #4]
 8003edc:	68db      	ldr	r3, [r3, #12]
 8003ede:	9903      	ldr	r1, [sp, #12]
 8003ee0:	4805      	ldr	r0, [pc, #20]	@ (8003ef8 <chThdCreateSuspendedI+0x118>)
 8003ee2:	f7ff ff3d 	bl	8003d60 <__thd_object_init>
 8003ee6:	4603      	mov	r3, r0
}
 8003ee8:	4618      	mov	r0, r3
 8003eea:	b005      	add	sp, #20
 8003eec:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ef0:	080056e4 	.word	0x080056e4
 8003ef4:	080002d1 	.word	0x080002d1
 8003ef8:	20000988 	.word	0x20000988
 8003efc:	00000000 	.word	0x00000000

08003f00 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8003f00:	b500      	push	{lr}
 8003f02:	b083      	sub	sp, #12
 8003f04:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8003f06:	9801      	ldr	r0, [sp, #4]
 8003f08:	f7ff ff6a 	bl	8003de0 <chThdCreateSuspendedI>
 8003f0c:	4603      	mov	r3, r0
 8003f0e:	4618      	mov	r0, r3
 8003f10:	f7ff fc06 	bl	8003720 <chSchReadyI>
 8003f14:	4603      	mov	r3, r0
}
 8003f16:	4618      	mov	r0, r3
 8003f18:	b003      	add	sp, #12
 8003f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f1e:	bf00      	nop

08003f20 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003f20:	b500      	push	{lr}
 8003f22:	b087      	sub	sp, #28
 8003f24:	9003      	str	r0, [sp, #12]
 8003f26:	9102      	str	r1, [sp, #8]
 8003f28:	9201      	str	r2, [sp, #4]
 8003f2a:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 8003f2c:	9b03      	ldr	r3, [sp, #12]
 8003f2e:	2b00      	cmp	r3, #0
 8003f30:	bf0c      	ite	eq
 8003f32:	2301      	moveq	r3, #1
 8003f34:	2300      	movne	r3, #0
 8003f36:	b2db      	uxtb	r3, r3
 8003f38:	2b00      	cmp	r3, #0
 8003f3a:	d109      	bne.n	8003f50 <chThdCreateStatic+0x30>
 8003f3c:	9b03      	ldr	r3, [sp, #12]
 8003f3e:	f003 0307 	and.w	r3, r3, #7
 8003f42:	2b00      	cmp	r3, #0
 8003f44:	bf14      	ite	ne
 8003f46:	2301      	movne	r3, #1
 8003f48:	2300      	moveq	r3, #0
 8003f4a:	b2db      	uxtb	r3, r3
 8003f4c:	2b00      	cmp	r3, #0
 8003f4e:	d001      	beq.n	8003f54 <chThdCreateStatic+0x34>
 8003f50:	2301      	movs	r3, #1
 8003f52:	e000      	b.n	8003f56 <chThdCreateStatic+0x36>
 8003f54:	2300      	movs	r3, #0
 8003f56:	2b00      	cmp	r3, #0
 8003f58:	d107      	bne.n	8003f6a <chThdCreateStatic+0x4a>
 8003f5a:	9b02      	ldr	r3, [sp, #8]
 8003f5c:	2bef      	cmp	r3, #239	@ 0xef
 8003f5e:	bf94      	ite	ls
 8003f60:	2301      	movls	r3, #1
 8003f62:	2300      	movhi	r3, #0
 8003f64:	b2db      	uxtb	r3, r3
 8003f66:	2b00      	cmp	r3, #0
 8003f68:	d001      	beq.n	8003f6e <chThdCreateStatic+0x4e>
 8003f6a:	2301      	movs	r3, #1
 8003f6c:	e000      	b.n	8003f70 <chThdCreateStatic+0x50>
 8003f6e:	2300      	movs	r3, #0
 8003f70:	2b00      	cmp	r3, #0
 8003f72:	d109      	bne.n	8003f88 <chThdCreateStatic+0x68>
 8003f74:	9b02      	ldr	r3, [sp, #8]
 8003f76:	f003 0307 	and.w	r3, r3, #7
 8003f7a:	2b00      	cmp	r3, #0
 8003f7c:	bf14      	ite	ne
 8003f7e:	2301      	movne	r3, #1
 8003f80:	2300      	moveq	r3, #0
 8003f82:	b2db      	uxtb	r3, r3
 8003f84:	2b00      	cmp	r3, #0
 8003f86:	d001      	beq.n	8003f8c <chThdCreateStatic+0x6c>
 8003f88:	2301      	movs	r3, #1
 8003f8a:	e000      	b.n	8003f8e <chThdCreateStatic+0x6e>
 8003f8c:	2300      	movs	r3, #0
 8003f8e:	2b00      	cmp	r3, #0
 8003f90:	d107      	bne.n	8003fa2 <chThdCreateStatic+0x82>
 8003f92:	9b01      	ldr	r3, [sp, #4]
 8003f94:	2bff      	cmp	r3, #255	@ 0xff
 8003f96:	bf8c      	ite	hi
 8003f98:	2301      	movhi	r3, #1
 8003f9a:	2300      	movls	r3, #0
 8003f9c:	b2db      	uxtb	r3, r3
 8003f9e:	2b00      	cmp	r3, #0
 8003fa0:	d001      	beq.n	8003fa6 <chThdCreateStatic+0x86>
 8003fa2:	2301      	movs	r3, #1
 8003fa4:	e000      	b.n	8003fa8 <chThdCreateStatic+0x88>
 8003fa6:	2300      	movs	r3, #0
 8003fa8:	2b00      	cmp	r3, #0
 8003faa:	d107      	bne.n	8003fbc <chThdCreateStatic+0x9c>
 8003fac:	9b00      	ldr	r3, [sp, #0]
 8003fae:	2b00      	cmp	r3, #0
 8003fb0:	bf0c      	ite	eq
 8003fb2:	2301      	moveq	r3, #1
 8003fb4:	2300      	movne	r3, #0
 8003fb6:	b2db      	uxtb	r3, r3
 8003fb8:	2b00      	cmp	r3, #0
 8003fba:	d002      	beq.n	8003fc2 <chThdCreateStatic+0xa2>
 8003fbc:	481e      	ldr	r0, [pc, #120]	@ (8004038 <chThdCreateStatic+0x118>)
 8003fbe:	f7fe fcb7 	bl	8002930 <chSysHalt>
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8003fc2:	9803      	ldr	r0, [sp, #12]
 8003fc4:	f000 fa9c 	bl	8004500 <chRegFindThreadByWorkingArea>
 8003fc8:	4603      	mov	r3, r0
 8003fca:	2b00      	cmp	r3, #0
 8003fcc:	bf14      	ite	ne
 8003fce:	2301      	movne	r3, #1
 8003fd0:	2300      	moveq	r3, #0
 8003fd2:	b2db      	uxtb	r3, r3
 8003fd4:	2b00      	cmp	r3, #0
 8003fd6:	d002      	beq.n	8003fde <chThdCreateStatic+0xbe>
 8003fd8:	4817      	ldr	r0, [pc, #92]	@ (8004038 <chThdCreateStatic+0x118>)
 8003fda:	f7fe fca9 	bl	8002930 <chSysHalt>

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wsp, (uint8_t *)wsp + size);
#endif

  chSysLock();
 8003fde:	f7ff fe57 	bl	8003c90 <chSysLock.lto_priv.6>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 8003fe2:	9b02      	ldr	r3, [sp, #8]
 8003fe4:	3b48      	subs	r3, #72	@ 0x48
 8003fe6:	9a03      	ldr	r2, [sp, #12]
 8003fe8:	4413      	add	r3, r2
 8003fea:	9305      	str	r3, [sp, #20]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8003fec:	9b05      	ldr	r3, [sp, #20]
 8003fee:	9a03      	ldr	r2, [sp, #12]
 8003ff0:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003ff2:	9b05      	ldr	r3, [sp, #20]
 8003ff4:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8003ff8:	9b05      	ldr	r3, [sp, #20]
 8003ffa:	60da      	str	r2, [r3, #12]
 8003ffc:	9b05      	ldr	r3, [sp, #20]
 8003ffe:	68db      	ldr	r3, [r3, #12]
 8004000:	9a00      	ldr	r2, [sp, #0]
 8004002:	601a      	str	r2, [r3, #0]
 8004004:	9b05      	ldr	r3, [sp, #20]
 8004006:	68db      	ldr	r3, [r3, #12]
 8004008:	9a08      	ldr	r2, [sp, #32]
 800400a:	605a      	str	r2, [r3, #4]
 800400c:	9b05      	ldr	r3, [sp, #20]
 800400e:	68db      	ldr	r3, [r3, #12]
 8004010:	4a0a      	ldr	r2, [pc, #40]	@ (800403c <chThdCreateStatic+0x11c>)
 8004012:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 8004014:	9b01      	ldr	r3, [sp, #4]
 8004016:	4a0a      	ldr	r2, [pc, #40]	@ (8004040 <chThdCreateStatic+0x120>)
 8004018:	9905      	ldr	r1, [sp, #20]
 800401a:	480a      	ldr	r0, [pc, #40]	@ (8004044 <chThdCreateStatic+0x124>)
 800401c:	f7ff fea0 	bl	8003d60 <__thd_object_init>
 8004020:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8004022:	2100      	movs	r1, #0
 8004024:	9805      	ldr	r0, [sp, #20]
 8004026:	f7ff fc1b 	bl	8003860 <chSchWakeupS>
  chSysUnlock();
 800402a:	f7ff fe41 	bl	8003cb0 <chSysUnlock.lto_priv.6>

  return tp;
 800402e:	9b05      	ldr	r3, [sp, #20]
}
 8004030:	4618      	mov	r0, r3
 8004032:	b007      	add	sp, #28
 8004034:	f85d fb04 	ldr.w	pc, [sp], #4
 8004038:	08005708 	.word	0x08005708
 800403c:	080002d1 	.word	0x080002d1
 8004040:	080055f0 	.word	0x080055f0
 8004044:	20000988 	.word	0x20000988
	...

08004050 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8004050:	b510      	push	{r4, lr}
 8004052:	b082      	sub	sp, #8
 8004054:	9001      	str	r0, [sp, #4]

  chSysLock();
 8004056:	f7ff fe1b 	bl	8003c90 <chSysLock.lto_priv.6>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800405a:	9b01      	ldr	r3, [sp, #4]
 800405c:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8004060:	2b00      	cmp	r3, #0
 8004062:	bf0c      	ite	eq
 8004064:	2301      	moveq	r3, #1
 8004066:	2300      	movne	r3, #0
 8004068:	b2db      	uxtb	r3, r3
 800406a:	2b00      	cmp	r3, #0
 800406c:	d002      	beq.n	8004074 <chThdRelease+0x24>
 800406e:	481f      	ldr	r0, [pc, #124]	@ (80040ec <chThdRelease+0x9c>)
 8004070:	f7fe fc5e 	bl	8002930 <chSysHalt>
  tp->refs--;
 8004074:	9b01      	ldr	r3, [sp, #4]
 8004076:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800407a:	3b01      	subs	r3, #1
 800407c:	b2da      	uxtb	r2, r3
 800407e:	9b01      	ldr	r3, [sp, #4]
 8004080:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8004084:	9b01      	ldr	r3, [sp, #4]
 8004086:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800408a:	2b00      	cmp	r3, #0
 800408c:	d129      	bne.n	80040e2 <chThdRelease+0x92>
 800408e:	9b01      	ldr	r3, [sp, #4]
 8004090:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004094:	2b0f      	cmp	r3, #15
 8004096:	d124      	bne.n	80040e2 <chThdRelease+0x92>
    REG_REMOVE(tp);
 8004098:	9b01      	ldr	r3, [sp, #4]
 800409a:	3310      	adds	r3, #16
 800409c:	4618      	mov	r0, r3
 800409e:	f7ff fde7 	bl	8003c70 <ch_queue_dequeue.lto_priv.1>
    chSysUnlock();
 80040a2:	f7ff fe05 	bl	8003cb0 <chSysUnlock.lto_priv.6>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80040a6:	9b01      	ldr	r3, [sp, #4]
 80040a8:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 80040ac:	f003 0303 	and.w	r3, r3, #3
 80040b0:	2b01      	cmp	r3, #1
 80040b2:	d002      	beq.n	80040ba <chThdRelease+0x6a>
 80040b4:	2b02      	cmp	r3, #2
 80040b6:	d008      	beq.n	80040ca <chThdRelease+0x7a>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
      /* Nothing else to do for static threads.*/
      break;
 80040b8:	e012      	b.n	80040e0 <chThdRelease+0x90>
      chHeapFree(chThdGetWorkingAreaX(tp));
 80040ba:	9801      	ldr	r0, [sp, #4]
 80040bc:	f7ff fe30 	bl	8003d20 <chThdGetWorkingAreaX.lto_priv.0>
 80040c0:	4603      	mov	r3, r0
 80040c2:	4618      	mov	r0, r3
 80040c4:	f000 fd1c 	bl	8004b00 <chHeapFree>
      break;
 80040c8:	e00a      	b.n	80040e0 <chThdRelease+0x90>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 80040ca:	9b01      	ldr	r3, [sp, #4]
 80040cc:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
 80040ce:	9801      	ldr	r0, [sp, #4]
 80040d0:	f7ff fe26 	bl	8003d20 <chThdGetWorkingAreaX.lto_priv.0>
 80040d4:	4603      	mov	r3, r0
 80040d6:	4619      	mov	r1, r3
 80040d8:	4620      	mov	r0, r4
 80040da:	f000 fe89 	bl	8004df0 <chPoolFree>
      break;
 80040de:	bf00      	nop
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
 80040e0:	e001      	b.n	80040e6 <chThdRelease+0x96>
  }
  chSysUnlock();
 80040e2:	f7ff fde5 	bl	8003cb0 <chSysUnlock.lto_priv.6>
}
 80040e6:	b002      	add	sp, #8
 80040e8:	bd10      	pop	{r4, pc}
 80040ea:	bf00      	nop
 80040ec:	0800571c 	.word	0x0800571c

080040f0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80040f0:	b500      	push	{lr}
 80040f2:	b083      	sub	sp, #12
 80040f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80040f6:	f7ff fdcb 	bl	8003c90 <chSysLock.lto_priv.6>
  chThdExitS(msg);
 80040fa:	9801      	ldr	r0, [sp, #4]
 80040fc:	f000 f808 	bl	8004110 <chThdExitS>
  /* The thread never returns here.*/
}
 8004100:	bf00      	nop
 8004102:	b003      	add	sp, #12
 8004104:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004110 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8004110:	b500      	push	{lr}
 8004112:	b085      	sub	sp, #20
 8004114:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004116:	f7ff fdfb 	bl	8003d10 <chThdGetSelfX.lto_priv.0>
 800411a:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 800411c:	9b03      	ldr	r3, [sp, #12]
 800411e:	9a01      	ldr	r2, [sp, #4]
 8004120:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8004122:	e008      	b.n	8004136 <chThdExitS+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8004124:	9b03      	ldr	r3, [sp, #12]
 8004126:	332c      	adds	r3, #44	@ 0x2c
 8004128:	4618      	mov	r0, r3
 800412a:	f7ff fd69 	bl	8003c00 <ch_list_unlink>
 800412e:	4603      	mov	r3, r0
 8004130:	4618      	mov	r0, r3
 8004132:	f7ff faf5 	bl	8003720 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8004136:	9b03      	ldr	r3, [sp, #12]
 8004138:	332c      	adds	r3, #44	@ 0x2c
 800413a:	4618      	mov	r0, r3
 800413c:	f7ff fd50 	bl	8003be0 <ch_list_notempty>
 8004140:	4603      	mov	r3, r0
 8004142:	2b00      	cmp	r3, #0
 8004144:	d1ee      	bne.n	8004124 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8004146:	9b03      	ldr	r3, [sp, #12]
 8004148:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800414c:	2b00      	cmp	r3, #0
 800414e:	bf0c      	ite	eq
 8004150:	2301      	moveq	r3, #1
 8004152:	2300      	movne	r3, #0
 8004154:	b2db      	uxtb	r3, r3
 8004156:	2b00      	cmp	r3, #0
 8004158:	d010      	beq.n	800417c <chThdExitS+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 800415a:	9b03      	ldr	r3, [sp, #12]
 800415c:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8004160:	f003 0303 	and.w	r3, r3, #3
 8004164:	2b00      	cmp	r3, #0
 8004166:	bf0c      	ite	eq
 8004168:	2301      	moveq	r3, #1
 800416a:	2300      	movne	r3, #0
 800416c:	b2db      	uxtb	r3, r3
 800416e:	2b00      	cmp	r3, #0
 8004170:	d004      	beq.n	800417c <chThdExitS+0x6c>
      REG_REMOVE(currtp);
 8004172:	9b03      	ldr	r3, [sp, #12]
 8004174:	3310      	adds	r3, #16
 8004176:	4618      	mov	r0, r3
 8004178:	f7ff fd7a 	bl	8003c70 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800417c:	200f      	movs	r0, #15
 800417e:	f7ff faef 	bl	8003760 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8004182:	4803      	ldr	r0, [pc, #12]	@ (8004190 <chThdExitS+0x80>)
 8004184:	f7fe fbd4 	bl	8002930 <chSysHalt>
}
 8004188:	bf00      	nop
 800418a:	b005      	add	sp, #20
 800418c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004190:	0800572c 	.word	0x0800572c
	...

080041a0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 80041a0:	b500      	push	{lr}
 80041a2:	b083      	sub	sp, #12
 80041a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80041a6:	f7ff fd73 	bl	8003c90 <chSysLock.lto_priv.6>
  chThdSleepS(time);
 80041aa:	9801      	ldr	r0, [sp, #4]
 80041ac:	f7ff fdc0 	bl	8003d30 <chThdSleepS>
  chSysUnlock();
 80041b0:	f7ff fd7e 	bl	8003cb0 <chSysUnlock.lto_priv.6>
}
 80041b4:	bf00      	nop
 80041b6:	b003      	add	sp, #12
 80041b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80041bc:	0000      	movs	r0, r0
	...

080041c0 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 80041c0:	b500      	push	{lr}
 80041c2:	b085      	sub	sp, #20
 80041c4:	9001      	str	r0, [sp, #4]
 80041c6:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 80041c8:	f7ff fda2 	bl	8003d10 <chThdGetSelfX.lto_priv.0>
 80041cc:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 80041ce:	9b01      	ldr	r3, [sp, #4]
 80041d0:	681b      	ldr	r3, [r3, #0]
 80041d2:	2b00      	cmp	r3, #0
 80041d4:	bf14      	ite	ne
 80041d6:	2301      	movne	r3, #1
 80041d8:	2300      	moveq	r3, #0
 80041da:	b2db      	uxtb	r3, r3
 80041dc:	2b00      	cmp	r3, #0
 80041de:	d002      	beq.n	80041e6 <chThdSuspendTimeoutS+0x26>
 80041e0:	480e      	ldr	r0, [pc, #56]	@ (800421c <chThdSuspendTimeoutS+0x5c>)
 80041e2:	f7fe fba5 	bl	8002930 <chSysHalt>

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 80041e6:	9b00      	ldr	r3, [sp, #0]
 80041e8:	2b00      	cmp	r3, #0
 80041ea:	bf0c      	ite	eq
 80041ec:	2301      	moveq	r3, #1
 80041ee:	2300      	movne	r3, #0
 80041f0:	b2db      	uxtb	r3, r3
 80041f2:	2b00      	cmp	r3, #0
 80041f4:	d002      	beq.n	80041fc <chThdSuspendTimeoutS+0x3c>
    return MSG_TIMEOUT;
 80041f6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80041fa:	e00a      	b.n	8004212 <chThdSuspendTimeoutS+0x52>
  }

  *trp = tp;
 80041fc:	9b01      	ldr	r3, [sp, #4]
 80041fe:	9a03      	ldr	r2, [sp, #12]
 8004200:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8004202:	9b03      	ldr	r3, [sp, #12]
 8004204:	9a01      	ldr	r2, [sp, #4]
 8004206:	629a      	str	r2, [r3, #40]	@ 0x28

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8004208:	9900      	ldr	r1, [sp, #0]
 800420a:	2003      	movs	r0, #3
 800420c:	f7ff faf0 	bl	80037f0 <chSchGoSleepTimeoutS>
 8004210:	4603      	mov	r3, r0
}
 8004212:	4618      	mov	r0, r3
 8004214:	b005      	add	sp, #20
 8004216:	f85d fb04 	ldr.w	pc, [sp], #4
 800421a:	bf00      	nop
 800421c:	08005744 	.word	0x08005744

08004220 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8004220:	b500      	push	{lr}
 8004222:	b085      	sub	sp, #20
 8004224:	9001      	str	r0, [sp, #4]
 8004226:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8004228:	9b01      	ldr	r3, [sp, #4]
 800422a:	681b      	ldr	r3, [r3, #0]
 800422c:	2b00      	cmp	r3, #0
 800422e:	d018      	beq.n	8004262 <chThdResumeI+0x42>
    thread_t *tp = *trp;
 8004230:	9b01      	ldr	r3, [sp, #4]
 8004232:	681b      	ldr	r3, [r3, #0]
 8004234:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004236:	9b03      	ldr	r3, [sp, #12]
 8004238:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800423c:	2b03      	cmp	r3, #3
 800423e:	bf14      	ite	ne
 8004240:	2301      	movne	r3, #1
 8004242:	2300      	moveq	r3, #0
 8004244:	b2db      	uxtb	r3, r3
 8004246:	2b00      	cmp	r3, #0
 8004248:	d002      	beq.n	8004250 <chThdResumeI+0x30>
 800424a:	4808      	ldr	r0, [pc, #32]	@ (800426c <chThdResumeI+0x4c>)
 800424c:	f7fe fb70 	bl	8002930 <chSysHalt>

    *trp = NULL;
 8004250:	9b01      	ldr	r3, [sp, #4]
 8004252:	2200      	movs	r2, #0
 8004254:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8004256:	9b03      	ldr	r3, [sp, #12]
 8004258:	9a00      	ldr	r2, [sp, #0]
 800425a:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 800425c:	9803      	ldr	r0, [sp, #12]
 800425e:	f7ff fa5f 	bl	8003720 <chSchReadyI>
  }
}
 8004262:	bf00      	nop
 8004264:	b005      	add	sp, #20
 8004266:	f85d fb04 	ldr.w	pc, [sp], #4
 800426a:	bf00      	nop
 800426c:	0800575c 	.word	0x0800575c

08004270 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8004270:	b500      	push	{lr}
 8004272:	b085      	sub	sp, #20
 8004274:	9001      	str	r0, [sp, #4]
 8004276:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8004278:	9b01      	ldr	r3, [sp, #4]
 800427a:	681b      	ldr	r3, [r3, #0]
 800427c:	2b00      	cmp	r3, #0
 800427e:	d016      	beq.n	80042ae <chThdResumeS+0x3e>
    thread_t *tp = *trp;
 8004280:	9b01      	ldr	r3, [sp, #4]
 8004282:	681b      	ldr	r3, [r3, #0]
 8004284:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004286:	9b03      	ldr	r3, [sp, #12]
 8004288:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800428c:	2b03      	cmp	r3, #3
 800428e:	bf14      	ite	ne
 8004290:	2301      	movne	r3, #1
 8004292:	2300      	moveq	r3, #0
 8004294:	b2db      	uxtb	r3, r3
 8004296:	2b00      	cmp	r3, #0
 8004298:	d002      	beq.n	80042a0 <chThdResumeS+0x30>
 800429a:	4807      	ldr	r0, [pc, #28]	@ (80042b8 <chThdResumeS+0x48>)
 800429c:	f7fe fb48 	bl	8002930 <chSysHalt>

    *trp = NULL;
 80042a0:	9b01      	ldr	r3, [sp, #4]
 80042a2:	2200      	movs	r2, #0
 80042a4:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 80042a6:	9900      	ldr	r1, [sp, #0]
 80042a8:	9803      	ldr	r0, [sp, #12]
 80042aa:	f7ff fad9 	bl	8003860 <chSchWakeupS>
  }
}
 80042ae:	bf00      	nop
 80042b0:	b005      	add	sp, #20
 80042b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80042b6:	bf00      	nop
 80042b8:	0800576c 	.word	0x0800576c
 80042bc:	00000000 	.word	0x00000000

080042c0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80042c0:	b4f0      	push	{r4, r5, r6, r7}
 80042c2:	b084      	sub	sp, #16
 80042c4:	9003      	str	r0, [sp, #12]
 80042c6:	9102      	str	r1, [sp, #8]
 80042c8:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80042ca:	9b03      	ldr	r3, [sp, #12]
 80042cc:	68db      	ldr	r3, [r3, #12]
 80042ce:	1c5a      	adds	r2, r3, #1
 80042d0:	9b03      	ldr	r3, [sp, #12]
 80042d2:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 80042d4:	9b03      	ldr	r3, [sp, #12]
 80042d6:	689b      	ldr	r3, [r3, #8]
 80042d8:	9a02      	ldr	r2, [sp, #8]
 80042da:	1ad2      	subs	r2, r2, r3
 80042dc:	9b01      	ldr	r3, [sp, #4]
 80042de:	1ad2      	subs	r2, r2, r3
 80042e0:	9b03      	ldr	r3, [sp, #12]
 80042e2:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80042e4:	9b03      	ldr	r3, [sp, #12]
 80042e6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80042ea:	9903      	ldr	r1, [sp, #12]
 80042ec:	6889      	ldr	r1, [r1, #8]
 80042ee:	2000      	movs	r0, #0
 80042f0:	460c      	mov	r4, r1
 80042f2:	4605      	mov	r5, r0
 80042f4:	1916      	adds	r6, r2, r4
 80042f6:	eb43 0705 	adc.w	r7, r3, r5
 80042fa:	9b03      	ldr	r3, [sp, #12]
 80042fc:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
 8004300:	9b03      	ldr	r3, [sp, #12]
 8004302:	689a      	ldr	r2, [r3, #8]
 8004304:	9b03      	ldr	r3, [sp, #12]
 8004306:	685b      	ldr	r3, [r3, #4]
 8004308:	429a      	cmp	r2, r3
 800430a:	d903      	bls.n	8004314 <tm_stop+0x54>
    tmp->worst = tmp->last;
 800430c:	9b03      	ldr	r3, [sp, #12]
 800430e:	689a      	ldr	r2, [r3, #8]
 8004310:	9b03      	ldr	r3, [sp, #12]
 8004312:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8004314:	9b03      	ldr	r3, [sp, #12]
 8004316:	689a      	ldr	r2, [r3, #8]
 8004318:	9b03      	ldr	r3, [sp, #12]
 800431a:	681b      	ldr	r3, [r3, #0]
 800431c:	429a      	cmp	r2, r3
 800431e:	d203      	bcs.n	8004328 <tm_stop+0x68>
    tmp->best = tmp->last;
 8004320:	9b03      	ldr	r3, [sp, #12]
 8004322:	689a      	ldr	r2, [r3, #8]
 8004324:	9b03      	ldr	r3, [sp, #12]
 8004326:	601a      	str	r2, [r3, #0]
  }
}
 8004328:	bf00      	nop
 800432a:	b004      	add	sp, #16
 800432c:	bcf0      	pop	{r4, r5, r6, r7}
 800432e:	4770      	bx	lr

08004330 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8004330:	b082      	sub	sp, #8
 8004332:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8004334:	9b01      	ldr	r3, [sp, #4]
 8004336:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800433a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 800433c:	9b01      	ldr	r3, [sp, #4]
 800433e:	2200      	movs	r2, #0
 8004340:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8004342:	9b01      	ldr	r3, [sp, #4]
 8004344:	2200      	movs	r2, #0
 8004346:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8004348:	9b01      	ldr	r3, [sp, #4]
 800434a:	2200      	movs	r2, #0
 800434c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 800434e:	9901      	ldr	r1, [sp, #4]
 8004350:	f04f 0200 	mov.w	r2, #0
 8004354:	f04f 0300 	mov.w	r3, #0
 8004358:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 800435c:	bf00      	nop
 800435e:	b002      	add	sp, #8
 8004360:	4770      	bx	lr
 8004362:	bf00      	nop
	...

08004370 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8004370:	b082      	sub	sp, #8
 8004372:	9001      	str	r0, [sp, #4]
  return DWT->CYCCNT;
 8004374:	4b03      	ldr	r3, [pc, #12]	@ (8004384 <chTMStartMeasurementX+0x14>)
 8004376:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8004378:	9b01      	ldr	r3, [sp, #4]
 800437a:	609a      	str	r2, [r3, #8]
}
 800437c:	bf00      	nop
 800437e:	b002      	add	sp, #8
 8004380:	4770      	bx	lr
 8004382:	bf00      	nop
 8004384:	e0001000 	.word	0xe0001000
	...

08004390 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8004390:	b500      	push	{lr}
 8004392:	b083      	sub	sp, #12
 8004394:	9001      	str	r0, [sp, #4]
 8004396:	4b06      	ldr	r3, [pc, #24]	@ (80043b0 <chTMStopMeasurementX+0x20>)
 8004398:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 800439a:	4a06      	ldr	r2, [pc, #24]	@ (80043b4 <chTMStopMeasurementX+0x24>)
 800439c:	6892      	ldr	r2, [r2, #8]
 800439e:	4619      	mov	r1, r3
 80043a0:	9801      	ldr	r0, [sp, #4]
 80043a2:	f7ff ff8d 	bl	80042c0 <tm_stop>
}
 80043a6:	bf00      	nop
 80043a8:	b003      	add	sp, #12
 80043aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80043ae:	bf00      	nop
 80043b0:	e0001000 	.word	0xe0001000
 80043b4:	2000097c 	.word	0x2000097c
	...

080043c0 <chSysLock.lto_priv.7>:
static inline void chSysLock(void) {
 80043c0:	b500      	push	{lr}
 80043c2:	b083      	sub	sp, #12
 80043c4:	2330      	movs	r3, #48	@ 0x30
 80043c6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80043c8:	9b01      	ldr	r3, [sp, #4]
 80043ca:	f383 8811 	msr	BASEPRI, r3
}
 80043ce:	bf00      	nop
}
 80043d0:	bf00      	nop
  __dbg_check_lock();
 80043d2:	f7fe fb35 	bl	8002a40 <__dbg_check_lock>
}
 80043d6:	bf00      	nop
 80043d8:	b003      	add	sp, #12
 80043da:	f85d fb04 	ldr.w	pc, [sp], #4
 80043de:	bf00      	nop

080043e0 <chSysUnlock.lto_priv.7>:
static inline void chSysUnlock(void) {
 80043e0:	b500      	push	{lr}
 80043e2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80043e4:	f7fe fb54 	bl	8002a90 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80043e8:	4b12      	ldr	r3, [pc, #72]	@ (8004434 <chSysUnlock.lto_priv.7+0x54>)
 80043ea:	681b      	ldr	r3, [r3, #0]
 80043ec:	4a11      	ldr	r2, [pc, #68]	@ (8004434 <chSysUnlock.lto_priv.7+0x54>)
 80043ee:	4293      	cmp	r3, r2
 80043f0:	bf14      	ite	ne
 80043f2:	2301      	movne	r3, #1
 80043f4:	2300      	moveq	r3, #0
 80043f6:	b2db      	uxtb	r3, r3
 80043f8:	2b00      	cmp	r3, #0
 80043fa:	d00f      	beq.n	800441c <chSysUnlock.lto_priv.7+0x3c>
 80043fc:	4b0d      	ldr	r3, [pc, #52]	@ (8004434 <chSysUnlock.lto_priv.7+0x54>)
 80043fe:	68db      	ldr	r3, [r3, #12]
 8004400:	689a      	ldr	r2, [r3, #8]
 8004402:	4b0c      	ldr	r3, [pc, #48]	@ (8004434 <chSysUnlock.lto_priv.7+0x54>)
 8004404:	681b      	ldr	r3, [r3, #0]
 8004406:	689b      	ldr	r3, [r3, #8]
 8004408:	429a      	cmp	r2, r3
 800440a:	bf34      	ite	cc
 800440c:	2301      	movcc	r3, #1
 800440e:	2300      	movcs	r3, #0
 8004410:	b2db      	uxtb	r3, r3
 8004412:	2b00      	cmp	r3, #0
 8004414:	d002      	beq.n	800441c <chSysUnlock.lto_priv.7+0x3c>
 8004416:	4808      	ldr	r0, [pc, #32]	@ (8004438 <chSysUnlock.lto_priv.7+0x58>)
 8004418:	f7fe fa8a 	bl	8002930 <chSysHalt>
 800441c:	2300      	movs	r3, #0
 800441e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004420:	9b01      	ldr	r3, [sp, #4]
 8004422:	f383 8811 	msr	BASEPRI, r3
}
 8004426:	bf00      	nop
}
 8004428:	bf00      	nop
}
 800442a:	bf00      	nop
 800442c:	b003      	add	sp, #12
 800442e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004432:	bf00      	nop
 8004434:	20000988 	.word	0x20000988
 8004438:	080057a8 	.word	0x080057a8
 800443c:	00000000 	.word	0x00000000

08004440 <chThdGetWorkingAreaX.lto_priv.1>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8004440:	b082      	sub	sp, #8
 8004442:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8004444:	9b01      	ldr	r3, [sp, #4]
 8004446:	6a1b      	ldr	r3, [r3, #32]
}
 8004448:	4618      	mov	r0, r3
 800444a:	b002      	add	sp, #8
 800444c:	4770      	bx	lr
 800444e:	bf00      	nop

08004450 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8004450:	b500      	push	{lr}
 8004452:	b083      	sub	sp, #12
  thread_t *tp;
  uint8_t *p;

  chSysLock();
 8004454:	f7ff ffb4 	bl	80043c0 <chSysLock.lto_priv.7>
  p = (uint8_t *)REG_HEADER(currcore)->next;
 8004458:	4b0a      	ldr	r3, [pc, #40]	@ (8004484 <chRegFirstThread+0x34>)
 800445a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800445c:	9301      	str	r3, [sp, #4]
  /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 800445e:	9b01      	ldr	r3, [sp, #4]
 8004460:	3b10      	subs	r3, #16
 8004462:	9300      	str	r3, [sp, #0]
  /*lint -restore*/
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8004464:	9b00      	ldr	r3, [sp, #0]
 8004466:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800446a:	3301      	adds	r3, #1
 800446c:	b2da      	uxtb	r2, r3
 800446e:	9b00      	ldr	r3, [sp, #0]
 8004470:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
#endif
  chSysUnlock();
 8004474:	f7ff ffb4 	bl	80043e0 <chSysUnlock.lto_priv.7>

  return tp;
 8004478:	9b00      	ldr	r3, [sp, #0]
}
 800447a:	4618      	mov	r0, r3
 800447c:	b003      	add	sp, #12
 800447e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004482:	bf00      	nop
 8004484:	20000988 	.word	0x20000988
	...

08004490 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8004490:	b500      	push	{lr}
 8004492:	b087      	sub	sp, #28
 8004494:	9001      	str	r0, [sp, #4]
  thread_t *ntp;
  ch_queue_t *nqp;

  chSysLock();
 8004496:	f7ff ff93 	bl	80043c0 <chSysLock.lto_priv.7>

  /* Next element in the registry queue.*/
  nqp = tp->rqueue.next;
 800449a:	9b01      	ldr	r3, [sp, #4]
 800449c:	691b      	ldr	r3, [r3, #16]
 800449e:	9304      	str	r3, [sp, #16]
  if (nqp == REG_HEADER(currcore)) {
 80044a0:	9b04      	ldr	r3, [sp, #16]
 80044a2:	4a15      	ldr	r2, [pc, #84]	@ (80044f8 <chRegNextThread+0x68>)
 80044a4:	4293      	cmp	r3, r2
 80044a6:	d102      	bne.n	80044ae <chRegNextThread+0x1e>
    ntp = NULL;
 80044a8:	2300      	movs	r3, #0
 80044aa:	9305      	str	r3, [sp, #20]
 80044ac:	e019      	b.n	80044e2 <chRegNextThread+0x52>
  }
  else {
    uint8_t *p = (uint8_t *)nqp;
 80044ae:	9b04      	ldr	r3, [sp, #16]
 80044b0:	9303      	str	r3, [sp, #12]
    /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 80044b2:	9b03      	ldr	r3, [sp, #12]
 80044b4:	3b10      	subs	r3, #16
 80044b6:	9305      	str	r3, [sp, #20]
    /*lint -restore*/

#if CH_CFG_USE_DYNAMIC == TRUE
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 80044b8:	9b05      	ldr	r3, [sp, #20]
 80044ba:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 80044be:	2bff      	cmp	r3, #255	@ 0xff
 80044c0:	bf0c      	ite	eq
 80044c2:	2301      	moveq	r3, #1
 80044c4:	2300      	movne	r3, #0
 80044c6:	b2db      	uxtb	r3, r3
 80044c8:	2b00      	cmp	r3, #0
 80044ca:	d002      	beq.n	80044d2 <chRegNextThread+0x42>
 80044cc:	480b      	ldr	r0, [pc, #44]	@ (80044fc <chRegNextThread+0x6c>)
 80044ce:	f7fe fa2f 	bl	8002930 <chSysHalt>

    ntp->refs++;
 80044d2:	9b05      	ldr	r3, [sp, #20]
 80044d4:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 80044d8:	3301      	adds	r3, #1
 80044da:	b2da      	uxtb	r2, r3
 80044dc:	9b05      	ldr	r3, [sp, #20]
 80044de:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
#endif
  }
  chSysUnlock();
 80044e2:	f7ff ff7d 	bl	80043e0 <chSysUnlock.lto_priv.7>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80044e6:	9801      	ldr	r0, [sp, #4]
 80044e8:	f7ff fdb2 	bl	8004050 <chThdRelease>
#endif

  return ntp;
 80044ec:	9b05      	ldr	r3, [sp, #20]
}
 80044ee:	4618      	mov	r0, r3
 80044f0:	b007      	add	sp, #28
 80044f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80044f6:	bf00      	nop
 80044f8:	200009b0 	.word	0x200009b0
 80044fc:	080057b4 	.word	0x080057b4

08004500 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8004500:	b500      	push	{lr}
 8004502:	b085      	sub	sp, #20
 8004504:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8004506:	f7ff ffa3 	bl	8004450 <chRegFirstThread>
 800450a:	9003      	str	r0, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800450c:	9803      	ldr	r0, [sp, #12]
 800450e:	f7ff ff97 	bl	8004440 <chThdGetWorkingAreaX.lto_priv.1>
 8004512:	4602      	mov	r2, r0
 8004514:	9b01      	ldr	r3, [sp, #4]
 8004516:	4293      	cmp	r3, r2
 8004518:	d101      	bne.n	800451e <chRegFindThreadByWorkingArea+0x1e>
      return ctp;
 800451a:	9b03      	ldr	r3, [sp, #12]
 800451c:	e007      	b.n	800452e <chRegFindThreadByWorkingArea+0x2e>
    }
    ctp = chRegNextThread(ctp);
 800451e:	9803      	ldr	r0, [sp, #12]
 8004520:	f7ff ffb6 	bl	8004490 <chRegNextThread>
 8004524:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 8004526:	9b03      	ldr	r3, [sp, #12]
 8004528:	2b00      	cmp	r3, #0
 800452a:	d1ef      	bne.n	800450c <chRegFindThreadByWorkingArea+0xc>

  return NULL;
 800452c:	2300      	movs	r3, #0
}
 800452e:	4618      	mov	r0, r3
 8004530:	b005      	add	sp, #20
 8004532:	f85d fb04 	ldr.w	pc, [sp], #4
 8004536:	bf00      	nop
	...

08004540 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004540:	b082      	sub	sp, #8
 8004542:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004544:	9b01      	ldr	r3, [sp, #4]
 8004546:	9a01      	ldr	r2, [sp, #4]
 8004548:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800454a:	9b01      	ldr	r3, [sp, #4]
 800454c:	9a01      	ldr	r2, [sp, #4]
 800454e:	605a      	str	r2, [r3, #4]
}
 8004550:	bf00      	nop
 8004552:	b002      	add	sp, #8
 8004554:	4770      	bx	lr
 8004556:	bf00      	nop
	...

08004560 <ch_queue_notempty.lto_priv.2>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 8004560:	b082      	sub	sp, #8
 8004562:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 8004564:	9b01      	ldr	r3, [sp, #4]
 8004566:	681b      	ldr	r3, [r3, #0]
 8004568:	9a01      	ldr	r2, [sp, #4]
 800456a:	429a      	cmp	r2, r3
 800456c:	bf14      	ite	ne
 800456e:	2301      	movne	r3, #1
 8004570:	2300      	moveq	r3, #0
 8004572:	b2db      	uxtb	r3, r3
}
 8004574:	4618      	mov	r0, r3
 8004576:	b002      	add	sp, #8
 8004578:	4770      	bx	lr
 800457a:	bf00      	nop
 800457c:	0000      	movs	r0, r0
	...

08004580 <ch_queue_fifo_remove.lto_priv.2>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 8004580:	b084      	sub	sp, #16
 8004582:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 8004584:	9b01      	ldr	r3, [sp, #4]
 8004586:	681b      	ldr	r3, [r3, #0]
 8004588:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 800458a:	9b03      	ldr	r3, [sp, #12]
 800458c:	681a      	ldr	r2, [r3, #0]
 800458e:	9b01      	ldr	r3, [sp, #4]
 8004590:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 8004592:	9b01      	ldr	r3, [sp, #4]
 8004594:	681b      	ldr	r3, [r3, #0]
 8004596:	9a01      	ldr	r2, [sp, #4]
 8004598:	605a      	str	r2, [r3, #4]
  return p;
 800459a:	9b03      	ldr	r3, [sp, #12]
}
 800459c:	4618      	mov	r0, r3
 800459e:	b004      	add	sp, #16
 80045a0:	4770      	bx	lr
 80045a2:	bf00      	nop
	...

080045b0 <ch_queue_dequeue.lto_priv.2>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80045b0:	b082      	sub	sp, #8
 80045b2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80045b4:	9b01      	ldr	r3, [sp, #4]
 80045b6:	685b      	ldr	r3, [r3, #4]
 80045b8:	9a01      	ldr	r2, [sp, #4]
 80045ba:	6812      	ldr	r2, [r2, #0]
 80045bc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80045be:	9b01      	ldr	r3, [sp, #4]
 80045c0:	681b      	ldr	r3, [r3, #0]
 80045c2:	9a01      	ldr	r2, [sp, #4]
 80045c4:	6852      	ldr	r2, [r2, #4]
 80045c6:	605a      	str	r2, [r3, #4]
  return p;
 80045c8:	9b01      	ldr	r3, [sp, #4]
}
 80045ca:	4618      	mov	r0, r3
 80045cc:	b002      	add	sp, #8
 80045ce:	4770      	bx	lr

080045d0 <chSysLock.lto_priv.9>:
static inline void chSysLock(void) {
 80045d0:	b500      	push	{lr}
 80045d2:	b083      	sub	sp, #12
 80045d4:	2330      	movs	r3, #48	@ 0x30
 80045d6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80045d8:	9b01      	ldr	r3, [sp, #4]
 80045da:	f383 8811 	msr	BASEPRI, r3
}
 80045de:	bf00      	nop
}
 80045e0:	bf00      	nop
  __dbg_check_lock();
 80045e2:	f7fe fa2d 	bl	8002a40 <__dbg_check_lock>
}
 80045e6:	bf00      	nop
 80045e8:	b003      	add	sp, #12
 80045ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80045ee:	bf00      	nop

080045f0 <chSysUnlock.lto_priv.9>:
static inline void chSysUnlock(void) {
 80045f0:	b500      	push	{lr}
 80045f2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80045f4:	f7fe fa4c 	bl	8002a90 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80045f8:	4b12      	ldr	r3, [pc, #72]	@ (8004644 <chSysUnlock.lto_priv.9+0x54>)
 80045fa:	681b      	ldr	r3, [r3, #0]
 80045fc:	4a11      	ldr	r2, [pc, #68]	@ (8004644 <chSysUnlock.lto_priv.9+0x54>)
 80045fe:	4293      	cmp	r3, r2
 8004600:	bf14      	ite	ne
 8004602:	2301      	movne	r3, #1
 8004604:	2300      	moveq	r3, #0
 8004606:	b2db      	uxtb	r3, r3
 8004608:	2b00      	cmp	r3, #0
 800460a:	d00f      	beq.n	800462c <chSysUnlock.lto_priv.9+0x3c>
 800460c:	4b0d      	ldr	r3, [pc, #52]	@ (8004644 <chSysUnlock.lto_priv.9+0x54>)
 800460e:	68db      	ldr	r3, [r3, #12]
 8004610:	689a      	ldr	r2, [r3, #8]
 8004612:	4b0c      	ldr	r3, [pc, #48]	@ (8004644 <chSysUnlock.lto_priv.9+0x54>)
 8004614:	681b      	ldr	r3, [r3, #0]
 8004616:	689b      	ldr	r3, [r3, #8]
 8004618:	429a      	cmp	r2, r3
 800461a:	bf34      	ite	cc
 800461c:	2301      	movcc	r3, #1
 800461e:	2300      	movcs	r3, #0
 8004620:	b2db      	uxtb	r3, r3
 8004622:	2b00      	cmp	r3, #0
 8004624:	d002      	beq.n	800462c <chSysUnlock.lto_priv.9+0x3c>
 8004626:	4808      	ldr	r0, [pc, #32]	@ (8004648 <chSysUnlock.lto_priv.9+0x58>)
 8004628:	f7fe f982 	bl	8002930 <chSysHalt>
 800462c:	2300      	movs	r3, #0
 800462e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004630:	9b01      	ldr	r3, [sp, #4]
 8004632:	f383 8811 	msr	BASEPRI, r3
}
 8004636:	bf00      	nop
}
 8004638:	bf00      	nop
}
 800463a:	bf00      	nop
 800463c:	b003      	add	sp, #12
 800463e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004642:	bf00      	nop
 8004644:	20000988 	.word	0x20000988
 8004648:	080057d4 	.word	0x080057d4
 800464c:	00000000 	.word	0x00000000

08004650 <ch_sch_prio_insert.lto_priv.0>:
/*===========================================================================*/

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 8004650:	b084      	sub	sp, #16
 8004652:	9001      	str	r0, [sp, #4]
 8004654:	9100      	str	r1, [sp, #0]

  ch_queue_t *cp = qp;
 8004656:	9b01      	ldr	r3, [sp, #4]
 8004658:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->next;
 800465a:	9b03      	ldr	r3, [sp, #12]
 800465c:	681b      	ldr	r3, [r3, #0]
 800465e:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
 8004660:	9a03      	ldr	r2, [sp, #12]
 8004662:	9b01      	ldr	r3, [sp, #4]
 8004664:	429a      	cmp	r2, r3
 8004666:	d005      	beq.n	8004674 <ch_sch_prio_insert.lto_priv.0+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8004668:	9b03      	ldr	r3, [sp, #12]
 800466a:	689a      	ldr	r2, [r3, #8]
 800466c:	9b00      	ldr	r3, [sp, #0]
 800466e:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
 8004670:	429a      	cmp	r2, r3
 8004672:	d2f2      	bcs.n	800465a <ch_sch_prio_insert.lto_priv.0+0xa>
  tp->next       = cp;
 8004674:	9b00      	ldr	r3, [sp, #0]
 8004676:	9a03      	ldr	r2, [sp, #12]
 8004678:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
 800467a:	9b03      	ldr	r3, [sp, #12]
 800467c:	685a      	ldr	r2, [r3, #4]
 800467e:	9b00      	ldr	r3, [sp, #0]
 8004680:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
 8004682:	9b00      	ldr	r3, [sp, #0]
 8004684:	685b      	ldr	r3, [r3, #4]
 8004686:	9a00      	ldr	r2, [sp, #0]
 8004688:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
 800468a:	9b03      	ldr	r3, [sp, #12]
 800468c:	9a00      	ldr	r2, [sp, #0]
 800468e:	605a      	str	r2, [r3, #4]
}
 8004690:	bf00      	nop
 8004692:	b004      	add	sp, #16
 8004694:	4770      	bx	lr
 8004696:	bf00      	nop
	...

080046a0 <chThdGetSelfX.lto_priv.2>:
  return __sch_get_currthread();
 80046a0:	4b01      	ldr	r3, [pc, #4]	@ (80046a8 <chThdGetSelfX.lto_priv.2+0x8>)
 80046a2:	68db      	ldr	r3, [r3, #12]
}
 80046a4:	4618      	mov	r0, r3
 80046a6:	4770      	bx	lr
 80046a8:	20000988 	.word	0x20000988
 80046ac:	00000000 	.word	0x00000000

080046b0 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 80046b0:	b500      	push	{lr}
 80046b2:	b083      	sub	sp, #12
 80046b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 80046b6:	f7fe fafb 	bl	8002cb0 <chDbgCheckClassS>

  return ch_queue_notempty(&mp->queue);
 80046ba:	9b01      	ldr	r3, [sp, #4]
 80046bc:	4618      	mov	r0, r3
 80046be:	f7ff ff4f 	bl	8004560 <ch_queue_notempty.lto_priv.2>
 80046c2:	4603      	mov	r3, r0
}
 80046c4:	4618      	mov	r0, r3
 80046c6:	b003      	add	sp, #12
 80046c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80046cc:	0000      	movs	r0, r0
	...

080046d0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 80046d0:	b500      	push	{lr}
 80046d2:	b083      	sub	sp, #12
 80046d4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 80046d6:	9b01      	ldr	r3, [sp, #4]
 80046d8:	2b00      	cmp	r3, #0
 80046da:	bf0c      	ite	eq
 80046dc:	2301      	moveq	r3, #1
 80046de:	2300      	movne	r3, #0
 80046e0:	b2db      	uxtb	r3, r3
 80046e2:	2b00      	cmp	r3, #0
 80046e4:	d002      	beq.n	80046ec <chMtxObjectInit+0x1c>
 80046e6:	4807      	ldr	r0, [pc, #28]	@ (8004704 <chMtxObjectInit+0x34>)
 80046e8:	f7fe f922 	bl	8002930 <chSysHalt>

  ch_queue_init(&mp->queue);
 80046ec:	9b01      	ldr	r3, [sp, #4]
 80046ee:	4618      	mov	r0, r3
 80046f0:	f7ff ff26 	bl	8004540 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 80046f4:	9b01      	ldr	r3, [sp, #4]
 80046f6:	2200      	movs	r2, #0
 80046f8:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 80046fa:	bf00      	nop
 80046fc:	b003      	add	sp, #12
 80046fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004702:	bf00      	nop
 8004704:	080057c4 	.word	0x080057c4
	...

08004710 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8004710:	b500      	push	{lr}
 8004712:	b083      	sub	sp, #12
 8004714:	9001      	str	r0, [sp, #4]

  chSysLock();
 8004716:	f7ff ff5b 	bl	80045d0 <chSysLock.lto_priv.9>
  chMtxLockS(mp);
 800471a:	9801      	ldr	r0, [sp, #4]
 800471c:	f000 f808 	bl	8004730 <chMtxLockS>
  chSysUnlock();
 8004720:	f7ff ff66 	bl	80045f0 <chSysUnlock.lto_priv.9>
}
 8004724:	bf00      	nop
 8004726:	b003      	add	sp, #12
 8004728:	f85d fb04 	ldr.w	pc, [sp], #4
 800472c:	0000      	movs	r0, r0
	...

08004730 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8004730:	b510      	push	{r4, lr}
 8004732:	b084      	sub	sp, #16
 8004734:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004736:	f7ff ffb3 	bl	80046a0 <chThdGetSelfX.lto_priv.2>
 800473a:	9002      	str	r0, [sp, #8]

  chDbgCheckClassS();
 800473c:	f7fe fab8 	bl	8002cb0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8004740:	9b01      	ldr	r3, [sp, #4]
 8004742:	2b00      	cmp	r3, #0
 8004744:	bf0c      	ite	eq
 8004746:	2301      	moveq	r3, #1
 8004748:	2300      	movne	r3, #0
 800474a:	b2db      	uxtb	r3, r3
 800474c:	2b00      	cmp	r3, #0
 800474e:	d002      	beq.n	8004756 <chMtxLockS+0x26>
 8004750:	4840      	ldr	r0, [pc, #256]	@ (8004854 <chMtxLockS+0x124>)
 8004752:	f7fe f8ed 	bl	8002930 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8004756:	9b01      	ldr	r3, [sp, #4]
 8004758:	689b      	ldr	r3, [r3, #8]
 800475a:	2b00      	cmp	r3, #0
 800475c:	d06c      	beq.n	8004838 <chMtxLockS+0x108>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 800475e:	9b01      	ldr	r3, [sp, #4]
 8004760:	689b      	ldr	r3, [r3, #8]
 8004762:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8004764:	e03b      	b.n	80047de <chMtxLockS+0xae>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8004766:	9b02      	ldr	r3, [sp, #8]
 8004768:	689a      	ldr	r2, [r3, #8]
 800476a:	9b03      	ldr	r3, [sp, #12]
 800476c:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800476e:	9b03      	ldr	r3, [sp, #12]
 8004770:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004774:	2b07      	cmp	r3, #7
 8004776:	d016      	beq.n	80047a6 <chMtxLockS+0x76>
 8004778:	2b07      	cmp	r3, #7
 800477a:	dc2e      	bgt.n	80047da <chMtxLockS+0xaa>
 800477c:	2b00      	cmp	r3, #0
 800477e:	d01f      	beq.n	80047c0 <chMtxLockS+0x90>
 8004780:	2b06      	cmp	r3, #6
 8004782:	d12a      	bne.n	80047da <chMtxLockS+0xaa>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004784:	9b03      	ldr	r3, [sp, #12]
 8004786:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004788:	461c      	mov	r4, r3
 800478a:	9b03      	ldr	r3, [sp, #12]
 800478c:	4618      	mov	r0, r3
 800478e:	f7ff ff0f 	bl	80045b0 <ch_queue_dequeue.lto_priv.2>
 8004792:	4603      	mov	r3, r0
 8004794:	4619      	mov	r1, r3
 8004796:	4620      	mov	r0, r4
 8004798:	f7ff ff5a 	bl	8004650 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          tp = tp->u.wtmtxp->owner;
 800479c:	9b03      	ldr	r3, [sp, #12]
 800479e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80047a0:	689b      	ldr	r3, [r3, #8]
 80047a2:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 80047a4:	e01b      	b.n	80047de <chMtxLockS+0xae>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 80047a6:	9b03      	ldr	r3, [sp, #12]
 80047a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80047aa:	461c      	mov	r4, r3
 80047ac:	9b03      	ldr	r3, [sp, #12]
 80047ae:	4618      	mov	r0, r3
 80047b0:	f7ff fefe 	bl	80045b0 <ch_queue_dequeue.lto_priv.2>
 80047b4:	4603      	mov	r3, r0
 80047b6:	4619      	mov	r1, r3
 80047b8:	4620      	mov	r0, r4
 80047ba:	f7ff ff49 	bl	8004650 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          break;
 80047be:	e00d      	b.n	80047dc <chMtxLockS+0xac>
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 80047c0:	9b03      	ldr	r3, [sp, #12]
 80047c2:	2201      	movs	r2, #1
 80047c4:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 80047c8:	9b03      	ldr	r3, [sp, #12]
 80047ca:	4618      	mov	r0, r3
 80047cc:	f7ff fef0 	bl	80045b0 <ch_queue_dequeue.lto_priv.2>
 80047d0:	4603      	mov	r3, r0
 80047d2:	4618      	mov	r0, r3
 80047d4:	f7fe ffa4 	bl	8003720 <chSchReadyI>
          break;
 80047d8:	e000      	b.n	80047dc <chMtxLockS+0xac>
        default:
          /* Nothing to do for other states.*/
          break;
 80047da:	bf00      	nop
        }
        break;
 80047dc:	e005      	b.n	80047ea <chMtxLockS+0xba>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 80047de:	9b03      	ldr	r3, [sp, #12]
 80047e0:	689a      	ldr	r2, [r3, #8]
 80047e2:	9b02      	ldr	r3, [sp, #8]
 80047e4:	689b      	ldr	r3, [r3, #8]
 80047e6:	429a      	cmp	r2, r3
 80047e8:	d3bd      	bcc.n	8004766 <chMtxLockS+0x36>
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
 80047ea:	9b01      	ldr	r3, [sp, #4]
 80047ec:	9a02      	ldr	r2, [sp, #8]
 80047ee:	4611      	mov	r1, r2
 80047f0:	4618      	mov	r0, r3
 80047f2:	f7ff ff2d 	bl	8004650 <ch_sch_prio_insert.lto_priv.0>
      currtp->u.wtmtxp = mp;
 80047f6:	9b02      	ldr	r3, [sp, #8]
 80047f8:	9a01      	ldr	r2, [sp, #4]
 80047fa:	629a      	str	r2, [r3, #40]	@ 0x28
      chSchGoSleepS(CH_STATE_WTMTX);
 80047fc:	2006      	movs	r0, #6
 80047fe:	f7fe ffaf 	bl	8003760 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 8004802:	9b01      	ldr	r3, [sp, #4]
 8004804:	689b      	ldr	r3, [r3, #8]
 8004806:	9a02      	ldr	r2, [sp, #8]
 8004808:	429a      	cmp	r2, r3
 800480a:	bf14      	ite	ne
 800480c:	2301      	movne	r3, #1
 800480e:	2300      	moveq	r3, #0
 8004810:	b2db      	uxtb	r3, r3
 8004812:	2b00      	cmp	r3, #0
 8004814:	d002      	beq.n	800481c <chMtxLockS+0xec>
 8004816:	480f      	ldr	r0, [pc, #60]	@ (8004854 <chMtxLockS+0x124>)
 8004818:	f7fe f88a 	bl	8002930 <chSysHalt>
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 800481c:	9b02      	ldr	r3, [sp, #8]
 800481e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8004820:	9a01      	ldr	r2, [sp, #4]
 8004822:	429a      	cmp	r2, r3
 8004824:	bf14      	ite	ne
 8004826:	2301      	movne	r3, #1
 8004828:	2300      	moveq	r3, #0
 800482a:	b2db      	uxtb	r3, r3
 800482c:	2b00      	cmp	r3, #0
 800482e:	d00d      	beq.n	800484c <chMtxLockS+0x11c>
 8004830:	4808      	ldr	r0, [pc, #32]	@ (8004854 <chMtxLockS+0x124>)
 8004832:	f7fe f87d 	bl	8002930 <chSysHalt>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 8004836:	e009      	b.n	800484c <chMtxLockS+0x11c>
    mp->owner = currtp;
 8004838:	9b01      	ldr	r3, [sp, #4]
 800483a:	9a02      	ldr	r2, [sp, #8]
 800483c:	609a      	str	r2, [r3, #8]
    mp->next = currtp->mtxlist;
 800483e:	9b02      	ldr	r3, [sp, #8]
 8004840:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8004842:	9b01      	ldr	r3, [sp, #4]
 8004844:	60da      	str	r2, [r3, #12]
    currtp->mtxlist = mp;
 8004846:	9b02      	ldr	r3, [sp, #8]
 8004848:	9a01      	ldr	r2, [sp, #4]
 800484a:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 800484c:	bf00      	nop
 800484e:	b004      	add	sp, #16
 8004850:	bd10      	pop	{r4, pc}
 8004852:	bf00      	nop
 8004854:	080057e0 	.word	0x080057e0
	...

08004860 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8004860:	b500      	push	{lr}
 8004862:	b087      	sub	sp, #28
 8004864:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004866:	f7ff ff1b 	bl	80046a0 <chThdGetSelfX.lto_priv.2>
 800486a:	9003      	str	r0, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800486c:	9b01      	ldr	r3, [sp, #4]
 800486e:	2b00      	cmp	r3, #0
 8004870:	bf0c      	ite	eq
 8004872:	2301      	moveq	r3, #1
 8004874:	2300      	movne	r3, #0
 8004876:	b2db      	uxtb	r3, r3
 8004878:	2b00      	cmp	r3, #0
 800487a:	d002      	beq.n	8004882 <chMtxUnlock+0x22>
 800487c:	4839      	ldr	r0, [pc, #228]	@ (8004964 <chMtxUnlock+0x104>)
 800487e:	f7fe f857 	bl	8002930 <chSysHalt>

  chSysLock();
 8004882:	f7ff fea5 	bl	80045d0 <chSysLock.lto_priv.9>

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8004886:	9b03      	ldr	r3, [sp, #12]
 8004888:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800488a:	2b00      	cmp	r3, #0
 800488c:	bf0c      	ite	eq
 800488e:	2301      	moveq	r3, #1
 8004890:	2300      	movne	r3, #0
 8004892:	b2db      	uxtb	r3, r3
 8004894:	2b00      	cmp	r3, #0
 8004896:	d002      	beq.n	800489e <chMtxUnlock+0x3e>
 8004898:	4832      	ldr	r0, [pc, #200]	@ (8004964 <chMtxUnlock+0x104>)
 800489a:	f7fe f849 	bl	8002930 <chSysHalt>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 800489e:	9b03      	ldr	r3, [sp, #12]
 80048a0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80048a2:	689b      	ldr	r3, [r3, #8]
 80048a4:	9a03      	ldr	r2, [sp, #12]
 80048a6:	429a      	cmp	r2, r3
 80048a8:	bf14      	ite	ne
 80048aa:	2301      	movne	r3, #1
 80048ac:	2300      	moveq	r3, #0
 80048ae:	b2db      	uxtb	r3, r3
 80048b0:	2b00      	cmp	r3, #0
 80048b2:	d002      	beq.n	80048ba <chMtxUnlock+0x5a>
 80048b4:	482b      	ldr	r0, [pc, #172]	@ (8004964 <chMtxUnlock+0x104>)
 80048b6:	f7fe f83b 	bl	8002930 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 80048ba:	9b03      	ldr	r3, [sp, #12]
 80048bc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80048be:	9a01      	ldr	r2, [sp, #4]
 80048c0:	429a      	cmp	r2, r3
 80048c2:	bf14      	ite	ne
 80048c4:	2301      	movne	r3, #1
 80048c6:	2300      	moveq	r3, #0
 80048c8:	b2db      	uxtb	r3, r3
 80048ca:	2b00      	cmp	r3, #0
 80048cc:	d002      	beq.n	80048d4 <chMtxUnlock+0x74>
 80048ce:	4825      	ldr	r0, [pc, #148]	@ (8004964 <chMtxUnlock+0x104>)
 80048d0:	f7fe f82e 	bl	8002930 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 80048d4:	9b01      	ldr	r3, [sp, #4]
 80048d6:	68da      	ldr	r2, [r3, #12]
 80048d8:	9b03      	ldr	r3, [sp, #12]
 80048da:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80048dc:	9801      	ldr	r0, [sp, #4]
 80048de:	f7ff fee7 	bl	80046b0 <chMtxQueueNotEmptyS>
 80048e2:	4603      	mov	r3, r0
 80048e4:	2b00      	cmp	r3, #0
 80048e6:	d034      	beq.n	8004952 <chMtxUnlock+0xf2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 80048e8:	9b03      	ldr	r3, [sp, #12]
 80048ea:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80048ec:	9304      	str	r3, [sp, #16]
      lmp = currtp->mtxlist;
 80048ee:	9b03      	ldr	r3, [sp, #12]
 80048f0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80048f2:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80048f4:	e012      	b.n	800491c <chMtxUnlock+0xbc>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80048f6:	9805      	ldr	r0, [sp, #20]
 80048f8:	f7ff feda 	bl	80046b0 <chMtxQueueNotEmptyS>
 80048fc:	4603      	mov	r3, r0
 80048fe:	2b00      	cmp	r3, #0
 8004900:	d009      	beq.n	8004916 <chMtxUnlock+0xb6>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 8004902:	9b05      	ldr	r3, [sp, #20]
 8004904:	681b      	ldr	r3, [r3, #0]
 8004906:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8004908:	9a04      	ldr	r2, [sp, #16]
 800490a:	429a      	cmp	r2, r3
 800490c:	d203      	bcs.n	8004916 <chMtxUnlock+0xb6>
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
 800490e:	9b05      	ldr	r3, [sp, #20]
 8004910:	681b      	ldr	r3, [r3, #0]
 8004912:	689b      	ldr	r3, [r3, #8]
 8004914:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 8004916:	9b05      	ldr	r3, [sp, #20]
 8004918:	68db      	ldr	r3, [r3, #12]
 800491a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 800491c:	9b05      	ldr	r3, [sp, #20]
 800491e:	2b00      	cmp	r3, #0
 8004920:	d1e9      	bne.n	80048f6 <chMtxUnlock+0x96>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 8004922:	9b03      	ldr	r3, [sp, #12]
 8004924:	9a04      	ldr	r2, [sp, #16]
 8004926:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
 8004928:	9b01      	ldr	r3, [sp, #4]
 800492a:	4618      	mov	r0, r3
 800492c:	f7ff fe28 	bl	8004580 <ch_queue_fifo_remove.lto_priv.2>
 8004930:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 8004932:	9b01      	ldr	r3, [sp, #4]
 8004934:	9a02      	ldr	r2, [sp, #8]
 8004936:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8004938:	9b02      	ldr	r3, [sp, #8]
 800493a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800493c:	9b01      	ldr	r3, [sp, #4]
 800493e:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8004940:	9b02      	ldr	r3, [sp, #8]
 8004942:	9a01      	ldr	r2, [sp, #4]
 8004944:	63da      	str	r2, [r3, #60]	@ 0x3c

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8004946:	9802      	ldr	r0, [sp, #8]
 8004948:	f7fe feea 	bl	8003720 <chSchReadyI>
      chSchRescheduleS();
 800494c:	f7fe ffd8 	bl	8003900 <chSchRescheduleS>
 8004950:	e002      	b.n	8004958 <chMtxUnlock+0xf8>
    }
    else {
      mp->owner = NULL;
 8004952:	9b01      	ldr	r3, [sp, #4]
 8004954:	2200      	movs	r2, #0
 8004956:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8004958:	f7ff fe4a 	bl	80045f0 <chSysUnlock.lto_priv.9>
}
 800495c:	bf00      	nop
 800495e:	b007      	add	sp, #28
 8004960:	f85d fb04 	ldr.w	pc, [sp], #4
 8004964:	080057ec 	.word	0x080057ec
	...

08004970 <chSysLock.lto_priv.15>:
static inline void chSysLock(void) {
 8004970:	b500      	push	{lr}
 8004972:	b083      	sub	sp, #12
 8004974:	2330      	movs	r3, #48	@ 0x30
 8004976:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004978:	9b01      	ldr	r3, [sp, #4]
 800497a:	f383 8811 	msr	BASEPRI, r3
}
 800497e:	bf00      	nop
}
 8004980:	bf00      	nop
  __dbg_check_lock();
 8004982:	f7fe f85d 	bl	8002a40 <__dbg_check_lock>
}
 8004986:	bf00      	nop
 8004988:	b003      	add	sp, #12
 800498a:	f85d fb04 	ldr.w	pc, [sp], #4
 800498e:	bf00      	nop

08004990 <chSysUnlock.lto_priv.15>:
static inline void chSysUnlock(void) {
 8004990:	b500      	push	{lr}
 8004992:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004994:	f7fe f87c 	bl	8002a90 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004998:	4b12      	ldr	r3, [pc, #72]	@ (80049e4 <chSysUnlock.lto_priv.15+0x54>)
 800499a:	681b      	ldr	r3, [r3, #0]
 800499c:	4a11      	ldr	r2, [pc, #68]	@ (80049e4 <chSysUnlock.lto_priv.15+0x54>)
 800499e:	4293      	cmp	r3, r2
 80049a0:	bf14      	ite	ne
 80049a2:	2301      	movne	r3, #1
 80049a4:	2300      	moveq	r3, #0
 80049a6:	b2db      	uxtb	r3, r3
 80049a8:	2b00      	cmp	r3, #0
 80049aa:	d00f      	beq.n	80049cc <chSysUnlock.lto_priv.15+0x3c>
 80049ac:	4b0d      	ldr	r3, [pc, #52]	@ (80049e4 <chSysUnlock.lto_priv.15+0x54>)
 80049ae:	68db      	ldr	r3, [r3, #12]
 80049b0:	689a      	ldr	r2, [r3, #8]
 80049b2:	4b0c      	ldr	r3, [pc, #48]	@ (80049e4 <chSysUnlock.lto_priv.15+0x54>)
 80049b4:	681b      	ldr	r3, [r3, #0]
 80049b6:	689b      	ldr	r3, [r3, #8]
 80049b8:	429a      	cmp	r2, r3
 80049ba:	bf34      	ite	cc
 80049bc:	2301      	movcc	r3, #1
 80049be:	2300      	movcs	r3, #0
 80049c0:	b2db      	uxtb	r3, r3
 80049c2:	2b00      	cmp	r3, #0
 80049c4:	d002      	beq.n	80049cc <chSysUnlock.lto_priv.15+0x3c>
 80049c6:	4808      	ldr	r0, [pc, #32]	@ (80049e8 <chSysUnlock.lto_priv.15+0x58>)
 80049c8:	f7fd ffb2 	bl	8002930 <chSysHalt>
 80049cc:	2300      	movs	r3, #0
 80049ce:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80049d0:	9b01      	ldr	r3, [sp, #4]
 80049d2:	f383 8811 	msr	BASEPRI, r3
}
 80049d6:	bf00      	nop
}
 80049d8:	bf00      	nop
}
 80049da:	bf00      	nop
 80049dc:	b003      	add	sp, #12
 80049de:	f85d fb04 	ldr.w	pc, [sp], #4
 80049e2:	bf00      	nop
 80049e4:	20000988 	.word	0x20000988
 80049e8:	0800580c 	.word	0x0800580c
 80049ec:	00000000 	.word	0x00000000

080049f0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 80049f0:	4b03      	ldr	r3, [pc, #12]	@ (8004a00 <__core_init+0x10>)
 80049f2:	4a04      	ldr	r2, [pc, #16]	@ (8004a04 <__core_init+0x14>)
 80049f4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 80049f6:	4b02      	ldr	r3, [pc, #8]	@ (8004a00 <__core_init+0x10>)
 80049f8:	4a03      	ldr	r2, [pc, #12]	@ (8004a08 <__core_init+0x18>)
 80049fa:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 80049fc:	bf00      	nop
 80049fe:	4770      	bx	lr
 8004a00:	20000b48 	.word	0x20000b48
 8004a04:	20000e38 	.word	0x20000e38
 8004a08:	20020000 	.word	0x20020000
 8004a0c:	00000000 	.word	0x00000000

08004a10 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8004a10:	b500      	push	{lr}
 8004a12:	b087      	sub	sp, #28
 8004a14:	9003      	str	r0, [sp, #12]
 8004a16:	9102      	str	r1, [sp, #8]
 8004a18:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 8004a1a:	f7fe f929 	bl	8002c70 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8004a1e:	9b02      	ldr	r3, [sp, #8]
 8004a20:	2b00      	cmp	r3, #0
 8004a22:	bf0c      	ite	eq
 8004a24:	2301      	moveq	r3, #1
 8004a26:	2300      	movne	r3, #0
 8004a28:	b2db      	uxtb	r3, r3
 8004a2a:	2b00      	cmp	r3, #0
 8004a2c:	d10a      	bne.n	8004a44 <chCoreAllocFromTopI+0x34>
 8004a2e:	9b02      	ldr	r3, [sp, #8]
 8004a30:	1e5a      	subs	r2, r3, #1
 8004a32:	9b02      	ldr	r3, [sp, #8]
 8004a34:	4013      	ands	r3, r2
 8004a36:	2b00      	cmp	r3, #0
 8004a38:	bf14      	ite	ne
 8004a3a:	2301      	movne	r3, #1
 8004a3c:	2300      	moveq	r3, #0
 8004a3e:	b2db      	uxtb	r3, r3
 8004a40:	2b00      	cmp	r3, #0
 8004a42:	d002      	beq.n	8004a4a <chCoreAllocFromTopI+0x3a>
 8004a44:	4812      	ldr	r0, [pc, #72]	@ (8004a90 <chCoreAllocFromTopI+0x80>)
 8004a46:	f7fd ff73 	bl	8002930 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8004a4a:	4b12      	ldr	r3, [pc, #72]	@ (8004a94 <chCoreAllocFromTopI+0x84>)
 8004a4c:	685a      	ldr	r2, [r3, #4]
 8004a4e:	9b03      	ldr	r3, [sp, #12]
 8004a50:	425b      	negs	r3, r3
 8004a52:	4413      	add	r3, r2
 8004a54:	461a      	mov	r2, r3
 8004a56:	9b02      	ldr	r3, [sp, #8]
 8004a58:	425b      	negs	r3, r3
 8004a5a:	4013      	ands	r3, r2
 8004a5c:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 8004a5e:	9b01      	ldr	r3, [sp, #4]
 8004a60:	425b      	negs	r3, r3
 8004a62:	9a05      	ldr	r2, [sp, #20]
 8004a64:	4413      	add	r3, r2
 8004a66:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8004a68:	4b0a      	ldr	r3, [pc, #40]	@ (8004a94 <chCoreAllocFromTopI+0x84>)
 8004a6a:	681b      	ldr	r3, [r3, #0]
 8004a6c:	9a04      	ldr	r2, [sp, #16]
 8004a6e:	429a      	cmp	r2, r3
 8004a70:	d304      	bcc.n	8004a7c <chCoreAllocFromTopI+0x6c>
 8004a72:	4b08      	ldr	r3, [pc, #32]	@ (8004a94 <chCoreAllocFromTopI+0x84>)
 8004a74:	685b      	ldr	r3, [r3, #4]
 8004a76:	9a04      	ldr	r2, [sp, #16]
 8004a78:	429a      	cmp	r2, r3
 8004a7a:	d901      	bls.n	8004a80 <chCoreAllocFromTopI+0x70>
    return NULL;
 8004a7c:	2300      	movs	r3, #0
 8004a7e:	e003      	b.n	8004a88 <chCoreAllocFromTopI+0x78>
  }

  ch_memcore.topmem = prev;
 8004a80:	4a04      	ldr	r2, [pc, #16]	@ (8004a94 <chCoreAllocFromTopI+0x84>)
 8004a82:	9b04      	ldr	r3, [sp, #16]
 8004a84:	6053      	str	r3, [r2, #4]

  return p;
 8004a86:	9b05      	ldr	r3, [sp, #20]
}
 8004a88:	4618      	mov	r0, r3
 8004a8a:	b007      	add	sp, #28
 8004a8c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a90:	080057f8 	.word	0x080057f8
 8004a94:	20000b48 	.word	0x20000b48
	...

08004aa0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8004aa0:	b500      	push	{lr}
 8004aa2:	b087      	sub	sp, #28
 8004aa4:	9003      	str	r0, [sp, #12]
 8004aa6:	9102      	str	r1, [sp, #8]
 8004aa8:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 8004aaa:	f7ff ff61 	bl	8004970 <chSysLock.lto_priv.15>
  p = chCoreAllocFromTopI(size, align, offset);
 8004aae:	9a01      	ldr	r2, [sp, #4]
 8004ab0:	9902      	ldr	r1, [sp, #8]
 8004ab2:	9803      	ldr	r0, [sp, #12]
 8004ab4:	f7ff ffac 	bl	8004a10 <chCoreAllocFromTopI>
 8004ab8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8004aba:	f7ff ff69 	bl	8004990 <chSysUnlock.lto_priv.15>

  return p;
 8004abe:	9b05      	ldr	r3, [sp, #20]
}
 8004ac0:	4618      	mov	r0, r3
 8004ac2:	b007      	add	sp, #28
 8004ac4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004ad0 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 8004ad0:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8004ad2:	4b07      	ldr	r3, [pc, #28]	@ (8004af0 <__heap_init+0x20>)
 8004ad4:	4a07      	ldr	r2, [pc, #28]	@ (8004af4 <__heap_init+0x24>)
 8004ad6:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8004ad8:	4b05      	ldr	r3, [pc, #20]	@ (8004af0 <__heap_init+0x20>)
 8004ada:	2200      	movs	r2, #0
 8004adc:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 8004ade:	4b04      	ldr	r3, [pc, #16]	@ (8004af0 <__heap_init+0x20>)
 8004ae0:	2200      	movs	r2, #0
 8004ae2:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8004ae4:	4804      	ldr	r0, [pc, #16]	@ (8004af8 <__heap_init+0x28>)
 8004ae6:	f7ff fdf3 	bl	80046d0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 8004aea:	bf00      	nop
 8004aec:	bd08      	pop	{r3, pc}
 8004aee:	bf00      	nop
 8004af0:	20000b50 	.word	0x20000b50
 8004af4:	08004aa1 	.word	0x08004aa1
 8004af8:	20000b5c 	.word	0x20000b5c
 8004afc:	00000000 	.word	0x00000000

08004b00 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8004b00:	b500      	push	{lr}
 8004b02:	b087      	sub	sp, #28
 8004b04:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8004b06:	9b01      	ldr	r3, [sp, #4]
 8004b08:	2b00      	cmp	r3, #0
 8004b0a:	bf0c      	ite	eq
 8004b0c:	2301      	moveq	r3, #1
 8004b0e:	2300      	movne	r3, #0
 8004b10:	b2db      	uxtb	r3, r3
 8004b12:	2b00      	cmp	r3, #0
 8004b14:	d109      	bne.n	8004b2a <chHeapFree+0x2a>
 8004b16:	9b01      	ldr	r3, [sp, #4]
 8004b18:	f003 0307 	and.w	r3, r3, #7
 8004b1c:	2b00      	cmp	r3, #0
 8004b1e:	bf14      	ite	ne
 8004b20:	2301      	movne	r3, #1
 8004b22:	2300      	moveq	r3, #0
 8004b24:	b2db      	uxtb	r3, r3
 8004b26:	2b00      	cmp	r3, #0
 8004b28:	d002      	beq.n	8004b30 <chHeapFree+0x30>
 8004b2a:	4843      	ldr	r0, [pc, #268]	@ (8004c38 <chHeapFree+0x138>)
 8004b2c:	f7fd ff00 	bl	8002930 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8004b30:	9b01      	ldr	r3, [sp, #4]
 8004b32:	3b08      	subs	r3, #8
 8004b34:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8004b36:	9b04      	ldr	r3, [sp, #16]
 8004b38:	681b      	ldr	r3, [r3, #0]
 8004b3a:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 8004b3c:	9b03      	ldr	r3, [sp, #12]
 8004b3e:	3304      	adds	r3, #4
 8004b40:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8004b42:	9b04      	ldr	r3, [sp, #16]
 8004b44:	685b      	ldr	r3, [r3, #4]
 8004b46:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8004b48:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8004b4a:	9b04      	ldr	r3, [sp, #16]
 8004b4c:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8004b4e:	9b03      	ldr	r3, [sp, #12]
 8004b50:	330c      	adds	r3, #12
 8004b52:	4618      	mov	r0, r3
 8004b54:	f7ff fddc 	bl	8004710 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8004b58:	9a04      	ldr	r2, [sp, #16]
 8004b5a:	9b05      	ldr	r3, [sp, #20]
 8004b5c:	429a      	cmp	r2, r3
 8004b5e:	bf2c      	ite	cs
 8004b60:	2301      	movcs	r3, #1
 8004b62:	2300      	movcc	r3, #0
 8004b64:	b2db      	uxtb	r3, r3
 8004b66:	2b00      	cmp	r3, #0
 8004b68:	d010      	beq.n	8004b8c <chHeapFree+0x8c>
 8004b6a:	9b05      	ldr	r3, [sp, #20]
 8004b6c:	685b      	ldr	r3, [r3, #4]
 8004b6e:	3301      	adds	r3, #1
 8004b70:	00db      	lsls	r3, r3, #3
 8004b72:	9a05      	ldr	r2, [sp, #20]
 8004b74:	4413      	add	r3, r2
 8004b76:	9a04      	ldr	r2, [sp, #16]
 8004b78:	429a      	cmp	r2, r3
 8004b7a:	bf34      	ite	cc
 8004b7c:	2301      	movcc	r3, #1
 8004b7e:	2300      	movcs	r3, #0
 8004b80:	b2db      	uxtb	r3, r3
 8004b82:	2b00      	cmp	r3, #0
 8004b84:	d002      	beq.n	8004b8c <chHeapFree+0x8c>
 8004b86:	482c      	ldr	r0, [pc, #176]	@ (8004c38 <chHeapFree+0x138>)
 8004b88:	f7fd fed2 	bl	8002930 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8004b8c:	9b03      	ldr	r3, [sp, #12]
 8004b8e:	3304      	adds	r3, #4
 8004b90:	9a05      	ldr	r2, [sp, #20]
 8004b92:	429a      	cmp	r2, r3
 8004b94:	d003      	beq.n	8004b9e <chHeapFree+0x9e>
 8004b96:	9a04      	ldr	r2, [sp, #16]
 8004b98:	9b05      	ldr	r3, [sp, #20]
 8004b9a:	429a      	cmp	r2, r3
 8004b9c:	d93d      	bls.n	8004c1a <chHeapFree+0x11a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8004b9e:	9b05      	ldr	r3, [sp, #20]
 8004ba0:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8004ba2:	2b00      	cmp	r3, #0
 8004ba4:	d004      	beq.n	8004bb0 <chHeapFree+0xb0>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8004ba6:	9b05      	ldr	r3, [sp, #20]
 8004ba8:	681b      	ldr	r3, [r3, #0]
 8004baa:	9a04      	ldr	r2, [sp, #16]
 8004bac:	429a      	cmp	r2, r3
 8004bae:	d234      	bcs.n	8004c1a <chHeapFree+0x11a>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8004bb0:	9b05      	ldr	r3, [sp, #20]
 8004bb2:	681a      	ldr	r2, [r3, #0]
 8004bb4:	9b04      	ldr	r3, [sp, #16]
 8004bb6:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8004bb8:	9b05      	ldr	r3, [sp, #20]
 8004bba:	9a04      	ldr	r2, [sp, #16]
 8004bbc:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8004bbe:	9b04      	ldr	r3, [sp, #16]
 8004bc0:	685b      	ldr	r3, [r3, #4]
 8004bc2:	3301      	adds	r3, #1
 8004bc4:	00db      	lsls	r3, r3, #3
 8004bc6:	9a04      	ldr	r2, [sp, #16]
 8004bc8:	441a      	add	r2, r3
 8004bca:	9b04      	ldr	r3, [sp, #16]
 8004bcc:	681b      	ldr	r3, [r3, #0]
 8004bce:	429a      	cmp	r2, r3
 8004bd0:	d10d      	bne.n	8004bee <chHeapFree+0xee>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8004bd2:	9b04      	ldr	r3, [sp, #16]
 8004bd4:	685a      	ldr	r2, [r3, #4]
 8004bd6:	9b04      	ldr	r3, [sp, #16]
 8004bd8:	681b      	ldr	r3, [r3, #0]
 8004bda:	685b      	ldr	r3, [r3, #4]
 8004bdc:	4413      	add	r3, r2
 8004bde:	1c5a      	adds	r2, r3, #1
 8004be0:	9b04      	ldr	r3, [sp, #16]
 8004be2:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8004be4:	9b04      	ldr	r3, [sp, #16]
 8004be6:	681b      	ldr	r3, [r3, #0]
 8004be8:	681a      	ldr	r2, [r3, #0]
 8004bea:	9b04      	ldr	r3, [sp, #16]
 8004bec:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8004bee:	9b05      	ldr	r3, [sp, #20]
 8004bf0:	685b      	ldr	r3, [r3, #4]
 8004bf2:	3301      	adds	r3, #1
 8004bf4:	00db      	lsls	r3, r3, #3
 8004bf6:	9a05      	ldr	r2, [sp, #20]
 8004bf8:	4413      	add	r3, r2
 8004bfa:	9a04      	ldr	r2, [sp, #16]
 8004bfc:	429a      	cmp	r2, r3
 8004bfe:	d110      	bne.n	8004c22 <chHeapFree+0x122>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8004c00:	9b05      	ldr	r3, [sp, #20]
 8004c02:	685a      	ldr	r2, [r3, #4]
 8004c04:	9b04      	ldr	r3, [sp, #16]
 8004c06:	685b      	ldr	r3, [r3, #4]
 8004c08:	4413      	add	r3, r2
 8004c0a:	1c5a      	adds	r2, r3, #1
 8004c0c:	9b05      	ldr	r3, [sp, #20]
 8004c0e:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8004c10:	9b04      	ldr	r3, [sp, #16]
 8004c12:	681a      	ldr	r2, [r3, #0]
 8004c14:	9b05      	ldr	r3, [sp, #20]
 8004c16:	601a      	str	r2, [r3, #0]
      }
      break;
 8004c18:	e003      	b.n	8004c22 <chHeapFree+0x122>
    }
    qp = H_NEXT(qp);
 8004c1a:	9b05      	ldr	r3, [sp, #20]
 8004c1c:	681b      	ldr	r3, [r3, #0]
 8004c1e:	9305      	str	r3, [sp, #20]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8004c20:	e79a      	b.n	8004b58 <chHeapFree+0x58>
      break;
 8004c22:	bf00      	nop
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8004c24:	9b03      	ldr	r3, [sp, #12]
 8004c26:	330c      	adds	r3, #12
 8004c28:	4618      	mov	r0, r3
 8004c2a:	f7ff fe19 	bl	8004860 <chMtxUnlock>

  return;
 8004c2e:	bf00      	nop
}
 8004c30:	b007      	add	sp, #28
 8004c32:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c36:	bf00      	nop
 8004c38:	08005818 	.word	0x08005818
 8004c3c:	00000000 	.word	0x00000000

08004c40 <chSysLock.lto_priv.16>:
static inline void chSysLock(void) {
 8004c40:	b500      	push	{lr}
 8004c42:	b083      	sub	sp, #12
 8004c44:	2330      	movs	r3, #48	@ 0x30
 8004c46:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004c48:	9b01      	ldr	r3, [sp, #4]
 8004c4a:	f383 8811 	msr	BASEPRI, r3
}
 8004c4e:	bf00      	nop
}
 8004c50:	bf00      	nop
  __dbg_check_lock();
 8004c52:	f7fd fef5 	bl	8002a40 <__dbg_check_lock>
}
 8004c56:	bf00      	nop
 8004c58:	b003      	add	sp, #12
 8004c5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c5e:	bf00      	nop

08004c60 <chSysUnlock.lto_priv.16>:
static inline void chSysUnlock(void) {
 8004c60:	b500      	push	{lr}
 8004c62:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004c64:	f7fd ff14 	bl	8002a90 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004c68:	4b12      	ldr	r3, [pc, #72]	@ (8004cb4 <chSysUnlock.lto_priv.16+0x54>)
 8004c6a:	681b      	ldr	r3, [r3, #0]
 8004c6c:	4a11      	ldr	r2, [pc, #68]	@ (8004cb4 <chSysUnlock.lto_priv.16+0x54>)
 8004c6e:	4293      	cmp	r3, r2
 8004c70:	bf14      	ite	ne
 8004c72:	2301      	movne	r3, #1
 8004c74:	2300      	moveq	r3, #0
 8004c76:	b2db      	uxtb	r3, r3
 8004c78:	2b00      	cmp	r3, #0
 8004c7a:	d00f      	beq.n	8004c9c <chSysUnlock.lto_priv.16+0x3c>
 8004c7c:	4b0d      	ldr	r3, [pc, #52]	@ (8004cb4 <chSysUnlock.lto_priv.16+0x54>)
 8004c7e:	68db      	ldr	r3, [r3, #12]
 8004c80:	689a      	ldr	r2, [r3, #8]
 8004c82:	4b0c      	ldr	r3, [pc, #48]	@ (8004cb4 <chSysUnlock.lto_priv.16+0x54>)
 8004c84:	681b      	ldr	r3, [r3, #0]
 8004c86:	689b      	ldr	r3, [r3, #8]
 8004c88:	429a      	cmp	r2, r3
 8004c8a:	bf34      	ite	cc
 8004c8c:	2301      	movcc	r3, #1
 8004c8e:	2300      	movcs	r3, #0
 8004c90:	b2db      	uxtb	r3, r3
 8004c92:	2b00      	cmp	r3, #0
 8004c94:	d002      	beq.n	8004c9c <chSysUnlock.lto_priv.16+0x3c>
 8004c96:	4808      	ldr	r0, [pc, #32]	@ (8004cb8 <chSysUnlock.lto_priv.16+0x58>)
 8004c98:	f7fd fe4a 	bl	8002930 <chSysHalt>
 8004c9c:	2300      	movs	r3, #0
 8004c9e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004ca0:	9b01      	ldr	r3, [sp, #4]
 8004ca2:	f383 8811 	msr	BASEPRI, r3
}
 8004ca6:	bf00      	nop
}
 8004ca8:	bf00      	nop
}
 8004caa:	bf00      	nop
 8004cac:	b003      	add	sp, #12
 8004cae:	f85d fb04 	ldr.w	pc, [sp], #4
 8004cb2:	bf00      	nop
 8004cb4:	20000988 	.word	0x20000988
 8004cb8:	0800583c 	.word	0x0800583c
 8004cbc:	00000000 	.word	0x00000000

08004cc0 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8004cc0:	b500      	push	{lr}
 8004cc2:	b085      	sub	sp, #20
 8004cc4:	9003      	str	r0, [sp, #12]
 8004cc6:	9102      	str	r1, [sp, #8]
 8004cc8:	9201      	str	r2, [sp, #4]
 8004cca:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 8004ccc:	9b03      	ldr	r3, [sp, #12]
 8004cce:	2b00      	cmp	r3, #0
 8004cd0:	bf0c      	ite	eq
 8004cd2:	2301      	moveq	r3, #1
 8004cd4:	2300      	movne	r3, #0
 8004cd6:	b2db      	uxtb	r3, r3
 8004cd8:	2b00      	cmp	r3, #0
 8004cda:	d107      	bne.n	8004cec <chPoolObjectInitAligned+0x2c>
 8004cdc:	9b02      	ldr	r3, [sp, #8]
 8004cde:	2b03      	cmp	r3, #3
 8004ce0:	bf94      	ite	ls
 8004ce2:	2301      	movls	r3, #1
 8004ce4:	2300      	movhi	r3, #0
 8004ce6:	b2db      	uxtb	r3, r3
 8004ce8:	2b00      	cmp	r3, #0
 8004cea:	d001      	beq.n	8004cf0 <chPoolObjectInitAligned+0x30>
 8004cec:	2301      	movs	r3, #1
 8004cee:	e000      	b.n	8004cf2 <chPoolObjectInitAligned+0x32>
 8004cf0:	2300      	movs	r3, #0
 8004cf2:	2b00      	cmp	r3, #0
 8004cf4:	d107      	bne.n	8004d06 <chPoolObjectInitAligned+0x46>
 8004cf6:	9b01      	ldr	r3, [sp, #4]
 8004cf8:	2b03      	cmp	r3, #3
 8004cfa:	bf94      	ite	ls
 8004cfc:	2301      	movls	r3, #1
 8004cfe:	2300      	movhi	r3, #0
 8004d00:	b2db      	uxtb	r3, r3
 8004d02:	2b00      	cmp	r3, #0
 8004d04:	d001      	beq.n	8004d0a <chPoolObjectInitAligned+0x4a>
 8004d06:	2301      	movs	r3, #1
 8004d08:	e000      	b.n	8004d0c <chPoolObjectInitAligned+0x4c>
 8004d0a:	2300      	movs	r3, #0
 8004d0c:	2b00      	cmp	r3, #0
 8004d0e:	d117      	bne.n	8004d40 <chPoolObjectInitAligned+0x80>
 8004d10:	9b01      	ldr	r3, [sp, #4]
 8004d12:	2b00      	cmp	r3, #0
 8004d14:	bf0c      	ite	eq
 8004d16:	2301      	moveq	r3, #1
 8004d18:	2300      	movne	r3, #0
 8004d1a:	b2db      	uxtb	r3, r3
 8004d1c:	2b00      	cmp	r3, #0
 8004d1e:	d10a      	bne.n	8004d36 <chPoolObjectInitAligned+0x76>
 8004d20:	9b01      	ldr	r3, [sp, #4]
 8004d22:	1e5a      	subs	r2, r3, #1
 8004d24:	9b01      	ldr	r3, [sp, #4]
 8004d26:	4013      	ands	r3, r2
 8004d28:	2b00      	cmp	r3, #0
 8004d2a:	bf14      	ite	ne
 8004d2c:	2301      	movne	r3, #1
 8004d2e:	2300      	moveq	r3, #0
 8004d30:	b2db      	uxtb	r3, r3
 8004d32:	2b00      	cmp	r3, #0
 8004d34:	d001      	beq.n	8004d3a <chPoolObjectInitAligned+0x7a>
 8004d36:	2301      	movs	r3, #1
 8004d38:	e000      	b.n	8004d3c <chPoolObjectInitAligned+0x7c>
 8004d3a:	2300      	movs	r3, #0
 8004d3c:	2b00      	cmp	r3, #0
 8004d3e:	d002      	beq.n	8004d46 <chPoolObjectInitAligned+0x86>
 8004d40:	4809      	ldr	r0, [pc, #36]	@ (8004d68 <chPoolObjectInitAligned+0xa8>)
 8004d42:	f7fd fdf5 	bl	8002930 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8004d46:	9b03      	ldr	r3, [sp, #12]
 8004d48:	2200      	movs	r2, #0
 8004d4a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8004d4c:	9b03      	ldr	r3, [sp, #12]
 8004d4e:	9a02      	ldr	r2, [sp, #8]
 8004d50:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8004d52:	9b03      	ldr	r3, [sp, #12]
 8004d54:	9a01      	ldr	r2, [sp, #4]
 8004d56:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8004d58:	9b03      	ldr	r3, [sp, #12]
 8004d5a:	9a00      	ldr	r2, [sp, #0]
 8004d5c:	60da      	str	r2, [r3, #12]
}
 8004d5e:	bf00      	nop
 8004d60:	b005      	add	sp, #20
 8004d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d66:	bf00      	nop
 8004d68:	08005824 	.word	0x08005824
 8004d6c:	00000000 	.word	0x00000000

08004d70 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8004d70:	b500      	push	{lr}
 8004d72:	b085      	sub	sp, #20
 8004d74:	9001      	str	r0, [sp, #4]
 8004d76:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8004d78:	9b00      	ldr	r3, [sp, #0]
 8004d7a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 8004d7c:	f7fd ff78 	bl	8002c70 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8004d80:	9b01      	ldr	r3, [sp, #4]
 8004d82:	2b00      	cmp	r3, #0
 8004d84:	bf0c      	ite	eq
 8004d86:	2301      	moveq	r3, #1
 8004d88:	2300      	movne	r3, #0
 8004d8a:	b2db      	uxtb	r3, r3
 8004d8c:	2b00      	cmp	r3, #0
 8004d8e:	d107      	bne.n	8004da0 <chPoolFreeI+0x30>
 8004d90:	9b00      	ldr	r3, [sp, #0]
 8004d92:	2b00      	cmp	r3, #0
 8004d94:	bf0c      	ite	eq
 8004d96:	2301      	moveq	r3, #1
 8004d98:	2300      	movne	r3, #0
 8004d9a:	b2db      	uxtb	r3, r3
 8004d9c:	2b00      	cmp	r3, #0
 8004d9e:	d001      	beq.n	8004da4 <chPoolFreeI+0x34>
 8004da0:	2301      	movs	r3, #1
 8004da2:	e000      	b.n	8004da6 <chPoolFreeI+0x36>
 8004da4:	2300      	movs	r3, #0
 8004da6:	2b00      	cmp	r3, #0
 8004da8:	d10b      	bne.n	8004dc2 <chPoolFreeI+0x52>
 8004daa:	9b01      	ldr	r3, [sp, #4]
 8004dac:	689b      	ldr	r3, [r3, #8]
 8004dae:	1e5a      	subs	r2, r3, #1
 8004db0:	9b00      	ldr	r3, [sp, #0]
 8004db2:	4013      	ands	r3, r2
 8004db4:	2b00      	cmp	r3, #0
 8004db6:	bf14      	ite	ne
 8004db8:	2301      	movne	r3, #1
 8004dba:	2300      	moveq	r3, #0
 8004dbc:	b2db      	uxtb	r3, r3
 8004dbe:	2b00      	cmp	r3, #0
 8004dc0:	d002      	beq.n	8004dc8 <chPoolFreeI+0x58>
 8004dc2:	4807      	ldr	r0, [pc, #28]	@ (8004de0 <chPoolFreeI+0x70>)
 8004dc4:	f7fd fdb4 	bl	8002930 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8004dc8:	9b01      	ldr	r3, [sp, #4]
 8004dca:	681a      	ldr	r2, [r3, #0]
 8004dcc:	9b03      	ldr	r3, [sp, #12]
 8004dce:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8004dd0:	9b01      	ldr	r3, [sp, #4]
 8004dd2:	9a03      	ldr	r2, [sp, #12]
 8004dd4:	601a      	str	r2, [r3, #0]
}
 8004dd6:	bf00      	nop
 8004dd8:	b005      	add	sp, #20
 8004dda:	f85d fb04 	ldr.w	pc, [sp], #4
 8004dde:	bf00      	nop
 8004de0:	08005848 	.word	0x08005848
	...

08004df0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8004df0:	b500      	push	{lr}
 8004df2:	b083      	sub	sp, #12
 8004df4:	9001      	str	r0, [sp, #4]
 8004df6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8004df8:	f7ff ff22 	bl	8004c40 <chSysLock.lto_priv.16>
  chPoolFreeI(mp, objp);
 8004dfc:	9900      	ldr	r1, [sp, #0]
 8004dfe:	9801      	ldr	r0, [sp, #4]
 8004e00:	f7ff ffb6 	bl	8004d70 <chPoolFreeI>
  chSysUnlock();
 8004e04:	f7ff ff2c 	bl	8004c60 <chSysUnlock.lto_priv.16>
}
 8004e08:	bf00      	nop
 8004e0a:	b003      	add	sp, #12
 8004e0c:	f85d fb04 	ldr.w	pc, [sp], #4

08004e10 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8004e10:	b500      	push	{lr}
 8004e12:	b083      	sub	sp, #12
 8004e14:	9001      	str	r0, [sp, #4]
 8004e16:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8004e18:	2200      	movs	r2, #0
 8004e1a:	9900      	ldr	r1, [sp, #0]
 8004e1c:	9801      	ldr	r0, [sp, #4]
 8004e1e:	f7ff fdf7 	bl	8004a10 <chCoreAllocFromTopI>
 8004e22:	4603      	mov	r3, r0
}
 8004e24:	4618      	mov	r0, r3
 8004e26:	b003      	add	sp, #12
 8004e28:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e2c:	0000      	movs	r0, r0
	...

08004e30 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8004e30:	b500      	push	{lr}
 8004e32:	b085      	sub	sp, #20
 8004e34:	9003      	str	r0, [sp, #12]
 8004e36:	9102      	str	r1, [sp, #8]
 8004e38:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8004e3a:	9b01      	ldr	r3, [sp, #4]
 8004e3c:	2204      	movs	r2, #4
 8004e3e:	9902      	ldr	r1, [sp, #8]
 8004e40:	9803      	ldr	r0, [sp, #12]
 8004e42:	f7ff ff3d 	bl	8004cc0 <chPoolObjectInitAligned>
}
 8004e46:	bf00      	nop
 8004e48:	b005      	add	sp, #20
 8004e4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e4e:	bf00      	nop

08004e50 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8004e50:	b082      	sub	sp, #8
 8004e52:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8004e54:	9b01      	ldr	r3, [sp, #4]
 8004e56:	9a01      	ldr	r2, [sp, #4]
 8004e58:	601a      	str	r2, [r3, #0]
}
 8004e5a:	bf00      	nop
 8004e5c:	b002      	add	sp, #8
 8004e5e:	4770      	bx	lr

08004e60 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8004e60:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8004e62:	4810      	ldr	r0, [pc, #64]	@ (8004ea4 <__factory_init+0x44>)
 8004e64:	f7ff fc34 	bl	80046d0 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8004e68:	480f      	ldr	r0, [pc, #60]	@ (8004ea8 <__factory_init+0x48>)
 8004e6a:	f7ff fff1 	bl	8004e50 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8004e6e:	4a0f      	ldr	r2, [pc, #60]	@ (8004eac <__factory_init+0x4c>)
 8004e70:	2114      	movs	r1, #20
 8004e72:	480f      	ldr	r0, [pc, #60]	@ (8004eb0 <__factory_init+0x50>)
 8004e74:	f7ff ffdc 	bl	8004e30 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8004e78:	480e      	ldr	r0, [pc, #56]	@ (8004eb4 <__factory_init+0x54>)
 8004e7a:	f7ff ffe9 	bl	8004e50 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8004e7e:	480e      	ldr	r0, [pc, #56]	@ (8004eb8 <__factory_init+0x58>)
 8004e80:	f7ff ffe6 	bl	8004e50 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8004e84:	4a09      	ldr	r2, [pc, #36]	@ (8004eac <__factory_init+0x4c>)
 8004e86:	211c      	movs	r1, #28
 8004e88:	480c      	ldr	r0, [pc, #48]	@ (8004ebc <__factory_init+0x5c>)
 8004e8a:	f7ff ffd1 	bl	8004e30 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8004e8e:	480c      	ldr	r0, [pc, #48]	@ (8004ec0 <__factory_init+0x60>)
 8004e90:	f7ff ffde 	bl	8004e50 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8004e94:	480b      	ldr	r0, [pc, #44]	@ (8004ec4 <__factory_init+0x64>)
 8004e96:	f7ff ffdb 	bl	8004e50 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 8004e9a:	480b      	ldr	r0, [pc, #44]	@ (8004ec8 <__factory_init+0x68>)
 8004e9c:	f7ff ffd8 	bl	8004e50 <dyn_list_init>
#endif
}
 8004ea0:	bf00      	nop
 8004ea2:	bd08      	pop	{r3, pc}
 8004ea4:	20000b6c 	.word	0x20000b6c
 8004ea8:	20000b7c 	.word	0x20000b7c
 8004eac:	08004e11 	.word	0x08004e11
 8004eb0:	20000b80 	.word	0x20000b80
 8004eb4:	20000b90 	.word	0x20000b90
 8004eb8:	20000b94 	.word	0x20000b94
 8004ebc:	20000b98 	.word	0x20000b98
 8004ec0:	20000ba8 	.word	0x20000ba8
 8004ec4:	20000bac 	.word	0x20000bac
 8004ec8:	20000bb0 	.word	0x20000bb0
 8004ecc:	00000000 	.word	0x00000000

08004ed0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8004ed0:	b084      	sub	sp, #16
 8004ed2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8004ed4:	9b01      	ldr	r3, [sp, #4]
 8004ed6:	f003 0307 	and.w	r3, r3, #7
 8004eda:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004edc:	4b0b      	ldr	r3, [pc, #44]	@ (8004f0c <__NVIC_SetPriorityGrouping+0x3c>)
 8004ede:	68db      	ldr	r3, [r3, #12]
 8004ee0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8004ee2:	9a02      	ldr	r2, [sp, #8]
 8004ee4:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8004ee8:	4013      	ands	r3, r2
 8004eea:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8004eec:	9b03      	ldr	r3, [sp, #12]
 8004eee:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8004ef0:	9b02      	ldr	r3, [sp, #8]
 8004ef2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8004ef4:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8004ef8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004efc:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 8004efe:	4a03      	ldr	r2, [pc, #12]	@ (8004f0c <__NVIC_SetPriorityGrouping+0x3c>)
 8004f00:	9b02      	ldr	r3, [sp, #8]
 8004f02:	60d3      	str	r3, [r2, #12]
}
 8004f04:	bf00      	nop
 8004f06:	b004      	add	sp, #16
 8004f08:	4770      	bx	lr
 8004f0a:	bf00      	nop
 8004f0c:	e000ed00 	.word	0xe000ed00

08004f10 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8004f10:	b082      	sub	sp, #8
 8004f12:	4603      	mov	r3, r0
 8004f14:	9100      	str	r1, [sp, #0]
 8004f16:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 8004f1a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004f1e:	2b00      	cmp	r3, #0
 8004f20:	db0a      	blt.n	8004f38 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004f22:	9b00      	ldr	r3, [sp, #0]
 8004f24:	b2da      	uxtb	r2, r3
 8004f26:	490c      	ldr	r1, [pc, #48]	@ (8004f58 <__NVIC_SetPriority+0x48>)
 8004f28:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004f2c:	0112      	lsls	r2, r2, #4
 8004f2e:	b2d2      	uxtb	r2, r2
 8004f30:	440b      	add	r3, r1
 8004f32:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8004f36:	e00b      	b.n	8004f50 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004f38:	9b00      	ldr	r3, [sp, #0]
 8004f3a:	b2da      	uxtb	r2, r3
 8004f3c:	4907      	ldr	r1, [pc, #28]	@ (8004f5c <__NVIC_SetPriority+0x4c>)
 8004f3e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004f42:	f003 030f 	and.w	r3, r3, #15
 8004f46:	3b04      	subs	r3, #4
 8004f48:	0112      	lsls	r2, r2, #4
 8004f4a:	b2d2      	uxtb	r2, r2
 8004f4c:	440b      	add	r3, r1
 8004f4e:	761a      	strb	r2, [r3, #24]
}
 8004f50:	bf00      	nop
 8004f52:	b002      	add	sp, #8
 8004f54:	4770      	bx	lr
 8004f56:	bf00      	nop
 8004f58:	e000e100 	.word	0xe000e100
 8004f5c:	e000ed00 	.word	0xe000ed00

08004f60 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004f60:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004f62:	f3ef 8309 	mrs	r3, PSP
 8004f66:	9300      	str	r3, [sp, #0]
  return(result);
 8004f68:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 8004f6a:	9303      	str	r3, [sp, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8004f6c:	9b03      	ldr	r3, [sp, #12]
 8004f6e:	3320      	adds	r3, #32
 8004f70:	9303      	str	r3, [sp, #12]
 8004f72:	9b03      	ldr	r3, [sp, #12]
 8004f74:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004f76:	9b01      	ldr	r3, [sp, #4]
 8004f78:	f383 8809 	msr	PSP, r3
}
 8004f7c:	bf00      	nop
 8004f7e:	2300      	movs	r3, #0
 8004f80:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004f82:	9b02      	ldr	r3, [sp, #8]
 8004f84:	f383 8811 	msr	BASEPRI, r3
}
 8004f88:	bf00      	nop
 8004f8a:	bf00      	nop
}
 8004f8c:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8004f8e:	bf00      	nop
 8004f90:	b004      	add	sp, #16
 8004f92:	4770      	bx	lr
	...

08004fa0 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004fa0:	b500      	push	{lr}
 8004fa2:	b085      	sub	sp, #20
 8004fa4:	9001      	str	r0, [sp, #4]
 8004fa6:	2330      	movs	r3, #48	@ 0x30
 8004fa8:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004faa:	9b03      	ldr	r3, [sp, #12]
 8004fac:	f383 8811 	msr	BASEPRI, r3
}
 8004fb0:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8004fb2:	b662      	cpsie	i
}
 8004fb4:	bf00      	nop
}
 8004fb6:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8004fb8:	2003      	movs	r0, #3
 8004fba:	f7ff ff89 	bl	8004ed0 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8004fbe:	4b0d      	ldr	r3, [pc, #52]	@ (8004ff4 <port_init+0x54>)
 8004fc0:	68db      	ldr	r3, [r3, #12]
 8004fc2:	4a0c      	ldr	r2, [pc, #48]	@ (8004ff4 <port_init+0x54>)
 8004fc4:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004fc8:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8004fca:	4b0b      	ldr	r3, [pc, #44]	@ (8004ff8 <port_init+0x58>)
 8004fcc:	681b      	ldr	r3, [r3, #0]
 8004fce:	4a0a      	ldr	r2, [pc, #40]	@ (8004ff8 <port_init+0x58>)
 8004fd0:	f043 0301 	orr.w	r3, r3, #1
 8004fd4:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8004fd6:	2102      	movs	r1, #2
 8004fd8:	f06f 0004 	mvn.w	r0, #4
 8004fdc:	f7ff ff98 	bl	8004f10 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004fe0:	2103      	movs	r1, #3
 8004fe2:	f06f 0001 	mvn.w	r0, #1
 8004fe6:	f7ff ff93 	bl	8004f10 <__NVIC_SetPriority>

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 8004fea:	bf00      	nop
 8004fec:	b005      	add	sp, #20
 8004fee:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ff2:	bf00      	nop
 8004ff4:	e000edf0 	.word	0xe000edf0
 8004ff8:	e0001000 	.word	0xe0001000
 8004ffc:	00000000 	.word	0x00000000

08005000 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 8005000:	b500      	push	{lr}
 8005002:	b087      	sub	sp, #28
 8005004:	2330      	movs	r3, #48	@ 0x30
 8005006:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005008:	9b03      	ldr	r3, [sp, #12]
 800500a:	f383 8811 	msr	BASEPRI, r3
}
 800500e:	bf00      	nop
}
 8005010:	bf00      	nop
}
 8005012:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8005014:	4b18      	ldr	r3, [pc, #96]	@ (8005078 <__port_irq_epilogue+0x78>)
 8005016:	685b      	ldr	r3, [r3, #4]
 8005018:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800501c:	2b00      	cmp	r3, #0
 800501e:	d020      	beq.n	8005062 <__port_irq_epilogue+0x62>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8005020:	f3ef 8309 	mrs	r3, PSP
 8005024:	9301      	str	r3, [sp, #4]
  return(result);
 8005026:	9b01      	ldr	r3, [sp, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 8005028:	9305      	str	r3, [sp, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 800502a:	9b05      	ldr	r3, [sp, #20]
 800502c:	3b20      	subs	r3, #32
 800502e:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 8005030:	9b05      	ldr	r3, [sp, #20]
 8005032:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8005034:	9b04      	ldr	r3, [sp, #16]
 8005036:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 800503a:	61da      	str	r2, [r3, #28]
 800503c:	9b05      	ldr	r3, [sp, #20]
 800503e:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8005040:	9b02      	ldr	r3, [sp, #8]
 8005042:	f383 8809 	msr	PSP, r3
}
 8005046:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8005048:	f7fe fc7a 	bl	8003940 <chSchIsPreemptionRequired>
 800504c:	4603      	mov	r3, r0
 800504e:	2b00      	cmp	r3, #0
 8005050:	d003      	beq.n	800505a <__port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8005052:	4a0a      	ldr	r2, [pc, #40]	@ (800507c <__port_irq_epilogue+0x7c>)
 8005054:	9b04      	ldr	r3, [sp, #16]
 8005056:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8005058:	e00b      	b.n	8005072 <__port_irq_epilogue+0x72>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 800505a:	4a09      	ldr	r2, [pc, #36]	@ (8005080 <__port_irq_epilogue+0x80>)
 800505c:	9b04      	ldr	r3, [sp, #16]
 800505e:	619a      	str	r2, [r3, #24]
    return;
 8005060:	e007      	b.n	8005072 <__port_irq_epilogue+0x72>
 8005062:	2300      	movs	r3, #0
 8005064:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005066:	9b00      	ldr	r3, [sp, #0]
 8005068:	f383 8811 	msr	BASEPRI, r3
}
 800506c:	bf00      	nop
}
 800506e:	bf00      	nop
}
 8005070:	bf00      	nop
  }
  port_unlock_from_isr();
}
 8005072:	b007      	add	sp, #28
 8005074:	f85d fb04 	ldr.w	pc, [sp], #4
 8005078:	e000ed00 	.word	0xe000ed00
 800507c:	080002e7 	.word	0x080002e7
 8005080:	080002f2 	.word	0x080002f2
	...

08005090 <portab_setup>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

void portab_setup(void) {
 8005090:	b508      	push	{r3, lr}

  /* ADC inputs.*/
  palSetPadMode(GPIOA, 0U, PAL_MODE_INPUT_ANALOG);
 8005092:	2203      	movs	r2, #3
 8005094:	2101      	movs	r1, #1
 8005096:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800509a:	f7fd f8d1 	bl	8002240 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 1U, PAL_MODE_INPUT_ANALOG);
 800509e:	2203      	movs	r2, #3
 80050a0:	2102      	movs	r1, #2
 80050a2:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80050a6:	f7fd f8cb 	bl	8002240 <_pal_lld_setgroupmode>
}
 80050aa:	bf00      	nop
 80050ac:	bd08      	pop	{r3, pc}
 80050ae:	bf00      	nop

080050b0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80050b0:	b082      	sub	sp, #8
 80050b2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 80050b4:	4b03      	ldr	r3, [pc, #12]	@ (80050c4 <chRegSetThreadName+0x14>)
 80050b6:	68db      	ldr	r3, [r3, #12]
 80050b8:	9a01      	ldr	r2, [sp, #4]
 80050ba:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 80050bc:	bf00      	nop
 80050be:	b002      	add	sp, #8
 80050c0:	4770      	bx	lr
 80050c2:	bf00      	nop
 80050c4:	20000988 	.word	0x20000988
	...

080050d0 <adccallback>:

/*
 * ADC streaming callback.
 */
size_t n= 0, nx = 0, ny = 0;
void adccallback(ADCDriver *adcp) {
 80050d0:	b082      	sub	sp, #8
 80050d2:	9001      	str	r0, [sp, #4]

  /* Updating counters.*/
  n++;
 80050d4:	4b0b      	ldr	r3, [pc, #44]	@ (8005104 <adccallback+0x34>)
 80050d6:	681b      	ldr	r3, [r3, #0]
 80050d8:	3301      	adds	r3, #1
 80050da:	4a0a      	ldr	r2, [pc, #40]	@ (8005104 <adccallback+0x34>)
 80050dc:	6013      	str	r3, [r2, #0]
  if (adcIsBufferComplete(adcp)) {
 80050de:	9b01      	ldr	r3, [sp, #4]
 80050e0:	781b      	ldrb	r3, [r3, #0]
 80050e2:	2b04      	cmp	r3, #4
 80050e4:	d105      	bne.n	80050f2 <adccallback+0x22>
    nx += 1;
 80050e6:	4b08      	ldr	r3, [pc, #32]	@ (8005108 <adccallback+0x38>)
 80050e8:	681b      	ldr	r3, [r3, #0]
 80050ea:	3301      	adds	r3, #1
 80050ec:	4a06      	ldr	r2, [pc, #24]	@ (8005108 <adccallback+0x38>)
 80050ee:	6013      	str	r3, [r2, #0]
 80050f0:	e004      	b.n	80050fc <adccallback+0x2c>
  }
  else {
    ny += 1;
 80050f2:	4b06      	ldr	r3, [pc, #24]	@ (800510c <adccallback+0x3c>)
 80050f4:	681b      	ldr	r3, [r3, #0]
 80050f6:	3301      	adds	r3, #1
 80050f8:	4a04      	ldr	r2, [pc, #16]	@ (800510c <adccallback+0x3c>)
 80050fa:	6013      	str	r3, [r2, #0]
  if ((n % 200) == 0U) {
#if defined(PORTAB_LINE_LED2)
    palToggleLine(PORTAB_LINE_LED2);
#endif
  }
}
 80050fc:	bf00      	nop
 80050fe:	b002      	add	sp, #8
 8005100:	4770      	bx	lr
 8005102:	bf00      	nop
 8005104:	20000cbc 	.word	0x20000cbc
 8005108:	20000cc0 	.word	0x20000cc0
 800510c:	20000cc4 	.word	0x20000cc4

08005110 <adcerrorcallback>:

/*
 * ADC errors callback, should never happen.
 */
void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8005110:	b500      	push	{lr}
 8005112:	b083      	sub	sp, #12
 8005114:	9001      	str	r0, [sp, #4]
 8005116:	9100      	str	r1, [sp, #0]

  (void)adcp;
  (void)err;

  chSysHalt("it happened");
 8005118:	4803      	ldr	r0, [pc, #12]	@ (8005128 <adcerrorcallback+0x18>)
 800511a:	f7fd fc09 	bl	8002930 <chSysHalt>
}
 800511e:	bf00      	nop
 8005120:	b003      	add	sp, #12
 8005122:	f85d fb04 	ldr.w	pc, [sp], #4
 8005126:	bf00      	nop
 8005128:	080055f8 	.word	0x080055f8
 800512c:	00000000 	.word	0x00000000

08005130 <Thread1>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED attached to TP1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8005130:	b500      	push	{lr}
 8005132:	b083      	sub	sp, #12
 8005134:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 8005136:	480a      	ldr	r0, [pc, #40]	@ (8005160 <Thread1+0x30>)
 8005138:	f7ff ffba 	bl	80050b0 <chRegSetThreadName>
  while (true) {
    palSetLine(PORTAB_LINE_LED1);
 800513c:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8005140:	2220      	movs	r2, #32
 8005142:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8005144:	f241 3088 	movw	r0, #5000	@ 0x1388
 8005148:	f7ff f82a 	bl	80041a0 <chThdSleep>
    palClearLine(PORTAB_LINE_LED1);
 800514c:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8005150:	2220      	movs	r2, #32
 8005152:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8005154:	f241 3088 	movw	r0, #5000	@ 0x1388
 8005158:	f7ff f822 	bl	80041a0 <chThdSleep>
    palSetLine(PORTAB_LINE_LED1);
 800515c:	bf00      	nop
 800515e:	e7ed      	b.n	800513c <Thread1+0xc>
 8005160:	08005604 	.word	0x08005604
	...

08005170 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8005170:	b500      	push	{lr}
 8005172:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8005174:	f7fb f91c 	bl	80003b0 <halInit>
  chSysInit();
 8005178:	f7fd fbaa 	bl	80028d0 <chSysInit>

  /* Board-dependent GPIO setup code.*/
  portab_setup();
 800517c:	f7ff ff88 	bl	8005090 <portab_setup>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8005180:	2300      	movs	r3, #0
 8005182:	9300      	str	r3, [sp, #0]
 8005184:	4b1b      	ldr	r3, [pc, #108]	@ (80051f4 <main+0x84>)
 8005186:	2280      	movs	r2, #128	@ 0x80
 8005188:	f44f 71b8 	mov.w	r1, #368	@ 0x170
 800518c:	481a      	ldr	r0, [pc, #104]	@ (80051f8 <main+0x88>)
 800518e:	f7fe fec7 	bl	8003f20 <chThdCreateStatic>

  /*
   * Starting PORTAB_ADC1 driver and the temperature sensor.
   */
  adcStart(&PORTAB_ADC1, &portab_adccfg1);
 8005192:	491a      	ldr	r1, [pc, #104]	@ (80051fc <main+0x8c>)
 8005194:	481a      	ldr	r0, [pc, #104]	@ (8005200 <main+0x90>)
 8005196:	f7fb fa63 	bl	8000660 <adcStart>
  adcSTM32EnableVREF(&PORTAB_ADC1);
 800519a:	4819      	ldr	r0, [pc, #100]	@ (8005200 <main+0x90>)
 800519c:	f7fc fdc0 	bl	8001d20 <adcSTM32EnableVREF>
  adcSTM32EnableTS(&PORTAB_ADC1);
 80051a0:	4817      	ldr	r0, [pc, #92]	@ (8005200 <main+0x90>)
 80051a2:	f7fc fdcd 	bl	8001d40 <adcSTM32EnableTS>

  /* Performing a one-shot conversion on two channels.*/
  adcConvert(&PORTAB_ADC1, &portab_adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
 80051a6:	2302      	movs	r3, #2
 80051a8:	4a16      	ldr	r2, [pc, #88]	@ (8005204 <main+0x94>)
 80051aa:	4917      	ldr	r1, [pc, #92]	@ (8005208 <main+0x98>)
 80051ac:	4814      	ldr	r0, [pc, #80]	@ (8005200 <main+0x90>)
 80051ae:	f7fb fb77 	bl	80008a0 <adcConvert>
  cacheBufferInvalidate(samples1, sizeof (samples1) / sizeof (adcsample_t));

  /*
   * Starting PORTAB_GPT1 driver, it is used for triggering the ADC.
   */
  gptStart(&PORTAB_GPT1, &portab_gptcfg1);
 80051b2:	4916      	ldr	r1, [pc, #88]	@ (800520c <main+0x9c>)
 80051b4:	4816      	ldr	r0, [pc, #88]	@ (8005210 <main+0xa0>)
 80051b6:	f7fb fc0b 	bl	80009d0 <gptStart>

  /*
   * Starting an ADC continuous conversion triggered with a period of
   * 1/10000 second.
   */
  adcStartConversion(&PORTAB_ADC1, &portab_adcgrpcfg2,
 80051ba:	2340      	movs	r3, #64	@ 0x40
 80051bc:	4a15      	ldr	r2, [pc, #84]	@ (8005214 <main+0xa4>)
 80051be:	4916      	ldr	r1, [pc, #88]	@ (8005218 <main+0xa8>)
 80051c0:	480f      	ldr	r0, [pc, #60]	@ (8005200 <main+0x90>)
 80051c2:	f7fb fa95 	bl	80006f0 <adcStartConversion>
                     samples2, ADC_GRP2_BUF_DEPTH);
  gptStartContinuous(&PORTAB_GPT1, 100U);
 80051c6:	2164      	movs	r1, #100	@ 0x64
 80051c8:	4811      	ldr	r0, [pc, #68]	@ (8005210 <main+0xa0>)
 80051ca:	f7fb fc51 	bl	8000a70 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the
   * conversion is stopped.
   */
  while (true) {
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 80051ce:	4b13      	ldr	r3, [pc, #76]	@ (800521c <main+0xac>)
 80051d0:	691b      	ldr	r3, [r3, #16]
 80051d2:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80051d6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80051da:	d105      	bne.n	80051e8 <main+0x78>
      gptStopTimer(&PORTAB_GPT1);
 80051dc:	480c      	ldr	r0, [pc, #48]	@ (8005210 <main+0xa0>)
 80051de:	f7fb fc87 	bl	8000af0 <gptStopTimer>
      adcStopConversion(&PORTAB_ADC1);
 80051e2:	4807      	ldr	r0, [pc, #28]	@ (8005200 <main+0x90>)
 80051e4:	f7fb fb14 	bl	8000810 <adcStopConversion>
    }
    chThdSleepMilliseconds(500);
 80051e8:	f241 3088 	movw	r0, #5000	@ 0x1388
 80051ec:	f7fe ffd8 	bl	80041a0 <chThdSleep>
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 80051f0:	e7ed      	b.n	80051ce <main+0x5e>
 80051f2:	bf00      	nop
 80051f4:	08005131 	.word	0x08005131
 80051f8:	20000cc8 	.word	0x20000cc8
 80051fc:	08005864 	.word	0x08005864
 8005200:	20000800 	.word	0x20000800
 8005204:	20000bb4 	.word	0x20000bb4
 8005208:	08005868 	.word	0x08005868
 800520c:	08005854 	.word	0x08005854
 8005210:	2000096c 	.word	0x2000096c
 8005214:	20000bbc 	.word	0x20000bbc
 8005218:	080058a8 	.word	0x080058a8
 800521c:	48000800 	.word	0x48000800
