
build/stm32g071rb_nucleo64/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000191 	.word	0x08000191
 8000008:	08004cb1 	.word	0x08004cb1
 800000c:	08000193 	.word	0x08000193
 8000010:	08000193 	.word	0x08000193
 8000014:	08000193 	.word	0x08000193
 8000018:	08000193 	.word	0x08000193
 800001c:	08000193 	.word	0x08000193
 8000020:	08000193 	.word	0x08000193
 8000024:	08000193 	.word	0x08000193
 8000028:	08000193 	.word	0x08000193
 800002c:	08000193 	.word	0x08000193
 8000030:	08000193 	.word	0x08000193
 8000034:	08000193 	.word	0x08000193
 8000038:	08000193 	.word	0x08000193
 800003c:	08000193 	.word	0x08000193
 8000040:	08000193 	.word	0x08000193
 8000044:	08000193 	.word	0x08000193
 8000048:	08000193 	.word	0x08000193
 800004c:	08000193 	.word	0x08000193
 8000050:	08000193 	.word	0x08000193
 8000054:	08000193 	.word	0x08000193
 8000058:	08000193 	.word	0x08000193
 800005c:	08000193 	.word	0x08000193
 8000060:	08000193 	.word	0x08000193
 8000064:	08001881 	.word	0x08001881
 8000068:	08000bc1 	.word	0x08000bc1
 800006c:	08000c11 	.word	0x08000c11
 8000070:	08001481 	.word	0x08001481
 8000074:	08000193 	.word	0x08000193
 8000078:	08000193 	.word	0x08000193
 800007c:	08000d11 	.word	0x08000d11
 8000080:	08000193 	.word	0x08000193
 8000084:	08000d71 	.word	0x08000d71
 8000088:	08000193 	.word	0x08000193
 800008c:	08000193 	.word	0x08000193
 8000090:	08000193 	.word	0x08000193
 8000094:	08000193 	.word	0x08000193
 8000098:	08000193 	.word	0x08000193
 800009c:	08000193 	.word	0x08000193
 80000a0:	08000193 	.word	0x08000193
 80000a4:	08000193 	.word	0x08000193
 80000a8:	08000193 	.word	0x08000193
 80000ac:	08000193 	.word	0x08000193
 80000b0:	08000193 	.word	0x08000193
 80000b4:	08000193 	.word	0x08000193
 80000b8:	08000193 	.word	0x08000193
 80000bc:	08000193 	.word	0x08000193

Disassembly of section .text:

080000c0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80000c0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80000c2:	4824      	ldr	r0, [pc, #144]	@ (8000154 <endfiniloop+0x6>)
                msr     MSP, r0
 80000c4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80000c8:	4823      	ldr	r0, [pc, #140]	@ (8000158 <endfiniloop+0xa>)
                msr     PSP, r0
 80000ca:	f380 8809 	msr	PSP, r0

                /* CPU mode initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 80000ce:	2002      	movs	r0, #2
                msr     CONTROL, r0
 80000d0:	f380 8814 	msr	CONTROL, r0
                isb
 80000d4:	f3bf 8f6f 	isb	sy
                str     r0, [r1]
#endif

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80000d8:	f000 f8d2 	bl	8000280 <__cpu_init>
#endif

                /* Early initialization..*/
                bl      __early_init
 80000dc:	f002 f808 	bl	80020f0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80000e0:	481e      	ldr	r0, [pc, #120]	@ (800015c <endfiniloop+0xe>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80000e2:	491f      	ldr	r1, [pc, #124]	@ (8000160 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 80000e4:	4a1b      	ldr	r2, [pc, #108]	@ (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
msloop:
                cmp     r1, r2
 80000e6:	4291      	cmp	r1, r2
                bge     endmsloop
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
                str     r0, [r1]
 80000ea:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000ec:	3104      	adds	r1, #4
                b       msloop
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80000f0:	491c      	ldr	r1, [pc, #112]	@ (8000164 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 80000f2:	4a19      	ldr	r2, [pc, #100]	@ (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
psloop:
                cmp     r1, r2
 80000f4:	4291      	cmp	r1, r2
                bge     endpsloop
 80000f6:	da02      	bge.n	80000fe <endpsloop>
                str     r0, [r1]
 80000f8:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000fa:	3104      	adds	r1, #4
                b       psloop
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 80000fe:	491a      	ldr	r1, [pc, #104]	@ (8000168 <endfiniloop+0x1a>)
                ldr     r2, =__data_base__
 8000100:	4a1a      	ldr	r2, [pc, #104]	@ (800016c <endfiniloop+0x1e>)
                ldr     r3, =__data_end__
 8000102:	4b1b      	ldr	r3, [pc, #108]	@ (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
dloop:
                cmp     r2, r3
 8000104:	429a      	cmp	r2, r3
                bge     enddloop
 8000106:	da04      	bge.n	8000112 <enddloop>
                ldr     r0, [r1]
 8000108:	6808      	ldr	r0, [r1, #0]
                str     r0, [r2]
 800010a:	6010      	str	r0, [r2, #0]
                adds    r1, #4
 800010c:	3104      	adds	r1, #4
                adds    r2, #4
 800010e:	3204      	adds	r2, #4
                b       dloop
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 8000112:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000114:	4917      	ldr	r1, [pc, #92]	@ (8000174 <endfiniloop+0x26>)
                ldr     r2, =__bss_end__
 8000116:	4a18      	ldr	r2, [pc, #96]	@ (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
bloop:
                cmp     r1, r2
 8000118:	4291      	cmp	r1, r2
                bge     endbloop
 800011a:	da02      	bge.n	8000122 <endbloop>
                str     r0, [r1]
 800011c:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 800011e:	3104      	adds	r1, #4
                b       bloop
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
endbloop:
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000122:	f000 f8c5 	bl	80002b0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000126:	f000 f8b3 	bl	8000290 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 800012a:	4c14      	ldr	r4, [pc, #80]	@ (800017c <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end__
 800012c:	4d14      	ldr	r5, [pc, #80]	@ (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
initloop:
                cmp     r4, r5
 800012e:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000130:	da03      	bge.n	800013a <endinitloop>
                ldr     r1, [r4]
 8000132:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000134:	4788      	blx	r1
                adds    r4, #4
 8000136:	3404      	adds	r4, #4
                b       initloop
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800013a:	f004 fe89 	bl	8004e50 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800013e:	4c11      	ldr	r4, [pc, #68]	@ (8000184 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end__
 8000140:	4d11      	ldr	r5, [pc, #68]	@ (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
finiloop:
                cmp     r4, r5
 8000142:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000144:	da03      	bge.n	800014e <endfiniloop>
                ldr     r1, [r4]
 8000146:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000148:	4788      	blx	r1
                adds    r4, #4
 800014a:	3404      	adds	r4, #4
                b       finiloop
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800014e:	490f      	ldr	r1, [pc, #60]	@ (800018c <endfiniloop+0x3e>)
                bx      r1
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 8000154:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000158:	20000600 	.word	0x20000600
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800015c:	55555555 	.word	0x55555555
                ldr     r1, =__main_stack_base__
 8000160:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000164:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000168:	08005554 	.word	0x08005554
                ldr     r2, =__data_base__
 800016c:	20000600 	.word	0x20000600
                ldr     r3, =__data_end__
 8000170:	20000600 	.word	0x20000600
                ldr     r1, =__bss_base__
 8000174:	20000600 	.word	0x20000600
                ldr     r2, =__bss_end__
 8000178:	200013d8 	.word	0x200013d8
                ldr     r4, =__init_array_base__
 800017c:	080000c0 	.word	0x080000c0
                ldr     r5, =__init_array_end__
 8000180:	080000c0 	.word	0x080000c0
                ldr     r4, =__fini_array_base__
 8000184:	080000c0 	.word	0x080000c0
                ldr     r5, =__fini_array_end__
 8000188:	080000c0 	.word	0x080000c0
                ldr     r1, =__default_exit
 800018c:	080002a1 	.word	0x080002a1

08000190 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000190:	e796      	b.n	80000c0 <_crt0_entry>

08000192 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000192:	f000 f800 	bl	8000196 <_unhandled_exception>

08000196 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000196:	e7fe      	b.n	8000196 <_unhandled_exception>

08000198 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, lr}
 8000198:	b5f0      	push	{r4, r5, r6, r7, lr}
                mov     r4, r8
 800019a:	4644      	mov	r4, r8
                mov     r5, r9
 800019c:	464d      	mov	r5, r9
                mov     r6, r10
 800019e:	4656      	mov	r6, sl
                mov     r7, r11
 80001a0:	465f      	mov	r7, fp
                push    {r4, r5, r6, r7}
 80001a2:	b4f0      	push	{r4, r5, r6, r7}
                
                mov     r3, sp
 80001a4:	466b      	mov	r3, sp
                str     r3, [r1, #CONTEXT_OFFSET]
 80001a6:	60cb      	str	r3, [r1, #12]
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80001a8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80001aa:	469d      	mov	sp, r3
                
                pop     {r4, r5, r6, r7}
 80001ac:	bcf0      	pop	{r4, r5, r6, r7}
                mov     r8, r4
 80001ae:	46a0      	mov	r8, r4
                mov     r9, r5
 80001b0:	46a9      	mov	r9, r5
                mov     r10, r6
 80001b2:	46b2      	mov	sl, r6
                mov     r11, r7
 80001b4:	46bb      	mov	fp, r7
                pop     {r4, r5, r6, r7, pc}
 80001b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b8 <__port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_thread_start
__port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80001b8:	f002 f8ba 	bl	8002330 <__dbg_check_unlock>
#endif
#if CH_DBG_STATISTICS
                bl      __stats_stop_measure_crit_thd
#endif
                cpsie   i
 80001bc:	b662      	cpsie	i
                mov     r0, r5
 80001be:	1c28      	adds	r0, r5, #0
                blx     r4
 80001c0:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80001c2:	2000      	movs	r0, #0
                bl      chThdExit
 80001c4:	f003 fe84 	bl	8003ed0 <chThdExit>

080001c8 <.zombies>:
.zombies:       b       .zombies
 80001c8:	e7fe      	b.n	80001c8 <.zombies>

080001ca <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 80001ca:	f002 f889 	bl	80022e0 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 80001ce:	f003 fa77 	bl	80036c0 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80001d2:	f002 f8ad 	bl	8002330 <__dbg_check_unlock>

080001d6 <__port_exit_from_isr>:
#if CH_DBG_STATISTICS
                bl      __stats_stop_measure_crit_thd
#endif
                .globl  __port_exit_from_isr
__port_exit_from_isr:
                ldr     r2, .L2
 80001d6:	4a02      	ldr	r2, [pc, #8]	@ (80001e0 <__port_exit_from_isr+0xa>)
                ldr     r3, .L3
 80001d8:	4b02      	ldr	r3, [pc, #8]	@ (80001e4 <__port_exit_from_isr+0xe>)
                str     r3, [r2, #0]
 80001da:	6013      	str	r3, [r2, #0]
#if CORTEX_ALTERNATE_SWITCH
                cpsie   i
#endif
.L1:            b       .L1
 80001dc:	e7fe      	b.n	80001dc <__port_exit_from_isr+0x6>
 80001de:	46c0      	nop			@ (mov r8, r8)
 80001e0:	e000ed04 	.word	0xe000ed04
 80001e4:	80000000 	.word	0x80000000

080001e8 <__udivsi3>:
 80001e8:	2900      	cmp	r1, #0
 80001ea:	d034      	beq.n	8000256 <.udivsi3_skip_div0_test+0x6a>

080001ec <.udivsi3_skip_div0_test>:
 80001ec:	2301      	movs	r3, #1
 80001ee:	2200      	movs	r2, #0
 80001f0:	b410      	push	{r4}
 80001f2:	4288      	cmp	r0, r1
 80001f4:	d32c      	bcc.n	8000250 <.udivsi3_skip_div0_test+0x64>
 80001f6:	2401      	movs	r4, #1
 80001f8:	0724      	lsls	r4, r4, #28
 80001fa:	42a1      	cmp	r1, r4
 80001fc:	d204      	bcs.n	8000208 <.udivsi3_skip_div0_test+0x1c>
 80001fe:	4281      	cmp	r1, r0
 8000200:	d202      	bcs.n	8000208 <.udivsi3_skip_div0_test+0x1c>
 8000202:	0109      	lsls	r1, r1, #4
 8000204:	011b      	lsls	r3, r3, #4
 8000206:	e7f8      	b.n	80001fa <.udivsi3_skip_div0_test+0xe>
 8000208:	00e4      	lsls	r4, r4, #3
 800020a:	42a1      	cmp	r1, r4
 800020c:	d204      	bcs.n	8000218 <.udivsi3_skip_div0_test+0x2c>
 800020e:	4281      	cmp	r1, r0
 8000210:	d202      	bcs.n	8000218 <.udivsi3_skip_div0_test+0x2c>
 8000212:	0049      	lsls	r1, r1, #1
 8000214:	005b      	lsls	r3, r3, #1
 8000216:	e7f8      	b.n	800020a <.udivsi3_skip_div0_test+0x1e>
 8000218:	4288      	cmp	r0, r1
 800021a:	d301      	bcc.n	8000220 <.udivsi3_skip_div0_test+0x34>
 800021c:	1a40      	subs	r0, r0, r1
 800021e:	431a      	orrs	r2, r3
 8000220:	084c      	lsrs	r4, r1, #1
 8000222:	42a0      	cmp	r0, r4
 8000224:	d302      	bcc.n	800022c <.udivsi3_skip_div0_test+0x40>
 8000226:	1b00      	subs	r0, r0, r4
 8000228:	085c      	lsrs	r4, r3, #1
 800022a:	4322      	orrs	r2, r4
 800022c:	088c      	lsrs	r4, r1, #2
 800022e:	42a0      	cmp	r0, r4
 8000230:	d302      	bcc.n	8000238 <.udivsi3_skip_div0_test+0x4c>
 8000232:	1b00      	subs	r0, r0, r4
 8000234:	089c      	lsrs	r4, r3, #2
 8000236:	4322      	orrs	r2, r4
 8000238:	08cc      	lsrs	r4, r1, #3
 800023a:	42a0      	cmp	r0, r4
 800023c:	d302      	bcc.n	8000244 <.udivsi3_skip_div0_test+0x58>
 800023e:	1b00      	subs	r0, r0, r4
 8000240:	08dc      	lsrs	r4, r3, #3
 8000242:	4322      	orrs	r2, r4
 8000244:	2800      	cmp	r0, #0
 8000246:	d003      	beq.n	8000250 <.udivsi3_skip_div0_test+0x64>
 8000248:	091b      	lsrs	r3, r3, #4
 800024a:	d001      	beq.n	8000250 <.udivsi3_skip_div0_test+0x64>
 800024c:	0909      	lsrs	r1, r1, #4
 800024e:	e7e3      	b.n	8000218 <.udivsi3_skip_div0_test+0x2c>
 8000250:	0010      	movs	r0, r2
 8000252:	bc10      	pop	{r4}
 8000254:	4770      	bx	lr
 8000256:	b501      	push	{r0, lr}
 8000258:	2000      	movs	r0, #0
 800025a:	f000 f80b 	bl	8000274 <__aeabi_idiv0>
 800025e:	bd02      	pop	{r1, pc}

08000260 <__aeabi_uidivmod>:
 8000260:	2900      	cmp	r1, #0
 8000262:	d0f8      	beq.n	8000256 <.udivsi3_skip_div0_test+0x6a>
 8000264:	b503      	push	{r0, r1, lr}
 8000266:	f7ff ffc1 	bl	80001ec <.udivsi3_skip_div0_test>
 800026a:	bc0e      	pop	{r1, r2, r3}
 800026c:	4342      	muls	r2, r0
 800026e:	1a89      	subs	r1, r1, r2
 8000270:	4718      	bx	r3
 8000272:	46c0      	nop			@ (mov r8, r8)

08000274 <__aeabi_idiv0>:
 8000274:	4770      	bx	lr
 8000276:	46c0      	nop			@ (mov r8, r8)
	...

08000280 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000280:	46c0      	nop			@ (mov r8, r8)
 8000282:	4770      	bx	lr
	...

08000290 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000290:	46c0      	nop			@ (mov r8, r8)
 8000292:	4770      	bx	lr
	...

080002a0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
     asm volatile ("nop");
 80002a0:	46c0      	nop			@ (mov r8, r8)
 80002a2:	e7fd      	b.n	80002a0 <__default_exit>
	...

080002b0 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80002b0:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80002b2:	4b17      	ldr	r3, [pc, #92]	@ (8000310 <__init_ram_areas+0x60>)
 80002b4:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 80002b6:	9b03      	ldr	r3, [sp, #12]
 80002b8:	681b      	ldr	r3, [r3, #0]
 80002ba:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 80002bc:	9b03      	ldr	r3, [sp, #12]
 80002be:	685b      	ldr	r3, [r3, #4]
 80002c0:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80002c2:	e009      	b.n	80002d8 <__init_ram_areas+0x28>
      *p = *tp;
 80002c4:	9b02      	ldr	r3, [sp, #8]
 80002c6:	681a      	ldr	r2, [r3, #0]
 80002c8:	9b01      	ldr	r3, [sp, #4]
 80002ca:	601a      	str	r2, [r3, #0]
      p++;
 80002cc:	9b01      	ldr	r3, [sp, #4]
 80002ce:	3304      	adds	r3, #4
 80002d0:	9301      	str	r3, [sp, #4]
      tp++;
 80002d2:	9b02      	ldr	r3, [sp, #8]
 80002d4:	3304      	adds	r3, #4
 80002d6:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 80002d8:	9b03      	ldr	r3, [sp, #12]
 80002da:	689b      	ldr	r3, [r3, #8]
 80002dc:	9a01      	ldr	r2, [sp, #4]
 80002de:	429a      	cmp	r2, r3
 80002e0:	d3f0      	bcc.n	80002c4 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80002e2:	e005      	b.n	80002f0 <__init_ram_areas+0x40>
      *p = 0;
 80002e4:	9b01      	ldr	r3, [sp, #4]
 80002e6:	2200      	movs	r2, #0
 80002e8:	601a      	str	r2, [r3, #0]
      p++;
 80002ea:	9b01      	ldr	r3, [sp, #4]
 80002ec:	3304      	adds	r3, #4
 80002ee:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 80002f0:	9b03      	ldr	r3, [sp, #12]
 80002f2:	68db      	ldr	r3, [r3, #12]
 80002f4:	9a01      	ldr	r2, [sp, #4]
 80002f6:	429a      	cmp	r2, r3
 80002f8:	d3f4      	bcc.n	80002e4 <__init_ram_areas+0x34>
    }
    rap++;
 80002fa:	9b03      	ldr	r3, [sp, #12]
 80002fc:	3310      	adds	r3, #16
 80002fe:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000300:	9a03      	ldr	r2, [sp, #12]
 8000302:	4b04      	ldr	r3, [pc, #16]	@ (8000314 <__init_ram_areas+0x64>)
 8000304:	429a      	cmp	r2, r3
 8000306:	d3d6      	bcc.n	80002b6 <__init_ram_areas+0x6>
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8000308:	46c0      	nop			@ (mov r8, r8)
 800030a:	46c0      	nop			@ (mov r8, r8)
 800030c:	b004      	add	sp, #16
 800030e:	4770      	bx	lr
 8000310:	08004f10 	.word	0x08004f10
 8000314:	08004f90 	.word	0x08004f90
	...

08000320 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000320:	46c0      	nop			@ (mov r8, r8)
 8000322:	4770      	bx	lr
	...

08000330 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000330:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000332:	f7ff fff5 	bl	8000320 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000336:	f000 feb3 	bl	80010a0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 800033a:	f001 fbf1 	bl	8001b20 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800033e:	f000 f937 	bl	80005b0 <adcInit>
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 8000342:	f000 fadd 	bl	8000900 <gptInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000346:	f001 fedb 	bl	8002100 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800034a:	f000 f851 	bl	80003f0 <stInit>
#endif
}
 800034e:	46c0      	nop			@ (mov r8, r8)
 8000350:	bd10      	pop	{r4, pc}
 8000352:	46c0      	nop			@ (mov r8, r8)
	...

08000360 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000360:	2380      	movs	r3, #128	@ 0x80
 8000362:	05db      	lsls	r3, r3, #23
 8000364:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000366:	b29b      	uxth	r3, r3
}
 8000368:	0018      	movs	r0, r3
 800036a:	4770      	bx	lr
 800036c:	0000      	movs	r0, r0
	...

08000370 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 8000370:	b082      	sub	sp, #8
 8000372:	0002      	movs	r2, r0
 8000374:	466b      	mov	r3, sp
 8000376:	3306      	adds	r3, #6
 8000378:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800037a:	2380      	movs	r3, #128	@ 0x80
 800037c:	05db      	lsls	r3, r3, #23
 800037e:	466a      	mov	r2, sp
 8000380:	3206      	adds	r2, #6
 8000382:	8812      	ldrh	r2, [r2, #0]
 8000384:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 8000386:	2380      	movs	r3, #128	@ 0x80
 8000388:	05db      	lsls	r3, r3, #23
 800038a:	2200      	movs	r2, #0
 800038c:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800038e:	2380      	movs	r3, #128	@ 0x80
 8000390:	05db      	lsls	r3, r3, #23
 8000392:	2202      	movs	r2, #2
 8000394:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 8000396:	46c0      	nop			@ (mov r8, r8)
 8000398:	b002      	add	sp, #8
 800039a:	4770      	bx	lr
 800039c:	0000      	movs	r0, r0
	...

080003a0 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 80003a0:	2380      	movs	r3, #128	@ 0x80
 80003a2:	05db      	lsls	r3, r3, #23
 80003a4:	2200      	movs	r2, #0
 80003a6:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 80003a8:	46c0      	nop			@ (mov r8, r8)
 80003aa:	4770      	bx	lr
 80003ac:	0000      	movs	r0, r0
	...

080003b0 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 80003b0:	b082      	sub	sp, #8
 80003b2:	0002      	movs	r2, r0
 80003b4:	466b      	mov	r3, sp
 80003b6:	3306      	adds	r3, #6
 80003b8:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003ba:	2380      	movs	r3, #128	@ 0x80
 80003bc:	05db      	lsls	r3, r3, #23
 80003be:	466a      	mov	r2, sp
 80003c0:	3206      	adds	r2, #6
 80003c2:	8812      	ldrh	r2, [r2, #0]
 80003c4:	635a      	str	r2, [r3, #52]	@ 0x34
}
 80003c6:	46c0      	nop			@ (mov r8, r8)
 80003c8:	b002      	add	sp, #8
 80003ca:	4770      	bx	lr
 80003cc:	0000      	movs	r0, r0
	...

080003d0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80003d0:	2380      	movs	r3, #128	@ 0x80
 80003d2:	05db      	lsls	r3, r3, #23
 80003d4:	68db      	ldr	r3, [r3, #12]
 80003d6:	2202      	movs	r2, #2
 80003d8:	4013      	ands	r3, r2
 80003da:	1e5a      	subs	r2, r3, #1
 80003dc:	4193      	sbcs	r3, r2
 80003de:	b2db      	uxtb	r3, r3
}
 80003e0:	0018      	movs	r0, r3
 80003e2:	4770      	bx	lr
	...

080003f0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80003f0:	b510      	push	{r4, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 80003f2:	f001 fc9d 	bl	8001d30 <st_lld_init>
}
 80003f6:	46c0      	nop			@ (mov r8, r8)
 80003f8:	bd10      	pop	{r4, pc}
 80003fa:	46c0      	nop			@ (mov r8, r8)
 80003fc:	0000      	movs	r0, r0
	...

08000400 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 8000400:	b510      	push	{r4, lr}

  return st_lld_get_counter();
 8000402:	f7ff ffad 	bl	8000360 <st_lld_get_counter>
 8000406:	0003      	movs	r3, r0
}
 8000408:	0018      	movs	r0, r3
 800040a:	bd10      	pop	{r4, pc}
 800040c:	0000      	movs	r0, r0
	...

08000410 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000410:	b500      	push	{lr}
 8000412:	b083      	sub	sp, #12
 8000414:	0002      	movs	r2, r0
 8000416:	466b      	mov	r3, sp
 8000418:	3306      	adds	r3, #6
 800041a:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800041c:	f000 f840 	bl	80004a0 <stIsAlarmActive>
 8000420:	1e03      	subs	r3, r0, #0
 8000422:	d003      	beq.n	800042c <stStartAlarm+0x1c>
 8000424:	4b06      	ldr	r3, [pc, #24]	@ (8000440 <stStartAlarm+0x30>)
 8000426:	0018      	movs	r0, r3
 8000428:	f001 feea 	bl	8002200 <chSysHalt>

  st_lld_start_alarm(abstime);
 800042c:	466b      	mov	r3, sp
 800042e:	3306      	adds	r3, #6
 8000430:	881b      	ldrh	r3, [r3, #0]
 8000432:	0018      	movs	r0, r3
 8000434:	f7ff ff9c 	bl	8000370 <st_lld_start_alarm>
}
 8000438:	46c0      	nop			@ (mov r8, r8)
 800043a:	b003      	add	sp, #12
 800043c:	bd00      	pop	{pc}
 800043e:	46c0      	nop			@ (mov r8, r8)
 8000440:	08004f90 	.word	0x08004f90
	...

08000450 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000450:	b510      	push	{r4, lr}

  st_lld_stop_alarm();
 8000452:	f7ff ffa5 	bl	80003a0 <st_lld_stop_alarm>
}
 8000456:	46c0      	nop			@ (mov r8, r8)
 8000458:	bd10      	pop	{r4, pc}
 800045a:	46c0      	nop			@ (mov r8, r8)
 800045c:	0000      	movs	r0, r0
	...

08000460 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000460:	b500      	push	{lr}
 8000462:	b083      	sub	sp, #12
 8000464:	0002      	movs	r2, r0
 8000466:	466b      	mov	r3, sp
 8000468:	3306      	adds	r3, #6
 800046a:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800046c:	f000 f818 	bl	80004a0 <stIsAlarmActive>
 8000470:	0003      	movs	r3, r0
 8000472:	001a      	movs	r2, r3
 8000474:	2301      	movs	r3, #1
 8000476:	4053      	eors	r3, r2
 8000478:	b2db      	uxtb	r3, r3
 800047a:	2b00      	cmp	r3, #0
 800047c:	d003      	beq.n	8000486 <stSetAlarm+0x26>
 800047e:	4b06      	ldr	r3, [pc, #24]	@ (8000498 <stSetAlarm+0x38>)
 8000480:	0018      	movs	r0, r3
 8000482:	f001 febd 	bl	8002200 <chSysHalt>

  st_lld_set_alarm(abstime);
 8000486:	466b      	mov	r3, sp
 8000488:	3306      	adds	r3, #6
 800048a:	881b      	ldrh	r3, [r3, #0]
 800048c:	0018      	movs	r0, r3
 800048e:	f7ff ff8f 	bl	80003b0 <st_lld_set_alarm>
}
 8000492:	46c0      	nop			@ (mov r8, r8)
 8000494:	b003      	add	sp, #12
 8000496:	bd00      	pop	{pc}
 8000498:	08004fa0 	.word	0x08004fa0
 800049c:	00000000 	.word	0x00000000

080004a0 <stIsAlarmActive>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @api
 */
bool stIsAlarmActive(void) {
 80004a0:	b510      	push	{r4, lr}

  return st_lld_is_alarm_active();
 80004a2:	f7ff ff95 	bl	80003d0 <st_lld_is_alarm_active>
 80004a6:	0003      	movs	r3, r0
}
 80004a8:	0018      	movs	r0, r3
 80004aa:	bd10      	pop	{r4, pc}
 80004ac:	0000      	movs	r0, r0
	...

080004b0 <port_lock.lto_priv.2>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004b0:	b672      	cpsid	i
}
 80004b2:	46c0      	nop			@ (mov r8, r8)
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80004b4:	46c0      	nop			@ (mov r8, r8)
 80004b6:	4770      	bx	lr
	...

080004c0 <port_unlock.lto_priv.2>:
  __ASM volatile ("cpsie i" : : : "memory");
 80004c0:	b662      	cpsie	i
}
 80004c2:	46c0      	nop			@ (mov r8, r8)
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80004c4:	46c0      	nop			@ (mov r8, r8)
 80004c6:	4770      	bx	lr
	...

080004d0 <chSysLock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 80004d0:	b510      	push	{r4, lr}

  port_lock();
 80004d2:	f7ff ffed 	bl	80004b0 <port_lock.lto_priv.2>
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 80004d6:	f001 ff03 	bl	80022e0 <__dbg_check_lock>
}
 80004da:	46c0      	nop			@ (mov r8, r8)
 80004dc:	bd10      	pop	{r4, pc}
 80004de:	46c0      	nop			@ (mov r8, r8)

080004e0 <chSysUnlock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80004e0:	b510      	push	{r4, lr}

  __dbg_check_unlock();
 80004e2:	f001 ff25 	bl	8002330 <__dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80004e6:	4b0e      	ldr	r3, [pc, #56]	@ (8000520 <chSysUnlock.lto_priv.2+0x40>)
 80004e8:	681a      	ldr	r2, [r3, #0]
 80004ea:	4b0d      	ldr	r3, [pc, #52]	@ (8000520 <chSysUnlock.lto_priv.2+0x40>)
 80004ec:	1ad3      	subs	r3, r2, r3
 80004ee:	1e5a      	subs	r2, r3, #1
 80004f0:	4193      	sbcs	r3, r2
 80004f2:	b2db      	uxtb	r3, r3
 80004f4:	2b00      	cmp	r3, #0
 80004f6:	d00f      	beq.n	8000518 <chSysUnlock.lto_priv.2+0x38>
 80004f8:	4b09      	ldr	r3, [pc, #36]	@ (8000520 <chSysUnlock.lto_priv.2+0x40>)
 80004fa:	68db      	ldr	r3, [r3, #12]
 80004fc:	689a      	ldr	r2, [r3, #8]
 80004fe:	4b08      	ldr	r3, [pc, #32]	@ (8000520 <chSysUnlock.lto_priv.2+0x40>)
 8000500:	681b      	ldr	r3, [r3, #0]
 8000502:	689b      	ldr	r3, [r3, #8]
 8000504:	429a      	cmp	r2, r3
 8000506:	419b      	sbcs	r3, r3
 8000508:	425b      	negs	r3, r3
 800050a:	b2db      	uxtb	r3, r3
 800050c:	2b00      	cmp	r3, #0
 800050e:	d003      	beq.n	8000518 <chSysUnlock.lto_priv.2+0x38>
 8000510:	4b04      	ldr	r3, [pc, #16]	@ (8000524 <chSysUnlock.lto_priv.2+0x44>)
 8000512:	0018      	movs	r0, r3
 8000514:	f001 fe74 	bl	8002200 <chSysHalt>
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
 8000518:	f7ff ffd2 	bl	80004c0 <port_unlock.lto_priv.2>
}
 800051c:	46c0      	nop			@ (mov r8, r8)
 800051e:	bd10      	pop	{r4, pc}
 8000520:	20000690 	.word	0x20000690
 8000524:	08004fb8 	.word	0x08004fb8
	...

08000530 <osalSysLock.lto_priv.2>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000530:	b510      	push	{r4, lr}

  chSysLock();
 8000532:	f7ff ffcd 	bl	80004d0 <chSysLock.lto_priv.2>
}
 8000536:	46c0      	nop			@ (mov r8, r8)
 8000538:	bd10      	pop	{r4, pc}
 800053a:	46c0      	nop			@ (mov r8, r8)
 800053c:	0000      	movs	r0, r0
	...

08000540 <osalSysUnlock.lto_priv.2>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8000540:	b510      	push	{r4, lr}

  chSysUnlock();
 8000542:	f7ff ffcd 	bl	80004e0 <chSysUnlock.lto_priv.2>
}
 8000546:	46c0      	nop			@ (mov r8, r8)
 8000548:	bd10      	pop	{r4, pc}
 800054a:	46c0      	nop			@ (mov r8, r8)
 800054c:	0000      	movs	r0, r0
	...

08000550 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8000550:	b500      	push	{lr}
 8000552:	b083      	sub	sp, #12
 8000554:	9001      	str	r0, [sp, #4]

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8000556:	2301      	movs	r3, #1
 8000558:	425a      	negs	r2, r3
 800055a:	9b01      	ldr	r3, [sp, #4]
 800055c:	0011      	movs	r1, r2
 800055e:	0018      	movs	r0, r3
 8000560:	f003 fd16 	bl	8003f90 <chThdSuspendTimeoutS>
 8000564:	0003      	movs	r3, r0
}
 8000566:	0018      	movs	r0, r3
 8000568:	b003      	add	sp, #12
 800056a:	bd00      	pop	{pc}
 800056c:	0000      	movs	r0, r0
	...

08000570 <osalThreadResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 8000570:	b500      	push	{lr}
 8000572:	b083      	sub	sp, #12
 8000574:	9001      	str	r0, [sp, #4]
 8000576:	9100      	str	r1, [sp, #0]

  chThdResumeS(trp, msg);
 8000578:	9a00      	ldr	r2, [sp, #0]
 800057a:	9b01      	ldr	r3, [sp, #4]
 800057c:	0011      	movs	r1, r2
 800057e:	0018      	movs	r0, r3
 8000580:	f003 fd5e 	bl	8004040 <chThdResumeS>
}
 8000584:	46c0      	nop			@ (mov r8, r8)
 8000586:	b003      	add	sp, #12
 8000588:	bd00      	pop	{pc}
 800058a:	46c0      	nop			@ (mov r8, r8)
 800058c:	0000      	movs	r0, r0
	...

08000590 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8000590:	b500      	push	{lr}
 8000592:	b083      	sub	sp, #12
 8000594:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8000596:	9b01      	ldr	r3, [sp, #4]
 8000598:	0018      	movs	r0, r3
 800059a:	f003 ff01 	bl	80043a0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800059e:	46c0      	nop			@ (mov r8, r8)
 80005a0:	b003      	add	sp, #12
 80005a2:	bd00      	pop	{pc}
	...

080005b0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 80005b0:	b510      	push	{r4, lr}

  adc_lld_init();
 80005b2:	f000 ff85 	bl	80014c0 <adc_lld_init>
}
 80005b6:	46c0      	nop			@ (mov r8, r8)
 80005b8:	bd10      	pop	{r4, pc}
 80005ba:	46c0      	nop			@ (mov r8, r8)
 80005bc:	0000      	movs	r0, r0
	...

080005c0 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 80005c0:	b500      	push	{lr}
 80005c2:	b083      	sub	sp, #12
 80005c4:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 80005c6:	9b01      	ldr	r3, [sp, #4]
 80005c8:	2201      	movs	r2, #1
 80005ca:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 80005cc:	9b01      	ldr	r3, [sp, #4]
 80005ce:	2200      	movs	r2, #0
 80005d0:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 80005d2:	9b01      	ldr	r3, [sp, #4]
 80005d4:	2200      	movs	r2, #0
 80005d6:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 80005d8:	9b01      	ldr	r3, [sp, #4]
 80005da:	2200      	movs	r2, #0
 80005dc:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 80005de:	9b01      	ldr	r3, [sp, #4]
 80005e0:	2200      	movs	r2, #0
 80005e2:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 80005e4:	9b01      	ldr	r3, [sp, #4]
 80005e6:	2200      	movs	r2, #0
 80005e8:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 80005ea:	9b01      	ldr	r3, [sp, #4]
 80005ec:	3318      	adds	r3, #24
 80005ee:	0018      	movs	r0, r3
 80005f0:	f7ff ffce 	bl	8000590 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 80005f4:	46c0      	nop			@ (mov r8, r8)
 80005f6:	b003      	add	sp, #12
 80005f8:	bd00      	pop	{pc}
 80005fa:	46c0      	nop			@ (mov r8, r8)
 80005fc:	0000      	movs	r0, r0
	...

08000600 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8000600:	b500      	push	{lr}
 8000602:	b085      	sub	sp, #20
 8000604:	9001      	str	r0, [sp, #4]
 8000606:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(adcp != NULL);
 8000608:	9b01      	ldr	r3, [sp, #4]
 800060a:	425a      	negs	r2, r3
 800060c:	4153      	adcs	r3, r2
 800060e:	b2db      	uxtb	r3, r3
 8000610:	2b00      	cmp	r3, #0
 8000612:	d003      	beq.n	800061c <adcStart+0x1c>
 8000614:	4b19      	ldr	r3, [pc, #100]	@ (800067c <adcStart+0x7c>)
 8000616:	0018      	movs	r0, r3
 8000618:	f001 fdf2 	bl	8002200 <chSysHalt>

  osalSysLock();
 800061c:	f7ff ff88 	bl	8000530 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 8000620:	9b01      	ldr	r3, [sp, #4]
 8000622:	781b      	ldrb	r3, [r3, #0]
 8000624:	3b01      	subs	r3, #1
 8000626:	1e5a      	subs	r2, r3, #1
 8000628:	4193      	sbcs	r3, r2
 800062a:	b2db      	uxtb	r3, r3
 800062c:	2b00      	cmp	r3, #0
 800062e:	d00b      	beq.n	8000648 <adcStart+0x48>
 8000630:	9b01      	ldr	r3, [sp, #4]
 8000632:	781b      	ldrb	r3, [r3, #0]
 8000634:	3b02      	subs	r3, #2
 8000636:	1e5a      	subs	r2, r3, #1
 8000638:	4193      	sbcs	r3, r2
 800063a:	b2db      	uxtb	r3, r3
 800063c:	2b00      	cmp	r3, #0
 800063e:	d003      	beq.n	8000648 <adcStart+0x48>
 8000640:	4b0e      	ldr	r3, [pc, #56]	@ (800067c <adcStart+0x7c>)
 8000642:	0018      	movs	r0, r3
 8000644:	f001 fddc 	bl	8002200 <chSysHalt>
                "invalid state");
  adcp->config = config;
 8000648:	9b01      	ldr	r3, [sp, #4]
 800064a:	9a00      	ldr	r2, [sp, #0]
 800064c:	605a      	str	r2, [r3, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
#else
  adc_lld_start(adcp);
 800064e:	9b01      	ldr	r3, [sp, #4]
 8000650:	0018      	movs	r0, r3
 8000652:	f000 ff55 	bl	8001500 <adc_lld_start>
  msg = HAL_RET_SUCCESS;
 8000656:	2300      	movs	r3, #0
 8000658:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 800065a:	9b03      	ldr	r3, [sp, #12]
 800065c:	2b00      	cmp	r3, #0
 800065e:	d103      	bne.n	8000668 <adcStart+0x68>
    adcp->state = ADC_READY;
 8000660:	9b01      	ldr	r3, [sp, #4]
 8000662:	2202      	movs	r2, #2
 8000664:	701a      	strb	r2, [r3, #0]
 8000666:	e002      	b.n	800066e <adcStart+0x6e>
  }
  else {
    adcp->state = ADC_STOP;
 8000668:	9b01      	ldr	r3, [sp, #4]
 800066a:	2201      	movs	r2, #1
 800066c:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 800066e:	f7ff ff67 	bl	8000540 <osalSysUnlock.lto_priv.2>

  return msg;
 8000672:	9b03      	ldr	r3, [sp, #12]
}
 8000674:	0018      	movs	r0, r3
 8000676:	b005      	add	sp, #20
 8000678:	bd00      	pop	{pc}
 800067a:	46c0      	nop			@ (mov r8, r8)
 800067c:	08004fac 	.word	0x08004fac

08000680 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 8000680:	b500      	push	{lr}
 8000682:	b085      	sub	sp, #20
 8000684:	9003      	str	r0, [sp, #12]
 8000686:	9102      	str	r1, [sp, #8]
 8000688:	9201      	str	r2, [sp, #4]
 800068a:	9300      	str	r3, [sp, #0]

  osalSysLock();
 800068c:	f7ff ff50 	bl	8000530 <osalSysLock.lto_priv.2>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000690:	9b00      	ldr	r3, [sp, #0]
 8000692:	9a01      	ldr	r2, [sp, #4]
 8000694:	9902      	ldr	r1, [sp, #8]
 8000696:	9803      	ldr	r0, [sp, #12]
 8000698:	f000 f80a 	bl	80006b0 <adcStartConversionI>
  osalSysUnlock();
 800069c:	f7ff ff50 	bl	8000540 <osalSysUnlock.lto_priv.2>
}
 80006a0:	46c0      	nop			@ (mov r8, r8)
 80006a2:	b005      	add	sp, #20
 80006a4:	bd00      	pop	{pc}
 80006a6:	46c0      	nop			@ (mov r8, r8)
	...

080006b0 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
 80006b0:	b500      	push	{lr}
 80006b2:	b085      	sub	sp, #20
 80006b4:	9003      	str	r0, [sp, #12]
 80006b6:	9102      	str	r1, [sp, #8]
 80006b8:	9201      	str	r2, [sp, #4]
 80006ba:	9300      	str	r3, [sp, #0]

  osalDbgCheckClassI();
 80006bc:	f001 ff10 	bl	80024e0 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
 80006c0:	9b03      	ldr	r3, [sp, #12]
 80006c2:	425a      	negs	r2, r3
 80006c4:	4153      	adcs	r3, r2
 80006c6:	b2db      	uxtb	r3, r3
 80006c8:	2b00      	cmp	r3, #0
 80006ca:	d105      	bne.n	80006d8 <adcStartConversionI+0x28>
 80006cc:	9b02      	ldr	r3, [sp, #8]
 80006ce:	425a      	negs	r2, r3
 80006d0:	4153      	adcs	r3, r2
 80006d2:	b2db      	uxtb	r3, r3
 80006d4:	2b00      	cmp	r3, #0
 80006d6:	d001      	beq.n	80006dc <adcStartConversionI+0x2c>
 80006d8:	2301      	movs	r3, #1
 80006da:	e000      	b.n	80006de <adcStartConversionI+0x2e>
 80006dc:	2300      	movs	r3, #0
 80006de:	2b00      	cmp	r3, #0
 80006e0:	d105      	bne.n	80006ee <adcStartConversionI+0x3e>
 80006e2:	9b01      	ldr	r3, [sp, #4]
 80006e4:	425a      	negs	r2, r3
 80006e6:	4153      	adcs	r3, r2
 80006e8:	b2db      	uxtb	r3, r3
 80006ea:	2b00      	cmp	r3, #0
 80006ec:	d001      	beq.n	80006f2 <adcStartConversionI+0x42>
 80006ee:	2301      	movs	r3, #1
 80006f0:	e000      	b.n	80006f4 <adcStartConversionI+0x44>
 80006f2:	2300      	movs	r3, #0
 80006f4:	2b00      	cmp	r3, #0
 80006f6:	d105      	bne.n	8000704 <adcStartConversionI+0x54>
 80006f8:	9b00      	ldr	r3, [sp, #0]
 80006fa:	425a      	negs	r2, r3
 80006fc:	4153      	adcs	r3, r2
 80006fe:	b2db      	uxtb	r3, r3
 8000700:	2b00      	cmp	r3, #0
 8000702:	d001      	beq.n	8000708 <adcStartConversionI+0x58>
 8000704:	2301      	movs	r3, #1
 8000706:	e000      	b.n	800070a <adcStartConversionI+0x5a>
 8000708:	2300      	movs	r3, #0
 800070a:	2b00      	cmp	r3, #0
 800070c:	d10f      	bne.n	800072e <adcStartConversionI+0x7e>
 800070e:	9b00      	ldr	r3, [sp, #0]
 8000710:	3b01      	subs	r3, #1
 8000712:	1e5a      	subs	r2, r3, #1
 8000714:	4193      	sbcs	r3, r2
 8000716:	b2db      	uxtb	r3, r3
 8000718:	2b00      	cmp	r3, #0
 800071a:	d005      	beq.n	8000728 <adcStartConversionI+0x78>
 800071c:	9b00      	ldr	r3, [sp, #0]
 800071e:	2201      	movs	r2, #1
 8000720:	4013      	ands	r3, r2
 8000722:	d001      	beq.n	8000728 <adcStartConversionI+0x78>
 8000724:	2301      	movs	r3, #1
 8000726:	e000      	b.n	800072a <adcStartConversionI+0x7a>
 8000728:	2300      	movs	r3, #0
 800072a:	2b00      	cmp	r3, #0
 800072c:	d003      	beq.n	8000736 <adcStartConversionI+0x86>
 800072e:	4b15      	ldr	r3, [pc, #84]	@ (8000784 <adcStartConversionI+0xd4>)
 8000730:	0018      	movs	r0, r3
 8000732:	f001 fd65 	bl	8002200 <chSysHalt>
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
 8000736:	9b03      	ldr	r3, [sp, #12]
 8000738:	781b      	ldrb	r3, [r3, #0]
 800073a:	3b02      	subs	r3, #2
 800073c:	1e5a      	subs	r2, r3, #1
 800073e:	4193      	sbcs	r3, r2
 8000740:	b2db      	uxtb	r3, r3
 8000742:	2b00      	cmp	r3, #0
 8000744:	d00b      	beq.n	800075e <adcStartConversionI+0xae>
 8000746:	9b03      	ldr	r3, [sp, #12]
 8000748:	781b      	ldrb	r3, [r3, #0]
 800074a:	3b05      	subs	r3, #5
 800074c:	1e5a      	subs	r2, r3, #1
 800074e:	4193      	sbcs	r3, r2
 8000750:	b2db      	uxtb	r3, r3
 8000752:	2b00      	cmp	r3, #0
 8000754:	d003      	beq.n	800075e <adcStartConversionI+0xae>
 8000756:	4b0b      	ldr	r3, [pc, #44]	@ (8000784 <adcStartConversionI+0xd4>)
 8000758:	0018      	movs	r0, r3
 800075a:	f001 fd51 	bl	8002200 <chSysHalt>
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 800075e:	9b03      	ldr	r3, [sp, #12]
 8000760:	9a01      	ldr	r2, [sp, #4]
 8000762:	609a      	str	r2, [r3, #8]
  adcp->depth    = depth;
 8000764:	9b03      	ldr	r3, [sp, #12]
 8000766:	9a00      	ldr	r2, [sp, #0]
 8000768:	60da      	str	r2, [r3, #12]
  adcp->grpp     = grpp;
 800076a:	9b03      	ldr	r3, [sp, #12]
 800076c:	9a02      	ldr	r2, [sp, #8]
 800076e:	611a      	str	r2, [r3, #16]
  adcp->state    = ADC_ACTIVE;
 8000770:	9b03      	ldr	r3, [sp, #12]
 8000772:	2203      	movs	r2, #3
 8000774:	701a      	strb	r2, [r3, #0]
  adc_lld_start_conversion(adcp);
 8000776:	9b03      	ldr	r3, [sp, #12]
 8000778:	0018      	movs	r0, r3
 800077a:	f000 ff31 	bl	80015e0 <adc_lld_start_conversion>
}
 800077e:	46c0      	nop			@ (mov r8, r8)
 8000780:	b005      	add	sp, #20
 8000782:	bd00      	pop	{pc}
 8000784:	08004fc4 	.word	0x08004fc4
	...

08000790 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
 8000790:	b500      	push	{lr}
 8000792:	b083      	sub	sp, #12
 8000794:	9001      	str	r0, [sp, #4]

  osalDbgCheck(adcp != NULL);
 8000796:	9b01      	ldr	r3, [sp, #4]
 8000798:	425a      	negs	r2, r3
 800079a:	4153      	adcs	r3, r2
 800079c:	b2db      	uxtb	r3, r3
 800079e:	2b00      	cmp	r3, #0
 80007a0:	d003      	beq.n	80007aa <adcStopConversion+0x1a>
 80007a2:	4b1a      	ldr	r3, [pc, #104]	@ (800080c <adcStopConversion+0x7c>)
 80007a4:	0018      	movs	r0, r3
 80007a6:	f001 fd2b 	bl	8002200 <chSysHalt>

  osalSysLock();
 80007aa:	f7ff fec1 	bl	8000530 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_READY) || (adcp->state == ADC_ACTIVE),
 80007ae:	9b01      	ldr	r3, [sp, #4]
 80007b0:	781b      	ldrb	r3, [r3, #0]
 80007b2:	3b02      	subs	r3, #2
 80007b4:	1e5a      	subs	r2, r3, #1
 80007b6:	4193      	sbcs	r3, r2
 80007b8:	b2db      	uxtb	r3, r3
 80007ba:	2b00      	cmp	r3, #0
 80007bc:	d00b      	beq.n	80007d6 <adcStopConversion+0x46>
 80007be:	9b01      	ldr	r3, [sp, #4]
 80007c0:	781b      	ldrb	r3, [r3, #0]
 80007c2:	3b03      	subs	r3, #3
 80007c4:	1e5a      	subs	r2, r3, #1
 80007c6:	4193      	sbcs	r3, r2
 80007c8:	b2db      	uxtb	r3, r3
 80007ca:	2b00      	cmp	r3, #0
 80007cc:	d003      	beq.n	80007d6 <adcStopConversion+0x46>
 80007ce:	4b0f      	ldr	r3, [pc, #60]	@ (800080c <adcStopConversion+0x7c>)
 80007d0:	0018      	movs	r0, r3
 80007d2:	f001 fd15 	bl	8002200 <chSysHalt>
                "invalid state");
  if (adcp->state != ADC_READY) {
 80007d6:	9b01      	ldr	r3, [sp, #4]
 80007d8:	781b      	ldrb	r3, [r3, #0]
 80007da:	2b02      	cmp	r3, #2
 80007dc:	d011      	beq.n	8000802 <adcStopConversion+0x72>
    adc_lld_stop_conversion(adcp);
 80007de:	9b01      	ldr	r3, [sp, #4]
 80007e0:	0018      	movs	r0, r3
 80007e2:	f000 ff9d 	bl	8001720 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
 80007e6:	9b01      	ldr	r3, [sp, #4]
 80007e8:	2200      	movs	r2, #0
 80007ea:	611a      	str	r2, [r3, #16]
    adcp->state = ADC_READY;
 80007ec:	9b01      	ldr	r3, [sp, #4]
 80007ee:	2202      	movs	r2, #2
 80007f0:	701a      	strb	r2, [r3, #0]
    _adc_reset_s(adcp);
 80007f2:	9b01      	ldr	r3, [sp, #4]
 80007f4:	3314      	adds	r3, #20
 80007f6:	2202      	movs	r2, #2
 80007f8:	4252      	negs	r2, r2
 80007fa:	0011      	movs	r1, r2
 80007fc:	0018      	movs	r0, r3
 80007fe:	f7ff feb7 	bl	8000570 <osalThreadResumeS>
  }
  osalSysUnlock();
 8000802:	f7ff fe9d 	bl	8000540 <osalSysUnlock.lto_priv.2>
}
 8000806:	46c0      	nop			@ (mov r8, r8)
 8000808:	b003      	add	sp, #12
 800080a:	bd00      	pop	{pc}
 800080c:	08004fd8 	.word	0x08004fd8

08000810 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8000810:	b500      	push	{lr}
 8000812:	b087      	sub	sp, #28
 8000814:	9003      	str	r0, [sp, #12]
 8000816:	9102      	str	r1, [sp, #8]
 8000818:	9201      	str	r2, [sp, #4]
 800081a:	9300      	str	r3, [sp, #0]
  msg_t msg;

  osalSysLock();
 800081c:	f7ff fe88 	bl	8000530 <osalSysLock.lto_priv.2>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
 8000820:	9b03      	ldr	r3, [sp, #12]
 8000822:	695b      	ldr	r3, [r3, #20]
 8000824:	1e5a      	subs	r2, r3, #1
 8000826:	4193      	sbcs	r3, r2
 8000828:	b2db      	uxtb	r3, r3
 800082a:	2b00      	cmp	r3, #0
 800082c:	d003      	beq.n	8000836 <adcConvert+0x26>
 800082e:	4b0b      	ldr	r3, [pc, #44]	@ (800085c <adcConvert+0x4c>)
 8000830:	0018      	movs	r0, r3
 8000832:	f001 fce5 	bl	8002200 <chSysHalt>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000836:	9b00      	ldr	r3, [sp, #0]
 8000838:	9a01      	ldr	r2, [sp, #4]
 800083a:	9902      	ldr	r1, [sp, #8]
 800083c:	9803      	ldr	r0, [sp, #12]
 800083e:	f7ff ff37 	bl	80006b0 <adcStartConversionI>
  msg = osalThreadSuspendS(&adcp->thread);
 8000842:	9b03      	ldr	r3, [sp, #12]
 8000844:	3314      	adds	r3, #20
 8000846:	0018      	movs	r0, r3
 8000848:	f7ff fe82 	bl	8000550 <osalThreadSuspendS>
 800084c:	0003      	movs	r3, r0
 800084e:	9305      	str	r3, [sp, #20]
  osalSysUnlock();
 8000850:	f7ff fe76 	bl	8000540 <osalSysUnlock.lto_priv.2>
  return msg;
 8000854:	9b05      	ldr	r3, [sp, #20]
}
 8000856:	0018      	movs	r0, r3
 8000858:	b007      	add	sp, #28
 800085a:	bd00      	pop	{pc}
 800085c:	08004fec 	.word	0x08004fec

08000860 <port_lock.lto_priv.3>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000860:	b672      	cpsid	i
}
 8000862:	46c0      	nop			@ (mov r8, r8)
}
 8000864:	46c0      	nop			@ (mov r8, r8)
 8000866:	4770      	bx	lr
	...

08000870 <port_unlock.lto_priv.3>:
  __ASM volatile ("cpsie i" : : : "memory");
 8000870:	b662      	cpsie	i
}
 8000872:	46c0      	nop			@ (mov r8, r8)
}
 8000874:	46c0      	nop			@ (mov r8, r8)
 8000876:	4770      	bx	lr
	...

08000880 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
 8000880:	b510      	push	{r4, lr}
  port_lock();
 8000882:	f7ff ffed 	bl	8000860 <port_lock.lto_priv.3>
  __dbg_check_lock();
 8000886:	f001 fd2b 	bl	80022e0 <__dbg_check_lock>
}
 800088a:	46c0      	nop			@ (mov r8, r8)
 800088c:	bd10      	pop	{r4, pc}
 800088e:	46c0      	nop			@ (mov r8, r8)

08000890 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
 8000890:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8000892:	f001 fd4d 	bl	8002330 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000896:	4b0e      	ldr	r3, [pc, #56]	@ (80008d0 <chSysUnlock.lto_priv.3+0x40>)
 8000898:	681a      	ldr	r2, [r3, #0]
 800089a:	4b0d      	ldr	r3, [pc, #52]	@ (80008d0 <chSysUnlock.lto_priv.3+0x40>)
 800089c:	1ad3      	subs	r3, r2, r3
 800089e:	1e5a      	subs	r2, r3, #1
 80008a0:	4193      	sbcs	r3, r2
 80008a2:	b2db      	uxtb	r3, r3
 80008a4:	2b00      	cmp	r3, #0
 80008a6:	d00f      	beq.n	80008c8 <chSysUnlock.lto_priv.3+0x38>
 80008a8:	4b09      	ldr	r3, [pc, #36]	@ (80008d0 <chSysUnlock.lto_priv.3+0x40>)
 80008aa:	68db      	ldr	r3, [r3, #12]
 80008ac:	689a      	ldr	r2, [r3, #8]
 80008ae:	4b08      	ldr	r3, [pc, #32]	@ (80008d0 <chSysUnlock.lto_priv.3+0x40>)
 80008b0:	681b      	ldr	r3, [r3, #0]
 80008b2:	689b      	ldr	r3, [r3, #8]
 80008b4:	429a      	cmp	r2, r3
 80008b6:	419b      	sbcs	r3, r3
 80008b8:	425b      	negs	r3, r3
 80008ba:	b2db      	uxtb	r3, r3
 80008bc:	2b00      	cmp	r3, #0
 80008be:	d003      	beq.n	80008c8 <chSysUnlock.lto_priv.3+0x38>
 80008c0:	4b04      	ldr	r3, [pc, #16]	@ (80008d4 <chSysUnlock.lto_priv.3+0x44>)
 80008c2:	0018      	movs	r0, r3
 80008c4:	f001 fc9c 	bl	8002200 <chSysHalt>
  port_unlock();
 80008c8:	f7ff ffd2 	bl	8000870 <port_unlock.lto_priv.3>
}
 80008cc:	46c0      	nop			@ (mov r8, r8)
 80008ce:	bd10      	pop	{r4, pc}
 80008d0:	20000690 	.word	0x20000690
 80008d4:	08005004 	.word	0x08005004
	...

080008e0 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
 80008e0:	b510      	push	{r4, lr}
  chSysLock();
 80008e2:	f7ff ffcd 	bl	8000880 <chSysLock.lto_priv.3>
}
 80008e6:	46c0      	nop			@ (mov r8, r8)
 80008e8:	bd10      	pop	{r4, pc}
 80008ea:	46c0      	nop			@ (mov r8, r8)
 80008ec:	0000      	movs	r0, r0
	...

080008f0 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
 80008f0:	b510      	push	{r4, lr}
  chSysUnlock();
 80008f2:	f7ff ffcd 	bl	8000890 <chSysUnlock.lto_priv.3>
}
 80008f6:	46c0      	nop			@ (mov r8, r8)
 80008f8:	bd10      	pop	{r4, pc}
 80008fa:	46c0      	nop			@ (mov r8, r8)
 80008fc:	0000      	movs	r0, r0
	...

08000900 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8000900:	b510      	push	{r4, lr}

  gpt_lld_init();
 8000902:	f001 fa75 	bl	8001df0 <gpt_lld_init>
}
 8000906:	46c0      	nop			@ (mov r8, r8)
 8000908:	bd10      	pop	{r4, pc}
 800090a:	46c0      	nop			@ (mov r8, r8)
 800090c:	0000      	movs	r0, r0
	...

08000910 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8000910:	b082      	sub	sp, #8
 8000912:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 8000914:	9b01      	ldr	r3, [sp, #4]
 8000916:	2201      	movs	r2, #1
 8000918:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 800091a:	9b01      	ldr	r3, [sp, #4]
 800091c:	2200      	movs	r2, #0
 800091e:	605a      	str	r2, [r3, #4]
}
 8000920:	46c0      	nop			@ (mov r8, r8)
 8000922:	b002      	add	sp, #8
 8000924:	4770      	bx	lr
 8000926:	46c0      	nop			@ (mov r8, r8)
	...

08000930 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8000930:	b500      	push	{lr}
 8000932:	b085      	sub	sp, #20
 8000934:	9001      	str	r0, [sp, #4]
 8000936:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 8000938:	9b01      	ldr	r3, [sp, #4]
 800093a:	425a      	negs	r2, r3
 800093c:	4153      	adcs	r3, r2
 800093e:	b2db      	uxtb	r3, r3
 8000940:	2b00      	cmp	r3, #0
 8000942:	d105      	bne.n	8000950 <gptStart+0x20>
 8000944:	9b00      	ldr	r3, [sp, #0]
 8000946:	425a      	negs	r2, r3
 8000948:	4153      	adcs	r3, r2
 800094a:	b2db      	uxtb	r3, r3
 800094c:	2b00      	cmp	r3, #0
 800094e:	d003      	beq.n	8000958 <gptStart+0x28>
 8000950:	4b19      	ldr	r3, [pc, #100]	@ (80009b8 <gptStart+0x88>)
 8000952:	0018      	movs	r0, r3
 8000954:	f001 fc54 	bl	8002200 <chSysHalt>

  osalSysLock();
 8000958:	f7ff ffc2 	bl	80008e0 <osalSysLock.lto_priv.3>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
 800095c:	9b01      	ldr	r3, [sp, #4]
 800095e:	781b      	ldrb	r3, [r3, #0]
 8000960:	3b01      	subs	r3, #1
 8000962:	1e5a      	subs	r2, r3, #1
 8000964:	4193      	sbcs	r3, r2
 8000966:	b2db      	uxtb	r3, r3
 8000968:	2b00      	cmp	r3, #0
 800096a:	d00b      	beq.n	8000984 <gptStart+0x54>
 800096c:	9b01      	ldr	r3, [sp, #4]
 800096e:	781b      	ldrb	r3, [r3, #0]
 8000970:	3b02      	subs	r3, #2
 8000972:	1e5a      	subs	r2, r3, #1
 8000974:	4193      	sbcs	r3, r2
 8000976:	b2db      	uxtb	r3, r3
 8000978:	2b00      	cmp	r3, #0
 800097a:	d003      	beq.n	8000984 <gptStart+0x54>
 800097c:	4b0e      	ldr	r3, [pc, #56]	@ (80009b8 <gptStart+0x88>)
 800097e:	0018      	movs	r0, r3
 8000980:	f001 fc3e 	bl	8002200 <chSysHalt>
              "invalid state");

  gptp->config = config;
 8000984:	9b01      	ldr	r3, [sp, #4]
 8000986:	9a00      	ldr	r2, [sp, #0]
 8000988:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 800098a:	9b01      	ldr	r3, [sp, #4]
 800098c:	0018      	movs	r0, r3
 800098e:	f001 fa3f 	bl	8001e10 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 8000992:	2300      	movs	r3, #0
 8000994:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 8000996:	9b03      	ldr	r3, [sp, #12]
 8000998:	2b00      	cmp	r3, #0
 800099a:	d103      	bne.n	80009a4 <gptStart+0x74>
    gptp->state = GPT_READY;
 800099c:	9b01      	ldr	r3, [sp, #4]
 800099e:	2202      	movs	r2, #2
 80009a0:	701a      	strb	r2, [r3, #0]
 80009a2:	e002      	b.n	80009aa <gptStart+0x7a>
  }
  else {
    gptp->state = GPT_STOP;
 80009a4:	9b01      	ldr	r3, [sp, #4]
 80009a6:	2201      	movs	r2, #1
 80009a8:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 80009aa:	f7ff ffa1 	bl	80008f0 <osalSysUnlock.lto_priv.3>

  return msg;
 80009ae:	9b03      	ldr	r3, [sp, #12]
}
 80009b0:	0018      	movs	r0, r3
 80009b2:	b005      	add	sp, #20
 80009b4:	bd00      	pop	{pc}
 80009b6:	46c0      	nop			@ (mov r8, r8)
 80009b8:	08004ff8 	.word	0x08004ff8
 80009bc:	00000000 	.word	0x00000000

080009c0 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 80009c0:	b500      	push	{lr}
 80009c2:	b083      	sub	sp, #12
 80009c4:	9001      	str	r0, [sp, #4]
 80009c6:	9100      	str	r1, [sp, #0]

  osalSysLock();
 80009c8:	f7ff ff8a 	bl	80008e0 <osalSysLock.lto_priv.3>
  gptStartContinuousI(gptp, interval);
 80009cc:	9a00      	ldr	r2, [sp, #0]
 80009ce:	9b01      	ldr	r3, [sp, #4]
 80009d0:	0011      	movs	r1, r2
 80009d2:	0018      	movs	r0, r3
 80009d4:	f000 f80c 	bl	80009f0 <gptStartContinuousI>
  osalSysUnlock();
 80009d8:	f7ff ff8a 	bl	80008f0 <osalSysUnlock.lto_priv.3>
}
 80009dc:	46c0      	nop			@ (mov r8, r8)
 80009de:	b003      	add	sp, #12
 80009e0:	bd00      	pop	{pc}
 80009e2:	46c0      	nop			@ (mov r8, r8)
	...

080009f0 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 80009f0:	b500      	push	{lr}
 80009f2:	b083      	sub	sp, #12
 80009f4:	9001      	str	r0, [sp, #4]
 80009f6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 80009f8:	f001 fd72 	bl	80024e0 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 80009fc:	9b01      	ldr	r3, [sp, #4]
 80009fe:	425a      	negs	r2, r3
 8000a00:	4153      	adcs	r3, r2
 8000a02:	b2db      	uxtb	r3, r3
 8000a04:	2b00      	cmp	r3, #0
 8000a06:	d003      	beq.n	8000a10 <gptStartContinuousI+0x20>
 8000a08:	4b0d      	ldr	r3, [pc, #52]	@ (8000a40 <gptStartContinuousI+0x50>)
 8000a0a:	0018      	movs	r0, r3
 8000a0c:	f001 fbf8 	bl	8002200 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
 8000a10:	9b01      	ldr	r3, [sp, #4]
 8000a12:	781b      	ldrb	r3, [r3, #0]
 8000a14:	3b02      	subs	r3, #2
 8000a16:	1e5a      	subs	r2, r3, #1
 8000a18:	4193      	sbcs	r3, r2
 8000a1a:	b2db      	uxtb	r3, r3
 8000a1c:	2b00      	cmp	r3, #0
 8000a1e:	d003      	beq.n	8000a28 <gptStartContinuousI+0x38>
 8000a20:	4b07      	ldr	r3, [pc, #28]	@ (8000a40 <gptStartContinuousI+0x50>)
 8000a22:	0018      	movs	r0, r3
 8000a24:	f001 fbec 	bl	8002200 <chSysHalt>
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000a28:	9b01      	ldr	r3, [sp, #4]
 8000a2a:	2203      	movs	r2, #3
 8000a2c:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 8000a2e:	9a00      	ldr	r2, [sp, #0]
 8000a30:	9b01      	ldr	r3, [sp, #4]
 8000a32:	0011      	movs	r1, r2
 8000a34:	0018      	movs	r0, r3
 8000a36:	f001 fa63 	bl	8001f00 <gpt_lld_start_timer>
}
 8000a3a:	46c0      	nop			@ (mov r8, r8)
 8000a3c:	b003      	add	sp, #12
 8000a3e:	bd00      	pop	{pc}
 8000a40:	08005010 	.word	0x08005010
	...

08000a50 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000a50:	b500      	push	{lr}
 8000a52:	b083      	sub	sp, #12
 8000a54:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8000a56:	f7ff ff43 	bl	80008e0 <osalSysLock.lto_priv.3>
  gptStopTimerI(gptp);
 8000a5a:	9b01      	ldr	r3, [sp, #4]
 8000a5c:	0018      	movs	r0, r3
 8000a5e:	f000 f807 	bl	8000a70 <gptStopTimerI>
  osalSysUnlock();
 8000a62:	f7ff ff45 	bl	80008f0 <osalSysUnlock.lto_priv.3>
}
 8000a66:	46c0      	nop			@ (mov r8, r8)
 8000a68:	b003      	add	sp, #12
 8000a6a:	bd00      	pop	{pc}
 8000a6c:	0000      	movs	r0, r0
	...

08000a70 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000a70:	b500      	push	{lr}
 8000a72:	b083      	sub	sp, #12
 8000a74:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8000a76:	f001 fd33 	bl	80024e0 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000a7a:	9b01      	ldr	r3, [sp, #4]
 8000a7c:	425a      	negs	r2, r3
 8000a7e:	4153      	adcs	r3, r2
 8000a80:	b2db      	uxtb	r3, r3
 8000a82:	2b00      	cmp	r3, #0
 8000a84:	d003      	beq.n	8000a8e <gptStopTimerI+0x1e>
 8000a86:	4b17      	ldr	r3, [pc, #92]	@ (8000ae4 <gptStopTimerI+0x74>)
 8000a88:	0018      	movs	r0, r3
 8000a8a:	f001 fbb9 	bl	8002200 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
 8000a8e:	9b01      	ldr	r3, [sp, #4]
 8000a90:	781b      	ldrb	r3, [r3, #0]
 8000a92:	3b02      	subs	r3, #2
 8000a94:	1e5a      	subs	r2, r3, #1
 8000a96:	4193      	sbcs	r3, r2
 8000a98:	b2db      	uxtb	r3, r3
 8000a9a:	2b00      	cmp	r3, #0
 8000a9c:	d009      	beq.n	8000ab2 <gptStopTimerI+0x42>
 8000a9e:	9b01      	ldr	r3, [sp, #4]
 8000aa0:	781b      	ldrb	r3, [r3, #0]
 8000aa2:	3b03      	subs	r3, #3
 8000aa4:	1e5a      	subs	r2, r3, #1
 8000aa6:	4193      	sbcs	r3, r2
 8000aa8:	b2db      	uxtb	r3, r3
 8000aaa:	2b00      	cmp	r3, #0
 8000aac:	d001      	beq.n	8000ab2 <gptStopTimerI+0x42>
 8000aae:	2301      	movs	r3, #1
 8000ab0:	e000      	b.n	8000ab4 <gptStopTimerI+0x44>
 8000ab2:	2300      	movs	r3, #0
 8000ab4:	2b00      	cmp	r3, #0
 8000ab6:	d00b      	beq.n	8000ad0 <gptStopTimerI+0x60>
 8000ab8:	9b01      	ldr	r3, [sp, #4]
 8000aba:	781b      	ldrb	r3, [r3, #0]
 8000abc:	3b04      	subs	r3, #4
 8000abe:	1e5a      	subs	r2, r3, #1
 8000ac0:	4193      	sbcs	r3, r2
 8000ac2:	b2db      	uxtb	r3, r3
 8000ac4:	2b00      	cmp	r3, #0
 8000ac6:	d003      	beq.n	8000ad0 <gptStopTimerI+0x60>
 8000ac8:	4b06      	ldr	r3, [pc, #24]	@ (8000ae4 <gptStopTimerI+0x74>)
 8000aca:	0018      	movs	r0, r3
 8000acc:	f001 fb98 	bl	8002200 <chSysHalt>
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000ad0:	9b01      	ldr	r3, [sp, #4]
 8000ad2:	2202      	movs	r2, #2
 8000ad4:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000ad6:	9b01      	ldr	r3, [sp, #4]
 8000ad8:	0018      	movs	r0, r3
 8000ada:	f001 fa39 	bl	8001f50 <gpt_lld_stop_timer>
}
 8000ade:	46c0      	nop			@ (mov r8, r8)
 8000ae0:	b003      	add	sp, #12
 8000ae2:	bd00      	pop	{pc}
 8000ae4:	08005024 	.word	0x08005024
	...

08000af0 <nvicInit>:
/*===========================================================================*/

/**
 * @brief   NVIC clearing and initialization.
 */
void nvicInit(void) {
 8000af0:	b082      	sub	sp, #8
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
 8000af2:	2300      	movs	r3, #0
 8000af4:	9300      	str	r3, [sp, #0]
#else
  uint32_t n = SCnSCB->ICTR;
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 8000af6:	2300      	movs	r3, #0
 8000af8:	9301      	str	r3, [sp, #4]
 8000afa:	e010      	b.n	8000b1e <nvicInit+0x2e>
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8000afc:	490c      	ldr	r1, [pc, #48]	@ (8000b30 <nvicInit+0x40>)
 8000afe:	9b01      	ldr	r3, [sp, #4]
 8000b00:	3320      	adds	r3, #32
 8000b02:	009b      	lsls	r3, r3, #2
 8000b04:	2201      	movs	r2, #1
 8000b06:	4252      	negs	r2, r2
 8000b08:	505a      	str	r2, [r3, r1]
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 8000b0a:	4909      	ldr	r1, [pc, #36]	@ (8000b30 <nvicInit+0x40>)
 8000b0c:	9b01      	ldr	r3, [sp, #4]
 8000b0e:	3360      	adds	r3, #96	@ 0x60
 8000b10:	009b      	lsls	r3, r3, #2
 8000b12:	2201      	movs	r2, #1
 8000b14:	4252      	negs	r2, r2
 8000b16:	505a      	str	r2, [r3, r1]
  for (uint32_t i = 0U; i <= n; i++) {
 8000b18:	9b01      	ldr	r3, [sp, #4]
 8000b1a:	3301      	adds	r3, #1
 8000b1c:	9301      	str	r3, [sp, #4]
 8000b1e:	9a01      	ldr	r2, [sp, #4]
 8000b20:	9b00      	ldr	r3, [sp, #0]
 8000b22:	429a      	cmp	r2, r3
 8000b24:	d9ea      	bls.n	8000afc <nvicInit+0xc>
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
    NVIC->__ITNS[i] = 0xFFFFFFFFU;
#endif
  }
}
 8000b26:	46c0      	nop			@ (mov r8, r8)
 8000b28:	46c0      	nop			@ (mov r8, r8)
 8000b2a:	b002      	add	sp, #8
 8000b2c:	4770      	bx	lr
 8000b2e:	46c0      	nop			@ (mov r8, r8)
 8000b30:	e000e100 	.word	0xe000e100
	...

08000b40 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000b40:	b082      	sub	sp, #8
 8000b42:	9001      	str	r0, [sp, #4]
 8000b44:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000b46:	4a1c      	ldr	r2, [pc, #112]	@ (8000bb8 <nvicEnableVector+0x78>)
 8000b48:	9b01      	ldr	r3, [sp, #4]
 8000b4a:	089b      	lsrs	r3, r3, #2
 8000b4c:	33c0      	adds	r3, #192	@ 0xc0
 8000b4e:	009b      	lsls	r3, r3, #2
 8000b50:	589b      	ldr	r3, [r3, r2]
 8000b52:	9a01      	ldr	r2, [sp, #4]
 8000b54:	2103      	movs	r1, #3
 8000b56:	400a      	ands	r2, r1
 8000b58:	00d2      	lsls	r2, r2, #3
 8000b5a:	21ff      	movs	r1, #255	@ 0xff
 8000b5c:	4091      	lsls	r1, r2
 8000b5e:	000a      	movs	r2, r1
 8000b60:	43d2      	mvns	r2, r2
 8000b62:	401a      	ands	r2, r3
 8000b64:	0011      	movs	r1, r2
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 8000b66:	9b00      	ldr	r3, [sp, #0]
 8000b68:	019a      	lsls	r2, r3, #6
 8000b6a:	9b01      	ldr	r3, [sp, #4]
 8000b6c:	2003      	movs	r0, #3
 8000b6e:	4003      	ands	r3, r0
 8000b70:	00db      	lsls	r3, r3, #3
 8000b72:	409a      	lsls	r2, r3
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000b74:	4810      	ldr	r0, [pc, #64]	@ (8000bb8 <nvicEnableVector+0x78>)
 8000b76:	9b01      	ldr	r3, [sp, #4]
 8000b78:	089b      	lsrs	r3, r3, #2
 8000b7a:	430a      	orrs	r2, r1
 8000b7c:	33c0      	adds	r3, #192	@ 0xc0
 8000b7e:	009b      	lsls	r3, r3, #2
 8000b80:	501a      	str	r2, [r3, r0]
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000b82:	9b01      	ldr	r3, [sp, #4]
 8000b84:	221f      	movs	r2, #31
 8000b86:	401a      	ands	r2, r3
 8000b88:	490b      	ldr	r1, [pc, #44]	@ (8000bb8 <nvicEnableVector+0x78>)
 8000b8a:	9b01      	ldr	r3, [sp, #4]
 8000b8c:	095b      	lsrs	r3, r3, #5
 8000b8e:	2001      	movs	r0, #1
 8000b90:	4090      	lsls	r0, r2
 8000b92:	0002      	movs	r2, r0
 8000b94:	3360      	adds	r3, #96	@ 0x60
 8000b96:	009b      	lsls	r3, r3, #2
 8000b98:	505a      	str	r2, [r3, r1]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000b9a:	9b01      	ldr	r3, [sp, #4]
 8000b9c:	221f      	movs	r2, #31
 8000b9e:	401a      	ands	r2, r3
 8000ba0:	4905      	ldr	r1, [pc, #20]	@ (8000bb8 <nvicEnableVector+0x78>)
 8000ba2:	9b01      	ldr	r3, [sp, #4]
 8000ba4:	095b      	lsrs	r3, r3, #5
 8000ba6:	2001      	movs	r0, #1
 8000ba8:	4090      	lsls	r0, r2
 8000baa:	0002      	movs	r2, r0
 8000bac:	009b      	lsls	r3, r3, #2
 8000bae:	505a      	str	r2, [r3, r1]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000bb0:	46c0      	nop			@ (mov r8, r8)
 8000bb2:	b002      	add	sp, #8
 8000bb4:	4770      	bx	lr
 8000bb6:	46c0      	nop			@ (mov r8, r8)
 8000bb8:	e000e100 	.word	0xe000e100
 8000bbc:	00000000 	.word	0x00000000

08000bc0 <Vector68>:
/**
 * @brief   DMA1 streams 2 and 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH23_HANDLER) {
 8000bc0:	b500      	push	{lr}
 8000bc2:	b083      	sub	sp, #12
 8000bc4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000bc6:	9301      	str	r3, [sp, #4]
 8000bc8:	4b0d      	ldr	r3, [pc, #52]	@ (8000c00 <Vector68+0x40>)
 8000bca:	0018      	movs	r0, r3
 8000bcc:	f001 fdd0 	bl	8002770 <__trace_isr_enter>
 8000bd0:	f001 fc26 	bl	8002420 <__dbg_check_enter_isr>

  /* Check on channel 2.*/
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000bd4:	4b0b      	ldr	r3, [pc, #44]	@ (8000c04 <Vector68+0x44>)
 8000bd6:	0018      	movs	r0, r3
 8000bd8:	f000 ff4a 	bl	8001a70 <dmaServeInterrupt>

  /* Check on channel 3.*/
  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000bdc:	4b0a      	ldr	r3, [pc, #40]	@ (8000c08 <Vector68+0x48>)
 8000bde:	0018      	movs	r0, r3
 8000be0:	f000 ff46 	bl	8001a70 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8000be4:	f001 fc4c 	bl	8002480 <__dbg_check_leave_isr>
 8000be8:	4b05      	ldr	r3, [pc, #20]	@ (8000c00 <Vector68+0x40>)
 8000bea:	0018      	movs	r0, r3
 8000bec:	f001 fdf0 	bl	80027d0 <__trace_isr_leave>
 8000bf0:	9b01      	ldr	r3, [sp, #4]
 8000bf2:	0018      	movs	r0, r3
 8000bf4:	f004 f884 	bl	8004d00 <__port_irq_epilogue>
}
 8000bf8:	46c0      	nop			@ (mov r8, r8)
 8000bfa:	b003      	add	sp, #12
 8000bfc:	bd00      	pop	{pc}
 8000bfe:	46c0      	nop			@ (mov r8, r8)
 8000c00:	08005034 	.word	0x08005034
 8000c04:	080050a4 	.word	0x080050a4
 8000c08:	080050b8 	.word	0x080050b8
 8000c0c:	00000000 	.word	0x00000000

08000c10 <Vector6C>:
/**
 * @brief   DMA1 streams 4, 5, 6 and 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4567_HANDLER) {
 8000c10:	b500      	push	{lr}
 8000c12:	b083      	sub	sp, #12
 8000c14:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000c16:	9301      	str	r3, [sp, #4]
 8000c18:	4b11      	ldr	r3, [pc, #68]	@ (8000c60 <Vector6C+0x50>)
 8000c1a:	0018      	movs	r0, r3
 8000c1c:	f001 fda8 	bl	8002770 <__trace_isr_enter>
 8000c20:	f001 fbfe 	bl	8002420 <__dbg_check_enter_isr>

  /* Check on channel 4.*/
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8000c24:	4b0f      	ldr	r3, [pc, #60]	@ (8000c64 <Vector6C+0x54>)
 8000c26:	0018      	movs	r0, r3
 8000c28:	f000 ff22 	bl	8001a70 <dmaServeInterrupt>

#if STM32_DMA1_NUM_CHANNELS >= 5
  /* Check on channel 5.*/
  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8000c2c:	4b0e      	ldr	r3, [pc, #56]	@ (8000c68 <Vector6C+0x58>)
 8000c2e:	0018      	movs	r0, r3
 8000c30:	f000 ff1e 	bl	8001a70 <dmaServeInterrupt>
#endif

#if STM32_DMA1_NUM_CHANNELS >= 6
  /* Check on channel 6.*/
  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8000c34:	4b0d      	ldr	r3, [pc, #52]	@ (8000c6c <Vector6C+0x5c>)
 8000c36:	0018      	movs	r0, r3
 8000c38:	f000 ff1a 	bl	8001a70 <dmaServeInterrupt>
#endif

#if STM32_DMA1_NUM_CHANNELS >= 7
  /* Check on channel 7.*/
  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8000c3c:	4b0c      	ldr	r3, [pc, #48]	@ (8000c70 <Vector6C+0x60>)
 8000c3e:	0018      	movs	r0, r3
 8000c40:	f000 ff16 	bl	8001a70 <dmaServeInterrupt>
#endif

  OSAL_IRQ_EPILOGUE();
 8000c44:	f001 fc1c 	bl	8002480 <__dbg_check_leave_isr>
 8000c48:	4b05      	ldr	r3, [pc, #20]	@ (8000c60 <Vector6C+0x50>)
 8000c4a:	0018      	movs	r0, r3
 8000c4c:	f001 fdc0 	bl	80027d0 <__trace_isr_leave>
 8000c50:	9b01      	ldr	r3, [sp, #4]
 8000c52:	0018      	movs	r0, r3
 8000c54:	f004 f854 	bl	8004d00 <__port_irq_epilogue>
}
 8000c58:	46c0      	nop			@ (mov r8, r8)
 8000c5a:	b003      	add	sp, #12
 8000c5c:	bd00      	pop	{pc}
 8000c5e:	46c0      	nop			@ (mov r8, r8)
 8000c60:	08005040 	.word	0x08005040
 8000c64:	080050cc 	.word	0x080050cc
 8000c68:	080050e0 	.word	0x080050e0
 8000c6c:	080050f4 	.word	0x080050f4
 8000c70:	08005108 	.word	0x08005108
	...

08000c80 <exti0_1_irq_init>:

static inline void exti0_1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_1_NUMBER, STM32_IRQ_EXTI0_1_PRIORITY);
#endif
}
 8000c80:	46c0      	nop			@ (mov r8, r8)
 8000c82:	4770      	bx	lr
	...

08000c90 <exti2_3_irq_init>:

static inline void exti2_3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_3_NUMBER, STM32_IRQ_EXTI2_3_PRIORITY);
#endif
}
 8000c90:	46c0      	nop			@ (mov r8, r8)
 8000c92:	4770      	bx	lr
	...

08000ca0 <exti4_15_irq_init>:

static inline void exti4_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_15_NUMBER, STM32_IRQ_EXTI4_15_PRIORITY);
#endif
}
 8000ca0:	46c0      	nop			@ (mov r8, r8)
 8000ca2:	4770      	bx	lr
	...

08000cb0 <exti19_exti21_irq_init>:

static inline void exti19_exti21_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED) || defined(STM32_EXTI21_IS_USED)
  nvicEnableVector(STM32_EXTI1921_NUMBER, STM32_IRQ_EXTI1921_PRIORITY);
#endif
}
 8000cb0:	46c0      	nop			@ (mov r8, r8)
 8000cb2:	4770      	bx	lr
	...

08000cc0 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000cc0:	46c0      	nop			@ (mov r8, r8)
 8000cc2:	4770      	bx	lr
	...

08000cd0 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000cd0:	46c0      	nop			@ (mov r8, r8)
 8000cd2:	4770      	bx	lr
	...

08000ce0 <usart3_usart4_lpuart1_irq_init>:
static inline void usart3_usart4_lpuart1_irq_init(void) {
#if defined(STM32_USART3_IS_USED) || defined(STM32_UART4_IS_USED) ||        \
    defined(STM32_LPUART1_IS_USED)
  nvicEnableVector(STM32_USART3_4_LP1_NUMBER, STM32_IRQ_USART3_4_LP1_PRIORITY);
#endif
}
 8000ce0:	46c0      	nop			@ (mov r8, r8)
 8000ce2:	4770      	bx	lr
	...

08000cf0 <tim1_irq_init>:
static inline void tim1_irq_init(void) {
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_IRQ_TIM1_UP_PRIORITY);
  nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8000cf0:	46c0      	nop			@ (mov r8, r8)
 8000cf2:	4770      	bx	lr
	...

08000d00 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8000d00:	b510      	push	{r4, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8000d02:	2101      	movs	r1, #1
 8000d04:	200f      	movs	r0, #15
 8000d06:	f7ff ff1b 	bl	8000b40 <nvicEnableVector>
#endif
}
 8000d0a:	46c0      	nop			@ (mov r8, r8)
 8000d0c:	bd10      	pop	{r4, pc}
 8000d0e:	46c0      	nop			@ (mov r8, r8)

08000d10 <Vector7C>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000d10:	b500      	push	{lr}
 8000d12:	b083      	sub	sp, #12
 8000d14:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000d16:	9301      	str	r3, [sp, #4]
 8000d18:	4b0a      	ldr	r3, [pc, #40]	@ (8000d44 <Vector7C+0x34>)
 8000d1a:	0018      	movs	r0, r3
 8000d1c:	f001 fd28 	bl	8002770 <__trace_isr_enter>
 8000d20:	f001 fb7e 	bl	8002420 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000d24:	f001 f844 	bl	8001db0 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000d28:	f001 fbaa 	bl	8002480 <__dbg_check_leave_isr>
 8000d2c:	4b05      	ldr	r3, [pc, #20]	@ (8000d44 <Vector7C+0x34>)
 8000d2e:	0018      	movs	r0, r3
 8000d30:	f001 fd4e 	bl	80027d0 <__trace_isr_leave>
 8000d34:	9b01      	ldr	r3, [sp, #4]
 8000d36:	0018      	movs	r0, r3
 8000d38:	f003 ffe2 	bl	8004d00 <__port_irq_epilogue>
}
 8000d3c:	46c0      	nop			@ (mov r8, r8)
 8000d3e:	b003      	add	sp, #12
 8000d40:	bd00      	pop	{pc}
 8000d42:	46c0      	nop			@ (mov r8, r8)
 8000d44:	0800504c 	.word	0x0800504c
	...

08000d50 <tim3_irq_init>:

static inline void tim3_irq_init(void) {
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
 8000d50:	46c0      	nop			@ (mov r8, r8)
 8000d52:	4770      	bx	lr
	...

08000d60 <tim6_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim6_irq_init(void) {
 8000d60:	b510      	push	{r4, lr}
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
 8000d62:	2101      	movs	r1, #1
 8000d64:	2011      	movs	r0, #17
 8000d66:	f7ff feeb 	bl	8000b40 <nvicEnableVector>
#endif
}
 8000d6a:	46c0      	nop			@ (mov r8, r8)
 8000d6c:	bd10      	pop	{r4, pc}
 8000d6e:	46c0      	nop			@ (mov r8, r8)

08000d70 <Vector84>:
/**
 * @brief   TIM6 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM6_HANDLER) {
 8000d70:	b500      	push	{lr}
 8000d72:	b083      	sub	sp, #12
 8000d74:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000d76:	9301      	str	r3, [sp, #4]
 8000d78:	4b0b      	ldr	r3, [pc, #44]	@ (8000da8 <Vector84+0x38>)
 8000d7a:	0018      	movs	r0, r3
 8000d7c:	f001 fcf8 	bl	8002770 <__trace_isr_enter>
 8000d80:	f001 fb4e 	bl	8002420 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM6
  gpt_lld_serve_interrupt(&GPTD6);
 8000d84:	4b09      	ldr	r3, [pc, #36]	@ (8000dac <Vector84+0x3c>)
 8000d86:	0018      	movs	r0, r3
 8000d88:	f001 f8fa 	bl	8001f80 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM6
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000d8c:	f001 fb78 	bl	8002480 <__dbg_check_leave_isr>
 8000d90:	4b05      	ldr	r3, [pc, #20]	@ (8000da8 <Vector84+0x38>)
 8000d92:	0018      	movs	r0, r3
 8000d94:	f001 fd1c 	bl	80027d0 <__trace_isr_leave>
 8000d98:	9b01      	ldr	r3, [sp, #4]
 8000d9a:	0018      	movs	r0, r3
 8000d9c:	f003 ffb0 	bl	8004d00 <__port_irq_epilogue>
}
 8000da0:	46c0      	nop			@ (mov r8, r8)
 8000da2:	b003      	add	sp, #12
 8000da4:	bd00      	pop	{pc}
 8000da6:	46c0      	nop			@ (mov r8, r8)
 8000da8:	08005058 	.word	0x08005058
 8000dac:	20000674 	.word	0x20000674

08000db0 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 8000db0:	46c0      	nop			@ (mov r8, r8)
 8000db2:	4770      	bx	lr
	...

08000dc0 <tim14_irq_init>:

static inline void tim14_irq_init(void) {
#if defined(STM32_TIM14_IS_USED)
  nvicEnableVector(STM32_TIM14_NUMBER, STM32_IRQ_TIM14_PRIORITY);
#endif
}
 8000dc0:	46c0      	nop			@ (mov r8, r8)
 8000dc2:	4770      	bx	lr
	...

08000dd0 <tim15_irq_init>:

static inline void tim15_irq_init(void) {
#if defined(STM32_TIM15_IS_USED)
  nvicEnableVector(STM32_TIM15_NUMBER, STM32_IRQ_TIM15_PRIORITY);
#endif
}
 8000dd0:	46c0      	nop			@ (mov r8, r8)
 8000dd2:	4770      	bx	lr
	...

08000de0 <tim16_irq_init>:

static inline void tim16_irq_init(void) {
#if defined(STM32_TIM16_IS_USED)
  nvicEnableVector(STM32_TIM16_NUMBER, STM32_IRQ_TIM16_PRIORITY);
#endif
}
 8000de0:	46c0      	nop			@ (mov r8, r8)
 8000de2:	4770      	bx	lr
	...

08000df0 <tim17_irq_init>:

static inline void tim17_irq_init(void) {
#if defined(STM32_TIM17_IS_USED)
  nvicEnableVector(STM32_TIM17_NUMBER, STM32_IRQ_TIM17_PRIORITY);
#endif
}
 8000df0:	46c0      	nop			@ (mov r8, r8)
 8000df2:	4770      	bx	lr
	...

08000e00 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000e00:	b510      	push	{r4, lr}

  exti0_1_irq_init();
 8000e02:	f7ff ff3d 	bl	8000c80 <exti0_1_irq_init>
  exti2_3_irq_init();
 8000e06:	f7ff ff43 	bl	8000c90 <exti2_3_irq_init>
  exti4_15_irq_init();
 8000e0a:	f7ff ff49 	bl	8000ca0 <exti4_15_irq_init>
  exti19_exti21_irq_init();
 8000e0e:	f7ff ff4f 	bl	8000cb0 <exti19_exti21_irq_init>

  tim1_irq_init();
 8000e12:	f7ff ff6d 	bl	8000cf0 <tim1_irq_init>
  tim2_irq_init();
 8000e16:	f7ff ff73 	bl	8000d00 <tim2_irq_init>
#if STM32_HAS_TIM3 && STM32_HAS_TIM4
  tim3_tim4_irq_init();
#elif STM32_HAS_TIM3
  tim3_irq_init();
 8000e1a:	f7ff ff99 	bl	8000d50 <tim3_irq_init>
#endif
  tim6_irq_init();
 8000e1e:	f7ff ff9f 	bl	8000d60 <tim6_irq_init>
  tim7_irq_init();
 8000e22:	f7ff ffc5 	bl	8000db0 <tim7_irq_init>
  tim14_irq_init();
 8000e26:	f7ff ffcb 	bl	8000dc0 <tim14_irq_init>
  tim15_irq_init();
 8000e2a:	f7ff ffd1 	bl	8000dd0 <tim15_irq_init>
  tim16_irq_init();
 8000e2e:	f7ff ffd7 	bl	8000de0 <tim16_irq_init>
  tim17_irq_init();
 8000e32:	f7ff ffdd 	bl	8000df0 <tim17_irq_init>

  usart1_irq_init();
 8000e36:	f7ff ff43 	bl	8000cc0 <usart1_irq_init>
#if STM32_HAS_USART2 && STM32_HAS_LPUART2
  usart2_lpuart2_irq_init();
#elif STM32_HAS_USART2
  usart2_irq_init();
 8000e3a:	f7ff ff49 	bl	8000cd0 <usart2_irq_init>
#endif
#if STM32_HAS_USART3 && STM32_HAS_UART4 && STM32_HAS_UART5 && STM32_HAS_USART6 && STM32_HAS_LPUART1
  usart3_usart4_usart5_usart6_lpuart1_irq_init();
#elif STM32_HAS_USART3 && STM32_HAS_UART4 && STM32_HAS_LPUART1
  usart3_usart4_lpuart1_irq_init();
 8000e3e:	f7ff ff4f 	bl	8000ce0 <usart3_usart4_lpuart1_irq_init>
#elif STM32_HAS_LPUART1
  lpuart1_irq_init();
#endif
}
 8000e42:	46c0      	nop			@ (mov r8, r8)
 8000e44:	bd10      	pop	{r4, pc}
 8000e46:	46c0      	nop			@ (mov r8, r8)
	...

08000e50 <lse_init>:
  while ((RCC->BDCR & (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) !=
         (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) {
  }
#endif
#endif
}
 8000e50:	46c0      	nop			@ (mov r8, r8)
 8000e52:	4770      	bx	lr
	...

08000e60 <lsi_init>:

__STATIC_INLINE void lsi_init(void) {

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= STM32_LSIPRE | RCC_CSR_LSION;
 8000e60:	4b07      	ldr	r3, [pc, #28]	@ (8000e80 <lsi_init+0x20>)
 8000e62:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8000e64:	4b06      	ldr	r3, [pc, #24]	@ (8000e80 <lsi_init+0x20>)
 8000e66:	2101      	movs	r1, #1
 8000e68:	430a      	orrs	r2, r1
 8000e6a:	661a      	str	r2, [r3, #96]	@ 0x60
  while ((RCC->BDCR & RCC_CSR_LSIRDY) == 0U) {
 8000e6c:	46c0      	nop			@ (mov r8, r8)
 8000e6e:	4b04      	ldr	r3, [pc, #16]	@ (8000e80 <lsi_init+0x20>)
 8000e70:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8000e72:	2202      	movs	r2, #2
 8000e74:	4013      	ands	r3, r2
 8000e76:	d0fa      	beq.n	8000e6e <lsi_init+0xe>
  }
#endif
}
 8000e78:	46c0      	nop			@ (mov r8, r8)
 8000e7a:	46c0      	nop			@ (mov r8, r8)
 8000e7c:	4770      	bx	lr
 8000e7e:	46c0      	nop			@ (mov r8, r8)
 8000e80:	40021000 	.word	0x40021000
	...

08000e90 <hsi16_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void hsi16_enable(void) {

  RCC->CR |= RCC_CR_HSION;
 8000e90:	4b08      	ldr	r3, [pc, #32]	@ (8000eb4 <hsi16_enable+0x24>)
 8000e92:	681a      	ldr	r2, [r3, #0]
 8000e94:	4b07      	ldr	r3, [pc, #28]	@ (8000eb4 <hsi16_enable+0x24>)
 8000e96:	2180      	movs	r1, #128	@ 0x80
 8000e98:	0049      	lsls	r1, r1, #1
 8000e9a:	430a      	orrs	r2, r1
 8000e9c:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0U) {
 8000e9e:	46c0      	nop			@ (mov r8, r8)
 8000ea0:	4b04      	ldr	r3, [pc, #16]	@ (8000eb4 <hsi16_enable+0x24>)
 8000ea2:	681a      	ldr	r2, [r3, #0]
 8000ea4:	2380      	movs	r3, #128	@ 0x80
 8000ea6:	00db      	lsls	r3, r3, #3
 8000ea8:	4013      	ands	r3, r2
 8000eaa:	d0f9      	beq.n	8000ea0 <hsi16_enable+0x10>
    /* Waiting for HSI16 activation.*/
  }
}
 8000eac:	46c0      	nop			@ (mov r8, r8)
 8000eae:	46c0      	nop			@ (mov r8, r8)
 8000eb0:	4770      	bx	lr
 8000eb2:	46c0      	nop			@ (mov r8, r8)
 8000eb4:	40021000 	.word	0x40021000
	...

08000ec0 <hsi16_init>:
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI) {
    /* Wait until HSI is selected.*/
  }
}

__STATIC_INLINE void hsi16_init(void) {
 8000ec0:	b510      	push	{r4, lr}

#if STM32_HSI16_ENABLED
  /* HSI activation.*/
  hsi16_enable();
 8000ec2:	f7ff ffe5 	bl	8000e90 <hsi16_enable>
#endif
}
 8000ec6:	46c0      	nop			@ (mov r8, r8)
 8000ec8:	bd10      	pop	{r4, pc}
 8000eca:	46c0      	nop			@ (mov r8, r8)
 8000ecc:	0000      	movs	r0, r0
	...

08000ed0 <hsi48_init>:

#if STM32_HSI48_ENABLED
  /* HSI activation.*/
  hsi48_enable();
#endif
}
 8000ed0:	46c0      	nop			@ (mov r8, r8)
 8000ed2:	4770      	bx	lr
	...

08000ee0 <hse_init>:
__STATIC_INLINE void hse_init(void) {

#if STM32_HSE_ENABLED
  hse_enable();
#endif
}
 8000ee0:	46c0      	nop			@ (mov r8, r8)
 8000ee2:	4770      	bx	lr
	...

08000ef0 <pll_not_locked>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE bool pll_not_locked(void) {

  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8000ef0:	4b04      	ldr	r3, [pc, #16]	@ (8000f04 <pll_not_locked+0x14>)
 8000ef2:	681a      	ldr	r2, [r3, #0]
 8000ef4:	2380      	movs	r3, #128	@ 0x80
 8000ef6:	049b      	lsls	r3, r3, #18
 8000ef8:	4013      	ands	r3, r2
 8000efa:	425a      	negs	r2, r3
 8000efc:	4153      	adcs	r3, r2
 8000efe:	b2db      	uxtb	r3, r3
}
 8000f00:	0018      	movs	r0, r3
 8000f02:	4770      	bx	lr
 8000f04:	40021000 	.word	0x40021000
	...

08000f10 <pll_wait_lock>:

__STATIC_INLINE void pll_wait_lock(void) {
 8000f10:	b510      	push	{r4, lr}

  while (pll_not_locked()) {
 8000f12:	46c0      	nop			@ (mov r8, r8)
 8000f14:	f7ff ffec 	bl	8000ef0 <pll_not_locked>
 8000f18:	1e03      	subs	r3, r0, #0
 8000f1a:	d1fb      	bne.n	8000f14 <pll_wait_lock+0x4>
    /* Waiting for PLL lock.*/
  }
}
 8000f1c:	46c0      	nop			@ (mov r8, r8)
 8000f1e:	46c0      	nop			@ (mov r8, r8)
 8000f20:	bd10      	pop	{r4, pc}
 8000f22:	46c0      	nop			@ (mov r8, r8)
	...

08000f30 <pll_init>:

#endif /* STM32_RCC_HAS_PLL */

__STATIC_INLINE void pll_init(void) {
 8000f30:	b510      	push	{r4, lr}

#if STM32_RCC_HAS_PLL
#if STM32_ACTIVATE_PLL
  /* PLLM and PLLSRC are common to all PLLs.*/
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 8000f32:	4b07      	ldr	r3, [pc, #28]	@ (8000f50 <pll_init+0x20>)
 8000f34:	4a07      	ldr	r2, [pc, #28]	@ (8000f54 <pll_init+0x24>)
 8000f36:	60da      	str	r2, [r3, #12]
                 STM32_PLLP   | STM32_PLLPEN |
                 STM32_PLLN   | STM32_PLLM   |
                 STM32_PLLSRC;

  /* PLL activation.*/
  RCC->CR |= RCC_CR_PLLON;
 8000f38:	4b05      	ldr	r3, [pc, #20]	@ (8000f50 <pll_init+0x20>)
 8000f3a:	681a      	ldr	r2, [r3, #0]
 8000f3c:	4b04      	ldr	r3, [pc, #16]	@ (8000f50 <pll_init+0x20>)
 8000f3e:	2180      	movs	r1, #128	@ 0x80
 8000f40:	0449      	lsls	r1, r1, #17
 8000f42:	430a      	orrs	r2, r1
 8000f44:	601a      	str	r2, [r3, #0]

  pll_wait_lock();
 8000f46:	f7ff ffe3 	bl	8000f10 <pll_wait_lock>
#endif
#endif
}
 8000f4a:	46c0      	nop			@ (mov r8, r8)
 8000f4c:	bd10      	pop	{r4, pc}
 8000f4e:	46c0      	nop			@ (mov r8, r8)
 8000f50:	40021000 	.word	0x40021000
 8000f54:	36031012 	.word	0x36031012
	...

08000f60 <bd_init>:
/*===========================================================================*/

/**
 * @brief   Initializes the backup domain.
 */
__STATIC_INLINE void bd_init(void) {
 8000f60:	b082      	sub	sp, #8
  uint32_t bdcr;

  /* Current settings.*/
  bdcr = RCC->BDCR;
 8000f62:	4b06      	ldr	r3, [pc, #24]	@ (8000f7c <bd_init+0x1c>)
 8000f64:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8000f66:	9301      	str	r3, [sp, #4]
    bdcr |= RCC_BDCR_RTCEN;
  }
#endif

  /* Selectors.*/
  bdcr &= ~(STM32_RTCSEL_MASK | STM32_LSCOSEL_MASK);
 8000f68:	9b01      	ldr	r3, [sp, #4]
 8000f6a:	4a05      	ldr	r2, [pc, #20]	@ (8000f80 <bd_init+0x20>)
 8000f6c:	4013      	ands	r3, r2
 8000f6e:	9301      	str	r3, [sp, #4]
  bdcr |= STM32_RTCSEL | STM32_LSCOSEL;

  /* Final settings.*/
  RCC->BDCR = bdcr;
 8000f70:	4b02      	ldr	r3, [pc, #8]	@ (8000f7c <bd_init+0x1c>)
 8000f72:	9a01      	ldr	r2, [sp, #4]
 8000f74:	65da      	str	r2, [r3, #92]	@ 0x5c
}
 8000f76:	46c0      	nop			@ (mov r8, r8)
 8000f78:	b002      	add	sp, #8
 8000f7a:	4770      	bx	lr
 8000f7c:	40021000 	.word	0x40021000
 8000f80:	fcfffcff 	.word	0xfcfffcff
	...

08000f90 <bd_reset>:
 *          of the whole BKP domain.
 */
__STATIC_INLINE void bd_reset(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8000f90:	4b07      	ldr	r3, [pc, #28]	@ (8000fb0 <bd_reset+0x20>)
 8000f92:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 8000f94:	23c0      	movs	r3, #192	@ 0xc0
 8000f96:	009b      	lsls	r3, r3, #2
 8000f98:	4013      	ands	r3, r2
 8000f9a:	d006      	beq.n	8000faa <bd_reset+0x1a>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000f9c:	4b04      	ldr	r3, [pc, #16]	@ (8000fb0 <bd_reset+0x20>)
 8000f9e:	2280      	movs	r2, #128	@ 0x80
 8000fa0:	0252      	lsls	r2, r2, #9
 8000fa2:	65da      	str	r2, [r3, #92]	@ 0x5c
    RCC->BDCR = 0U;
 8000fa4:	4b02      	ldr	r3, [pc, #8]	@ (8000fb0 <bd_reset+0x20>)
 8000fa6:	2200      	movs	r2, #0
 8000fa8:	65da      	str	r2, [r3, #92]	@ 0x5c
  }
}
 8000faa:	46c0      	nop			@ (mov r8, r8)
 8000fac:	4770      	bx	lr
 8000fae:	46c0      	nop			@ (mov r8, r8)
 8000fb0:	40021000 	.word	0x40021000
	...

08000fc0 <flash_set_acr>:
/**
 * @brief   Safe setting of flash ACR register.
 *
 * @param[in] acr       value for the ACR register
 */
__STATIC_INLINE void flash_set_acr(uint32_t acr) {
 8000fc0:	b082      	sub	sp, #8
 8000fc2:	9001      	str	r0, [sp, #4]

  FLASH->ACR = acr;
 8000fc4:	4b07      	ldr	r3, [pc, #28]	@ (8000fe4 <flash_set_acr+0x24>)
 8000fc6:	9a01      	ldr	r2, [sp, #4]
 8000fc8:	601a      	str	r2, [r3, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) != (acr & FLASH_ACR_LATENCY_Msk)) {
 8000fca:	46c0      	nop			@ (mov r8, r8)
 8000fcc:	4b05      	ldr	r3, [pc, #20]	@ (8000fe4 <flash_set_acr+0x24>)
 8000fce:	681a      	ldr	r2, [r3, #0]
 8000fd0:	9b01      	ldr	r3, [sp, #4]
 8000fd2:	4053      	eors	r3, r2
 8000fd4:	2207      	movs	r2, #7
 8000fd6:	4013      	ands	r3, r2
 8000fd8:	d1f8      	bne.n	8000fcc <flash_set_acr+0xc>
    /* Waiting for flash wait states setup.*/
  }
}
 8000fda:	46c0      	nop			@ (mov r8, r8)
 8000fdc:	46c0      	nop			@ (mov r8, r8)
 8000fde:	b002      	add	sp, #8
 8000fe0:	4770      	bx	lr
 8000fe2:	46c0      	nop			@ (mov r8, r8)
 8000fe4:	40022000 	.word	0x40022000
	...

08000ff0 <hal_lld_set_static_pwr>:
 * @note    CR1, CR2 and CR5 are not initialized inside this function.
 */
__STATIC_INLINE void hal_lld_set_static_pwr(void) {

  /* PWR clock enabled.*/
  rccEnablePWRInterface(false);
 8000ff0:	4b1a      	ldr	r3, [pc, #104]	@ (800105c <hal_lld_set_static_pwr+0x6c>)
 8000ff2:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8000ff4:	4b19      	ldr	r3, [pc, #100]	@ (800105c <hal_lld_set_static_pwr+0x6c>)
 8000ff6:	2180      	movs	r1, #128	@ 0x80
 8000ff8:	0549      	lsls	r1, r1, #21
 8000ffa:	430a      	orrs	r2, r1
 8000ffc:	63da      	str	r2, [r3, #60]	@ 0x3c
 8000ffe:	4b17      	ldr	r3, [pc, #92]	@ (800105c <hal_lld_set_static_pwr+0x6c>)
 8001000:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001002:	4b16      	ldr	r3, [pc, #88]	@ (800105c <hal_lld_set_static_pwr+0x6c>)
 8001004:	4916      	ldr	r1, [pc, #88]	@ (8001060 <hal_lld_set_static_pwr+0x70>)
 8001006:	400a      	ands	r2, r1
 8001008:	64da      	str	r2, [r3, #76]	@ 0x4c
 800100a:	4b14      	ldr	r3, [pc, #80]	@ (800105c <hal_lld_set_static_pwr+0x6c>)
 800100c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c

  /* Static PWR configurations.*/
  PWR->CR3   = STM32_PWR_CR3;
 800100e:	4b15      	ldr	r3, [pc, #84]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 8001010:	2280      	movs	r2, #128	@ 0x80
 8001012:	0212      	lsls	r2, r2, #8
 8001014:	609a      	str	r2, [r3, #8]
  PWR->CR4   = STM32_PWR_CR4;
 8001016:	4b13      	ldr	r3, [pc, #76]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 8001018:	2200      	movs	r2, #0
 800101a:	60da      	str	r2, [r3, #12]
  PWR->PUCRA = STM32_PWR_PUCRA;
 800101c:	4b11      	ldr	r3, [pc, #68]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 800101e:	2200      	movs	r2, #0
 8001020:	621a      	str	r2, [r3, #32]
  PWR->PDCRA = STM32_PWR_PDCRA;
 8001022:	4b10      	ldr	r3, [pc, #64]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 8001024:	2200      	movs	r2, #0
 8001026:	625a      	str	r2, [r3, #36]	@ 0x24
  PWR->PUCRB = STM32_PWR_PUCRB;
 8001028:	4b0e      	ldr	r3, [pc, #56]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 800102a:	2200      	movs	r2, #0
 800102c:	629a      	str	r2, [r3, #40]	@ 0x28
  PWR->PDCRB = STM32_PWR_PDCRB;
 800102e:	4b0d      	ldr	r3, [pc, #52]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 8001030:	2200      	movs	r2, #0
 8001032:	62da      	str	r2, [r3, #44]	@ 0x2c
  PWR->PUCRC = STM32_PWR_PUCRC;
 8001034:	4b0b      	ldr	r3, [pc, #44]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 8001036:	2200      	movs	r2, #0
 8001038:	631a      	str	r2, [r3, #48]	@ 0x30
  PWR->PDCRC = STM32_PWR_PDCRC;
 800103a:	4b0a      	ldr	r3, [pc, #40]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 800103c:	2200      	movs	r2, #0
 800103e:	635a      	str	r2, [r3, #52]	@ 0x34
#if STM32_HAS_GPIOD
  PWR->PUCRD = STM32_PWR_PUCRD;
 8001040:	4b08      	ldr	r3, [pc, #32]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 8001042:	2200      	movs	r2, #0
 8001044:	639a      	str	r2, [r3, #56]	@ 0x38
  PWR->PDCRD = STM32_PWR_PDCRD;
 8001046:	4b07      	ldr	r3, [pc, #28]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 8001048:	2200      	movs	r2, #0
 800104a:	63da      	str	r2, [r3, #60]	@ 0x3c
#if STM32_HAS_GPIOE
  PWR->PUCRE = STM32_PWR_PUCRE;
  PWR->PDCRE = STM32_PWR_PDCRE;
#endif
#if STM32_HAS_GPIOF
  PWR->PUCRF = STM32_PWR_PUCRF;
 800104c:	4b05      	ldr	r3, [pc, #20]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 800104e:	2200      	movs	r2, #0
 8001050:	649a      	str	r2, [r3, #72]	@ 0x48
  PWR->PDCRF = STM32_PWR_PDCRF;
 8001052:	4b04      	ldr	r3, [pc, #16]	@ (8001064 <hal_lld_set_static_pwr+0x74>)
 8001054:	2200      	movs	r2, #0
 8001056:	64da      	str	r2, [r3, #76]	@ 0x4c
#endif
#if STM32_HAS_GPIOI
  PWR->PUCRI = STM32_PWR_PUCRI;
  PWR->PDCRI = STM32_PWR_PDCRI;
#endif
}
 8001058:	46c0      	nop			@ (mov r8, r8)
 800105a:	4770      	bx	lr
 800105c:	40021000 	.word	0x40021000
 8001060:	efffffff 	.word	0xefffffff
 8001064:	40007000 	.word	0x40007000
	...

08001070 <hal_lld_set_static_clocks>:
 * @brief   Initializes static muxes and dividers.
 */
__STATIC_INLINE void hal_lld_set_static_clocks(void) {

  /* Clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_PPRE | STM32_HPRE;
 8001070:	4b06      	ldr	r3, [pc, #24]	@ (800108c <hal_lld_set_static_clocks+0x1c>)
 8001072:	2200      	movs	r2, #0
 8001074:	609a      	str	r2, [r3, #8]

  /* Set HSISYS divisor.*/
  RCC->CR = (RCC->CR & ~STM32_HSIDIV_MASK) | STM32_HSIDIV;
 8001076:	4b05      	ldr	r3, [pc, #20]	@ (800108c <hal_lld_set_static_clocks+0x1c>)
 8001078:	681a      	ldr	r2, [r3, #0]
 800107a:	4b04      	ldr	r3, [pc, #16]	@ (800108c <hal_lld_set_static_clocks+0x1c>)
 800107c:	4904      	ldr	r1, [pc, #16]	@ (8001090 <hal_lld_set_static_clocks+0x20>)
 800107e:	400a      	ands	r2, r1
 8001080:	601a      	str	r2, [r3, #0]
  /* CCIPR2 register initialization.*/
  RCC->CCIPR2 = STM32_USBSEL    | STM32_FDCANSEL  | STM32_I2S2SEL   |
                STM32_I2S1SEL;
#else
  /* CCIPR register initialization.*/
  RCC->CCIPR =  STM32_ADCSEL    | STM32_RNGDIV     | STM32_RNGSEL    |
 8001082:	4b02      	ldr	r3, [pc, #8]	@ (800108c <hal_lld_set_static_clocks+0x1c>)
 8001084:	4a03      	ldr	r2, [pc, #12]	@ (8001094 <hal_lld_set_static_clocks+0x24>)
 8001086:	655a      	str	r2, [r3, #84]	@ 0x54
                STM32_TIM15SEL  | STM32_TIM1SEL    | STM32_LPTIM2SEL |
                STM32_LPTIM1SEL | STM32_I2S1SEL    | STM32_I2C1SEL   |
                STM32_CECSEL    | STM32_USART3SEL  | STM32_USART2SEL |
                STM32_USART1SEL | STM32_LPUART2SEL | STM32_LPUART1SEL;
#endif
}
 8001088:	46c0      	nop			@ (mov r8, r8)
 800108a:	4770      	bx	lr
 800108c:	40021000 	.word	0x40021000
 8001090:	ffffc7ff 	.word	0xffffc7ff
 8001094:	44000515 	.word	0x44000515
	...

080010a0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80010a0:	b510      	push	{r4, lr}

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80010a2:	f000 fc0d 	bl	80018c0 <dmaInit>
#endif

  /* NVIC initialization.*/
  nvicInit();
 80010a6:	f7ff fd23 	bl	8000af0 <nvicInit>

  /* IRQ subsystem initialization.*/
  irqInit();
 80010aa:	f7ff fea9 	bl	8000e00 <irqInit>
}
 80010ae:	46c0      	nop			@ (mov r8, r8)
 80010b0:	bd10      	pop	{r4, pc}
 80010b2:	46c0      	nop			@ (mov r8, r8)
	...

080010c0 <stm32_clock_init>:
  bd_init();
#endif /* STM32_NO_INIT */
}

#else /* !defined(HAL_LLD_USE_CLOCK_MANAGEMENT) */
void stm32_clock_init(void) {
 80010c0:	b510      	push	{r4, lr}

#if !STM32_NO_INIT
  /* Reset of all peripherals.*/
  rccResetAHB(~0);
 80010c2:	4b3d      	ldr	r3, [pc, #244]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010c4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80010c6:	4b3c      	ldr	r3, [pc, #240]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010c8:	2201      	movs	r2, #1
 80010ca:	4252      	negs	r2, r2
 80010cc:	629a      	str	r2, [r3, #40]	@ 0x28
 80010ce:	4b3a      	ldr	r3, [pc, #232]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010d0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80010d2:	4b39      	ldr	r3, [pc, #228]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010d4:	2200      	movs	r2, #0
 80010d6:	629a      	str	r2, [r3, #40]	@ 0x28
 80010d8:	4b37      	ldr	r3, [pc, #220]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010da:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  rccResetAPBR1(~0);
 80010dc:	4b36      	ldr	r3, [pc, #216]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010de:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80010e0:	4b35      	ldr	r3, [pc, #212]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010e2:	2201      	movs	r2, #1
 80010e4:	4252      	negs	r2, r2
 80010e6:	62da      	str	r2, [r3, #44]	@ 0x2c
 80010e8:	4b33      	ldr	r3, [pc, #204]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010ea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80010ec:	4b32      	ldr	r3, [pc, #200]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010ee:	2200      	movs	r2, #0
 80010f0:	62da      	str	r2, [r3, #44]	@ 0x2c
 80010f2:	4b31      	ldr	r3, [pc, #196]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010f4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccResetAPBR2(~0);
 80010f6:	4b30      	ldr	r3, [pc, #192]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010f8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80010fa:	4b2f      	ldr	r3, [pc, #188]	@ (80011b8 <stm32_clock_init+0xf8>)
 80010fc:	2201      	movs	r2, #1
 80010fe:	4252      	negs	r2, r2
 8001100:	631a      	str	r2, [r3, #48]	@ 0x30
 8001102:	4b2d      	ldr	r3, [pc, #180]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001104:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001106:	4b2c      	ldr	r3, [pc, #176]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001108:	2200      	movs	r2, #0
 800110a:	631a      	str	r2, [r3, #48]	@ 0x30
 800110c:	4b2a      	ldr	r3, [pc, #168]	@ (80011b8 <stm32_clock_init+0xf8>)
 800110e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPBR2(RCC_APBENR2_SYSCFGEN, false);
 8001110:	4b29      	ldr	r3, [pc, #164]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001112:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8001114:	4b28      	ldr	r3, [pc, #160]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001116:	2101      	movs	r1, #1
 8001118:	430a      	orrs	r2, r1
 800111a:	641a      	str	r2, [r3, #64]	@ 0x40
 800111c:	4b26      	ldr	r3, [pc, #152]	@ (80011b8 <stm32_clock_init+0xf8>)
 800111e:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8001120:	4b25      	ldr	r3, [pc, #148]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001122:	2101      	movs	r1, #1
 8001124:	438a      	bics	r2, r1
 8001126:	651a      	str	r2, [r3, #80]	@ 0x50
 8001128:	4b23      	ldr	r3, [pc, #140]	@ (80011b8 <stm32_clock_init+0xf8>)
 800112a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50

#if defined(HAL_USE_RTC) && defined(RCC_APBENR1_RTCAPBEN)
  rccEnableAPBR1(RCC_APBENR1_RTCAPBEN, false);
 800112c:	4b22      	ldr	r3, [pc, #136]	@ (80011b8 <stm32_clock_init+0xf8>)
 800112e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8001130:	4b21      	ldr	r3, [pc, #132]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001132:	2180      	movs	r1, #128	@ 0x80
 8001134:	00c9      	lsls	r1, r1, #3
 8001136:	430a      	orrs	r2, r1
 8001138:	63da      	str	r2, [r3, #60]	@ 0x3c
 800113a:	4b1f      	ldr	r3, [pc, #124]	@ (80011b8 <stm32_clock_init+0xf8>)
 800113c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800113e:	4b1e      	ldr	r3, [pc, #120]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001140:	491e      	ldr	r1, [pc, #120]	@ (80011bc <stm32_clock_init+0xfc>)
 8001142:	400a      	ands	r2, r1
 8001144:	64da      	str	r2, [r3, #76]	@ 0x4c
 8001146:	4b1c      	ldr	r3, [pc, #112]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001148:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
#endif

  /* Static PWR configurations.*/
  hal_lld_set_static_pwr();
 800114a:	f7ff ff51 	bl	8000ff0 <hal_lld_set_static_pwr>

  /* Additional PWR configurations.*/
  PWR->CR2 = STM32_PWR_CR2;
 800114e:	4b1c      	ldr	r3, [pc, #112]	@ (80011c0 <stm32_clock_init+0x100>)
 8001150:	2200      	movs	r2, #0
 8001152:	605a      	str	r2, [r3, #4]

  /* Core voltage setup.*/
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 8001154:	4b1a      	ldr	r3, [pc, #104]	@ (80011c0 <stm32_clock_init+0x100>)
 8001156:	22c0      	movs	r2, #192	@ 0xc0
 8001158:	0092      	lsls	r2, r2, #2
 800115a:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 800115c:	46c0      	nop			@ (mov r8, r8)
 800115e:	4b18      	ldr	r3, [pc, #96]	@ (80011c0 <stm32_clock_init+0x100>)
 8001160:	695a      	ldr	r2, [r3, #20]
 8001162:	2380      	movs	r3, #128	@ 0x80
 8001164:	00db      	lsls	r3, r3, #3
 8001166:	4013      	ands	r3, r2
 8001168:	d1f9      	bne.n	800115e <stm32_clock_init+0x9e>
    ;                                       /* stable.                      */

  /* Backup domain reset.*/
  bd_reset();
 800116a:	f7ff ff11 	bl	8000f90 <bd_reset>

  /* Clocks setup.*/
  lse_init();
 800116e:	f7ff fe6f 	bl	8000e50 <lse_init>
  lsi_init();
 8001172:	f7ff fe75 	bl	8000e60 <lsi_init>
  hsi16_init();
 8001176:	f7ff fea3 	bl	8000ec0 <hsi16_init>
  hsi48_init();
 800117a:	f7ff fea9 	bl	8000ed0 <hsi48_init>
  hse_init();
 800117e:	f7ff feaf 	bl	8000ee0 <hse_init>

  /* Backup domain initializations.*/
  bd_init();
 8001182:	f7ff feed 	bl	8000f60 <bd_init>

  /* PLLs activation, if required.*/
  pll_init();
 8001186:	f7ff fed3 	bl	8000f30 <pll_init>

  /* Static clocks setup.*/
  hal_lld_set_static_clocks();
 800118a:	f7ff ff71 	bl	8001070 <hal_lld_set_static_clocks>

  /* Set flash WS's for SYSCLK source.*/
  flash_set_acr(FLASH_ACR_DBG_SWEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 800118e:	4b0d      	ldr	r3, [pc, #52]	@ (80011c4 <stm32_clock_init+0x104>)
 8001190:	0018      	movs	r0, r3
 8001192:	f7ff ff15 	bl	8000fc0 <flash_set_acr>
                STM32_FLASHBITS);

  /* Switching to the configured SYSCLK source if it is different from HSI16.*/
#if STM32_SW != STM32_SW_HSISYS
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001196:	4b08      	ldr	r3, [pc, #32]	@ (80011b8 <stm32_clock_init+0xf8>)
 8001198:	689a      	ldr	r2, [r3, #8]
 800119a:	4b07      	ldr	r3, [pc, #28]	@ (80011b8 <stm32_clock_init+0xf8>)
 800119c:	2102      	movs	r1, #2
 800119e:	430a      	orrs	r2, r1
 80011a0:	609a      	str	r2, [r3, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 3))
 80011a2:	46c0      	nop			@ (mov r8, r8)
 80011a4:	4b04      	ldr	r3, [pc, #16]	@ (80011b8 <stm32_clock_init+0xf8>)
 80011a6:	689b      	ldr	r3, [r3, #8]
 80011a8:	2238      	movs	r2, #56	@ 0x38
 80011aa:	4013      	ands	r3, r2
 80011ac:	2b10      	cmp	r3, #16
 80011ae:	d1f9      	bne.n	80011a4 <stm32_clock_init+0xe4>
    ;
#endif

#endif /* STM32_NO_INIT */
}
 80011b0:	46c0      	nop			@ (mov r8, r8)
 80011b2:	46c0      	nop			@ (mov r8, r8)
 80011b4:	bd10      	pop	{r4, pc}
 80011b6:	46c0      	nop			@ (mov r8, r8)
 80011b8:	40021000 	.word	0x40021000
 80011bc:	fffffbff 	.word	0xfffffbff
 80011c0:	40007000 	.word	0x40007000
 80011c4:	00040302 	.word	0x00040302
	...

080011d0 <port_lock.lto_priv.4>:
  __ASM volatile ("cpsid i" : : : "memory");
 80011d0:	b672      	cpsid	i
}
 80011d2:	46c0      	nop			@ (mov r8, r8)
}
 80011d4:	46c0      	nop			@ (mov r8, r8)
 80011d6:	4770      	bx	lr
	...

080011e0 <port_unlock.lto_priv.4>:
  __ASM volatile ("cpsie i" : : : "memory");
 80011e0:	b662      	cpsie	i
}
 80011e2:	46c0      	nop			@ (mov r8, r8)
}
 80011e4:	46c0      	nop			@ (mov r8, r8)
 80011e6:	4770      	bx	lr
	...

080011f0 <port_lock_from_isr.lto_priv.0>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80011f0:	b510      	push	{r4, lr}

  port_lock();
 80011f2:	f7ff ffed 	bl	80011d0 <port_lock.lto_priv.4>
}
 80011f6:	46c0      	nop			@ (mov r8, r8)
 80011f8:	bd10      	pop	{r4, pc}
 80011fa:	46c0      	nop			@ (mov r8, r8)
 80011fc:	0000      	movs	r0, r0
	...

08001200 <port_unlock_from_isr.lto_priv.0>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001200:	b510      	push	{r4, lr}

  port_unlock();
 8001202:	f7ff ffed 	bl	80011e0 <port_unlock.lto_priv.4>
}
 8001206:	46c0      	nop			@ (mov r8, r8)
 8001208:	bd10      	pop	{r4, pc}
 800120a:	46c0      	nop			@ (mov r8, r8)
 800120c:	0000      	movs	r0, r0
	...

08001210 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001210:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8001212:	f7ff ffed 	bl	80011f0 <port_lock_from_isr.lto_priv.0>
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 8001216:	f001 f8b3 	bl	8002380 <__dbg_check_lock_from_isr>
}
 800121a:	46c0      	nop			@ (mov r8, r8)
 800121c:	bd10      	pop	{r4, pc}
 800121e:	46c0      	nop			@ (mov r8, r8)

08001220 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001220:	b510      	push	{r4, lr}

  __dbg_check_unlock_from_isr();
 8001222:	f001 f8d5 	bl	80023d0 <__dbg_check_unlock_from_isr>
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001226:	f7ff ffeb 	bl	8001200 <port_unlock_from_isr.lto_priv.0>
}
 800122a:	46c0      	nop			@ (mov r8, r8)
 800122c:	bd10      	pop	{r4, pc}
 800122e:	46c0      	nop			@ (mov r8, r8)

08001230 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 8001230:	b510      	push	{r4, lr}
  chSysLockFromISR();
 8001232:	f7ff ffed 	bl	8001210 <chSysLockFromISR.lto_priv.0>
}
 8001236:	46c0      	nop			@ (mov r8, r8)
 8001238:	bd10      	pop	{r4, pc}
 800123a:	46c0      	nop			@ (mov r8, r8)
 800123c:	0000      	movs	r0, r0
	...

08001240 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 8001240:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 8001242:	f7ff ffed 	bl	8001220 <chSysUnlockFromISR.lto_priv.0>
}
 8001246:	46c0      	nop			@ (mov r8, r8)
 8001248:	bd10      	pop	{r4, pc}
 800124a:	46c0      	nop			@ (mov r8, r8)
 800124c:	0000      	movs	r0, r0
	...

08001250 <osalThreadResumeI.lto_priv.1>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001250:	b500      	push	{lr}
 8001252:	b083      	sub	sp, #12
 8001254:	9001      	str	r0, [sp, #4]
 8001256:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8001258:	9a00      	ldr	r2, [sp, #0]
 800125a:	9b01      	ldr	r3, [sp, #4]
 800125c:	0011      	movs	r1, r2
 800125e:	0018      	movs	r0, r3
 8001260:	f002 fec6 	bl	8003ff0 <chThdResumeI>
}
 8001264:	46c0      	nop			@ (mov r8, r8)
 8001266:	b003      	add	sp, #12
 8001268:	bd00      	pop	{pc}
 800126a:	46c0      	nop			@ (mov r8, r8)
 800126c:	0000      	movs	r0, r0
	...

08001270 <adc_lld_vreg_on>:
/**
 * @brief   ADC voltage regulator enable.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
NOINLINE static void adc_lld_vreg_on(ADC_TypeDef *adc) {
 8001270:	b500      	push	{lr}
 8001272:	b085      	sub	sp, #20
 8001274:	9001      	str	r0, [sp, #4]

  osalDbgAssert(adc->CR == 0, "invalid register state");
 8001276:	9b01      	ldr	r3, [sp, #4]
 8001278:	689b      	ldr	r3, [r3, #8]
 800127a:	1e5a      	subs	r2, r3, #1
 800127c:	4193      	sbcs	r3, r2
 800127e:	b2db      	uxtb	r3, r3
 8001280:	2b00      	cmp	r3, #0
 8001282:	d003      	beq.n	800128c <adc_lld_vreg_on+0x1c>
 8001284:	4b0a      	ldr	r3, [pc, #40]	@ (80012b0 <adc_lld_vreg_on+0x40>)
 8001286:	0018      	movs	r0, r3
 8001288:	f000 ffba 	bl	8002200 <chSysHalt>

#if defined(ADC_CR_ADVREGEN)
  adc->CR = ADC_CR_ADVREGEN;
 800128c:	9b01      	ldr	r3, [sp, #4]
 800128e:	2280      	movs	r2, #128	@ 0x80
 8001290:	0552      	lsls	r2, r2, #21
 8001292:	609a      	str	r2, [r3, #8]
  volatile uint32_t loop = STM32_HCLK >> 16;
 8001294:	23f4      	movs	r3, #244	@ 0xf4
 8001296:	009b      	lsls	r3, r3, #2
 8001298:	9303      	str	r3, [sp, #12]
  do {
    loop--;
 800129a:	9b03      	ldr	r3, [sp, #12]
 800129c:	3b01      	subs	r3, #1
 800129e:	9303      	str	r3, [sp, #12]
  } while (loop > 0);
 80012a0:	9b03      	ldr	r3, [sp, #12]
 80012a2:	2b00      	cmp	r3, #0
 80012a4:	d1f9      	bne.n	800129a <adc_lld_vreg_on+0x2a>
#else
#endif
}
 80012a6:	46c0      	nop			@ (mov r8, r8)
 80012a8:	46c0      	nop			@ (mov r8, r8)
 80012aa:	b005      	add	sp, #20
 80012ac:	bd00      	pop	{pc}
 80012ae:	46c0      	nop			@ (mov r8, r8)
 80012b0:	08005064 	.word	0x08005064
	...

080012c0 <adc_lld_calibrate>:
/**
 * @brief   Calibrates an ADC unit.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_calibrate(ADC_TypeDef *adc) {
 80012c0:	b082      	sub	sp, #8
 80012c2:	9001      	str	r0, [sp, #4]

  adc->CR |= ADC_CR_ADCAL;
 80012c4:	9b01      	ldr	r3, [sp, #4]
 80012c6:	689b      	ldr	r3, [r3, #8]
 80012c8:	2280      	movs	r2, #128	@ 0x80
 80012ca:	0612      	lsls	r2, r2, #24
 80012cc:	431a      	orrs	r2, r3
 80012ce:	9b01      	ldr	r3, [sp, #4]
 80012d0:	609a      	str	r2, [r3, #8]
  while (adc->CR & ADC_CR_ADCAL) {
 80012d2:	46c0      	nop			@ (mov r8, r8)
 80012d4:	9b01      	ldr	r3, [sp, #4]
 80012d6:	689b      	ldr	r3, [r3, #8]
 80012d8:	2b00      	cmp	r3, #0
 80012da:	dbfb      	blt.n	80012d4 <adc_lld_calibrate+0x14>
    /* Waiting for calibration end.*/
  }
}
 80012dc:	46c0      	nop			@ (mov r8, r8)
 80012de:	46c0      	nop			@ (mov r8, r8)
 80012e0:	b002      	add	sp, #8
 80012e2:	4770      	bx	lr
	...

080012f0 <adc_lld_stop_adc>:
/**
 * @brief   Stops an ongoing conversion, if any.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {
 80012f0:	b082      	sub	sp, #8
 80012f2:	9001      	str	r0, [sp, #4]

  if (adc->CR & ADC_CR_ADSTART) {
 80012f4:	9b01      	ldr	r3, [sp, #4]
 80012f6:	689b      	ldr	r3, [r3, #8]
 80012f8:	2204      	movs	r2, #4
 80012fa:	4013      	ands	r3, r2
 80012fc:	d00e      	beq.n	800131c <adc_lld_stop_adc+0x2c>
    adc->CR |= ADC_CR_ADSTP;
 80012fe:	9b01      	ldr	r3, [sp, #4]
 8001300:	689b      	ldr	r3, [r3, #8]
 8001302:	2210      	movs	r2, #16
 8001304:	431a      	orrs	r2, r3
 8001306:	9b01      	ldr	r3, [sp, #4]
 8001308:	609a      	str	r2, [r3, #8]
    while (adc->CR & ADC_CR_ADSTP)
 800130a:	46c0      	nop			@ (mov r8, r8)
 800130c:	9b01      	ldr	r3, [sp, #4]
 800130e:	689b      	ldr	r3, [r3, #8]
 8001310:	2210      	movs	r2, #16
 8001312:	4013      	ands	r3, r2
 8001314:	d1fa      	bne.n	800130c <adc_lld_stop_adc+0x1c>
      ;
    adc->IER = 0;
 8001316:	9b01      	ldr	r3, [sp, #4]
 8001318:	2200      	movs	r2, #0
 800131a:	605a      	str	r2, [r3, #4]
  }

  /* Disabling the ADC.*/
  adc->CR |= ADC_CR_ADDIS;
 800131c:	9b01      	ldr	r3, [sp, #4]
 800131e:	689b      	ldr	r3, [r3, #8]
 8001320:	2202      	movs	r2, #2
 8001322:	431a      	orrs	r2, r3
 8001324:	9b01      	ldr	r3, [sp, #4]
 8001326:	609a      	str	r2, [r3, #8]
  while ((adc->CR & ADC_CR_ADEN) != 0U) {
 8001328:	46c0      	nop			@ (mov r8, r8)
 800132a:	9b01      	ldr	r3, [sp, #4]
 800132c:	689b      	ldr	r3, [r3, #8]
 800132e:	2201      	movs	r2, #1
 8001330:	4013      	ands	r3, r2
 8001332:	d1fa      	bne.n	800132a <adc_lld_stop_adc+0x3a>
    /* Waiting for ADC to be disabled.*/
  }
}
 8001334:	46c0      	nop			@ (mov r8, r8)
 8001336:	46c0      	nop			@ (mov r8, r8)
 8001338:	b002      	add	sp, #8
 800133a:	4770      	bx	lr
 800133c:	0000      	movs	r0, r0
	...

08001340 <adc_lld_serve_rx_interrupt>:
 * @brief   ADC DMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001340:	b500      	push	{lr}
 8001342:	b083      	sub	sp, #12
 8001344:	9001      	str	r0, [sp, #4]
 8001346:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001348:	9b00      	ldr	r3, [sp, #0]
 800134a:	2208      	movs	r2, #8
 800134c:	4013      	ands	r3, r2
 800134e:	d030      	beq.n	80013b2 <adc_lld_serve_rx_interrupt+0x72>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8001350:	9b01      	ldr	r3, [sp, #4]
 8001352:	0018      	movs	r0, r3
 8001354:	f000 f9e4 	bl	8001720 <adc_lld_stop_conversion>
 8001358:	9b01      	ldr	r3, [sp, #4]
 800135a:	691b      	ldr	r3, [r3, #16]
 800135c:	689b      	ldr	r3, [r3, #8]
 800135e:	2b00      	cmp	r3, #0
 8001360:	d014      	beq.n	800138c <adc_lld_serve_rx_interrupt+0x4c>
 8001362:	9b01      	ldr	r3, [sp, #4]
 8001364:	2205      	movs	r2, #5
 8001366:	701a      	strb	r2, [r3, #0]
 8001368:	9b01      	ldr	r3, [sp, #4]
 800136a:	691b      	ldr	r3, [r3, #16]
 800136c:	689b      	ldr	r3, [r3, #8]
 800136e:	9a01      	ldr	r2, [sp, #4]
 8001370:	2101      	movs	r1, #1
 8001372:	0010      	movs	r0, r2
 8001374:	4798      	blx	r3
 8001376:	9b01      	ldr	r3, [sp, #4]
 8001378:	781b      	ldrb	r3, [r3, #0]
 800137a:	2b05      	cmp	r3, #5
 800137c:	d10c      	bne.n	8001398 <adc_lld_serve_rx_interrupt+0x58>
 800137e:	9b01      	ldr	r3, [sp, #4]
 8001380:	2202      	movs	r2, #2
 8001382:	701a      	strb	r2, [r3, #0]
 8001384:	9b01      	ldr	r3, [sp, #4]
 8001386:	2200      	movs	r2, #0
 8001388:	611a      	str	r2, [r3, #16]
 800138a:	e005      	b.n	8001398 <adc_lld_serve_rx_interrupt+0x58>
 800138c:	9b01      	ldr	r3, [sp, #4]
 800138e:	2202      	movs	r2, #2
 8001390:	701a      	strb	r2, [r3, #0]
 8001392:	9b01      	ldr	r3, [sp, #4]
 8001394:	2200      	movs	r2, #0
 8001396:	611a      	str	r2, [r3, #16]
 8001398:	f7ff ff4a 	bl	8001230 <osalSysLockFromISR.lto_priv.0>
 800139c:	9b01      	ldr	r3, [sp, #4]
 800139e:	3314      	adds	r3, #20
 80013a0:	2201      	movs	r2, #1
 80013a2:	4252      	negs	r2, r2
 80013a4:	0011      	movs	r1, r2
 80013a6:	0018      	movs	r0, r3
 80013a8:	f7ff ff52 	bl	8001250 <osalThreadResumeI.lto_priv.1>
 80013ac:	f7ff ff48 	bl	8001240 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 80013b0:	e05f      	b.n	8001472 <adc_lld_serve_rx_interrupt+0x132>
    if (adcp->grpp != NULL) {
 80013b2:	9b01      	ldr	r3, [sp, #4]
 80013b4:	691b      	ldr	r3, [r3, #16]
 80013b6:	2b00      	cmp	r3, #0
 80013b8:	d05b      	beq.n	8001472 <adc_lld_serve_rx_interrupt+0x132>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80013ba:	9b00      	ldr	r3, [sp, #0]
 80013bc:	2202      	movs	r2, #2
 80013be:	4013      	ands	r3, r2
 80013c0:	d048      	beq.n	8001454 <adc_lld_serve_rx_interrupt+0x114>
        _adc_isr_full_code(adcp);
 80013c2:	9b01      	ldr	r3, [sp, #4]
 80013c4:	691b      	ldr	r3, [r3, #16]
 80013c6:	781b      	ldrb	r3, [r3, #0]
 80013c8:	2b00      	cmp	r3, #0
 80013ca:	d015      	beq.n	80013f8 <adc_lld_serve_rx_interrupt+0xb8>
 80013cc:	9b01      	ldr	r3, [sp, #4]
 80013ce:	691b      	ldr	r3, [r3, #16]
 80013d0:	685b      	ldr	r3, [r3, #4]
 80013d2:	2b00      	cmp	r3, #0
 80013d4:	d04d      	beq.n	8001472 <adc_lld_serve_rx_interrupt+0x132>
 80013d6:	9b01      	ldr	r3, [sp, #4]
 80013d8:	2204      	movs	r2, #4
 80013da:	701a      	strb	r2, [r3, #0]
 80013dc:	9b01      	ldr	r3, [sp, #4]
 80013de:	691b      	ldr	r3, [r3, #16]
 80013e0:	685b      	ldr	r3, [r3, #4]
 80013e2:	9a01      	ldr	r2, [sp, #4]
 80013e4:	0010      	movs	r0, r2
 80013e6:	4798      	blx	r3
 80013e8:	9b01      	ldr	r3, [sp, #4]
 80013ea:	781b      	ldrb	r3, [r3, #0]
 80013ec:	2b04      	cmp	r3, #4
 80013ee:	d140      	bne.n	8001472 <adc_lld_serve_rx_interrupt+0x132>
 80013f0:	9b01      	ldr	r3, [sp, #4]
 80013f2:	2203      	movs	r2, #3
 80013f4:	701a      	strb	r2, [r3, #0]
}
 80013f6:	e03c      	b.n	8001472 <adc_lld_serve_rx_interrupt+0x132>
        _adc_isr_full_code(adcp);
 80013f8:	9b01      	ldr	r3, [sp, #4]
 80013fa:	0018      	movs	r0, r3
 80013fc:	f000 f990 	bl	8001720 <adc_lld_stop_conversion>
 8001400:	9b01      	ldr	r3, [sp, #4]
 8001402:	691b      	ldr	r3, [r3, #16]
 8001404:	685b      	ldr	r3, [r3, #4]
 8001406:	2b00      	cmp	r3, #0
 8001408:	d013      	beq.n	8001432 <adc_lld_serve_rx_interrupt+0xf2>
 800140a:	9b01      	ldr	r3, [sp, #4]
 800140c:	2204      	movs	r2, #4
 800140e:	701a      	strb	r2, [r3, #0]
 8001410:	9b01      	ldr	r3, [sp, #4]
 8001412:	691b      	ldr	r3, [r3, #16]
 8001414:	685b      	ldr	r3, [r3, #4]
 8001416:	9a01      	ldr	r2, [sp, #4]
 8001418:	0010      	movs	r0, r2
 800141a:	4798      	blx	r3
 800141c:	9b01      	ldr	r3, [sp, #4]
 800141e:	781b      	ldrb	r3, [r3, #0]
 8001420:	2b04      	cmp	r3, #4
 8001422:	d10c      	bne.n	800143e <adc_lld_serve_rx_interrupt+0xfe>
 8001424:	9b01      	ldr	r3, [sp, #4]
 8001426:	2202      	movs	r2, #2
 8001428:	701a      	strb	r2, [r3, #0]
 800142a:	9b01      	ldr	r3, [sp, #4]
 800142c:	2200      	movs	r2, #0
 800142e:	611a      	str	r2, [r3, #16]
 8001430:	e005      	b.n	800143e <adc_lld_serve_rx_interrupt+0xfe>
 8001432:	9b01      	ldr	r3, [sp, #4]
 8001434:	2202      	movs	r2, #2
 8001436:	701a      	strb	r2, [r3, #0]
 8001438:	9b01      	ldr	r3, [sp, #4]
 800143a:	2200      	movs	r2, #0
 800143c:	611a      	str	r2, [r3, #16]
 800143e:	f7ff fef7 	bl	8001230 <osalSysLockFromISR.lto_priv.0>
 8001442:	9b01      	ldr	r3, [sp, #4]
 8001444:	3314      	adds	r3, #20
 8001446:	2100      	movs	r1, #0
 8001448:	0018      	movs	r0, r3
 800144a:	f7ff ff01 	bl	8001250 <osalThreadResumeI.lto_priv.1>
 800144e:	f7ff fef7 	bl	8001240 <osalSysUnlockFromISR.lto_priv.0>
}
 8001452:	e00e      	b.n	8001472 <adc_lld_serve_rx_interrupt+0x132>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8001454:	9b00      	ldr	r3, [sp, #0]
 8001456:	2204      	movs	r2, #4
 8001458:	4013      	ands	r3, r2
 800145a:	d00a      	beq.n	8001472 <adc_lld_serve_rx_interrupt+0x132>
        _adc_isr_half_code(adcp);
 800145c:	9b01      	ldr	r3, [sp, #4]
 800145e:	691b      	ldr	r3, [r3, #16]
 8001460:	685b      	ldr	r3, [r3, #4]
 8001462:	2b00      	cmp	r3, #0
 8001464:	d005      	beq.n	8001472 <adc_lld_serve_rx_interrupt+0x132>
 8001466:	9b01      	ldr	r3, [sp, #4]
 8001468:	691b      	ldr	r3, [r3, #16]
 800146a:	685b      	ldr	r3, [r3, #4]
 800146c:	9a01      	ldr	r2, [sp, #4]
 800146e:	0010      	movs	r0, r2
 8001470:	4798      	blx	r3
}
 8001472:	46c0      	nop			@ (mov r8, r8)
 8001474:	b003      	add	sp, #12
 8001476:	bd00      	pop	{pc}
	...

08001480 <Vector70>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8001480:	b500      	push	{lr}
 8001482:	b083      	sub	sp, #12
 8001484:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8001486:	9301      	str	r3, [sp, #4]
 8001488:	4b0b      	ldr	r3, [pc, #44]	@ (80014b8 <Vector70+0x38>)
 800148a:	0018      	movs	r0, r3
 800148c:	f001 f970 	bl	8002770 <__trace_isr_enter>
 8001490:	f000 ffc6 	bl	8002420 <__dbg_check_enter_isr>

  adc_lld_serve_interrupt(&ADCD1);
 8001494:	4b09      	ldr	r3, [pc, #36]	@ (80014bc <Vector70+0x3c>)
 8001496:	0018      	movs	r0, r3
 8001498:	f000 f962 	bl	8001760 <adc_lld_serve_interrupt>

#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif

  OSAL_IRQ_EPILOGUE();
 800149c:	f000 fff0 	bl	8002480 <__dbg_check_leave_isr>
 80014a0:	4b05      	ldr	r3, [pc, #20]	@ (80014b8 <Vector70+0x38>)
 80014a2:	0018      	movs	r0, r3
 80014a4:	f001 f994 	bl	80027d0 <__trace_isr_leave>
 80014a8:	9b01      	ldr	r3, [sp, #4]
 80014aa:	0018      	movs	r0, r3
 80014ac:	f003 fc28 	bl	8004d00 <__port_irq_epilogue>
}
 80014b0:	46c0      	nop			@ (mov r8, r8)
 80014b2:	b003      	add	sp, #12
 80014b4:	bd00      	pop	{pc}
 80014b6:	46c0      	nop			@ (mov r8, r8)
 80014b8:	08005074 	.word	0x08005074
 80014bc:	20000600 	.word	0x20000600

080014c0 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 80014c0:	b510      	push	{r4, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 80014c2:	4b09      	ldr	r3, [pc, #36]	@ (80014e8 <adc_lld_init+0x28>)
 80014c4:	0018      	movs	r0, r3
 80014c6:	f7ff f87b 	bl	80005c0 <adcObjectInit>
  ADCD1.adc     = ADC1;
 80014ca:	4b07      	ldr	r3, [pc, #28]	@ (80014e8 <adc_lld_init+0x28>)
 80014cc:	4a07      	ldr	r2, [pc, #28]	@ (80014ec <adc_lld_init+0x2c>)
 80014ce:	629a      	str	r2, [r3, #40]	@ 0x28
  ADCD1.dmastp  = NULL;
 80014d0:	4b05      	ldr	r3, [pc, #20]	@ (80014e8 <adc_lld_init+0x28>)
 80014d2:	2200      	movs	r2, #0
 80014d4:	62da      	str	r2, [r3, #44]	@ 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 80014d6:	4b04      	ldr	r3, [pc, #16]	@ (80014e8 <adc_lld_init+0x28>)
 80014d8:	4a05      	ldr	r2, [pc, #20]	@ (80014f0 <adc_lld_init+0x30>)
 80014da:	631a      	str	r2, [r3, #48]	@ 0x30
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;

  /* The vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC1_IRQ_PRIORITY);
 80014dc:	2102      	movs	r1, #2
 80014de:	200c      	movs	r0, #12
 80014e0:	f7ff fb2e 	bl	8000b40 <nvicEnableVector>
#endif
}
 80014e4:	46c0      	nop			@ (mov r8, r8)
 80014e6:	bd10      	pop	{r4, pc}
 80014e8:	20000600 	.word	0x20000600
 80014ec:	40012400 	.word	0x40012400
 80014f0:	0000258a 	.word	0x0000258a
	...

08001500 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8001500:	b500      	push	{lr}
 8001502:	b083      	sub	sp, #12
 8001504:	9001      	str	r0, [sp, #4]

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	781b      	ldrb	r3, [r3, #0]
 800150a:	2b01      	cmp	r3, #1
 800150c:	d153      	bne.n	80015b6 <adc_lld_start+0xb6>

#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800150e:	9a01      	ldr	r2, [sp, #4]
 8001510:	4b2a      	ldr	r3, [pc, #168]	@ (80015bc <adc_lld_start+0xbc>)
 8001512:	429a      	cmp	r2, r3
 8001514:	d145      	bne.n	80015a2 <adc_lld_start+0xa2>
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 8001516:	9b01      	ldr	r3, [sp, #4]
 8001518:	4a29      	ldr	r2, [pc, #164]	@ (80015c0 <adc_lld_start+0xc0>)
 800151a:	2102      	movs	r1, #2
 800151c:	2007      	movs	r0, #7
 800151e:	f000 f9ff 	bl	8001920 <dmaStreamAllocI>
 8001522:	0002      	movs	r2, r0
 8001524:	9b01      	ldr	r3, [sp, #4]
 8001526:	62da      	str	r2, [r3, #44]	@ 0x2c
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8001528:	9b01      	ldr	r3, [sp, #4]
 800152a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800152c:	425a      	negs	r2, r3
 800152e:	4153      	adcs	r3, r2
 8001530:	b2db      	uxtb	r3, r3
 8001532:	2b00      	cmp	r3, #0
 8001534:	d003      	beq.n	800153e <adc_lld_start+0x3e>
 8001536:	4b23      	ldr	r3, [pc, #140]	@ (80015c4 <adc_lld_start+0xc4>)
 8001538:	0018      	movs	r0, r3
 800153a:	f000 fe61 	bl	8002200 <chSysHalt>
      rccResetADC1();
 800153e:	4b22      	ldr	r3, [pc, #136]	@ (80015c8 <adc_lld_start+0xc8>)
 8001540:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001542:	4b21      	ldr	r3, [pc, #132]	@ (80015c8 <adc_lld_start+0xc8>)
 8001544:	2180      	movs	r1, #128	@ 0x80
 8001546:	0349      	lsls	r1, r1, #13
 8001548:	430a      	orrs	r2, r1
 800154a:	631a      	str	r2, [r3, #48]	@ 0x30
 800154c:	4b1e      	ldr	r3, [pc, #120]	@ (80015c8 <adc_lld_start+0xc8>)
 800154e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001550:	4b1d      	ldr	r3, [pc, #116]	@ (80015c8 <adc_lld_start+0xc8>)
 8001552:	491e      	ldr	r1, [pc, #120]	@ (80015cc <adc_lld_start+0xcc>)
 8001554:	400a      	ands	r2, r1
 8001556:	631a      	str	r2, [r3, #48]	@ 0x30
 8001558:	4b1b      	ldr	r3, [pc, #108]	@ (80015c8 <adc_lld_start+0xc8>)
 800155a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
      rccEnableADC1(true);
 800155c:	4b1a      	ldr	r3, [pc, #104]	@ (80015c8 <adc_lld_start+0xc8>)
 800155e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8001560:	4b19      	ldr	r3, [pc, #100]	@ (80015c8 <adc_lld_start+0xc8>)
 8001562:	2180      	movs	r1, #128	@ 0x80
 8001564:	0349      	lsls	r1, r1, #13
 8001566:	430a      	orrs	r2, r1
 8001568:	641a      	str	r2, [r3, #64]	@ 0x40
 800156a:	4b17      	ldr	r3, [pc, #92]	@ (80015c8 <adc_lld_start+0xc8>)
 800156c:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 800156e:	4b16      	ldr	r3, [pc, #88]	@ (80015c8 <adc_lld_start+0xc8>)
 8001570:	2180      	movs	r1, #128	@ 0x80
 8001572:	0349      	lsls	r1, r1, #13
 8001574:	430a      	orrs	r2, r1
 8001576:	651a      	str	r2, [r3, #80]	@ 0x50
 8001578:	4b13      	ldr	r3, [pc, #76]	@ (80015c8 <adc_lld_start+0xc8>)
 800157a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50

      /* DMA setup.*/
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800157c:	9b01      	ldr	r3, [sp, #4]
 800157e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001580:	685b      	ldr	r3, [r3, #4]
 8001582:	4a13      	ldr	r2, [pc, #76]	@ (80015d0 <adc_lld_start+0xd0>)
 8001584:	609a      	str	r2, [r3, #8]
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC1);
 8001586:	9b01      	ldr	r3, [sp, #4]
 8001588:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800158a:	2105      	movs	r1, #5
 800158c:	0018      	movs	r0, r3
 800158e:	f000 faa7 	bl	8001ae0 <dmaSetRequestSource>

      /* Clock settings.*/
      ADC1_COMMON->CCR = STM32_ADC_PRESC << ADC_CCR_PRESC_Pos;
 8001592:	4b10      	ldr	r3, [pc, #64]	@ (80015d4 <adc_lld_start+0xd4>)
 8001594:	2280      	movs	r2, #128	@ 0x80
 8001596:	02d2      	lsls	r2, r2, #11
 8001598:	601a      	str	r2, [r3, #0]
      adcp->adc->CFGR2 = STM32_ADC_ADC1_CFGR2;
 800159a:	9b01      	ldr	r3, [sp, #4]
 800159c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800159e:	2200      	movs	r2, #0
 80015a0:	611a      	str	r2, [r3, #16]
    }
#endif /* STM32_ADC_USE_ADC1 */

    /* Regulator enabled and stabilized.*/
    adc_lld_vreg_on(adcp->adc);
 80015a2:	9b01      	ldr	r3, [sp, #4]
 80015a4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015a6:	0018      	movs	r0, r3
 80015a8:	f7ff fe62 	bl	8001270 <adc_lld_vreg_on>

    /* Calibrating ADC.*/
    adc_lld_calibrate(adcp->adc);
 80015ac:	9b01      	ldr	r3, [sp, #4]
 80015ae:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015b0:	0018      	movs	r0, r3
 80015b2:	f7ff fe85 	bl	80012c0 <adc_lld_calibrate>
  }
}
 80015b6:	46c0      	nop			@ (mov r8, r8)
 80015b8:	b003      	add	sp, #12
 80015ba:	bd00      	pop	{pc}
 80015bc:	20000600 	.word	0x20000600
 80015c0:	08001341 	.word	0x08001341
 80015c4:	08005080 	.word	0x08005080
 80015c8:	40021000 	.word	0x40021000
 80015cc:	ffefffff 	.word	0xffefffff
 80015d0:	40012440 	.word	0x40012440
 80015d4:	40012708 	.word	0x40012708
	...

080015e0 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 80015e0:	b086      	sub	sp, #24
 80015e2:	9001      	str	r0, [sp, #4]
  uint32_t mode, cfgr1;
  const ADCConversionGroup *grpp = adcp->grpp;
 80015e4:	9b01      	ldr	r3, [sp, #4]
 80015e6:	691b      	ldr	r3, [r3, #16]
 80015e8:	9303      	str	r3, [sp, #12]

  /* Write back ISR bits to clear register.*/
  adcp->adc->ISR = adcp->adc->ISR;
 80015ea:	9b01      	ldr	r3, [sp, #4]
 80015ec:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80015ee:	9b01      	ldr	r3, [sp, #4]
 80015f0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015f2:	6812      	ldr	r2, [r2, #0]
 80015f4:	601a      	str	r2, [r3, #0]

  /* Get group1 configuration. Transfer the clock mode for group2.*/
  cfgr1  = grpp->cfgr1 | ADC_CFGR1_DMAEN;
 80015f6:	9b03      	ldr	r3, [sp, #12]
 80015f8:	68db      	ldr	r3, [r3, #12]
 80015fa:	2201      	movs	r2, #1
 80015fc:	4313      	orrs	r3, r2
 80015fe:	9304      	str	r3, [sp, #16]

  /* DMA setup.*/
  mode  = adcp->dmamode;
 8001600:	9b01      	ldr	r3, [sp, #4]
 8001602:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001604:	9305      	str	r3, [sp, #20]
  if (grpp->circular) {
 8001606:	9b03      	ldr	r3, [sp, #12]
 8001608:	781b      	ldrb	r3, [r3, #0]
 800160a:	2b00      	cmp	r3, #0
 800160c:	d00f      	beq.n	800162e <adc_lld_start_conversion+0x4e>
    mode  |= STM32_DMA_CR_CIRC;
 800160e:	9b05      	ldr	r3, [sp, #20]
 8001610:	2220      	movs	r2, #32
 8001612:	4313      	orrs	r3, r2
 8001614:	9305      	str	r3, [sp, #20]
    cfgr1 |= ADC_CFGR1_DMACFG;
 8001616:	9b04      	ldr	r3, [sp, #16]
 8001618:	2202      	movs	r2, #2
 800161a:	4313      	orrs	r3, r2
 800161c:	9304      	str	r3, [sp, #16]
    if (adcp->depth > 1) {
 800161e:	9b01      	ldr	r3, [sp, #4]
 8001620:	68db      	ldr	r3, [r3, #12]
 8001622:	2b01      	cmp	r3, #1
 8001624:	d903      	bls.n	800162e <adc_lld_start_conversion+0x4e>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
 8001626:	9b05      	ldr	r3, [sp, #20]
 8001628:	2204      	movs	r2, #4
 800162a:	4313      	orrs	r3, r2
 800162c:	9305      	str	r3, [sp, #20]
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800162e:	9b01      	ldr	r3, [sp, #4]
 8001630:	689a      	ldr	r2, [r3, #8]
 8001632:	9b01      	ldr	r3, [sp, #4]
 8001634:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001636:	685b      	ldr	r3, [r3, #4]
 8001638:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels *
 800163a:	9b03      	ldr	r3, [sp, #12]
 800163c:	885b      	ldrh	r3, [r3, #2]
 800163e:	0019      	movs	r1, r3
 8001640:	9b01      	ldr	r3, [sp, #4]
 8001642:	68da      	ldr	r2, [r3, #12]
 8001644:	9b01      	ldr	r3, [sp, #4]
 8001646:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001648:	685b      	ldr	r3, [r3, #4]
 800164a:	434a      	muls	r2, r1
 800164c:	605a      	str	r2, [r3, #4]
                                            (uint32_t)adcp->depth));
  dmaStreamSetMode(adcp->dmastp, mode);
 800164e:	9b01      	ldr	r3, [sp, #4]
 8001650:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001652:	685b      	ldr	r3, [r3, #4]
 8001654:	9a05      	ldr	r2, [sp, #20]
 8001656:	601a      	str	r2, [r3, #0]

  /* Apply ADC configuration.*/
  adcp->adc->CFGR1  = cfgr1;
 8001658:	9b01      	ldr	r3, [sp, #4]
 800165a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800165c:	9a04      	ldr	r2, [sp, #16]
 800165e:	60da      	str	r2, [r3, #12]
  adcp->adc->CHSELR = grpp->chselr;
 8001660:	9b01      	ldr	r3, [sp, #4]
 8001662:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001664:	9a03      	ldr	r2, [sp, #12]
 8001666:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8001668:	629a      	str	r2, [r3, #40]	@ 0x28

  while ((adcp->adc->ISR & ADC_ISR_CCRDY) == 0U) {
 800166a:	46c0      	nop			@ (mov r8, r8)
 800166c:	9b01      	ldr	r3, [sp, #4]
 800166e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001670:	681a      	ldr	r2, [r3, #0]
 8001672:	2380      	movs	r3, #128	@ 0x80
 8001674:	019b      	lsls	r3, r3, #6
 8001676:	4013      	ands	r3, r2
 8001678:	d0f8      	beq.n	800166c <adc_lld_start_conversion+0x8c>
    /* Wait for the channel bits (or sequence), CHSEL mode and scan direction
       to be applied.*/
  }

  /* Set the sample rate(s).*/
  adcp->adc->SMPR = grpp->smpr;
 800167a:	9b01      	ldr	r3, [sp, #4]
 800167c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800167e:	9a03      	ldr	r2, [sp, #12]
 8001680:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8001682:	615a      	str	r2, [r3, #20]

  /* Enable ADC interrupts if callback specified.*/
   if (grpp->error_cb != NULL) {
 8001684:	9b03      	ldr	r3, [sp, #12]
 8001686:	689b      	ldr	r3, [r3, #8]
 8001688:	2b00      	cmp	r3, #0
 800168a:	d01f      	beq.n	80016cc <adc_lld_start_conversion+0xec>
    adcp->adc->IER    = ADC_IER_OVRIE | ADC_IER_AWD1IE
 800168c:	9b01      	ldr	r3, [sp, #4]
 800168e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001690:	22e4      	movs	r2, #228	@ 0xe4
 8001692:	0092      	lsls	r2, r2, #2
 8001694:	605a      	str	r2, [r3, #4]
                                      | ADC_IER_AWD2IE
                                      | ADC_IER_AWD3IE;
    adcp->adc->TR1    = grpp->tr1;
 8001696:	9b01      	ldr	r3, [sp, #4]
 8001698:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800169a:	9a03      	ldr	r2, [sp, #12]
 800169c:	6912      	ldr	r2, [r2, #16]
 800169e:	621a      	str	r2, [r3, #32]
    adcp->adc->TR2    = grpp->tr2;
 80016a0:	9b01      	ldr	r3, [sp, #4]
 80016a2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80016a4:	9a03      	ldr	r2, [sp, #12]
 80016a6:	6952      	ldr	r2, [r2, #20]
 80016a8:	625a      	str	r2, [r3, #36]	@ 0x24
    adcp->adc->TR3    = grpp->tr3;
 80016aa:	9b01      	ldr	r3, [sp, #4]
 80016ac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80016ae:	9a03      	ldr	r2, [sp, #12]
 80016b0:	6992      	ldr	r2, [r2, #24]
 80016b2:	62da      	str	r2, [r3, #44]	@ 0x2c
    adcp->adc->AWD2CR = grpp->awd2cr;
 80016b4:	9b01      	ldr	r3, [sp, #4]
 80016b6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80016b8:	9b03      	ldr	r3, [sp, #12]
 80016ba:	69db      	ldr	r3, [r3, #28]
 80016bc:	21a0      	movs	r1, #160	@ 0xa0
 80016be:	5053      	str	r3, [r2, r1]
    adcp->adc->AWD3CR = grpp->awd3cr;
 80016c0:	9b01      	ldr	r3, [sp, #4]
 80016c2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80016c4:	9b03      	ldr	r3, [sp, #12]
 80016c6:	6a1b      	ldr	r3, [r3, #32]
 80016c8:	21a4      	movs	r1, #164	@ 0xa4
 80016ca:	5053      	str	r3, [r2, r1]
  }

  /* Enable the ADC. Note: Setting ADEN must be deferred as a STM32G071 will
     reset RES[1:0] resolution bits if CFGR1 is modified with ADEN set
     (see STM32G071xx errata ES0418 Rev 3 2.6.2). Same applies to STM32WL.*/
  adcp->adc->CR  |= ADC_CR_ADEN;
 80016cc:	9b01      	ldr	r3, [sp, #4]
 80016ce:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80016d0:	689a      	ldr	r2, [r3, #8]
 80016d2:	9b01      	ldr	r3, [sp, #4]
 80016d4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80016d6:	2101      	movs	r1, #1
 80016d8:	430a      	orrs	r2, r1
 80016da:	609a      	str	r2, [r3, #8]
  while ((adcp->adc->ISR & ADC_ISR_ADRDY) == 0U) {
 80016dc:	46c0      	nop			@ (mov r8, r8)
 80016de:	9b01      	ldr	r3, [sp, #4]
 80016e0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80016e2:	681b      	ldr	r3, [r3, #0]
 80016e4:	2201      	movs	r2, #1
 80016e6:	4013      	ands	r3, r2
 80016e8:	d0f9      	beq.n	80016de <adc_lld_start_conversion+0xfe>
    /* Wait for the ADC to become ready.*/
  }

  /* Enable DMA controller stream.*/
  dmaStreamEnable(adcp->dmastp);
 80016ea:	9b01      	ldr	r3, [sp, #4]
 80016ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80016ee:	685b      	ldr	r3, [r3, #4]
 80016f0:	681a      	ldr	r2, [r3, #0]
 80016f2:	9b01      	ldr	r3, [sp, #4]
 80016f4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80016f6:	685b      	ldr	r3, [r3, #4]
 80016f8:	2101      	movs	r1, #1
 80016fa:	430a      	orrs	r2, r1
 80016fc:	601a      	str	r2, [r3, #0]

  /* ADC conversion start.*/
  adcp->adc->CR |= ADC_CR_ADSTART;
 80016fe:	9b01      	ldr	r3, [sp, #4]
 8001700:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001702:	689a      	ldr	r2, [r3, #8]
 8001704:	9b01      	ldr	r3, [sp, #4]
 8001706:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001708:	2104      	movs	r1, #4
 800170a:	430a      	orrs	r2, r1
 800170c:	609a      	str	r2, [r3, #8]
}
 800170e:	46c0      	nop			@ (mov r8, r8)
 8001710:	b006      	add	sp, #24
 8001712:	4770      	bx	lr
	...

08001720 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8001720:	b500      	push	{lr}
 8001722:	b083      	sub	sp, #12
 8001724:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
 8001726:	9b01      	ldr	r3, [sp, #4]
 8001728:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800172a:	685b      	ldr	r3, [r3, #4]
 800172c:	681a      	ldr	r2, [r3, #0]
 800172e:	9b01      	ldr	r3, [sp, #4]
 8001730:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001732:	685b      	ldr	r3, [r3, #4]
 8001734:	210f      	movs	r1, #15
 8001736:	438a      	bics	r2, r1
 8001738:	601a      	str	r2, [r3, #0]
 800173a:	9b01      	ldr	r3, [sp, #4]
 800173c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800173e:	7c1b      	ldrb	r3, [r3, #16]
 8001740:	001a      	movs	r2, r3
 8001742:	230e      	movs	r3, #14
 8001744:	4093      	lsls	r3, r2
 8001746:	001a      	movs	r2, r3
 8001748:	9b01      	ldr	r3, [sp, #4]
 800174a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800174c:	681b      	ldr	r3, [r3, #0]
 800174e:	605a      	str	r2, [r3, #4]
  adc_lld_stop_adc(adcp->adc);
 8001750:	9b01      	ldr	r3, [sp, #4]
 8001752:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001754:	0018      	movs	r0, r3
 8001756:	f7ff fdcb 	bl	80012f0 <adc_lld_stop_adc>
}
 800175a:	46c0      	nop			@ (mov r8, r8)
 800175c:	b003      	add	sp, #12
 800175e:	bd00      	pop	{pc}

08001760 <adc_lld_serve_interrupt>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_serve_interrupt(ADCDriver *adcp) {
 8001760:	b500      	push	{lr}
 8001762:	b085      	sub	sp, #20
 8001764:	9001      	str	r0, [sp, #4]
  uint32_t isr;

  isr = adcp->adc->ISR;
 8001766:	9b01      	ldr	r3, [sp, #4]
 8001768:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800176a:	681b      	ldr	r3, [r3, #0]
 800176c:	9302      	str	r3, [sp, #8]
  adcp->adc->ISR = isr;
 800176e:	9b01      	ldr	r3, [sp, #4]
 8001770:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001772:	9a02      	ldr	r2, [sp, #8]
 8001774:	601a      	str	r2, [r3, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8001776:	9b01      	ldr	r3, [sp, #4]
 8001778:	691b      	ldr	r3, [r3, #16]
 800177a:	2b00      	cmp	r3, #0
 800177c:	d05a      	beq.n	8001834 <adc_lld_serve_interrupt+0xd4>
    adcerror_t emask = 0U;
 800177e:	2300      	movs	r3, #0
 8001780:	9303      	str	r3, [sp, #12]

    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the state is checked too.*/
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8001782:	9b02      	ldr	r3, [sp, #8]
 8001784:	2210      	movs	r2, #16
 8001786:	4013      	ands	r3, r2
 8001788:	d007      	beq.n	800179a <adc_lld_serve_interrupt+0x3a>
 800178a:	9b01      	ldr	r3, [sp, #4]
 800178c:	781b      	ldrb	r3, [r3, #0]
 800178e:	2b03      	cmp	r3, #3
 8001790:	d103      	bne.n	800179a <adc_lld_serve_interrupt+0x3a>
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
 8001792:	9b03      	ldr	r3, [sp, #12]
 8001794:	2202      	movs	r2, #2
 8001796:	4313      	orrs	r3, r2
 8001798:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD1) {
 800179a:	9b02      	ldr	r3, [sp, #8]
 800179c:	2280      	movs	r2, #128	@ 0x80
 800179e:	4013      	ands	r3, r2
 80017a0:	d003      	beq.n	80017aa <adc_lld_serve_interrupt+0x4a>
      /* Analog watchdog 1 error.*/
      emask |= ADC_ERR_AWD1;
 80017a2:	9b03      	ldr	r3, [sp, #12]
 80017a4:	2204      	movs	r2, #4
 80017a6:	4313      	orrs	r3, r2
 80017a8:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD2) {
 80017aa:	9a02      	ldr	r2, [sp, #8]
 80017ac:	2380      	movs	r3, #128	@ 0x80
 80017ae:	005b      	lsls	r3, r3, #1
 80017b0:	4013      	ands	r3, r2
 80017b2:	d003      	beq.n	80017bc <adc_lld_serve_interrupt+0x5c>
      /* Analog watchdog 2 error.*/
      emask |= ADC_ERR_AWD2;
 80017b4:	9b03      	ldr	r3, [sp, #12]
 80017b6:	2208      	movs	r2, #8
 80017b8:	4313      	orrs	r3, r2
 80017ba:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD3) {
 80017bc:	9a02      	ldr	r2, [sp, #8]
 80017be:	2380      	movs	r3, #128	@ 0x80
 80017c0:	009b      	lsls	r3, r3, #2
 80017c2:	4013      	ands	r3, r2
 80017c4:	d003      	beq.n	80017ce <adc_lld_serve_interrupt+0x6e>
      /* Analog watchdog 3 error.*/
      emask |= ADC_ERR_AWD3;
 80017c6:	9b03      	ldr	r3, [sp, #12]
 80017c8:	2210      	movs	r2, #16
 80017ca:	4313      	orrs	r3, r2
 80017cc:	9303      	str	r3, [sp, #12]
    }
    if (emask != 0U) {
 80017ce:	9b03      	ldr	r3, [sp, #12]
 80017d0:	2b00      	cmp	r3, #0
 80017d2:	d02f      	beq.n	8001834 <adc_lld_serve_interrupt+0xd4>
      _adc_isr_error_code(adcp, emask);
 80017d4:	9b01      	ldr	r3, [sp, #4]
 80017d6:	0018      	movs	r0, r3
 80017d8:	f7ff ffa2 	bl	8001720 <adc_lld_stop_conversion>
 80017dc:	9b01      	ldr	r3, [sp, #4]
 80017de:	691b      	ldr	r3, [r3, #16]
 80017e0:	689b      	ldr	r3, [r3, #8]
 80017e2:	2b00      	cmp	r3, #0
 80017e4:	d014      	beq.n	8001810 <adc_lld_serve_interrupt+0xb0>
 80017e6:	9b01      	ldr	r3, [sp, #4]
 80017e8:	2205      	movs	r2, #5
 80017ea:	701a      	strb	r2, [r3, #0]
 80017ec:	9b01      	ldr	r3, [sp, #4]
 80017ee:	691b      	ldr	r3, [r3, #16]
 80017f0:	689b      	ldr	r3, [r3, #8]
 80017f2:	9903      	ldr	r1, [sp, #12]
 80017f4:	9a01      	ldr	r2, [sp, #4]
 80017f6:	0010      	movs	r0, r2
 80017f8:	4798      	blx	r3
 80017fa:	9b01      	ldr	r3, [sp, #4]
 80017fc:	781b      	ldrb	r3, [r3, #0]
 80017fe:	2b05      	cmp	r3, #5
 8001800:	d10c      	bne.n	800181c <adc_lld_serve_interrupt+0xbc>
 8001802:	9b01      	ldr	r3, [sp, #4]
 8001804:	2202      	movs	r2, #2
 8001806:	701a      	strb	r2, [r3, #0]
 8001808:	9b01      	ldr	r3, [sp, #4]
 800180a:	2200      	movs	r2, #0
 800180c:	611a      	str	r2, [r3, #16]
 800180e:	e005      	b.n	800181c <adc_lld_serve_interrupt+0xbc>
 8001810:	9b01      	ldr	r3, [sp, #4]
 8001812:	2202      	movs	r2, #2
 8001814:	701a      	strb	r2, [r3, #0]
 8001816:	9b01      	ldr	r3, [sp, #4]
 8001818:	2200      	movs	r2, #0
 800181a:	611a      	str	r2, [r3, #16]
 800181c:	f7ff fd08 	bl	8001230 <osalSysLockFromISR.lto_priv.0>
 8001820:	9b01      	ldr	r3, [sp, #4]
 8001822:	3314      	adds	r3, #20
 8001824:	2201      	movs	r2, #1
 8001826:	4252      	negs	r2, r2
 8001828:	0011      	movs	r1, r2
 800182a:	0018      	movs	r0, r3
 800182c:	f7ff fd10 	bl	8001250 <osalThreadResumeI.lto_priv.1>
 8001830:	f7ff fd06 	bl	8001240 <osalSysUnlockFromISR.lto_priv.0>
    }
  }
}
 8001834:	46c0      	nop			@ (mov r8, r8)
 8001836:	b005      	add	sp, #20
 8001838:	bd00      	pop	{pc}
 800183a:	46c0      	nop			@ (mov r8, r8)
 800183c:	0000      	movs	r0, r0
	...

08001840 <adcSTM32EnableVREF>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableVREF(ADCDriver *adcp) {
 8001840:	b082      	sub	sp, #8
 8001842:	9001      	str	r0, [sp, #4]

  (void)adcp;

  ADC1_COMMON->CCR |= ADC_CCR_VREFEN;
 8001844:	4b04      	ldr	r3, [pc, #16]	@ (8001858 <adcSTM32EnableVREF+0x18>)
 8001846:	681a      	ldr	r2, [r3, #0]
 8001848:	4b03      	ldr	r3, [pc, #12]	@ (8001858 <adcSTM32EnableVREF+0x18>)
 800184a:	2180      	movs	r1, #128	@ 0x80
 800184c:	03c9      	lsls	r1, r1, #15
 800184e:	430a      	orrs	r2, r1
 8001850:	601a      	str	r2, [r3, #0]
}
 8001852:	46c0      	nop			@ (mov r8, r8)
 8001854:	b002      	add	sp, #8
 8001856:	4770      	bx	lr
 8001858:	40012708 	.word	0x40012708
 800185c:	00000000 	.word	0x00000000

08001860 <adcSTM32EnableTS>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {
 8001860:	b082      	sub	sp, #8
 8001862:	9001      	str	r0, [sp, #4]

  (void)adcp;

  ADC1_COMMON->CCR |= ADC_CCR_TSEN;
 8001864:	4b04      	ldr	r3, [pc, #16]	@ (8001878 <adcSTM32EnableTS+0x18>)
 8001866:	681a      	ldr	r2, [r3, #0]
 8001868:	4b03      	ldr	r3, [pc, #12]	@ (8001878 <adcSTM32EnableTS+0x18>)
 800186a:	2180      	movs	r1, #128	@ 0x80
 800186c:	0409      	lsls	r1, r1, #16
 800186e:	430a      	orrs	r2, r1
 8001870:	601a      	str	r2, [r3, #0]
}
 8001872:	46c0      	nop			@ (mov r8, r8)
 8001874:	b002      	add	sp, #8
 8001876:	4770      	bx	lr
 8001878:	40012708 	.word	0x40012708
 800187c:	00000000 	.word	0x00000000

08001880 <Vector64>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001880:	b500      	push	{lr}
 8001882:	b083      	sub	sp, #12
 8001884:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8001886:	9301      	str	r3, [sp, #4]
 8001888:	4b0b      	ldr	r3, [pc, #44]	@ (80018b8 <Vector64+0x38>)
 800188a:	0018      	movs	r0, r3
 800188c:	f000 ff70 	bl	8002770 <__trace_isr_enter>
 8001890:	f000 fdc6 	bl	8002420 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8001894:	4b09      	ldr	r3, [pc, #36]	@ (80018bc <Vector64+0x3c>)
 8001896:	0018      	movs	r0, r3
 8001898:	f000 f8ea 	bl	8001a70 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800189c:	f000 fdf0 	bl	8002480 <__dbg_check_leave_isr>
 80018a0:	4b05      	ldr	r3, [pc, #20]	@ (80018b8 <Vector64+0x38>)
 80018a2:	0018      	movs	r0, r3
 80018a4:	f000 ff94 	bl	80027d0 <__trace_isr_leave>
 80018a8:	9b01      	ldr	r3, [sp, #4]
 80018aa:	0018      	movs	r0, r3
 80018ac:	f003 fa28 	bl	8004d00 <__port_irq_epilogue>
}
 80018b0:	46c0      	nop			@ (mov r8, r8)
 80018b2:	b003      	add	sp, #12
 80018b4:	bd00      	pop	{pc}
 80018b6:	46c0      	nop			@ (mov r8, r8)
 80018b8:	0800511c 	.word	0x0800511c
 80018bc:	08005090 	.word	0x08005090

080018c0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 80018c0:	b082      	sub	sp, #8
  int i;

  dma.allocated_mask = 0U;
 80018c2:	4b13      	ldr	r3, [pc, #76]	@ (8001910 <dmaInit+0x50>)
 80018c4:	2200      	movs	r2, #0
 80018c6:	601a      	str	r2, [r3, #0]
  dma.isr_mask       = 0U;
 80018c8:	4b11      	ldr	r3, [pc, #68]	@ (8001910 <dmaInit+0x50>)
 80018ca:	2200      	movs	r2, #0
 80018cc:	605a      	str	r2, [r3, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80018ce:	2300      	movs	r3, #0
 80018d0:	9301      	str	r3, [sp, #4]
 80018d2:	e013      	b.n	80018fc <dmaInit+0x3c>
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80018d4:	490f      	ldr	r1, [pc, #60]	@ (8001914 <dmaInit+0x54>)
 80018d6:	9a01      	ldr	r2, [sp, #4]
 80018d8:	0013      	movs	r3, r2
 80018da:	009b      	lsls	r3, r3, #2
 80018dc:	189b      	adds	r3, r3, r2
 80018de:	009b      	lsls	r3, r3, #2
 80018e0:	18cb      	adds	r3, r1, r3
 80018e2:	3304      	adds	r3, #4
 80018e4:	681b      	ldr	r3, [r3, #0]
 80018e6:	2200      	movs	r2, #0
 80018e8:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 80018ea:	4b09      	ldr	r3, [pc, #36]	@ (8001910 <dmaInit+0x50>)
 80018ec:	9a01      	ldr	r2, [sp, #4]
 80018ee:	3201      	adds	r2, #1
 80018f0:	00d2      	lsls	r2, r2, #3
 80018f2:	2100      	movs	r1, #0
 80018f4:	50d1      	str	r1, [r2, r3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80018f6:	9b01      	ldr	r3, [sp, #4]
 80018f8:	3301      	adds	r3, #1
 80018fa:	9301      	str	r3, [sp, #4]
 80018fc:	9b01      	ldr	r3, [sp, #4]
 80018fe:	2b06      	cmp	r3, #6
 8001900:	dde8      	ble.n	80018d4 <dmaInit+0x14>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8001902:	4b05      	ldr	r3, [pc, #20]	@ (8001918 <dmaInit+0x58>)
 8001904:	2201      	movs	r2, #1
 8001906:	4252      	negs	r2, r2
 8001908:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
#endif
}
 800190a:	46c0      	nop			@ (mov r8, r8)
 800190c:	b002      	add	sp, #8
 800190e:	4770      	bx	lr
 8001910:	20000634 	.word	0x20000634
 8001914:	08005090 	.word	0x08005090
 8001918:	40020000 	.word	0x40020000
 800191c:	00000000 	.word	0x00000000

08001920 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8001920:	b500      	push	{lr}
 8001922:	b08b      	sub	sp, #44	@ 0x2c
 8001924:	9003      	str	r0, [sp, #12]
 8001926:	9102      	str	r1, [sp, #8]
 8001928:	9201      	str	r2, [sp, #4]
 800192a:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 800192c:	f000 fdd8 	bl	80024e0 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 8001930:	9b03      	ldr	r3, [sp, #12]
 8001932:	2b06      	cmp	r3, #6
 8001934:	d804      	bhi.n	8001940 <dmaStreamAllocI+0x20>
    startid = id;
 8001936:	9b03      	ldr	r3, [sp, #12]
 8001938:	9308      	str	r3, [sp, #32]
    endid   = id;
 800193a:	9b03      	ldr	r3, [sp, #12]
 800193c:	9307      	str	r3, [sp, #28]
 800193e:	e015      	b.n	800196c <dmaStreamAllocI+0x4c>
  }
#if STM32_DMA_SUPPORTS_DMAMUX == TRUE
  else if (id == STM32_DMA_STREAM_ID_ANY) {
 8001940:	9b03      	ldr	r3, [sp, #12]
 8001942:	2b07      	cmp	r3, #7
 8001944:	d104      	bne.n	8001950 <dmaStreamAllocI+0x30>
    startid = 0U;
 8001946:	2300      	movs	r3, #0
 8001948:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 800194a:	2306      	movs	r3, #6
 800194c:	9307      	str	r3, [sp, #28]
 800194e:	e00d      	b.n	800196c <dmaStreamAllocI+0x4c>
  }
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA1) {
 8001950:	9b03      	ldr	r3, [sp, #12]
 8001952:	2b08      	cmp	r3, #8
 8001954:	d104      	bne.n	8001960 <dmaStreamAllocI+0x40>
    startid = 0U;
 8001956:	2300      	movs	r3, #0
 8001958:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA1_NUM_CHANNELS - 1U;
 800195a:	2306      	movs	r3, #6
 800195c:	9307      	str	r3, [sp, #28]
 800195e:	e005      	b.n	800196c <dmaStreamAllocI+0x4c>
    endid   = STM32_DMA_STREAMS - 1U;
  }
#endif
#endif
  else {
    osalDbgCheck(false);
 8001960:	4b3c      	ldr	r3, [pc, #240]	@ (8001a54 <dmaStreamAllocI+0x134>)
 8001962:	0018      	movs	r0, r3
 8001964:	f000 fc4c 	bl	8002200 <chSysHalt>
    return NULL;
 8001968:	2300      	movs	r3, #0
 800196a:	e070      	b.n	8001a4e <dmaStreamAllocI+0x12e>
  }

  for (i = startid; i <= endid; i++) {
 800196c:	9b08      	ldr	r3, [sp, #32]
 800196e:	9309      	str	r3, [sp, #36]	@ 0x24
 8001970:	e068      	b.n	8001a44 <dmaStreamAllocI+0x124>
    uint32_t mask = (1U << i);
 8001972:	2201      	movs	r2, #1
 8001974:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001976:	409a      	lsls	r2, r3
 8001978:	0013      	movs	r3, r2
 800197a:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 800197c:	4b36      	ldr	r3, [pc, #216]	@ (8001a58 <dmaStreamAllocI+0x138>)
 800197e:	681b      	ldr	r3, [r3, #0]
 8001980:	9a06      	ldr	r2, [sp, #24]
 8001982:	4013      	ands	r3, r2
 8001984:	d15b      	bne.n	8001a3e <dmaStreamAllocI+0x11e>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8001986:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001988:	0013      	movs	r3, r2
 800198a:	009b      	lsls	r3, r3, #2
 800198c:	189b      	adds	r3, r3, r2
 800198e:	009b      	lsls	r3, r3, #2
 8001990:	4a32      	ldr	r2, [pc, #200]	@ (8001a5c <dmaStreamAllocI+0x13c>)
 8001992:	189b      	adds	r3, r3, r2
 8001994:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8001996:	4b30      	ldr	r3, [pc, #192]	@ (8001a58 <dmaStreamAllocI+0x138>)
 8001998:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800199a:	3201      	adds	r2, #1
 800199c:	00d2      	lsls	r2, r2, #3
 800199e:	9901      	ldr	r1, [sp, #4]
 80019a0:	50d1      	str	r1, [r2, r3]
      dma.streams[i].param = param;
 80019a2:	4a2d      	ldr	r2, [pc, #180]	@ (8001a58 <dmaStreamAllocI+0x138>)
 80019a4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80019a6:	3301      	adds	r3, #1
 80019a8:	00db      	lsls	r3, r3, #3
 80019aa:	18d3      	adds	r3, r2, r3
 80019ac:	3304      	adds	r3, #4
 80019ae:	9a00      	ldr	r2, [sp, #0]
 80019b0:	601a      	str	r2, [r3, #0]
      dma.allocated_mask  |= mask;
 80019b2:	4b29      	ldr	r3, [pc, #164]	@ (8001a58 <dmaStreamAllocI+0x138>)
 80019b4:	681a      	ldr	r2, [r3, #0]
 80019b6:	9b06      	ldr	r3, [sp, #24]
 80019b8:	431a      	orrs	r2, r3
 80019ba:	4b27      	ldr	r3, [pc, #156]	@ (8001a58 <dmaStreamAllocI+0x138>)
 80019bc:	601a      	str	r2, [r3, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 80019be:	9b06      	ldr	r3, [sp, #24]
 80019c0:	227f      	movs	r2, #127	@ 0x7f
 80019c2:	4013      	ands	r3, r2
 80019c4:	d00d      	beq.n	80019e2 <dmaStreamAllocI+0xc2>
        rccEnableDMA1(true);
 80019c6:	4b26      	ldr	r3, [pc, #152]	@ (8001a60 <dmaStreamAllocI+0x140>)
 80019c8:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 80019ca:	4b25      	ldr	r3, [pc, #148]	@ (8001a60 <dmaStreamAllocI+0x140>)
 80019cc:	2101      	movs	r1, #1
 80019ce:	430a      	orrs	r2, r1
 80019d0:	639a      	str	r2, [r3, #56]	@ 0x38
 80019d2:	4b23      	ldr	r3, [pc, #140]	@ (8001a60 <dmaStreamAllocI+0x140>)
 80019d4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 80019d6:	4b22      	ldr	r3, [pc, #136]	@ (8001a60 <dmaStreamAllocI+0x140>)
 80019d8:	2101      	movs	r1, #1
 80019da:	430a      	orrs	r2, r1
 80019dc:	649a      	str	r2, [r3, #72]	@ 0x48
 80019de:	4b20      	ldr	r3, [pc, #128]	@ (8001a60 <dmaStreamAllocI+0x140>)
 80019e0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 80019e2:	9b01      	ldr	r3, [sp, #4]
 80019e4:	2b00      	cmp	r3, #0
 80019e6:	d013      	beq.n	8001a10 <dmaStreamAllocI+0xf0>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 80019e8:	4b1b      	ldr	r3, [pc, #108]	@ (8001a58 <dmaStreamAllocI+0x138>)
 80019ea:	685a      	ldr	r2, [r3, #4]
 80019ec:	9b05      	ldr	r3, [sp, #20]
 80019ee:	689b      	ldr	r3, [r3, #8]
 80019f0:	4013      	ands	r3, r2
 80019f2:	d107      	bne.n	8001a04 <dmaStreamAllocI+0xe4>
          nvicEnableVector(dmastp->vector, priority);
 80019f4:	9b05      	ldr	r3, [sp, #20]
 80019f6:	7c9b      	ldrb	r3, [r3, #18]
 80019f8:	001a      	movs	r2, r3
 80019fa:	9b02      	ldr	r3, [sp, #8]
 80019fc:	0019      	movs	r1, r3
 80019fe:	0010      	movs	r0, r2
 8001a00:	f7ff f89e 	bl	8000b40 <nvicEnableVector>
        }
        dma.isr_mask |= mask;
 8001a04:	4b14      	ldr	r3, [pc, #80]	@ (8001a58 <dmaStreamAllocI+0x138>)
 8001a06:	685a      	ldr	r2, [r3, #4]
 8001a08:	9b06      	ldr	r3, [sp, #24]
 8001a0a:	431a      	orrs	r2, r3
 8001a0c:	4b12      	ldr	r3, [pc, #72]	@ (8001a58 <dmaStreamAllocI+0x138>)
 8001a0e:	605a      	str	r2, [r3, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 8001a10:	9b05      	ldr	r3, [sp, #20]
 8001a12:	685b      	ldr	r3, [r3, #4]
 8001a14:	681a      	ldr	r2, [r3, #0]
 8001a16:	9b05      	ldr	r3, [sp, #20]
 8001a18:	685b      	ldr	r3, [r3, #4]
 8001a1a:	210f      	movs	r1, #15
 8001a1c:	438a      	bics	r2, r1
 8001a1e:	601a      	str	r2, [r3, #0]
 8001a20:	9b05      	ldr	r3, [sp, #20]
 8001a22:	7c1b      	ldrb	r3, [r3, #16]
 8001a24:	001a      	movs	r2, r3
 8001a26:	230e      	movs	r3, #14
 8001a28:	4093      	lsls	r3, r2
 8001a2a:	001a      	movs	r2, r3
 8001a2c:	9b05      	ldr	r3, [sp, #20]
 8001a2e:	681b      	ldr	r3, [r3, #0]
 8001a30:	605a      	str	r2, [r3, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001a32:	9b05      	ldr	r3, [sp, #20]
 8001a34:	685b      	ldr	r3, [r3, #4]
 8001a36:	2200      	movs	r2, #0
 8001a38:	601a      	str	r2, [r3, #0]

      return dmastp;
 8001a3a:	9b05      	ldr	r3, [sp, #20]
 8001a3c:	e007      	b.n	8001a4e <dmaStreamAllocI+0x12e>
  for (i = startid; i <= endid; i++) {
 8001a3e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001a40:	3301      	adds	r3, #1
 8001a42:	9309      	str	r3, [sp, #36]	@ 0x24
 8001a44:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001a46:	9b07      	ldr	r3, [sp, #28]
 8001a48:	429a      	cmp	r2, r3
 8001a4a:	d992      	bls.n	8001972 <dmaStreamAllocI+0x52>
    }
  }

  return NULL;
 8001a4c:	2300      	movs	r3, #0
}
 8001a4e:	0018      	movs	r0, r3
 8001a50:	b00b      	add	sp, #44	@ 0x2c
 8001a52:	bd00      	pop	{pc}
 8001a54:	08005128 	.word	0x08005128
 8001a58:	20000634 	.word	0x20000634
 8001a5c:	08005090 	.word	0x08005090
 8001a60:	40021000 	.word	0x40021000
	...

08001a70 <dmaServeInterrupt>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
 8001a70:	b500      	push	{lr}
 8001a72:	b085      	sub	sp, #20
 8001a74:	9001      	str	r0, [sp, #4]
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;
 8001a76:	9b01      	ldr	r3, [sp, #4]
 8001a78:	7c5b      	ldrb	r3, [r3, #17]
 8001a7a:	9303      	str	r3, [sp, #12]

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001a7c:	9b01      	ldr	r3, [sp, #4]
 8001a7e:	681b      	ldr	r3, [r3, #0]
 8001a80:	681b      	ldr	r3, [r3, #0]
 8001a82:	9a01      	ldr	r2, [sp, #4]
 8001a84:	7c12      	ldrb	r2, [r2, #16]
 8001a86:	40d3      	lsrs	r3, r2
 8001a88:	220e      	movs	r2, #14
 8001a8a:	4013      	ands	r3, r2
 8001a8c:	9302      	str	r3, [sp, #8]
  if (flags & dmastp->channel->CCR) {
 8001a8e:	9b01      	ldr	r3, [sp, #4]
 8001a90:	685b      	ldr	r3, [r3, #4]
 8001a92:	681b      	ldr	r3, [r3, #0]
 8001a94:	9a02      	ldr	r2, [sp, #8]
 8001a96:	4013      	ands	r3, r2
 8001a98:	d01d      	beq.n	8001ad6 <dmaServeInterrupt+0x66>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8001a9a:	9b01      	ldr	r3, [sp, #4]
 8001a9c:	7c1b      	ldrb	r3, [r3, #16]
 8001a9e:	0019      	movs	r1, r3
 8001aa0:	9b01      	ldr	r3, [sp, #4]
 8001aa2:	681b      	ldr	r3, [r3, #0]
 8001aa4:	9a02      	ldr	r2, [sp, #8]
 8001aa6:	408a      	lsls	r2, r1
 8001aa8:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8001aaa:	4b0c      	ldr	r3, [pc, #48]	@ (8001adc <dmaServeInterrupt+0x6c>)
 8001aac:	9a03      	ldr	r2, [sp, #12]
 8001aae:	3201      	adds	r2, #1
 8001ab0:	00d2      	lsls	r2, r2, #3
 8001ab2:	58d3      	ldr	r3, [r2, r3]
 8001ab4:	2b00      	cmp	r3, #0
 8001ab6:	d00e      	beq.n	8001ad6 <dmaServeInterrupt+0x66>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8001ab8:	4b08      	ldr	r3, [pc, #32]	@ (8001adc <dmaServeInterrupt+0x6c>)
 8001aba:	9a03      	ldr	r2, [sp, #12]
 8001abc:	3201      	adds	r2, #1
 8001abe:	00d2      	lsls	r2, r2, #3
 8001ac0:	58d2      	ldr	r2, [r2, r3]
 8001ac2:	4906      	ldr	r1, [pc, #24]	@ (8001adc <dmaServeInterrupt+0x6c>)
 8001ac4:	9b03      	ldr	r3, [sp, #12]
 8001ac6:	3301      	adds	r3, #1
 8001ac8:	00db      	lsls	r3, r3, #3
 8001aca:	18cb      	adds	r3, r1, r3
 8001acc:	3304      	adds	r3, #4
 8001ace:	681b      	ldr	r3, [r3, #0]
 8001ad0:	9902      	ldr	r1, [sp, #8]
 8001ad2:	0018      	movs	r0, r3
 8001ad4:	4790      	blx	r2
    }
  }
}
 8001ad6:	46c0      	nop			@ (mov r8, r8)
 8001ad8:	b005      	add	sp, #20
 8001ada:	bd00      	pop	{pc}
 8001adc:	20000634 	.word	0x20000634

08001ae0 <dmaSetRequestSource>:
 * @param[in] dmastp    pointer to a @p stm32_dma_stream_t structure
 * @param[in] per       peripheral identifier
 *
 * @special
 */
void dmaSetRequestSource(const stm32_dma_stream_t *dmastp, uint32_t per) {
 8001ae0:	b500      	push	{lr}
 8001ae2:	b083      	sub	sp, #12
 8001ae4:	9001      	str	r0, [sp, #4]
 8001ae6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(per < 256U);
 8001ae8:	9b00      	ldr	r3, [sp, #0]
 8001aea:	22ff      	movs	r2, #255	@ 0xff
 8001aec:	429a      	cmp	r2, r3
 8001aee:	419b      	sbcs	r3, r3
 8001af0:	425b      	negs	r3, r3
 8001af2:	b2db      	uxtb	r3, r3
 8001af4:	2b00      	cmp	r3, #0
 8001af6:	d003      	beq.n	8001b00 <dmaSetRequestSource+0x20>
 8001af8:	4b05      	ldr	r3, [pc, #20]	@ (8001b10 <dmaSetRequestSource+0x30>)
 8001afa:	0018      	movs	r0, r3
 8001afc:	f000 fb80 	bl	8002200 <chSysHalt>

  dmastp->mux->CCR = per;
 8001b00:	9b01      	ldr	r3, [sp, #4]
 8001b02:	68db      	ldr	r3, [r3, #12]
 8001b04:	9a00      	ldr	r2, [sp, #0]
 8001b06:	601a      	str	r2, [r3, #0]
}
 8001b08:	46c0      	nop			@ (mov r8, r8)
 8001b0a:	b003      	add	sp, #12
 8001b0c:	bd00      	pop	{pc}
 8001b0e:	46c0      	nop			@ (mov r8, r8)
 8001b10:	08005138 	.word	0x08005138
	...

08001b20 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8001b20:	46c0      	nop			@ (mov r8, r8)
 8001b22:	4770      	bx	lr
	...

08001b30 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001b30:	b08e      	sub	sp, #56	@ 0x38
 8001b32:	9003      	str	r0, [sp, #12]
 8001b34:	9102      	str	r1, [sp, #8]
 8001b36:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001b38:	9b01      	ldr	r3, [sp, #4]
 8001b3a:	2203      	movs	r2, #3
 8001b3c:	4013      	ands	r3, r2
 8001b3e:	930d      	str	r3, [sp, #52]	@ 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001b40:	9b01      	ldr	r3, [sp, #4]
 8001b42:	089b      	lsrs	r3, r3, #2
 8001b44:	2201      	movs	r2, #1
 8001b46:	4013      	ands	r3, r2
 8001b48:	930c      	str	r3, [sp, #48]	@ 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001b4a:	9b01      	ldr	r3, [sp, #4]
 8001b4c:	08db      	lsrs	r3, r3, #3
 8001b4e:	2203      	movs	r2, #3
 8001b50:	4013      	ands	r3, r2
 8001b52:	930b      	str	r3, [sp, #44]	@ 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001b54:	9b01      	ldr	r3, [sp, #4]
 8001b56:	095b      	lsrs	r3, r3, #5
 8001b58:	2203      	movs	r2, #3
 8001b5a:	4013      	ands	r3, r2
 8001b5c:	930a      	str	r3, [sp, #40]	@ 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001b5e:	9b01      	ldr	r3, [sp, #4]
 8001b60:	09db      	lsrs	r3, r3, #7
 8001b62:	220f      	movs	r2, #15
 8001b64:	4013      	ands	r3, r2
 8001b66:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8001b68:	2300      	movs	r3, #0
 8001b6a:	9309      	str	r3, [sp, #36]	@ 0x24
  while (true) {
    if ((mask & 1) != 0) {
 8001b6c:	9b02      	ldr	r3, [sp, #8]
 8001b6e:	2201      	movs	r2, #1
 8001b70:	4013      	ands	r3, r2
 8001b72:	d100      	bne.n	8001b76 <_pal_lld_setgroupmode+0x46>
 8001b74:	e079      	b.n	8001c6a <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001b76:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001b78:	2207      	movs	r2, #7
 8001b7a:	4013      	ands	r3, r2
 8001b7c:	009b      	lsls	r3, r3, #2
 8001b7e:	9a08      	ldr	r2, [sp, #32]
 8001b80:	409a      	lsls	r2, r3
 8001b82:	0013      	movs	r3, r2
 8001b84:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8001b86:	2201      	movs	r2, #1
 8001b88:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001b8a:	409a      	lsls	r2, r3
 8001b8c:	0013      	movs	r3, r2
 8001b8e:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8001b90:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001b92:	005b      	lsls	r3, r3, #1
 8001b94:	2203      	movs	r2, #3
 8001b96:	409a      	lsls	r2, r3
 8001b98:	0013      	movs	r3, r2
 8001b9a:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8001b9c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001b9e:	2207      	movs	r2, #7
 8001ba0:	4013      	ands	r3, r2
 8001ba2:	009b      	lsls	r3, r3, #2
 8001ba4:	220f      	movs	r2, #15
 8001ba6:	409a      	lsls	r2, r3
 8001ba8:	0013      	movs	r3, r2
 8001baa:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001bac:	9b03      	ldr	r3, [sp, #12]
 8001bae:	685b      	ldr	r3, [r3, #4]
 8001bb0:	9a06      	ldr	r2, [sp, #24]
 8001bb2:	43d2      	mvns	r2, r2
 8001bb4:	401a      	ands	r2, r3
 8001bb6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8001bb8:	431a      	orrs	r2, r3
 8001bba:	9b03      	ldr	r3, [sp, #12]
 8001bbc:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001bbe:	9b03      	ldr	r3, [sp, #12]
 8001bc0:	689b      	ldr	r3, [r3, #8]
 8001bc2:	9a05      	ldr	r2, [sp, #20]
 8001bc4:	43d2      	mvns	r2, r2
 8001bc6:	401a      	ands	r2, r3
 8001bc8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8001bca:	431a      	orrs	r2, r3
 8001bcc:	9b03      	ldr	r3, [sp, #12]
 8001bce:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001bd0:	9b03      	ldr	r3, [sp, #12]
 8001bd2:	68db      	ldr	r3, [r3, #12]
 8001bd4:	9a05      	ldr	r2, [sp, #20]
 8001bd6:	43d2      	mvns	r2, r2
 8001bd8:	401a      	ands	r2, r3
 8001bda:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8001bdc:	431a      	orrs	r2, r3
 8001bde:	9b03      	ldr	r3, [sp, #12]
 8001be0:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001be2:	9b01      	ldr	r3, [sp, #4]
 8001be4:	2203      	movs	r2, #3
 8001be6:	4013      	ands	r3, r2
 8001be8:	2b02      	cmp	r3, #2
 8001bea:	d11f      	bne.n	8001c2c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8001bec:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001bee:	2b07      	cmp	r3, #7
 8001bf0:	d809      	bhi.n	8001c06 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001bf2:	9b03      	ldr	r3, [sp, #12]
 8001bf4:	6a1b      	ldr	r3, [r3, #32]
 8001bf6:	9a04      	ldr	r2, [sp, #16]
 8001bf8:	43d2      	mvns	r2, r2
 8001bfa:	401a      	ands	r2, r3
 8001bfc:	9b07      	ldr	r3, [sp, #28]
 8001bfe:	431a      	orrs	r2, r3
 8001c00:	9b03      	ldr	r3, [sp, #12]
 8001c02:	621a      	str	r2, [r3, #32]
 8001c04:	e008      	b.n	8001c18 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001c06:	9b03      	ldr	r3, [sp, #12]
 8001c08:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001c0a:	9a04      	ldr	r2, [sp, #16]
 8001c0c:	43d2      	mvns	r2, r2
 8001c0e:	401a      	ands	r2, r3
 8001c10:	9b07      	ldr	r3, [sp, #28]
 8001c12:	431a      	orrs	r2, r3
 8001c14:	9b03      	ldr	r3, [sp, #12]
 8001c16:	625a      	str	r2, [r3, #36]	@ 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8001c18:	9b03      	ldr	r3, [sp, #12]
 8001c1a:	681b      	ldr	r3, [r3, #0]
 8001c1c:	9a05      	ldr	r2, [sp, #20]
 8001c1e:	43d2      	mvns	r2, r2
 8001c20:	401a      	ands	r2, r3
 8001c22:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8001c24:	431a      	orrs	r2, r3
 8001c26:	9b03      	ldr	r3, [sp, #12]
 8001c28:	601a      	str	r2, [r3, #0]
 8001c2a:	e01e      	b.n	8001c6a <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8001c2c:	9b03      	ldr	r3, [sp, #12]
 8001c2e:	681b      	ldr	r3, [r3, #0]
 8001c30:	9a05      	ldr	r2, [sp, #20]
 8001c32:	43d2      	mvns	r2, r2
 8001c34:	401a      	ands	r2, r3
 8001c36:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8001c38:	431a      	orrs	r2, r3
 8001c3a:	9b03      	ldr	r3, [sp, #12]
 8001c3c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8001c3e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001c40:	2b07      	cmp	r3, #7
 8001c42:	d809      	bhi.n	8001c58 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001c44:	9b03      	ldr	r3, [sp, #12]
 8001c46:	6a1b      	ldr	r3, [r3, #32]
 8001c48:	9a04      	ldr	r2, [sp, #16]
 8001c4a:	43d2      	mvns	r2, r2
 8001c4c:	401a      	ands	r2, r3
 8001c4e:	9b07      	ldr	r3, [sp, #28]
 8001c50:	431a      	orrs	r2, r3
 8001c52:	9b03      	ldr	r3, [sp, #12]
 8001c54:	621a      	str	r2, [r3, #32]
 8001c56:	e008      	b.n	8001c6a <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001c58:	9b03      	ldr	r3, [sp, #12]
 8001c5a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001c5c:	9a04      	ldr	r2, [sp, #16]
 8001c5e:	43d2      	mvns	r2, r2
 8001c60:	401a      	ands	r2, r3
 8001c62:	9b07      	ldr	r3, [sp, #28]
 8001c64:	431a      	orrs	r2, r3
 8001c66:	9b03      	ldr	r3, [sp, #12]
 8001c68:	625a      	str	r2, [r3, #36]	@ 0x24
      }
    }
    mask >>= 1;
 8001c6a:	9b02      	ldr	r3, [sp, #8]
 8001c6c:	085b      	lsrs	r3, r3, #1
 8001c6e:	9302      	str	r3, [sp, #8]
    if (!mask)
 8001c70:	9b02      	ldr	r3, [sp, #8]
 8001c72:	2b00      	cmp	r3, #0
 8001c74:	d00f      	beq.n	8001c96 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 8001c76:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8001c78:	005b      	lsls	r3, r3, #1
 8001c7a:	930c      	str	r3, [sp, #48]	@ 0x30
    ospeedr <<= 2;
 8001c7c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8001c7e:	009b      	lsls	r3, r3, #2
 8001c80:	930b      	str	r3, [sp, #44]	@ 0x2c
    pupdr <<= 2;
 8001c82:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8001c84:	009b      	lsls	r3, r3, #2
 8001c86:	930a      	str	r3, [sp, #40]	@ 0x28
    moder <<= 2;
 8001c88:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8001c8a:	009b      	lsls	r3, r3, #2
 8001c8c:	930d      	str	r3, [sp, #52]	@ 0x34
    bit++;
 8001c8e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001c90:	3301      	adds	r3, #1
 8001c92:	9309      	str	r3, [sp, #36]	@ 0x24
    if ((mask & 1) != 0) {
 8001c94:	e76a      	b.n	8001b6c <_pal_lld_setgroupmode+0x3c>
      return;
 8001c96:	46c0      	nop			@ (mov r8, r8)
  }
}
 8001c98:	b00e      	add	sp, #56	@ 0x38
 8001c9a:	4770      	bx	lr
 8001c9c:	0000      	movs	r0, r0
	...

08001ca0 <port_lock.lto_priv.6>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001ca0:	b672      	cpsid	i
}
 8001ca2:	46c0      	nop			@ (mov r8, r8)
}
 8001ca4:	46c0      	nop			@ (mov r8, r8)
 8001ca6:	4770      	bx	lr
	...

08001cb0 <port_unlock.lto_priv.6>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001cb0:	b662      	cpsie	i
}
 8001cb2:	46c0      	nop			@ (mov r8, r8)
}
 8001cb4:	46c0      	nop			@ (mov r8, r8)
 8001cb6:	4770      	bx	lr
	...

08001cc0 <port_lock_from_isr.lto_priv.1>:
static inline void port_lock_from_isr(void) {
 8001cc0:	b510      	push	{r4, lr}
  port_lock();
 8001cc2:	f7ff ffed 	bl	8001ca0 <port_lock.lto_priv.6>
}
 8001cc6:	46c0      	nop			@ (mov r8, r8)
 8001cc8:	bd10      	pop	{r4, pc}
 8001cca:	46c0      	nop			@ (mov r8, r8)
 8001ccc:	0000      	movs	r0, r0
	...

08001cd0 <port_unlock_from_isr.lto_priv.1>:
static inline void port_unlock_from_isr(void) {
 8001cd0:	b510      	push	{r4, lr}
  port_unlock();
 8001cd2:	f7ff ffed 	bl	8001cb0 <port_unlock.lto_priv.6>
}
 8001cd6:	46c0      	nop			@ (mov r8, r8)
 8001cd8:	bd10      	pop	{r4, pc}
 8001cda:	46c0      	nop			@ (mov r8, r8)
 8001cdc:	0000      	movs	r0, r0
	...

08001ce0 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 8001ce0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8001ce2:	f7ff ffed 	bl	8001cc0 <port_lock_from_isr.lto_priv.1>
  __dbg_check_lock_from_isr();
 8001ce6:	f000 fb4b 	bl	8002380 <__dbg_check_lock_from_isr>
}
 8001cea:	46c0      	nop			@ (mov r8, r8)
 8001cec:	bd10      	pop	{r4, pc}
 8001cee:	46c0      	nop			@ (mov r8, r8)

08001cf0 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8001cf0:	b510      	push	{r4, lr}
  __dbg_check_unlock_from_isr();
 8001cf2:	f000 fb6d 	bl	80023d0 <__dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8001cf6:	f7ff ffeb 	bl	8001cd0 <port_unlock_from_isr.lto_priv.1>
}
 8001cfa:	46c0      	nop			@ (mov r8, r8)
 8001cfc:	bd10      	pop	{r4, pc}
 8001cfe:	46c0      	nop			@ (mov r8, r8)

08001d00 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 8001d00:	b510      	push	{r4, lr}
  chSysLockFromISR();
 8001d02:	f7ff ffed 	bl	8001ce0 <chSysLockFromISR.lto_priv.1>
}
 8001d06:	46c0      	nop			@ (mov r8, r8)
 8001d08:	bd10      	pop	{r4, pc}
 8001d0a:	46c0      	nop			@ (mov r8, r8)
 8001d0c:	0000      	movs	r0, r0
	...

08001d10 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 8001d10:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 8001d12:	f7ff ffed 	bl	8001cf0 <chSysUnlockFromISR.lto_priv.1>
}
 8001d16:	46c0      	nop			@ (mov r8, r8)
 8001d18:	bd10      	pop	{r4, pc}
 8001d1a:	46c0      	nop			@ (mov r8, r8)
 8001d1c:	0000      	movs	r0, r0
	...

08001d20 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 8001d20:	b510      	push	{r4, lr}
  chSysTimerHandlerI();
 8001d22:	f000 faa5 	bl	8002270 <chSysTimerHandlerI>
}
 8001d26:	46c0      	nop			@ (mov r8, r8)
 8001d28:	bd10      	pop	{r4, pc}
 8001d2a:	46c0      	nop			@ (mov r8, r8)
 8001d2c:	0000      	movs	r0, r0
	...

08001d30 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001d30:	4b1a      	ldr	r3, [pc, #104]	@ (8001d9c <st_lld_init+0x6c>)
 8001d32:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8001d34:	4b19      	ldr	r3, [pc, #100]	@ (8001d9c <st_lld_init+0x6c>)
 8001d36:	2101      	movs	r1, #1
 8001d38:	430a      	orrs	r2, r1
 8001d3a:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001d3c:	4b17      	ldr	r3, [pc, #92]	@ (8001d9c <st_lld_init+0x6c>)
 8001d3e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001d40:	4b16      	ldr	r3, [pc, #88]	@ (8001d9c <st_lld_init+0x6c>)
 8001d42:	2101      	movs	r1, #1
 8001d44:	430a      	orrs	r2, r1
 8001d46:	64da      	str	r2, [r3, #76]	@ 0x4c
 8001d48:	4b14      	ldr	r3, [pc, #80]	@ (8001d9c <st_lld_init+0x6c>)
 8001d4a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001d4c:	4b14      	ldr	r3, [pc, #80]	@ (8001da0 <st_lld_init+0x70>)
 8001d4e:	689a      	ldr	r2, [r3, #8]
 8001d50:	4b13      	ldr	r3, [pc, #76]	@ (8001da0 <st_lld_init+0x70>)
 8001d52:	2101      	movs	r1, #1
 8001d54:	430a      	orrs	r2, r1
 8001d56:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001d58:	2380      	movs	r3, #128	@ 0x80
 8001d5a:	05db      	lsls	r3, r3, #23
 8001d5c:	4a11      	ldr	r2, [pc, #68]	@ (8001da4 <st_lld_init+0x74>)
 8001d5e:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001d60:	2380      	movs	r3, #128	@ 0x80
 8001d62:	05db      	lsls	r3, r3, #23
 8001d64:	4a10      	ldr	r2, [pc, #64]	@ (8001da8 <st_lld_init+0x78>)
 8001d66:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001d68:	2380      	movs	r3, #128	@ 0x80
 8001d6a:	05db      	lsls	r3, r3, #23
 8001d6c:	2200      	movs	r2, #0
 8001d6e:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001d70:	2380      	movs	r3, #128	@ 0x80
 8001d72:	05db      	lsls	r3, r3, #23
 8001d74:	2200      	movs	r2, #0
 8001d76:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 8001d78:	2380      	movs	r3, #128	@ 0x80
 8001d7a:	05db      	lsls	r3, r3, #23
 8001d7c:	2200      	movs	r2, #0
 8001d7e:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001d80:	2380      	movs	r3, #128	@ 0x80
 8001d82:	05db      	lsls	r3, r3, #23
 8001d84:	2200      	movs	r2, #0
 8001d86:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001d88:	2380      	movs	r3, #128	@ 0x80
 8001d8a:	05db      	lsls	r3, r3, #23
 8001d8c:	2201      	movs	r2, #1
 8001d8e:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001d90:	2380      	movs	r3, #128	@ 0x80
 8001d92:	05db      	lsls	r3, r3, #23
 8001d94:	2201      	movs	r2, #1
 8001d96:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001d98:	46c0      	nop			@ (mov r8, r8)
 8001d9a:	4770      	bx	lr
 8001d9c:	40021000 	.word	0x40021000
 8001da0:	40015800 	.word	0x40015800
 8001da4:	0000f9ff 	.word	0x0000f9ff
 8001da8:	0000ffff 	.word	0x0000ffff
 8001dac:	00000000 	.word	0x00000000

08001db0 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8001db0:	b500      	push	{lr}
 8001db2:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8001db4:	2380      	movs	r3, #128	@ 0x80
 8001db6:	05db      	lsls	r3, r3, #23
 8001db8:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 8001dba:	9b01      	ldr	r3, [sp, #4]
 8001dbc:	691b      	ldr	r3, [r3, #16]
 8001dbe:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001dc0:	9b01      	ldr	r3, [sp, #4]
 8001dc2:	68db      	ldr	r3, [r3, #12]
 8001dc4:	22ff      	movs	r2, #255	@ 0xff
 8001dc6:	401a      	ands	r2, r3
 8001dc8:	9b00      	ldr	r3, [sp, #0]
 8001dca:	4013      	ands	r3, r2
 8001dcc:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 8001dce:	9b00      	ldr	r3, [sp, #0]
 8001dd0:	43da      	mvns	r2, r3
 8001dd2:	9b01      	ldr	r3, [sp, #4]
 8001dd4:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8001dd6:	9b00      	ldr	r3, [sp, #0]
 8001dd8:	2202      	movs	r2, #2
 8001dda:	4013      	ands	r3, r2
 8001ddc:	d005      	beq.n	8001dea <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 8001dde:	f7ff ff8f 	bl	8001d00 <osalSysLockFromISR.lto_priv.1>
    osalOsTimerHandlerI();
 8001de2:	f7ff ff9d 	bl	8001d20 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8001de6:	f7ff ff93 	bl	8001d10 <osalSysUnlockFromISR.lto_priv.1>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 8001dea:	46c0      	nop			@ (mov r8, r8)
 8001dec:	b003      	add	sp, #12
 8001dee:	bd00      	pop	{pc}

08001df0 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8001df0:	b510      	push	{r4, lr}
  gptObjectInit(&GPTD5);
#endif

#if STM32_GPT_USE_TIM6
  /* Driver initialization.*/
  GPTD6.tim = STM32_TIM6;
 8001df2:	4b04      	ldr	r3, [pc, #16]	@ (8001e04 <gpt_lld_init+0x14>)
 8001df4:	4a04      	ldr	r2, [pc, #16]	@ (8001e08 <gpt_lld_init+0x18>)
 8001df6:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD6);
 8001df8:	4b02      	ldr	r3, [pc, #8]	@ (8001e04 <gpt_lld_init+0x14>)
 8001dfa:	0018      	movs	r0, r3
 8001dfc:	f7fe fd88 	bl	8000910 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 8001e00:	46c0      	nop			@ (mov r8, r8)
 8001e02:	bd10      	pop	{r4, pc}
 8001e04:	20000674 	.word	0x20000674
 8001e08:	40001000 	.word	0x40001000
 8001e0c:	00000000 	.word	0x00000000

08001e10 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 8001e10:	b500      	push	{lr}
 8001e12:	b085      	sub	sp, #20
 8001e14:	9001      	str	r0, [sp, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 8001e16:	9b01      	ldr	r3, [sp, #4]
 8001e18:	781b      	ldrb	r3, [r3, #0]
 8001e1a:	2b01      	cmp	r3, #1
 8001e1c:	d122      	bne.n	8001e64 <gpt_lld_start+0x54>
#endif
    }
#endif

#if STM32_GPT_USE_TIM6
    if (&GPTD6 == gptp) {
 8001e1e:	9a01      	ldr	r2, [sp, #4]
 8001e20:	4b32      	ldr	r3, [pc, #200]	@ (8001eec <gpt_lld_start+0xdc>)
 8001e22:	429a      	cmp	r2, r3
 8001e24:	d11e      	bne.n	8001e64 <gpt_lld_start+0x54>
      rccEnableTIM6(true);
 8001e26:	4b32      	ldr	r3, [pc, #200]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e28:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8001e2a:	4b31      	ldr	r3, [pc, #196]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e2c:	2110      	movs	r1, #16
 8001e2e:	430a      	orrs	r2, r1
 8001e30:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001e32:	4b2f      	ldr	r3, [pc, #188]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e34:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001e36:	4b2e      	ldr	r3, [pc, #184]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e38:	2110      	movs	r1, #16
 8001e3a:	430a      	orrs	r2, r1
 8001e3c:	64da      	str	r2, [r3, #76]	@ 0x4c
 8001e3e:	4b2c      	ldr	r3, [pc, #176]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e40:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
      rccResetTIM6();
 8001e42:	4b2b      	ldr	r3, [pc, #172]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e44:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8001e46:	4b2a      	ldr	r3, [pc, #168]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e48:	2110      	movs	r1, #16
 8001e4a:	430a      	orrs	r2, r1
 8001e4c:	62da      	str	r2, [r3, #44]	@ 0x2c
 8001e4e:	4b28      	ldr	r3, [pc, #160]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e50:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8001e52:	4b27      	ldr	r3, [pc, #156]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e54:	2110      	movs	r1, #16
 8001e56:	438a      	bics	r2, r1
 8001e58:	62da      	str	r2, [r3, #44]	@ 0x2c
 8001e5a:	4b25      	ldr	r3, [pc, #148]	@ (8001ef0 <gpt_lld_start+0xe0>)
 8001e5c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
      nvicEnableVector(STM32_TIM6_NUMBER, STM32_GPT_TIM6_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM6CLK)
      gptp->clock = STM32_TIM6CLK;
#else
      gptp->clock = STM32_TIMCLK1;
 8001e5e:	9b01      	ldr	r3, [sp, #4]
 8001e60:	4a24      	ldr	r2, [pc, #144]	@ (8001ef4 <gpt_lld_start+0xe4>)
 8001e62:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8001e64:	9b01      	ldr	r3, [sp, #4]
 8001e66:	689a      	ldr	r2, [r3, #8]
 8001e68:	9b01      	ldr	r3, [sp, #4]
 8001e6a:	685b      	ldr	r3, [r3, #4]
 8001e6c:	681b      	ldr	r3, [r3, #0]
 8001e6e:	0019      	movs	r1, r3
 8001e70:	0010      	movs	r0, r2
 8001e72:	f7fe f9b9 	bl	80001e8 <__udivsi3>
 8001e76:	0003      	movs	r3, r0
 8001e78:	b29a      	uxth	r2, r3
 8001e7a:	230e      	movs	r3, #14
 8001e7c:	446b      	add	r3, sp
 8001e7e:	3a01      	subs	r2, #1
 8001e80:	801a      	strh	r2, [r3, #0]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
 8001e82:	230e      	movs	r3, #14
 8001e84:	446b      	add	r3, sp
 8001e86:	881b      	ldrh	r3, [r3, #0]
 8001e88:	3301      	adds	r3, #1
 8001e8a:	001a      	movs	r2, r3
 8001e8c:	9b01      	ldr	r3, [sp, #4]
 8001e8e:	685b      	ldr	r3, [r3, #4]
 8001e90:	681b      	ldr	r3, [r3, #0]
 8001e92:	435a      	muls	r2, r3
 8001e94:	9b01      	ldr	r3, [sp, #4]
 8001e96:	689b      	ldr	r3, [r3, #8]
 8001e98:	1ad3      	subs	r3, r2, r3
 8001e9a:	1e5a      	subs	r2, r3, #1
 8001e9c:	4193      	sbcs	r3, r2
 8001e9e:	b2db      	uxtb	r3, r3
 8001ea0:	2b00      	cmp	r3, #0
 8001ea2:	d003      	beq.n	8001eac <gpt_lld_start+0x9c>
 8001ea4:	4b14      	ldr	r3, [pc, #80]	@ (8001ef8 <gpt_lld_start+0xe8>)
 8001ea6:	0018      	movs	r0, r3
 8001ea8:	f000 f9aa 	bl	8002200 <chSysHalt>
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0U;                         /* Initially stopped.       */
 8001eac:	9b01      	ldr	r3, [sp, #4]
 8001eae:	68db      	ldr	r3, [r3, #12]
 8001eb0:	2200      	movs	r2, #0
 8001eb2:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 8001eb4:	9b01      	ldr	r3, [sp, #4]
 8001eb6:	685a      	ldr	r2, [r3, #4]
 8001eb8:	9b01      	ldr	r3, [sp, #4]
 8001eba:	68db      	ldr	r3, [r3, #12]
 8001ebc:	6892      	ldr	r2, [r2, #8]
 8001ebe:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8001ec0:	9b01      	ldr	r3, [sp, #4]
 8001ec2:	68db      	ldr	r3, [r3, #12]
 8001ec4:	220e      	movs	r2, #14
 8001ec6:	446a      	add	r2, sp
 8001ec8:	8812      	ldrh	r2, [r2, #0]
 8001eca:	629a      	str	r2, [r3, #40]	@ 0x28
  gptp->tim->SR   = 0U;                         /* Clear pending IRQs.      */
 8001ecc:	9b01      	ldr	r3, [sp, #4]
 8001ece:	68db      	ldr	r3, [r3, #12]
 8001ed0:	2200      	movs	r2, #0
 8001ed2:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 8001ed4:	9b01      	ldr	r3, [sp, #4]
 8001ed6:	685b      	ldr	r3, [r3, #4]
 8001ed8:	68da      	ldr	r2, [r3, #12]
 8001eda:	9b01      	ldr	r3, [sp, #4]
 8001edc:	68db      	ldr	r3, [r3, #12]
 8001ede:	21ff      	movs	r1, #255	@ 0xff
 8001ee0:	438a      	bics	r2, r1
 8001ee2:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 8001ee4:	46c0      	nop			@ (mov r8, r8)
 8001ee6:	b005      	add	sp, #20
 8001ee8:	bd00      	pop	{pc}
 8001eea:	46c0      	nop			@ (mov r8, r8)
 8001eec:	20000674 	.word	0x20000674
 8001ef0:	40021000 	.word	0x40021000
 8001ef4:	03d09000 	.word	0x03d09000
 8001ef8:	0800514c 	.word	0x0800514c
 8001efc:	00000000 	.word	0x00000000

08001f00 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 8001f00:	b082      	sub	sp, #8
 8001f02:	9001      	str	r0, [sp, #4]
 8001f04:	9100      	str	r1, [sp, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8001f06:	9b01      	ldr	r3, [sp, #4]
 8001f08:	68db      	ldr	r3, [r3, #12]
 8001f0a:	9a00      	ldr	r2, [sp, #0]
 8001f0c:	3a01      	subs	r2, #1
 8001f0e:	62da      	str	r2, [r3, #44]	@ 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 8001f10:	9b01      	ldr	r3, [sp, #4]
 8001f12:	68db      	ldr	r3, [r3, #12]
 8001f14:	2201      	movs	r2, #1
 8001f16:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0U;                          /* Reset counter.           */
 8001f18:	9b01      	ldr	r3, [sp, #4]
 8001f1a:	68db      	ldr	r3, [r3, #12]
 8001f1c:	2200      	movs	r2, #0
 8001f1e:	625a      	str	r2, [r3, #36]	@ 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8001f20:	9b01      	ldr	r3, [sp, #4]
 8001f22:	68db      	ldr	r3, [r3, #12]
 8001f24:	2200      	movs	r2, #0
 8001f26:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8001f28:	9b01      	ldr	r3, [sp, #4]
 8001f2a:	685b      	ldr	r3, [r3, #4]
 8001f2c:	685b      	ldr	r3, [r3, #4]
 8001f2e:	2b00      	cmp	r3, #0
 8001f30:	d007      	beq.n	8001f42 <gpt_lld_start_timer+0x42>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8001f32:	9b01      	ldr	r3, [sp, #4]
 8001f34:	68db      	ldr	r3, [r3, #12]
 8001f36:	68da      	ldr	r2, [r3, #12]
 8001f38:	9b01      	ldr	r3, [sp, #4]
 8001f3a:	68db      	ldr	r3, [r3, #12]
 8001f3c:	2101      	movs	r1, #1
 8001f3e:	430a      	orrs	r2, r1
 8001f40:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8001f42:	9b01      	ldr	r3, [sp, #4]
 8001f44:	68db      	ldr	r3, [r3, #12]
 8001f46:	2285      	movs	r2, #133	@ 0x85
 8001f48:	601a      	str	r2, [r3, #0]
}
 8001f4a:	46c0      	nop			@ (mov r8, r8)
 8001f4c:	b002      	add	sp, #8
 8001f4e:	4770      	bx	lr

08001f50 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 8001f50:	b082      	sub	sp, #8
 8001f52:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1 = 0U;                          /* Initially stopped.       */
 8001f54:	9b01      	ldr	r3, [sp, #4]
 8001f56:	68db      	ldr	r3, [r3, #12]
 8001f58:	2200      	movs	r2, #0
 8001f5a:	601a      	str	r2, [r3, #0]
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8001f5c:	9b01      	ldr	r3, [sp, #4]
 8001f5e:	68db      	ldr	r3, [r3, #12]
 8001f60:	2200      	movs	r2, #0
 8001f62:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8001f64:	9b01      	ldr	r3, [sp, #4]
 8001f66:	68db      	ldr	r3, [r3, #12]
 8001f68:	68da      	ldr	r2, [r3, #12]
 8001f6a:	9b01      	ldr	r3, [sp, #4]
 8001f6c:	68db      	ldr	r3, [r3, #12]
 8001f6e:	21ff      	movs	r1, #255	@ 0xff
 8001f70:	438a      	bics	r2, r1
 8001f72:	60da      	str	r2, [r3, #12]
}
 8001f74:	46c0      	nop			@ (mov r8, r8)
 8001f76:	b002      	add	sp, #8
 8001f78:	4770      	bx	lr
 8001f7a:	46c0      	nop			@ (mov r8, r8)
 8001f7c:	0000      	movs	r0, r0
	...

08001f80 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 8001f80:	b500      	push	{lr}
 8001f82:	b085      	sub	sp, #20
 8001f84:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 8001f86:	9b01      	ldr	r3, [sp, #4]
 8001f88:	68db      	ldr	r3, [r3, #12]
 8001f8a:	691b      	ldr	r3, [r3, #16]
 8001f8c:	9303      	str	r3, [sp, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001f8e:	9b01      	ldr	r3, [sp, #4]
 8001f90:	68db      	ldr	r3, [r3, #12]
 8001f92:	68db      	ldr	r3, [r3, #12]
 8001f94:	22ff      	movs	r2, #255	@ 0xff
 8001f96:	401a      	ands	r2, r3
 8001f98:	9b03      	ldr	r3, [sp, #12]
 8001f9a:	4013      	ands	r3, r2
 8001f9c:	9303      	str	r3, [sp, #12]
  gptp->tim->SR = ~sr;
 8001f9e:	9b01      	ldr	r3, [sp, #4]
 8001fa0:	68db      	ldr	r3, [r3, #12]
 8001fa2:	9a03      	ldr	r2, [sp, #12]
 8001fa4:	43d2      	mvns	r2, r2
 8001fa6:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8001fa8:	9b03      	ldr	r3, [sp, #12]
 8001faa:	2201      	movs	r2, #1
 8001fac:	4013      	ands	r3, r2
 8001fae:	d015      	beq.n	8001fdc <gpt_lld_serve_interrupt+0x5c>
    _gpt_isr_invoke_cb(gptp);
 8001fb0:	9b01      	ldr	r3, [sp, #4]
 8001fb2:	781b      	ldrb	r3, [r3, #0]
 8001fb4:	2b04      	cmp	r3, #4
 8001fb6:	d106      	bne.n	8001fc6 <gpt_lld_serve_interrupt+0x46>
 8001fb8:	9b01      	ldr	r3, [sp, #4]
 8001fba:	2202      	movs	r2, #2
 8001fbc:	701a      	strb	r2, [r3, #0]
 8001fbe:	9b01      	ldr	r3, [sp, #4]
 8001fc0:	0018      	movs	r0, r3
 8001fc2:	f7ff ffc5 	bl	8001f50 <gpt_lld_stop_timer>
 8001fc6:	9b01      	ldr	r3, [sp, #4]
 8001fc8:	685b      	ldr	r3, [r3, #4]
 8001fca:	685b      	ldr	r3, [r3, #4]
 8001fcc:	2b00      	cmp	r3, #0
 8001fce:	d005      	beq.n	8001fdc <gpt_lld_serve_interrupt+0x5c>
 8001fd0:	9b01      	ldr	r3, [sp, #4]
 8001fd2:	685b      	ldr	r3, [r3, #4]
 8001fd4:	685b      	ldr	r3, [r3, #4]
 8001fd6:	9a01      	ldr	r2, [sp, #4]
 8001fd8:	0010      	movs	r0, r2
 8001fda:	4798      	blx	r3
  }
}
 8001fdc:	46c0      	nop			@ (mov r8, r8)
 8001fde:	b005      	add	sp, #20
 8001fe0:	bd00      	pop	{pc}
 8001fe2:	46c0      	nop			@ (mov r8, r8)
	...

08001ff0 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8001ff0:	b082      	sub	sp, #8
 8001ff2:	9001      	str	r0, [sp, #4]
 8001ff4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8001ff6:	9b00      	ldr	r3, [sp, #0]
 8001ff8:	685a      	ldr	r2, [r3, #4]
 8001ffa:	9b01      	ldr	r3, [sp, #4]
 8001ffc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001ffe:	9b00      	ldr	r3, [sp, #0]
 8002000:	689a      	ldr	r2, [r3, #8]
 8002002:	9b01      	ldr	r3, [sp, #4]
 8002004:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8002006:	9b00      	ldr	r3, [sp, #0]
 8002008:	68da      	ldr	r2, [r3, #12]
 800200a:	9b01      	ldr	r3, [sp, #4]
 800200c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800200e:	9b00      	ldr	r3, [sp, #0]
 8002010:	691a      	ldr	r2, [r3, #16]
 8002012:	9b01      	ldr	r3, [sp, #4]
 8002014:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8002016:	9b00      	ldr	r3, [sp, #0]
 8002018:	695a      	ldr	r2, [r3, #20]
 800201a:	9b01      	ldr	r3, [sp, #4]
 800201c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800201e:	9b00      	ldr	r3, [sp, #0]
 8002020:	699a      	ldr	r2, [r3, #24]
 8002022:	9b01      	ldr	r3, [sp, #4]
 8002024:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8002026:	9b00      	ldr	r3, [sp, #0]
 8002028:	681a      	ldr	r2, [r3, #0]
 800202a:	9b01      	ldr	r3, [sp, #4]
 800202c:	601a      	str	r2, [r3, #0]
}
 800202e:	46c0      	nop			@ (mov r8, r8)
 8002030:	b002      	add	sp, #8
 8002032:	4770      	bx	lr
	...

08002040 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8002040:	b510      	push	{r4, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetIOP(STM32_GPIO_EN_MASK);
 8002042:	4b1e      	ldr	r3, [pc, #120]	@ (80020bc <stm32_gpio_init+0x7c>)
 8002044:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8002046:	4b1d      	ldr	r3, [pc, #116]	@ (80020bc <stm32_gpio_init+0x7c>)
 8002048:	212f      	movs	r1, #47	@ 0x2f
 800204a:	430a      	orrs	r2, r1
 800204c:	625a      	str	r2, [r3, #36]	@ 0x24
 800204e:	4b1b      	ldr	r3, [pc, #108]	@ (80020bc <stm32_gpio_init+0x7c>)
 8002050:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8002052:	4b1a      	ldr	r3, [pc, #104]	@ (80020bc <stm32_gpio_init+0x7c>)
 8002054:	212f      	movs	r1, #47	@ 0x2f
 8002056:	438a      	bics	r2, r1
 8002058:	625a      	str	r2, [r3, #36]	@ 0x24
 800205a:	4b18      	ldr	r3, [pc, #96]	@ (80020bc <stm32_gpio_init+0x7c>)
 800205c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  rccEnableIOP(STM32_GPIO_EN_MASK, true);
 800205e:	4b17      	ldr	r3, [pc, #92]	@ (80020bc <stm32_gpio_init+0x7c>)
 8002060:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8002062:	4b16      	ldr	r3, [pc, #88]	@ (80020bc <stm32_gpio_init+0x7c>)
 8002064:	212f      	movs	r1, #47	@ 0x2f
 8002066:	430a      	orrs	r2, r1
 8002068:	635a      	str	r2, [r3, #52]	@ 0x34
 800206a:	4b14      	ldr	r3, [pc, #80]	@ (80020bc <stm32_gpio_init+0x7c>)
 800206c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800206e:	4b13      	ldr	r3, [pc, #76]	@ (80020bc <stm32_gpio_init+0x7c>)
 8002070:	212f      	movs	r1, #47	@ 0x2f
 8002072:	430a      	orrs	r2, r1
 8002074:	645a      	str	r2, [r3, #68]	@ 0x44
 8002076:	4b11      	ldr	r3, [pc, #68]	@ (80020bc <stm32_gpio_init+0x7c>)
 8002078:	6c5b      	ldr	r3, [r3, #68]	@ 0x44

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 800207a:	4a11      	ldr	r2, [pc, #68]	@ (80020c0 <stm32_gpio_init+0x80>)
 800207c:	23a0      	movs	r3, #160	@ 0xa0
 800207e:	05db      	lsls	r3, r3, #23
 8002080:	0011      	movs	r1, r2
 8002082:	0018      	movs	r0, r3
 8002084:	f7ff ffb4 	bl	8001ff0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8002088:	4b0e      	ldr	r3, [pc, #56]	@ (80020c4 <stm32_gpio_init+0x84>)
 800208a:	4a0f      	ldr	r2, [pc, #60]	@ (80020c8 <stm32_gpio_init+0x88>)
 800208c:	0019      	movs	r1, r3
 800208e:	0010      	movs	r0, r2
 8002090:	f7ff ffae 	bl	8001ff0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 8002094:	4b0d      	ldr	r3, [pc, #52]	@ (80020cc <stm32_gpio_init+0x8c>)
 8002096:	4a0e      	ldr	r2, [pc, #56]	@ (80020d0 <stm32_gpio_init+0x90>)
 8002098:	0019      	movs	r1, r3
 800209a:	0010      	movs	r0, r2
 800209c:	f7ff ffa8 	bl	8001ff0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 80020a0:	4b0c      	ldr	r3, [pc, #48]	@ (80020d4 <stm32_gpio_init+0x94>)
 80020a2:	4a0d      	ldr	r2, [pc, #52]	@ (80020d8 <stm32_gpio_init+0x98>)
 80020a4:	0019      	movs	r1, r3
 80020a6:	0010      	movs	r0, r2
 80020a8:	f7ff ffa2 	bl	8001ff0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 80020ac:	4b0b      	ldr	r3, [pc, #44]	@ (80020dc <stm32_gpio_init+0x9c>)
 80020ae:	4a0c      	ldr	r2, [pc, #48]	@ (80020e0 <stm32_gpio_init+0xa0>)
 80020b0:	0019      	movs	r1, r3
 80020b2:	0010      	movs	r0, r2
 80020b4:	f7ff ff9c 	bl	8001ff0 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 80020b8:	46c0      	nop			@ (mov r8, r8)
 80020ba:	bd10      	pop	{r4, pc}
 80020bc:	40021000 	.word	0x40021000
 80020c0:	0800515c 	.word	0x0800515c
 80020c4:	08005178 	.word	0x08005178
 80020c8:	50000400 	.word	0x50000400
 80020cc:	08005194 	.word	0x08005194
 80020d0:	50000800 	.word	0x50000800
 80020d4:	080051b0 	.word	0x080051b0
 80020d8:	50000c00 	.word	0x50000c00
 80020dc:	080051cc 	.word	0x080051cc
 80020e0:	50001400 	.word	0x50001400
	...

080020f0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80020f0:	b510      	push	{r4, lr}

  stm32_gpio_init();
 80020f2:	f7ff ffa5 	bl	8002040 <stm32_gpio_init>
  stm32_clock_init();
 80020f6:	f7fe ffe3 	bl	80010c0 <stm32_clock_init>
}
 80020fa:	46c0      	nop			@ (mov r8, r8)
 80020fc:	bd10      	pop	{r4, pc}
 80020fe:	46c0      	nop			@ (mov r8, r8)

08002100 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    Add your board-specific code, if any.
 */
void boardInit(void) {

}
 8002100:	46c0      	nop			@ (mov r8, r8)
 8002102:	4770      	bx	lr
	...

08002110 <port_unlock.lto_priv.7>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002110:	b662      	cpsie	i
}
 8002112:	46c0      	nop			@ (mov r8, r8)
}
 8002114:	46c0      	nop			@ (mov r8, r8)
 8002116:	4770      	bx	lr
	...

08002120 <port_disable>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002120:	b672      	cpsid	i
}
 8002122:	46c0      	nop			@ (mov r8, r8)
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8002124:	46c0      	nop			@ (mov r8, r8)
 8002126:	4770      	bx	lr
	...

08002130 <chSysUnlock.lto_priv.5>:
static inline void chSysUnlock(void) {
 8002130:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8002132:	f000 f8fd 	bl	8002330 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8002136:	4b0e      	ldr	r3, [pc, #56]	@ (8002170 <chSysUnlock.lto_priv.5+0x40>)
 8002138:	681a      	ldr	r2, [r3, #0]
 800213a:	4b0d      	ldr	r3, [pc, #52]	@ (8002170 <chSysUnlock.lto_priv.5+0x40>)
 800213c:	1ad3      	subs	r3, r2, r3
 800213e:	1e5a      	subs	r2, r3, #1
 8002140:	4193      	sbcs	r3, r2
 8002142:	b2db      	uxtb	r3, r3
 8002144:	2b00      	cmp	r3, #0
 8002146:	d00f      	beq.n	8002168 <chSysUnlock.lto_priv.5+0x38>
 8002148:	4b09      	ldr	r3, [pc, #36]	@ (8002170 <chSysUnlock.lto_priv.5+0x40>)
 800214a:	68db      	ldr	r3, [r3, #12]
 800214c:	689a      	ldr	r2, [r3, #8]
 800214e:	4b08      	ldr	r3, [pc, #32]	@ (8002170 <chSysUnlock.lto_priv.5+0x40>)
 8002150:	681b      	ldr	r3, [r3, #0]
 8002152:	689b      	ldr	r3, [r3, #8]
 8002154:	429a      	cmp	r2, r3
 8002156:	419b      	sbcs	r3, r3
 8002158:	425b      	negs	r3, r3
 800215a:	b2db      	uxtb	r3, r3
 800215c:	2b00      	cmp	r3, #0
 800215e:	d003      	beq.n	8002168 <chSysUnlock.lto_priv.5+0x38>
 8002160:	4b04      	ldr	r3, [pc, #16]	@ (8002174 <chSysUnlock.lto_priv.5+0x44>)
 8002162:	0018      	movs	r0, r3
 8002164:	f000 f84c 	bl	8002200 <chSysHalt>
  port_unlock();
 8002168:	f7ff ffd2 	bl	8002110 <port_unlock.lto_priv.7>
}
 800216c:	46c0      	nop			@ (mov r8, r8)
 800216e:	bd10      	pop	{r4, pc}
 8002170:	20000690 	.word	0x20000690
 8002174:	08005274 	.word	0x08005274
	...

08002180 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 8002180:	b510      	push	{r4, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 8002182:	f002 fa9d 	bl	80046c0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8002186:	f002 fb03 	bl	8004790 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 800218a:	f002 fcb9 	bl	8004b00 <__factory_init>
#endif
}
 800218e:	46c0      	nop			@ (mov r8, r8)
 8002190:	bd10      	pop	{r4, pc}
 8002192:	46c0      	nop			@ (mov r8, r8)
	...

080021a0 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 80021a0:	b500      	push	{lr}
 80021a2:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 80021a4:	4b11      	ldr	r3, [pc, #68]	@ (80021ec <chSysInit+0x4c>)
 80021a6:	2201      	movs	r2, #1
 80021a8:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80021aa:	2300      	movs	r3, #0
 80021ac:	9301      	str	r3, [sp, #4]
 80021ae:	e009      	b.n	80021c4 <chSysInit+0x24>
    ch_system.instances[i] = NULL;
 80021b0:	4a0e      	ldr	r2, [pc, #56]	@ (80021ec <chSysInit+0x4c>)
 80021b2:	9b01      	ldr	r3, [sp, #4]
 80021b4:	009b      	lsls	r3, r3, #2
 80021b6:	18d3      	adds	r3, r2, r3
 80021b8:	3304      	adds	r3, #4
 80021ba:	2200      	movs	r2, #0
 80021bc:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80021be:	9b01      	ldr	r3, [sp, #4]
 80021c0:	3301      	adds	r3, #1
 80021c2:	9301      	str	r3, [sp, #4]
 80021c4:	9b01      	ldr	r3, [sp, #4]
 80021c6:	2b00      	cmp	r3, #0
 80021c8:	d0f2      	beq.n	80021b0 <chSysInit+0x10>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 80021ca:	f7ff ffd9 	bl	8002180 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 80021ce:	4a08      	ldr	r2, [pc, #32]	@ (80021f0 <chSysInit+0x50>)
 80021d0:	4b08      	ldr	r3, [pc, #32]	@ (80021f4 <chSysInit+0x54>)
 80021d2:	0011      	movs	r1, r2
 80021d4:	0018      	movs	r0, r3
 80021d6:	f001 fb43 	bl	8003860 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 80021da:	4b04      	ldr	r3, [pc, #16]	@ (80021ec <chSysInit+0x4c>)
 80021dc:	2202      	movs	r2, #2
 80021de:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 80021e0:	f7ff ffa6 	bl	8002130 <chSysUnlock.lto_priv.5>
}
 80021e4:	46c0      	nop			@ (mov r8, r8)
 80021e6:	b003      	add	sp, #12
 80021e8:	bd00      	pop	{pc}
 80021ea:	46c0      	nop			@ (mov r8, r8)
 80021ec:	20000684 	.word	0x20000684
 80021f0:	08005260 	.word	0x08005260
 80021f4:	20000690 	.word	0x20000690
	...

08002200 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002200:	b500      	push	{lr}
 8002202:	b083      	sub	sp, #12
 8002204:	9001      	str	r0, [sp, #4]

  port_disable();
 8002206:	f7ff ff8b 	bl	8002120 <port_disable>

  /* Logging the event.*/
  __trace_halt(reason);
 800220a:	9b01      	ldr	r3, [sp, #4]
 800220c:	0018      	movs	r0, r3
 800220e:	f000 fb0f 	bl	8002830 <__trace_halt>

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 8002212:	4b04      	ldr	r3, [pc, #16]	@ (8002224 <chSysHalt+0x24>)
 8002214:	2184      	movs	r1, #132	@ 0x84
 8002216:	9a01      	ldr	r2, [sp, #4]
 8002218:	505a      	str	r2, [r3, r1]
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 800221a:	4b03      	ldr	r3, [pc, #12]	@ (8002228 <chSysHalt+0x28>)
 800221c:	2203      	movs	r2, #3
 800221e:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
     asm volatile ("nop");
 8002220:	46c0      	nop			@ (mov r8, r8)
 8002222:	e7fd      	b.n	8002220 <chSysHalt+0x20>
 8002224:	20000690 	.word	0x20000690
 8002228:	20000684 	.word	0x20000684
 800222c:	00000000 	.word	0x00000000

08002230 <chSysGetIdleThreadX>:
 *
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
 8002230:	b500      	push	{lr}
 8002232:	b083      	sub	sp, #12
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8002234:	4b09      	ldr	r3, [pc, #36]	@ (800225c <chSysGetIdleThreadX+0x2c>)
 8002236:	685b      	ldr	r3, [r3, #4]
 8002238:	9301      	str	r3, [sp, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 800223a:	9b01      	ldr	r3, [sp, #4]
 800223c:	689b      	ldr	r3, [r3, #8]
 800223e:	3b01      	subs	r3, #1
 8002240:	1e5a      	subs	r2, r3, #1
 8002242:	4193      	sbcs	r3, r2
 8002244:	b2db      	uxtb	r3, r3
 8002246:	2b00      	cmp	r3, #0
 8002248:	d003      	beq.n	8002252 <chSysGetIdleThreadX+0x22>
 800224a:	4b05      	ldr	r3, [pc, #20]	@ (8002260 <chSysGetIdleThreadX+0x30>)
 800224c:	0018      	movs	r0, r3
 800224e:	f7ff ffd7 	bl	8002200 <chSysHalt>

  return tp;
 8002252:	9b01      	ldr	r3, [sp, #4]
}
 8002254:	0018      	movs	r0, r3
 8002256:	b003      	add	sp, #12
 8002258:	bd00      	pop	{pc}
 800225a:	46c0      	nop			@ (mov r8, r8)
 800225c:	20000690 	.word	0x20000690
 8002260:	08005280 	.word	0x08005280
	...

08002270 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002270:	b510      	push	{r4, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 8002272:	f000 f935 	bl	80024e0 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8002276:	f000 fe5b 	bl	8002f30 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800227a:	46c0      	nop			@ (mov r8, r8)
 800227c:	bd10      	pop	{r4, pc}
 800227e:	46c0      	nop			@ (mov r8, r8)

08002280 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 8002280:	b082      	sub	sp, #8
 8002282:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8002284:	4b04      	ldr	r3, [pc, #16]	@ (8002298 <chRFCUCollectFaultsI+0x18>)
 8002286:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8002288:	9b01      	ldr	r3, [sp, #4]
 800228a:	431a      	orrs	r2, r3
 800228c:	4b02      	ldr	r3, [pc, #8]	@ (8002298 <chRFCUCollectFaultsI+0x18>)
 800228e:	635a      	str	r2, [r3, #52]	@ 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8002290:	46c0      	nop			@ (mov r8, r8)
 8002292:	b002      	add	sp, #8
 8002294:	4770      	bx	lr
 8002296:	46c0      	nop			@ (mov r8, r8)
 8002298:	20000690 	.word	0x20000690
 800229c:	00000000 	.word	0x00000000

080022a0 <port_lock.lto_priv.8>:
  __ASM volatile ("cpsid i" : : : "memory");
 80022a0:	b672      	cpsid	i
}
 80022a2:	46c0      	nop			@ (mov r8, r8)
}
 80022a4:	46c0      	nop			@ (mov r8, r8)
 80022a6:	4770      	bx	lr
	...

080022b0 <port_unlock.lto_priv.8>:
  __ASM volatile ("cpsie i" : : : "memory");
 80022b0:	b662      	cpsie	i
}
 80022b2:	46c0      	nop			@ (mov r8, r8)
}
 80022b4:	46c0      	nop			@ (mov r8, r8)
 80022b6:	4770      	bx	lr
	...

080022c0 <port_lock_from_isr.lto_priv.3>:
static inline void port_lock_from_isr(void) {
 80022c0:	b510      	push	{r4, lr}
  port_lock();
 80022c2:	f7ff ffed 	bl	80022a0 <port_lock.lto_priv.8>
}
 80022c6:	46c0      	nop			@ (mov r8, r8)
 80022c8:	bd10      	pop	{r4, pc}
 80022ca:	46c0      	nop			@ (mov r8, r8)
 80022cc:	0000      	movs	r0, r0
	...

080022d0 <port_unlock_from_isr.lto_priv.3>:
static inline void port_unlock_from_isr(void) {
 80022d0:	b510      	push	{r4, lr}
  port_unlock();
 80022d2:	f7ff ffed 	bl	80022b0 <port_unlock.lto_priv.8>
}
 80022d6:	46c0      	nop			@ (mov r8, r8)
 80022d8:	bd10      	pop	{r4, pc}
 80022da:	46c0      	nop			@ (mov r8, r8)
 80022dc:	0000      	movs	r0, r0
	...

080022e0 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 80022e0:	b500      	push	{lr}
 80022e2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80022e4:	4b0e      	ldr	r3, [pc, #56]	@ (8002320 <__dbg_check_lock+0x40>)
 80022e6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80022e8:	9b01      	ldr	r3, [sp, #4]
 80022ea:	2288      	movs	r2, #136	@ 0x88
 80022ec:	589b      	ldr	r3, [r3, r2]
 80022ee:	1e5a      	subs	r2, r3, #1
 80022f0:	4193      	sbcs	r3, r2
 80022f2:	b2db      	uxtb	r3, r3
 80022f4:	2b00      	cmp	r3, #0
 80022f6:	d107      	bne.n	8002308 <__dbg_check_lock+0x28>
 80022f8:	9b01      	ldr	r3, [sp, #4]
 80022fa:	228c      	movs	r2, #140	@ 0x8c
 80022fc:	589b      	ldr	r3, [r3, r2]
 80022fe:	1e5a      	subs	r2, r3, #1
 8002300:	4193      	sbcs	r3, r2
 8002302:	b2db      	uxtb	r3, r3
 8002304:	2b00      	cmp	r3, #0
 8002306:	d003      	beq.n	8002310 <__dbg_check_lock+0x30>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 8002308:	4b06      	ldr	r3, [pc, #24]	@ (8002324 <__dbg_check_lock+0x44>)
 800230a:	0018      	movs	r0, r3
 800230c:	f7ff ff78 	bl	8002200 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002310:	9b01      	ldr	r3, [sp, #4]
 8002312:	228c      	movs	r2, #140	@ 0x8c
 8002314:	2101      	movs	r1, #1
 8002316:	5099      	str	r1, [r3, r2]
}
 8002318:	46c0      	nop			@ (mov r8, r8)
 800231a:	b003      	add	sp, #12
 800231c:	bd00      	pop	{pc}
 800231e:	46c0      	nop			@ (mov r8, r8)
 8002320:	20000690 	.word	0x20000690
 8002324:	080051ec 	.word	0x080051ec
	...

08002330 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 8002330:	b500      	push	{lr}
 8002332:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002334:	4b0e      	ldr	r3, [pc, #56]	@ (8002370 <__dbg_check_unlock+0x40>)
 8002336:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002338:	9b01      	ldr	r3, [sp, #4]
 800233a:	2288      	movs	r2, #136	@ 0x88
 800233c:	589b      	ldr	r3, [r3, r2]
 800233e:	1e5a      	subs	r2, r3, #1
 8002340:	4193      	sbcs	r3, r2
 8002342:	b2db      	uxtb	r3, r3
 8002344:	2b00      	cmp	r3, #0
 8002346:	d108      	bne.n	800235a <__dbg_check_unlock+0x2a>
 8002348:	9b01      	ldr	r3, [sp, #4]
 800234a:	228c      	movs	r2, #140	@ 0x8c
 800234c:	589b      	ldr	r3, [r3, r2]
 800234e:	1e5a      	subs	r2, r3, #1
 8002350:	4313      	orrs	r3, r2
 8002352:	0fdb      	lsrs	r3, r3, #31
 8002354:	b2db      	uxtb	r3, r3
 8002356:	2b00      	cmp	r3, #0
 8002358:	d003      	beq.n	8002362 <__dbg_check_unlock+0x32>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 800235a:	4b06      	ldr	r3, [pc, #24]	@ (8002374 <__dbg_check_unlock+0x44>)
 800235c:	0018      	movs	r0, r3
 800235e:	f7ff ff4f 	bl	8002200 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002362:	9b01      	ldr	r3, [sp, #4]
 8002364:	228c      	movs	r2, #140	@ 0x8c
 8002366:	2100      	movs	r1, #0
 8002368:	5099      	str	r1, [r3, r2]
}
 800236a:	46c0      	nop			@ (mov r8, r8)
 800236c:	b003      	add	sp, #12
 800236e:	bd00      	pop	{pc}
 8002370:	20000690 	.word	0x20000690
 8002374:	080051f4 	.word	0x080051f4
	...

08002380 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 8002380:	b500      	push	{lr}
 8002382:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002384:	4b0e      	ldr	r3, [pc, #56]	@ (80023c0 <__dbg_check_lock_from_isr+0x40>)
 8002386:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002388:	9b01      	ldr	r3, [sp, #4]
 800238a:	2288      	movs	r2, #136	@ 0x88
 800238c:	589b      	ldr	r3, [r3, r2]
 800238e:	1e5a      	subs	r2, r3, #1
 8002390:	4313      	orrs	r3, r2
 8002392:	0fdb      	lsrs	r3, r3, #31
 8002394:	b2db      	uxtb	r3, r3
 8002396:	2b00      	cmp	r3, #0
 8002398:	d107      	bne.n	80023aa <__dbg_check_lock_from_isr+0x2a>
 800239a:	9b01      	ldr	r3, [sp, #4]
 800239c:	228c      	movs	r2, #140	@ 0x8c
 800239e:	589b      	ldr	r3, [r3, r2]
 80023a0:	1e5a      	subs	r2, r3, #1
 80023a2:	4193      	sbcs	r3, r2
 80023a4:	b2db      	uxtb	r3, r3
 80023a6:	2b00      	cmp	r3, #0
 80023a8:	d003      	beq.n	80023b2 <__dbg_check_lock_from_isr+0x32>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 80023aa:	4b06      	ldr	r3, [pc, #24]	@ (80023c4 <__dbg_check_lock_from_isr+0x44>)
 80023ac:	0018      	movs	r0, r3
 80023ae:	f7ff ff27 	bl	8002200 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 80023b2:	9b01      	ldr	r3, [sp, #4]
 80023b4:	228c      	movs	r2, #140	@ 0x8c
 80023b6:	2101      	movs	r1, #1
 80023b8:	5099      	str	r1, [r3, r2]
}
 80023ba:	46c0      	nop			@ (mov r8, r8)
 80023bc:	b003      	add	sp, #12
 80023be:	bd00      	pop	{pc}
 80023c0:	20000690 	.word	0x20000690
 80023c4:	080051fc 	.word	0x080051fc
	...

080023d0 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 80023d0:	b500      	push	{lr}
 80023d2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80023d4:	4b0f      	ldr	r3, [pc, #60]	@ (8002414 <__dbg_check_unlock_from_isr+0x44>)
 80023d6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80023d8:	9b01      	ldr	r3, [sp, #4]
 80023da:	2288      	movs	r2, #136	@ 0x88
 80023dc:	589b      	ldr	r3, [r3, r2]
 80023de:	1e5a      	subs	r2, r3, #1
 80023e0:	4313      	orrs	r3, r2
 80023e2:	0fdb      	lsrs	r3, r3, #31
 80023e4:	b2db      	uxtb	r3, r3
 80023e6:	2b00      	cmp	r3, #0
 80023e8:	d108      	bne.n	80023fc <__dbg_check_unlock_from_isr+0x2c>
 80023ea:	9b01      	ldr	r3, [sp, #4]
 80023ec:	228c      	movs	r2, #140	@ 0x8c
 80023ee:	589b      	ldr	r3, [r3, r2]
 80023f0:	1e5a      	subs	r2, r3, #1
 80023f2:	4313      	orrs	r3, r2
 80023f4:	0fdb      	lsrs	r3, r3, #31
 80023f6:	b2db      	uxtb	r3, r3
 80023f8:	2b00      	cmp	r3, #0
 80023fa:	d003      	beq.n	8002404 <__dbg_check_unlock_from_isr+0x34>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 80023fc:	4b06      	ldr	r3, [pc, #24]	@ (8002418 <__dbg_check_unlock_from_isr+0x48>)
 80023fe:	0018      	movs	r0, r3
 8002400:	f7ff fefe 	bl	8002200 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002404:	9b01      	ldr	r3, [sp, #4]
 8002406:	228c      	movs	r2, #140	@ 0x8c
 8002408:	2100      	movs	r1, #0
 800240a:	5099      	str	r1, [r3, r2]
}
 800240c:	46c0      	nop			@ (mov r8, r8)
 800240e:	b003      	add	sp, #12
 8002410:	bd00      	pop	{pc}
 8002412:	46c0      	nop			@ (mov r8, r8)
 8002414:	20000690 	.word	0x20000690
 8002418:	08005204 	.word	0x08005204
 800241c:	00000000 	.word	0x00000000

08002420 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 8002420:	b500      	push	{lr}
 8002422:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002424:	4b11      	ldr	r3, [pc, #68]	@ (800246c <__dbg_check_enter_isr+0x4c>)
 8002426:	9301      	str	r3, [sp, #4]

  port_lock_from_isr();
 8002428:	f7ff ff4a 	bl	80022c0 <port_lock_from_isr.lto_priv.3>
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 800242c:	9b01      	ldr	r3, [sp, #4]
 800242e:	2288      	movs	r2, #136	@ 0x88
 8002430:	589b      	ldr	r3, [r3, r2]
 8002432:	0fdb      	lsrs	r3, r3, #31
 8002434:	b2db      	uxtb	r3, r3
 8002436:	2b00      	cmp	r3, #0
 8002438:	d107      	bne.n	800244a <__dbg_check_enter_isr+0x2a>
 800243a:	9b01      	ldr	r3, [sp, #4]
 800243c:	228c      	movs	r2, #140	@ 0x8c
 800243e:	589b      	ldr	r3, [r3, r2]
 8002440:	1e5a      	subs	r2, r3, #1
 8002442:	4193      	sbcs	r3, r2
 8002444:	b2db      	uxtb	r3, r3
 8002446:	2b00      	cmp	r3, #0
 8002448:	d003      	beq.n	8002452 <__dbg_check_enter_isr+0x32>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 800244a:	4b09      	ldr	r3, [pc, #36]	@ (8002470 <__dbg_check_enter_isr+0x50>)
 800244c:	0018      	movs	r0, r3
 800244e:	f7ff fed7 	bl	8002200 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 8002452:	9b01      	ldr	r3, [sp, #4]
 8002454:	2288      	movs	r2, #136	@ 0x88
 8002456:	589b      	ldr	r3, [r3, r2]
 8002458:	1c5a      	adds	r2, r3, #1
 800245a:	9b01      	ldr	r3, [sp, #4]
 800245c:	2188      	movs	r1, #136	@ 0x88
 800245e:	505a      	str	r2, [r3, r1]
  port_unlock_from_isr();
 8002460:	f7ff ff36 	bl	80022d0 <port_unlock_from_isr.lto_priv.3>
}
 8002464:	46c0      	nop			@ (mov r8, r8)
 8002466:	b003      	add	sp, #12
 8002468:	bd00      	pop	{pc}
 800246a:	46c0      	nop			@ (mov r8, r8)
 800246c:	20000690 	.word	0x20000690
 8002470:	0800520c 	.word	0x0800520c
	...

08002480 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 8002480:	b500      	push	{lr}
 8002482:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002484:	4b12      	ldr	r3, [pc, #72]	@ (80024d0 <__dbg_check_leave_isr+0x50>)
 8002486:	9301      	str	r3, [sp, #4]

  port_lock_from_isr();
 8002488:	f7ff ff1a 	bl	80022c0 <port_lock_from_isr.lto_priv.3>
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 800248c:	9b01      	ldr	r3, [sp, #4]
 800248e:	2288      	movs	r2, #136	@ 0x88
 8002490:	589b      	ldr	r3, [r3, r2]
 8002492:	1e5a      	subs	r2, r3, #1
 8002494:	4313      	orrs	r3, r2
 8002496:	0fdb      	lsrs	r3, r3, #31
 8002498:	b2db      	uxtb	r3, r3
 800249a:	2b00      	cmp	r3, #0
 800249c:	d107      	bne.n	80024ae <__dbg_check_leave_isr+0x2e>
 800249e:	9b01      	ldr	r3, [sp, #4]
 80024a0:	228c      	movs	r2, #140	@ 0x8c
 80024a2:	589b      	ldr	r3, [r3, r2]
 80024a4:	1e5a      	subs	r2, r3, #1
 80024a6:	4193      	sbcs	r3, r2
 80024a8:	b2db      	uxtb	r3, r3
 80024aa:	2b00      	cmp	r3, #0
 80024ac:	d003      	beq.n	80024b6 <__dbg_check_leave_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 80024ae:	4b09      	ldr	r3, [pc, #36]	@ (80024d4 <__dbg_check_leave_isr+0x54>)
 80024b0:	0018      	movs	r0, r3
 80024b2:	f7ff fea5 	bl	8002200 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 80024b6:	9b01      	ldr	r3, [sp, #4]
 80024b8:	2288      	movs	r2, #136	@ 0x88
 80024ba:	589b      	ldr	r3, [r3, r2]
 80024bc:	1e5a      	subs	r2, r3, #1
 80024be:	9b01      	ldr	r3, [sp, #4]
 80024c0:	2188      	movs	r1, #136	@ 0x88
 80024c2:	505a      	str	r2, [r3, r1]
  port_unlock_from_isr();
 80024c4:	f7ff ff04 	bl	80022d0 <port_unlock_from_isr.lto_priv.3>
}
 80024c8:	46c0      	nop			@ (mov r8, r8)
 80024ca:	b003      	add	sp, #12
 80024cc:	bd00      	pop	{pc}
 80024ce:	46c0      	nop			@ (mov r8, r8)
 80024d0:	20000690 	.word	0x20000690
 80024d4:	08005214 	.word	0x08005214
	...

080024e0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 80024e0:	b500      	push	{lr}
 80024e2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80024e4:	4b0c      	ldr	r3, [pc, #48]	@ (8002518 <chDbgCheckClassI+0x38>)
 80024e6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80024e8:	9b01      	ldr	r3, [sp, #4]
 80024ea:	2288      	movs	r2, #136	@ 0x88
 80024ec:	589b      	ldr	r3, [r3, r2]
 80024ee:	0fdb      	lsrs	r3, r3, #31
 80024f0:	b2db      	uxtb	r3, r3
 80024f2:	2b00      	cmp	r3, #0
 80024f4:	d108      	bne.n	8002508 <chDbgCheckClassI+0x28>
 80024f6:	9b01      	ldr	r3, [sp, #4]
 80024f8:	228c      	movs	r2, #140	@ 0x8c
 80024fa:	589b      	ldr	r3, [r3, r2]
 80024fc:	1e5a      	subs	r2, r3, #1
 80024fe:	4313      	orrs	r3, r2
 8002500:	0fdb      	lsrs	r3, r3, #31
 8002502:	b2db      	uxtb	r3, r3
 8002504:	2b00      	cmp	r3, #0
 8002506:	d003      	beq.n	8002510 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 8002508:	4b04      	ldr	r3, [pc, #16]	@ (800251c <chDbgCheckClassI+0x3c>)
 800250a:	0018      	movs	r0, r3
 800250c:	f7ff fe78 	bl	8002200 <chSysHalt>
  }
}
 8002510:	46c0      	nop			@ (mov r8, r8)
 8002512:	b003      	add	sp, #12
 8002514:	bd00      	pop	{pc}
 8002516:	46c0      	nop			@ (mov r8, r8)
 8002518:	20000690 	.word	0x20000690
 800251c:	0800521c 	.word	0x0800521c

08002520 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002520:	b500      	push	{lr}
 8002522:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002524:	4b0c      	ldr	r3, [pc, #48]	@ (8002558 <chDbgCheckClassS+0x38>)
 8002526:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002528:	9b01      	ldr	r3, [sp, #4]
 800252a:	2288      	movs	r2, #136	@ 0x88
 800252c:	589b      	ldr	r3, [r3, r2]
 800252e:	1e5a      	subs	r2, r3, #1
 8002530:	4193      	sbcs	r3, r2
 8002532:	b2db      	uxtb	r3, r3
 8002534:	2b00      	cmp	r3, #0
 8002536:	d108      	bne.n	800254a <chDbgCheckClassS+0x2a>
 8002538:	9b01      	ldr	r3, [sp, #4]
 800253a:	228c      	movs	r2, #140	@ 0x8c
 800253c:	589b      	ldr	r3, [r3, r2]
 800253e:	1e5a      	subs	r2, r3, #1
 8002540:	4313      	orrs	r3, r2
 8002542:	0fdb      	lsrs	r3, r3, #31
 8002544:	b2db      	uxtb	r3, r3
 8002546:	2b00      	cmp	r3, #0
 8002548:	d003      	beq.n	8002552 <chDbgCheckClassS+0x32>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 800254a:	4b04      	ldr	r3, [pc, #16]	@ (800255c <chDbgCheckClassS+0x3c>)
 800254c:	0018      	movs	r0, r3
 800254e:	f7ff fe57 	bl	8002200 <chSysHalt>
  }
}
 8002552:	46c0      	nop			@ (mov r8, r8)
 8002554:	b003      	add	sp, #12
 8002556:	bd00      	pop	{pc}
 8002558:	20000690 	.word	0x20000690
 800255c:	08005224 	.word	0x08005224

08002560 <port_lock.lto_priv.9>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002560:	b672      	cpsid	i
}
 8002562:	46c0      	nop			@ (mov r8, r8)
}
 8002564:	46c0      	nop			@ (mov r8, r8)
 8002566:	4770      	bx	lr
	...

08002570 <port_unlock.lto_priv.9>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002570:	b662      	cpsie	i
}
 8002572:	46c0      	nop			@ (mov r8, r8)
}
 8002574:	46c0      	nop			@ (mov r8, r8)
 8002576:	4770      	bx	lr
	...

08002580 <port_lock_from_isr.lto_priv.4>:
static inline void port_lock_from_isr(void) {
 8002580:	b510      	push	{r4, lr}
  port_lock();
 8002582:	f7ff ffed 	bl	8002560 <port_lock.lto_priv.9>
}
 8002586:	46c0      	nop			@ (mov r8, r8)
 8002588:	bd10      	pop	{r4, pc}
 800258a:	46c0      	nop			@ (mov r8, r8)
 800258c:	0000      	movs	r0, r0
	...

08002590 <port_unlock_from_isr.lto_priv.4>:
static inline void port_unlock_from_isr(void) {
 8002590:	b510      	push	{r4, lr}
  port_unlock();
 8002592:	f7ff ffed 	bl	8002570 <port_unlock.lto_priv.9>
}
 8002596:	46c0      	nop			@ (mov r8, r8)
 8002598:	bd10      	pop	{r4, pc}
 800259a:	46c0      	nop			@ (mov r8, r8)
 800259c:	0000      	movs	r0, r0
	...

080025a0 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80025a0:	b510      	push	{r4, lr}

  return stGetCounter();
 80025a2:	f7fd ff2d 	bl	8000400 <stGetCounter>
 80025a6:	0003      	movs	r3, r0
}
 80025a8:	0018      	movs	r0, r3
 80025aa:	bd10      	pop	{r4, pc}
 80025ac:	0000      	movs	r0, r0
	...

080025b0 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80025b0:	b510      	push	{r4, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80025b2:	f7ff fff5 	bl	80025a0 <port_timer_get_time.lto_priv.0>
 80025b6:	0003      	movs	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80025b8:	0018      	movs	r0, r3
 80025ba:	bd10      	pop	{r4, pc}
 80025bc:	0000      	movs	r0, r0
	...

080025c0 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {
 80025c0:	b510      	push	{r4, lr}
 80025c2:	b082      	sub	sp, #8
 80025c4:	9001      	str	r0, [sp, #4]

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80025c6:	9b01      	ldr	r3, [sp, #4]
 80025c8:	2294      	movs	r2, #148	@ 0x94
 80025ca:	589c      	ldr	r4, [r3, r2]
 80025cc:	f7ff fff0 	bl	80025b0 <chVTGetSystemTimeX.lto_priv.0>
 80025d0:	0003      	movs	r3, r0
 80025d2:	80a3      	strh	r3, [r4, #4]
#if PORT_SUPPORTS_RT == TRUE
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
#else
  oip->trace_buffer.ptr->rtstamp = (rtcnt_t)0;
 80025d4:	9b01      	ldr	r3, [sp, #4]
 80025d6:	2294      	movs	r2, #148	@ 0x94
 80025d8:	589b      	ldr	r3, [r3, r2]
 80025da:	681a      	ldr	r2, [r3, #0]
 80025dc:	21ff      	movs	r1, #255	@ 0xff
 80025de:	400a      	ands	r2, r1
 80025e0:	601a      	str	r2, [r3, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 80025e2:	9b01      	ldr	r3, [sp, #4]
 80025e4:	2294      	movs	r2, #148	@ 0x94
 80025e6:	589b      	ldr	r3, [r3, r2]
 80025e8:	3310      	adds	r3, #16
 80025ea:	001a      	movs	r2, r3
 80025ec:	9b01      	ldr	r3, [sp, #4]
 80025ee:	2194      	movs	r1, #148	@ 0x94
 80025f0:	505a      	str	r2, [r3, r1]
 80025f2:	9b01      	ldr	r3, [sp, #4]
 80025f4:	2294      	movs	r2, #148	@ 0x94
 80025f6:	589a      	ldr	r2, [r3, r2]
 80025f8:	9b01      	ldr	r3, [sp, #4]
 80025fa:	4907      	ldr	r1, [pc, #28]	@ (8002618 <trace_next+0x58>)
 80025fc:	468c      	mov	ip, r1
 80025fe:	4463      	add	r3, ip
 8002600:	429a      	cmp	r2, r3
 8002602:	d305      	bcc.n	8002610 <trace_next+0x50>
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8002604:	9b01      	ldr	r3, [sp, #4]
 8002606:	3398      	adds	r3, #152	@ 0x98
 8002608:	001a      	movs	r2, r3
 800260a:	9b01      	ldr	r3, [sp, #4]
 800260c:	2194      	movs	r1, #148	@ 0x94
 800260e:	505a      	str	r2, [r3, r1]
  }
}
 8002610:	46c0      	nop			@ (mov r8, r8)
 8002612:	b002      	add	sp, #8
 8002614:	bd10      	pop	{r4, pc}
 8002616:	46c0      	nop			@ (mov r8, r8)
 8002618:	00000898 	.word	0x00000898
 800261c:	00000000 	.word	0x00000000

08002620 <__trace_object_init>:
 *
 * @param[out] tbp      pointer to the @p trace_buffer_t structure
 *
 * @notapi
 */
void __trace_object_init(trace_buffer_t *tbp) {
 8002620:	b084      	sub	sp, #16
 8002622:	9001      	str	r0, [sp, #4]
  unsigned i;

  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8002624:	9b01      	ldr	r3, [sp, #4]
 8002626:	2220      	movs	r2, #32
 8002628:	4252      	negs	r2, r2
 800262a:	801a      	strh	r2, [r3, #0]
  tbp->size      = CH_DBG_TRACE_BUFFER_SIZE;
 800262c:	9b01      	ldr	r3, [sp, #4]
 800262e:	2280      	movs	r2, #128	@ 0x80
 8002630:	805a      	strh	r2, [r3, #2]
  tbp->ptr       = &tbp->buffer[0];
 8002632:	9b01      	ldr	r3, [sp, #4]
 8002634:	3308      	adds	r3, #8
 8002636:	001a      	movs	r2, r3
 8002638:	9b01      	ldr	r3, [sp, #4]
 800263a:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800263c:	2300      	movs	r3, #0
 800263e:	9303      	str	r3, [sp, #12]
 8002640:	e00c      	b.n	800265c <__trace_object_init+0x3c>
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8002642:	9a01      	ldr	r2, [sp, #4]
 8002644:	9b03      	ldr	r3, [sp, #12]
 8002646:	2108      	movs	r1, #8
 8002648:	011b      	lsls	r3, r3, #4
 800264a:	18d3      	adds	r3, r2, r3
 800264c:	185b      	adds	r3, r3, r1
 800264e:	781a      	ldrb	r2, [r3, #0]
 8002650:	2107      	movs	r1, #7
 8002652:	438a      	bics	r2, r1
 8002654:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002656:	9b03      	ldr	r3, [sp, #12]
 8002658:	3301      	adds	r3, #1
 800265a:	9303      	str	r3, [sp, #12]
 800265c:	9b03      	ldr	r3, [sp, #12]
 800265e:	2b7f      	cmp	r3, #127	@ 0x7f
 8002660:	d9ef      	bls.n	8002642 <__trace_object_init+0x22>
  }
}
 8002662:	46c0      	nop			@ (mov r8, r8)
 8002664:	46c0      	nop			@ (mov r8, r8)
 8002666:	b004      	add	sp, #16
 8002668:	4770      	bx	lr
 800266a:	46c0      	nop			@ (mov r8, r8)
 800266c:	0000      	movs	r0, r0
	...

08002670 <__trace_ready>:
 * @param[in] tp        the thread that just become ready
 * @param[in] msg       the thread ready message
 *
 * @notapi
 */
void __trace_ready(thread_t *tp, msg_t msg) {
 8002670:	b500      	push	{lr}
 8002672:	b085      	sub	sp, #20
 8002674:	9001      	str	r0, [sp, #4]
 8002676:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8002678:	4b1a      	ldr	r3, [pc, #104]	@ (80026e4 <__trace_ready+0x74>)
 800267a:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 800267c:	9b03      	ldr	r3, [sp, #12]
 800267e:	2290      	movs	r2, #144	@ 0x90
 8002680:	5a9b      	ldrh	r3, [r3, r2]
 8002682:	001a      	movs	r2, r3
 8002684:	2301      	movs	r3, #1
 8002686:	4013      	ands	r3, r2
 8002688:	d128      	bne.n	80026dc <__trace_ready+0x6c>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 800268a:	9b03      	ldr	r3, [sp, #12]
 800268c:	2294      	movs	r2, #148	@ 0x94
 800268e:	589b      	ldr	r3, [r3, r2]
 8002690:	781a      	ldrb	r2, [r3, #0]
 8002692:	2107      	movs	r1, #7
 8002694:	438a      	bics	r2, r1
 8002696:	1c11      	adds	r1, r2, #0
 8002698:	2201      	movs	r2, #1
 800269a:	430a      	orrs	r2, r1
 800269c:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)tp->state;
 800269e:	9b01      	ldr	r3, [sp, #4]
 80026a0:	2224      	movs	r2, #36	@ 0x24
 80026a2:	5c99      	ldrb	r1, [r3, r2]
 80026a4:	9b03      	ldr	r3, [sp, #12]
 80026a6:	2294      	movs	r2, #148	@ 0x94
 80026a8:	589b      	ldr	r3, [r3, r2]
 80026aa:	221f      	movs	r2, #31
 80026ac:	400a      	ands	r2, r1
 80026ae:	b2d2      	uxtb	r2, r2
 80026b0:	00d0      	lsls	r0, r2, #3
 80026b2:	781a      	ldrb	r2, [r3, #0]
 80026b4:	2107      	movs	r1, #7
 80026b6:	400a      	ands	r2, r1
 80026b8:	1c11      	adds	r1, r2, #0
 80026ba:	1c02      	adds	r2, r0, #0
 80026bc:	430a      	orrs	r2, r1
 80026be:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.rdy.tp    = tp;
 80026c0:	9b03      	ldr	r3, [sp, #12]
 80026c2:	2294      	movs	r2, #148	@ 0x94
 80026c4:	589b      	ldr	r3, [r3, r2]
 80026c6:	9a01      	ldr	r2, [sp, #4]
 80026c8:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 80026ca:	9b03      	ldr	r3, [sp, #12]
 80026cc:	2294      	movs	r2, #148	@ 0x94
 80026ce:	589b      	ldr	r3, [r3, r2]
 80026d0:	9a00      	ldr	r2, [sp, #0]
 80026d2:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 80026d4:	9b03      	ldr	r3, [sp, #12]
 80026d6:	0018      	movs	r0, r3
 80026d8:	f7ff ff72 	bl	80025c0 <trace_next>
  }
}
 80026dc:	46c0      	nop			@ (mov r8, r8)
 80026de:	b005      	add	sp, #20
 80026e0:	bd00      	pop	{pc}
 80026e2:	46c0      	nop			@ (mov r8, r8)
 80026e4:	20000690 	.word	0x20000690
	...

080026f0 <__trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void __trace_switch(thread_t *ntp, thread_t *otp) {
 80026f0:	b500      	push	{lr}
 80026f2:	b085      	sub	sp, #20
 80026f4:	9001      	str	r0, [sp, #4]
 80026f6:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 80026f8:	4b1a      	ldr	r3, [pc, #104]	@ (8002764 <__trace_switch+0x74>)
 80026fa:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80026fc:	9b03      	ldr	r3, [sp, #12]
 80026fe:	2290      	movs	r2, #144	@ 0x90
 8002700:	5a9b      	ldrh	r3, [r3, r2]
 8002702:	001a      	movs	r2, r3
 8002704:	2302      	movs	r3, #2
 8002706:	4013      	ands	r3, r2
 8002708:	d129      	bne.n	800275e <__trace_switch+0x6e>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800270a:	9b03      	ldr	r3, [sp, #12]
 800270c:	2294      	movs	r2, #148	@ 0x94
 800270e:	589b      	ldr	r3, [r3, r2]
 8002710:	781a      	ldrb	r2, [r3, #0]
 8002712:	2107      	movs	r1, #7
 8002714:	438a      	bics	r2, r1
 8002716:	1c11      	adds	r1, r2, #0
 8002718:	2202      	movs	r2, #2
 800271a:	430a      	orrs	r2, r1
 800271c:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)otp->state;
 800271e:	9b00      	ldr	r3, [sp, #0]
 8002720:	2224      	movs	r2, #36	@ 0x24
 8002722:	5c99      	ldrb	r1, [r3, r2]
 8002724:	9b03      	ldr	r3, [sp, #12]
 8002726:	2294      	movs	r2, #148	@ 0x94
 8002728:	589b      	ldr	r3, [r3, r2]
 800272a:	221f      	movs	r2, #31
 800272c:	400a      	ands	r2, r1
 800272e:	b2d2      	uxtb	r2, r2
 8002730:	00d0      	lsls	r0, r2, #3
 8002732:	781a      	ldrb	r2, [r3, #0]
 8002734:	2107      	movs	r1, #7
 8002736:	400a      	ands	r2, r1
 8002738:	1c11      	adds	r1, r2, #0
 800273a:	1c02      	adds	r2, r0, #0
 800273c:	430a      	orrs	r2, r1
 800273e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
 8002740:	9b03      	ldr	r3, [sp, #12]
 8002742:	2294      	movs	r2, #148	@ 0x94
 8002744:	589b      	ldr	r3, [r3, r2]
 8002746:	9a01      	ldr	r2, [sp, #4]
 8002748:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800274a:	9b03      	ldr	r3, [sp, #12]
 800274c:	2294      	movs	r2, #148	@ 0x94
 800274e:	589b      	ldr	r3, [r3, r2]
 8002750:	9a00      	ldr	r2, [sp, #0]
 8002752:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8002754:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 8002756:	9b03      	ldr	r3, [sp, #12]
 8002758:	0018      	movs	r0, r3
 800275a:	f7ff ff31 	bl	80025c0 <trace_next>
  }
}
 800275e:	46c0      	nop			@ (mov r8, r8)
 8002760:	b005      	add	sp, #20
 8002762:	bd00      	pop	{pc}
 8002764:	20000690 	.word	0x20000690
	...

08002770 <__trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_enter(const char *isr) {
 8002770:	b500      	push	{lr}
 8002772:	b085      	sub	sp, #20
 8002774:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 8002776:	4b15      	ldr	r3, [pc, #84]	@ (80027cc <__trace_isr_enter+0x5c>)
 8002778:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800277a:	9b03      	ldr	r3, [sp, #12]
 800277c:	2290      	movs	r2, #144	@ 0x90
 800277e:	5a9b      	ldrh	r3, [r3, r2]
 8002780:	001a      	movs	r2, r3
 8002782:	2304      	movs	r3, #4
 8002784:	4013      	ands	r3, r2
 8002786:	d11d      	bne.n	80027c4 <__trace_isr_enter+0x54>
    port_lock_from_isr();
 8002788:	f7ff fefa 	bl	8002580 <port_lock_from_isr.lto_priv.4>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800278c:	9b03      	ldr	r3, [sp, #12]
 800278e:	2294      	movs	r2, #148	@ 0x94
 8002790:	589b      	ldr	r3, [r3, r2]
 8002792:	781a      	ldrb	r2, [r3, #0]
 8002794:	2107      	movs	r1, #7
 8002796:	438a      	bics	r2, r1
 8002798:	1c11      	adds	r1, r2, #0
 800279a:	2203      	movs	r2, #3
 800279c:	430a      	orrs	r2, r1
 800279e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state       = 0U;
 80027a0:	9b03      	ldr	r3, [sp, #12]
 80027a2:	2294      	movs	r2, #148	@ 0x94
 80027a4:	589b      	ldr	r3, [r3, r2]
 80027a6:	781a      	ldrb	r2, [r3, #0]
 80027a8:	2107      	movs	r1, #7
 80027aa:	400a      	ands	r2, r1
 80027ac:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80027ae:	9b03      	ldr	r3, [sp, #12]
 80027b0:	2294      	movs	r2, #148	@ 0x94
 80027b2:	589b      	ldr	r3, [r3, r2]
 80027b4:	9a01      	ldr	r2, [sp, #4]
 80027b6:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80027b8:	9b03      	ldr	r3, [sp, #12]
 80027ba:	0018      	movs	r0, r3
 80027bc:	f7ff ff00 	bl	80025c0 <trace_next>
    port_unlock_from_isr();
 80027c0:	f7ff fee6 	bl	8002590 <port_unlock_from_isr.lto_priv.4>
  }
}
 80027c4:	46c0      	nop			@ (mov r8, r8)
 80027c6:	b005      	add	sp, #20
 80027c8:	bd00      	pop	{pc}
 80027ca:	46c0      	nop			@ (mov r8, r8)
 80027cc:	20000690 	.word	0x20000690

080027d0 <__trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_leave(const char *isr) {
 80027d0:	b500      	push	{lr}
 80027d2:	b085      	sub	sp, #20
 80027d4:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 80027d6:	4b15      	ldr	r3, [pc, #84]	@ (800282c <__trace_isr_leave+0x5c>)
 80027d8:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80027da:	9b03      	ldr	r3, [sp, #12]
 80027dc:	2290      	movs	r2, #144	@ 0x90
 80027de:	5a9b      	ldrh	r3, [r3, r2]
 80027e0:	001a      	movs	r2, r3
 80027e2:	2304      	movs	r3, #4
 80027e4:	4013      	ands	r3, r2
 80027e6:	d11d      	bne.n	8002824 <__trace_isr_leave+0x54>
    port_lock_from_isr();
 80027e8:	f7ff feca 	bl	8002580 <port_lock_from_isr.lto_priv.4>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80027ec:	9b03      	ldr	r3, [sp, #12]
 80027ee:	2294      	movs	r2, #148	@ 0x94
 80027f0:	589b      	ldr	r3, [r3, r2]
 80027f2:	781a      	ldrb	r2, [r3, #0]
 80027f4:	2107      	movs	r1, #7
 80027f6:	438a      	bics	r2, r1
 80027f8:	1c11      	adds	r1, r2, #0
 80027fa:	2204      	movs	r2, #4
 80027fc:	430a      	orrs	r2, r1
 80027fe:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state       = 0U;
 8002800:	9b03      	ldr	r3, [sp, #12]
 8002802:	2294      	movs	r2, #148	@ 0x94
 8002804:	589b      	ldr	r3, [r3, r2]
 8002806:	781a      	ldrb	r2, [r3, #0]
 8002808:	2107      	movs	r1, #7
 800280a:	400a      	ands	r2, r1
 800280c:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800280e:	9b03      	ldr	r3, [sp, #12]
 8002810:	2294      	movs	r2, #148	@ 0x94
 8002812:	589b      	ldr	r3, [r3, r2]
 8002814:	9a01      	ldr	r2, [sp, #4]
 8002816:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002818:	9b03      	ldr	r3, [sp, #12]
 800281a:	0018      	movs	r0, r3
 800281c:	f7ff fed0 	bl	80025c0 <trace_next>
    port_unlock_from_isr();
 8002820:	f7ff feb6 	bl	8002590 <port_unlock_from_isr.lto_priv.4>
  }
}
 8002824:	46c0      	nop			@ (mov r8, r8)
 8002826:	b005      	add	sp, #20
 8002828:	bd00      	pop	{pc}
 800282a:	46c0      	nop			@ (mov r8, r8)
 800282c:	20000690 	.word	0x20000690

08002830 <__trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void __trace_halt(const char *reason) {
 8002830:	b500      	push	{lr}
 8002832:	b085      	sub	sp, #20
 8002834:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 8002836:	4b13      	ldr	r3, [pc, #76]	@ (8002884 <__trace_halt+0x54>)
 8002838:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 800283a:	9b03      	ldr	r3, [sp, #12]
 800283c:	2290      	movs	r2, #144	@ 0x90
 800283e:	5a9b      	ldrh	r3, [r3, r2]
 8002840:	001a      	movs	r2, r3
 8002842:	2308      	movs	r3, #8
 8002844:	4013      	ands	r3, r2
 8002846:	d119      	bne.n	800287c <__trace_halt+0x4c>
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8002848:	9b03      	ldr	r3, [sp, #12]
 800284a:	2294      	movs	r2, #148	@ 0x94
 800284c:	589b      	ldr	r3, [r3, r2]
 800284e:	781a      	ldrb	r2, [r3, #0]
 8002850:	2107      	movs	r1, #7
 8002852:	438a      	bics	r2, r1
 8002854:	1c11      	adds	r1, r2, #0
 8002856:	2205      	movs	r2, #5
 8002858:	430a      	orrs	r2, r1
 800285a:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state         = 0;
 800285c:	9b03      	ldr	r3, [sp, #12]
 800285e:	2294      	movs	r2, #148	@ 0x94
 8002860:	589b      	ldr	r3, [r3, r2]
 8002862:	781a      	ldrb	r2, [r3, #0]
 8002864:	2107      	movs	r1, #7
 8002866:	400a      	ands	r2, r1
 8002868:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.halt.reason = reason;
 800286a:	9b03      	ldr	r3, [sp, #12]
 800286c:	2294      	movs	r2, #148	@ 0x94
 800286e:	589b      	ldr	r3, [r3, r2]
 8002870:	9a01      	ldr	r2, [sp, #4]
 8002872:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002874:	9b03      	ldr	r3, [sp, #12]
 8002876:	0018      	movs	r0, r3
 8002878:	f7ff fea2 	bl	80025c0 <trace_next>
  }
}
 800287c:	46c0      	nop			@ (mov r8, r8)
 800287e:	b005      	add	sp, #20
 8002880:	bd00      	pop	{pc}
 8002882:	46c0      	nop			@ (mov r8, r8)
 8002884:	20000690 	.word	0x20000690
	...

08002890 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8002890:	b500      	push	{lr}
 8002892:	b083      	sub	sp, #12
 8002894:	0002      	movs	r2, r0
 8002896:	9100      	str	r1, [sp, #0]
 8002898:	466b      	mov	r3, sp
 800289a:	3306      	adds	r3, #6
 800289c:	801a      	strh	r2, [r3, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 800289e:	9900      	ldr	r1, [sp, #0]
 80028a0:	2380      	movs	r3, #128	@ 0x80
 80028a2:	025a      	lsls	r2, r3, #9
 80028a4:	2300      	movs	r3, #0
 80028a6:	4291      	cmp	r1, r2
 80028a8:	415b      	adcs	r3, r3
 80028aa:	b2db      	uxtb	r3, r3
 80028ac:	2b00      	cmp	r3, #0
 80028ae:	d003      	beq.n	80028b8 <chTimeAddX+0x28>
 80028b0:	4b06      	ldr	r3, [pc, #24]	@ (80028cc <chTimeAddX+0x3c>)
 80028b2:	0018      	movs	r0, r3
 80028b4:	f7ff fca4 	bl	8002200 <chSysHalt>
#endif

  return systime + (systime_t)interval;
 80028b8:	9b00      	ldr	r3, [sp, #0]
 80028ba:	b29a      	uxth	r2, r3
 80028bc:	466b      	mov	r3, sp
 80028be:	3306      	adds	r3, #6
 80028c0:	881b      	ldrh	r3, [r3, #0]
 80028c2:	18d3      	adds	r3, r2, r3
 80028c4:	b29b      	uxth	r3, r3
}
 80028c6:	0018      	movs	r0, r3
 80028c8:	b003      	add	sp, #12
 80028ca:	bd00      	pop	{pc}
 80028cc:	08005294 	.word	0x08005294

080028d0 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 80028d0:	b082      	sub	sp, #8
 80028d2:	0002      	movs	r2, r0
 80028d4:	466b      	mov	r3, sp
 80028d6:	3306      	adds	r3, #6
 80028d8:	801a      	strh	r2, [r3, #0]
 80028da:	ab01      	add	r3, sp, #4
 80028dc:	1c0a      	adds	r2, r1, #0
 80028de:	801a      	strh	r2, [r3, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80028e0:	aa01      	add	r2, sp, #4
 80028e2:	466b      	mov	r3, sp
 80028e4:	3306      	adds	r3, #6
 80028e6:	8812      	ldrh	r2, [r2, #0]
 80028e8:	881b      	ldrh	r3, [r3, #0]
 80028ea:	1ad3      	subs	r3, r2, r3
 80028ec:	b29b      	uxth	r3, r3
  /*lint -restore*/
}
 80028ee:	0018      	movs	r0, r3
 80028f0:	b002      	add	sp, #8
 80028f2:	4770      	bx	lr
	...

08002900 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8002900:	b082      	sub	sp, #8
 8002902:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8002904:	9b01      	ldr	r3, [sp, #4]
 8002906:	681b      	ldr	r3, [r3, #0]
 8002908:	9a01      	ldr	r2, [sp, #4]
 800290a:	1ad3      	subs	r3, r2, r3
 800290c:	425a      	negs	r2, r3
 800290e:	4153      	adcs	r3, r2
 8002910:	b2db      	uxtb	r3, r3
}
 8002912:	0018      	movs	r0, r3
 8002914:	b002      	add	sp, #8
 8002916:	4770      	bx	lr
	...

08002920 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8002920:	b082      	sub	sp, #8
 8002922:	9001      	str	r0, [sp, #4]
 8002924:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8002926:	9b01      	ldr	r3, [sp, #4]
 8002928:	681b      	ldr	r3, [r3, #0]
 800292a:	9a00      	ldr	r2, [sp, #0]
 800292c:	1ad3      	subs	r3, r2, r3
 800292e:	425a      	negs	r2, r3
 8002930:	4153      	adcs	r3, r2
 8002932:	b2db      	uxtb	r3, r3
}
 8002934:	0018      	movs	r0, r3
 8002936:	b002      	add	sp, #8
 8002938:	4770      	bx	lr
 800293a:	46c0      	nop			@ (mov r8, r8)
 800293c:	0000      	movs	r0, r0
	...

08002940 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 8002940:	b084      	sub	sp, #16
 8002942:	9003      	str	r0, [sp, #12]
 8002944:	9102      	str	r1, [sp, #8]
 8002946:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002948:	9b02      	ldr	r3, [sp, #8]
 800294a:	9a01      	ldr	r2, [sp, #4]
 800294c:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 800294e:	9b02      	ldr	r3, [sp, #8]
 8002950:	9a03      	ldr	r2, [sp, #12]
 8002952:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8002954:	9b02      	ldr	r3, [sp, #8]
 8002956:	685b      	ldr	r3, [r3, #4]
 8002958:	681a      	ldr	r2, [r3, #0]
 800295a:	9b02      	ldr	r3, [sp, #8]
 800295c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 800295e:	9b02      	ldr	r3, [sp, #8]
 8002960:	681b      	ldr	r3, [r3, #0]
 8002962:	9a02      	ldr	r2, [sp, #8]
 8002964:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 8002966:	9b03      	ldr	r3, [sp, #12]
 8002968:	9a02      	ldr	r2, [sp, #8]
 800296a:	601a      	str	r2, [r3, #0]
}
 800296c:	46c0      	nop			@ (mov r8, r8)
 800296e:	b004      	add	sp, #16
 8002970:	4770      	bx	lr
 8002972:	46c0      	nop			@ (mov r8, r8)
	...

08002980 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 8002980:	b084      	sub	sp, #16
 8002982:	9003      	str	r0, [sp, #12]
 8002984:	9102      	str	r1, [sp, #8]
 8002986:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002988:	9b02      	ldr	r3, [sp, #8]
 800298a:	9a01      	ldr	r2, [sp, #4]
 800298c:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 800298e:	9b02      	ldr	r3, [sp, #8]
 8002990:	9a03      	ldr	r2, [sp, #12]
 8002992:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8002994:	9b02      	ldr	r3, [sp, #8]
 8002996:	681b      	ldr	r3, [r3, #0]
 8002998:	685a      	ldr	r2, [r3, #4]
 800299a:	9b02      	ldr	r3, [sp, #8]
 800299c:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 800299e:	9b02      	ldr	r3, [sp, #8]
 80029a0:	685b      	ldr	r3, [r3, #4]
 80029a2:	9a02      	ldr	r2, [sp, #8]
 80029a4:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 80029a6:	9b03      	ldr	r3, [sp, #12]
 80029a8:	9a02      	ldr	r2, [sp, #8]
 80029aa:	605a      	str	r2, [r3, #4]
}
 80029ac:	46c0      	nop			@ (mov r8, r8)
 80029ae:	b004      	add	sp, #16
 80029b0:	4770      	bx	lr
 80029b2:	46c0      	nop			@ (mov r8, r8)
	...

080029c0 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 80029c0:	b500      	push	{lr}
 80029c2:	b087      	sub	sp, #28
 80029c4:	9003      	str	r0, [sp, #12]
 80029c6:	9102      	str	r1, [sp, #8]
 80029c8:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 80029ca:	9b03      	ldr	r3, [sp, #12]
 80029cc:	681b      	ldr	r3, [r3, #0]
 80029ce:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 80029d0:	e013      	b.n	80029fa <ch_dlist_insert+0x3a>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 80029d2:	9a05      	ldr	r2, [sp, #20]
 80029d4:	9b02      	ldr	r3, [sp, #8]
 80029d6:	1ad3      	subs	r3, r2, r3
 80029d8:	425a      	negs	r2, r3
 80029da:	4153      	adcs	r3, r2
 80029dc:	b2db      	uxtb	r3, r3
 80029de:	2b00      	cmp	r3, #0
 80029e0:	d003      	beq.n	80029ea <ch_dlist_insert+0x2a>
 80029e2:	4b14      	ldr	r3, [pc, #80]	@ (8002a34 <ch_dlist_insert+0x74>)
 80029e4:	0018      	movs	r0, r3
 80029e6:	f7ff fc0b 	bl	8002200 <chSysHalt>

    delta -= dlp->delta;
 80029ea:	9b05      	ldr	r3, [sp, #20]
 80029ec:	689b      	ldr	r3, [r3, #8]
 80029ee:	9a01      	ldr	r2, [sp, #4]
 80029f0:	1ad3      	subs	r3, r2, r3
 80029f2:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 80029f4:	9b05      	ldr	r3, [sp, #20]
 80029f6:	681b      	ldr	r3, [r3, #0]
 80029f8:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 80029fa:	9b05      	ldr	r3, [sp, #20]
 80029fc:	689a      	ldr	r2, [r3, #8]
 80029fe:	9b01      	ldr	r3, [sp, #4]
 8002a00:	429a      	cmp	r2, r3
 8002a02:	419b      	sbcs	r3, r3
 8002a04:	425b      	negs	r3, r3
 8002a06:	b2db      	uxtb	r3, r3
 8002a08:	2b00      	cmp	r3, #0
 8002a0a:	d1e2      	bne.n	80029d2 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 8002a0c:	9a01      	ldr	r2, [sp, #4]
 8002a0e:	9902      	ldr	r1, [sp, #8]
 8002a10:	9b05      	ldr	r3, [sp, #20]
 8002a12:	0018      	movs	r0, r3
 8002a14:	f7ff ffb4 	bl	8002980 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8002a18:	9b05      	ldr	r3, [sp, #20]
 8002a1a:	689a      	ldr	r2, [r3, #8]
 8002a1c:	9b01      	ldr	r3, [sp, #4]
 8002a1e:	1ad2      	subs	r2, r2, r3
 8002a20:	9b05      	ldr	r3, [sp, #20]
 8002a22:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8002a24:	9b03      	ldr	r3, [sp, #12]
 8002a26:	2201      	movs	r2, #1
 8002a28:	4252      	negs	r2, r2
 8002a2a:	609a      	str	r2, [r3, #8]
}
 8002a2c:	46c0      	nop			@ (mov r8, r8)
 8002a2e:	b007      	add	sp, #28
 8002a30:	bd00      	pop	{pc}
 8002a32:	46c0      	nop			@ (mov r8, r8)
 8002a34:	080052a0 	.word	0x080052a0
	...

08002a40 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8002a40:	b084      	sub	sp, #16
 8002a42:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8002a44:	9b01      	ldr	r3, [sp, #4]
 8002a46:	681b      	ldr	r3, [r3, #0]
 8002a48:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 8002a4a:	9b03      	ldr	r3, [sp, #12]
 8002a4c:	681a      	ldr	r2, [r3, #0]
 8002a4e:	9b01      	ldr	r3, [sp, #4]
 8002a50:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8002a52:	9b01      	ldr	r3, [sp, #4]
 8002a54:	681b      	ldr	r3, [r3, #0]
 8002a56:	9a01      	ldr	r2, [sp, #4]
 8002a58:	605a      	str	r2, [r3, #4]

  return dlp;
 8002a5a:	9b03      	ldr	r3, [sp, #12]
}
 8002a5c:	0018      	movs	r0, r3
 8002a5e:	b004      	add	sp, #16
 8002a60:	4770      	bx	lr
 8002a62:	46c0      	nop			@ (mov r8, r8)
	...

08002a70 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 8002a70:	b082      	sub	sp, #8
 8002a72:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 8002a74:	9b01      	ldr	r3, [sp, #4]
 8002a76:	685b      	ldr	r3, [r3, #4]
 8002a78:	9a01      	ldr	r2, [sp, #4]
 8002a7a:	6812      	ldr	r2, [r2, #0]
 8002a7c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 8002a7e:	9b01      	ldr	r3, [sp, #4]
 8002a80:	681b      	ldr	r3, [r3, #0]
 8002a82:	9a01      	ldr	r2, [sp, #4]
 8002a84:	6852      	ldr	r2, [r2, #4]
 8002a86:	605a      	str	r2, [r3, #4]

  return dlp;
 8002a88:	9b01      	ldr	r3, [sp, #4]
}
 8002a8a:	0018      	movs	r0, r3
 8002a8c:	b002      	add	sp, #8
 8002a8e:	4770      	bx	lr

08002a90 <port_lock.lto_priv.10>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002a90:	b672      	cpsid	i
}
 8002a92:	46c0      	nop			@ (mov r8, r8)
}
 8002a94:	46c0      	nop			@ (mov r8, r8)
 8002a96:	4770      	bx	lr
	...

08002aa0 <port_unlock.lto_priv.10>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002aa0:	b662      	cpsie	i
}
 8002aa2:	46c0      	nop			@ (mov r8, r8)
}
 8002aa4:	46c0      	nop			@ (mov r8, r8)
 8002aa6:	4770      	bx	lr
	...

08002ab0 <port_lock_from_isr.lto_priv.5>:
static inline void port_lock_from_isr(void) {
 8002ab0:	b510      	push	{r4, lr}
  port_lock();
 8002ab2:	f7ff ffed 	bl	8002a90 <port_lock.lto_priv.10>
}
 8002ab6:	46c0      	nop			@ (mov r8, r8)
 8002ab8:	bd10      	pop	{r4, pc}
 8002aba:	46c0      	nop			@ (mov r8, r8)
 8002abc:	0000      	movs	r0, r0
	...

08002ac0 <port_unlock_from_isr.lto_priv.5>:
static inline void port_unlock_from_isr(void) {
 8002ac0:	b510      	push	{r4, lr}
  port_unlock();
 8002ac2:	f7ff ffed 	bl	8002aa0 <port_unlock.lto_priv.10>
}
 8002ac6:	46c0      	nop			@ (mov r8, r8)
 8002ac8:	bd10      	pop	{r4, pc}
 8002aca:	46c0      	nop			@ (mov r8, r8)
 8002acc:	0000      	movs	r0, r0
	...

08002ad0 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 8002ad0:	b500      	push	{lr}
 8002ad2:	b083      	sub	sp, #12
 8002ad4:	0002      	movs	r2, r0
 8002ad6:	466b      	mov	r3, sp
 8002ad8:	3306      	adds	r3, #6
 8002ada:	801a      	strh	r2, [r3, #0]
  stStartAlarm(time);
 8002adc:	466b      	mov	r3, sp
 8002ade:	3306      	adds	r3, #6
 8002ae0:	881b      	ldrh	r3, [r3, #0]
 8002ae2:	0018      	movs	r0, r3
 8002ae4:	f7fd fc94 	bl	8000410 <stStartAlarm>
}
 8002ae8:	46c0      	nop			@ (mov r8, r8)
 8002aea:	b003      	add	sp, #12
 8002aec:	bd00      	pop	{pc}
 8002aee:	46c0      	nop			@ (mov r8, r8)

08002af0 <port_timer_stop_alarm>:
static inline void port_timer_stop_alarm(void) {
 8002af0:	b510      	push	{r4, lr}
  stStopAlarm();
 8002af2:	f7fd fcad 	bl	8000450 <stStopAlarm>
}
 8002af6:	46c0      	nop			@ (mov r8, r8)
 8002af8:	bd10      	pop	{r4, pc}
 8002afa:	46c0      	nop			@ (mov r8, r8)
 8002afc:	0000      	movs	r0, r0
	...

08002b00 <port_timer_set_alarm>:
static inline void port_timer_set_alarm(systime_t time) {
 8002b00:	b500      	push	{lr}
 8002b02:	b083      	sub	sp, #12
 8002b04:	0002      	movs	r2, r0
 8002b06:	466b      	mov	r3, sp
 8002b08:	3306      	adds	r3, #6
 8002b0a:	801a      	strh	r2, [r3, #0]
  stSetAlarm(time);
 8002b0c:	466b      	mov	r3, sp
 8002b0e:	3306      	adds	r3, #6
 8002b10:	881b      	ldrh	r3, [r3, #0]
 8002b12:	0018      	movs	r0, r3
 8002b14:	f7fd fca4 	bl	8000460 <stSetAlarm>
}
 8002b18:	46c0      	nop			@ (mov r8, r8)
 8002b1a:	b003      	add	sp, #12
 8002b1c:	bd00      	pop	{pc}
 8002b1e:	46c0      	nop			@ (mov r8, r8)

08002b20 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 8002b20:	b510      	push	{r4, lr}
  return stGetCounter();
 8002b22:	f7fd fc6d 	bl	8000400 <stGetCounter>
 8002b26:	0003      	movs	r3, r0
}
 8002b28:	0018      	movs	r0, r3
 8002b2a:	bd10      	pop	{r4, pc}
 8002b2c:	0000      	movs	r0, r0
	...

08002b30 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 8002b30:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8002b32:	f7ff ffbd 	bl	8002ab0 <port_lock_from_isr.lto_priv.5>
  __dbg_check_lock_from_isr();
 8002b36:	f7ff fc23 	bl	8002380 <__dbg_check_lock_from_isr>
}
 8002b3a:	46c0      	nop			@ (mov r8, r8)
 8002b3c:	bd10      	pop	{r4, pc}
 8002b3e:	46c0      	nop			@ (mov r8, r8)

08002b40 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
 8002b40:	b510      	push	{r4, lr}
  __dbg_check_unlock_from_isr();
 8002b42:	f7ff fc45 	bl	80023d0 <__dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8002b46:	f7ff ffbb 	bl	8002ac0 <port_unlock_from_isr.lto_priv.5>
}
 8002b4a:	46c0      	nop			@ (mov r8, r8)
 8002b4c:	bd10      	pop	{r4, pc}
 8002b4e:	46c0      	nop			@ (mov r8, r8)

08002b50 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 8002b50:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8002b52:	f7ff ffe5 	bl	8002b20 <port_timer_get_time.lto_priv.1>
 8002b56:	0003      	movs	r3, r0
}
 8002b58:	0018      	movs	r0, r3
 8002b5a:	bd10      	pop	{r4, pc}
 8002b5c:	0000      	movs	r0, r0
	...

08002b60 <chVTIsArmedI.lto_priv.0>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8002b60:	b500      	push	{lr}
 8002b62:	b083      	sub	sp, #12
 8002b64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002b66:	f7ff fcbb 	bl	80024e0 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 8002b6a:	9b01      	ldr	r3, [sp, #4]
 8002b6c:	681b      	ldr	r3, [r3, #0]
 8002b6e:	1e5a      	subs	r2, r3, #1
 8002b70:	4193      	sbcs	r3, r2
 8002b72:	b2db      	uxtb	r3, r3
}
 8002b74:	0018      	movs	r0, r3
 8002b76:	b003      	add	sp, #12
 8002b78:	bd00      	pop	{pc}
 8002b7a:	46c0      	nop			@ (mov r8, r8)
 8002b7c:	0000      	movs	r0, r0
	...

08002b80 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 8002b80:	b510      	push	{r4, lr}
 8002b82:	b086      	sub	sp, #24
 8002b84:	0002      	movs	r2, r0
 8002b86:	9100      	str	r1, [sp, #0]
 8002b88:	466b      	mov	r3, sp
 8002b8a:	3306      	adds	r3, #6
 8002b8c:	801a      	strh	r2, [r3, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002b8e:	2302      	movs	r3, #2
 8002b90:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 8002b92:	9a00      	ldr	r2, [sp, #0]
 8002b94:	9b05      	ldr	r3, [sp, #20]
 8002b96:	429a      	cmp	r2, r3
 8002b98:	d202      	bcs.n	8002ba0 <vt_set_alarm+0x20>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002b9a:	9b05      	ldr	r3, [sp, #20]
 8002b9c:	9300      	str	r3, [sp, #0]
 8002b9e:	e007      	b.n	8002bb0 <vt_set_alarm+0x30>
  }
#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
  else if (delay > VT_MAX_DELAY) {
 8002ba0:	9a00      	ldr	r2, [sp, #0]
 8002ba2:	23ff      	movs	r3, #255	@ 0xff
 8002ba4:	021b      	lsls	r3, r3, #8
 8002ba6:	429a      	cmp	r2, r3
 8002ba8:	d902      	bls.n	8002bb0 <vt_set_alarm+0x30>
    /* The delta could be too large for the physical timer to handle
       this can happen when: sizeof (systime_t) < sizeof (sysinterval_t).*/
    delay = VT_MAX_DELAY;
 8002baa:	23ff      	movs	r3, #255	@ 0xff
 8002bac:	021b      	lsls	r3, r3, #8
 8002bae:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 8002bb0:	9a00      	ldr	r2, [sp, #0]
 8002bb2:	466b      	mov	r3, sp
 8002bb4:	3306      	adds	r3, #6
 8002bb6:	881b      	ldrh	r3, [r3, #0]
 8002bb8:	0011      	movs	r1, r2
 8002bba:	0018      	movs	r0, r3
 8002bbc:	f7ff fe68 	bl	8002890 <chTimeAddX>
 8002bc0:	0003      	movs	r3, r0
 8002bc2:	0018      	movs	r0, r3
 8002bc4:	f7ff ff9c 	bl	8002b00 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002bc8:	2412      	movs	r4, #18
 8002bca:	446c      	add	r4, sp
 8002bcc:	f7ff ffc0 	bl	8002b50 <chVTGetSystemTimeX.lto_priv.1>
 8002bd0:	0003      	movs	r3, r0
 8002bd2:	8023      	strh	r3, [r4, #0]
    nowdelta = chTimeDiffX(now, newnow);
 8002bd4:	2312      	movs	r3, #18
 8002bd6:	446b      	add	r3, sp
 8002bd8:	881a      	ldrh	r2, [r3, #0]
 8002bda:	466b      	mov	r3, sp
 8002bdc:	3306      	adds	r3, #6
 8002bde:	881b      	ldrh	r3, [r3, #0]
 8002be0:	0011      	movs	r1, r2
 8002be2:	0018      	movs	r0, r3
 8002be4:	f7ff fe74 	bl	80028d0 <chTimeDiffX.lto_priv.0>
 8002be8:	0003      	movs	r3, r0
 8002bea:	9303      	str	r3, [sp, #12]
    if (likely(nowdelta < delay)) {
 8002bec:	9a03      	ldr	r2, [sp, #12]
 8002bee:	9b00      	ldr	r3, [sp, #0]
 8002bf0:	429a      	cmp	r2, r3
 8002bf2:	419b      	sbcs	r3, r3
 8002bf4:	425b      	negs	r3, r3
 8002bf6:	b2db      	uxtb	r3, r3
 8002bf8:	2b00      	cmp	r3, #0
 8002bfa:	d10b      	bne.n	8002c14 <vt_set_alarm+0x94>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002bfc:	9b05      	ldr	r3, [sp, #20]
 8002bfe:	3301      	adds	r3, #1
 8002c00:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002c02:	466b      	mov	r3, sp
 8002c04:	3306      	adds	r3, #6
 8002c06:	2212      	movs	r2, #18
 8002c08:	446a      	add	r2, sp
 8002c0a:	8812      	ldrh	r2, [r2, #0]
 8002c0c:	801a      	strh	r2, [r3, #0]
    delay = currdelta;
 8002c0e:	9b05      	ldr	r3, [sp, #20]
 8002c10:	9300      	str	r3, [sp, #0]
  while (true) {
 8002c12:	e7cd      	b.n	8002bb0 <vt_set_alarm+0x30>
      break;
 8002c14:	46c0      	nop			@ (mov r8, r8)
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002c16:	9b05      	ldr	r3, [sp, #20]
 8002c18:	2b02      	cmp	r3, #2
 8002c1a:	d902      	bls.n	8002c22 <vt_set_alarm+0xa2>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002c1c:	2001      	movs	r0, #1
 8002c1e:	f7ff fb2f 	bl	8002280 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002c22:	46c0      	nop			@ (mov r8, r8)
 8002c24:	b006      	add	sp, #24
 8002c26:	bd10      	pop	{r4, pc}
	...

08002c30 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8002c30:	b510      	push	{r4, lr}
 8002c32:	b086      	sub	sp, #24
 8002c34:	9003      	str	r0, [sp, #12]
 8002c36:	9102      	str	r1, [sp, #8]
 8002c38:	9300      	str	r3, [sp, #0]
 8002c3a:	466b      	mov	r3, sp
 8002c3c:	3306      	adds	r3, #6
 8002c3e:	801a      	strh	r2, [r3, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8002c40:	9b03      	ldr	r3, [sp, #12]
 8002c42:	466a      	mov	r2, sp
 8002c44:	3206      	adds	r2, #6
 8002c46:	8812      	ldrh	r2, [r2, #0]
 8002c48:	819a      	strh	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8002c4a:	9b03      	ldr	r3, [sp, #12]
 8002c4c:	9902      	ldr	r1, [sp, #8]
 8002c4e:	9a00      	ldr	r2, [sp, #0]
 8002c50:	0018      	movs	r0, r3
 8002c52:	f7ff fe75 	bl	8002940 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002c56:	2302      	movs	r3, #2
 8002c58:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8002c5a:	9a00      	ldr	r2, [sp, #0]
 8002c5c:	9b05      	ldr	r3, [sp, #20]
 8002c5e:	429a      	cmp	r2, r3
 8002c60:	d202      	bcs.n	8002c68 <vt_insert_first+0x38>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002c62:	9b05      	ldr	r3, [sp, #20]
 8002c64:	9300      	str	r3, [sp, #0]
 8002c66:	e007      	b.n	8002c78 <vt_insert_first+0x48>
  }
#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
  else if (delay > VT_MAX_DELAY) {
 8002c68:	9a00      	ldr	r2, [sp, #0]
 8002c6a:	23ff      	movs	r3, #255	@ 0xff
 8002c6c:	021b      	lsls	r3, r3, #8
 8002c6e:	429a      	cmp	r2, r3
 8002c70:	d902      	bls.n	8002c78 <vt_insert_first+0x48>
    /* The delta could be too large for the physical timer to handle
       this can happen when: sizeof (systime_t) < sizeof (sysinterval_t).*/
    delay = VT_MAX_DELAY;
 8002c72:	23ff      	movs	r3, #255	@ 0xff
 8002c74:	021b      	lsls	r3, r3, #8
 8002c76:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 8002c78:	9b03      	ldr	r3, [sp, #12]
 8002c7a:	899b      	ldrh	r3, [r3, #12]
 8002c7c:	9a00      	ldr	r2, [sp, #0]
 8002c7e:	0011      	movs	r1, r2
 8002c80:	0018      	movs	r0, r3
 8002c82:	f7ff fe05 	bl	8002890 <chTimeAddX>
 8002c86:	0003      	movs	r3, r0
 8002c88:	0018      	movs	r0, r3
 8002c8a:	f7ff ff21 	bl	8002ad0 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002c8e:	2412      	movs	r4, #18
 8002c90:	446c      	add	r4, sp
 8002c92:	f7ff ff5d 	bl	8002b50 <chVTGetSystemTimeX.lto_priv.1>
 8002c96:	0003      	movs	r3, r0
 8002c98:	8023      	strh	r3, [r4, #0]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8002c9a:	2312      	movs	r3, #18
 8002c9c:	446b      	add	r3, sp
 8002c9e:	881a      	ldrh	r2, [r3, #0]
 8002ca0:	466b      	mov	r3, sp
 8002ca2:	3306      	adds	r3, #6
 8002ca4:	881b      	ldrh	r3, [r3, #0]
 8002ca6:	0011      	movs	r1, r2
 8002ca8:	0018      	movs	r0, r3
 8002caa:	f7ff fe11 	bl	80028d0 <chTimeDiffX.lto_priv.0>
 8002cae:	0002      	movs	r2, r0
 8002cb0:	9b00      	ldr	r3, [sp, #0]
 8002cb2:	429a      	cmp	r2, r3
 8002cb4:	419b      	sbcs	r3, r3
 8002cb6:	425b      	negs	r3, r3
 8002cb8:	b2db      	uxtb	r3, r3
 8002cba:	2b00      	cmp	r3, #0
 8002cbc:	d117      	bne.n	8002cee <vt_insert_first+0xbe>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002cbe:	9b05      	ldr	r3, [sp, #20]
 8002cc0:	3301      	adds	r3, #1
 8002cc2:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8002cc4:	9a05      	ldr	r2, [sp, #20]
 8002cc6:	466b      	mov	r3, sp
 8002cc8:	3306      	adds	r3, #6
 8002cca:	881b      	ldrh	r3, [r3, #0]
 8002ccc:	0011      	movs	r1, r2
 8002cce:	0018      	movs	r0, r3
 8002cd0:	f7ff fdde 	bl	8002890 <chTimeAddX>
 8002cd4:	0003      	movs	r3, r0
 8002cd6:	0018      	movs	r0, r3
 8002cd8:	f7ff ff12 	bl	8002b00 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002cdc:	466b      	mov	r3, sp
 8002cde:	3306      	adds	r3, #6
 8002ce0:	2212      	movs	r2, #18
 8002ce2:	446a      	add	r2, sp
 8002ce4:	8812      	ldrh	r2, [r2, #0]
 8002ce6:	801a      	strh	r2, [r3, #0]
    delay = currdelta;
 8002ce8:	9b05      	ldr	r3, [sp, #20]
 8002cea:	9300      	str	r3, [sp, #0]
  while (true) {
 8002cec:	e7cf      	b.n	8002c8e <vt_insert_first+0x5e>
      break;
 8002cee:	46c0      	nop			@ (mov r8, r8)
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002cf0:	9b05      	ldr	r3, [sp, #20]
 8002cf2:	2b02      	cmp	r3, #2
 8002cf4:	d902      	bls.n	8002cfc <vt_insert_first+0xcc>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002cf6:	2001      	movs	r0, #1
 8002cf8:	f7ff fac2 	bl	8002280 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002cfc:	46c0      	nop			@ (mov r8, r8)
 8002cfe:	b006      	add	sp, #24
 8002d00:	bd10      	pop	{r4, pc}
 8002d02:	46c0      	nop			@ (mov r8, r8)
	...

08002d10 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 8002d10:	b510      	push	{r4, lr}
 8002d12:	b088      	sub	sp, #32
 8002d14:	9003      	str	r0, [sp, #12]
 8002d16:	9102      	str	r1, [sp, #8]
 8002d18:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 8002d1a:	241a      	movs	r4, #26
 8002d1c:	446c      	add	r4, sp
 8002d1e:	f7ff ff17 	bl	8002b50 <chVTGetSystemTimeX.lto_priv.1>
 8002d22:	0003      	movs	r3, r0
 8002d24:	8023      	strh	r3, [r4, #0]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002d26:	9b03      	ldr	r3, [sp, #12]
 8002d28:	0018      	movs	r0, r3
 8002d2a:	f7ff fde9 	bl	8002900 <ch_dlist_isempty>
 8002d2e:	1e03      	subs	r3, r0, #0
 8002d30:	d009      	beq.n	8002d46 <vt_enqueue+0x36>

      vt_insert_first(vtlp, vtp, now, delay);
 8002d32:	9c01      	ldr	r4, [sp, #4]
 8002d34:	231a      	movs	r3, #26
 8002d36:	446b      	add	r3, sp
 8002d38:	881a      	ldrh	r2, [r3, #0]
 8002d3a:	9902      	ldr	r1, [sp, #8]
 8002d3c:	9803      	ldr	r0, [sp, #12]
 8002d3e:	0023      	movs	r3, r4
 8002d40:	f7ff ff76 	bl	8002c30 <vt_insert_first>

      return;
 8002d44:	e028      	b.n	8002d98 <vt_enqueue+0x88>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002d46:	9b03      	ldr	r3, [sp, #12]
 8002d48:	899a      	ldrh	r2, [r3, #12]
 8002d4a:	231a      	movs	r3, #26
 8002d4c:	446b      	add	r3, sp
 8002d4e:	881b      	ldrh	r3, [r3, #0]
 8002d50:	0019      	movs	r1, r3
 8002d52:	0010      	movs	r0, r2
 8002d54:	f7ff fdbc 	bl	80028d0 <chTimeDiffX.lto_priv.0>
 8002d58:	0003      	movs	r3, r0
 8002d5a:	9305      	str	r3, [sp, #20]
    delta    = nowdelta + delay;
 8002d5c:	9a05      	ldr	r2, [sp, #20]
 8002d5e:	9b01      	ldr	r3, [sp, #4]
 8002d60:	18d3      	adds	r3, r2, r3
 8002d62:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 8002d64:	9a07      	ldr	r2, [sp, #28]
 8002d66:	9b05      	ldr	r3, [sp, #20]
 8002d68:	429a      	cmp	r2, r3
 8002d6a:	d201      	bcs.n	8002d70 <vt_enqueue+0x60>
      delta = delay;
 8002d6c:	9b01      	ldr	r3, [sp, #4]
 8002d6e:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8002d70:	9b03      	ldr	r3, [sp, #12]
 8002d72:	681b      	ldr	r3, [r3, #0]
 8002d74:	689b      	ldr	r3, [r3, #8]
 8002d76:	9a07      	ldr	r2, [sp, #28]
 8002d78:	429a      	cmp	r2, r3
 8002d7a:	d207      	bcs.n	8002d8c <vt_enqueue+0x7c>

      vt_set_alarm(now, delay);
 8002d7c:	9a01      	ldr	r2, [sp, #4]
 8002d7e:	231a      	movs	r3, #26
 8002d80:	446b      	add	r3, sp
 8002d82:	881b      	ldrh	r3, [r3, #0]
 8002d84:	0011      	movs	r1, r2
 8002d86:	0018      	movs	r0, r3
 8002d88:	f7ff fefa 	bl	8002b80 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8002d8c:	9b03      	ldr	r3, [sp, #12]
 8002d8e:	9902      	ldr	r1, [sp, #8]
 8002d90:	9a07      	ldr	r2, [sp, #28]
 8002d92:	0018      	movs	r0, r3
 8002d94:	f7ff fe14 	bl	80029c0 <ch_dlist_insert>
}
 8002d98:	b008      	add	sp, #32
 8002d9a:	bd10      	pop	{r4, pc}
 8002d9c:	0000      	movs	r0, r0
	...

08002da0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8002da0:	b500      	push	{lr}
 8002da2:	b087      	sub	sp, #28
 8002da4:	9003      	str	r0, [sp, #12]
 8002da6:	9102      	str	r1, [sp, #8]
 8002da8:	9201      	str	r2, [sp, #4]
 8002daa:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002dac:	4b18      	ldr	r3, [pc, #96]	@ (8002e10 <chVTDoSetI+0x70>)
 8002dae:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002db0:	f7ff fb96 	bl	80024e0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002db4:	9b03      	ldr	r3, [sp, #12]
 8002db6:	425a      	negs	r2, r3
 8002db8:	4153      	adcs	r3, r2
 8002dba:	b2db      	uxtb	r3, r3
 8002dbc:	2b00      	cmp	r3, #0
 8002dbe:	d105      	bne.n	8002dcc <chVTDoSetI+0x2c>
 8002dc0:	9b01      	ldr	r3, [sp, #4]
 8002dc2:	425a      	negs	r2, r3
 8002dc4:	4153      	adcs	r3, r2
 8002dc6:	b2db      	uxtb	r3, r3
 8002dc8:	2b00      	cmp	r3, #0
 8002dca:	d001      	beq.n	8002dd0 <chVTDoSetI+0x30>
 8002dcc:	2301      	movs	r3, #1
 8002dce:	e000      	b.n	8002dd2 <chVTDoSetI+0x32>
 8002dd0:	2300      	movs	r3, #0
 8002dd2:	2b00      	cmp	r3, #0
 8002dd4:	d105      	bne.n	8002de2 <chVTDoSetI+0x42>
 8002dd6:	9b02      	ldr	r3, [sp, #8]
 8002dd8:	425a      	negs	r2, r3
 8002dda:	4153      	adcs	r3, r2
 8002ddc:	b2db      	uxtb	r3, r3
 8002dde:	2b00      	cmp	r3, #0
 8002de0:	d003      	beq.n	8002dea <chVTDoSetI+0x4a>
 8002de2:	4b0c      	ldr	r3, [pc, #48]	@ (8002e14 <chVTDoSetI+0x74>)
 8002de4:	0018      	movs	r0, r3
 8002de6:	f7ff fa0b 	bl	8002200 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8002dea:	9b03      	ldr	r3, [sp, #12]
 8002dec:	9a00      	ldr	r2, [sp, #0]
 8002dee:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 8002df0:	9b03      	ldr	r3, [sp, #12]
 8002df2:	9a01      	ldr	r2, [sp, #4]
 8002df4:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8002df6:	9b03      	ldr	r3, [sp, #12]
 8002df8:	2200      	movs	r2, #0
 8002dfa:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8002dfc:	9a02      	ldr	r2, [sp, #8]
 8002dfe:	9903      	ldr	r1, [sp, #12]
 8002e00:	9b05      	ldr	r3, [sp, #20]
 8002e02:	0018      	movs	r0, r3
 8002e04:	f7ff ff84 	bl	8002d10 <vt_enqueue>
}
 8002e08:	46c0      	nop			@ (mov r8, r8)
 8002e0a:	b007      	add	sp, #28
 8002e0c:	bd00      	pop	{pc}
 8002e0e:	46c0      	nop			@ (mov r8, r8)
 8002e10:	200006a0 	.word	0x200006a0
 8002e14:	080052b0 	.word	0x080052b0
	...

08002e20 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8002e20:	b510      	push	{r4, lr}
 8002e22:	b086      	sub	sp, #24
 8002e24:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002e26:	4b40      	ldr	r3, [pc, #256]	@ (8002f28 <chVTDoResetI+0x108>)
 8002e28:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002e2a:	f7ff fb59 	bl	80024e0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8002e2e:	9b01      	ldr	r3, [sp, #4]
 8002e30:	425a      	negs	r2, r3
 8002e32:	4153      	adcs	r3, r2
 8002e34:	b2db      	uxtb	r3, r3
 8002e36:	2b00      	cmp	r3, #0
 8002e38:	d003      	beq.n	8002e42 <chVTDoResetI+0x22>
 8002e3a:	4b3c      	ldr	r3, [pc, #240]	@ (8002f2c <chVTDoResetI+0x10c>)
 8002e3c:	0018      	movs	r0, r3
 8002e3e:	f7ff f9df 	bl	8002200 <chSysHalt>
  chDbgAssert(chVTIsArmedI(vtp), "timer not armed");
 8002e42:	9b01      	ldr	r3, [sp, #4]
 8002e44:	0018      	movs	r0, r3
 8002e46:	f7ff fe8b 	bl	8002b60 <chVTIsArmedI.lto_priv.0>
 8002e4a:	0003      	movs	r3, r0
 8002e4c:	001a      	movs	r2, r3
 8002e4e:	2301      	movs	r3, #1
 8002e50:	4053      	eors	r3, r2
 8002e52:	b2db      	uxtb	r3, r3
 8002e54:	2b00      	cmp	r3, #0
 8002e56:	d003      	beq.n	8002e60 <chVTDoResetI+0x40>
 8002e58:	4b34      	ldr	r3, [pc, #208]	@ (8002f2c <chVTDoResetI+0x10c>)
 8002e5a:	0018      	movs	r0, r3
 8002e5c:	f7ff f9d0 	bl	8002200 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8002e60:	9b05      	ldr	r3, [sp, #20]
 8002e62:	9a01      	ldr	r2, [sp, #4]
 8002e64:	0011      	movs	r1, r2
 8002e66:	0018      	movs	r0, r3
 8002e68:	f7ff fd5a 	bl	8002920 <ch_dlist_isfirst>
 8002e6c:	0003      	movs	r3, r0
 8002e6e:	001a      	movs	r2, r3
 8002e70:	2301      	movs	r3, #1
 8002e72:	4053      	eors	r3, r2
 8002e74:	b2db      	uxtb	r3, r3
 8002e76:	2b00      	cmp	r3, #0
 8002e78:	d014      	beq.n	8002ea4 <chVTDoResetI+0x84>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8002e7a:	9b01      	ldr	r3, [sp, #4]
 8002e7c:	0018      	movs	r0, r3
 8002e7e:	f7ff fdf7 	bl	8002a70 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8002e82:	9b01      	ldr	r3, [sp, #4]
 8002e84:	681b      	ldr	r3, [r3, #0]
 8002e86:	6899      	ldr	r1, [r3, #8]
 8002e88:	9b01      	ldr	r3, [sp, #4]
 8002e8a:	689a      	ldr	r2, [r3, #8]
 8002e8c:	9b01      	ldr	r3, [sp, #4]
 8002e8e:	681b      	ldr	r3, [r3, #0]
 8002e90:	188a      	adds	r2, r1, r2
 8002e92:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8002e94:	9b01      	ldr	r3, [sp, #4]
 8002e96:	2200      	movs	r2, #0
 8002e98:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8002e9a:	9b05      	ldr	r3, [sp, #20]
 8002e9c:	2201      	movs	r2, #1
 8002e9e:	4252      	negs	r2, r2
 8002ea0:	609a      	str	r2, [r3, #8]

    return;
 8002ea2:	e03f      	b.n	8002f24 <chVTDoResetI+0x104>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8002ea4:	9b05      	ldr	r3, [sp, #20]
 8002ea6:	0018      	movs	r0, r3
 8002ea8:	f7ff fdca 	bl	8002a40 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8002eac:	9b01      	ldr	r3, [sp, #4]
 8002eae:	2200      	movs	r2, #0
 8002eb0:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002eb2:	9b05      	ldr	r3, [sp, #20]
 8002eb4:	0018      	movs	r0, r3
 8002eb6:	f7ff fd23 	bl	8002900 <ch_dlist_isempty>
 8002eba:	1e03      	subs	r3, r0, #0
 8002ebc:	d002      	beq.n	8002ec4 <chVTDoResetI+0xa4>

    port_timer_stop_alarm();
 8002ebe:	f7ff fe17 	bl	8002af0 <port_timer_stop_alarm>

    return;
 8002ec2:	e02f      	b.n	8002f24 <chVTDoResetI+0x104>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8002ec4:	9b05      	ldr	r3, [sp, #20]
 8002ec6:	681b      	ldr	r3, [r3, #0]
 8002ec8:	6899      	ldr	r1, [r3, #8]
 8002eca:	9b01      	ldr	r3, [sp, #4]
 8002ecc:	689a      	ldr	r2, [r3, #8]
 8002ece:	9b05      	ldr	r3, [sp, #20]
 8002ed0:	681b      	ldr	r3, [r3, #0]
 8002ed2:	188a      	adds	r2, r1, r2
 8002ed4:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 8002ed6:	2412      	movs	r4, #18
 8002ed8:	446c      	add	r4, sp
 8002eda:	f7ff fe39 	bl	8002b50 <chVTGetSystemTimeX.lto_priv.1>
 8002ede:	0003      	movs	r3, r0
 8002ee0:	8023      	strh	r3, [r4, #0]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002ee2:	9b05      	ldr	r3, [sp, #20]
 8002ee4:	899a      	ldrh	r2, [r3, #12]
 8002ee6:	2312      	movs	r3, #18
 8002ee8:	446b      	add	r3, sp
 8002eea:	881b      	ldrh	r3, [r3, #0]
 8002eec:	0019      	movs	r1, r3
 8002eee:	0010      	movs	r0, r2
 8002ef0:	f7ff fcee 	bl	80028d0 <chTimeDiffX.lto_priv.0>
 8002ef4:	0003      	movs	r3, r0
 8002ef6:	9303      	str	r3, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8002ef8:	9b05      	ldr	r3, [sp, #20]
 8002efa:	681b      	ldr	r3, [r3, #0]
 8002efc:	689b      	ldr	r3, [r3, #8]
 8002efe:	9a03      	ldr	r2, [sp, #12]
 8002f00:	429a      	cmp	r2, r3
 8002f02:	d20e      	bcs.n	8002f22 <chVTDoResetI+0x102>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8002f04:	9b05      	ldr	r3, [sp, #20]
 8002f06:	681b      	ldr	r3, [r3, #0]
 8002f08:	689a      	ldr	r2, [r3, #8]
 8002f0a:	9b03      	ldr	r3, [sp, #12]
 8002f0c:	1ad3      	subs	r3, r2, r3
 8002f0e:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 8002f10:	9a02      	ldr	r2, [sp, #8]
 8002f12:	2312      	movs	r3, #18
 8002f14:	446b      	add	r3, sp
 8002f16:	881b      	ldrh	r3, [r3, #0]
 8002f18:	0011      	movs	r1, r2
 8002f1a:	0018      	movs	r0, r3
 8002f1c:	f7ff fe30 	bl	8002b80 <vt_set_alarm>
 8002f20:	e000      	b.n	8002f24 <chVTDoResetI+0x104>
    return;
 8002f22:	46c0      	nop			@ (mov r8, r8)
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002f24:	b006      	add	sp, #24
 8002f26:	bd10      	pop	{r4, pc}
 8002f28:	200006a0 	.word	0x200006a0
 8002f2c:	080052bc 	.word	0x080052bc

08002f30 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8002f30:	b510      	push	{r4, lr}
 8002f32:	b088      	sub	sp, #32
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002f34:	4b5c      	ldr	r3, [pc, #368]	@ (80030a8 <chVTDoTickI+0x178>)
 8002f36:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002f38:	f7ff fad2 	bl	80024e0 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8002f3c:	9b05      	ldr	r3, [sp, #20]
 8002f3e:	681b      	ldr	r3, [r3, #0]
 8002f40:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 8002f42:	240e      	movs	r4, #14
 8002f44:	446c      	add	r4, sp
 8002f46:	f7ff fe03 	bl	8002b50 <chVTGetSystemTimeX.lto_priv.1>
 8002f4a:	0003      	movs	r3, r0
 8002f4c:	8023      	strh	r3, [r4, #0]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002f4e:	9b05      	ldr	r3, [sp, #20]
 8002f50:	899a      	ldrh	r2, [r3, #12]
 8002f52:	230e      	movs	r3, #14
 8002f54:	446b      	add	r3, sp
 8002f56:	881b      	ldrh	r3, [r3, #0]
 8002f58:	0019      	movs	r1, r3
 8002f5a:	0010      	movs	r0, r2
 8002f5c:	f7ff fcb8 	bl	80028d0 <chTimeDiffX.lto_priv.0>
 8002f60:	0003      	movs	r3, r0
 8002f62:	9302      	str	r3, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 8002f64:	9b04      	ldr	r3, [sp, #16]
 8002f66:	689b      	ldr	r3, [r3, #8]
 8002f68:	9a02      	ldr	r2, [sp, #8]
 8002f6a:	429a      	cmp	r2, r3
 8002f6c:	d200      	bcs.n	8002f70 <chVTDoTickI+0x40>
 8002f6e:	e078      	b.n	8003062 <chVTDoTickI+0x132>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 8002f70:	9b05      	ldr	r3, [sp, #20]
 8002f72:	899a      	ldrh	r2, [r3, #12]
 8002f74:	9b04      	ldr	r3, [sp, #16]
 8002f76:	689b      	ldr	r3, [r3, #8]
 8002f78:	4669      	mov	r1, sp
 8002f7a:	1d8c      	adds	r4, r1, #6
 8002f7c:	0019      	movs	r1, r3
 8002f7e:	0010      	movs	r0, r2
 8002f80:	f7ff fc86 	bl	8002890 <chTimeAddX>
 8002f84:	0003      	movs	r3, r0
 8002f86:	8023      	strh	r3, [r4, #0]
    vtlp->lasttime = lasttime;
 8002f88:	9b05      	ldr	r3, [sp, #20]
 8002f8a:	466a      	mov	r2, sp
 8002f8c:	3206      	adds	r2, #6
 8002f8e:	8812      	ldrh	r2, [r2, #0]
 8002f90:	819a      	strh	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8002f92:	9b04      	ldr	r3, [sp, #16]
 8002f94:	0018      	movs	r0, r3
 8002f96:	f7ff fd6b 	bl	8002a70 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8002f9a:	9b04      	ldr	r3, [sp, #16]
 8002f9c:	2200      	movs	r2, #0
 8002f9e:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002fa0:	9b05      	ldr	r3, [sp, #20]
 8002fa2:	0018      	movs	r0, r3
 8002fa4:	f7ff fcac 	bl	8002900 <ch_dlist_isempty>
 8002fa8:	1e03      	subs	r3, r0, #0
 8002faa:	d001      	beq.n	8002fb0 <chVTDoTickI+0x80>
      port_timer_stop_alarm();
 8002fac:	f7ff fda0 	bl	8002af0 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 8002fb0:	f7ff fdc6 	bl	8002b40 <chSysUnlockFromISR.lto_priv.3>

    vtp->func(vtp, vtp->par);
 8002fb4:	9b04      	ldr	r3, [sp, #16]
 8002fb6:	68da      	ldr	r2, [r3, #12]
 8002fb8:	9b04      	ldr	r3, [sp, #16]
 8002fba:	6919      	ldr	r1, [r3, #16]
 8002fbc:	9b04      	ldr	r3, [sp, #16]
 8002fbe:	0018      	movs	r0, r3
 8002fc0:	4790      	blx	r2

    chSysLockFromISR();
 8002fc2:	f7ff fdb5 	bl	8002b30 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8002fc6:	9b04      	ldr	r3, [sp, #16]
 8002fc8:	695b      	ldr	r3, [r3, #20]
 8002fca:	1e5a      	subs	r2, r3, #1
 8002fcc:	4193      	sbcs	r3, r2
 8002fce:	b2db      	uxtb	r3, r3
 8002fd0:	2b00      	cmp	r3, #0
 8002fd2:	d0b3      	beq.n	8002f3c <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8002fd4:	240e      	movs	r4, #14
 8002fd6:	446c      	add	r4, sp
 8002fd8:	f7ff fdba 	bl	8002b50 <chVTGetSystemTimeX.lto_priv.1>
 8002fdc:	0003      	movs	r3, r0
 8002fde:	8023      	strh	r3, [r4, #0]
      nowdelta = chTimeDiffX(lasttime, now);
 8002fe0:	230e      	movs	r3, #14
 8002fe2:	446b      	add	r3, sp
 8002fe4:	881a      	ldrh	r2, [r3, #0]
 8002fe6:	466b      	mov	r3, sp
 8002fe8:	3306      	adds	r3, #6
 8002fea:	881b      	ldrh	r3, [r3, #0]
 8002fec:	0011      	movs	r1, r2
 8002fee:	0018      	movs	r0, r3
 8002ff0:	f7ff fc6e 	bl	80028d0 <chTimeDiffX.lto_priv.0>
 8002ff4:	0003      	movs	r3, r0
 8002ff6:	9302      	str	r3, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8002ff8:	9b04      	ldr	r3, [sp, #16]
 8002ffa:	695b      	ldr	r3, [r3, #20]
 8002ffc:	9a02      	ldr	r2, [sp, #8]
 8002ffe:	429a      	cmp	r2, r3
 8003000:	d909      	bls.n	8003016 <chVTDoTickI+0xe6>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
 8003002:	4b2a      	ldr	r3, [pc, #168]	@ (80030ac <chVTDoTickI+0x17c>)
 8003004:	0018      	movs	r0, r3
 8003006:	f7ff f8fb 	bl	8002200 <chSysHalt>
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 800300a:	2002      	movs	r0, #2
 800300c:	f7ff f938 	bl	8002280 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8003010:	2300      	movs	r3, #0
 8003012:	9306      	str	r3, [sp, #24]
 8003014:	e004      	b.n	8003020 <chVTDoTickI+0xf0>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 8003016:	9b04      	ldr	r3, [sp, #16]
 8003018:	695a      	ldr	r2, [r3, #20]
 800301a:	9b02      	ldr	r3, [sp, #8]
 800301c:	1ad3      	subs	r3, r2, r3
 800301e:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8003020:	9b05      	ldr	r3, [sp, #20]
 8003022:	0018      	movs	r0, r3
 8003024:	f7ff fc6c 	bl	8002900 <ch_dlist_isempty>
 8003028:	1e03      	subs	r3, r0, #0
 800302a:	d009      	beq.n	8003040 <chVTDoTickI+0x110>

        vt_insert_first(vtlp, vtp, now, delay);
 800302c:	9c06      	ldr	r4, [sp, #24]
 800302e:	230e      	movs	r3, #14
 8003030:	446b      	add	r3, sp
 8003032:	881a      	ldrh	r2, [r3, #0]
 8003034:	9904      	ldr	r1, [sp, #16]
 8003036:	9805      	ldr	r0, [sp, #20]
 8003038:	0023      	movs	r3, r4
 800303a:	f7ff fdf9 	bl	8002c30 <vt_insert_first>

        return;
 800303e:	e030      	b.n	80030a2 <chVTDoTickI+0x172>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8003040:	9a02      	ldr	r2, [sp, #8]
 8003042:	9b06      	ldr	r3, [sp, #24]
 8003044:	18d3      	adds	r3, r2, r3
 8003046:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 8003048:	9a07      	ldr	r2, [sp, #28]
 800304a:	9b02      	ldr	r3, [sp, #8]
 800304c:	429a      	cmp	r2, r3
 800304e:	d201      	bcs.n	8003054 <chVTDoTickI+0x124>
        delta = delay;
 8003050:	9b06      	ldr	r3, [sp, #24]
 8003052:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003054:	9b05      	ldr	r3, [sp, #20]
 8003056:	9904      	ldr	r1, [sp, #16]
 8003058:	9a07      	ldr	r2, [sp, #28]
 800305a:	0018      	movs	r0, r3
 800305c:	f7ff fcb0 	bl	80029c0 <ch_dlist_insert>
  while (true) {
 8003060:	e76c      	b.n	8002f3c <chVTDoTickI+0xc>
      break;
 8003062:	46c0      	nop			@ (mov r8, r8)
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003064:	9b05      	ldr	r3, [sp, #20]
 8003066:	0018      	movs	r0, r3
 8003068:	f7ff fc4a 	bl	8002900 <ch_dlist_isempty>
 800306c:	1e03      	subs	r3, r0, #0
 800306e:	d117      	bne.n	80030a0 <chVTDoTickI+0x170>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 8003070:	9b05      	ldr	r3, [sp, #20]
 8003072:	899a      	ldrh	r2, [r3, #12]
 8003074:	9b02      	ldr	r3, [sp, #8]
 8003076:	b29b      	uxth	r3, r3
 8003078:	18d3      	adds	r3, r2, r3
 800307a:	b29a      	uxth	r2, r3
 800307c:	9b05      	ldr	r3, [sp, #20]
 800307e:	819a      	strh	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 8003080:	9b04      	ldr	r3, [sp, #16]
 8003082:	689a      	ldr	r2, [r3, #8]
 8003084:	9b02      	ldr	r3, [sp, #8]
 8003086:	1ad2      	subs	r2, r2, r3
 8003088:	9b04      	ldr	r3, [sp, #16]
 800308a:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 800308c:	9b04      	ldr	r3, [sp, #16]
 800308e:	689a      	ldr	r2, [r3, #8]
 8003090:	230e      	movs	r3, #14
 8003092:	446b      	add	r3, sp
 8003094:	881b      	ldrh	r3, [r3, #0]
 8003096:	0011      	movs	r1, r2
 8003098:	0018      	movs	r0, r3
 800309a:	f7ff fd71 	bl	8002b80 <vt_set_alarm>
 800309e:	e000      	b.n	80030a2 <chVTDoTickI+0x172>
    return;
 80030a0:	46c0      	nop			@ (mov r8, r8)
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80030a2:	b008      	add	sp, #32
 80030a4:	bd10      	pop	{r4, pc}
 80030a6:	46c0      	nop			@ (mov r8, r8)
 80030a8:	200006a0 	.word	0x200006a0
 80030ac:	080052cc 	.word	0x080052cc

080030b0 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80030b0:	b082      	sub	sp, #8
 80030b2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80030b4:	9b01      	ldr	r3, [sp, #4]
 80030b6:	685b      	ldr	r3, [r3, #4]
 80030b8:	9a01      	ldr	r2, [sp, #4]
 80030ba:	6812      	ldr	r2, [r2, #0]
 80030bc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80030be:	9b01      	ldr	r3, [sp, #4]
 80030c0:	681b      	ldr	r3, [r3, #0]
 80030c2:	9a01      	ldr	r2, [sp, #4]
 80030c4:	6852      	ldr	r2, [r2, #4]
 80030c6:	605a      	str	r2, [r3, #4]
  return p;
 80030c8:	9b01      	ldr	r3, [sp, #4]
}
 80030ca:	0018      	movs	r0, r3
 80030cc:	b002      	add	sp, #8
 80030ce:	4770      	bx	lr

080030d0 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 80030d0:	b084      	sub	sp, #16
 80030d2:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 80030d4:	9b01      	ldr	r3, [sp, #4]
 80030d6:	681b      	ldr	r3, [r3, #0]
 80030d8:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 80030da:	9b03      	ldr	r3, [sp, #12]
 80030dc:	681a      	ldr	r2, [r3, #0]
 80030de:	9b01      	ldr	r3, [sp, #4]
 80030e0:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 80030e2:	9b01      	ldr	r3, [sp, #4]
 80030e4:	681b      	ldr	r3, [r3, #0]
 80030e6:	9a01      	ldr	r2, [sp, #4]
 80030e8:	605a      	str	r2, [r3, #4]
  return p;
 80030ea:	9b03      	ldr	r3, [sp, #12]
}
 80030ec:	0018      	movs	r0, r3
 80030ee:	b004      	add	sp, #16
 80030f0:	4770      	bx	lr
 80030f2:	46c0      	nop			@ (mov r8, r8)
	...

08003100 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8003100:	b082      	sub	sp, #8
 8003102:	9001      	str	r0, [sp, #4]
 8003104:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003106:	9b01      	ldr	r3, [sp, #4]
 8003108:	681b      	ldr	r3, [r3, #0]
 800310a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 800310c:	9b01      	ldr	r3, [sp, #4]
 800310e:	6899      	ldr	r1, [r3, #8]
 8003110:	9b00      	ldr	r3, [sp, #0]
 8003112:	689a      	ldr	r2, [r3, #8]
 8003114:	2300      	movs	r3, #0
 8003116:	4291      	cmp	r1, r2
 8003118:	415b      	adcs	r3, r3
 800311a:	b2db      	uxtb	r3, r3
 800311c:	2b00      	cmp	r3, #0
 800311e:	d1f2      	bne.n	8003106 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8003120:	9b00      	ldr	r3, [sp, #0]
 8003122:	9a01      	ldr	r2, [sp, #4]
 8003124:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003126:	9b01      	ldr	r3, [sp, #4]
 8003128:	685a      	ldr	r2, [r3, #4]
 800312a:	9b00      	ldr	r3, [sp, #0]
 800312c:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 800312e:	9b00      	ldr	r3, [sp, #0]
 8003130:	685b      	ldr	r3, [r3, #4]
 8003132:	9a00      	ldr	r2, [sp, #0]
 8003134:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003136:	9b01      	ldr	r3, [sp, #4]
 8003138:	9a00      	ldr	r2, [sp, #0]
 800313a:	605a      	str	r2, [r3, #4]
  return p;
 800313c:	9b00      	ldr	r3, [sp, #0]
}
 800313e:	0018      	movs	r0, r3
 8003140:	b002      	add	sp, #8
 8003142:	4770      	bx	lr
	...

08003150 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8003150:	b082      	sub	sp, #8
 8003152:	9001      	str	r0, [sp, #4]
 8003154:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003156:	9b01      	ldr	r3, [sp, #4]
 8003158:	681b      	ldr	r3, [r3, #0]
 800315a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 800315c:	9b01      	ldr	r3, [sp, #4]
 800315e:	689a      	ldr	r2, [r3, #8]
 8003160:	9b00      	ldr	r3, [sp, #0]
 8003162:	689b      	ldr	r3, [r3, #8]
 8003164:	4293      	cmp	r3, r2
 8003166:	419b      	sbcs	r3, r3
 8003168:	425b      	negs	r3, r3
 800316a:	b2db      	uxtb	r3, r3
 800316c:	2b00      	cmp	r3, #0
 800316e:	d1f2      	bne.n	8003156 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 8003170:	9b00      	ldr	r3, [sp, #0]
 8003172:	9a01      	ldr	r2, [sp, #4]
 8003174:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003176:	9b01      	ldr	r3, [sp, #4]
 8003178:	685a      	ldr	r2, [r3, #4]
 800317a:	9b00      	ldr	r3, [sp, #0]
 800317c:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 800317e:	9b00      	ldr	r3, [sp, #0]
 8003180:	685b      	ldr	r3, [r3, #4]
 8003182:	9a00      	ldr	r2, [sp, #0]
 8003184:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003186:	9b01      	ldr	r3, [sp, #4]
 8003188:	9a00      	ldr	r2, [sp, #0]
 800318a:	605a      	str	r2, [r3, #4]
  return p;
 800318c:	9b00      	ldr	r3, [sp, #0]
}
 800318e:	0018      	movs	r0, r3
 8003190:	b002      	add	sp, #8
 8003192:	4770      	bx	lr
	...

080031a0 <port_lock.lto_priv.11>:
  __ASM volatile ("cpsid i" : : : "memory");
 80031a0:	b672      	cpsid	i
}
 80031a2:	46c0      	nop			@ (mov r8, r8)
}
 80031a4:	46c0      	nop			@ (mov r8, r8)
 80031a6:	4770      	bx	lr
	...

080031b0 <port_unlock.lto_priv.11>:
  __ASM volatile ("cpsie i" : : : "memory");
 80031b0:	b662      	cpsie	i
}
 80031b2:	46c0      	nop			@ (mov r8, r8)
}
 80031b4:	46c0      	nop			@ (mov r8, r8)
 80031b6:	4770      	bx	lr
	...

080031c0 <port_lock_from_isr.lto_priv.6>:
static inline void port_lock_from_isr(void) {
 80031c0:	b510      	push	{r4, lr}
  port_lock();
 80031c2:	f7ff ffed 	bl	80031a0 <port_lock.lto_priv.11>
}
 80031c6:	46c0      	nop			@ (mov r8, r8)
 80031c8:	bd10      	pop	{r4, pc}
 80031ca:	46c0      	nop			@ (mov r8, r8)
 80031cc:	0000      	movs	r0, r0
	...

080031d0 <port_unlock_from_isr.lto_priv.6>:
static inline void port_unlock_from_isr(void) {
 80031d0:	b510      	push	{r4, lr}
  port_unlock();
 80031d2:	f7ff ffed 	bl	80031b0 <port_unlock.lto_priv.11>
}
 80031d6:	46c0      	nop			@ (mov r8, r8)
 80031d8:	bd10      	pop	{r4, pc}
 80031da:	46c0      	nop			@ (mov r8, r8)
 80031dc:	0000      	movs	r0, r0
	...

080031e0 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 80031e0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 80031e2:	f7ff ffed 	bl	80031c0 <port_lock_from_isr.lto_priv.6>
  __dbg_check_lock_from_isr();
 80031e6:	f7ff f8cb 	bl	8002380 <__dbg_check_lock_from_isr>
}
 80031ea:	46c0      	nop			@ (mov r8, r8)
 80031ec:	bd10      	pop	{r4, pc}
 80031ee:	46c0      	nop			@ (mov r8, r8)

080031f0 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 80031f0:	b510      	push	{r4, lr}
  __dbg_check_unlock_from_isr();
 80031f2:	f7ff f8ed 	bl	80023d0 <__dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 80031f6:	f7ff ffeb 	bl	80031d0 <port_unlock_from_isr.lto_priv.6>
}
 80031fa:	46c0      	nop			@ (mov r8, r8)
 80031fc:	bd10      	pop	{r4, pc}
 80031fe:	46c0      	nop			@ (mov r8, r8)

08003200 <chVTIsArmedI.lto_priv.1>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8003200:	b500      	push	{lr}
 8003202:	b083      	sub	sp, #12
 8003204:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8003206:	f7ff f96b 	bl	80024e0 <chDbgCheckClassI>
  return (bool)(vtp->dlist.next != NULL);
 800320a:	9b01      	ldr	r3, [sp, #4]
 800320c:	681b      	ldr	r3, [r3, #0]
 800320e:	1e5a      	subs	r2, r3, #1
 8003210:	4193      	sbcs	r3, r2
 8003212:	b2db      	uxtb	r3, r3
}
 8003214:	0018      	movs	r0, r3
 8003216:	b003      	add	sp, #12
 8003218:	bd00      	pop	{pc}
 800321a:	46c0      	nop			@ (mov r8, r8)
 800321c:	0000      	movs	r0, r0
	...

08003220 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8003220:	b500      	push	{lr}
 8003222:	b083      	sub	sp, #12
 8003224:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003226:	f7ff f95b 	bl	80024e0 <chDbgCheckClassI>

  sp->cnt++;
 800322a:	9b01      	ldr	r3, [sp, #4]
 800322c:	689b      	ldr	r3, [r3, #8]
 800322e:	1c5a      	adds	r2, r3, #1
 8003230:	9b01      	ldr	r3, [sp, #4]
 8003232:	609a      	str	r2, [r3, #8]
}
 8003234:	46c0      	nop			@ (mov r8, r8)
 8003236:	b003      	add	sp, #12
 8003238:	bd00      	pop	{pc}
 800323a:	46c0      	nop			@ (mov r8, r8)
 800323c:	0000      	movs	r0, r0
	...

08003240 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8003240:	b500      	push	{lr}
 8003242:	b083      	sub	sp, #12
 8003244:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003246:	9b01      	ldr	r3, [sp, #4]
 8003248:	2224      	movs	r2, #36	@ 0x24
 800324a:	5c9b      	ldrb	r3, [r3, r2]
 800324c:	425a      	negs	r2, r3
 800324e:	4153      	adcs	r3, r2
 8003250:	b2db      	uxtb	r3, r3
 8003252:	2b00      	cmp	r3, #0
 8003254:	d108      	bne.n	8003268 <__sch_ready_behind+0x28>
 8003256:	9b01      	ldr	r3, [sp, #4]
 8003258:	2224      	movs	r2, #36	@ 0x24
 800325a:	5c9b      	ldrb	r3, [r3, r2]
 800325c:	3b0f      	subs	r3, #15
 800325e:	425a      	negs	r2, r3
 8003260:	4153      	adcs	r3, r2
 8003262:	b2db      	uxtb	r3, r3
 8003264:	2b00      	cmp	r3, #0
 8003266:	d003      	beq.n	8003270 <__sch_ready_behind+0x30>
 8003268:	4b0d      	ldr	r3, [pc, #52]	@ (80032a0 <__sch_ready_behind+0x60>)
 800326a:	0018      	movs	r0, r3
 800326c:	f7fe ffc8 	bl	8002200 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 8003270:	9b01      	ldr	r3, [sp, #4]
 8003272:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8003274:	9b01      	ldr	r3, [sp, #4]
 8003276:	0011      	movs	r1, r2
 8003278:	0018      	movs	r0, r3
 800327a:	f7ff f9f9 	bl	8002670 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 800327e:	9b01      	ldr	r3, [sp, #4]
 8003280:	2224      	movs	r2, #36	@ 0x24
 8003282:	2100      	movs	r1, #0
 8003284:	5499      	strb	r1, [r3, r2]

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8003286:	9b01      	ldr	r3, [sp, #4]
 8003288:	699b      	ldr	r3, [r3, #24]
 800328a:	001a      	movs	r2, r3
 800328c:	9b01      	ldr	r3, [sp, #4]
 800328e:	0019      	movs	r1, r3
 8003290:	0010      	movs	r0, r2
 8003292:	f7ff ff35 	bl	8003100 <ch_pqueue_insert_behind>
 8003296:	0003      	movs	r3, r0
                                           &tp->hdr.pqueue));
}
 8003298:	0018      	movs	r0, r3
 800329a:	b003      	add	sp, #12
 800329c:	bd00      	pop	{pc}
 800329e:	46c0      	nop			@ (mov r8, r8)
 80032a0:	0800530c 	.word	0x0800530c
	...

080032b0 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 80032b0:	b500      	push	{lr}
 80032b2:	b083      	sub	sp, #12
 80032b4:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 80032b6:	9b01      	ldr	r3, [sp, #4]
 80032b8:	2224      	movs	r2, #36	@ 0x24
 80032ba:	5c9b      	ldrb	r3, [r3, r2]
 80032bc:	425a      	negs	r2, r3
 80032be:	4153      	adcs	r3, r2
 80032c0:	b2db      	uxtb	r3, r3
 80032c2:	2b00      	cmp	r3, #0
 80032c4:	d108      	bne.n	80032d8 <__sch_ready_ahead+0x28>
 80032c6:	9b01      	ldr	r3, [sp, #4]
 80032c8:	2224      	movs	r2, #36	@ 0x24
 80032ca:	5c9b      	ldrb	r3, [r3, r2]
 80032cc:	3b0f      	subs	r3, #15
 80032ce:	425a      	negs	r2, r3
 80032d0:	4153      	adcs	r3, r2
 80032d2:	b2db      	uxtb	r3, r3
 80032d4:	2b00      	cmp	r3, #0
 80032d6:	d003      	beq.n	80032e0 <__sch_ready_ahead+0x30>
 80032d8:	4b0d      	ldr	r3, [pc, #52]	@ (8003310 <__sch_ready_ahead+0x60>)
 80032da:	0018      	movs	r0, r3
 80032dc:	f7fe ff90 	bl	8002200 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 80032e0:	9b01      	ldr	r3, [sp, #4]
 80032e2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80032e4:	9b01      	ldr	r3, [sp, #4]
 80032e6:	0011      	movs	r1, r2
 80032e8:	0018      	movs	r0, r3
 80032ea:	f7ff f9c1 	bl	8002670 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80032ee:	9b01      	ldr	r3, [sp, #4]
 80032f0:	2224      	movs	r2, #36	@ 0x24
 80032f2:	2100      	movs	r1, #0
 80032f4:	5499      	strb	r1, [r3, r2]

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 80032f6:	9b01      	ldr	r3, [sp, #4]
 80032f8:	699b      	ldr	r3, [r3, #24]
 80032fa:	001a      	movs	r2, r3
 80032fc:	9b01      	ldr	r3, [sp, #4]
 80032fe:	0019      	movs	r1, r3
 8003300:	0010      	movs	r0, r2
 8003302:	f7ff ff25 	bl	8003150 <ch_pqueue_insert_ahead>
 8003306:	0003      	movs	r3, r0
                                          &tp->hdr.pqueue));
}
 8003308:	0018      	movs	r0, r3
 800330a:	b003      	add	sp, #12
 800330c:	bd00      	pop	{pc}
 800330e:	46c0      	nop			@ (mov r8, r8)
 8003310:	08005320 	.word	0x08005320
	...

08003320 <__sch_reschedule_ahead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_ahead(void) {
 8003320:	b500      	push	{lr}
 8003322:	b087      	sub	sp, #28
  os_instance_t *oip = currcore;
 8003324:	4b1b      	ldr	r3, [pc, #108]	@ (8003394 <__sch_reschedule_ahead+0x74>)
 8003326:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 8003328:	9b05      	ldr	r3, [sp, #20]
 800332a:	68db      	ldr	r3, [r3, #12]
 800332c:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800332e:	9b05      	ldr	r3, [sp, #20]
 8003330:	0018      	movs	r0, r3
 8003332:	f7ff fecd 	bl	80030d0 <ch_pqueue_remove_highest>
 8003336:	0003      	movs	r3, r0
 8003338:	9303      	str	r3, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 800333a:	9b03      	ldr	r3, [sp, #12]
 800333c:	2224      	movs	r2, #36	@ 0x24
 800333e:	2101      	movs	r1, #1
 8003340:	5499      	strb	r1, [r3, r2]
  __instance_set_currthread(oip, ntp);
 8003342:	9b05      	ldr	r3, [sp, #20]
 8003344:	9a03      	ldr	r2, [sp, #12]
 8003346:	60da      	str	r2, [r3, #12]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = __sch_ready_ahead(otp);
 8003348:	9b04      	ldr	r3, [sp, #16]
 800334a:	0018      	movs	r0, r3
 800334c:	f7ff ffb0 	bl	80032b0 <__sch_ready_ahead>
 8003350:	0003      	movs	r3, r0
 8003352:	9304      	str	r3, [sp, #16]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8003354:	9a04      	ldr	r2, [sp, #16]
 8003356:	9b03      	ldr	r3, [sp, #12]
 8003358:	0011      	movs	r1, r2
 800335a:	0018      	movs	r0, r3
 800335c:	f7ff f9c8 	bl	80026f0 <__trace_switch>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003360:	f3ef 8309 	mrs	r3, PSP
 8003364:	9301      	str	r3, [sp, #4]
  return(result);
 8003366:	9b01      	ldr	r3, [sp, #4]
 8003368:	9302      	str	r3, [sp, #8]
 800336a:	9b02      	ldr	r3, [sp, #8]
 800336c:	3b24      	subs	r3, #36	@ 0x24
 800336e:	001a      	movs	r2, r3
 8003370:	9b04      	ldr	r3, [sp, #16]
 8003372:	6a1b      	ldr	r3, [r3, #32]
 8003374:	429a      	cmp	r2, r3
 8003376:	d203      	bcs.n	8003380 <__sch_reschedule_ahead+0x60>
 8003378:	4b07      	ldr	r3, [pc, #28]	@ (8003398 <__sch_reschedule_ahead+0x78>)
 800337a:	0018      	movs	r0, r3
 800337c:	f7fe ff40 	bl	8002200 <chSysHalt>
 8003380:	9a04      	ldr	r2, [sp, #16]
 8003382:	9b03      	ldr	r3, [sp, #12]
 8003384:	0011      	movs	r1, r2
 8003386:	0018      	movs	r0, r3
 8003388:	f7fc ff06 	bl	8000198 <__port_switch>
}
 800338c:	46c0      	nop			@ (mov r8, r8)
 800338e:	b007      	add	sp, #28
 8003390:	bd00      	pop	{pc}
 8003392:	46c0      	nop			@ (mov r8, r8)
 8003394:	20000690 	.word	0x20000690
 8003398:	0800522c 	.word	0x0800522c
 800339c:	00000000 	.word	0x00000000

080033a0 <__sch_wakeup>:

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 80033a0:	b500      	push	{lr}
 80033a2:	b085      	sub	sp, #20
 80033a4:	9001      	str	r0, [sp, #4]
 80033a6:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 80033a8:	9b00      	ldr	r3, [sp, #0]
 80033aa:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 80033ac:	f7ff ff18 	bl	80031e0 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
 80033b0:	9b03      	ldr	r3, [sp, #12]
 80033b2:	2224      	movs	r2, #36	@ 0x24
 80033b4:	5c9b      	ldrb	r3, [r3, r2]
 80033b6:	2b0c      	cmp	r3, #12
 80033b8:	d816      	bhi.n	80033e8 <__sch_wakeup+0x48>
 80033ba:	009a      	lsls	r2, r3, #2
 80033bc:	4b11      	ldr	r3, [pc, #68]	@ (8003404 <__sch_wakeup+0x64>)
 80033be:	18d3      	adds	r3, r2, r3
 80033c0:	681b      	ldr	r3, [r3, #0]
 80033c2:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 80033c4:	f7ff ff14 	bl	80031f0 <chSysUnlockFromISR.lto_priv.4>
    return;
 80033c8:	e01a      	b.n	8003400 <__sch_wakeup+0x60>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80033ca:	9b03      	ldr	r3, [sp, #12]
 80033cc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80033ce:	2200      	movs	r2, #0
 80033d0:	601a      	str	r2, [r3, #0]
    break;
 80033d2:	e00a      	b.n	80033ea <__sch_wakeup+0x4a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80033d4:	9b03      	ldr	r3, [sp, #12]
 80033d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80033d8:	0018      	movs	r0, r3
 80033da:	f7ff ff21 	bl	8003220 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 80033de:	9b03      	ldr	r3, [sp, #12]
 80033e0:	0018      	movs	r0, r3
 80033e2:	f7ff fe65 	bl	80030b0 <ch_queue_dequeue.lto_priv.0>
    break;
 80033e6:	e000      	b.n	80033ea <__sch_wakeup+0x4a>
  default:
    /* Any other state, nothing to do.*/
    break;
 80033e8:	46c0      	nop			@ (mov r8, r8)
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 80033ea:	9b03      	ldr	r3, [sp, #12]
 80033ec:	2201      	movs	r2, #1
 80033ee:	4252      	negs	r2, r2
 80033f0:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 80033f2:	9b03      	ldr	r3, [sp, #12]
 80033f4:	0018      	movs	r0, r3
 80033f6:	f7ff ff23 	bl	8003240 <__sch_ready_behind>
  chSysUnlockFromISR();
 80033fa:	f7ff fef9 	bl	80031f0 <chSysUnlockFromISR.lto_priv.4>

  return;
 80033fe:	46c0      	nop			@ (mov r8, r8)
}
 8003400:	b005      	add	sp, #20
 8003402:	bd00      	pop	{pc}
 8003404:	080052d8 	.word	0x080052d8
	...

08003410 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003410:	b500      	push	{lr}
 8003412:	b083      	sub	sp, #12
 8003414:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003416:	f7ff f863 	bl	80024e0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800341a:	9b01      	ldr	r3, [sp, #4]
 800341c:	425a      	negs	r2, r3
 800341e:	4153      	adcs	r3, r2
 8003420:	b2db      	uxtb	r3, r3
 8003422:	2b00      	cmp	r3, #0
 8003424:	d003      	beq.n	800342e <chSchReadyI+0x1e>
 8003426:	4b06      	ldr	r3, [pc, #24]	@ (8003440 <chSchReadyI+0x30>)
 8003428:	0018      	movs	r0, r3
 800342a:	f7fe fee9 	bl	8002200 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 800342e:	9b01      	ldr	r3, [sp, #4]
 8003430:	0018      	movs	r0, r3
 8003432:	f7ff ff05 	bl	8003240 <__sch_ready_behind>
 8003436:	0003      	movs	r3, r0
}
 8003438:	0018      	movs	r0, r3
 800343a:	b003      	add	sp, #12
 800343c:	bd00      	pop	{pc}
 800343e:	46c0      	nop			@ (mov r8, r8)
 8003440:	08005334 	.word	0x08005334
	...

08003450 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003450:	b500      	push	{lr}
 8003452:	b089      	sub	sp, #36	@ 0x24
 8003454:	0002      	movs	r2, r0
 8003456:	466b      	mov	r3, sp
 8003458:	3307      	adds	r3, #7
 800345a:	701a      	strb	r2, [r3, #0]
  os_instance_t *oip = currcore;
 800345c:	4b29      	ldr	r3, [pc, #164]	@ (8003504 <chSchGoSleepS+0xb4>)
 800345e:	9307      	str	r3, [sp, #28]
  thread_t *otp = __instance_get_currthread(oip);
 8003460:	9b07      	ldr	r3, [sp, #28]
 8003462:	68db      	ldr	r3, [r3, #12]
 8003464:	9306      	str	r3, [sp, #24]
  thread_t *ntp;

  chDbgCheckClassS();
 8003466:	f7ff f85b 	bl	8002520 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 800346a:	f7fe fee1 	bl	8002230 <chSysGetIdleThreadX>
 800346e:	0002      	movs	r2, r0
 8003470:	9b06      	ldr	r3, [sp, #24]
 8003472:	1a9b      	subs	r3, r3, r2
 8003474:	425a      	negs	r2, r3
 8003476:	4153      	adcs	r3, r2
 8003478:	b2db      	uxtb	r3, r3
 800347a:	2b00      	cmp	r3, #0
 800347c:	d003      	beq.n	8003486 <chSchGoSleepS+0x36>
 800347e:	4b22      	ldr	r3, [pc, #136]	@ (8003508 <chSchGoSleepS+0xb8>)
 8003480:	0018      	movs	r0, r3
 8003482:	f7fe febd 	bl	8002200 <chSysHalt>
  chDbgAssert(otp->owner == oip, "invalid core");
 8003486:	9b06      	ldr	r3, [sp, #24]
 8003488:	699b      	ldr	r3, [r3, #24]
 800348a:	9a07      	ldr	r2, [sp, #28]
 800348c:	1ad3      	subs	r3, r2, r3
 800348e:	1e5a      	subs	r2, r3, #1
 8003490:	4193      	sbcs	r3, r2
 8003492:	b2db      	uxtb	r3, r3
 8003494:	2b00      	cmp	r3, #0
 8003496:	d003      	beq.n	80034a0 <chSchGoSleepS+0x50>
 8003498:	4b1b      	ldr	r3, [pc, #108]	@ (8003508 <chSchGoSleepS+0xb8>)
 800349a:	0018      	movs	r0, r3
 800349c:	f7fe feb0 	bl	8002200 <chSysHalt>

  /* New state.*/
  otp->state = newstate;
 80034a0:	9b06      	ldr	r3, [sp, #24]
 80034a2:	466a      	mov	r2, sp
 80034a4:	3207      	adds	r2, #7
 80034a6:	2124      	movs	r1, #36	@ 0x24
 80034a8:	7812      	ldrb	r2, [r2, #0]
 80034aa:	545a      	strb	r2, [r3, r1]
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 80034ac:	9b07      	ldr	r3, [sp, #28]
 80034ae:	0018      	movs	r0, r3
 80034b0:	f7ff fe0e 	bl	80030d0 <ch_pqueue_remove_highest>
 80034b4:	0003      	movs	r3, r0
 80034b6:	9305      	str	r3, [sp, #20]
  ntp->state = CH_STATE_CURRENT;
 80034b8:	9b05      	ldr	r3, [sp, #20]
 80034ba:	2224      	movs	r2, #36	@ 0x24
 80034bc:	2101      	movs	r1, #1
 80034be:	5499      	strb	r1, [r3, r2]
  __instance_set_currthread(oip, ntp);
 80034c0:	9b07      	ldr	r3, [sp, #28]
 80034c2:	9a05      	ldr	r2, [sp, #20]
 80034c4:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80034c6:	9a06      	ldr	r2, [sp, #24]
 80034c8:	9b05      	ldr	r3, [sp, #20]
 80034ca:	0011      	movs	r1, r2
 80034cc:	0018      	movs	r0, r3
 80034ce:	f7ff f90f 	bl	80026f0 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80034d2:	f3ef 8309 	mrs	r3, PSP
 80034d6:	9303      	str	r3, [sp, #12]
  return(result);
 80034d8:	9b03      	ldr	r3, [sp, #12]
 80034da:	9304      	str	r3, [sp, #16]
 80034dc:	9b04      	ldr	r3, [sp, #16]
 80034de:	3b24      	subs	r3, #36	@ 0x24
 80034e0:	001a      	movs	r2, r3
 80034e2:	9b06      	ldr	r3, [sp, #24]
 80034e4:	6a1b      	ldr	r3, [r3, #32]
 80034e6:	429a      	cmp	r2, r3
 80034e8:	d203      	bcs.n	80034f2 <chSchGoSleepS+0xa2>
 80034ea:	4b08      	ldr	r3, [pc, #32]	@ (800350c <chSchGoSleepS+0xbc>)
 80034ec:	0018      	movs	r0, r3
 80034ee:	f7fe fe87 	bl	8002200 <chSysHalt>
 80034f2:	9a06      	ldr	r2, [sp, #24]
 80034f4:	9b05      	ldr	r3, [sp, #20]
 80034f6:	0011      	movs	r1, r2
 80034f8:	0018      	movs	r0, r3
 80034fa:	f7fc fe4d 	bl	8000198 <__port_switch>
}
 80034fe:	46c0      	nop			@ (mov r8, r8)
 8003500:	b009      	add	sp, #36	@ 0x24
 8003502:	bd00      	pop	{pc}
 8003504:	20000690 	.word	0x20000690
 8003508:	08005340 	.word	0x08005340
 800350c:	0800522c 	.word	0x0800522c

08003510 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8003510:	b500      	push	{lr}
 8003512:	b08b      	sub	sp, #44	@ 0x2c
 8003514:	0002      	movs	r2, r0
 8003516:	9100      	str	r1, [sp, #0]
 8003518:	466b      	mov	r3, sp
 800351a:	3307      	adds	r3, #7
 800351c:	701a      	strb	r2, [r3, #0]
  thread_t *tp = __instance_get_currthread(currcore);
 800351e:	4b15      	ldr	r3, [pc, #84]	@ (8003574 <chSchGoSleepTimeoutS+0x64>)
 8003520:	68db      	ldr	r3, [r3, #12]
 8003522:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();
 8003524:	f7fe fffc 	bl	8002520 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 8003528:	9b00      	ldr	r3, [sp, #0]
 800352a:	3301      	adds	r3, #1
 800352c:	d016      	beq.n	800355c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 800352e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003530:	4a11      	ldr	r2, [pc, #68]	@ (8003578 <chSchGoSleepTimeoutS+0x68>)
 8003532:	9900      	ldr	r1, [sp, #0]
 8003534:	a803      	add	r0, sp, #12
 8003536:	f7ff fc33 	bl	8002da0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800353a:	466b      	mov	r3, sp
 800353c:	3307      	adds	r3, #7
 800353e:	781b      	ldrb	r3, [r3, #0]
 8003540:	0018      	movs	r0, r3
 8003542:	f7ff ff85 	bl	8003450 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8003546:	ab03      	add	r3, sp, #12
 8003548:	0018      	movs	r0, r3
 800354a:	f7ff fe59 	bl	8003200 <chVTIsArmedI.lto_priv.1>
 800354e:	1e03      	subs	r3, r0, #0
 8003550:	d00a      	beq.n	8003568 <chSchGoSleepTimeoutS+0x58>
      chVTDoResetI(&vt);
 8003552:	ab03      	add	r3, sp, #12
 8003554:	0018      	movs	r0, r3
 8003556:	f7ff fc63 	bl	8002e20 <chVTDoResetI>
 800355a:	e005      	b.n	8003568 <chSchGoSleepTimeoutS+0x58>
    }
  }
  else {
    chSchGoSleepS(newstate);
 800355c:	466b      	mov	r3, sp
 800355e:	3307      	adds	r3, #7
 8003560:	781b      	ldrb	r3, [r3, #0]
 8003562:	0018      	movs	r0, r3
 8003564:	f7ff ff74 	bl	8003450 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 8003568:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800356a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
}
 800356c:	0018      	movs	r0, r3
 800356e:	b00b      	add	sp, #44	@ 0x2c
 8003570:	bd00      	pop	{pc}
 8003572:	46c0      	nop			@ (mov r8, r8)
 8003574:	20000690 	.word	0x20000690
 8003578:	080033a1 	.word	0x080033a1
 800357c:	00000000 	.word	0x00000000

08003580 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003580:	b500      	push	{lr}
 8003582:	b087      	sub	sp, #28
 8003584:	9001      	str	r0, [sp, #4]
 8003586:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8003588:	4b2e      	ldr	r3, [pc, #184]	@ (8003644 <chSchWakeupS+0xc4>)
 800358a:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 800358c:	9b05      	ldr	r3, [sp, #20]
 800358e:	68db      	ldr	r3, [r3, #12]
 8003590:	9304      	str	r3, [sp, #16]

  chDbgCheckClassS();
 8003592:	f7fe ffc5 	bl	8002520 <chDbgCheckClassS>

  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8003596:	9b05      	ldr	r3, [sp, #20]
 8003598:	681a      	ldr	r2, [r3, #0]
 800359a:	9b05      	ldr	r3, [sp, #20]
 800359c:	1ad3      	subs	r3, r2, r3
 800359e:	1e5a      	subs	r2, r3, #1
 80035a0:	4193      	sbcs	r3, r2
 80035a2:	b2db      	uxtb	r3, r3
 80035a4:	2b00      	cmp	r3, #0
 80035a6:	d00f      	beq.n	80035c8 <chSchWakeupS+0x48>
 80035a8:	9b05      	ldr	r3, [sp, #20]
 80035aa:	68db      	ldr	r3, [r3, #12]
 80035ac:	689a      	ldr	r2, [r3, #8]
 80035ae:	9b05      	ldr	r3, [sp, #20]
 80035b0:	681b      	ldr	r3, [r3, #0]
 80035b2:	689b      	ldr	r3, [r3, #8]
 80035b4:	429a      	cmp	r2, r3
 80035b6:	419b      	sbcs	r3, r3
 80035b8:	425b      	negs	r3, r3
 80035ba:	b2db      	uxtb	r3, r3
 80035bc:	2b00      	cmp	r3, #0
 80035be:	d003      	beq.n	80035c8 <chSchWakeupS+0x48>
 80035c0:	4b21      	ldr	r3, [pc, #132]	@ (8003648 <chSchWakeupS+0xc8>)
 80035c2:	0018      	movs	r0, r3
 80035c4:	f7fe fe1c 	bl	8002200 <chSysHalt>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80035c8:	9b01      	ldr	r3, [sp, #4]
 80035ca:	9a00      	ldr	r2, [sp, #0]
 80035cc:	629a      	str	r2, [r3, #40]	@ 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 80035ce:	9b01      	ldr	r3, [sp, #4]
 80035d0:	689a      	ldr	r2, [r3, #8]
 80035d2:	9b04      	ldr	r3, [sp, #16]
 80035d4:	6899      	ldr	r1, [r3, #8]
 80035d6:	2300      	movs	r3, #0
 80035d8:	4291      	cmp	r1, r2
 80035da:	415b      	adcs	r3, r3
 80035dc:	b2db      	uxtb	r3, r3
 80035de:	2b00      	cmp	r3, #0
 80035e0:	d004      	beq.n	80035ec <chSchWakeupS+0x6c>
    (void) __sch_ready_behind(ntp);
 80035e2:	9b01      	ldr	r3, [sp, #4]
 80035e4:	0018      	movs	r0, r3
 80035e6:	f7ff fe2b 	bl	8003240 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 80035ea:	e028      	b.n	800363e <chSchWakeupS+0xbe>
    otp = __sch_ready_ahead(otp);
 80035ec:	9b04      	ldr	r3, [sp, #16]
 80035ee:	0018      	movs	r0, r3
 80035f0:	f7ff fe5e 	bl	80032b0 <__sch_ready_ahead>
 80035f4:	0003      	movs	r3, r0
 80035f6:	9304      	str	r3, [sp, #16]
    ntp->state = CH_STATE_CURRENT;
 80035f8:	9b01      	ldr	r3, [sp, #4]
 80035fa:	2224      	movs	r2, #36	@ 0x24
 80035fc:	2101      	movs	r1, #1
 80035fe:	5499      	strb	r1, [r3, r2]
    __instance_set_currthread(oip, ntp);
 8003600:	9b05      	ldr	r3, [sp, #20]
 8003602:	9a01      	ldr	r2, [sp, #4]
 8003604:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 8003606:	9a04      	ldr	r2, [sp, #16]
 8003608:	9b01      	ldr	r3, [sp, #4]
 800360a:	0011      	movs	r1, r2
 800360c:	0018      	movs	r0, r3
 800360e:	f7ff f86f 	bl	80026f0 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003612:	f3ef 8309 	mrs	r3, PSP
 8003616:	9302      	str	r3, [sp, #8]
  return(result);
 8003618:	9b02      	ldr	r3, [sp, #8]
 800361a:	9303      	str	r3, [sp, #12]
 800361c:	9b03      	ldr	r3, [sp, #12]
 800361e:	3b24      	subs	r3, #36	@ 0x24
 8003620:	001a      	movs	r2, r3
 8003622:	9b04      	ldr	r3, [sp, #16]
 8003624:	6a1b      	ldr	r3, [r3, #32]
 8003626:	429a      	cmp	r2, r3
 8003628:	d203      	bcs.n	8003632 <chSchWakeupS+0xb2>
 800362a:	4b08      	ldr	r3, [pc, #32]	@ (800364c <chSchWakeupS+0xcc>)
 800362c:	0018      	movs	r0, r3
 800362e:	f7fe fde7 	bl	8002200 <chSysHalt>
 8003632:	9a04      	ldr	r2, [sp, #16]
 8003634:	9b01      	ldr	r3, [sp, #4]
 8003636:	0011      	movs	r1, r2
 8003638:	0018      	movs	r0, r3
 800363a:	f7fc fdad 	bl	8000198 <__port_switch>
}
 800363e:	46c0      	nop			@ (mov r8, r8)
 8003640:	b007      	add	sp, #28
 8003642:	bd00      	pop	{pc}
 8003644:	20000690 	.word	0x20000690
 8003648:	08005350 	.word	0x08005350
 800364c:	0800522c 	.word	0x0800522c

08003650 <chSchRescheduleS>:
 * @note    Only local threads are considered, other cores are signaled
 *          and perform a reschedule locally.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8003650:	b500      	push	{lr}
 8003652:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003654:	4b0b      	ldr	r3, [pc, #44]	@ (8003684 <chSchRescheduleS+0x34>)
 8003656:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
 8003658:	9b01      	ldr	r3, [sp, #4]
 800365a:	68db      	ldr	r3, [r3, #12]
 800365c:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();
 800365e:	f7fe ff5f 	bl	8002520 <chDbgCheckClassS>

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 8003662:	9b01      	ldr	r3, [sp, #4]
 8003664:	681b      	ldr	r3, [r3, #0]
 8003666:	689a      	ldr	r2, [r3, #8]
 8003668:	9b00      	ldr	r3, [sp, #0]
 800366a:	689b      	ldr	r3, [r3, #8]
 800366c:	4293      	cmp	r3, r2
 800366e:	419b      	sbcs	r3, r3
 8003670:	425b      	negs	r3, r3
 8003672:	b2db      	uxtb	r3, r3
 8003674:	2b00      	cmp	r3, #0
 8003676:	d001      	beq.n	800367c <chSchRescheduleS+0x2c>
    __sch_reschedule_ahead();
 8003678:	f7ff fe52 	bl	8003320 <__sch_reschedule_ahead>
  }
}
 800367c:	46c0      	nop			@ (mov r8, r8)
 800367e:	b003      	add	sp, #12
 8003680:	bd00      	pop	{pc}
 8003682:	46c0      	nop			@ (mov r8, r8)
 8003684:	20000690 	.word	0x20000690
	...

08003690 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8003690:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 8003692:	4b0a      	ldr	r3, [pc, #40]	@ (80036bc <chSchIsPreemptionRequired+0x2c>)
 8003694:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 8003696:	9b03      	ldr	r3, [sp, #12]
 8003698:	68db      	ldr	r3, [r3, #12]
 800369a:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 800369c:	9b03      	ldr	r3, [sp, #12]
 800369e:	681b      	ldr	r3, [r3, #0]
 80036a0:	689b      	ldr	r3, [r3, #8]
 80036a2:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 80036a4:	9b02      	ldr	r3, [sp, #8]
 80036a6:	689b      	ldr	r3, [r3, #8]
 80036a8:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80036aa:	9b01      	ldr	r3, [sp, #4]
 80036ac:	9a00      	ldr	r2, [sp, #0]
 80036ae:	429a      	cmp	r2, r3
 80036b0:	419b      	sbcs	r3, r3
 80036b2:	425b      	negs	r3, r3
 80036b4:	b2db      	uxtb	r3, r3
#endif
}
 80036b6:	0018      	movs	r0, r3
 80036b8:	b004      	add	sp, #16
 80036ba:	4770      	bx	lr
 80036bc:	20000690 	.word	0x20000690

080036c0 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 80036c0:	b500      	push	{lr}
 80036c2:	b087      	sub	sp, #28
  os_instance_t *oip = currcore;
 80036c4:	4b1b      	ldr	r3, [pc, #108]	@ (8003734 <chSchDoPreemption+0x74>)
 80036c6:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 80036c8:	9b05      	ldr	r3, [sp, #20]
 80036ca:	68db      	ldr	r3, [r3, #12]
 80036cc:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 80036ce:	9b05      	ldr	r3, [sp, #20]
 80036d0:	0018      	movs	r0, r3
 80036d2:	f7ff fcfd 	bl	80030d0 <ch_pqueue_remove_highest>
 80036d6:	0003      	movs	r3, r0
 80036d8:	9303      	str	r3, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 80036da:	9b03      	ldr	r3, [sp, #12]
 80036dc:	2224      	movs	r2, #36	@ 0x24
 80036de:	2101      	movs	r1, #1
 80036e0:	5499      	strb	r1, [r3, r2]
  __instance_set_currthread(oip, ntp);
 80036e2:	9b05      	ldr	r3, [sp, #20]
 80036e4:	9a03      	ldr	r2, [sp, #12]
 80036e6:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 80036e8:	9b04      	ldr	r3, [sp, #16]
 80036ea:	0018      	movs	r0, r3
 80036ec:	f7ff fde0 	bl	80032b0 <__sch_ready_ahead>
 80036f0:	0003      	movs	r3, r0
 80036f2:	9304      	str	r3, [sp, #16]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80036f4:	9a04      	ldr	r2, [sp, #16]
 80036f6:	9b03      	ldr	r3, [sp, #12]
 80036f8:	0011      	movs	r1, r2
 80036fa:	0018      	movs	r0, r3
 80036fc:	f7fe fff8 	bl	80026f0 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003700:	f3ef 8309 	mrs	r3, PSP
 8003704:	9301      	str	r3, [sp, #4]
  return(result);
 8003706:	9b01      	ldr	r3, [sp, #4]
 8003708:	9302      	str	r3, [sp, #8]
 800370a:	9b02      	ldr	r3, [sp, #8]
 800370c:	3b24      	subs	r3, #36	@ 0x24
 800370e:	001a      	movs	r2, r3
 8003710:	9b04      	ldr	r3, [sp, #16]
 8003712:	6a1b      	ldr	r3, [r3, #32]
 8003714:	429a      	cmp	r2, r3
 8003716:	d203      	bcs.n	8003720 <chSchDoPreemption+0x60>
 8003718:	4b07      	ldr	r3, [pc, #28]	@ (8003738 <chSchDoPreemption+0x78>)
 800371a:	0018      	movs	r0, r3
 800371c:	f7fe fd70 	bl	8002200 <chSysHalt>
 8003720:	9a04      	ldr	r2, [sp, #16]
 8003722:	9b03      	ldr	r3, [sp, #12]
 8003724:	0011      	movs	r1, r2
 8003726:	0018      	movs	r0, r3
 8003728:	f7fc fd36 	bl	8000198 <__port_switch>
}
 800372c:	46c0      	nop			@ (mov r8, r8)
 800372e:	b007      	add	sp, #28
 8003730:	bd00      	pop	{pc}
 8003732:	46c0      	nop			@ (mov r8, r8)
 8003734:	20000690 	.word	0x20000690
 8003738:	0800522c 	.word	0x0800522c
 800373c:	00000000 	.word	0x00000000

08003740 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 8003740:	b082      	sub	sp, #8
 8003742:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 8003744:	9b01      	ldr	r3, [sp, #4]
 8003746:	2200      	movs	r2, #0
 8003748:	601a      	str	r2, [r3, #0]
}
 800374a:	46c0      	nop			@ (mov r8, r8)
 800374c:	b002      	add	sp, #8
 800374e:	4770      	bx	lr

08003750 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 8003750:	b082      	sub	sp, #8
 8003752:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 8003754:	9b01      	ldr	r3, [sp, #4]
 8003756:	2200      	movs	r2, #0
 8003758:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 800375a:	9b01      	ldr	r3, [sp, #4]
 800375c:	2200      	movs	r2, #0
 800375e:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 8003760:	9b01      	ldr	r3, [sp, #4]
 8003762:	2201      	movs	r2, #1
 8003764:	609a      	str	r2, [r3, #8]
#endif
}
 8003766:	46c0      	nop			@ (mov r8, r8)
 8003768:	b002      	add	sp, #8
 800376a:	4770      	bx	lr
 800376c:	0000      	movs	r0, r0
	...

08003770 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003770:	b082      	sub	sp, #8
 8003772:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8003774:	9b01      	ldr	r3, [sp, #4]
 8003776:	9a01      	ldr	r2, [sp, #4]
 8003778:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800377a:	9b01      	ldr	r3, [sp, #4]
 800377c:	9a01      	ldr	r2, [sp, #4]
 800377e:	605a      	str	r2, [r3, #4]
}
 8003780:	46c0      	nop			@ (mov r8, r8)
 8003782:	b002      	add	sp, #8
 8003784:	4770      	bx	lr
 8003786:	46c0      	nop			@ (mov r8, r8)
	...

08003790 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 8003790:	b082      	sub	sp, #8
 8003792:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 8003794:	9b01      	ldr	r3, [sp, #4]
 8003796:	9a01      	ldr	r2, [sp, #4]
 8003798:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 800379a:	9b01      	ldr	r3, [sp, #4]
 800379c:	9a01      	ldr	r2, [sp, #4]
 800379e:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 80037a0:	9b01      	ldr	r3, [sp, #4]
 80037a2:	2200      	movs	r2, #0
 80037a4:	609a      	str	r2, [r3, #8]
}
 80037a6:	46c0      	nop			@ (mov r8, r8)
 80037a8:	b002      	add	sp, #8
 80037aa:	4770      	bx	lr
 80037ac:	0000      	movs	r0, r0
	...

080037b0 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 80037b0:	b082      	sub	sp, #8
 80037b2:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 80037b4:	9b01      	ldr	r3, [sp, #4]
 80037b6:	9a01      	ldr	r2, [sp, #4]
 80037b8:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 80037ba:	9b01      	ldr	r3, [sp, #4]
 80037bc:	9a01      	ldr	r2, [sp, #4]
 80037be:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 80037c0:	9b01      	ldr	r3, [sp, #4]
 80037c2:	2201      	movs	r2, #1
 80037c4:	4252      	negs	r2, r2
 80037c6:	609a      	str	r2, [r3, #8]
}
 80037c8:	46c0      	nop			@ (mov r8, r8)
 80037ca:	b002      	add	sp, #8
 80037cc:	4770      	bx	lr
 80037ce:	46c0      	nop			@ (mov r8, r8)

080037d0 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 80037d0:	46c0      	nop			@ (mov r8, r8)
 80037d2:	4770      	bx	lr
	...

080037e0 <port_timer_get_time.lto_priv.2>:
static inline systime_t port_timer_get_time(void) {
 80037e0:	b510      	push	{r4, lr}
  return stGetCounter();
 80037e2:	f7fc fe0d 	bl	8000400 <stGetCounter>
 80037e6:	0003      	movs	r3, r0
}
 80037e8:	0018      	movs	r0, r3
 80037ea:	bd10      	pop	{r4, pc}
 80037ec:	0000      	movs	r0, r0
	...

080037f0 <chVTGetSystemTimeX.lto_priv.2>:
static inline systime_t chVTGetSystemTimeX(void) {
 80037f0:	b510      	push	{r4, lr}
  return port_timer_get_time();
 80037f2:	f7ff fff5 	bl	80037e0 <port_timer_get_time.lto_priv.2>
 80037f6:	0003      	movs	r3, r0
}
 80037f8:	0018      	movs	r0, r3
 80037fa:	bd10      	pop	{r4, pc}
 80037fc:	0000      	movs	r0, r0
	...

08003800 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 8003800:	b530      	push	{r4, r5, lr}
 8003802:	b083      	sub	sp, #12
 8003804:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 8003806:	9b01      	ldr	r3, [sp, #4]
 8003808:	0018      	movs	r0, r3
 800380a:	f7ff ffd1 	bl	80037b0 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 800380e:	9b01      	ldr	r3, [sp, #4]
 8003810:	2200      	movs	r2, #0
 8003812:	819a      	strh	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003814:	f7ff ffec 	bl	80037f0 <chVTGetSystemTimeX.lto_priv.2>
 8003818:	0003      	movs	r3, r0
 800381a:	001c      	movs	r4, r3
 800381c:	2300      	movs	r3, #0
 800381e:	001d      	movs	r5, r3
 8003820:	9b01      	ldr	r3, [sp, #4]
 8003822:	611c      	str	r4, [r3, #16]
 8003824:	615d      	str	r5, [r3, #20]
#endif
}
 8003826:	46c0      	nop			@ (mov r8, r8)
 8003828:	b003      	add	sp, #12
 800382a:	bd30      	pop	{r4, r5, pc}
 800382c:	0000      	movs	r0, r0
	...

08003830 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8003830:	b500      	push	{lr}
 8003832:	b083      	sub	sp, #12
 8003834:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 8003836:	9b01      	ldr	r3, [sp, #4]
 8003838:	0018      	movs	r0, r3
 800383a:	f7ff ff99 	bl	8003770 <ch_queue_init.lto_priv.2>
}
 800383e:	46c0      	nop			@ (mov r8, r8)
 8003840:	b003      	add	sp, #12
 8003842:	bd00      	pop	{pc}
	...

08003850 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8003850:	b500      	push	{lr}
 8003852:	b083      	sub	sp, #12
 8003854:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8003856:	f7ff ffbb 	bl	80037d0 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
    asm volatile ("nop");
 800385a:	46c0      	nop			@ (mov r8, r8)
    port_wait_for_interrupt();
 800385c:	46c0      	nop			@ (mov r8, r8)
 800385e:	e7fa      	b.n	8003856 <__idle_thread+0x6>

08003860 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8003860:	b500      	push	{lr}
 8003862:	b08b      	sub	sp, #44	@ 0x2c
 8003864:	9001      	str	r0, [sp, #4]
 8003866:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 8003868:	2300      	movs	r3, #0
 800386a:	9309      	str	r3, [sp, #36]	@ 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 800386c:	4a3a      	ldr	r2, [pc, #232]	@ (8003958 <chInstanceObjectInit+0xf8>)
 800386e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003870:	009b      	lsls	r3, r3, #2
 8003872:	18d3      	adds	r3, r2, r3
 8003874:	3304      	adds	r3, #4
 8003876:	681b      	ldr	r3, [r3, #0]
 8003878:	1e5a      	subs	r2, r3, #1
 800387a:	4193      	sbcs	r3, r2
 800387c:	b2db      	uxtb	r3, r3
 800387e:	2b00      	cmp	r3, #0
 8003880:	d003      	beq.n	800388a <chInstanceObjectInit+0x2a>
 8003882:	4b36      	ldr	r3, [pc, #216]	@ (800395c <chInstanceObjectInit+0xfc>)
 8003884:	0018      	movs	r0, r3
 8003886:	f7fe fcbb 	bl	8002200 <chSysHalt>
  ch_system.instances[core_id] = oip;
 800388a:	4a33      	ldr	r2, [pc, #204]	@ (8003958 <chInstanceObjectInit+0xf8>)
 800388c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800388e:	009b      	lsls	r3, r3, #2
 8003890:	18d3      	adds	r3, r2, r3
 8003892:	3304      	adds	r3, #4
 8003894:	9a01      	ldr	r2, [sp, #4]
 8003896:	601a      	str	r2, [r3, #0]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 8003898:	9b01      	ldr	r3, [sp, #4]
 800389a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800389c:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 800389e:	9b01      	ldr	r3, [sp, #4]
 80038a0:	9a00      	ldr	r2, [sp, #0]
 80038a2:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 80038a4:	9b01      	ldr	r3, [sp, #4]
 80038a6:	0018      	movs	r0, r3
 80038a8:	f001 fa1a 	bl	8004ce0 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 80038ac:	9b01      	ldr	r3, [sp, #4]
 80038ae:	0018      	movs	r0, r3
 80038b0:	f7ff ff6e 	bl	8003790 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 80038b4:	9b01      	ldr	r3, [sp, #4]
 80038b6:	3328      	adds	r3, #40	@ 0x28
 80038b8:	0018      	movs	r0, r3
 80038ba:	f7ff ffb9 	bl	8003830 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 80038be:	9b01      	ldr	r3, [sp, #4]
 80038c0:	3334      	adds	r3, #52	@ 0x34
 80038c2:	0018      	movs	r0, r3
 80038c4:	f7ff ff3c 	bl	8003740 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 80038c8:	9b01      	ldr	r3, [sp, #4]
 80038ca:	3310      	adds	r3, #16
 80038cc:	0018      	movs	r0, r3
 80038ce:	f7ff ff97 	bl	8003800 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 80038d2:	9b01      	ldr	r3, [sp, #4]
 80038d4:	3384      	adds	r3, #132	@ 0x84
 80038d6:	0018      	movs	r0, r3
 80038d8:	f7ff ff3a 	bl	8003750 <__dbg_object_init>

#if CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED
  /* Trace buffer initialization.*/
  __trace_object_init(&oip->trace_buffer);
 80038dc:	9b01      	ldr	r3, [sp, #4]
 80038de:	3390      	adds	r3, #144	@ 0x90
 80038e0:	0018      	movs	r0, r3
 80038e2:	f7fe fe9d 	bl	8002620 <__trace_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 80038e6:	9b01      	ldr	r3, [sp, #4]
 80038e8:	333c      	adds	r3, #60	@ 0x3c
 80038ea:	0019      	movs	r1, r3
 80038ec:	4a1c      	ldr	r2, [pc, #112]	@ (8003960 <chInstanceObjectInit+0x100>)
 80038ee:	9801      	ldr	r0, [sp, #4]
 80038f0:	2380      	movs	r3, #128	@ 0x80
 80038f2:	f000 f905 	bl	8003b00 <__thd_object_init>
 80038f6:	0002      	movs	r2, r0
 80038f8:	9b01      	ldr	r3, [sp, #4]
 80038fa:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 80038fc:	9b01      	ldr	r3, [sp, #4]
 80038fe:	68db      	ldr	r3, [r3, #12]
 8003900:	9a00      	ldr	r2, [sp, #0]
 8003902:	6852      	ldr	r2, [r2, #4]
 8003904:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8003906:	9b01      	ldr	r3, [sp, #4]
 8003908:	68db      	ldr	r3, [r3, #12]
 800390a:	2224      	movs	r2, #36	@ 0x24
 800390c:	2101      	movs	r1, #1
 800390e:	5499      	strb	r1, [r3, r2]
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 8003910:	ab03      	add	r3, sp, #12
 8003912:	4a14      	ldr	r2, [pc, #80]	@ (8003964 <chInstanceObjectInit+0x104>)
 8003914:	601a      	str	r2, [r3, #0]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8003916:	9b00      	ldr	r3, [sp, #0]
 8003918:	68da      	ldr	r2, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 800391a:	ab03      	add	r3, sp, #12
 800391c:	605a      	str	r2, [r3, #4]
      .wend     = oicp->idlethread_end,
 800391e:	9b00      	ldr	r3, [sp, #0]
 8003920:	691a      	ldr	r2, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 8003922:	ab03      	add	r3, sp, #12
 8003924:	609a      	str	r2, [r3, #8]
 8003926:	ab03      	add	r3, sp, #12
 8003928:	2201      	movs	r2, #1
 800392a:	60da      	str	r2, [r3, #12]
 800392c:	ab03      	add	r3, sp, #12
 800392e:	4a0e      	ldr	r2, [pc, #56]	@ (8003968 <chInstanceObjectInit+0x108>)
 8003930:	611a      	str	r2, [r3, #16]
 8003932:	ab03      	add	r3, sp, #12
 8003934:	2200      	movs	r2, #0
 8003936:	615a      	str	r2, [r3, #20]
      .funcp    = __idle_thread,
      .arg      = NULL
    };

#if CH_DBG_FILL_THREADS == TRUE
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 8003938:	ab03      	add	r3, sp, #12
 800393a:	685a      	ldr	r2, [r3, #4]
                    (uint8_t *)idle_descriptor.wend);
 800393c:	ab03      	add	r3, sp, #12
 800393e:	689b      	ldr	r3, [r3, #8]
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 8003940:	0019      	movs	r1, r3
 8003942:	0010      	movs	r0, r2
 8003944:	f000 f91c 	bl	8003b80 <__thd_stackfill>
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 8003948:	ab03      	add	r3, sp, #12
 800394a:	0018      	movs	r0, r3
 800394c:	f000 f9c0 	bl	8003cd0 <chThdCreateI>
  }
#endif
}
 8003950:	46c0      	nop			@ (mov r8, r8)
 8003952:	b00b      	add	sp, #44	@ 0x2c
 8003954:	bd00      	pop	{pc}
 8003956:	46c0      	nop			@ (mov r8, r8)
 8003958:	20000684 	.word	0x20000684
 800395c:	08005360 	.word	0x08005360
 8003960:	08005410 	.word	0x08005410
 8003964:	0800523c 	.word	0x0800523c
 8003968:	08003851 	.word	0x08003851
 800396c:	00000000 	.word	0x00000000

08003970 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 8003970:	b082      	sub	sp, #8
 8003972:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 8003974:	9b01      	ldr	r3, [sp, #4]
 8003976:	9a01      	ldr	r2, [sp, #4]
 8003978:	601a      	str	r2, [r3, #0]
}
 800397a:	46c0      	nop			@ (mov r8, r8)
 800397c:	b002      	add	sp, #8
 800397e:	4770      	bx	lr

08003980 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 8003980:	b082      	sub	sp, #8
 8003982:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 8003984:	9b01      	ldr	r3, [sp, #4]
 8003986:	681b      	ldr	r3, [r3, #0]
 8003988:	9a01      	ldr	r2, [sp, #4]
 800398a:	1ad3      	subs	r3, r2, r3
 800398c:	1e5a      	subs	r2, r3, #1
 800398e:	4193      	sbcs	r3, r2
 8003990:	b2db      	uxtb	r3, r3
}
 8003992:	0018      	movs	r0, r3
 8003994:	b002      	add	sp, #8
 8003996:	4770      	bx	lr
	...

080039a0 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 80039a0:	b084      	sub	sp, #16
 80039a2:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 80039a4:	9b01      	ldr	r3, [sp, #4]
 80039a6:	681b      	ldr	r3, [r3, #0]
 80039a8:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 80039aa:	9b03      	ldr	r3, [sp, #12]
 80039ac:	681a      	ldr	r2, [r3, #0]
 80039ae:	9b01      	ldr	r3, [sp, #4]
 80039b0:	601a      	str	r2, [r3, #0]
  return p;
 80039b2:	9b03      	ldr	r3, [sp, #12]
}
 80039b4:	0018      	movs	r0, r3
 80039b6:	b004      	add	sp, #16
 80039b8:	4770      	bx	lr
 80039ba:	46c0      	nop			@ (mov r8, r8)
 80039bc:	0000      	movs	r0, r0
	...

080039c0 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80039c0:	b082      	sub	sp, #8
 80039c2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80039c4:	9b01      	ldr	r3, [sp, #4]
 80039c6:	9a01      	ldr	r2, [sp, #4]
 80039c8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80039ca:	9b01      	ldr	r3, [sp, #4]
 80039cc:	9a01      	ldr	r2, [sp, #4]
 80039ce:	605a      	str	r2, [r3, #4]
}
 80039d0:	46c0      	nop			@ (mov r8, r8)
 80039d2:	b002      	add	sp, #8
 80039d4:	4770      	bx	lr
 80039d6:	46c0      	nop			@ (mov r8, r8)
	...

080039e0 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 80039e0:	b082      	sub	sp, #8
 80039e2:	9001      	str	r0, [sp, #4]
 80039e4:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 80039e6:	9b00      	ldr	r3, [sp, #0]
 80039e8:	9a01      	ldr	r2, [sp, #4]
 80039ea:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 80039ec:	9b01      	ldr	r3, [sp, #4]
 80039ee:	685a      	ldr	r2, [r3, #4]
 80039f0:	9b00      	ldr	r3, [sp, #0]
 80039f2:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 80039f4:	9b00      	ldr	r3, [sp, #0]
 80039f6:	685b      	ldr	r3, [r3, #4]
 80039f8:	9a00      	ldr	r2, [sp, #0]
 80039fa:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 80039fc:	9b01      	ldr	r3, [sp, #4]
 80039fe:	9a00      	ldr	r2, [sp, #0]
 8003a00:	605a      	str	r2, [r3, #4]
}
 8003a02:	46c0      	nop			@ (mov r8, r8)
 8003a04:	b002      	add	sp, #8
 8003a06:	4770      	bx	lr
	...

08003a10 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003a10:	b082      	sub	sp, #8
 8003a12:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003a14:	9b01      	ldr	r3, [sp, #4]
 8003a16:	685b      	ldr	r3, [r3, #4]
 8003a18:	9a01      	ldr	r2, [sp, #4]
 8003a1a:	6812      	ldr	r2, [r2, #0]
 8003a1c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8003a1e:	9b01      	ldr	r3, [sp, #4]
 8003a20:	681b      	ldr	r3, [r3, #0]
 8003a22:	9a01      	ldr	r2, [sp, #4]
 8003a24:	6852      	ldr	r2, [r2, #4]
 8003a26:	605a      	str	r2, [r3, #4]
  return p;
 8003a28:	9b01      	ldr	r3, [sp, #4]
}
 8003a2a:	0018      	movs	r0, r3
 8003a2c:	b002      	add	sp, #8
 8003a2e:	4770      	bx	lr

08003a30 <port_lock.lto_priv.12>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003a30:	b672      	cpsid	i
}
 8003a32:	46c0      	nop			@ (mov r8, r8)
}
 8003a34:	46c0      	nop			@ (mov r8, r8)
 8003a36:	4770      	bx	lr
	...

08003a40 <port_unlock.lto_priv.12>:
  __ASM volatile ("cpsie i" : : : "memory");
 8003a40:	b662      	cpsie	i
}
 8003a42:	46c0      	nop			@ (mov r8, r8)
}
 8003a44:	46c0      	nop			@ (mov r8, r8)
 8003a46:	4770      	bx	lr
	...

08003a50 <chSysLock.lto_priv.7>:
static inline void chSysLock(void) {
 8003a50:	b510      	push	{r4, lr}
  port_lock();
 8003a52:	f7ff ffed 	bl	8003a30 <port_lock.lto_priv.12>
  __dbg_check_lock();
 8003a56:	f7fe fc43 	bl	80022e0 <__dbg_check_lock>
}
 8003a5a:	46c0      	nop			@ (mov r8, r8)
 8003a5c:	bd10      	pop	{r4, pc}
 8003a5e:	46c0      	nop			@ (mov r8, r8)

08003a60 <chSysUnlock.lto_priv.7>:
static inline void chSysUnlock(void) {
 8003a60:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8003a62:	f7fe fc65 	bl	8002330 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003a66:	4b0e      	ldr	r3, [pc, #56]	@ (8003aa0 <chSysUnlock.lto_priv.7+0x40>)
 8003a68:	681a      	ldr	r2, [r3, #0]
 8003a6a:	4b0d      	ldr	r3, [pc, #52]	@ (8003aa0 <chSysUnlock.lto_priv.7+0x40>)
 8003a6c:	1ad3      	subs	r3, r2, r3
 8003a6e:	1e5a      	subs	r2, r3, #1
 8003a70:	4193      	sbcs	r3, r2
 8003a72:	b2db      	uxtb	r3, r3
 8003a74:	2b00      	cmp	r3, #0
 8003a76:	d00f      	beq.n	8003a98 <chSysUnlock.lto_priv.7+0x38>
 8003a78:	4b09      	ldr	r3, [pc, #36]	@ (8003aa0 <chSysUnlock.lto_priv.7+0x40>)
 8003a7a:	68db      	ldr	r3, [r3, #12]
 8003a7c:	689a      	ldr	r2, [r3, #8]
 8003a7e:	4b08      	ldr	r3, [pc, #32]	@ (8003aa0 <chSysUnlock.lto_priv.7+0x40>)
 8003a80:	681b      	ldr	r3, [r3, #0]
 8003a82:	689b      	ldr	r3, [r3, #8]
 8003a84:	429a      	cmp	r2, r3
 8003a86:	419b      	sbcs	r3, r3
 8003a88:	425b      	negs	r3, r3
 8003a8a:	b2db      	uxtb	r3, r3
 8003a8c:	2b00      	cmp	r3, #0
 8003a8e:	d003      	beq.n	8003a98 <chSysUnlock.lto_priv.7+0x38>
 8003a90:	4b04      	ldr	r3, [pc, #16]	@ (8003aa4 <chSysUnlock.lto_priv.7+0x44>)
 8003a92:	0018      	movs	r0, r3
 8003a94:	f7fe fbb4 	bl	8002200 <chSysHalt>
  port_unlock();
 8003a98:	f7ff ffd2 	bl	8003a40 <port_unlock.lto_priv.12>
}
 8003a9c:	46c0      	nop			@ (mov r8, r8)
 8003a9e:	bd10      	pop	{r4, pc}
 8003aa0:	20000690 	.word	0x20000690
 8003aa4:	08005390 	.word	0x08005390
	...

08003ab0 <chThdGetSelfX.lto_priv.0>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8003ab0:	4b01      	ldr	r3, [pc, #4]	@ (8003ab8 <chThdGetSelfX.lto_priv.0+0x8>)
 8003ab2:	68db      	ldr	r3, [r3, #12]
}
 8003ab4:	0018      	movs	r0, r3
 8003ab6:	4770      	bx	lr
 8003ab8:	20000690 	.word	0x20000690
 8003abc:	00000000 	.word	0x00000000

08003ac0 <chThdGetWorkingAreaX.lto_priv.0>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8003ac0:	b082      	sub	sp, #8
 8003ac2:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 8003ac4:	9b01      	ldr	r3, [sp, #4]
 8003ac6:	6a1b      	ldr	r3, [r3, #32]
}
 8003ac8:	0018      	movs	r0, r3
 8003aca:	b002      	add	sp, #8
 8003acc:	4770      	bx	lr
 8003ace:	46c0      	nop			@ (mov r8, r8)

08003ad0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 8003ad0:	b500      	push	{lr}
 8003ad2:	b083      	sub	sp, #12
 8003ad4:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8003ad6:	9b01      	ldr	r3, [sp, #4]
 8003ad8:	425a      	negs	r2, r3
 8003ada:	4153      	adcs	r3, r2
 8003adc:	b2db      	uxtb	r3, r3
 8003ade:	2b00      	cmp	r3, #0
 8003ae0:	d003      	beq.n	8003aea <chThdSleepS+0x1a>
 8003ae2:	4b06      	ldr	r3, [pc, #24]	@ (8003afc <chThdSleepS+0x2c>)
 8003ae4:	0018      	movs	r0, r3
 8003ae6:	f7fe fb8b 	bl	8002200 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8003aea:	9b01      	ldr	r3, [sp, #4]
 8003aec:	0019      	movs	r1, r3
 8003aee:	2008      	movs	r0, #8
 8003af0:	f7ff fd0e 	bl	8003510 <chSchGoSleepTimeoutS>
}
 8003af4:	46c0      	nop			@ (mov r8, r8)
 8003af6:	b003      	add	sp, #12
 8003af8:	bd00      	pop	{pc}
 8003afa:	46c0      	nop			@ (mov r8, r8)
 8003afc:	080053cc 	.word	0x080053cc

08003b00 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8003b00:	b500      	push	{lr}
 8003b02:	b085      	sub	sp, #20
 8003b04:	9003      	str	r0, [sp, #12]
 8003b06:	9102      	str	r1, [sp, #8]
 8003b08:	9201      	str	r2, [sp, #4]
 8003b0a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 8003b0c:	9b02      	ldr	r3, [sp, #8]
 8003b0e:	9a00      	ldr	r2, [sp, #0]
 8003b10:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8003b12:	9b02      	ldr	r3, [sp, #8]
 8003b14:	2224      	movs	r2, #36	@ 0x24
 8003b16:	2102      	movs	r1, #2
 8003b18:	5499      	strb	r1, [r3, r2]
  tp->flags             = CH_FLAG_MODE_STATIC;
 8003b1a:	9b02      	ldr	r3, [sp, #8]
 8003b1c:	2225      	movs	r2, #37	@ 0x25
 8003b1e:	2100      	movs	r1, #0
 8003b20:	5499      	strb	r1, [r3, r2]
  tp->owner             = oip;
 8003b22:	9b02      	ldr	r3, [sp, #8]
 8003b24:	9a03      	ldr	r2, [sp, #12]
 8003b26:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8003b28:	9b02      	ldr	r3, [sp, #8]
 8003b2a:	9a00      	ldr	r2, [sp, #0]
 8003b2c:	641a      	str	r2, [r3, #64]	@ 0x40
  tp->mtxlist           = NULL;
 8003b2e:	9b02      	ldr	r3, [sp, #8]
 8003b30:	2200      	movs	r2, #0
 8003b32:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8003b34:	9b02      	ldr	r3, [sp, #8]
 8003b36:	2200      	movs	r2, #0
 8003b38:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 8003b3a:	9b02      	ldr	r3, [sp, #8]
 8003b3c:	2226      	movs	r2, #38	@ 0x26
 8003b3e:	2101      	movs	r1, #1
 8003b40:	5499      	strb	r1, [r3, r2]
  tp->name              = name;
 8003b42:	9b02      	ldr	r3, [sp, #8]
 8003b44:	9a01      	ldr	r2, [sp, #4]
 8003b46:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 8003b48:	9b03      	ldr	r3, [sp, #12]
 8003b4a:	3328      	adds	r3, #40	@ 0x28
 8003b4c:	001a      	movs	r2, r3
 8003b4e:	9b02      	ldr	r3, [sp, #8]
 8003b50:	3310      	adds	r3, #16
 8003b52:	0019      	movs	r1, r3
 8003b54:	0010      	movs	r0, r2
 8003b56:	f7ff ff43 	bl	80039e0 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 8003b5a:	9b02      	ldr	r3, [sp, #8]
 8003b5c:	332c      	adds	r3, #44	@ 0x2c
 8003b5e:	0018      	movs	r0, r3
 8003b60:	f7ff ff06 	bl	8003970 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8003b64:	9b02      	ldr	r3, [sp, #8]
 8003b66:	3330      	adds	r3, #48	@ 0x30
 8003b68:	0018      	movs	r0, r3
 8003b6a:	f7ff ff29 	bl	80039c0 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8003b6e:	9b02      	ldr	r3, [sp, #8]
}
 8003b70:	0018      	movs	r0, r3
 8003b72:	b005      	add	sp, #20
 8003b74:	bd00      	pop	{pc}
 8003b76:	46c0      	nop			@ (mov r8, r8)
	...

08003b80 <__thd_stackfill>:
 * @param[in] startp    first address to fill
 * @param[in] endp      last address to fill +1
 *
 * @notapi
 */
void __thd_stackfill(uint8_t *startp, uint8_t *endp) {
 8003b80:	b082      	sub	sp, #8
 8003b82:	9001      	str	r0, [sp, #4]
 8003b84:	9100      	str	r1, [sp, #0]

  do {
    *startp++ = CH_DBG_STACK_FILL_VALUE;
 8003b86:	9b01      	ldr	r3, [sp, #4]
 8003b88:	1c5a      	adds	r2, r3, #1
 8003b8a:	9201      	str	r2, [sp, #4]
 8003b8c:	2255      	movs	r2, #85	@ 0x55
 8003b8e:	701a      	strb	r2, [r3, #0]
  } while (likely(startp < endp));
 8003b90:	9a01      	ldr	r2, [sp, #4]
 8003b92:	9b00      	ldr	r3, [sp, #0]
 8003b94:	429a      	cmp	r2, r3
 8003b96:	419b      	sbcs	r3, r3
 8003b98:	425b      	negs	r3, r3
 8003b9a:	b2db      	uxtb	r3, r3
 8003b9c:	2b00      	cmp	r3, #0
 8003b9e:	d1f2      	bne.n	8003b86 <__thd_stackfill+0x6>
}
 8003ba0:	46c0      	nop			@ (mov r8, r8)
 8003ba2:	46c0      	nop			@ (mov r8, r8)
 8003ba4:	b002      	add	sp, #8
 8003ba6:	4770      	bx	lr
	...

08003bb0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8003bb0:	b500      	push	{lr}
 8003bb2:	b085      	sub	sp, #20
 8003bb4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8003bb6:	f7fe fc93 	bl	80024e0 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8003bba:	9b01      	ldr	r3, [sp, #4]
 8003bbc:	425a      	negs	r2, r3
 8003bbe:	4153      	adcs	r3, r2
 8003bc0:	b2db      	uxtb	r3, r3
 8003bc2:	2b00      	cmp	r3, #0
 8003bc4:	d003      	beq.n	8003bce <chThdCreateSuspendedI+0x1e>
 8003bc6:	4b3c      	ldr	r3, [pc, #240]	@ (8003cb8 <chThdCreateSuspendedI+0x108>)
 8003bc8:	0018      	movs	r0, r3
 8003bca:	f7fe fb19 	bl	8002200 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8003bce:	9b01      	ldr	r3, [sp, #4]
 8003bd0:	685b      	ldr	r3, [r3, #4]
 8003bd2:	001a      	movs	r2, r3
 8003bd4:	2307      	movs	r3, #7
 8003bd6:	4013      	ands	r3, r2
 8003bd8:	1e5a      	subs	r2, r3, #1
 8003bda:	4193      	sbcs	r3, r2
 8003bdc:	b2db      	uxtb	r3, r3
 8003bde:	2b00      	cmp	r3, #0
 8003be0:	d109      	bne.n	8003bf6 <chThdCreateSuspendedI+0x46>
 8003be2:	9b01      	ldr	r3, [sp, #4]
 8003be4:	689b      	ldr	r3, [r3, #8]
 8003be6:	001a      	movs	r2, r3
 8003be8:	2307      	movs	r3, #7
 8003bea:	4013      	ands	r3, r2
 8003bec:	1e5a      	subs	r2, r3, #1
 8003bee:	4193      	sbcs	r3, r2
 8003bf0:	b2db      	uxtb	r3, r3
 8003bf2:	2b00      	cmp	r3, #0
 8003bf4:	d001      	beq.n	8003bfa <chThdCreateSuspendedI+0x4a>
 8003bf6:	2301      	movs	r3, #1
 8003bf8:	e000      	b.n	8003bfc <chThdCreateSuspendedI+0x4c>
 8003bfa:	2300      	movs	r3, #0
 8003bfc:	2b00      	cmp	r3, #0
 8003bfe:	d109      	bne.n	8003c14 <chThdCreateSuspendedI+0x64>
 8003c00:	9b01      	ldr	r3, [sp, #4]
 8003c02:	689a      	ldr	r2, [r3, #8]
 8003c04:	9b01      	ldr	r3, [sp, #4]
 8003c06:	6859      	ldr	r1, [r3, #4]
 8003c08:	2300      	movs	r3, #0
 8003c0a:	4291      	cmp	r1, r2
 8003c0c:	415b      	adcs	r3, r3
 8003c0e:	b2db      	uxtb	r3, r3
 8003c10:	2b00      	cmp	r3, #0
 8003c12:	d001      	beq.n	8003c18 <chThdCreateSuspendedI+0x68>
 8003c14:	2301      	movs	r3, #1
 8003c16:	e000      	b.n	8003c1a <chThdCreateSuspendedI+0x6a>
 8003c18:	2300      	movs	r3, #0
 8003c1a:	2b00      	cmp	r3, #0
 8003c1c:	d10c      	bne.n	8003c38 <chThdCreateSuspendedI+0x88>
 8003c1e:	9b01      	ldr	r3, [sp, #4]
 8003c20:	689b      	ldr	r3, [r3, #8]
 8003c22:	001a      	movs	r2, r3
 8003c24:	9b01      	ldr	r3, [sp, #4]
 8003c26:	685b      	ldr	r3, [r3, #4]
 8003c28:	1ad2      	subs	r2, r2, r3
 8003c2a:	21cf      	movs	r1, #207	@ 0xcf
 8003c2c:	2300      	movs	r3, #0
 8003c2e:	4291      	cmp	r1, r2
 8003c30:	415b      	adcs	r3, r3
 8003c32:	b2db      	uxtb	r3, r3
 8003c34:	2b00      	cmp	r3, #0
 8003c36:	d003      	beq.n	8003c40 <chThdCreateSuspendedI+0x90>
 8003c38:	4b1f      	ldr	r3, [pc, #124]	@ (8003cb8 <chThdCreateSuspendedI+0x108>)
 8003c3a:	0018      	movs	r0, r3
 8003c3c:	f7fe fae0 	bl	8002200 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8003c40:	9b01      	ldr	r3, [sp, #4]
 8003c42:	68db      	ldr	r3, [r3, #12]
 8003c44:	22ff      	movs	r2, #255	@ 0xff
 8003c46:	429a      	cmp	r2, r3
 8003c48:	419b      	sbcs	r3, r3
 8003c4a:	425b      	negs	r3, r3
 8003c4c:	b2db      	uxtb	r3, r3
 8003c4e:	2b00      	cmp	r3, #0
 8003c50:	d106      	bne.n	8003c60 <chThdCreateSuspendedI+0xb0>
 8003c52:	9b01      	ldr	r3, [sp, #4]
 8003c54:	691b      	ldr	r3, [r3, #16]
 8003c56:	425a      	negs	r2, r3
 8003c58:	4153      	adcs	r3, r2
 8003c5a:	b2db      	uxtb	r3, r3
 8003c5c:	2b00      	cmp	r3, #0
 8003c5e:	d003      	beq.n	8003c68 <chThdCreateSuspendedI+0xb8>
 8003c60:	4b15      	ldr	r3, [pc, #84]	@ (8003cb8 <chThdCreateSuspendedI+0x108>)
 8003c62:	0018      	movs	r0, r3
 8003c64:	f7fe facc 	bl	8002200 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 8003c68:	9b01      	ldr	r3, [sp, #4]
 8003c6a:	689b      	ldr	r3, [r3, #8]
 8003c6c:	3b48      	subs	r3, #72	@ 0x48
 8003c6e:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8003c70:	9b01      	ldr	r3, [sp, #4]
 8003c72:	685a      	ldr	r2, [r3, #4]
 8003c74:	9b03      	ldr	r3, [sp, #12]
 8003c76:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003c78:	9b03      	ldr	r3, [sp, #12]
 8003c7a:	3b24      	subs	r3, #36	@ 0x24
 8003c7c:	001a      	movs	r2, r3
 8003c7e:	9b03      	ldr	r3, [sp, #12]
 8003c80:	60da      	str	r2, [r3, #12]
 8003c82:	9b01      	ldr	r3, [sp, #4]
 8003c84:	691a      	ldr	r2, [r3, #16]
 8003c86:	9b03      	ldr	r3, [sp, #12]
 8003c88:	68db      	ldr	r3, [r3, #12]
 8003c8a:	611a      	str	r2, [r3, #16]
 8003c8c:	9b01      	ldr	r3, [sp, #4]
 8003c8e:	695a      	ldr	r2, [r3, #20]
 8003c90:	9b03      	ldr	r3, [sp, #12]
 8003c92:	68db      	ldr	r3, [r3, #12]
 8003c94:	615a      	str	r2, [r3, #20]
 8003c96:	9b03      	ldr	r3, [sp, #12]
 8003c98:	68db      	ldr	r3, [r3, #12]
 8003c9a:	4a08      	ldr	r2, [pc, #32]	@ (8003cbc <chThdCreateSuspendedI+0x10c>)
 8003c9c:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8003c9e:	9b01      	ldr	r3, [sp, #4]
 8003ca0:	681a      	ldr	r2, [r3, #0]
 8003ca2:	9b01      	ldr	r3, [sp, #4]
 8003ca4:	68db      	ldr	r3, [r3, #12]
 8003ca6:	9903      	ldr	r1, [sp, #12]
 8003ca8:	4805      	ldr	r0, [pc, #20]	@ (8003cc0 <chThdCreateSuspendedI+0x110>)
 8003caa:	f7ff ff29 	bl	8003b00 <__thd_object_init>
 8003cae:	0003      	movs	r3, r0
}
 8003cb0:	0018      	movs	r0, r3
 8003cb2:	b005      	add	sp, #20
 8003cb4:	bd00      	pop	{pc}
 8003cb6:	46c0      	nop			@ (mov r8, r8)
 8003cb8:	08005378 	.word	0x08005378
 8003cbc:	080001b9 	.word	0x080001b9
 8003cc0:	20000690 	.word	0x20000690
	...

08003cd0 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8003cd0:	b500      	push	{lr}
 8003cd2:	b083      	sub	sp, #12
 8003cd4:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8003cd6:	9b01      	ldr	r3, [sp, #4]
 8003cd8:	0018      	movs	r0, r3
 8003cda:	f7ff ff69 	bl	8003bb0 <chThdCreateSuspendedI>
 8003cde:	0003      	movs	r3, r0
 8003ce0:	0018      	movs	r0, r3
 8003ce2:	f7ff fb95 	bl	8003410 <chSchReadyI>
 8003ce6:	0003      	movs	r3, r0
}
 8003ce8:	0018      	movs	r0, r3
 8003cea:	b003      	add	sp, #12
 8003cec:	bd00      	pop	{pc}
 8003cee:	46c0      	nop			@ (mov r8, r8)

08003cf0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003cf0:	b500      	push	{lr}
 8003cf2:	b087      	sub	sp, #28
 8003cf4:	9003      	str	r0, [sp, #12]
 8003cf6:	9102      	str	r1, [sp, #8]
 8003cf8:	9201      	str	r2, [sp, #4]
 8003cfa:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 8003cfc:	9b03      	ldr	r3, [sp, #12]
 8003cfe:	425a      	negs	r2, r3
 8003d00:	4153      	adcs	r3, r2
 8003d02:	b2db      	uxtb	r3, r3
 8003d04:	2b00      	cmp	r3, #0
 8003d06:	d107      	bne.n	8003d18 <chThdCreateStatic+0x28>
 8003d08:	9b03      	ldr	r3, [sp, #12]
 8003d0a:	2207      	movs	r2, #7
 8003d0c:	4013      	ands	r3, r2
 8003d0e:	1e5a      	subs	r2, r3, #1
 8003d10:	4193      	sbcs	r3, r2
 8003d12:	b2db      	uxtb	r3, r3
 8003d14:	2b00      	cmp	r3, #0
 8003d16:	d001      	beq.n	8003d1c <chThdCreateStatic+0x2c>
 8003d18:	2301      	movs	r3, #1
 8003d1a:	e000      	b.n	8003d1e <chThdCreateStatic+0x2e>
 8003d1c:	2300      	movs	r3, #0
 8003d1e:	2b00      	cmp	r3, #0
 8003d20:	d107      	bne.n	8003d32 <chThdCreateStatic+0x42>
 8003d22:	9a02      	ldr	r2, [sp, #8]
 8003d24:	21cf      	movs	r1, #207	@ 0xcf
 8003d26:	2300      	movs	r3, #0
 8003d28:	4291      	cmp	r1, r2
 8003d2a:	415b      	adcs	r3, r3
 8003d2c:	b2db      	uxtb	r3, r3
 8003d2e:	2b00      	cmp	r3, #0
 8003d30:	d001      	beq.n	8003d36 <chThdCreateStatic+0x46>
 8003d32:	2301      	movs	r3, #1
 8003d34:	e000      	b.n	8003d38 <chThdCreateStatic+0x48>
 8003d36:	2300      	movs	r3, #0
 8003d38:	2b00      	cmp	r3, #0
 8003d3a:	d107      	bne.n	8003d4c <chThdCreateStatic+0x5c>
 8003d3c:	9b02      	ldr	r3, [sp, #8]
 8003d3e:	2207      	movs	r2, #7
 8003d40:	4013      	ands	r3, r2
 8003d42:	1e5a      	subs	r2, r3, #1
 8003d44:	4193      	sbcs	r3, r2
 8003d46:	b2db      	uxtb	r3, r3
 8003d48:	2b00      	cmp	r3, #0
 8003d4a:	d001      	beq.n	8003d50 <chThdCreateStatic+0x60>
 8003d4c:	2301      	movs	r3, #1
 8003d4e:	e000      	b.n	8003d52 <chThdCreateStatic+0x62>
 8003d50:	2300      	movs	r3, #0
 8003d52:	2b00      	cmp	r3, #0
 8003d54:	d107      	bne.n	8003d66 <chThdCreateStatic+0x76>
 8003d56:	9b01      	ldr	r3, [sp, #4]
 8003d58:	22ff      	movs	r2, #255	@ 0xff
 8003d5a:	429a      	cmp	r2, r3
 8003d5c:	419b      	sbcs	r3, r3
 8003d5e:	425b      	negs	r3, r3
 8003d60:	b2db      	uxtb	r3, r3
 8003d62:	2b00      	cmp	r3, #0
 8003d64:	d001      	beq.n	8003d6a <chThdCreateStatic+0x7a>
 8003d66:	2301      	movs	r3, #1
 8003d68:	e000      	b.n	8003d6c <chThdCreateStatic+0x7c>
 8003d6a:	2300      	movs	r3, #0
 8003d6c:	2b00      	cmp	r3, #0
 8003d6e:	d105      	bne.n	8003d7c <chThdCreateStatic+0x8c>
 8003d70:	9b00      	ldr	r3, [sp, #0]
 8003d72:	425a      	negs	r2, r3
 8003d74:	4153      	adcs	r3, r2
 8003d76:	b2db      	uxtb	r3, r3
 8003d78:	2b00      	cmp	r3, #0
 8003d7a:	d003      	beq.n	8003d84 <chThdCreateStatic+0x94>
 8003d7c:	4b23      	ldr	r3, [pc, #140]	@ (8003e0c <chThdCreateStatic+0x11c>)
 8003d7e:	0018      	movs	r0, r3
 8003d80:	f7fe fa3e 	bl	8002200 <chSysHalt>
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8003d84:	9b03      	ldr	r3, [sp, #12]
 8003d86:	0018      	movs	r0, r3
 8003d88:	f000 fa22 	bl	80041d0 <chRegFindThreadByWorkingArea>
 8003d8c:	0003      	movs	r3, r0
 8003d8e:	1e5a      	subs	r2, r3, #1
 8003d90:	4193      	sbcs	r3, r2
 8003d92:	b2db      	uxtb	r3, r3
 8003d94:	2b00      	cmp	r3, #0
 8003d96:	d003      	beq.n	8003da0 <chThdCreateStatic+0xb0>
 8003d98:	4b1c      	ldr	r3, [pc, #112]	@ (8003e0c <chThdCreateStatic+0x11c>)
 8003d9a:	0018      	movs	r0, r3
 8003d9c:	f7fe fa30 	bl	8002200 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wsp, (uint8_t *)wsp + size);
 8003da0:	9a03      	ldr	r2, [sp, #12]
 8003da2:	9b02      	ldr	r3, [sp, #8]
 8003da4:	18d2      	adds	r2, r2, r3
 8003da6:	9b03      	ldr	r3, [sp, #12]
 8003da8:	0011      	movs	r1, r2
 8003daa:	0018      	movs	r0, r3
 8003dac:	f7ff fee8 	bl	8003b80 <__thd_stackfill>
#endif

  chSysLock();
 8003db0:	f7ff fe4e 	bl	8003a50 <chSysLock.lto_priv.7>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 8003db4:	9b02      	ldr	r3, [sp, #8]
 8003db6:	3b48      	subs	r3, #72	@ 0x48
 8003db8:	9a03      	ldr	r2, [sp, #12]
 8003dba:	18d3      	adds	r3, r2, r3
 8003dbc:	9305      	str	r3, [sp, #20]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8003dbe:	9b05      	ldr	r3, [sp, #20]
 8003dc0:	9a03      	ldr	r2, [sp, #12]
 8003dc2:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003dc4:	9b05      	ldr	r3, [sp, #20]
 8003dc6:	3b24      	subs	r3, #36	@ 0x24
 8003dc8:	001a      	movs	r2, r3
 8003dca:	9b05      	ldr	r3, [sp, #20]
 8003dcc:	60da      	str	r2, [r3, #12]
 8003dce:	9b05      	ldr	r3, [sp, #20]
 8003dd0:	68db      	ldr	r3, [r3, #12]
 8003dd2:	9a00      	ldr	r2, [sp, #0]
 8003dd4:	611a      	str	r2, [r3, #16]
 8003dd6:	9b05      	ldr	r3, [sp, #20]
 8003dd8:	68db      	ldr	r3, [r3, #12]
 8003dda:	9a08      	ldr	r2, [sp, #32]
 8003ddc:	615a      	str	r2, [r3, #20]
 8003dde:	9b05      	ldr	r3, [sp, #20]
 8003de0:	68db      	ldr	r3, [r3, #12]
 8003de2:	4a0b      	ldr	r2, [pc, #44]	@ (8003e10 <chThdCreateStatic+0x120>)
 8003de4:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 8003de6:	9b01      	ldr	r3, [sp, #4]
 8003de8:	4a0a      	ldr	r2, [pc, #40]	@ (8003e14 <chThdCreateStatic+0x124>)
 8003dea:	9905      	ldr	r1, [sp, #20]
 8003dec:	480a      	ldr	r0, [pc, #40]	@ (8003e18 <chThdCreateStatic+0x128>)
 8003dee:	f7ff fe87 	bl	8003b00 <__thd_object_init>
 8003df2:	0003      	movs	r3, r0
 8003df4:	9305      	str	r3, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8003df6:	9b05      	ldr	r3, [sp, #20]
 8003df8:	2100      	movs	r1, #0
 8003dfa:	0018      	movs	r0, r3
 8003dfc:	f7ff fbc0 	bl	8003580 <chSchWakeupS>
  chSysUnlock();
 8003e00:	f7ff fe2e 	bl	8003a60 <chSysUnlock.lto_priv.7>

  return tp;
 8003e04:	9b05      	ldr	r3, [sp, #20]
}
 8003e06:	0018      	movs	r0, r3
 8003e08:	b007      	add	sp, #28
 8003e0a:	bd00      	pop	{pc}
 8003e0c:	0800539c 	.word	0x0800539c
 8003e10:	080001b9 	.word	0x080001b9
 8003e14:	08005244 	.word	0x08005244
 8003e18:	20000690 	.word	0x20000690
 8003e1c:	00000000 	.word	0x00000000

08003e20 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8003e20:	b510      	push	{r4, lr}
 8003e22:	b082      	sub	sp, #8
 8003e24:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003e26:	f7ff fe13 	bl	8003a50 <chSysLock.lto_priv.7>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8003e2a:	9b01      	ldr	r3, [sp, #4]
 8003e2c:	2226      	movs	r2, #38	@ 0x26
 8003e2e:	5c9b      	ldrb	r3, [r3, r2]
 8003e30:	425a      	negs	r2, r3
 8003e32:	4153      	adcs	r3, r2
 8003e34:	b2db      	uxtb	r3, r3
 8003e36:	2b00      	cmp	r3, #0
 8003e38:	d003      	beq.n	8003e42 <chThdRelease+0x22>
 8003e3a:	4b21      	ldr	r3, [pc, #132]	@ (8003ec0 <chThdRelease+0xa0>)
 8003e3c:	0018      	movs	r0, r3
 8003e3e:	f7fe f9df 	bl	8002200 <chSysHalt>
  tp->refs--;
 8003e42:	9b01      	ldr	r3, [sp, #4]
 8003e44:	2226      	movs	r2, #38	@ 0x26
 8003e46:	5c9b      	ldrb	r3, [r3, r2]
 8003e48:	3b01      	subs	r3, #1
 8003e4a:	b2d9      	uxtb	r1, r3
 8003e4c:	9b01      	ldr	r3, [sp, #4]
 8003e4e:	2226      	movs	r2, #38	@ 0x26
 8003e50:	5499      	strb	r1, [r3, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8003e52:	9b01      	ldr	r3, [sp, #4]
 8003e54:	2226      	movs	r2, #38	@ 0x26
 8003e56:	5c9b      	ldrb	r3, [r3, r2]
 8003e58:	2b00      	cmp	r3, #0
 8003e5a:	d12c      	bne.n	8003eb6 <chThdRelease+0x96>
 8003e5c:	9b01      	ldr	r3, [sp, #4]
 8003e5e:	2224      	movs	r2, #36	@ 0x24
 8003e60:	5c9b      	ldrb	r3, [r3, r2]
 8003e62:	2b0f      	cmp	r3, #15
 8003e64:	d127      	bne.n	8003eb6 <chThdRelease+0x96>
    REG_REMOVE(tp);
 8003e66:	9b01      	ldr	r3, [sp, #4]
 8003e68:	3310      	adds	r3, #16
 8003e6a:	0018      	movs	r0, r3
 8003e6c:	f7ff fdd0 	bl	8003a10 <ch_queue_dequeue.lto_priv.1>
    chSysUnlock();
 8003e70:	f7ff fdf6 	bl	8003a60 <chSysUnlock.lto_priv.7>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8003e74:	9b01      	ldr	r3, [sp, #4]
 8003e76:	2225      	movs	r2, #37	@ 0x25
 8003e78:	5c9b      	ldrb	r3, [r3, r2]
 8003e7a:	001a      	movs	r2, r3
 8003e7c:	2303      	movs	r3, #3
 8003e7e:	4013      	ands	r3, r2
 8003e80:	2b01      	cmp	r3, #1
 8003e82:	d002      	beq.n	8003e8a <chThdRelease+0x6a>
 8003e84:	2b02      	cmp	r3, #2
 8003e86:	d009      	beq.n	8003e9c <chThdRelease+0x7c>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
      /* Nothing else to do for static threads.*/
      break;
 8003e88:	e014      	b.n	8003eb4 <chThdRelease+0x94>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8003e8a:	9b01      	ldr	r3, [sp, #4]
 8003e8c:	0018      	movs	r0, r3
 8003e8e:	f7ff fe17 	bl	8003ac0 <chThdGetWorkingAreaX.lto_priv.0>
 8003e92:	0003      	movs	r3, r0
 8003e94:	0018      	movs	r0, r3
 8003e96:	f000 fc93 	bl	80047c0 <chHeapFree>
      break;
 8003e9a:	e00b      	b.n	8003eb4 <chThdRelease+0x94>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8003e9c:	9b01      	ldr	r3, [sp, #4]
 8003e9e:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
 8003ea0:	9b01      	ldr	r3, [sp, #4]
 8003ea2:	0018      	movs	r0, r3
 8003ea4:	f7ff fe0c 	bl	8003ac0 <chThdGetWorkingAreaX.lto_priv.0>
 8003ea8:	0003      	movs	r3, r0
 8003eaa:	0019      	movs	r1, r3
 8003eac:	0020      	movs	r0, r4
 8003eae:	f000 fde7 	bl	8004a80 <chPoolFree>
      break;
 8003eb2:	46c0      	nop			@ (mov r8, r8)
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
 8003eb4:	e001      	b.n	8003eba <chThdRelease+0x9a>
  }
  chSysUnlock();
 8003eb6:	f7ff fdd3 	bl	8003a60 <chSysUnlock.lto_priv.7>
}
 8003eba:	b002      	add	sp, #8
 8003ebc:	bd10      	pop	{r4, pc}
 8003ebe:	46c0      	nop			@ (mov r8, r8)
 8003ec0:	080053b0 	.word	0x080053b0
	...

08003ed0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8003ed0:	b500      	push	{lr}
 8003ed2:	b083      	sub	sp, #12
 8003ed4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003ed6:	f7ff fdbb 	bl	8003a50 <chSysLock.lto_priv.7>
  chThdExitS(msg);
 8003eda:	9b01      	ldr	r3, [sp, #4]
 8003edc:	0018      	movs	r0, r3
 8003ede:	f000 f807 	bl	8003ef0 <chThdExitS>
  /* The thread never returns here.*/
}
 8003ee2:	46c0      	nop			@ (mov r8, r8)
 8003ee4:	b003      	add	sp, #12
 8003ee6:	bd00      	pop	{pc}
	...

08003ef0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8003ef0:	b500      	push	{lr}
 8003ef2:	b085      	sub	sp, #20
 8003ef4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8003ef6:	f7ff fddb 	bl	8003ab0 <chThdGetSelfX.lto_priv.0>
 8003efa:	0003      	movs	r3, r0
 8003efc:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 8003efe:	9b03      	ldr	r3, [sp, #12]
 8003f00:	9a01      	ldr	r2, [sp, #4]
 8003f02:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003f04:	e008      	b.n	8003f18 <chThdExitS+0x28>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8003f06:	9b03      	ldr	r3, [sp, #12]
 8003f08:	332c      	adds	r3, #44	@ 0x2c
 8003f0a:	0018      	movs	r0, r3
 8003f0c:	f7ff fd48 	bl	80039a0 <ch_list_unlink>
 8003f10:	0003      	movs	r3, r0
 8003f12:	0018      	movs	r0, r3
 8003f14:	f7ff fa7c 	bl	8003410 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003f18:	9b03      	ldr	r3, [sp, #12]
 8003f1a:	332c      	adds	r3, #44	@ 0x2c
 8003f1c:	0018      	movs	r0, r3
 8003f1e:	f7ff fd2f 	bl	8003980 <ch_list_notempty>
 8003f22:	1e03      	subs	r3, r0, #0
 8003f24:	d1ef      	bne.n	8003f06 <chThdExitS+0x16>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8003f26:	9b03      	ldr	r3, [sp, #12]
 8003f28:	2226      	movs	r2, #38	@ 0x26
 8003f2a:	5c9b      	ldrb	r3, [r3, r2]
 8003f2c:	425a      	negs	r2, r3
 8003f2e:	4153      	adcs	r3, r2
 8003f30:	b2db      	uxtb	r3, r3
 8003f32:	2b00      	cmp	r3, #0
 8003f34:	d00f      	beq.n	8003f56 <chThdExitS+0x66>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8003f36:	9b03      	ldr	r3, [sp, #12]
 8003f38:	2225      	movs	r2, #37	@ 0x25
 8003f3a:	5c9b      	ldrb	r3, [r3, r2]
 8003f3c:	001a      	movs	r2, r3
 8003f3e:	2303      	movs	r3, #3
 8003f40:	4013      	ands	r3, r2
 8003f42:	425a      	negs	r2, r3
 8003f44:	4153      	adcs	r3, r2
 8003f46:	b2db      	uxtb	r3, r3
 8003f48:	2b00      	cmp	r3, #0
 8003f4a:	d004      	beq.n	8003f56 <chThdExitS+0x66>
      REG_REMOVE(currtp);
 8003f4c:	9b03      	ldr	r3, [sp, #12]
 8003f4e:	3310      	adds	r3, #16
 8003f50:	0018      	movs	r0, r3
 8003f52:	f7ff fd5d 	bl	8003a10 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003f56:	200f      	movs	r0, #15
 8003f58:	f7ff fa7a 	bl	8003450 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8003f5c:	4b03      	ldr	r3, [pc, #12]	@ (8003f6c <chThdExitS+0x7c>)
 8003f5e:	0018      	movs	r0, r3
 8003f60:	f7fe f94e 	bl	8002200 <chSysHalt>
}
 8003f64:	46c0      	nop			@ (mov r8, r8)
 8003f66:	b005      	add	sp, #20
 8003f68:	bd00      	pop	{pc}
 8003f6a:	46c0      	nop			@ (mov r8, r8)
 8003f6c:	080053c0 	.word	0x080053c0

08003f70 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8003f70:	b500      	push	{lr}
 8003f72:	b083      	sub	sp, #12
 8003f74:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003f76:	f7ff fd6b 	bl	8003a50 <chSysLock.lto_priv.7>
  chThdSleepS(time);
 8003f7a:	9b01      	ldr	r3, [sp, #4]
 8003f7c:	0018      	movs	r0, r3
 8003f7e:	f7ff fda7 	bl	8003ad0 <chThdSleepS>
  chSysUnlock();
 8003f82:	f7ff fd6d 	bl	8003a60 <chSysUnlock.lto_priv.7>
}
 8003f86:	46c0      	nop			@ (mov r8, r8)
 8003f88:	b003      	add	sp, #12
 8003f8a:	bd00      	pop	{pc}
 8003f8c:	0000      	movs	r0, r0
	...

08003f90 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8003f90:	b500      	push	{lr}
 8003f92:	b085      	sub	sp, #20
 8003f94:	9001      	str	r0, [sp, #4]
 8003f96:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8003f98:	f7ff fd8a 	bl	8003ab0 <chThdGetSelfX.lto_priv.0>
 8003f9c:	0003      	movs	r3, r0
 8003f9e:	9303      	str	r3, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 8003fa0:	9b01      	ldr	r3, [sp, #4]
 8003fa2:	681b      	ldr	r3, [r3, #0]
 8003fa4:	1e5a      	subs	r2, r3, #1
 8003fa6:	4193      	sbcs	r3, r2
 8003fa8:	b2db      	uxtb	r3, r3
 8003faa:	2b00      	cmp	r3, #0
 8003fac:	d003      	beq.n	8003fb6 <chThdSuspendTimeoutS+0x26>
 8003fae:	4b0e      	ldr	r3, [pc, #56]	@ (8003fe8 <chThdSuspendTimeoutS+0x58>)
 8003fb0:	0018      	movs	r0, r3
 8003fb2:	f7fe f925 	bl	8002200 <chSysHalt>

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8003fb6:	9b00      	ldr	r3, [sp, #0]
 8003fb8:	425a      	negs	r2, r3
 8003fba:	4153      	adcs	r3, r2
 8003fbc:	b2db      	uxtb	r3, r3
 8003fbe:	2b00      	cmp	r3, #0
 8003fc0:	d002      	beq.n	8003fc8 <chThdSuspendTimeoutS+0x38>
    return MSG_TIMEOUT;
 8003fc2:	2301      	movs	r3, #1
 8003fc4:	425b      	negs	r3, r3
 8003fc6:	e00b      	b.n	8003fe0 <chThdSuspendTimeoutS+0x50>
  }

  *trp = tp;
 8003fc8:	9b01      	ldr	r3, [sp, #4]
 8003fca:	9a03      	ldr	r2, [sp, #12]
 8003fcc:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8003fce:	9b03      	ldr	r3, [sp, #12]
 8003fd0:	9a01      	ldr	r2, [sp, #4]
 8003fd2:	629a      	str	r2, [r3, #40]	@ 0x28

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003fd4:	9b00      	ldr	r3, [sp, #0]
 8003fd6:	0019      	movs	r1, r3
 8003fd8:	2003      	movs	r0, #3
 8003fda:	f7ff fa99 	bl	8003510 <chSchGoSleepTimeoutS>
 8003fde:	0003      	movs	r3, r0
}
 8003fe0:	0018      	movs	r0, r3
 8003fe2:	b005      	add	sp, #20
 8003fe4:	bd00      	pop	{pc}
 8003fe6:	46c0      	nop			@ (mov r8, r8)
 8003fe8:	080053d8 	.word	0x080053d8
 8003fec:	00000000 	.word	0x00000000

08003ff0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8003ff0:	b500      	push	{lr}
 8003ff2:	b085      	sub	sp, #20
 8003ff4:	9001      	str	r0, [sp, #4]
 8003ff6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8003ff8:	9b01      	ldr	r3, [sp, #4]
 8003ffa:	681b      	ldr	r3, [r3, #0]
 8003ffc:	2b00      	cmp	r3, #0
 8003ffe:	d019      	beq.n	8004034 <chThdResumeI+0x44>
    thread_t *tp = *trp;
 8004000:	9b01      	ldr	r3, [sp, #4]
 8004002:	681b      	ldr	r3, [r3, #0]
 8004004:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004006:	9b03      	ldr	r3, [sp, #12]
 8004008:	2224      	movs	r2, #36	@ 0x24
 800400a:	5c9b      	ldrb	r3, [r3, r2]
 800400c:	3b03      	subs	r3, #3
 800400e:	1e5a      	subs	r2, r3, #1
 8004010:	4193      	sbcs	r3, r2
 8004012:	b2db      	uxtb	r3, r3
 8004014:	2b00      	cmp	r3, #0
 8004016:	d003      	beq.n	8004020 <chThdResumeI+0x30>
 8004018:	4b08      	ldr	r3, [pc, #32]	@ (800403c <chThdResumeI+0x4c>)
 800401a:	0018      	movs	r0, r3
 800401c:	f7fe f8f0 	bl	8002200 <chSysHalt>

    *trp = NULL;
 8004020:	9b01      	ldr	r3, [sp, #4]
 8004022:	2200      	movs	r2, #0
 8004024:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8004026:	9b03      	ldr	r3, [sp, #12]
 8004028:	9a00      	ldr	r2, [sp, #0]
 800402a:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 800402c:	9b03      	ldr	r3, [sp, #12]
 800402e:	0018      	movs	r0, r3
 8004030:	f7ff f9ee 	bl	8003410 <chSchReadyI>
  }
}
 8004034:	46c0      	nop			@ (mov r8, r8)
 8004036:	b005      	add	sp, #20
 8004038:	bd00      	pop	{pc}
 800403a:	46c0      	nop			@ (mov r8, r8)
 800403c:	080053f0 	.word	0x080053f0

08004040 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8004040:	b500      	push	{lr}
 8004042:	b085      	sub	sp, #20
 8004044:	9001      	str	r0, [sp, #4]
 8004046:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8004048:	9b01      	ldr	r3, [sp, #4]
 800404a:	681b      	ldr	r3, [r3, #0]
 800404c:	2b00      	cmp	r3, #0
 800404e:	d018      	beq.n	8004082 <chThdResumeS+0x42>
    thread_t *tp = *trp;
 8004050:	9b01      	ldr	r3, [sp, #4]
 8004052:	681b      	ldr	r3, [r3, #0]
 8004054:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004056:	9b03      	ldr	r3, [sp, #12]
 8004058:	2224      	movs	r2, #36	@ 0x24
 800405a:	5c9b      	ldrb	r3, [r3, r2]
 800405c:	3b03      	subs	r3, #3
 800405e:	1e5a      	subs	r2, r3, #1
 8004060:	4193      	sbcs	r3, r2
 8004062:	b2db      	uxtb	r3, r3
 8004064:	2b00      	cmp	r3, #0
 8004066:	d003      	beq.n	8004070 <chThdResumeS+0x30>
 8004068:	4b07      	ldr	r3, [pc, #28]	@ (8004088 <chThdResumeS+0x48>)
 800406a:	0018      	movs	r0, r3
 800406c:	f7fe f8c8 	bl	8002200 <chSysHalt>

    *trp = NULL;
 8004070:	9b01      	ldr	r3, [sp, #4]
 8004072:	2200      	movs	r2, #0
 8004074:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 8004076:	9a00      	ldr	r2, [sp, #0]
 8004078:	9b03      	ldr	r3, [sp, #12]
 800407a:	0011      	movs	r1, r2
 800407c:	0018      	movs	r0, r3
 800407e:	f7ff fa7f 	bl	8003580 <chSchWakeupS>
  }
}
 8004082:	46c0      	nop			@ (mov r8, r8)
 8004084:	b005      	add	sp, #20
 8004086:	bd00      	pop	{pc}
 8004088:	08005400 	.word	0x08005400
 800408c:	00000000 	.word	0x00000000

08004090 <port_lock.lto_priv.13>:
  __ASM volatile ("cpsid i" : : : "memory");
 8004090:	b672      	cpsid	i
}
 8004092:	46c0      	nop			@ (mov r8, r8)
}
 8004094:	46c0      	nop			@ (mov r8, r8)
 8004096:	4770      	bx	lr
	...

080040a0 <port_unlock.lto_priv.13>:
  __ASM volatile ("cpsie i" : : : "memory");
 80040a0:	b662      	cpsie	i
}
 80040a2:	46c0      	nop			@ (mov r8, r8)
}
 80040a4:	46c0      	nop			@ (mov r8, r8)
 80040a6:	4770      	bx	lr
	...

080040b0 <chSysLock.lto_priv.8>:
static inline void chSysLock(void) {
 80040b0:	b510      	push	{r4, lr}
  port_lock();
 80040b2:	f7ff ffed 	bl	8004090 <port_lock.lto_priv.13>
  __dbg_check_lock();
 80040b6:	f7fe f913 	bl	80022e0 <__dbg_check_lock>
}
 80040ba:	46c0      	nop			@ (mov r8, r8)
 80040bc:	bd10      	pop	{r4, pc}
 80040be:	46c0      	nop			@ (mov r8, r8)

080040c0 <chSysUnlock.lto_priv.8>:
static inline void chSysUnlock(void) {
 80040c0:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 80040c2:	f7fe f935 	bl	8002330 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80040c6:	4b0e      	ldr	r3, [pc, #56]	@ (8004100 <chSysUnlock.lto_priv.8+0x40>)
 80040c8:	681a      	ldr	r2, [r3, #0]
 80040ca:	4b0d      	ldr	r3, [pc, #52]	@ (8004100 <chSysUnlock.lto_priv.8+0x40>)
 80040cc:	1ad3      	subs	r3, r2, r3
 80040ce:	1e5a      	subs	r2, r3, #1
 80040d0:	4193      	sbcs	r3, r2
 80040d2:	b2db      	uxtb	r3, r3
 80040d4:	2b00      	cmp	r3, #0
 80040d6:	d00f      	beq.n	80040f8 <chSysUnlock.lto_priv.8+0x38>
 80040d8:	4b09      	ldr	r3, [pc, #36]	@ (8004100 <chSysUnlock.lto_priv.8+0x40>)
 80040da:	68db      	ldr	r3, [r3, #12]
 80040dc:	689a      	ldr	r2, [r3, #8]
 80040de:	4b08      	ldr	r3, [pc, #32]	@ (8004100 <chSysUnlock.lto_priv.8+0x40>)
 80040e0:	681b      	ldr	r3, [r3, #0]
 80040e2:	689b      	ldr	r3, [r3, #8]
 80040e4:	429a      	cmp	r2, r3
 80040e6:	419b      	sbcs	r3, r3
 80040e8:	425b      	negs	r3, r3
 80040ea:	b2db      	uxtb	r3, r3
 80040ec:	2b00      	cmp	r3, #0
 80040ee:	d003      	beq.n	80040f8 <chSysUnlock.lto_priv.8+0x38>
 80040f0:	4b04      	ldr	r3, [pc, #16]	@ (8004104 <chSysUnlock.lto_priv.8+0x44>)
 80040f2:	0018      	movs	r0, r3
 80040f4:	f7fe f884 	bl	8002200 <chSysHalt>
  port_unlock();
 80040f8:	f7ff ffd2 	bl	80040a0 <port_unlock.lto_priv.13>
}
 80040fc:	46c0      	nop			@ (mov r8, r8)
 80040fe:	bd10      	pop	{r4, pc}
 8004100:	20000690 	.word	0x20000690
 8004104:	0800543c 	.word	0x0800543c
	...

08004110 <chThdGetWorkingAreaX.lto_priv.1>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8004110:	b082      	sub	sp, #8
 8004112:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8004114:	9b01      	ldr	r3, [sp, #4]
 8004116:	6a1b      	ldr	r3, [r3, #32]
}
 8004118:	0018      	movs	r0, r3
 800411a:	b002      	add	sp, #8
 800411c:	4770      	bx	lr
 800411e:	46c0      	nop			@ (mov r8, r8)

08004120 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8004120:	b500      	push	{lr}
 8004122:	b083      	sub	sp, #12
  thread_t *tp;
  uint8_t *p;

  chSysLock();
 8004124:	f7ff ffc4 	bl	80040b0 <chSysLock.lto_priv.8>
  p = (uint8_t *)REG_HEADER(currcore)->next;
 8004128:	4b09      	ldr	r3, [pc, #36]	@ (8004150 <chRegFirstThread+0x30>)
 800412a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800412c:	9301      	str	r3, [sp, #4]
  /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 800412e:	9b01      	ldr	r3, [sp, #4]
 8004130:	3b10      	subs	r3, #16
 8004132:	9300      	str	r3, [sp, #0]
  /*lint -restore*/
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8004134:	9b00      	ldr	r3, [sp, #0]
 8004136:	2226      	movs	r2, #38	@ 0x26
 8004138:	5c9b      	ldrb	r3, [r3, r2]
 800413a:	3301      	adds	r3, #1
 800413c:	b2d9      	uxtb	r1, r3
 800413e:	9b00      	ldr	r3, [sp, #0]
 8004140:	2226      	movs	r2, #38	@ 0x26
 8004142:	5499      	strb	r1, [r3, r2]
#endif
  chSysUnlock();
 8004144:	f7ff ffbc 	bl	80040c0 <chSysUnlock.lto_priv.8>

  return tp;
 8004148:	9b00      	ldr	r3, [sp, #0]
}
 800414a:	0018      	movs	r0, r3
 800414c:	b003      	add	sp, #12
 800414e:	bd00      	pop	{pc}
 8004150:	20000690 	.word	0x20000690
	...

08004160 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8004160:	b500      	push	{lr}
 8004162:	b087      	sub	sp, #28
 8004164:	9001      	str	r0, [sp, #4]
  thread_t *ntp;
  ch_queue_t *nqp;

  chSysLock();
 8004166:	f7ff ffa3 	bl	80040b0 <chSysLock.lto_priv.8>

  /* Next element in the registry queue.*/
  nqp = tp->rqueue.next;
 800416a:	9b01      	ldr	r3, [sp, #4]
 800416c:	691b      	ldr	r3, [r3, #16]
 800416e:	9304      	str	r3, [sp, #16]
  if (nqp == REG_HEADER(currcore)) {
 8004170:	9a04      	ldr	r2, [sp, #16]
 8004172:	4b15      	ldr	r3, [pc, #84]	@ (80041c8 <chRegNextThread+0x68>)
 8004174:	429a      	cmp	r2, r3
 8004176:	d102      	bne.n	800417e <chRegNextThread+0x1e>
    ntp = NULL;
 8004178:	2300      	movs	r3, #0
 800417a:	9305      	str	r3, [sp, #20]
 800417c:	e019      	b.n	80041b2 <chRegNextThread+0x52>
  }
  else {
    uint8_t *p = (uint8_t *)nqp;
 800417e:	9b04      	ldr	r3, [sp, #16]
 8004180:	9303      	str	r3, [sp, #12]
    /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8004182:	9b03      	ldr	r3, [sp, #12]
 8004184:	3b10      	subs	r3, #16
 8004186:	9305      	str	r3, [sp, #20]
    /*lint -restore*/

#if CH_CFG_USE_DYNAMIC == TRUE
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8004188:	9b05      	ldr	r3, [sp, #20]
 800418a:	2226      	movs	r2, #38	@ 0x26
 800418c:	5c9b      	ldrb	r3, [r3, r2]
 800418e:	3bff      	subs	r3, #255	@ 0xff
 8004190:	425a      	negs	r2, r3
 8004192:	4153      	adcs	r3, r2
 8004194:	b2db      	uxtb	r3, r3
 8004196:	2b00      	cmp	r3, #0
 8004198:	d003      	beq.n	80041a2 <chRegNextThread+0x42>
 800419a:	4b0c      	ldr	r3, [pc, #48]	@ (80041cc <chRegNextThread+0x6c>)
 800419c:	0018      	movs	r0, r3
 800419e:	f7fe f82f 	bl	8002200 <chSysHalt>

    ntp->refs++;
 80041a2:	9b05      	ldr	r3, [sp, #20]
 80041a4:	2226      	movs	r2, #38	@ 0x26
 80041a6:	5c9b      	ldrb	r3, [r3, r2]
 80041a8:	3301      	adds	r3, #1
 80041aa:	b2d9      	uxtb	r1, r3
 80041ac:	9b05      	ldr	r3, [sp, #20]
 80041ae:	2226      	movs	r2, #38	@ 0x26
 80041b0:	5499      	strb	r1, [r3, r2]
#endif
  }
  chSysUnlock();
 80041b2:	f7ff ff85 	bl	80040c0 <chSysUnlock.lto_priv.8>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80041b6:	9b01      	ldr	r3, [sp, #4]
 80041b8:	0018      	movs	r0, r3
 80041ba:	f7ff fe31 	bl	8003e20 <chThdRelease>
#endif

  return ntp;
 80041be:	9b05      	ldr	r3, [sp, #20]
}
 80041c0:	0018      	movs	r0, r3
 80041c2:	b007      	add	sp, #28
 80041c4:	bd00      	pop	{pc}
 80041c6:	46c0      	nop			@ (mov r8, r8)
 80041c8:	200006b8 	.word	0x200006b8
 80041cc:	08005448 	.word	0x08005448

080041d0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 80041d0:	b500      	push	{lr}
 80041d2:	b085      	sub	sp, #20
 80041d4:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 80041d6:	f7ff ffa3 	bl	8004120 <chRegFirstThread>
 80041da:	0003      	movs	r3, r0
 80041dc:	9303      	str	r3, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80041de:	9b03      	ldr	r3, [sp, #12]
 80041e0:	0018      	movs	r0, r3
 80041e2:	f7ff ff95 	bl	8004110 <chThdGetWorkingAreaX.lto_priv.1>
 80041e6:	0002      	movs	r2, r0
 80041e8:	9b01      	ldr	r3, [sp, #4]
 80041ea:	4293      	cmp	r3, r2
 80041ec:	d101      	bne.n	80041f2 <chRegFindThreadByWorkingArea+0x22>
      return ctp;
 80041ee:	9b03      	ldr	r3, [sp, #12]
 80041f0:	e009      	b.n	8004206 <chRegFindThreadByWorkingArea+0x36>
    }
    ctp = chRegNextThread(ctp);
 80041f2:	9b03      	ldr	r3, [sp, #12]
 80041f4:	0018      	movs	r0, r3
 80041f6:	f7ff ffb3 	bl	8004160 <chRegNextThread>
 80041fa:	0003      	movs	r3, r0
 80041fc:	9303      	str	r3, [sp, #12]
  } while (ctp != NULL);
 80041fe:	9b03      	ldr	r3, [sp, #12]
 8004200:	2b00      	cmp	r3, #0
 8004202:	d1ec      	bne.n	80041de <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 8004204:	2300      	movs	r3, #0
}
 8004206:	0018      	movs	r0, r3
 8004208:	b005      	add	sp, #20
 800420a:	bd00      	pop	{pc}
 800420c:	0000      	movs	r0, r0
	...

08004210 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004210:	b082      	sub	sp, #8
 8004212:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004214:	9b01      	ldr	r3, [sp, #4]
 8004216:	9a01      	ldr	r2, [sp, #4]
 8004218:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800421a:	9b01      	ldr	r3, [sp, #4]
 800421c:	9a01      	ldr	r2, [sp, #4]
 800421e:	605a      	str	r2, [r3, #4]
}
 8004220:	46c0      	nop			@ (mov r8, r8)
 8004222:	b002      	add	sp, #8
 8004224:	4770      	bx	lr
 8004226:	46c0      	nop			@ (mov r8, r8)
	...

08004230 <ch_queue_notempty.lto_priv.2>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 8004230:	b082      	sub	sp, #8
 8004232:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 8004234:	9b01      	ldr	r3, [sp, #4]
 8004236:	681b      	ldr	r3, [r3, #0]
 8004238:	9a01      	ldr	r2, [sp, #4]
 800423a:	1ad3      	subs	r3, r2, r3
 800423c:	1e5a      	subs	r2, r3, #1
 800423e:	4193      	sbcs	r3, r2
 8004240:	b2db      	uxtb	r3, r3
}
 8004242:	0018      	movs	r0, r3
 8004244:	b002      	add	sp, #8
 8004246:	4770      	bx	lr
	...

08004250 <ch_queue_fifo_remove.lto_priv.2>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 8004250:	b084      	sub	sp, #16
 8004252:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 8004254:	9b01      	ldr	r3, [sp, #4]
 8004256:	681b      	ldr	r3, [r3, #0]
 8004258:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 800425a:	9b03      	ldr	r3, [sp, #12]
 800425c:	681a      	ldr	r2, [r3, #0]
 800425e:	9b01      	ldr	r3, [sp, #4]
 8004260:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 8004262:	9b01      	ldr	r3, [sp, #4]
 8004264:	681b      	ldr	r3, [r3, #0]
 8004266:	9a01      	ldr	r2, [sp, #4]
 8004268:	605a      	str	r2, [r3, #4]
  return p;
 800426a:	9b03      	ldr	r3, [sp, #12]
}
 800426c:	0018      	movs	r0, r3
 800426e:	b004      	add	sp, #16
 8004270:	4770      	bx	lr
 8004272:	46c0      	nop			@ (mov r8, r8)
	...

08004280 <ch_queue_dequeue.lto_priv.2>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8004280:	b082      	sub	sp, #8
 8004282:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8004284:	9b01      	ldr	r3, [sp, #4]
 8004286:	685b      	ldr	r3, [r3, #4]
 8004288:	9a01      	ldr	r2, [sp, #4]
 800428a:	6812      	ldr	r2, [r2, #0]
 800428c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800428e:	9b01      	ldr	r3, [sp, #4]
 8004290:	681b      	ldr	r3, [r3, #0]
 8004292:	9a01      	ldr	r2, [sp, #4]
 8004294:	6852      	ldr	r2, [r2, #4]
 8004296:	605a      	str	r2, [r3, #4]
  return p;
 8004298:	9b01      	ldr	r3, [sp, #4]
}
 800429a:	0018      	movs	r0, r3
 800429c:	b002      	add	sp, #8
 800429e:	4770      	bx	lr

080042a0 <port_lock.lto_priv.15>:
  __ASM volatile ("cpsid i" : : : "memory");
 80042a0:	b672      	cpsid	i
}
 80042a2:	46c0      	nop			@ (mov r8, r8)
}
 80042a4:	46c0      	nop			@ (mov r8, r8)
 80042a6:	4770      	bx	lr
	...

080042b0 <port_unlock.lto_priv.15>:
  __ASM volatile ("cpsie i" : : : "memory");
 80042b0:	b662      	cpsie	i
}
 80042b2:	46c0      	nop			@ (mov r8, r8)
}
 80042b4:	46c0      	nop			@ (mov r8, r8)
 80042b6:	4770      	bx	lr
	...

080042c0 <chSysLock.lto_priv.10>:
static inline void chSysLock(void) {
 80042c0:	b510      	push	{r4, lr}
  port_lock();
 80042c2:	f7ff ffed 	bl	80042a0 <port_lock.lto_priv.15>
  __dbg_check_lock();
 80042c6:	f7fe f80b 	bl	80022e0 <__dbg_check_lock>
}
 80042ca:	46c0      	nop			@ (mov r8, r8)
 80042cc:	bd10      	pop	{r4, pc}
 80042ce:	46c0      	nop			@ (mov r8, r8)

080042d0 <chSysUnlock.lto_priv.10>:
static inline void chSysUnlock(void) {
 80042d0:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 80042d2:	f7fe f82d 	bl	8002330 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80042d6:	4b0e      	ldr	r3, [pc, #56]	@ (8004310 <chSysUnlock.lto_priv.10+0x40>)
 80042d8:	681a      	ldr	r2, [r3, #0]
 80042da:	4b0d      	ldr	r3, [pc, #52]	@ (8004310 <chSysUnlock.lto_priv.10+0x40>)
 80042dc:	1ad3      	subs	r3, r2, r3
 80042de:	1e5a      	subs	r2, r3, #1
 80042e0:	4193      	sbcs	r3, r2
 80042e2:	b2db      	uxtb	r3, r3
 80042e4:	2b00      	cmp	r3, #0
 80042e6:	d00f      	beq.n	8004308 <chSysUnlock.lto_priv.10+0x38>
 80042e8:	4b09      	ldr	r3, [pc, #36]	@ (8004310 <chSysUnlock.lto_priv.10+0x40>)
 80042ea:	68db      	ldr	r3, [r3, #12]
 80042ec:	689a      	ldr	r2, [r3, #8]
 80042ee:	4b08      	ldr	r3, [pc, #32]	@ (8004310 <chSysUnlock.lto_priv.10+0x40>)
 80042f0:	681b      	ldr	r3, [r3, #0]
 80042f2:	689b      	ldr	r3, [r3, #8]
 80042f4:	429a      	cmp	r2, r3
 80042f6:	419b      	sbcs	r3, r3
 80042f8:	425b      	negs	r3, r3
 80042fa:	b2db      	uxtb	r3, r3
 80042fc:	2b00      	cmp	r3, #0
 80042fe:	d003      	beq.n	8004308 <chSysUnlock.lto_priv.10+0x38>
 8004300:	4b04      	ldr	r3, [pc, #16]	@ (8004314 <chSysUnlock.lto_priv.10+0x44>)
 8004302:	0018      	movs	r0, r3
 8004304:	f7fd ff7c 	bl	8002200 <chSysHalt>
  port_unlock();
 8004308:	f7ff ffd2 	bl	80042b0 <port_unlock.lto_priv.15>
}
 800430c:	46c0      	nop			@ (mov r8, r8)
 800430e:	bd10      	pop	{r4, pc}
 8004310:	20000690 	.word	0x20000690
 8004314:	08005468 	.word	0x08005468
	...

08004320 <ch_sch_prio_insert.lto_priv.0>:
/*===========================================================================*/

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 8004320:	b084      	sub	sp, #16
 8004322:	9001      	str	r0, [sp, #4]
 8004324:	9100      	str	r1, [sp, #0]

  ch_queue_t *cp = qp;
 8004326:	9b01      	ldr	r3, [sp, #4]
 8004328:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->next;
 800432a:	9b03      	ldr	r3, [sp, #12]
 800432c:	681b      	ldr	r3, [r3, #0]
 800432e:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
 8004330:	9a03      	ldr	r2, [sp, #12]
 8004332:	9b01      	ldr	r3, [sp, #4]
 8004334:	429a      	cmp	r2, r3
 8004336:	d005      	beq.n	8004344 <ch_sch_prio_insert.lto_priv.0+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8004338:	9b03      	ldr	r3, [sp, #12]
 800433a:	689a      	ldr	r2, [r3, #8]
 800433c:	9b00      	ldr	r3, [sp, #0]
 800433e:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
 8004340:	429a      	cmp	r2, r3
 8004342:	d2f2      	bcs.n	800432a <ch_sch_prio_insert.lto_priv.0+0xa>
  tp->next       = cp;
 8004344:	9b00      	ldr	r3, [sp, #0]
 8004346:	9a03      	ldr	r2, [sp, #12]
 8004348:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
 800434a:	9b03      	ldr	r3, [sp, #12]
 800434c:	685a      	ldr	r2, [r3, #4]
 800434e:	9b00      	ldr	r3, [sp, #0]
 8004350:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
 8004352:	9b00      	ldr	r3, [sp, #0]
 8004354:	685b      	ldr	r3, [r3, #4]
 8004356:	9a00      	ldr	r2, [sp, #0]
 8004358:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
 800435a:	9b03      	ldr	r3, [sp, #12]
 800435c:	9a00      	ldr	r2, [sp, #0]
 800435e:	605a      	str	r2, [r3, #4]
}
 8004360:	46c0      	nop			@ (mov r8, r8)
 8004362:	b004      	add	sp, #16
 8004364:	4770      	bx	lr
 8004366:	46c0      	nop			@ (mov r8, r8)
	...

08004370 <chThdGetSelfX.lto_priv.2>:
  return __sch_get_currthread();
 8004370:	4b01      	ldr	r3, [pc, #4]	@ (8004378 <chThdGetSelfX.lto_priv.2+0x8>)
 8004372:	68db      	ldr	r3, [r3, #12]
}
 8004374:	0018      	movs	r0, r3
 8004376:	4770      	bx	lr
 8004378:	20000690 	.word	0x20000690
 800437c:	00000000 	.word	0x00000000

08004380 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8004380:	b500      	push	{lr}
 8004382:	b083      	sub	sp, #12
 8004384:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8004386:	f7fe f8cb 	bl	8002520 <chDbgCheckClassS>

  return ch_queue_notempty(&mp->queue);
 800438a:	9b01      	ldr	r3, [sp, #4]
 800438c:	0018      	movs	r0, r3
 800438e:	f7ff ff4f 	bl	8004230 <ch_queue_notempty.lto_priv.2>
 8004392:	0003      	movs	r3, r0
}
 8004394:	0018      	movs	r0, r3
 8004396:	b003      	add	sp, #12
 8004398:	bd00      	pop	{pc}
 800439a:	46c0      	nop			@ (mov r8, r8)
 800439c:	0000      	movs	r0, r0
	...

080043a0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 80043a0:	b500      	push	{lr}
 80043a2:	b083      	sub	sp, #12
 80043a4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 80043a6:	9b01      	ldr	r3, [sp, #4]
 80043a8:	425a      	negs	r2, r3
 80043aa:	4153      	adcs	r3, r2
 80043ac:	b2db      	uxtb	r3, r3
 80043ae:	2b00      	cmp	r3, #0
 80043b0:	d003      	beq.n	80043ba <chMtxObjectInit+0x1a>
 80043b2:	4b07      	ldr	r3, [pc, #28]	@ (80043d0 <chMtxObjectInit+0x30>)
 80043b4:	0018      	movs	r0, r3
 80043b6:	f7fd ff23 	bl	8002200 <chSysHalt>

  ch_queue_init(&mp->queue);
 80043ba:	9b01      	ldr	r3, [sp, #4]
 80043bc:	0018      	movs	r0, r3
 80043be:	f7ff ff27 	bl	8004210 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 80043c2:	9b01      	ldr	r3, [sp, #4]
 80043c4:	2200      	movs	r2, #0
 80043c6:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 80043c8:	46c0      	nop			@ (mov r8, r8)
 80043ca:	b003      	add	sp, #12
 80043cc:	bd00      	pop	{pc}
 80043ce:	46c0      	nop			@ (mov r8, r8)
 80043d0:	08005458 	.word	0x08005458
	...

080043e0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80043e0:	b500      	push	{lr}
 80043e2:	b083      	sub	sp, #12
 80043e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80043e6:	f7ff ff6b 	bl	80042c0 <chSysLock.lto_priv.10>
  chMtxLockS(mp);
 80043ea:	9b01      	ldr	r3, [sp, #4]
 80043ec:	0018      	movs	r0, r3
 80043ee:	f000 f807 	bl	8004400 <chMtxLockS>
  chSysUnlock();
 80043f2:	f7ff ff6d 	bl	80042d0 <chSysUnlock.lto_priv.10>
}
 80043f6:	46c0      	nop			@ (mov r8, r8)
 80043f8:	b003      	add	sp, #12
 80043fa:	bd00      	pop	{pc}
 80043fc:	0000      	movs	r0, r0
	...

08004400 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8004400:	b510      	push	{r4, lr}
 8004402:	b084      	sub	sp, #16
 8004404:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004406:	f7ff ffb3 	bl	8004370 <chThdGetSelfX.lto_priv.2>
 800440a:	0003      	movs	r3, r0
 800440c:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 800440e:	f7fe f887 	bl	8002520 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8004412:	9b01      	ldr	r3, [sp, #4]
 8004414:	425a      	negs	r2, r3
 8004416:	4153      	adcs	r3, r2
 8004418:	b2db      	uxtb	r3, r3
 800441a:	2b00      	cmp	r3, #0
 800441c:	d003      	beq.n	8004426 <chMtxLockS+0x26>
 800441e:	4b41      	ldr	r3, [pc, #260]	@ (8004524 <chMtxLockS+0x124>)
 8004420:	0018      	movs	r0, r3
 8004422:	f7fd feed 	bl	8002200 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8004426:	9b01      	ldr	r3, [sp, #4]
 8004428:	689b      	ldr	r3, [r3, #8]
 800442a:	2b00      	cmp	r3, #0
 800442c:	d100      	bne.n	8004430 <chMtxLockS+0x30>
 800442e:	e06b      	b.n	8004508 <chMtxLockS+0x108>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 8004430:	9b01      	ldr	r3, [sp, #4]
 8004432:	689b      	ldr	r3, [r3, #8]
 8004434:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8004436:	e03a      	b.n	80044ae <chMtxLockS+0xae>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8004438:	9b02      	ldr	r3, [sp, #8]
 800443a:	689a      	ldr	r2, [r3, #8]
 800443c:	9b03      	ldr	r3, [sp, #12]
 800443e:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8004440:	9b03      	ldr	r3, [sp, #12]
 8004442:	2224      	movs	r2, #36	@ 0x24
 8004444:	5c9b      	ldrb	r3, [r3, r2]
 8004446:	2b07      	cmp	r3, #7
 8004448:	d015      	beq.n	8004476 <chMtxLockS+0x76>
 800444a:	dc2e      	bgt.n	80044aa <chMtxLockS+0xaa>
 800444c:	2b00      	cmp	r3, #0
 800444e:	d01f      	beq.n	8004490 <chMtxLockS+0x90>
 8004450:	2b06      	cmp	r3, #6
 8004452:	d12a      	bne.n	80044aa <chMtxLockS+0xaa>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004454:	9b03      	ldr	r3, [sp, #12]
 8004456:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004458:	001c      	movs	r4, r3
 800445a:	9b03      	ldr	r3, [sp, #12]
 800445c:	0018      	movs	r0, r3
 800445e:	f7ff ff0f 	bl	8004280 <ch_queue_dequeue.lto_priv.2>
 8004462:	0003      	movs	r3, r0
 8004464:	0019      	movs	r1, r3
 8004466:	0020      	movs	r0, r4
 8004468:	f7ff ff5a 	bl	8004320 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          tp = tp->u.wtmtxp->owner;
 800446c:	9b03      	ldr	r3, [sp, #12]
 800446e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004470:	689b      	ldr	r3, [r3, #8]
 8004472:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8004474:	e01b      	b.n	80044ae <chMtxLockS+0xae>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004476:	9b03      	ldr	r3, [sp, #12]
 8004478:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800447a:	001c      	movs	r4, r3
 800447c:	9b03      	ldr	r3, [sp, #12]
 800447e:	0018      	movs	r0, r3
 8004480:	f7ff fefe 	bl	8004280 <ch_queue_dequeue.lto_priv.2>
 8004484:	0003      	movs	r3, r0
 8004486:	0019      	movs	r1, r3
 8004488:	0020      	movs	r0, r4
 800448a:	f7ff ff49 	bl	8004320 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          break;
 800448e:	e00d      	b.n	80044ac <chMtxLockS+0xac>
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8004490:	9b03      	ldr	r3, [sp, #12]
 8004492:	2224      	movs	r2, #36	@ 0x24
 8004494:	2101      	movs	r1, #1
 8004496:	5499      	strb	r1, [r3, r2]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 8004498:	9b03      	ldr	r3, [sp, #12]
 800449a:	0018      	movs	r0, r3
 800449c:	f7ff fef0 	bl	8004280 <ch_queue_dequeue.lto_priv.2>
 80044a0:	0003      	movs	r3, r0
 80044a2:	0018      	movs	r0, r3
 80044a4:	f7fe ffb4 	bl	8003410 <chSchReadyI>
          break;
 80044a8:	e000      	b.n	80044ac <chMtxLockS+0xac>
        default:
          /* Nothing to do for other states.*/
          break;
 80044aa:	46c0      	nop			@ (mov r8, r8)
        }
        break;
 80044ac:	e005      	b.n	80044ba <chMtxLockS+0xba>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 80044ae:	9b03      	ldr	r3, [sp, #12]
 80044b0:	689a      	ldr	r2, [r3, #8]
 80044b2:	9b02      	ldr	r3, [sp, #8]
 80044b4:	689b      	ldr	r3, [r3, #8]
 80044b6:	429a      	cmp	r2, r3
 80044b8:	d3be      	bcc.n	8004438 <chMtxLockS+0x38>
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
 80044ba:	9b01      	ldr	r3, [sp, #4]
 80044bc:	9a02      	ldr	r2, [sp, #8]
 80044be:	0011      	movs	r1, r2
 80044c0:	0018      	movs	r0, r3
 80044c2:	f7ff ff2d 	bl	8004320 <ch_sch_prio_insert.lto_priv.0>
      currtp->u.wtmtxp = mp;
 80044c6:	9b02      	ldr	r3, [sp, #8]
 80044c8:	9a01      	ldr	r2, [sp, #4]
 80044ca:	629a      	str	r2, [r3, #40]	@ 0x28
      chSchGoSleepS(CH_STATE_WTMTX);
 80044cc:	2006      	movs	r0, #6
 80044ce:	f7fe ffbf 	bl	8003450 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 80044d2:	9b01      	ldr	r3, [sp, #4]
 80044d4:	689b      	ldr	r3, [r3, #8]
 80044d6:	9a02      	ldr	r2, [sp, #8]
 80044d8:	1ad3      	subs	r3, r2, r3
 80044da:	1e5a      	subs	r2, r3, #1
 80044dc:	4193      	sbcs	r3, r2
 80044de:	b2db      	uxtb	r3, r3
 80044e0:	2b00      	cmp	r3, #0
 80044e2:	d003      	beq.n	80044ec <chMtxLockS+0xec>
 80044e4:	4b0f      	ldr	r3, [pc, #60]	@ (8004524 <chMtxLockS+0x124>)
 80044e6:	0018      	movs	r0, r3
 80044e8:	f7fd fe8a 	bl	8002200 <chSysHalt>
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 80044ec:	9b02      	ldr	r3, [sp, #8]
 80044ee:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80044f0:	9a01      	ldr	r2, [sp, #4]
 80044f2:	1ad3      	subs	r3, r2, r3
 80044f4:	1e5a      	subs	r2, r3, #1
 80044f6:	4193      	sbcs	r3, r2
 80044f8:	b2db      	uxtb	r3, r3
 80044fa:	2b00      	cmp	r3, #0
 80044fc:	d00e      	beq.n	800451c <chMtxLockS+0x11c>
 80044fe:	4b09      	ldr	r3, [pc, #36]	@ (8004524 <chMtxLockS+0x124>)
 8004500:	0018      	movs	r0, r3
 8004502:	f7fd fe7d 	bl	8002200 <chSysHalt>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 8004506:	e009      	b.n	800451c <chMtxLockS+0x11c>
    mp->owner = currtp;
 8004508:	9b01      	ldr	r3, [sp, #4]
 800450a:	9a02      	ldr	r2, [sp, #8]
 800450c:	609a      	str	r2, [r3, #8]
    mp->next = currtp->mtxlist;
 800450e:	9b02      	ldr	r3, [sp, #8]
 8004510:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8004512:	9b01      	ldr	r3, [sp, #4]
 8004514:	60da      	str	r2, [r3, #12]
    currtp->mtxlist = mp;
 8004516:	9b02      	ldr	r3, [sp, #8]
 8004518:	9a01      	ldr	r2, [sp, #4]
 800451a:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 800451c:	46c0      	nop			@ (mov r8, r8)
 800451e:	b004      	add	sp, #16
 8004520:	bd10      	pop	{r4, pc}
 8004522:	46c0      	nop			@ (mov r8, r8)
 8004524:	08005474 	.word	0x08005474
	...

08004530 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8004530:	b500      	push	{lr}
 8004532:	b087      	sub	sp, #28
 8004534:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004536:	f7ff ff1b 	bl	8004370 <chThdGetSelfX.lto_priv.2>
 800453a:	0003      	movs	r3, r0
 800453c:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800453e:	9b01      	ldr	r3, [sp, #4]
 8004540:	425a      	negs	r2, r3
 8004542:	4153      	adcs	r3, r2
 8004544:	b2db      	uxtb	r3, r3
 8004546:	2b00      	cmp	r3, #0
 8004548:	d003      	beq.n	8004552 <chMtxUnlock+0x22>
 800454a:	4b3a      	ldr	r3, [pc, #232]	@ (8004634 <chMtxUnlock+0x104>)
 800454c:	0018      	movs	r0, r3
 800454e:	f7fd fe57 	bl	8002200 <chSysHalt>

  chSysLock();
 8004552:	f7ff feb5 	bl	80042c0 <chSysLock.lto_priv.10>

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8004556:	9b03      	ldr	r3, [sp, #12]
 8004558:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800455a:	425a      	negs	r2, r3
 800455c:	4153      	adcs	r3, r2
 800455e:	b2db      	uxtb	r3, r3
 8004560:	2b00      	cmp	r3, #0
 8004562:	d003      	beq.n	800456c <chMtxUnlock+0x3c>
 8004564:	4b33      	ldr	r3, [pc, #204]	@ (8004634 <chMtxUnlock+0x104>)
 8004566:	0018      	movs	r0, r3
 8004568:	f7fd fe4a 	bl	8002200 <chSysHalt>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 800456c:	9b03      	ldr	r3, [sp, #12]
 800456e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8004570:	689b      	ldr	r3, [r3, #8]
 8004572:	9a03      	ldr	r2, [sp, #12]
 8004574:	1ad3      	subs	r3, r2, r3
 8004576:	1e5a      	subs	r2, r3, #1
 8004578:	4193      	sbcs	r3, r2
 800457a:	b2db      	uxtb	r3, r3
 800457c:	2b00      	cmp	r3, #0
 800457e:	d003      	beq.n	8004588 <chMtxUnlock+0x58>
 8004580:	4b2c      	ldr	r3, [pc, #176]	@ (8004634 <chMtxUnlock+0x104>)
 8004582:	0018      	movs	r0, r3
 8004584:	f7fd fe3c 	bl	8002200 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 8004588:	9b03      	ldr	r3, [sp, #12]
 800458a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800458c:	9a01      	ldr	r2, [sp, #4]
 800458e:	1ad3      	subs	r3, r2, r3
 8004590:	1e5a      	subs	r2, r3, #1
 8004592:	4193      	sbcs	r3, r2
 8004594:	b2db      	uxtb	r3, r3
 8004596:	2b00      	cmp	r3, #0
 8004598:	d003      	beq.n	80045a2 <chMtxUnlock+0x72>
 800459a:	4b26      	ldr	r3, [pc, #152]	@ (8004634 <chMtxUnlock+0x104>)
 800459c:	0018      	movs	r0, r3
 800459e:	f7fd fe2f 	bl	8002200 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 80045a2:	9b01      	ldr	r3, [sp, #4]
 80045a4:	68da      	ldr	r2, [r3, #12]
 80045a6:	9b03      	ldr	r3, [sp, #12]
 80045a8:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80045aa:	9b01      	ldr	r3, [sp, #4]
 80045ac:	0018      	movs	r0, r3
 80045ae:	f7ff fee7 	bl	8004380 <chMtxQueueNotEmptyS>
 80045b2:	1e03      	subs	r3, r0, #0
 80045b4:	d036      	beq.n	8004624 <chMtxUnlock+0xf4>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 80045b6:	9b03      	ldr	r3, [sp, #12]
 80045b8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80045ba:	9304      	str	r3, [sp, #16]
      lmp = currtp->mtxlist;
 80045bc:	9b03      	ldr	r3, [sp, #12]
 80045be:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80045c0:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80045c2:	e012      	b.n	80045ea <chMtxUnlock+0xba>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80045c4:	9b05      	ldr	r3, [sp, #20]
 80045c6:	0018      	movs	r0, r3
 80045c8:	f7ff feda 	bl	8004380 <chMtxQueueNotEmptyS>
 80045cc:	1e03      	subs	r3, r0, #0
 80045ce:	d009      	beq.n	80045e4 <chMtxUnlock+0xb4>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 80045d0:	9b05      	ldr	r3, [sp, #20]
 80045d2:	681b      	ldr	r3, [r3, #0]
 80045d4:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 80045d6:	9a04      	ldr	r2, [sp, #16]
 80045d8:	429a      	cmp	r2, r3
 80045da:	d203      	bcs.n	80045e4 <chMtxUnlock+0xb4>
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
 80045dc:	9b05      	ldr	r3, [sp, #20]
 80045de:	681b      	ldr	r3, [r3, #0]
 80045e0:	689b      	ldr	r3, [r3, #8]
 80045e2:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 80045e4:	9b05      	ldr	r3, [sp, #20]
 80045e6:	68db      	ldr	r3, [r3, #12]
 80045e8:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80045ea:	9b05      	ldr	r3, [sp, #20]
 80045ec:	2b00      	cmp	r3, #0
 80045ee:	d1e9      	bne.n	80045c4 <chMtxUnlock+0x94>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 80045f0:	9b03      	ldr	r3, [sp, #12]
 80045f2:	9a04      	ldr	r2, [sp, #16]
 80045f4:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
 80045f6:	9b01      	ldr	r3, [sp, #4]
 80045f8:	0018      	movs	r0, r3
 80045fa:	f7ff fe29 	bl	8004250 <ch_queue_fifo_remove.lto_priv.2>
 80045fe:	0003      	movs	r3, r0
 8004600:	9302      	str	r3, [sp, #8]
      mp->owner = tp;
 8004602:	9b01      	ldr	r3, [sp, #4]
 8004604:	9a02      	ldr	r2, [sp, #8]
 8004606:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8004608:	9b02      	ldr	r3, [sp, #8]
 800460a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800460c:	9b01      	ldr	r3, [sp, #4]
 800460e:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8004610:	9b02      	ldr	r3, [sp, #8]
 8004612:	9a01      	ldr	r2, [sp, #4]
 8004614:	63da      	str	r2, [r3, #60]	@ 0x3c

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8004616:	9b02      	ldr	r3, [sp, #8]
 8004618:	0018      	movs	r0, r3
 800461a:	f7fe fef9 	bl	8003410 <chSchReadyI>
      chSchRescheduleS();
 800461e:	f7ff f817 	bl	8003650 <chSchRescheduleS>
 8004622:	e002      	b.n	800462a <chMtxUnlock+0xfa>
    }
    else {
      mp->owner = NULL;
 8004624:	9b01      	ldr	r3, [sp, #4]
 8004626:	2200      	movs	r2, #0
 8004628:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 800462a:	f7ff fe51 	bl	80042d0 <chSysUnlock.lto_priv.10>
}
 800462e:	46c0      	nop			@ (mov r8, r8)
 8004630:	b007      	add	sp, #28
 8004632:	bd00      	pop	{pc}
 8004634:	08005480 	.word	0x08005480
	...

08004640 <port_lock.lto_priv.21>:
  __ASM volatile ("cpsid i" : : : "memory");
 8004640:	b672      	cpsid	i
}
 8004642:	46c0      	nop			@ (mov r8, r8)
}
 8004644:	46c0      	nop			@ (mov r8, r8)
 8004646:	4770      	bx	lr
	...

08004650 <port_unlock.lto_priv.21>:
  __ASM volatile ("cpsie i" : : : "memory");
 8004650:	b662      	cpsie	i
}
 8004652:	46c0      	nop			@ (mov r8, r8)
}
 8004654:	46c0      	nop			@ (mov r8, r8)
 8004656:	4770      	bx	lr
	...

08004660 <chSysLock.lto_priv.16>:
static inline void chSysLock(void) {
 8004660:	b510      	push	{r4, lr}
  port_lock();
 8004662:	f7ff ffed 	bl	8004640 <port_lock.lto_priv.21>
  __dbg_check_lock();
 8004666:	f7fd fe3b 	bl	80022e0 <__dbg_check_lock>
}
 800466a:	46c0      	nop			@ (mov r8, r8)
 800466c:	bd10      	pop	{r4, pc}
 800466e:	46c0      	nop			@ (mov r8, r8)

08004670 <chSysUnlock.lto_priv.16>:
static inline void chSysUnlock(void) {
 8004670:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8004672:	f7fd fe5d 	bl	8002330 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004676:	4b0e      	ldr	r3, [pc, #56]	@ (80046b0 <chSysUnlock.lto_priv.16+0x40>)
 8004678:	681a      	ldr	r2, [r3, #0]
 800467a:	4b0d      	ldr	r3, [pc, #52]	@ (80046b0 <chSysUnlock.lto_priv.16+0x40>)
 800467c:	1ad3      	subs	r3, r2, r3
 800467e:	1e5a      	subs	r2, r3, #1
 8004680:	4193      	sbcs	r3, r2
 8004682:	b2db      	uxtb	r3, r3
 8004684:	2b00      	cmp	r3, #0
 8004686:	d00f      	beq.n	80046a8 <chSysUnlock.lto_priv.16+0x38>
 8004688:	4b09      	ldr	r3, [pc, #36]	@ (80046b0 <chSysUnlock.lto_priv.16+0x40>)
 800468a:	68db      	ldr	r3, [r3, #12]
 800468c:	689a      	ldr	r2, [r3, #8]
 800468e:	4b08      	ldr	r3, [pc, #32]	@ (80046b0 <chSysUnlock.lto_priv.16+0x40>)
 8004690:	681b      	ldr	r3, [r3, #0]
 8004692:	689b      	ldr	r3, [r3, #8]
 8004694:	429a      	cmp	r2, r3
 8004696:	419b      	sbcs	r3, r3
 8004698:	425b      	negs	r3, r3
 800469a:	b2db      	uxtb	r3, r3
 800469c:	2b00      	cmp	r3, #0
 800469e:	d003      	beq.n	80046a8 <chSysUnlock.lto_priv.16+0x38>
 80046a0:	4b04      	ldr	r3, [pc, #16]	@ (80046b4 <chSysUnlock.lto_priv.16+0x44>)
 80046a2:	0018      	movs	r0, r3
 80046a4:	f7fd fdac 	bl	8002200 <chSysHalt>
  port_unlock();
 80046a8:	f7ff ffd2 	bl	8004650 <port_unlock.lto_priv.21>
}
 80046ac:	46c0      	nop			@ (mov r8, r8)
 80046ae:	bd10      	pop	{r4, pc}
 80046b0:	20000690 	.word	0x20000690
 80046b4:	080054a0 	.word	0x080054a0
	...

080046c0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 80046c0:	4b03      	ldr	r3, [pc, #12]	@ (80046d0 <__core_init+0x10>)
 80046c2:	4a04      	ldr	r2, [pc, #16]	@ (80046d4 <__core_init+0x14>)
 80046c4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 80046c6:	4b02      	ldr	r3, [pc, #8]	@ (80046d0 <__core_init+0x10>)
 80046c8:	4a03      	ldr	r2, [pc, #12]	@ (80046d8 <__core_init+0x18>)
 80046ca:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 80046cc:	46c0      	nop			@ (mov r8, r8)
 80046ce:	4770      	bx	lr
 80046d0:	20001008 	.word	0x20001008
 80046d4:	200013d8 	.word	0x200013d8
 80046d8:	20002000 	.word	0x20002000
 80046dc:	00000000 	.word	0x00000000

080046e0 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 80046e0:	b500      	push	{lr}
 80046e2:	b087      	sub	sp, #28
 80046e4:	9003      	str	r0, [sp, #12]
 80046e6:	9102      	str	r1, [sp, #8]
 80046e8:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 80046ea:	f7fd fef9 	bl	80024e0 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80046ee:	9b02      	ldr	r3, [sp, #8]
 80046f0:	425a      	negs	r2, r3
 80046f2:	4153      	adcs	r3, r2
 80046f4:	b2db      	uxtb	r3, r3
 80046f6:	2b00      	cmp	r3, #0
 80046f8:	d108      	bne.n	800470c <chCoreAllocFromTopI+0x2c>
 80046fa:	9b02      	ldr	r3, [sp, #8]
 80046fc:	3b01      	subs	r3, #1
 80046fe:	9a02      	ldr	r2, [sp, #8]
 8004700:	4013      	ands	r3, r2
 8004702:	1e5a      	subs	r2, r3, #1
 8004704:	4193      	sbcs	r3, r2
 8004706:	b2db      	uxtb	r3, r3
 8004708:	2b00      	cmp	r3, #0
 800470a:	d003      	beq.n	8004714 <chCoreAllocFromTopI+0x34>
 800470c:	4b12      	ldr	r3, [pc, #72]	@ (8004758 <chCoreAllocFromTopI+0x78>)
 800470e:	0018      	movs	r0, r3
 8004710:	f7fd fd76 	bl	8002200 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8004714:	4b11      	ldr	r3, [pc, #68]	@ (800475c <chCoreAllocFromTopI+0x7c>)
 8004716:	685a      	ldr	r2, [r3, #4]
 8004718:	9b03      	ldr	r3, [sp, #12]
 800471a:	425b      	negs	r3, r3
 800471c:	18d3      	adds	r3, r2, r3
 800471e:	001a      	movs	r2, r3
 8004720:	9b02      	ldr	r3, [sp, #8]
 8004722:	425b      	negs	r3, r3
 8004724:	4013      	ands	r3, r2
 8004726:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 8004728:	9b01      	ldr	r3, [sp, #4]
 800472a:	425b      	negs	r3, r3
 800472c:	9a05      	ldr	r2, [sp, #20]
 800472e:	18d3      	adds	r3, r2, r3
 8004730:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8004732:	4b0a      	ldr	r3, [pc, #40]	@ (800475c <chCoreAllocFromTopI+0x7c>)
 8004734:	681b      	ldr	r3, [r3, #0]
 8004736:	9a04      	ldr	r2, [sp, #16]
 8004738:	429a      	cmp	r2, r3
 800473a:	d304      	bcc.n	8004746 <chCoreAllocFromTopI+0x66>
 800473c:	4b07      	ldr	r3, [pc, #28]	@ (800475c <chCoreAllocFromTopI+0x7c>)
 800473e:	685b      	ldr	r3, [r3, #4]
 8004740:	9a04      	ldr	r2, [sp, #16]
 8004742:	429a      	cmp	r2, r3
 8004744:	d901      	bls.n	800474a <chCoreAllocFromTopI+0x6a>
    return NULL;
 8004746:	2300      	movs	r3, #0
 8004748:	e003      	b.n	8004752 <chCoreAllocFromTopI+0x72>
  }

  ch_memcore.topmem = prev;
 800474a:	4b04      	ldr	r3, [pc, #16]	@ (800475c <chCoreAllocFromTopI+0x7c>)
 800474c:	9a04      	ldr	r2, [sp, #16]
 800474e:	605a      	str	r2, [r3, #4]

  return p;
 8004750:	9b05      	ldr	r3, [sp, #20]
}
 8004752:	0018      	movs	r0, r3
 8004754:	b007      	add	sp, #28
 8004756:	bd00      	pop	{pc}
 8004758:	0800548c 	.word	0x0800548c
 800475c:	20001008 	.word	0x20001008

08004760 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8004760:	b500      	push	{lr}
 8004762:	b087      	sub	sp, #28
 8004764:	9003      	str	r0, [sp, #12]
 8004766:	9102      	str	r1, [sp, #8]
 8004768:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 800476a:	f7ff ff79 	bl	8004660 <chSysLock.lto_priv.16>
  p = chCoreAllocFromTopI(size, align, offset);
 800476e:	9a01      	ldr	r2, [sp, #4]
 8004770:	9902      	ldr	r1, [sp, #8]
 8004772:	9b03      	ldr	r3, [sp, #12]
 8004774:	0018      	movs	r0, r3
 8004776:	f7ff ffb3 	bl	80046e0 <chCoreAllocFromTopI>
 800477a:	0003      	movs	r3, r0
 800477c:	9305      	str	r3, [sp, #20]
  chSysUnlock();
 800477e:	f7ff ff77 	bl	8004670 <chSysUnlock.lto_priv.16>

  return p;
 8004782:	9b05      	ldr	r3, [sp, #20]
}
 8004784:	0018      	movs	r0, r3
 8004786:	b007      	add	sp, #28
 8004788:	bd00      	pop	{pc}
 800478a:	46c0      	nop			@ (mov r8, r8)
 800478c:	0000      	movs	r0, r0
	...

08004790 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 8004790:	b510      	push	{r4, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8004792:	4b07      	ldr	r3, [pc, #28]	@ (80047b0 <__heap_init+0x20>)
 8004794:	4a07      	ldr	r2, [pc, #28]	@ (80047b4 <__heap_init+0x24>)
 8004796:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8004798:	4b05      	ldr	r3, [pc, #20]	@ (80047b0 <__heap_init+0x20>)
 800479a:	2200      	movs	r2, #0
 800479c:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 800479e:	4b04      	ldr	r3, [pc, #16]	@ (80047b0 <__heap_init+0x20>)
 80047a0:	2200      	movs	r2, #0
 80047a2:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80047a4:	4b04      	ldr	r3, [pc, #16]	@ (80047b8 <__heap_init+0x28>)
 80047a6:	0018      	movs	r0, r3
 80047a8:	f7ff fdfa 	bl	80043a0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 80047ac:	46c0      	nop			@ (mov r8, r8)
 80047ae:	bd10      	pop	{r4, pc}
 80047b0:	20001010 	.word	0x20001010
 80047b4:	08004761 	.word	0x08004761
 80047b8:	2000101c 	.word	0x2000101c
 80047bc:	00000000 	.word	0x00000000

080047c0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80047c0:	b500      	push	{lr}
 80047c2:	b087      	sub	sp, #28
 80047c4:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80047c6:	9b01      	ldr	r3, [sp, #4]
 80047c8:	425a      	negs	r2, r3
 80047ca:	4153      	adcs	r3, r2
 80047cc:	b2db      	uxtb	r3, r3
 80047ce:	2b00      	cmp	r3, #0
 80047d0:	d107      	bne.n	80047e2 <chHeapFree+0x22>
 80047d2:	9b01      	ldr	r3, [sp, #4]
 80047d4:	2207      	movs	r2, #7
 80047d6:	4013      	ands	r3, r2
 80047d8:	1e5a      	subs	r2, r3, #1
 80047da:	4193      	sbcs	r3, r2
 80047dc:	b2db      	uxtb	r3, r3
 80047de:	2b00      	cmp	r3, #0
 80047e0:	d003      	beq.n	80047ea <chHeapFree+0x2a>
 80047e2:	4b42      	ldr	r3, [pc, #264]	@ (80048ec <chHeapFree+0x12c>)
 80047e4:	0018      	movs	r0, r3
 80047e6:	f7fd fd0b 	bl	8002200 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 80047ea:	9b01      	ldr	r3, [sp, #4]
 80047ec:	3b08      	subs	r3, #8
 80047ee:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 80047f0:	9b04      	ldr	r3, [sp, #16]
 80047f2:	681b      	ldr	r3, [r3, #0]
 80047f4:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 80047f6:	9b03      	ldr	r3, [sp, #12]
 80047f8:	3304      	adds	r3, #4
 80047fa:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80047fc:	9b04      	ldr	r3, [sp, #16]
 80047fe:	685b      	ldr	r3, [r3, #4]
 8004800:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8004802:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8004804:	9b04      	ldr	r3, [sp, #16]
 8004806:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8004808:	9b03      	ldr	r3, [sp, #12]
 800480a:	330c      	adds	r3, #12
 800480c:	0018      	movs	r0, r3
 800480e:	f7ff fde7 	bl	80043e0 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8004812:	9904      	ldr	r1, [sp, #16]
 8004814:	9a05      	ldr	r2, [sp, #20]
 8004816:	2300      	movs	r3, #0
 8004818:	4291      	cmp	r1, r2
 800481a:	415b      	adcs	r3, r3
 800481c:	b2db      	uxtb	r3, r3
 800481e:	2b00      	cmp	r3, #0
 8004820:	d010      	beq.n	8004844 <chHeapFree+0x84>
 8004822:	9b05      	ldr	r3, [sp, #20]
 8004824:	685b      	ldr	r3, [r3, #4]
 8004826:	3301      	adds	r3, #1
 8004828:	00db      	lsls	r3, r3, #3
 800482a:	9a05      	ldr	r2, [sp, #20]
 800482c:	18d3      	adds	r3, r2, r3
 800482e:	9a04      	ldr	r2, [sp, #16]
 8004830:	429a      	cmp	r2, r3
 8004832:	419b      	sbcs	r3, r3
 8004834:	425b      	negs	r3, r3
 8004836:	b2db      	uxtb	r3, r3
 8004838:	2b00      	cmp	r3, #0
 800483a:	d003      	beq.n	8004844 <chHeapFree+0x84>
 800483c:	4b2b      	ldr	r3, [pc, #172]	@ (80048ec <chHeapFree+0x12c>)
 800483e:	0018      	movs	r0, r3
 8004840:	f7fd fcde 	bl	8002200 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8004844:	9b03      	ldr	r3, [sp, #12]
 8004846:	3304      	adds	r3, #4
 8004848:	9a05      	ldr	r2, [sp, #20]
 800484a:	429a      	cmp	r2, r3
 800484c:	d003      	beq.n	8004856 <chHeapFree+0x96>
 800484e:	9a04      	ldr	r2, [sp, #16]
 8004850:	9b05      	ldr	r3, [sp, #20]
 8004852:	429a      	cmp	r2, r3
 8004854:	d93d      	bls.n	80048d2 <chHeapFree+0x112>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8004856:	9b05      	ldr	r3, [sp, #20]
 8004858:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 800485a:	2b00      	cmp	r3, #0
 800485c:	d004      	beq.n	8004868 <chHeapFree+0xa8>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800485e:	9b05      	ldr	r3, [sp, #20]
 8004860:	681b      	ldr	r3, [r3, #0]
 8004862:	9a04      	ldr	r2, [sp, #16]
 8004864:	429a      	cmp	r2, r3
 8004866:	d234      	bcs.n	80048d2 <chHeapFree+0x112>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8004868:	9b05      	ldr	r3, [sp, #20]
 800486a:	681a      	ldr	r2, [r3, #0]
 800486c:	9b04      	ldr	r3, [sp, #16]
 800486e:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8004870:	9b05      	ldr	r3, [sp, #20]
 8004872:	9a04      	ldr	r2, [sp, #16]
 8004874:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8004876:	9b04      	ldr	r3, [sp, #16]
 8004878:	685b      	ldr	r3, [r3, #4]
 800487a:	3301      	adds	r3, #1
 800487c:	00db      	lsls	r3, r3, #3
 800487e:	9a04      	ldr	r2, [sp, #16]
 8004880:	18d2      	adds	r2, r2, r3
 8004882:	9b04      	ldr	r3, [sp, #16]
 8004884:	681b      	ldr	r3, [r3, #0]
 8004886:	429a      	cmp	r2, r3
 8004888:	d10d      	bne.n	80048a6 <chHeapFree+0xe6>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800488a:	9b04      	ldr	r3, [sp, #16]
 800488c:	685a      	ldr	r2, [r3, #4]
 800488e:	9b04      	ldr	r3, [sp, #16]
 8004890:	681b      	ldr	r3, [r3, #0]
 8004892:	685b      	ldr	r3, [r3, #4]
 8004894:	18d3      	adds	r3, r2, r3
 8004896:	1c5a      	adds	r2, r3, #1
 8004898:	9b04      	ldr	r3, [sp, #16]
 800489a:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800489c:	9b04      	ldr	r3, [sp, #16]
 800489e:	681b      	ldr	r3, [r3, #0]
 80048a0:	681a      	ldr	r2, [r3, #0]
 80048a2:	9b04      	ldr	r3, [sp, #16]
 80048a4:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 80048a6:	9b05      	ldr	r3, [sp, #20]
 80048a8:	685b      	ldr	r3, [r3, #4]
 80048aa:	3301      	adds	r3, #1
 80048ac:	00db      	lsls	r3, r3, #3
 80048ae:	9a05      	ldr	r2, [sp, #20]
 80048b0:	18d3      	adds	r3, r2, r3
 80048b2:	9a04      	ldr	r2, [sp, #16]
 80048b4:	429a      	cmp	r2, r3
 80048b6:	d110      	bne.n	80048da <chHeapFree+0x11a>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80048b8:	9b05      	ldr	r3, [sp, #20]
 80048ba:	685a      	ldr	r2, [r3, #4]
 80048bc:	9b04      	ldr	r3, [sp, #16]
 80048be:	685b      	ldr	r3, [r3, #4]
 80048c0:	18d3      	adds	r3, r2, r3
 80048c2:	1c5a      	adds	r2, r3, #1
 80048c4:	9b05      	ldr	r3, [sp, #20]
 80048c6:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 80048c8:	9b04      	ldr	r3, [sp, #16]
 80048ca:	681a      	ldr	r2, [r3, #0]
 80048cc:	9b05      	ldr	r3, [sp, #20]
 80048ce:	601a      	str	r2, [r3, #0]
      }
      break;
 80048d0:	e003      	b.n	80048da <chHeapFree+0x11a>
    }
    qp = H_NEXT(qp);
 80048d2:	9b05      	ldr	r3, [sp, #20]
 80048d4:	681b      	ldr	r3, [r3, #0]
 80048d6:	9305      	str	r3, [sp, #20]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 80048d8:	e79b      	b.n	8004812 <chHeapFree+0x52>
      break;
 80048da:	46c0      	nop			@ (mov r8, r8)
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80048dc:	9b03      	ldr	r3, [sp, #12]
 80048de:	330c      	adds	r3, #12
 80048e0:	0018      	movs	r0, r3
 80048e2:	f7ff fe25 	bl	8004530 <chMtxUnlock>

  return;
 80048e6:	46c0      	nop			@ (mov r8, r8)
}
 80048e8:	b007      	add	sp, #28
 80048ea:	bd00      	pop	{pc}
 80048ec:	080054ac 	.word	0x080054ac

080048f0 <port_lock.lto_priv.22>:
  __ASM volatile ("cpsid i" : : : "memory");
 80048f0:	b672      	cpsid	i
}
 80048f2:	46c0      	nop			@ (mov r8, r8)
}
 80048f4:	46c0      	nop			@ (mov r8, r8)
 80048f6:	4770      	bx	lr
	...

08004900 <port_unlock.lto_priv.22>:
  __ASM volatile ("cpsie i" : : : "memory");
 8004900:	b662      	cpsie	i
}
 8004902:	46c0      	nop			@ (mov r8, r8)
}
 8004904:	46c0      	nop			@ (mov r8, r8)
 8004906:	4770      	bx	lr
	...

08004910 <chSysLock.lto_priv.17>:
static inline void chSysLock(void) {
 8004910:	b510      	push	{r4, lr}
  port_lock();
 8004912:	f7ff ffed 	bl	80048f0 <port_lock.lto_priv.22>
  __dbg_check_lock();
 8004916:	f7fd fce3 	bl	80022e0 <__dbg_check_lock>
}
 800491a:	46c0      	nop			@ (mov r8, r8)
 800491c:	bd10      	pop	{r4, pc}
 800491e:	46c0      	nop			@ (mov r8, r8)

08004920 <chSysUnlock.lto_priv.17>:
static inline void chSysUnlock(void) {
 8004920:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8004922:	f7fd fd05 	bl	8002330 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004926:	4b0e      	ldr	r3, [pc, #56]	@ (8004960 <chSysUnlock.lto_priv.17+0x40>)
 8004928:	681a      	ldr	r2, [r3, #0]
 800492a:	4b0d      	ldr	r3, [pc, #52]	@ (8004960 <chSysUnlock.lto_priv.17+0x40>)
 800492c:	1ad3      	subs	r3, r2, r3
 800492e:	1e5a      	subs	r2, r3, #1
 8004930:	4193      	sbcs	r3, r2
 8004932:	b2db      	uxtb	r3, r3
 8004934:	2b00      	cmp	r3, #0
 8004936:	d00f      	beq.n	8004958 <chSysUnlock.lto_priv.17+0x38>
 8004938:	4b09      	ldr	r3, [pc, #36]	@ (8004960 <chSysUnlock.lto_priv.17+0x40>)
 800493a:	68db      	ldr	r3, [r3, #12]
 800493c:	689a      	ldr	r2, [r3, #8]
 800493e:	4b08      	ldr	r3, [pc, #32]	@ (8004960 <chSysUnlock.lto_priv.17+0x40>)
 8004940:	681b      	ldr	r3, [r3, #0]
 8004942:	689b      	ldr	r3, [r3, #8]
 8004944:	429a      	cmp	r2, r3
 8004946:	419b      	sbcs	r3, r3
 8004948:	425b      	negs	r3, r3
 800494a:	b2db      	uxtb	r3, r3
 800494c:	2b00      	cmp	r3, #0
 800494e:	d003      	beq.n	8004958 <chSysUnlock.lto_priv.17+0x38>
 8004950:	4b04      	ldr	r3, [pc, #16]	@ (8004964 <chSysUnlock.lto_priv.17+0x44>)
 8004952:	0018      	movs	r0, r3
 8004954:	f7fd fc54 	bl	8002200 <chSysHalt>
  port_unlock();
 8004958:	f7ff ffd2 	bl	8004900 <port_unlock.lto_priv.22>
}
 800495c:	46c0      	nop			@ (mov r8, r8)
 800495e:	bd10      	pop	{r4, pc}
 8004960:	20000690 	.word	0x20000690
 8004964:	080054d0 	.word	0x080054d0
	...

08004970 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8004970:	b500      	push	{lr}
 8004972:	b085      	sub	sp, #20
 8004974:	9003      	str	r0, [sp, #12]
 8004976:	9102      	str	r1, [sp, #8]
 8004978:	9201      	str	r2, [sp, #4]
 800497a:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 800497c:	9b03      	ldr	r3, [sp, #12]
 800497e:	425a      	negs	r2, r3
 8004980:	4153      	adcs	r3, r2
 8004982:	b2db      	uxtb	r3, r3
 8004984:	2b00      	cmp	r3, #0
 8004986:	d107      	bne.n	8004998 <chPoolObjectInitAligned+0x28>
 8004988:	9a02      	ldr	r2, [sp, #8]
 800498a:	2103      	movs	r1, #3
 800498c:	2300      	movs	r3, #0
 800498e:	4291      	cmp	r1, r2
 8004990:	415b      	adcs	r3, r3
 8004992:	b2db      	uxtb	r3, r3
 8004994:	2b00      	cmp	r3, #0
 8004996:	d001      	beq.n	800499c <chPoolObjectInitAligned+0x2c>
 8004998:	2301      	movs	r3, #1
 800499a:	e000      	b.n	800499e <chPoolObjectInitAligned+0x2e>
 800499c:	2300      	movs	r3, #0
 800499e:	2b00      	cmp	r3, #0
 80049a0:	d107      	bne.n	80049b2 <chPoolObjectInitAligned+0x42>
 80049a2:	9a01      	ldr	r2, [sp, #4]
 80049a4:	2103      	movs	r1, #3
 80049a6:	2300      	movs	r3, #0
 80049a8:	4291      	cmp	r1, r2
 80049aa:	415b      	adcs	r3, r3
 80049ac:	b2db      	uxtb	r3, r3
 80049ae:	2b00      	cmp	r3, #0
 80049b0:	d001      	beq.n	80049b6 <chPoolObjectInitAligned+0x46>
 80049b2:	2301      	movs	r3, #1
 80049b4:	e000      	b.n	80049b8 <chPoolObjectInitAligned+0x48>
 80049b6:	2300      	movs	r3, #0
 80049b8:	2b00      	cmp	r3, #0
 80049ba:	d113      	bne.n	80049e4 <chPoolObjectInitAligned+0x74>
 80049bc:	9b01      	ldr	r3, [sp, #4]
 80049be:	425a      	negs	r2, r3
 80049c0:	4153      	adcs	r3, r2
 80049c2:	b2db      	uxtb	r3, r3
 80049c4:	2b00      	cmp	r3, #0
 80049c6:	d108      	bne.n	80049da <chPoolObjectInitAligned+0x6a>
 80049c8:	9b01      	ldr	r3, [sp, #4]
 80049ca:	3b01      	subs	r3, #1
 80049cc:	9a01      	ldr	r2, [sp, #4]
 80049ce:	4013      	ands	r3, r2
 80049d0:	1e5a      	subs	r2, r3, #1
 80049d2:	4193      	sbcs	r3, r2
 80049d4:	b2db      	uxtb	r3, r3
 80049d6:	2b00      	cmp	r3, #0
 80049d8:	d001      	beq.n	80049de <chPoolObjectInitAligned+0x6e>
 80049da:	2301      	movs	r3, #1
 80049dc:	e000      	b.n	80049e0 <chPoolObjectInitAligned+0x70>
 80049de:	2300      	movs	r3, #0
 80049e0:	2b00      	cmp	r3, #0
 80049e2:	d003      	beq.n	80049ec <chPoolObjectInitAligned+0x7c>
 80049e4:	4b09      	ldr	r3, [pc, #36]	@ (8004a0c <chPoolObjectInitAligned+0x9c>)
 80049e6:	0018      	movs	r0, r3
 80049e8:	f7fd fc0a 	bl	8002200 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 80049ec:	9b03      	ldr	r3, [sp, #12]
 80049ee:	2200      	movs	r2, #0
 80049f0:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 80049f2:	9b03      	ldr	r3, [sp, #12]
 80049f4:	9a02      	ldr	r2, [sp, #8]
 80049f6:	605a      	str	r2, [r3, #4]
  mp->align = align;
 80049f8:	9b03      	ldr	r3, [sp, #12]
 80049fa:	9a01      	ldr	r2, [sp, #4]
 80049fc:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 80049fe:	9b03      	ldr	r3, [sp, #12]
 8004a00:	9a00      	ldr	r2, [sp, #0]
 8004a02:	60da      	str	r2, [r3, #12]
}
 8004a04:	46c0      	nop			@ (mov r8, r8)
 8004a06:	b005      	add	sp, #20
 8004a08:	bd00      	pop	{pc}
 8004a0a:	46c0      	nop			@ (mov r8, r8)
 8004a0c:	080054b8 	.word	0x080054b8

08004a10 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8004a10:	b500      	push	{lr}
 8004a12:	b085      	sub	sp, #20
 8004a14:	9001      	str	r0, [sp, #4]
 8004a16:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8004a18:	9b00      	ldr	r3, [sp, #0]
 8004a1a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 8004a1c:	f7fd fd60 	bl	80024e0 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8004a20:	9b01      	ldr	r3, [sp, #4]
 8004a22:	425a      	negs	r2, r3
 8004a24:	4153      	adcs	r3, r2
 8004a26:	b2db      	uxtb	r3, r3
 8004a28:	2b00      	cmp	r3, #0
 8004a2a:	d105      	bne.n	8004a38 <chPoolFreeI+0x28>
 8004a2c:	9b00      	ldr	r3, [sp, #0]
 8004a2e:	425a      	negs	r2, r3
 8004a30:	4153      	adcs	r3, r2
 8004a32:	b2db      	uxtb	r3, r3
 8004a34:	2b00      	cmp	r3, #0
 8004a36:	d001      	beq.n	8004a3c <chPoolFreeI+0x2c>
 8004a38:	2301      	movs	r3, #1
 8004a3a:	e000      	b.n	8004a3e <chPoolFreeI+0x2e>
 8004a3c:	2300      	movs	r3, #0
 8004a3e:	2b00      	cmp	r3, #0
 8004a40:	d109      	bne.n	8004a56 <chPoolFreeI+0x46>
 8004a42:	9b01      	ldr	r3, [sp, #4]
 8004a44:	689b      	ldr	r3, [r3, #8]
 8004a46:	3b01      	subs	r3, #1
 8004a48:	9a00      	ldr	r2, [sp, #0]
 8004a4a:	4013      	ands	r3, r2
 8004a4c:	1e5a      	subs	r2, r3, #1
 8004a4e:	4193      	sbcs	r3, r2
 8004a50:	b2db      	uxtb	r3, r3
 8004a52:	2b00      	cmp	r3, #0
 8004a54:	d003      	beq.n	8004a5e <chPoolFreeI+0x4e>
 8004a56:	4b07      	ldr	r3, [pc, #28]	@ (8004a74 <chPoolFreeI+0x64>)
 8004a58:	0018      	movs	r0, r3
 8004a5a:	f7fd fbd1 	bl	8002200 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8004a5e:	9b01      	ldr	r3, [sp, #4]
 8004a60:	681a      	ldr	r2, [r3, #0]
 8004a62:	9b03      	ldr	r3, [sp, #12]
 8004a64:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8004a66:	9b01      	ldr	r3, [sp, #4]
 8004a68:	9a03      	ldr	r2, [sp, #12]
 8004a6a:	601a      	str	r2, [r3, #0]
}
 8004a6c:	46c0      	nop			@ (mov r8, r8)
 8004a6e:	b005      	add	sp, #20
 8004a70:	bd00      	pop	{pc}
 8004a72:	46c0      	nop			@ (mov r8, r8)
 8004a74:	080054dc 	.word	0x080054dc
	...

08004a80 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8004a80:	b500      	push	{lr}
 8004a82:	b083      	sub	sp, #12
 8004a84:	9001      	str	r0, [sp, #4]
 8004a86:	9100      	str	r1, [sp, #0]

  chSysLock();
 8004a88:	f7ff ff42 	bl	8004910 <chSysLock.lto_priv.17>
  chPoolFreeI(mp, objp);
 8004a8c:	9a00      	ldr	r2, [sp, #0]
 8004a8e:	9b01      	ldr	r3, [sp, #4]
 8004a90:	0011      	movs	r1, r2
 8004a92:	0018      	movs	r0, r3
 8004a94:	f7ff ffbc 	bl	8004a10 <chPoolFreeI>
  chSysUnlock();
 8004a98:	f7ff ff42 	bl	8004920 <chSysUnlock.lto_priv.17>
}
 8004a9c:	46c0      	nop			@ (mov r8, r8)
 8004a9e:	b003      	add	sp, #12
 8004aa0:	bd00      	pop	{pc}
 8004aa2:	46c0      	nop			@ (mov r8, r8)
	...

08004ab0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8004ab0:	b500      	push	{lr}
 8004ab2:	b083      	sub	sp, #12
 8004ab4:	9001      	str	r0, [sp, #4]
 8004ab6:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8004ab8:	9900      	ldr	r1, [sp, #0]
 8004aba:	9b01      	ldr	r3, [sp, #4]
 8004abc:	2200      	movs	r2, #0
 8004abe:	0018      	movs	r0, r3
 8004ac0:	f7ff fe0e 	bl	80046e0 <chCoreAllocFromTopI>
 8004ac4:	0003      	movs	r3, r0
}
 8004ac6:	0018      	movs	r0, r3
 8004ac8:	b003      	add	sp, #12
 8004aca:	bd00      	pop	{pc}
 8004acc:	0000      	movs	r0, r0
	...

08004ad0 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8004ad0:	b500      	push	{lr}
 8004ad2:	b085      	sub	sp, #20
 8004ad4:	9003      	str	r0, [sp, #12]
 8004ad6:	9102      	str	r1, [sp, #8]
 8004ad8:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8004ada:	9b01      	ldr	r3, [sp, #4]
 8004adc:	9902      	ldr	r1, [sp, #8]
 8004ade:	9803      	ldr	r0, [sp, #12]
 8004ae0:	2204      	movs	r2, #4
 8004ae2:	f7ff ff45 	bl	8004970 <chPoolObjectInitAligned>
}
 8004ae6:	46c0      	nop			@ (mov r8, r8)
 8004ae8:	b005      	add	sp, #20
 8004aea:	bd00      	pop	{pc}
 8004aec:	0000      	movs	r0, r0
	...

08004af0 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8004af0:	b082      	sub	sp, #8
 8004af2:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8004af4:	9b01      	ldr	r3, [sp, #4]
 8004af6:	9a01      	ldr	r2, [sp, #4]
 8004af8:	601a      	str	r2, [r3, #0]
}
 8004afa:	46c0      	nop			@ (mov r8, r8)
 8004afc:	b002      	add	sp, #8
 8004afe:	4770      	bx	lr

08004b00 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8004b00:	b510      	push	{r4, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8004b02:	4b15      	ldr	r3, [pc, #84]	@ (8004b58 <__factory_init+0x58>)
 8004b04:	0018      	movs	r0, r3
 8004b06:	f7ff fc4b 	bl	80043a0 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8004b0a:	4b14      	ldr	r3, [pc, #80]	@ (8004b5c <__factory_init+0x5c>)
 8004b0c:	0018      	movs	r0, r3
 8004b0e:	f7ff ffef 	bl	8004af0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8004b12:	4a13      	ldr	r2, [pc, #76]	@ (8004b60 <__factory_init+0x60>)
 8004b14:	4b13      	ldr	r3, [pc, #76]	@ (8004b64 <__factory_init+0x64>)
 8004b16:	2114      	movs	r1, #20
 8004b18:	0018      	movs	r0, r3
 8004b1a:	f7ff ffd9 	bl	8004ad0 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8004b1e:	4b12      	ldr	r3, [pc, #72]	@ (8004b68 <__factory_init+0x68>)
 8004b20:	0018      	movs	r0, r3
 8004b22:	f7ff ffe5 	bl	8004af0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8004b26:	4b11      	ldr	r3, [pc, #68]	@ (8004b6c <__factory_init+0x6c>)
 8004b28:	0018      	movs	r0, r3
 8004b2a:	f7ff ffe1 	bl	8004af0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8004b2e:	4a0c      	ldr	r2, [pc, #48]	@ (8004b60 <__factory_init+0x60>)
 8004b30:	4b0f      	ldr	r3, [pc, #60]	@ (8004b70 <__factory_init+0x70>)
 8004b32:	211c      	movs	r1, #28
 8004b34:	0018      	movs	r0, r3
 8004b36:	f7ff ffcb 	bl	8004ad0 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8004b3a:	4b0e      	ldr	r3, [pc, #56]	@ (8004b74 <__factory_init+0x74>)
 8004b3c:	0018      	movs	r0, r3
 8004b3e:	f7ff ffd7 	bl	8004af0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8004b42:	4b0d      	ldr	r3, [pc, #52]	@ (8004b78 <__factory_init+0x78>)
 8004b44:	0018      	movs	r0, r3
 8004b46:	f7ff ffd3 	bl	8004af0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 8004b4a:	4b0c      	ldr	r3, [pc, #48]	@ (8004b7c <__factory_init+0x7c>)
 8004b4c:	0018      	movs	r0, r3
 8004b4e:	f7ff ffcf 	bl	8004af0 <dyn_list_init>
#endif
}
 8004b52:	46c0      	nop			@ (mov r8, r8)
 8004b54:	bd10      	pop	{r4, pc}
 8004b56:	46c0      	nop			@ (mov r8, r8)
 8004b58:	2000102c 	.word	0x2000102c
 8004b5c:	2000103c 	.word	0x2000103c
 8004b60:	08004ab1 	.word	0x08004ab1
 8004b64:	20001040 	.word	0x20001040
 8004b68:	20001050 	.word	0x20001050
 8004b6c:	20001054 	.word	0x20001054
 8004b70:	20001058 	.word	0x20001058
 8004b74:	20001068 	.word	0x20001068
 8004b78:	2000106c 	.word	0x2000106c
 8004b7c:	20001070 	.word	0x20001070

08004b80 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8004b80:	b510      	push	{r4, lr}
 8004b82:	b082      	sub	sp, #8
 8004b84:	0002      	movs	r2, r0
 8004b86:	9100      	str	r1, [sp, #0]
 8004b88:	466b      	mov	r3, sp
 8004b8a:	3307      	adds	r3, #7
 8004b8c:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8004b8e:	466b      	mov	r3, sp
 8004b90:	3307      	adds	r3, #7
 8004b92:	781b      	ldrb	r3, [r3, #0]
 8004b94:	2b7f      	cmp	r3, #127	@ 0x7f
 8004b96:	d82c      	bhi.n	8004bf2 <__NVIC_SetPriority+0x72>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004b98:	4a32      	ldr	r2, [pc, #200]	@ (8004c64 <__NVIC_SetPriority+0xe4>)
 8004b9a:	466b      	mov	r3, sp
 8004b9c:	3307      	adds	r3, #7
 8004b9e:	781b      	ldrb	r3, [r3, #0]
 8004ba0:	b25b      	sxtb	r3, r3
 8004ba2:	089b      	lsrs	r3, r3, #2
 8004ba4:	33c0      	adds	r3, #192	@ 0xc0
 8004ba6:	009b      	lsls	r3, r3, #2
 8004ba8:	589b      	ldr	r3, [r3, r2]
 8004baa:	466a      	mov	r2, sp
 8004bac:	3207      	adds	r2, #7
 8004bae:	7812      	ldrb	r2, [r2, #0]
 8004bb0:	0011      	movs	r1, r2
 8004bb2:	2203      	movs	r2, #3
 8004bb4:	400a      	ands	r2, r1
 8004bb6:	00d2      	lsls	r2, r2, #3
 8004bb8:	21ff      	movs	r1, #255	@ 0xff
 8004bba:	4091      	lsls	r1, r2
 8004bbc:	000a      	movs	r2, r1
 8004bbe:	43d2      	mvns	r2, r2
 8004bc0:	401a      	ands	r2, r3
 8004bc2:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8004bc4:	9b00      	ldr	r3, [sp, #0]
 8004bc6:	019b      	lsls	r3, r3, #6
 8004bc8:	22ff      	movs	r2, #255	@ 0xff
 8004bca:	401a      	ands	r2, r3
 8004bcc:	466b      	mov	r3, sp
 8004bce:	3307      	adds	r3, #7
 8004bd0:	781b      	ldrb	r3, [r3, #0]
 8004bd2:	0018      	movs	r0, r3
 8004bd4:	2303      	movs	r3, #3
 8004bd6:	4003      	ands	r3, r0
 8004bd8:	00db      	lsls	r3, r3, #3
 8004bda:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004bdc:	4821      	ldr	r0, [pc, #132]	@ (8004c64 <__NVIC_SetPriority+0xe4>)
 8004bde:	466b      	mov	r3, sp
 8004be0:	3307      	adds	r3, #7
 8004be2:	781b      	ldrb	r3, [r3, #0]
 8004be4:	b25b      	sxtb	r3, r3
 8004be6:	089b      	lsrs	r3, r3, #2
 8004be8:	430a      	orrs	r2, r1
 8004bea:	33c0      	adds	r3, #192	@ 0xc0
 8004bec:	009b      	lsls	r3, r3, #2
 8004bee:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8004bf0:	e035      	b.n	8004c5e <__NVIC_SetPriority+0xde>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004bf2:	4a1d      	ldr	r2, [pc, #116]	@ (8004c68 <__NVIC_SetPriority+0xe8>)
 8004bf4:	466b      	mov	r3, sp
 8004bf6:	3307      	adds	r3, #7
 8004bf8:	781b      	ldrb	r3, [r3, #0]
 8004bfa:	0019      	movs	r1, r3
 8004bfc:	230f      	movs	r3, #15
 8004bfe:	400b      	ands	r3, r1
 8004c00:	3b08      	subs	r3, #8
 8004c02:	089b      	lsrs	r3, r3, #2
 8004c04:	3306      	adds	r3, #6
 8004c06:	009b      	lsls	r3, r3, #2
 8004c08:	18d3      	adds	r3, r2, r3
 8004c0a:	3304      	adds	r3, #4
 8004c0c:	681b      	ldr	r3, [r3, #0]
 8004c0e:	466a      	mov	r2, sp
 8004c10:	3207      	adds	r2, #7
 8004c12:	7812      	ldrb	r2, [r2, #0]
 8004c14:	0011      	movs	r1, r2
 8004c16:	2203      	movs	r2, #3
 8004c18:	400a      	ands	r2, r1
 8004c1a:	00d2      	lsls	r2, r2, #3
 8004c1c:	21ff      	movs	r1, #255	@ 0xff
 8004c1e:	4091      	lsls	r1, r2
 8004c20:	000a      	movs	r2, r1
 8004c22:	43d2      	mvns	r2, r2
 8004c24:	401a      	ands	r2, r3
 8004c26:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8004c28:	9b00      	ldr	r3, [sp, #0]
 8004c2a:	019b      	lsls	r3, r3, #6
 8004c2c:	22ff      	movs	r2, #255	@ 0xff
 8004c2e:	401a      	ands	r2, r3
 8004c30:	466b      	mov	r3, sp
 8004c32:	3307      	adds	r3, #7
 8004c34:	781b      	ldrb	r3, [r3, #0]
 8004c36:	0018      	movs	r0, r3
 8004c38:	2303      	movs	r3, #3
 8004c3a:	4003      	ands	r3, r0
 8004c3c:	00db      	lsls	r3, r3, #3
 8004c3e:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004c40:	4809      	ldr	r0, [pc, #36]	@ (8004c68 <__NVIC_SetPriority+0xe8>)
 8004c42:	466b      	mov	r3, sp
 8004c44:	3307      	adds	r3, #7
 8004c46:	781b      	ldrb	r3, [r3, #0]
 8004c48:	001c      	movs	r4, r3
 8004c4a:	230f      	movs	r3, #15
 8004c4c:	4023      	ands	r3, r4
 8004c4e:	3b08      	subs	r3, #8
 8004c50:	089b      	lsrs	r3, r3, #2
 8004c52:	430a      	orrs	r2, r1
 8004c54:	3306      	adds	r3, #6
 8004c56:	009b      	lsls	r3, r3, #2
 8004c58:	18c3      	adds	r3, r0, r3
 8004c5a:	3304      	adds	r3, #4
 8004c5c:	601a      	str	r2, [r3, #0]
}
 8004c5e:	46c0      	nop			@ (mov r8, r8)
 8004c60:	b002      	add	sp, #8
 8004c62:	bd10      	pop	{r4, pc}
 8004c64:	e000e100 	.word	0xe000e100
 8004c68:	e000ed00 	.word	0xe000ed00
 8004c6c:	00000000 	.word	0x00000000

08004c70 <port_lock.lto_priv.26>:
  __ASM volatile ("cpsid i" : : : "memory");
 8004c70:	b672      	cpsid	i
}
 8004c72:	46c0      	nop			@ (mov r8, r8)
}
 8004c74:	46c0      	nop			@ (mov r8, r8)
 8004c76:	4770      	bx	lr
	...

08004c80 <port_unlock.lto_priv.26>:
  __ASM volatile ("cpsie i" : : : "memory");
 8004c80:	b662      	cpsie	i
}
 8004c82:	46c0      	nop			@ (mov r8, r8)
}
 8004c84:	46c0      	nop			@ (mov r8, r8)
 8004c86:	4770      	bx	lr
	...

08004c90 <port_lock_from_isr.lto_priv.7>:
static inline void port_lock_from_isr(void) {
 8004c90:	b510      	push	{r4, lr}
  port_lock();
 8004c92:	f7ff ffed 	bl	8004c70 <port_lock.lto_priv.26>
}
 8004c96:	46c0      	nop			@ (mov r8, r8)
 8004c98:	bd10      	pop	{r4, pc}
 8004c9a:	46c0      	nop			@ (mov r8, r8)
 8004c9c:	0000      	movs	r0, r0
	...

08004ca0 <port_unlock_from_isr.lto_priv.7>:
static inline void port_unlock_from_isr(void) {
 8004ca0:	b510      	push	{r4, lr}
  port_unlock();
 8004ca2:	f7ff ffed 	bl	8004c80 <port_unlock.lto_priv.26>
}
 8004ca6:	46c0      	nop			@ (mov r8, r8)
 8004ca8:	bd10      	pop	{r4, pc}
 8004caa:	46c0      	nop			@ (mov r8, r8)
 8004cac:	0000      	movs	r0, r0
	...

08004cb0 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8004cb0:	b500      	push	{lr}
 8004cb2:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004cb4:	f3ef 8309 	mrs	r3, PSP
 8004cb8:	9301      	str	r3, [sp, #4]
  return(result);
 8004cba:	9b01      	ldr	r3, [sp, #4]
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 8004cbc:	9303      	str	r3, [sp, #12]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8004cbe:	9b03      	ldr	r3, [sp, #12]
 8004cc0:	3320      	adds	r3, #32
 8004cc2:	9303      	str	r3, [sp, #12]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8004cc4:	9b03      	ldr	r3, [sp, #12]
 8004cc6:	9302      	str	r3, [sp, #8]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004cc8:	9b02      	ldr	r3, [sp, #8]
 8004cca:	f383 8809 	msr	PSP, r3
}
 8004cce:	46c0      	nop			@ (mov r8, r8)

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8004cd0:	f7ff ffe6 	bl	8004ca0 <port_unlock_from_isr.lto_priv.7>
}
 8004cd4:	46c0      	nop			@ (mov r8, r8)
 8004cd6:	b005      	add	sp, #20
 8004cd8:	bd00      	pop	{pc}
 8004cda:	46c0      	nop			@ (mov r8, r8)
 8004cdc:	0000      	movs	r0, r0
	...

08004ce0 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004ce0:	b500      	push	{lr}
 8004ce2:	b083      	sub	sp, #12
 8004ce4:	9001      	str	r0, [sp, #4]

  (void)oip;

  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004ce6:	2302      	movs	r3, #2
 8004ce8:	425b      	negs	r3, r3
 8004cea:	2100      	movs	r1, #0
 8004cec:	0018      	movs	r0, r3
 8004cee:	f7ff ff47 	bl	8004b80 <__NVIC_SetPriority>
}
 8004cf2:	46c0      	nop			@ (mov r8, r8)
 8004cf4:	b003      	add	sp, #12
 8004cf6:	bd00      	pop	{pc}
	...

08004d00 <__port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void __port_irq_epilogue(uint32_t lr) {
 8004d00:	b500      	push	{lr}
 8004d02:	b087      	sub	sp, #28
 8004d04:	9001      	str	r0, [sp, #4]

  if (lr != 0xFFFFFFF1U) {
 8004d06:	9b01      	ldr	r3, [sp, #4]
 8004d08:	330f      	adds	r3, #15
 8004d0a:	d01e      	beq.n	8004d4a <__port_irq_epilogue+0x4a>
    struct port_extctx *ectxp;

    port_lock_from_isr();
 8004d0c:	f7ff ffc0 	bl	8004c90 <port_lock_from_isr.lto_priv.7>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004d10:	f3ef 8309 	mrs	r3, PSP
 8004d14:	9303      	str	r3, [sp, #12]
  return(result);
 8004d16:	9b03      	ldr	r3, [sp, #12]

    /* The extctx structure is pointed by the PSP register.*/
    ectxp = (struct port_extctx *)__get_PSP();
 8004d18:	9305      	str	r3, [sp, #20]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ectxp--;
 8004d1a:	9b05      	ldr	r3, [sp, #20]
 8004d1c:	3b20      	subs	r3, #32
 8004d1e:	9305      	str	r3, [sp, #20]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ectxp);
 8004d20:	9b05      	ldr	r3, [sp, #20]
 8004d22:	9304      	str	r3, [sp, #16]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004d24:	9b04      	ldr	r3, [sp, #16]
 8004d26:	f383 8809 	msr	PSP, r3
}
 8004d2a:	46c0      	nop			@ (mov r8, r8)

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8004d2c:	9b05      	ldr	r3, [sp, #20]
 8004d2e:	2280      	movs	r2, #128	@ 0x80
 8004d30:	0452      	lsls	r2, r2, #17
 8004d32:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004d34:	f7fe fcac 	bl	8003690 <chSchIsPreemptionRequired>
 8004d38:	1e03      	subs	r3, r0, #0
 8004d3a:	d003      	beq.n	8004d44 <__port_irq_epilogue+0x44>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8004d3c:	4a04      	ldr	r2, [pc, #16]	@ (8004d50 <__port_irq_epilogue+0x50>)
 8004d3e:	9b05      	ldr	r3, [sp, #20]
 8004d40:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8004d42:	e002      	b.n	8004d4a <__port_irq_epilogue+0x4a>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8004d44:	4a03      	ldr	r2, [pc, #12]	@ (8004d54 <__port_irq_epilogue+0x54>)
 8004d46:	9b05      	ldr	r3, [sp, #20]
 8004d48:	619a      	str	r2, [r3, #24]
}
 8004d4a:	46c0      	nop			@ (mov r8, r8)
 8004d4c:	b007      	add	sp, #28
 8004d4e:	bd00      	pop	{pc}
 8004d50:	080001cb 	.word	0x080001cb
 8004d54:	080001d6 	.word	0x080001d6
	...

08004d60 <portab_setup>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

void portab_setup(void) {
 8004d60:	b510      	push	{r4, lr}

  /* ADC inputs.*/
  palSetGroupMode(GPIOA, PAL_PORT_BIT(0), 0, PAL_MODE_INPUT_ANALOG);
 8004d62:	23a0      	movs	r3, #160	@ 0xa0
 8004d64:	05db      	lsls	r3, r3, #23
 8004d66:	2203      	movs	r2, #3
 8004d68:	2101      	movs	r1, #1
 8004d6a:	0018      	movs	r0, r3
 8004d6c:	f7fc fee0 	bl	8001b30 <_pal_lld_setgroupmode>
}
 8004d70:	46c0      	nop			@ (mov r8, r8)
 8004d72:	bd10      	pop	{r4, pc}
	...

08004d80 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8004d80:	b082      	sub	sp, #8
 8004d82:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8004d84:	4b03      	ldr	r3, [pc, #12]	@ (8004d94 <chRegSetThreadName+0x14>)
 8004d86:	68db      	ldr	r3, [r3, #12]
 8004d88:	9a01      	ldr	r2, [sp, #4]
 8004d8a:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 8004d8c:	46c0      	nop			@ (mov r8, r8)
 8004d8e:	b002      	add	sp, #8
 8004d90:	4770      	bx	lr
 8004d92:	46c0      	nop			@ (mov r8, r8)
 8004d94:	20000690 	.word	0x20000690
	...

08004da0 <adccallback>:

/*
 * ADC streaming callback.
 */
size_t n= 0, nx = 0, ny = 0;
void adccallback(ADCDriver *adcp) {
 8004da0:	b500      	push	{lr}
 8004da2:	b083      	sub	sp, #12
 8004da4:	9001      	str	r0, [sp, #4]

  /* Updating counters.*/
  n++;
 8004da6:	4b0e      	ldr	r3, [pc, #56]	@ (8004de0 <adccallback+0x40>)
 8004da8:	681b      	ldr	r3, [r3, #0]
 8004daa:	1c5a      	adds	r2, r3, #1
 8004dac:	4b0c      	ldr	r3, [pc, #48]	@ (8004de0 <adccallback+0x40>)
 8004dae:	601a      	str	r2, [r3, #0]
  if (adcIsBufferComplete(adcp)) {
 8004db0:	9b01      	ldr	r3, [sp, #4]
 8004db2:	781b      	ldrb	r3, [r3, #0]
 8004db4:	2b04      	cmp	r3, #4
 8004db6:	d105      	bne.n	8004dc4 <adccallback+0x24>
    nx += 1;
 8004db8:	4b0a      	ldr	r3, [pc, #40]	@ (8004de4 <adccallback+0x44>)
 8004dba:	681b      	ldr	r3, [r3, #0]
 8004dbc:	1c5a      	adds	r2, r3, #1
 8004dbe:	4b09      	ldr	r3, [pc, #36]	@ (8004de4 <adccallback+0x44>)
 8004dc0:	601a      	str	r2, [r3, #0]
 8004dc2:	e004      	b.n	8004dce <adccallback+0x2e>
  }
  else {
    ny += 1;
 8004dc4:	4b08      	ldr	r3, [pc, #32]	@ (8004de8 <adccallback+0x48>)
 8004dc6:	681b      	ldr	r3, [r3, #0]
 8004dc8:	1c5a      	adds	r2, r3, #1
 8004dca:	4b07      	ldr	r3, [pc, #28]	@ (8004de8 <adccallback+0x48>)
 8004dcc:	601a      	str	r2, [r3, #0]
  }

  if ((n % 200) == 0U) {
 8004dce:	4b04      	ldr	r3, [pc, #16]	@ (8004de0 <adccallback+0x40>)
 8004dd0:	681b      	ldr	r3, [r3, #0]
 8004dd2:	21c8      	movs	r1, #200	@ 0xc8
 8004dd4:	0018      	movs	r0, r3
 8004dd6:	f7fb fa43 	bl	8000260 <__aeabi_uidivmod>
#if defined(PORTAB_LINE_LED2)
    palToggleLine(PORTAB_LINE_LED2);
#endif
  }
}
 8004dda:	46c0      	nop			@ (mov r8, r8)
 8004ddc:	b003      	add	sp, #12
 8004dde:	bd00      	pop	{pc}
 8004de0:	20001278 	.word	0x20001278
 8004de4:	2000127c 	.word	0x2000127c
 8004de8:	20001280 	.word	0x20001280
 8004dec:	00000000 	.word	0x00000000

08004df0 <adcerrorcallback>:

/*
 * ADC errors callback, should never happen.
 */
void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8004df0:	b500      	push	{lr}
 8004df2:	b083      	sub	sp, #12
 8004df4:	9001      	str	r0, [sp, #4]
 8004df6:	9100      	str	r1, [sp, #0]

  (void)adcp;
  (void)err;

  chSysHalt("it happened");
 8004df8:	4b03      	ldr	r3, [pc, #12]	@ (8004e08 <adcerrorcallback+0x18>)
 8004dfa:	0018      	movs	r0, r3
 8004dfc:	f7fd fa00 	bl	8002200 <chSysHalt>
}
 8004e00:	46c0      	nop			@ (mov r8, r8)
 8004e02:	b003      	add	sp, #12
 8004e04:	bd00      	pop	{pc}
 8004e06:	46c0      	nop			@ (mov r8, r8)
 8004e08:	0800524c 	.word	0x0800524c
 8004e0c:	00000000 	.word	0x00000000

08004e10 <Thread1>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED attached to TP1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8004e10:	b500      	push	{lr}
 8004e12:	b083      	sub	sp, #12
 8004e14:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 8004e16:	4b0c      	ldr	r3, [pc, #48]	@ (8004e48 <Thread1+0x38>)
 8004e18:	0018      	movs	r0, r3
 8004e1a:	f7ff ffb1 	bl	8004d80 <chRegSetThreadName>
  while (true) {
    palSetLine(PORTAB_LINE_LED1);
 8004e1e:	23a0      	movs	r3, #160	@ 0xa0
 8004e20:	05db      	lsls	r3, r3, #23
 8004e22:	2220      	movs	r2, #32
 8004e24:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8004e26:	23fa      	movs	r3, #250	@ 0xfa
 8004e28:	005b      	lsls	r3, r3, #1
 8004e2a:	0018      	movs	r0, r3
 8004e2c:	f7ff f8a0 	bl	8003f70 <chThdSleep>
    palClearLine(PORTAB_LINE_LED1);
 8004e30:	23a0      	movs	r3, #160	@ 0xa0
 8004e32:	05db      	lsls	r3, r3, #23
 8004e34:	2220      	movs	r2, #32
 8004e36:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8004e38:	23fa      	movs	r3, #250	@ 0xfa
 8004e3a:	005b      	lsls	r3, r3, #1
 8004e3c:	0018      	movs	r0, r3
 8004e3e:	f7ff f897 	bl	8003f70 <chThdSleep>
    palSetLine(PORTAB_LINE_LED1);
 8004e42:	46c0      	nop			@ (mov r8, r8)
 8004e44:	e7eb      	b.n	8004e1e <Thread1+0xe>
 8004e46:	46c0      	nop			@ (mov r8, r8)
 8004e48:	08005258 	.word	0x08005258
 8004e4c:	00000000 	.word	0x00000000

08004e50 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8004e50:	b500      	push	{lr}
 8004e52:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8004e54:	f7fb fa6c 	bl	8000330 <halInit>
  chSysInit();
 8004e58:	f7fd f9a2 	bl	80021a0 <chSysInit>

  /* Board-dependent GPIO setup code.*/
  portab_setup();
 8004e5c:	f7ff ff80 	bl	8004d60 <portab_setup>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8004e60:	4b20      	ldr	r3, [pc, #128]	@ (8004ee4 <main+0x94>)
 8004e62:	22a8      	movs	r2, #168	@ 0xa8
 8004e64:	0051      	lsls	r1, r2, #1
 8004e66:	4820      	ldr	r0, [pc, #128]	@ (8004ee8 <main+0x98>)
 8004e68:	2200      	movs	r2, #0
 8004e6a:	9200      	str	r2, [sp, #0]
 8004e6c:	2280      	movs	r2, #128	@ 0x80
 8004e6e:	f7fe ff3f 	bl	8003cf0 <chThdCreateStatic>

  /*
   * Starting PORTAB_ADC1 driver and the temperature sensor.
   */
  adcStart(&PORTAB_ADC1, &portab_adccfg1);
 8004e72:	4a1e      	ldr	r2, [pc, #120]	@ (8004eec <main+0x9c>)
 8004e74:	4b1e      	ldr	r3, [pc, #120]	@ (8004ef0 <main+0xa0>)
 8004e76:	0011      	movs	r1, r2
 8004e78:	0018      	movs	r0, r3
 8004e7a:	f7fb fbc1 	bl	8000600 <adcStart>
  adcSTM32EnableVREF(&PORTAB_ADC1);
 8004e7e:	4b1c      	ldr	r3, [pc, #112]	@ (8004ef0 <main+0xa0>)
 8004e80:	0018      	movs	r0, r3
 8004e82:	f7fc fcdd 	bl	8001840 <adcSTM32EnableVREF>
  adcSTM32EnableTS(&PORTAB_ADC1);
 8004e86:	4b1a      	ldr	r3, [pc, #104]	@ (8004ef0 <main+0xa0>)
 8004e88:	0018      	movs	r0, r3
 8004e8a:	f7fc fce9 	bl	8001860 <adcSTM32EnableTS>

  /* Performing a one-shot conversion on two channels.*/
  adcConvert(&PORTAB_ADC1, &portab_adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
 8004e8e:	4a19      	ldr	r2, [pc, #100]	@ (8004ef4 <main+0xa4>)
 8004e90:	4919      	ldr	r1, [pc, #100]	@ (8004ef8 <main+0xa8>)
 8004e92:	4817      	ldr	r0, [pc, #92]	@ (8004ef0 <main+0xa0>)
 8004e94:	2302      	movs	r3, #2
 8004e96:	f7fb fcbb 	bl	8000810 <adcConvert>
  cacheBufferInvalidate(samples1, sizeof (samples1) / sizeof (adcsample_t));

  /*
   * Starting PORTAB_GPT1 driver, it is used for triggering the ADC.
   */
  gptStart(&PORTAB_GPT1, &portab_gptcfg1);
 8004e9a:	4a18      	ldr	r2, [pc, #96]	@ (8004efc <main+0xac>)
 8004e9c:	4b18      	ldr	r3, [pc, #96]	@ (8004f00 <main+0xb0>)
 8004e9e:	0011      	movs	r1, r2
 8004ea0:	0018      	movs	r0, r3
 8004ea2:	f7fb fd45 	bl	8000930 <gptStart>

  /*
   * Starting an ADC continuous conversion triggered with a period of
   * 1/10000 second.
   */
  adcStartConversion(&PORTAB_ADC1, &portab_adcgrpcfg2,
 8004ea6:	4a17      	ldr	r2, [pc, #92]	@ (8004f04 <main+0xb4>)
 8004ea8:	4917      	ldr	r1, [pc, #92]	@ (8004f08 <main+0xb8>)
 8004eaa:	4811      	ldr	r0, [pc, #68]	@ (8004ef0 <main+0xa0>)
 8004eac:	2340      	movs	r3, #64	@ 0x40
 8004eae:	f7fb fbe7 	bl	8000680 <adcStartConversion>
                     samples2, ADC_GRP2_BUF_DEPTH);
  gptStartContinuous(&PORTAB_GPT1, 100U);
 8004eb2:	4b13      	ldr	r3, [pc, #76]	@ (8004f00 <main+0xb0>)
 8004eb4:	2164      	movs	r1, #100	@ 0x64
 8004eb6:	0018      	movs	r0, r3
 8004eb8:	f7fb fd82 	bl	80009c0 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the
   * conversion is stopped.
   */
  while (true) {
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8004ebc:	4b13      	ldr	r3, [pc, #76]	@ (8004f0c <main+0xbc>)
 8004ebe:	691a      	ldr	r2, [r3, #16]
 8004ec0:	2380      	movs	r3, #128	@ 0x80
 8004ec2:	019b      	lsls	r3, r3, #6
 8004ec4:	4013      	ands	r3, r2
 8004ec6:	d107      	bne.n	8004ed8 <main+0x88>
      gptStopTimer(&PORTAB_GPT1);
 8004ec8:	4b0d      	ldr	r3, [pc, #52]	@ (8004f00 <main+0xb0>)
 8004eca:	0018      	movs	r0, r3
 8004ecc:	f7fb fdc0 	bl	8000a50 <gptStopTimer>
      adcStopConversion(&PORTAB_ADC1);
 8004ed0:	4b07      	ldr	r3, [pc, #28]	@ (8004ef0 <main+0xa0>)
 8004ed2:	0018      	movs	r0, r3
 8004ed4:	f7fb fc5c 	bl	8000790 <adcStopConversion>
    }
    chThdSleepMilliseconds(500);
 8004ed8:	23fa      	movs	r3, #250	@ 0xfa
 8004eda:	005b      	lsls	r3, r3, #1
 8004edc:	0018      	movs	r0, r3
 8004ede:	f7ff f847 	bl	8003f70 <chThdSleep>
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8004ee2:	e7eb      	b.n	8004ebc <main+0x6c>
 8004ee4:	08004e11 	.word	0x08004e11
 8004ee8:	20001288 	.word	0x20001288
 8004eec:	080054f8 	.word	0x080054f8
 8004ef0:	20000600 	.word	0x20000600
 8004ef4:	20001074 	.word	0x20001074
 8004ef8:	080054fc 	.word	0x080054fc
 8004efc:	080054e8 	.word	0x080054e8
 8004f00:	20000674 	.word	0x20000674
 8004f04:	20001078 	.word	0x20001078
 8004f08:	08005528 	.word	0x08005528
 8004f0c:	50000800 	.word	0x50000800
