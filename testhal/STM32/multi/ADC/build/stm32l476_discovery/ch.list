
build/stm32l476_discovery/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000279 	.word	0x08000279
 8000008:	0800027b 	.word	0x0800027b
 800000c:	0800027b 	.word	0x0800027b
 8000010:	0800027b 	.word	0x0800027b
 8000014:	0800027b 	.word	0x0800027b
 8000018:	0800027b 	.word	0x0800027b
 800001c:	0800027b 	.word	0x0800027b
 8000020:	0800027b 	.word	0x0800027b
 8000024:	0800027b 	.word	0x0800027b
 8000028:	0800027b 	.word	0x0800027b
 800002c:	08004d21 	.word	0x08004d21
 8000030:	0800027b 	.word	0x0800027b
 8000034:	0800027b 	.word	0x0800027b
 8000038:	0800027b 	.word	0x0800027b
 800003c:	0800027b 	.word	0x0800027b
 8000040:	0800027b 	.word	0x0800027b
 8000044:	0800027b 	.word	0x0800027b
 8000048:	0800027b 	.word	0x0800027b
 800004c:	0800027b 	.word	0x0800027b
 8000050:	0800027b 	.word	0x0800027b
 8000054:	0800027b 	.word	0x0800027b
 8000058:	0800027b 	.word	0x0800027b
 800005c:	0800027b 	.word	0x0800027b
 8000060:	0800027b 	.word	0x0800027b
 8000064:	0800027b 	.word	0x0800027b
 8000068:	0800027b 	.word	0x0800027b
 800006c:	08001b91 	.word	0x08001b91
 8000070:	08001bb1 	.word	0x08001bb1
 8000074:	08001bd1 	.word	0x08001bd1
 8000078:	08001bf1 	.word	0x08001bf1
 800007c:	08001c11 	.word	0x08001c11
 8000080:	08001c31 	.word	0x08001c31
 8000084:	08001c51 	.word	0x08001c51
 8000088:	08001671 	.word	0x08001671
 800008c:	0800027b 	.word	0x0800027b
 8000090:	0800027b 	.word	0x0800027b
 8000094:	0800027b 	.word	0x0800027b
 8000098:	0800027b 	.word	0x0800027b
 800009c:	0800027b 	.word	0x0800027b
 80000a0:	0800027b 	.word	0x0800027b
 80000a4:	0800027b 	.word	0x0800027b
 80000a8:	0800027b 	.word	0x0800027b
 80000ac:	0800027b 	.word	0x0800027b
 80000b0:	08000d31 	.word	0x08000d31
 80000b4:	0800027b 	.word	0x0800027b
 80000b8:	08000d71 	.word	0x08000d71
 80000bc:	0800027b 	.word	0x0800027b
 80000c0:	0800027b 	.word	0x0800027b
 80000c4:	0800027b 	.word	0x0800027b
 80000c8:	0800027b 	.word	0x0800027b
 80000cc:	0800027b 	.word	0x0800027b
 80000d0:	0800027b 	.word	0x0800027b
 80000d4:	0800027b 	.word	0x0800027b
 80000d8:	0800027b 	.word	0x0800027b
 80000dc:	0800027b 	.word	0x0800027b
 80000e0:	0800027b 	.word	0x0800027b
 80000e4:	0800027b 	.word	0x0800027b
 80000e8:	0800027b 	.word	0x0800027b
 80000ec:	0800027b 	.word	0x0800027b
 80000f0:	0800027b 	.word	0x0800027b
 80000f4:	0800027b 	.word	0x0800027b
 80000f8:	0800027b 	.word	0x0800027b
 80000fc:	080016c1 	.word	0x080016c1
 8000100:	0800027b 	.word	0x0800027b
 8000104:	0800027b 	.word	0x0800027b
 8000108:	0800027b 	.word	0x0800027b
 800010c:	0800027b 	.word	0x0800027b
 8000110:	0800027b 	.word	0x0800027b
 8000114:	0800027b 	.word	0x0800027b
 8000118:	0800027b 	.word	0x0800027b
 800011c:	0800027b 	.word	0x0800027b
 8000120:	08001c71 	.word	0x08001c71
 8000124:	08001c91 	.word	0x08001c91
 8000128:	08001cb1 	.word	0x08001cb1
 800012c:	08001cd1 	.word	0x08001cd1
 8000130:	08001cf1 	.word	0x08001cf1
 8000134:	0800027b 	.word	0x0800027b
 8000138:	0800027b 	.word	0x0800027b
 800013c:	0800027b 	.word	0x0800027b
 8000140:	0800027b 	.word	0x0800027b
 8000144:	0800027b 	.word	0x0800027b
 8000148:	0800027b 	.word	0x0800027b
 800014c:	0800027b 	.word	0x0800027b
 8000150:	08001d11 	.word	0x08001d11
 8000154:	08001d31 	.word	0x08001d31
 8000158:	0800027b 	.word	0x0800027b
 800015c:	0800027b 	.word	0x0800027b
 8000160:	0800027b 	.word	0x0800027b
 8000164:	0800027b 	.word	0x0800027b
 8000168:	0800027b 	.word	0x0800027b
 800016c:	0800027b 	.word	0x0800027b
 8000170:	0800027b 	.word	0x0800027b
 8000174:	0800027b 	.word	0x0800027b
 8000178:	0800027b 	.word	0x0800027b
 800017c:	0800027b 	.word	0x0800027b
 8000180:	0800027b 	.word	0x0800027b
 8000184:	0800027b 	.word	0x0800027b
 8000188:	0800027b 	.word	0x0800027b
 800018c:	0800027b 	.word	0x0800027b
 8000190:	0800027b 	.word	0x0800027b
 8000194:	0800027b 	.word	0x0800027b
 8000198:	0800027b 	.word	0x0800027b
 800019c:	0800027b 	.word	0x0800027b

Disassembly of section .text:

080001a0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001a0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001a2:	4826      	ldr	r0, [pc, #152]	@ (800023c <endfiniloop+0x6>)
                msr     MSP, r0
 80001a4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001a8:	4825      	ldr	r0, [pc, #148]	@ (8000240 <endfiniloop+0xa>)
                msr     PSP, r0
 80001aa:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80001ae:	4825      	ldr	r0, [pc, #148]	@ (8000244 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 80001b0:	4925      	ldr	r1, [pc, #148]	@ (8000248 <endfiniloop+0x12>)
                str     r0, [r1]
 80001b2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001b4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001b6:	f380 8814 	msr	CONTROL, r0
                isb
 80001ba:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001be:	f000 f87f 	bl	80002c0 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 80001c2:	f002 f9ed 	bl	80025a0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80001c6:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80001ca:	4920      	ldr	r1, [pc, #128]	@ (800024c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 80001cc:	4a1b      	ldr	r2, [pc, #108]	@ (800023c <endfiniloop+0x6>)

080001ce <msloop>:
msloop:
                cmp     r1, r2
 80001ce:	4291      	cmp	r1, r2
                itt     lo
 80001d0:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001d2:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 80001d6:	e7fa      	bcc.n	80001ce <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80001d8:	491d      	ldr	r1, [pc, #116]	@ (8000250 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 80001da:	4a19      	ldr	r2, [pc, #100]	@ (8000240 <endfiniloop+0xa>)

080001dc <psloop>:
psloop:
                cmp     r1, r2
 80001dc:	4291      	cmp	r1, r2
                itt     lo
 80001de:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001e0:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 80001e4:	e7fa      	bcc.n	80001dc <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 80001e6:	491b      	ldr	r1, [pc, #108]	@ (8000254 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 80001e8:	4a1b      	ldr	r2, [pc, #108]	@ (8000258 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 80001ea:	4b1c      	ldr	r3, [pc, #112]	@ (800025c <endfiniloop+0x26>)

080001ec <dloop>:
dloop:
                cmp     r2, r3
 80001ec:	429a      	cmp	r2, r3
                ittt    lo
 80001ee:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 80001f0:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 80001f4:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 80001f8:	e7f8      	bcc.n	80001ec <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 80001fa:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 80001fc:	4918      	ldr	r1, [pc, #96]	@ (8000260 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 80001fe:	4a19      	ldr	r2, [pc, #100]	@ (8000264 <endfiniloop+0x2e>)

08000200 <bloop>:
bloop:
                cmp     r1, r2
 8000200:	4291      	cmp	r1, r2
                itt     lo
 8000202:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000204:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000208:	e7fa      	bcc.n	8000200 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800020a:	f000 f871 	bl	80002f0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800020e:	f000 f85f 	bl	80002d0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000212:	4c15      	ldr	r4, [pc, #84]	@ (8000268 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000214:	4d15      	ldr	r5, [pc, #84]	@ (800026c <endfiniloop+0x36>)

08000216 <initloop>:
initloop:
                cmp     r4, r5
 8000216:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000218:	da03      	bge.n	8000222 <endinitloop>
                ldr     r1, [r4], #4
 800021a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800021e:	4788      	blx	r1
                b       initloop
 8000220:	e7f9      	b.n	8000216 <initloop>

08000222 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000222:	f004 fea5 	bl	8004f70 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000226:	4c12      	ldr	r4, [pc, #72]	@ (8000270 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000228:	4d12      	ldr	r5, [pc, #72]	@ (8000274 <endfiniloop+0x3e>)

0800022a <finiloop>:
finiloop:
                cmp     r4, r5
 800022a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800022c:	da03      	bge.n	8000236 <endfiniloop>
                ldr     r1, [r4], #4
 800022e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000232:	4788      	blx	r1
                b       finiloop
 8000234:	e7f9      	b.n	800022a <finiloop>

08000236 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000236:	f000 b853 	b.w	80002e0 <__default_exit>
 800023a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800023c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000240:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000244:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000248:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800024c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000250:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000254:	08005704 	.word	0x08005704
                ldr     r2, =__data_base__
 8000258:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800025c:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 8000260:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 8000264:	20000df0 	.word	0x20000df0
                ldr     r4, =__init_array_base__
 8000268:	080001a0 	.word	0x080001a0
                ldr     r5, =__init_array_end__
 800026c:	080001a0 	.word	0x080001a0
                ldr     r4, =__fini_array_base__
 8000270:	080001a0 	.word	0x080001a0
                ldr     r5, =__fini_array_end__
 8000274:	080001a0 	.word	0x080001a0

08000278 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000278:	e792      	b.n	80001a0 <_crt0_entry>

0800027a <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 800027a:	f000 f800 	bl	800027e <_unhandled_exception>

0800027e <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 800027e:	e7fe      	b.n	800027e <_unhandled_exception>

08000280 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000284:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000288:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 800028a:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800028c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000290 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 8000290:	f002 fade 	bl	8002850 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000294:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000296:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 800029a:	4628      	mov	r0, r5
                blx     r4
 800029c:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800029e:	2000      	movs	r0, #0
                bl      chThdExit
 80002a0:	f003 fe06 	bl	8003eb0 <chThdExit>

080002a4 <.zombies>:
.zombies:       b       .zombies
 80002a4:	e7fe      	b.n	80002a4 <.zombies>

080002a6 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 80002a6:	f002 faab 	bl	8002800 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 80002aa:	f003 fa49 	bl	8003740 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002ae:	f002 facf 	bl	8002850 <__dbg_check_unlock>

080002b2 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002b2:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002b4:	e7fe      	b.n	80002b4 <__port_exit_from_isr+0x2>
	...

080002c0 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80002c0:	bf00      	nop
 80002c2:	4770      	bx	lr
	...

080002d0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80002d0:	bf00      	nop
 80002d2:	4770      	bx	lr
	...

080002e0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
     asm volatile ("nop");
 80002e0:	bf00      	nop
 80002e2:	e7fd      	b.n	80002e0 <__default_exit>
	...

080002f0 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80002f0:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80002f2:	4b17      	ldr	r3, [pc, #92]	@ (8000350 <__init_ram_areas+0x60>)
 80002f4:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 80002f6:	9b03      	ldr	r3, [sp, #12]
 80002f8:	681b      	ldr	r3, [r3, #0]
 80002fa:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 80002fc:	9b03      	ldr	r3, [sp, #12]
 80002fe:	685b      	ldr	r3, [r3, #4]
 8000300:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000302:	e009      	b.n	8000318 <__init_ram_areas+0x28>
      *p = *tp;
 8000304:	9b02      	ldr	r3, [sp, #8]
 8000306:	681a      	ldr	r2, [r3, #0]
 8000308:	9b01      	ldr	r3, [sp, #4]
 800030a:	601a      	str	r2, [r3, #0]
      p++;
 800030c:	9b01      	ldr	r3, [sp, #4]
 800030e:	3304      	adds	r3, #4
 8000310:	9301      	str	r3, [sp, #4]
      tp++;
 8000312:	9b02      	ldr	r3, [sp, #8]
 8000314:	3304      	adds	r3, #4
 8000316:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8000318:	9b03      	ldr	r3, [sp, #12]
 800031a:	689b      	ldr	r3, [r3, #8]
 800031c:	9a01      	ldr	r2, [sp, #4]
 800031e:	429a      	cmp	r2, r3
 8000320:	d3f0      	bcc.n	8000304 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000322:	e005      	b.n	8000330 <__init_ram_areas+0x40>
      *p = 0;
 8000324:	9b01      	ldr	r3, [sp, #4]
 8000326:	2200      	movs	r2, #0
 8000328:	601a      	str	r2, [r3, #0]
      p++;
 800032a:	9b01      	ldr	r3, [sp, #4]
 800032c:	3304      	adds	r3, #4
 800032e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8000330:	9b03      	ldr	r3, [sp, #12]
 8000332:	68db      	ldr	r3, [r3, #12]
 8000334:	9a01      	ldr	r2, [sp, #4]
 8000336:	429a      	cmp	r2, r3
 8000338:	d3f4      	bcc.n	8000324 <__init_ram_areas+0x34>
    }
    rap++;
 800033a:	9b03      	ldr	r3, [sp, #12]
 800033c:	3310      	adds	r3, #16
 800033e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000340:	9b03      	ldr	r3, [sp, #12]
 8000342:	4a04      	ldr	r2, [pc, #16]	@ (8000354 <__init_ram_areas+0x64>)
 8000344:	4293      	cmp	r3, r2
 8000346:	d3d6      	bcc.n	80002f6 <__init_ram_areas+0x6>
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8000348:	bf00      	nop
 800034a:	bf00      	nop
 800034c:	b004      	add	sp, #16
 800034e:	4770      	bx	lr
 8000350:	0800501c 	.word	0x0800501c
 8000354:	0800509c 	.word	0x0800509c
	...

08000360 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000360:	bf00      	nop
 8000362:	4770      	bx	lr
	...

08000370 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000370:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000372:	f7ff fff5 	bl	8000360 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000376:	f000 feab 	bl	80010d0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 800037a:	f001 fe09 	bl	8001f90 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800037e:	f000 f927 	bl	80005d0 <adcInit>
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 8000382:	f000 faed 	bl	8000960 <gptInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000386:	f002 f913 	bl	80025b0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800038a:	f000 f851 	bl	8000430 <stInit>
#endif
}
 800038e:	bf00      	nop
 8000390:	bd08      	pop	{r3, pc}
 8000392:	bf00      	nop
	...

080003a0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80003a0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003a4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
}
 80003a6:	4618      	mov	r0, r3
 80003a8:	4770      	bx	lr
 80003aa:	bf00      	nop
 80003ac:	0000      	movs	r0, r0
	...

080003b0 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 80003b0:	b082      	sub	sp, #8
 80003b2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003b4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80003b8:	9b01      	ldr	r3, [sp, #4]
 80003ba:	6353      	str	r3, [r2, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 80003bc:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003c0:	2200      	movs	r2, #0
 80003c2:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80003c4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003c8:	2202      	movs	r2, #2
 80003ca:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 80003cc:	bf00      	nop
 80003ce:	b002      	add	sp, #8
 80003d0:	4770      	bx	lr
 80003d2:	bf00      	nop
	...

080003e0 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 80003e0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003e4:	2200      	movs	r2, #0
 80003e6:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 80003e8:	bf00      	nop
 80003ea:	4770      	bx	lr
 80003ec:	0000      	movs	r0, r0
	...

080003f0 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 80003f0:	b082      	sub	sp, #8
 80003f2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003f4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80003f8:	9b01      	ldr	r3, [sp, #4]
 80003fa:	6353      	str	r3, [r2, #52]	@ 0x34
}
 80003fc:	bf00      	nop
 80003fe:	b002      	add	sp, #8
 8000400:	4770      	bx	lr
 8000402:	bf00      	nop
	...

08000410 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000410:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000414:	68db      	ldr	r3, [r3, #12]
 8000416:	f003 0302 	and.w	r3, r3, #2
 800041a:	2b00      	cmp	r3, #0
 800041c:	bf14      	ite	ne
 800041e:	2301      	movne	r3, #1
 8000420:	2300      	moveq	r3, #0
 8000422:	b2db      	uxtb	r3, r3
}
 8000424:	4618      	mov	r0, r3
 8000426:	4770      	bx	lr
	...

08000430 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000430:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 8000432:	f001 fec5 	bl	80021c0 <st_lld_init>
}
 8000436:	bf00      	nop
 8000438:	bd08      	pop	{r3, pc}
 800043a:	bf00      	nop
 800043c:	0000      	movs	r0, r0
	...

08000440 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 8000440:	b508      	push	{r3, lr}

  return st_lld_get_counter();
 8000442:	f7ff ffad 	bl	80003a0 <st_lld_get_counter>
 8000446:	4603      	mov	r3, r0
}
 8000448:	4618      	mov	r0, r3
 800044a:	bd08      	pop	{r3, pc}
 800044c:	0000      	movs	r0, r0
	...

08000450 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000450:	b500      	push	{lr}
 8000452:	b083      	sub	sp, #12
 8000454:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000456:	f000 f833 	bl	80004c0 <stIsAlarmActive>
 800045a:	4603      	mov	r3, r0
 800045c:	2b00      	cmp	r3, #0
 800045e:	d002      	beq.n	8000466 <stStartAlarm+0x16>
 8000460:	4804      	ldr	r0, [pc, #16]	@ (8000474 <stStartAlarm+0x24>)
 8000462:	f002 f945 	bl	80026f0 <chSysHalt>

  st_lld_start_alarm(abstime);
 8000466:	9801      	ldr	r0, [sp, #4]
 8000468:	f7ff ffa2 	bl	80003b0 <st_lld_start_alarm>
}
 800046c:	bf00      	nop
 800046e:	b003      	add	sp, #12
 8000470:	f85d fb04 	ldr.w	pc, [sp], #4
 8000474:	0800509c 	.word	0x0800509c
	...

08000480 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000480:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8000482:	f7ff ffad 	bl	80003e0 <st_lld_stop_alarm>
}
 8000486:	bf00      	nop
 8000488:	bd08      	pop	{r3, pc}
 800048a:	bf00      	nop
 800048c:	0000      	movs	r0, r0
	...

08000490 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000490:	b500      	push	{lr}
 8000492:	b083      	sub	sp, #12
 8000494:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000496:	f000 f813 	bl	80004c0 <stIsAlarmActive>
 800049a:	4603      	mov	r3, r0
 800049c:	f083 0301 	eor.w	r3, r3, #1
 80004a0:	b2db      	uxtb	r3, r3
 80004a2:	2b00      	cmp	r3, #0
 80004a4:	d002      	beq.n	80004ac <stSetAlarm+0x1c>
 80004a6:	4805      	ldr	r0, [pc, #20]	@ (80004bc <stSetAlarm+0x2c>)
 80004a8:	f002 f922 	bl	80026f0 <chSysHalt>

  st_lld_set_alarm(abstime);
 80004ac:	9801      	ldr	r0, [sp, #4]
 80004ae:	f7ff ff9f 	bl	80003f0 <st_lld_set_alarm>
}
 80004b2:	bf00      	nop
 80004b4:	b003      	add	sp, #12
 80004b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80004ba:	bf00      	nop
 80004bc:	080050ac 	.word	0x080050ac

080004c0 <stIsAlarmActive>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @api
 */
bool stIsAlarmActive(void) {
 80004c0:	b508      	push	{r3, lr}

  return st_lld_is_alarm_active();
 80004c2:	f7ff ffa5 	bl	8000410 <st_lld_is_alarm_active>
 80004c6:	4603      	mov	r3, r0
}
 80004c8:	4618      	mov	r0, r3
 80004ca:	bd08      	pop	{r3, pc}
 80004cc:	0000      	movs	r0, r0
	...

080004d0 <chSysLock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 80004d0:	b500      	push	{lr}
 80004d2:	b083      	sub	sp, #12
 80004d4:	2330      	movs	r3, #48	@ 0x30
 80004d6:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80004d8:	9b01      	ldr	r3, [sp, #4]
 80004da:	f383 8811 	msr	BASEPRI, r3
}
 80004de:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004e0:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 80004e2:	f002 f98d 	bl	8002800 <__dbg_check_lock>
}
 80004e6:	bf00      	nop
 80004e8:	b003      	add	sp, #12
 80004ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80004ee:	bf00      	nop

080004f0 <chSysUnlock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80004f0:	b500      	push	{lr}
 80004f2:	b083      	sub	sp, #12

  __dbg_check_unlock();
 80004f4:	f002 f9ac 	bl	8002850 <__dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80004f8:	4b12      	ldr	r3, [pc, #72]	@ (8000544 <chSysUnlock.lto_priv.2+0x54>)
 80004fa:	681b      	ldr	r3, [r3, #0]
 80004fc:	4a11      	ldr	r2, [pc, #68]	@ (8000544 <chSysUnlock.lto_priv.2+0x54>)
 80004fe:	4293      	cmp	r3, r2
 8000500:	bf14      	ite	ne
 8000502:	2301      	movne	r3, #1
 8000504:	2300      	moveq	r3, #0
 8000506:	b2db      	uxtb	r3, r3
 8000508:	2b00      	cmp	r3, #0
 800050a:	d00f      	beq.n	800052c <chSysUnlock.lto_priv.2+0x3c>
 800050c:	4b0d      	ldr	r3, [pc, #52]	@ (8000544 <chSysUnlock.lto_priv.2+0x54>)
 800050e:	68db      	ldr	r3, [r3, #12]
 8000510:	689a      	ldr	r2, [r3, #8]
 8000512:	4b0c      	ldr	r3, [pc, #48]	@ (8000544 <chSysUnlock.lto_priv.2+0x54>)
 8000514:	681b      	ldr	r3, [r3, #0]
 8000516:	689b      	ldr	r3, [r3, #8]
 8000518:	429a      	cmp	r2, r3
 800051a:	bf34      	ite	cc
 800051c:	2301      	movcc	r3, #1
 800051e:	2300      	movcs	r3, #0
 8000520:	b2db      	uxtb	r3, r3
 8000522:	2b00      	cmp	r3, #0
 8000524:	d002      	beq.n	800052c <chSysUnlock.lto_priv.2+0x3c>
 8000526:	4808      	ldr	r0, [pc, #32]	@ (8000548 <chSysUnlock.lto_priv.2+0x58>)
 8000528:	f002 f8e2 	bl	80026f0 <chSysHalt>
 800052c:	2300      	movs	r3, #0
 800052e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000530:	9b01      	ldr	r3, [sp, #4]
 8000532:	f383 8811 	msr	BASEPRI, r3
}
 8000536:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000538:	bf00      	nop
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 800053a:	bf00      	nop
 800053c:	b003      	add	sp, #12
 800053e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000542:	bf00      	nop
 8000544:	20000940 	.word	0x20000940
 8000548:	080050c4 	.word	0x080050c4
 800054c:	00000000 	.word	0x00000000

08000550 <osalSysLock.lto_priv.2>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000550:	b508      	push	{r3, lr}

  chSysLock();
 8000552:	f7ff ffbd 	bl	80004d0 <chSysLock.lto_priv.2>
}
 8000556:	bf00      	nop
 8000558:	bd08      	pop	{r3, pc}
 800055a:	bf00      	nop
 800055c:	0000      	movs	r0, r0
	...

08000560 <osalSysUnlock.lto_priv.2>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8000560:	b508      	push	{r3, lr}

  chSysUnlock();
 8000562:	f7ff ffc5 	bl	80004f0 <chSysUnlock.lto_priv.2>
}
 8000566:	bf00      	nop
 8000568:	bd08      	pop	{r3, pc}
 800056a:	bf00      	nop
 800056c:	0000      	movs	r0, r0
	...

08000570 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8000570:	b500      	push	{lr}
 8000572:	b083      	sub	sp, #12
 8000574:	9001      	str	r0, [sp, #4]

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8000576:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 800057a:	9801      	ldr	r0, [sp, #4]
 800057c:	f003 fd00 	bl	8003f80 <chThdSuspendTimeoutS>
 8000580:	4603      	mov	r3, r0
}
 8000582:	4618      	mov	r0, r3
 8000584:	b003      	add	sp, #12
 8000586:	f85d fb04 	ldr.w	pc, [sp], #4
 800058a:	bf00      	nop
 800058c:	0000      	movs	r0, r0
	...

08000590 <osalThreadResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 8000590:	b500      	push	{lr}
 8000592:	b083      	sub	sp, #12
 8000594:	9001      	str	r0, [sp, #4]
 8000596:	9100      	str	r1, [sp, #0]

  chThdResumeS(trp, msg);
 8000598:	9900      	ldr	r1, [sp, #0]
 800059a:	9801      	ldr	r0, [sp, #4]
 800059c:	f003 fd48 	bl	8004030 <chThdResumeS>
}
 80005a0:	bf00      	nop
 80005a2:	b003      	add	sp, #12
 80005a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080005b0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80005b0:	b500      	push	{lr}
 80005b2:	b083      	sub	sp, #12
 80005b4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80005b6:	9801      	ldr	r0, [sp, #4]
 80005b8:	f003 ff6a 	bl	8004490 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80005bc:	bf00      	nop
 80005be:	b003      	add	sp, #12
 80005c0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080005d0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 80005d0:	b508      	push	{r3, lr}

  adc_lld_init();
 80005d2:	f001 f895 	bl	8001700 <adc_lld_init>
}
 80005d6:	bf00      	nop
 80005d8:	bd08      	pop	{r3, pc}
 80005da:	bf00      	nop
 80005dc:	0000      	movs	r0, r0
	...

080005e0 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 80005e0:	b500      	push	{lr}
 80005e2:	b083      	sub	sp, #12
 80005e4:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 80005e6:	9b01      	ldr	r3, [sp, #4]
 80005e8:	2201      	movs	r2, #1
 80005ea:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 80005ec:	9b01      	ldr	r3, [sp, #4]
 80005ee:	2200      	movs	r2, #0
 80005f0:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 80005f2:	9b01      	ldr	r3, [sp, #4]
 80005f4:	2200      	movs	r2, #0
 80005f6:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 80005f8:	9b01      	ldr	r3, [sp, #4]
 80005fa:	2200      	movs	r2, #0
 80005fc:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 80005fe:	9b01      	ldr	r3, [sp, #4]
 8000600:	2200      	movs	r2, #0
 8000602:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8000604:	9b01      	ldr	r3, [sp, #4]
 8000606:	2200      	movs	r2, #0
 8000608:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 800060a:	9b01      	ldr	r3, [sp, #4]
 800060c:	3318      	adds	r3, #24
 800060e:	4618      	mov	r0, r3
 8000610:	f7ff ffce 	bl	80005b0 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 8000614:	bf00      	nop
 8000616:	b003      	add	sp, #12
 8000618:	f85d fb04 	ldr.w	pc, [sp], #4
 800061c:	0000      	movs	r0, r0
	...

08000620 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8000620:	b500      	push	{lr}
 8000622:	b085      	sub	sp, #20
 8000624:	9001      	str	r0, [sp, #4]
 8000626:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(adcp != NULL);
 8000628:	9b01      	ldr	r3, [sp, #4]
 800062a:	2b00      	cmp	r3, #0
 800062c:	bf0c      	ite	eq
 800062e:	2301      	moveq	r3, #1
 8000630:	2300      	movne	r3, #0
 8000632:	b2db      	uxtb	r3, r3
 8000634:	2b00      	cmp	r3, #0
 8000636:	d002      	beq.n	800063e <adcStart+0x1e>
 8000638:	4819      	ldr	r0, [pc, #100]	@ (80006a0 <adcStart+0x80>)
 800063a:	f002 f859 	bl	80026f0 <chSysHalt>

  osalSysLock();
 800063e:	f7ff ff87 	bl	8000550 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 8000642:	9b01      	ldr	r3, [sp, #4]
 8000644:	781b      	ldrb	r3, [r3, #0]
 8000646:	2b01      	cmp	r3, #1
 8000648:	bf14      	ite	ne
 800064a:	2301      	movne	r3, #1
 800064c:	2300      	moveq	r3, #0
 800064e:	b2db      	uxtb	r3, r3
 8000650:	2b00      	cmp	r3, #0
 8000652:	d00b      	beq.n	800066c <adcStart+0x4c>
 8000654:	9b01      	ldr	r3, [sp, #4]
 8000656:	781b      	ldrb	r3, [r3, #0]
 8000658:	2b02      	cmp	r3, #2
 800065a:	bf14      	ite	ne
 800065c:	2301      	movne	r3, #1
 800065e:	2300      	moveq	r3, #0
 8000660:	b2db      	uxtb	r3, r3
 8000662:	2b00      	cmp	r3, #0
 8000664:	d002      	beq.n	800066c <adcStart+0x4c>
 8000666:	480e      	ldr	r0, [pc, #56]	@ (80006a0 <adcStart+0x80>)
 8000668:	f002 f842 	bl	80026f0 <chSysHalt>
                "invalid state");
  adcp->config = config;
 800066c:	9b01      	ldr	r3, [sp, #4]
 800066e:	9a00      	ldr	r2, [sp, #0]
 8000670:	605a      	str	r2, [r3, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
#else
  adc_lld_start(adcp);
 8000672:	9801      	ldr	r0, [sp, #4]
 8000674:	f001 f8c4 	bl	8001800 <adc_lld_start>
  msg = HAL_RET_SUCCESS;
 8000678:	2300      	movs	r3, #0
 800067a:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 800067c:	9b03      	ldr	r3, [sp, #12]
 800067e:	2b00      	cmp	r3, #0
 8000680:	d103      	bne.n	800068a <adcStart+0x6a>
    adcp->state = ADC_READY;
 8000682:	9b01      	ldr	r3, [sp, #4]
 8000684:	2202      	movs	r2, #2
 8000686:	701a      	strb	r2, [r3, #0]
 8000688:	e002      	b.n	8000690 <adcStart+0x70>
  }
  else {
    adcp->state = ADC_STOP;
 800068a:	9b01      	ldr	r3, [sp, #4]
 800068c:	2201      	movs	r2, #1
 800068e:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000690:	f7ff ff66 	bl	8000560 <osalSysUnlock.lto_priv.2>

  return msg;
 8000694:	9b03      	ldr	r3, [sp, #12]
}
 8000696:	4618      	mov	r0, r3
 8000698:	b005      	add	sp, #20
 800069a:	f85d fb04 	ldr.w	pc, [sp], #4
 800069e:	bf00      	nop
 80006a0:	080050b8 	.word	0x080050b8
	...

080006b0 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 80006b0:	b500      	push	{lr}
 80006b2:	b085      	sub	sp, #20
 80006b4:	9003      	str	r0, [sp, #12]
 80006b6:	9102      	str	r1, [sp, #8]
 80006b8:	9201      	str	r2, [sp, #4]
 80006ba:	9300      	str	r3, [sp, #0]

  osalSysLock();
 80006bc:	f7ff ff48 	bl	8000550 <osalSysLock.lto_priv.2>
  adcStartConversionI(adcp, grpp, samples, depth);
 80006c0:	9b00      	ldr	r3, [sp, #0]
 80006c2:	9a01      	ldr	r2, [sp, #4]
 80006c4:	9902      	ldr	r1, [sp, #8]
 80006c6:	9803      	ldr	r0, [sp, #12]
 80006c8:	f000 f80a 	bl	80006e0 <adcStartConversionI>
  osalSysUnlock();
 80006cc:	f7ff ff48 	bl	8000560 <osalSysUnlock.lto_priv.2>
}
 80006d0:	bf00      	nop
 80006d2:	b005      	add	sp, #20
 80006d4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080006e0 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
 80006e0:	b500      	push	{lr}
 80006e2:	b085      	sub	sp, #20
 80006e4:	9003      	str	r0, [sp, #12]
 80006e6:	9102      	str	r1, [sp, #8]
 80006e8:	9201      	str	r2, [sp, #4]
 80006ea:	9300      	str	r3, [sp, #0]

  osalDbgCheckClassI();
 80006ec:	f002 f9a0 	bl	8002a30 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
 80006f0:	9b03      	ldr	r3, [sp, #12]
 80006f2:	2b00      	cmp	r3, #0
 80006f4:	bf0c      	ite	eq
 80006f6:	2301      	moveq	r3, #1
 80006f8:	2300      	movne	r3, #0
 80006fa:	b2db      	uxtb	r3, r3
 80006fc:	2b00      	cmp	r3, #0
 80006fe:	d107      	bne.n	8000710 <adcStartConversionI+0x30>
 8000700:	9b02      	ldr	r3, [sp, #8]
 8000702:	2b00      	cmp	r3, #0
 8000704:	bf0c      	ite	eq
 8000706:	2301      	moveq	r3, #1
 8000708:	2300      	movne	r3, #0
 800070a:	b2db      	uxtb	r3, r3
 800070c:	2b00      	cmp	r3, #0
 800070e:	d001      	beq.n	8000714 <adcStartConversionI+0x34>
 8000710:	2301      	movs	r3, #1
 8000712:	e000      	b.n	8000716 <adcStartConversionI+0x36>
 8000714:	2300      	movs	r3, #0
 8000716:	2b00      	cmp	r3, #0
 8000718:	d107      	bne.n	800072a <adcStartConversionI+0x4a>
 800071a:	9b01      	ldr	r3, [sp, #4]
 800071c:	2b00      	cmp	r3, #0
 800071e:	bf0c      	ite	eq
 8000720:	2301      	moveq	r3, #1
 8000722:	2300      	movne	r3, #0
 8000724:	b2db      	uxtb	r3, r3
 8000726:	2b00      	cmp	r3, #0
 8000728:	d001      	beq.n	800072e <adcStartConversionI+0x4e>
 800072a:	2301      	movs	r3, #1
 800072c:	e000      	b.n	8000730 <adcStartConversionI+0x50>
 800072e:	2300      	movs	r3, #0
 8000730:	2b00      	cmp	r3, #0
 8000732:	d107      	bne.n	8000744 <adcStartConversionI+0x64>
 8000734:	9b00      	ldr	r3, [sp, #0]
 8000736:	2b00      	cmp	r3, #0
 8000738:	bf0c      	ite	eq
 800073a:	2301      	moveq	r3, #1
 800073c:	2300      	movne	r3, #0
 800073e:	b2db      	uxtb	r3, r3
 8000740:	2b00      	cmp	r3, #0
 8000742:	d001      	beq.n	8000748 <adcStartConversionI+0x68>
 8000744:	2301      	movs	r3, #1
 8000746:	e000      	b.n	800074a <adcStartConversionI+0x6a>
 8000748:	2300      	movs	r3, #0
 800074a:	2b00      	cmp	r3, #0
 800074c:	d111      	bne.n	8000772 <adcStartConversionI+0x92>
 800074e:	9b00      	ldr	r3, [sp, #0]
 8000750:	2b01      	cmp	r3, #1
 8000752:	bf14      	ite	ne
 8000754:	2301      	movne	r3, #1
 8000756:	2300      	moveq	r3, #0
 8000758:	b2db      	uxtb	r3, r3
 800075a:	2b00      	cmp	r3, #0
 800075c:	d006      	beq.n	800076c <adcStartConversionI+0x8c>
 800075e:	9b00      	ldr	r3, [sp, #0]
 8000760:	f003 0301 	and.w	r3, r3, #1
 8000764:	2b00      	cmp	r3, #0
 8000766:	d001      	beq.n	800076c <adcStartConversionI+0x8c>
 8000768:	2301      	movs	r3, #1
 800076a:	e000      	b.n	800076e <adcStartConversionI+0x8e>
 800076c:	2300      	movs	r3, #0
 800076e:	2b00      	cmp	r3, #0
 8000770:	d002      	beq.n	8000778 <adcStartConversionI+0x98>
 8000772:	4815      	ldr	r0, [pc, #84]	@ (80007c8 <adcStartConversionI+0xe8>)
 8000774:	f001 ffbc 	bl	80026f0 <chSysHalt>
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
 8000778:	9b03      	ldr	r3, [sp, #12]
 800077a:	781b      	ldrb	r3, [r3, #0]
 800077c:	2b02      	cmp	r3, #2
 800077e:	bf14      	ite	ne
 8000780:	2301      	movne	r3, #1
 8000782:	2300      	moveq	r3, #0
 8000784:	b2db      	uxtb	r3, r3
 8000786:	2b00      	cmp	r3, #0
 8000788:	d00b      	beq.n	80007a2 <adcStartConversionI+0xc2>
 800078a:	9b03      	ldr	r3, [sp, #12]
 800078c:	781b      	ldrb	r3, [r3, #0]
 800078e:	2b05      	cmp	r3, #5
 8000790:	bf14      	ite	ne
 8000792:	2301      	movne	r3, #1
 8000794:	2300      	moveq	r3, #0
 8000796:	b2db      	uxtb	r3, r3
 8000798:	2b00      	cmp	r3, #0
 800079a:	d002      	beq.n	80007a2 <adcStartConversionI+0xc2>
 800079c:	480a      	ldr	r0, [pc, #40]	@ (80007c8 <adcStartConversionI+0xe8>)
 800079e:	f001 ffa7 	bl	80026f0 <chSysHalt>
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 80007a2:	9b03      	ldr	r3, [sp, #12]
 80007a4:	9a01      	ldr	r2, [sp, #4]
 80007a6:	609a      	str	r2, [r3, #8]
  adcp->depth    = depth;
 80007a8:	9b03      	ldr	r3, [sp, #12]
 80007aa:	9a00      	ldr	r2, [sp, #0]
 80007ac:	60da      	str	r2, [r3, #12]
  adcp->grpp     = grpp;
 80007ae:	9b03      	ldr	r3, [sp, #12]
 80007b0:	9a02      	ldr	r2, [sp, #8]
 80007b2:	611a      	str	r2, [r3, #16]
  adcp->state    = ADC_ACTIVE;
 80007b4:	9b03      	ldr	r3, [sp, #12]
 80007b6:	2203      	movs	r2, #3
 80007b8:	701a      	strb	r2, [r3, #0]
  adc_lld_start_conversion(adcp);
 80007ba:	9803      	ldr	r0, [sp, #12]
 80007bc:	f001 f8e8 	bl	8001990 <adc_lld_start_conversion>
}
 80007c0:	bf00      	nop
 80007c2:	b005      	add	sp, #20
 80007c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80007c8:	080050d0 	.word	0x080050d0
 80007cc:	00000000 	.word	0x00000000

080007d0 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
 80007d0:	b500      	push	{lr}
 80007d2:	b083      	sub	sp, #12
 80007d4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(adcp != NULL);
 80007d6:	9b01      	ldr	r3, [sp, #4]
 80007d8:	2b00      	cmp	r3, #0
 80007da:	bf0c      	ite	eq
 80007dc:	2301      	moveq	r3, #1
 80007de:	2300      	movne	r3, #0
 80007e0:	b2db      	uxtb	r3, r3
 80007e2:	2b00      	cmp	r3, #0
 80007e4:	d002      	beq.n	80007ec <adcStopConversion+0x1c>
 80007e6:	481a      	ldr	r0, [pc, #104]	@ (8000850 <adcStopConversion+0x80>)
 80007e8:	f001 ff82 	bl	80026f0 <chSysHalt>

  osalSysLock();
 80007ec:	f7ff feb0 	bl	8000550 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_READY) || (adcp->state == ADC_ACTIVE),
 80007f0:	9b01      	ldr	r3, [sp, #4]
 80007f2:	781b      	ldrb	r3, [r3, #0]
 80007f4:	2b02      	cmp	r3, #2
 80007f6:	bf14      	ite	ne
 80007f8:	2301      	movne	r3, #1
 80007fa:	2300      	moveq	r3, #0
 80007fc:	b2db      	uxtb	r3, r3
 80007fe:	2b00      	cmp	r3, #0
 8000800:	d00b      	beq.n	800081a <adcStopConversion+0x4a>
 8000802:	9b01      	ldr	r3, [sp, #4]
 8000804:	781b      	ldrb	r3, [r3, #0]
 8000806:	2b03      	cmp	r3, #3
 8000808:	bf14      	ite	ne
 800080a:	2301      	movne	r3, #1
 800080c:	2300      	moveq	r3, #0
 800080e:	b2db      	uxtb	r3, r3
 8000810:	2b00      	cmp	r3, #0
 8000812:	d002      	beq.n	800081a <adcStopConversion+0x4a>
 8000814:	480e      	ldr	r0, [pc, #56]	@ (8000850 <adcStopConversion+0x80>)
 8000816:	f001 ff6b 	bl	80026f0 <chSysHalt>
                "invalid state");
  if (adcp->state != ADC_READY) {
 800081a:	9b01      	ldr	r3, [sp, #4]
 800081c:	781b      	ldrb	r3, [r3, #0]
 800081e:	2b02      	cmp	r3, #2
 8000820:	d00f      	beq.n	8000842 <adcStopConversion+0x72>
    adc_lld_stop_conversion(adcp);
 8000822:	9801      	ldr	r0, [sp, #4]
 8000824:	f001 f974 	bl	8001b10 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
 8000828:	9b01      	ldr	r3, [sp, #4]
 800082a:	2200      	movs	r2, #0
 800082c:	611a      	str	r2, [r3, #16]
    adcp->state = ADC_READY;
 800082e:	9b01      	ldr	r3, [sp, #4]
 8000830:	2202      	movs	r2, #2
 8000832:	701a      	strb	r2, [r3, #0]
    _adc_reset_s(adcp);
 8000834:	9b01      	ldr	r3, [sp, #4]
 8000836:	3314      	adds	r3, #20
 8000838:	f06f 0101 	mvn.w	r1, #1
 800083c:	4618      	mov	r0, r3
 800083e:	f7ff fea7 	bl	8000590 <osalThreadResumeS>
  }
  osalSysUnlock();
 8000842:	f7ff fe8d 	bl	8000560 <osalSysUnlock.lto_priv.2>
}
 8000846:	bf00      	nop
 8000848:	b003      	add	sp, #12
 800084a:	f85d fb04 	ldr.w	pc, [sp], #4
 800084e:	bf00      	nop
 8000850:	080050e4 	.word	0x080050e4
	...

08000860 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8000860:	b500      	push	{lr}
 8000862:	b087      	sub	sp, #28
 8000864:	9003      	str	r0, [sp, #12]
 8000866:	9102      	str	r1, [sp, #8]
 8000868:	9201      	str	r2, [sp, #4]
 800086a:	9300      	str	r3, [sp, #0]
  msg_t msg;

  osalSysLock();
 800086c:	f7ff fe70 	bl	8000550 <osalSysLock.lto_priv.2>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
 8000870:	9b03      	ldr	r3, [sp, #12]
 8000872:	695b      	ldr	r3, [r3, #20]
 8000874:	2b00      	cmp	r3, #0
 8000876:	bf14      	ite	ne
 8000878:	2301      	movne	r3, #1
 800087a:	2300      	moveq	r3, #0
 800087c:	b2db      	uxtb	r3, r3
 800087e:	2b00      	cmp	r3, #0
 8000880:	d002      	beq.n	8000888 <adcConvert+0x28>
 8000882:	480b      	ldr	r0, [pc, #44]	@ (80008b0 <adcConvert+0x50>)
 8000884:	f001 ff34 	bl	80026f0 <chSysHalt>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000888:	9b00      	ldr	r3, [sp, #0]
 800088a:	9a01      	ldr	r2, [sp, #4]
 800088c:	9902      	ldr	r1, [sp, #8]
 800088e:	9803      	ldr	r0, [sp, #12]
 8000890:	f7ff ff26 	bl	80006e0 <adcStartConversionI>
  msg = osalThreadSuspendS(&adcp->thread);
 8000894:	9b03      	ldr	r3, [sp, #12]
 8000896:	3314      	adds	r3, #20
 8000898:	4618      	mov	r0, r3
 800089a:	f7ff fe69 	bl	8000570 <osalThreadSuspendS>
 800089e:	9005      	str	r0, [sp, #20]
  osalSysUnlock();
 80008a0:	f7ff fe5e 	bl	8000560 <osalSysUnlock.lto_priv.2>
  return msg;
 80008a4:	9b05      	ldr	r3, [sp, #20]
}
 80008a6:	4618      	mov	r0, r3
 80008a8:	b007      	add	sp, #28
 80008aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80008ae:	bf00      	nop
 80008b0:	080050f8 	.word	0x080050f8
	...

080008c0 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
 80008c0:	b500      	push	{lr}
 80008c2:	b083      	sub	sp, #12
 80008c4:	2330      	movs	r3, #48	@ 0x30
 80008c6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80008c8:	9b01      	ldr	r3, [sp, #4]
 80008ca:	f383 8811 	msr	BASEPRI, r3
}
 80008ce:	bf00      	nop
}
 80008d0:	bf00      	nop
  __dbg_check_lock();
 80008d2:	f001 ff95 	bl	8002800 <__dbg_check_lock>
}
 80008d6:	bf00      	nop
 80008d8:	b003      	add	sp, #12
 80008da:	f85d fb04 	ldr.w	pc, [sp], #4
 80008de:	bf00      	nop

080008e0 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
 80008e0:	b500      	push	{lr}
 80008e2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80008e4:	f001 ffb4 	bl	8002850 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80008e8:	4b12      	ldr	r3, [pc, #72]	@ (8000934 <chSysUnlock.lto_priv.3+0x54>)
 80008ea:	681b      	ldr	r3, [r3, #0]
 80008ec:	4a11      	ldr	r2, [pc, #68]	@ (8000934 <chSysUnlock.lto_priv.3+0x54>)
 80008ee:	4293      	cmp	r3, r2
 80008f0:	bf14      	ite	ne
 80008f2:	2301      	movne	r3, #1
 80008f4:	2300      	moveq	r3, #0
 80008f6:	b2db      	uxtb	r3, r3
 80008f8:	2b00      	cmp	r3, #0
 80008fa:	d00f      	beq.n	800091c <chSysUnlock.lto_priv.3+0x3c>
 80008fc:	4b0d      	ldr	r3, [pc, #52]	@ (8000934 <chSysUnlock.lto_priv.3+0x54>)
 80008fe:	68db      	ldr	r3, [r3, #12]
 8000900:	689a      	ldr	r2, [r3, #8]
 8000902:	4b0c      	ldr	r3, [pc, #48]	@ (8000934 <chSysUnlock.lto_priv.3+0x54>)
 8000904:	681b      	ldr	r3, [r3, #0]
 8000906:	689b      	ldr	r3, [r3, #8]
 8000908:	429a      	cmp	r2, r3
 800090a:	bf34      	ite	cc
 800090c:	2301      	movcc	r3, #1
 800090e:	2300      	movcs	r3, #0
 8000910:	b2db      	uxtb	r3, r3
 8000912:	2b00      	cmp	r3, #0
 8000914:	d002      	beq.n	800091c <chSysUnlock.lto_priv.3+0x3c>
 8000916:	4808      	ldr	r0, [pc, #32]	@ (8000938 <chSysUnlock.lto_priv.3+0x58>)
 8000918:	f001 feea 	bl	80026f0 <chSysHalt>
 800091c:	2300      	movs	r3, #0
 800091e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000920:	9b01      	ldr	r3, [sp, #4]
 8000922:	f383 8811 	msr	BASEPRI, r3
}
 8000926:	bf00      	nop
}
 8000928:	bf00      	nop
}
 800092a:	bf00      	nop
 800092c:	b003      	add	sp, #12
 800092e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000932:	bf00      	nop
 8000934:	20000940 	.word	0x20000940
 8000938:	08005110 	.word	0x08005110
 800093c:	00000000 	.word	0x00000000

08000940 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
 8000940:	b508      	push	{r3, lr}
  chSysLock();
 8000942:	f7ff ffbd 	bl	80008c0 <chSysLock.lto_priv.3>
}
 8000946:	bf00      	nop
 8000948:	bd08      	pop	{r3, pc}
 800094a:	bf00      	nop
 800094c:	0000      	movs	r0, r0
	...

08000950 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
 8000950:	b508      	push	{r3, lr}
  chSysUnlock();
 8000952:	f7ff ffc5 	bl	80008e0 <chSysUnlock.lto_priv.3>
}
 8000956:	bf00      	nop
 8000958:	bd08      	pop	{r3, pc}
 800095a:	bf00      	nop
 800095c:	0000      	movs	r0, r0
	...

08000960 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8000960:	b508      	push	{r3, lr}

  gpt_lld_init();
 8000962:	f001 fc95 	bl	8002290 <gpt_lld_init>
}
 8000966:	bf00      	nop
 8000968:	bd08      	pop	{r3, pc}
 800096a:	bf00      	nop
 800096c:	0000      	movs	r0, r0
	...

08000970 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8000970:	b082      	sub	sp, #8
 8000972:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 8000974:	9b01      	ldr	r3, [sp, #4]
 8000976:	2201      	movs	r2, #1
 8000978:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 800097a:	9b01      	ldr	r3, [sp, #4]
 800097c:	2200      	movs	r2, #0
 800097e:	605a      	str	r2, [r3, #4]
}
 8000980:	bf00      	nop
 8000982:	b002      	add	sp, #8
 8000984:	4770      	bx	lr
 8000986:	bf00      	nop
	...

08000990 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8000990:	b500      	push	{lr}
 8000992:	b085      	sub	sp, #20
 8000994:	9001      	str	r0, [sp, #4]
 8000996:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 8000998:	9b01      	ldr	r3, [sp, #4]
 800099a:	2b00      	cmp	r3, #0
 800099c:	bf0c      	ite	eq
 800099e:	2301      	moveq	r3, #1
 80009a0:	2300      	movne	r3, #0
 80009a2:	b2db      	uxtb	r3, r3
 80009a4:	2b00      	cmp	r3, #0
 80009a6:	d107      	bne.n	80009b8 <gptStart+0x28>
 80009a8:	9b00      	ldr	r3, [sp, #0]
 80009aa:	2b00      	cmp	r3, #0
 80009ac:	bf0c      	ite	eq
 80009ae:	2301      	moveq	r3, #1
 80009b0:	2300      	movne	r3, #0
 80009b2:	b2db      	uxtb	r3, r3
 80009b4:	2b00      	cmp	r3, #0
 80009b6:	d002      	beq.n	80009be <gptStart+0x2e>
 80009b8:	4819      	ldr	r0, [pc, #100]	@ (8000a20 <gptStart+0x90>)
 80009ba:	f001 fe99 	bl	80026f0 <chSysHalt>

  osalSysLock();
 80009be:	f7ff ffbf 	bl	8000940 <osalSysLock.lto_priv.3>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
 80009c2:	9b01      	ldr	r3, [sp, #4]
 80009c4:	781b      	ldrb	r3, [r3, #0]
 80009c6:	2b01      	cmp	r3, #1
 80009c8:	bf14      	ite	ne
 80009ca:	2301      	movne	r3, #1
 80009cc:	2300      	moveq	r3, #0
 80009ce:	b2db      	uxtb	r3, r3
 80009d0:	2b00      	cmp	r3, #0
 80009d2:	d00b      	beq.n	80009ec <gptStart+0x5c>
 80009d4:	9b01      	ldr	r3, [sp, #4]
 80009d6:	781b      	ldrb	r3, [r3, #0]
 80009d8:	2b02      	cmp	r3, #2
 80009da:	bf14      	ite	ne
 80009dc:	2301      	movne	r3, #1
 80009de:	2300      	moveq	r3, #0
 80009e0:	b2db      	uxtb	r3, r3
 80009e2:	2b00      	cmp	r3, #0
 80009e4:	d002      	beq.n	80009ec <gptStart+0x5c>
 80009e6:	480e      	ldr	r0, [pc, #56]	@ (8000a20 <gptStart+0x90>)
 80009e8:	f001 fe82 	bl	80026f0 <chSysHalt>
              "invalid state");

  gptp->config = config;
 80009ec:	9b01      	ldr	r3, [sp, #4]
 80009ee:	9a00      	ldr	r2, [sp, #0]
 80009f0:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 80009f2:	9801      	ldr	r0, [sp, #4]
 80009f4:	f001 fc5c 	bl	80022b0 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 80009f8:	2300      	movs	r3, #0
 80009fa:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 80009fc:	9b03      	ldr	r3, [sp, #12]
 80009fe:	2b00      	cmp	r3, #0
 8000a00:	d103      	bne.n	8000a0a <gptStart+0x7a>
    gptp->state = GPT_READY;
 8000a02:	9b01      	ldr	r3, [sp, #4]
 8000a04:	2202      	movs	r2, #2
 8000a06:	701a      	strb	r2, [r3, #0]
 8000a08:	e002      	b.n	8000a10 <gptStart+0x80>
  }
  else {
    gptp->state = GPT_STOP;
 8000a0a:	9b01      	ldr	r3, [sp, #4]
 8000a0c:	2201      	movs	r2, #1
 8000a0e:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000a10:	f7ff ff9e 	bl	8000950 <osalSysUnlock.lto_priv.3>

  return msg;
 8000a14:	9b03      	ldr	r3, [sp, #12]
}
 8000a16:	4618      	mov	r0, r3
 8000a18:	b005      	add	sp, #20
 8000a1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a1e:	bf00      	nop
 8000a20:	08005104 	.word	0x08005104
	...

08000a30 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 8000a30:	b500      	push	{lr}
 8000a32:	b083      	sub	sp, #12
 8000a34:	9001      	str	r0, [sp, #4]
 8000a36:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8000a38:	f7ff ff82 	bl	8000940 <osalSysLock.lto_priv.3>
  gptStartContinuousI(gptp, interval);
 8000a3c:	9900      	ldr	r1, [sp, #0]
 8000a3e:	9801      	ldr	r0, [sp, #4]
 8000a40:	f000 f806 	bl	8000a50 <gptStartContinuousI>
  osalSysUnlock();
 8000a44:	f7ff ff84 	bl	8000950 <osalSysUnlock.lto_priv.3>
}
 8000a48:	bf00      	nop
 8000a4a:	b003      	add	sp, #12
 8000a4c:	f85d fb04 	ldr.w	pc, [sp], #4

08000a50 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 8000a50:	b500      	push	{lr}
 8000a52:	b083      	sub	sp, #12
 8000a54:	9001      	str	r0, [sp, #4]
 8000a56:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8000a58:	f001 ffea 	bl	8002a30 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000a5c:	9b01      	ldr	r3, [sp, #4]
 8000a5e:	2b00      	cmp	r3, #0
 8000a60:	bf0c      	ite	eq
 8000a62:	2301      	moveq	r3, #1
 8000a64:	2300      	movne	r3, #0
 8000a66:	b2db      	uxtb	r3, r3
 8000a68:	2b00      	cmp	r3, #0
 8000a6a:	d002      	beq.n	8000a72 <gptStartContinuousI+0x22>
 8000a6c:	480c      	ldr	r0, [pc, #48]	@ (8000aa0 <gptStartContinuousI+0x50>)
 8000a6e:	f001 fe3f 	bl	80026f0 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
 8000a72:	9b01      	ldr	r3, [sp, #4]
 8000a74:	781b      	ldrb	r3, [r3, #0]
 8000a76:	2b02      	cmp	r3, #2
 8000a78:	bf14      	ite	ne
 8000a7a:	2301      	movne	r3, #1
 8000a7c:	2300      	moveq	r3, #0
 8000a7e:	b2db      	uxtb	r3, r3
 8000a80:	2b00      	cmp	r3, #0
 8000a82:	d002      	beq.n	8000a8a <gptStartContinuousI+0x3a>
 8000a84:	4806      	ldr	r0, [pc, #24]	@ (8000aa0 <gptStartContinuousI+0x50>)
 8000a86:	f001 fe33 	bl	80026f0 <chSysHalt>
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000a8a:	9b01      	ldr	r3, [sp, #4]
 8000a8c:	2203      	movs	r2, #3
 8000a8e:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 8000a90:	9900      	ldr	r1, [sp, #0]
 8000a92:	9801      	ldr	r0, [sp, #4]
 8000a94:	f001 fc84 	bl	80023a0 <gpt_lld_start_timer>
}
 8000a98:	bf00      	nop
 8000a9a:	b003      	add	sp, #12
 8000a9c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000aa0:	0800511c 	.word	0x0800511c
	...

08000ab0 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000ab0:	b500      	push	{lr}
 8000ab2:	b083      	sub	sp, #12
 8000ab4:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8000ab6:	f7ff ff43 	bl	8000940 <osalSysLock.lto_priv.3>
  gptStopTimerI(gptp);
 8000aba:	9801      	ldr	r0, [sp, #4]
 8000abc:	f000 f808 	bl	8000ad0 <gptStopTimerI>
  osalSysUnlock();
 8000ac0:	f7ff ff46 	bl	8000950 <osalSysUnlock.lto_priv.3>
}
 8000ac4:	bf00      	nop
 8000ac6:	b003      	add	sp, #12
 8000ac8:	f85d fb04 	ldr.w	pc, [sp], #4
 8000acc:	0000      	movs	r0, r0
	...

08000ad0 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000ad0:	b500      	push	{lr}
 8000ad2:	b083      	sub	sp, #12
 8000ad4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8000ad6:	f001 ffab 	bl	8002a30 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000ada:	9b01      	ldr	r3, [sp, #4]
 8000adc:	2b00      	cmp	r3, #0
 8000ade:	bf0c      	ite	eq
 8000ae0:	2301      	moveq	r3, #1
 8000ae2:	2300      	movne	r3, #0
 8000ae4:	b2db      	uxtb	r3, r3
 8000ae6:	2b00      	cmp	r3, #0
 8000ae8:	d002      	beq.n	8000af0 <gptStopTimerI+0x20>
 8000aea:	4818      	ldr	r0, [pc, #96]	@ (8000b4c <gptStopTimerI+0x7c>)
 8000aec:	f001 fe00 	bl	80026f0 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
 8000af0:	9b01      	ldr	r3, [sp, #4]
 8000af2:	781b      	ldrb	r3, [r3, #0]
 8000af4:	2b02      	cmp	r3, #2
 8000af6:	bf14      	ite	ne
 8000af8:	2301      	movne	r3, #1
 8000afa:	2300      	moveq	r3, #0
 8000afc:	b2db      	uxtb	r3, r3
 8000afe:	2b00      	cmp	r3, #0
 8000b00:	d00a      	beq.n	8000b18 <gptStopTimerI+0x48>
 8000b02:	9b01      	ldr	r3, [sp, #4]
 8000b04:	781b      	ldrb	r3, [r3, #0]
 8000b06:	2b03      	cmp	r3, #3
 8000b08:	bf14      	ite	ne
 8000b0a:	2301      	movne	r3, #1
 8000b0c:	2300      	moveq	r3, #0
 8000b0e:	b2db      	uxtb	r3, r3
 8000b10:	2b00      	cmp	r3, #0
 8000b12:	d001      	beq.n	8000b18 <gptStopTimerI+0x48>
 8000b14:	2301      	movs	r3, #1
 8000b16:	e000      	b.n	8000b1a <gptStopTimerI+0x4a>
 8000b18:	2300      	movs	r3, #0
 8000b1a:	2b00      	cmp	r3, #0
 8000b1c:	d00b      	beq.n	8000b36 <gptStopTimerI+0x66>
 8000b1e:	9b01      	ldr	r3, [sp, #4]
 8000b20:	781b      	ldrb	r3, [r3, #0]
 8000b22:	2b04      	cmp	r3, #4
 8000b24:	bf14      	ite	ne
 8000b26:	2301      	movne	r3, #1
 8000b28:	2300      	moveq	r3, #0
 8000b2a:	b2db      	uxtb	r3, r3
 8000b2c:	2b00      	cmp	r3, #0
 8000b2e:	d002      	beq.n	8000b36 <gptStopTimerI+0x66>
 8000b30:	4806      	ldr	r0, [pc, #24]	@ (8000b4c <gptStopTimerI+0x7c>)
 8000b32:	f001 fddd 	bl	80026f0 <chSysHalt>
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000b36:	9b01      	ldr	r3, [sp, #4]
 8000b38:	2202      	movs	r2, #2
 8000b3a:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000b3c:	9801      	ldr	r0, [sp, #4]
 8000b3e:	f001 fc57 	bl	80023f0 <gpt_lld_stop_timer>
}
 8000b42:	bf00      	nop
 8000b44:	b003      	add	sp, #12
 8000b46:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b4a:	bf00      	nop
 8000b4c:	08005130 	.word	0x08005130

08000b50 <nvicInit>:
/*===========================================================================*/

/**
 * @brief   NVIC clearing and initialization.
 */
void nvicInit(void) {
 8000b50:	b082      	sub	sp, #8
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
#else
  uint32_t n = SCnSCB->ICTR;
 8000b52:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8000b56:	685b      	ldr	r3, [r3, #4]
 8000b58:	9300      	str	r3, [sp, #0]
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 8000b5a:	2300      	movs	r3, #0
 8000b5c:	9301      	str	r3, [sp, #4]
 8000b5e:	e010      	b.n	8000b82 <nvicInit+0x32>
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8000b60:	4a0c      	ldr	r2, [pc, #48]	@ (8000b94 <nvicInit+0x44>)
 8000b62:	9b01      	ldr	r3, [sp, #4]
 8000b64:	3320      	adds	r3, #32
 8000b66:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8000b6a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 8000b6e:	4a09      	ldr	r2, [pc, #36]	@ (8000b94 <nvicInit+0x44>)
 8000b70:	9b01      	ldr	r3, [sp, #4]
 8000b72:	3360      	adds	r3, #96	@ 0x60
 8000b74:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8000b78:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  for (uint32_t i = 0U; i <= n; i++) {
 8000b7c:	9b01      	ldr	r3, [sp, #4]
 8000b7e:	3301      	adds	r3, #1
 8000b80:	9301      	str	r3, [sp, #4]
 8000b82:	9a01      	ldr	r2, [sp, #4]
 8000b84:	9b00      	ldr	r3, [sp, #0]
 8000b86:	429a      	cmp	r2, r3
 8000b88:	d9ea      	bls.n	8000b60 <nvicInit+0x10>
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
    NVIC->__ITNS[i] = 0xFFFFFFFFU;
#endif
  }
}
 8000b8a:	bf00      	nop
 8000b8c:	bf00      	nop
 8000b8e:	b002      	add	sp, #8
 8000b90:	4770      	bx	lr
 8000b92:	bf00      	nop
 8000b94:	e000e100 	.word	0xe000e100
	...

08000ba0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000ba0:	b082      	sub	sp, #8
 8000ba2:	9001      	str	r0, [sp, #4]
 8000ba4:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8000ba6:	9b00      	ldr	r3, [sp, #0]
 8000ba8:	b2db      	uxtb	r3, r3
 8000baa:	4a11      	ldr	r2, [pc, #68]	@ (8000bf0 <nvicEnableVector+0x50>)
 8000bac:	011b      	lsls	r3, r3, #4
 8000bae:	b2d9      	uxtb	r1, r3
 8000bb0:	9b01      	ldr	r3, [sp, #4]
 8000bb2:	4413      	add	r3, r2
 8000bb4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8000bb8:	460a      	mov	r2, r1
 8000bba:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000bbc:	9b01      	ldr	r3, [sp, #4]
 8000bbe:	f003 021f 	and.w	r2, r3, #31
 8000bc2:	490b      	ldr	r1, [pc, #44]	@ (8000bf0 <nvicEnableVector+0x50>)
 8000bc4:	9b01      	ldr	r3, [sp, #4]
 8000bc6:	095b      	lsrs	r3, r3, #5
 8000bc8:	2001      	movs	r0, #1
 8000bca:	fa00 f202 	lsl.w	r2, r0, r2
 8000bce:	3360      	adds	r3, #96	@ 0x60
 8000bd0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000bd4:	9b01      	ldr	r3, [sp, #4]
 8000bd6:	f003 021f 	and.w	r2, r3, #31
 8000bda:	4905      	ldr	r1, [pc, #20]	@ (8000bf0 <nvicEnableVector+0x50>)
 8000bdc:	9b01      	ldr	r3, [sp, #4]
 8000bde:	095b      	lsrs	r3, r3, #5
 8000be0:	2001      	movs	r0, #1
 8000be2:	fa00 f202 	lsl.w	r2, r0, r2
 8000be6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000bea:	bf00      	nop
 8000bec:	b002      	add	sp, #8
 8000bee:	4770      	bx	lr
 8000bf0:	e000e100 	.word	0xe000e100
	...

08000c00 <exti0_irq_init>:

static inline void exti0_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
 8000c00:	bf00      	nop
 8000c02:	4770      	bx	lr
	...

08000c10 <exti1_irq_init>:

static inline void exti1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
 8000c10:	bf00      	nop
 8000c12:	4770      	bx	lr
	...

08000c20 <exti2_irq_init>:

static inline void exti2_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
 8000c20:	bf00      	nop
 8000c22:	4770      	bx	lr
	...

08000c30 <exti3_irq_init>:

static inline void exti3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
 8000c30:	bf00      	nop
 8000c32:	4770      	bx	lr
	...

08000c40 <exti4_irq_init>:

static inline void exti4_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
 8000c40:	bf00      	nop
 8000c42:	4770      	bx	lr
	...

08000c50 <exti5_9_irq_init>:

static inline void exti5_9_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
 8000c50:	bf00      	nop
 8000c52:	4770      	bx	lr
	...

08000c60 <exti10_15_irq_init>:

static inline void exti10_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
 8000c60:	bf00      	nop
 8000c62:	4770      	bx	lr
	...

08000c70 <exti16_exti35_38_irq_init>:
#if defined(STM32_EXTI16_IS_USED) || defined(STM32_EXTI35_IS_USED) ||       \
    defined(STM32_EXTI36_IS_USED) || defined(STM32_EXTI37_IS_USED) ||       \
    defined(STM32_EXTI38_IS_USED)
  nvicEnableVector(STM32_EXTI1635_38_NUMBER, STM32_IRQ_EXTI1635_38_PRIORITY);
#endif
}
 8000c70:	bf00      	nop
 8000c72:	4770      	bx	lr
	...

08000c80 <exti18_irq_init>:

static inline void exti18_irq_init(void) {
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
 8000c80:	bf00      	nop
 8000c82:	4770      	bx	lr
	...

08000c90 <exti19_irq_init>:

static inline void exti19_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
 8000c90:	bf00      	nop
 8000c92:	4770      	bx	lr
	...

08000ca0 <exti21_22_irq_init>:

static inline void exti21_22_irq_init(void) {
#if defined(STM32_EXTI21_IS_USED) || defined(STM32_EXTI22_IS_USED)
  nvicEnableVector(STM32_EXTI21_22_NUMBER, STM32_IRQ_EXTI21_22_PRIORITY);
#endif
}
 8000ca0:	bf00      	nop
 8000ca2:	4770      	bx	lr
	...

08000cb0 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000cb0:	bf00      	nop
 8000cb2:	4770      	bx	lr
	...

08000cc0 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000cc0:	bf00      	nop
 8000cc2:	4770      	bx	lr
	...

08000cd0 <usart3_irq_init>:

static inline void usart3_irq_init(void) {
#if defined(STM32_USART3_IS_USED)
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
#endif
}
 8000cd0:	bf00      	nop
 8000cd2:	4770      	bx	lr
	...

08000ce0 <uart4_irq_init>:

static inline void uart4_irq_init(void) {
#if defined(STM32_UART4_IS_USED)
  nvicEnableVector(STM32_UART4_NUMBER, STM32_IRQ_UART4_PRIORITY);
#endif
}
 8000ce0:	bf00      	nop
 8000ce2:	4770      	bx	lr
	...

08000cf0 <uart5_irq_init>:

static inline void uart5_irq_init(void) {
#if defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_IRQ_UART5_PRIORITY);
#endif
}
 8000cf0:	bf00      	nop
 8000cf2:	4770      	bx	lr
	...

08000d00 <lpuart1_irq_init>:

static inline void lpuart1_irq_init(void) {
#if defined(STM32_LPUART1_IS_USED)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_IRQ_LPUART1_PRIORITY);
#endif
}
 8000d00:	bf00      	nop
 8000d02:	4770      	bx	lr
	...

08000d10 <tim1_tim15_tim16_tim17_irq_init>:
#endif
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_CC_NUMBER,
                   STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8000d10:	bf00      	nop
 8000d12:	4770      	bx	lr
	...

08000d20 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8000d20:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8000d22:	2107      	movs	r1, #7
 8000d24:	201c      	movs	r0, #28
 8000d26:	f7ff ff3b 	bl	8000ba0 <nvicEnableVector>
#endif
}
 8000d2a:	bf00      	nop
 8000d2c:	bd08      	pop	{r3, pc}
 8000d2e:	bf00      	nop

08000d30 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000d30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000d32:	f001 fe05 	bl	8002940 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000d36:	f001 fa83 	bl	8002240 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000d3a:	f001 fe39 	bl	80029b0 <__dbg_check_leave_isr>
 8000d3e:	f004 f83f 	bl	8004dc0 <__port_irq_epilogue>
}
 8000d42:	bf00      	nop
 8000d44:	bd08      	pop	{r3, pc}
 8000d46:	bf00      	nop
	...

08000d50 <tim3_irq_init>:

static inline void tim3_irq_init(void) {
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
 8000d50:	bf00      	nop
 8000d52:	4770      	bx	lr
	...

08000d60 <tim4_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim4_irq_init(void) {
 8000d60:	b508      	push	{r3, lr}
#if defined(STM32_TIM4_IS_USED)
  nvicEnableVector(STM32_TIM4_NUMBER, STM32_IRQ_TIM4_PRIORITY);
 8000d62:	2107      	movs	r1, #7
 8000d64:	201e      	movs	r0, #30
 8000d66:	f7ff ff1b 	bl	8000ba0 <nvicEnableVector>
#endif
}
 8000d6a:	bf00      	nop
 8000d6c:	bd08      	pop	{r3, pc}
 8000d6e:	bf00      	nop

08000d70 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8000d70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000d72:	f001 fde5 	bl	8002940 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM4
  gpt_lld_serve_interrupt(&GPTD4);
 8000d76:	4804      	ldr	r0, [pc, #16]	@ (8000d88 <VectorB8+0x18>)
 8000d78:	f001 fb52 	bl	8002420 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM4
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000d7c:	f001 fe18 	bl	80029b0 <__dbg_check_leave_isr>
 8000d80:	f004 f81e 	bl	8004dc0 <__port_irq_epilogue>
}
 8000d84:	bf00      	nop
 8000d86:	bd08      	pop	{r3, pc}
 8000d88:	20000924 	.word	0x20000924
 8000d8c:	00000000 	.word	0x00000000

08000d90 <tim5_irq_init>:

static inline void tim5_irq_init(void) {
#if defined(STM32_TIM5_IS_USED)
  nvicEnableVector(STM32_TIM5_NUMBER, STM32_IRQ_TIM5_PRIORITY);
#endif
}
 8000d90:	bf00      	nop
 8000d92:	4770      	bx	lr
	...

08000da0 <tim6_irq_init>:

static inline void tim6_irq_init(void) {
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
#endif
}
 8000da0:	bf00      	nop
 8000da2:	4770      	bx	lr
	...

08000db0 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 8000db0:	bf00      	nop
 8000db2:	4770      	bx	lr
	...

08000dc0 <tim8_irq_init>:
static inline void tim8_irq_init(void) {
#if defined(STM32_TIM8_IS_USED)
  nvicEnableVector(STM32_TIM8_UP_NUMBER, STM32_IRQ_TIM8_UP_PRIORITY);
  nvicEnableVector(STM32_TIM8_CC_NUMBER, STM32_IRQ_TIM8_CC_PRIORITY);
#endif
}
 8000dc0:	bf00      	nop
 8000dc2:	4770      	bx	lr
	...

08000dd0 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000dd0:	b508      	push	{r3, lr}

  exti0_irq_init();
 8000dd2:	f7ff ff15 	bl	8000c00 <exti0_irq_init>
  exti1_irq_init();
 8000dd6:	f7ff ff1b 	bl	8000c10 <exti1_irq_init>
  exti2_irq_init();
 8000dda:	f7ff ff21 	bl	8000c20 <exti2_irq_init>
  exti3_irq_init();
 8000dde:	f7ff ff27 	bl	8000c30 <exti3_irq_init>
  exti4_irq_init();
 8000de2:	f7ff ff2d 	bl	8000c40 <exti4_irq_init>
  exti5_9_irq_init();
 8000de6:	f7ff ff33 	bl	8000c50 <exti5_9_irq_init>
  exti10_15_irq_init();
 8000dea:	f7ff ff39 	bl	8000c60 <exti10_15_irq_init>
  exti16_exti35_38_irq_init();
 8000dee:	f7ff ff3f 	bl	8000c70 <exti16_exti35_38_irq_init>
  exti18_irq_init();
 8000df2:	f7ff ff45 	bl	8000c80 <exti18_irq_init>
  exti19_irq_init();
 8000df6:	f7ff ff4b 	bl	8000c90 <exti19_irq_init>
  exti21_22_irq_init();
 8000dfa:	f7ff ff51 	bl	8000ca0 <exti21_22_irq_init>

  tim1_tim15_tim16_tim17_irq_init();
 8000dfe:	f7ff ff87 	bl	8000d10 <tim1_tim15_tim16_tim17_irq_init>
  tim2_irq_init();
 8000e02:	f7ff ff8d 	bl	8000d20 <tim2_irq_init>
  tim3_irq_init();
 8000e06:	f7ff ffa3 	bl	8000d50 <tim3_irq_init>
  tim4_irq_init();
 8000e0a:	f7ff ffa9 	bl	8000d60 <tim4_irq_init>
  tim5_irq_init();
 8000e0e:	f7ff ffbf 	bl	8000d90 <tim5_irq_init>
  tim6_irq_init();
 8000e12:	f7ff ffc5 	bl	8000da0 <tim6_irq_init>
  tim7_irq_init();
 8000e16:	f7ff ffcb 	bl	8000db0 <tim7_irq_init>
  tim8_irq_init();
 8000e1a:	f7ff ffd1 	bl	8000dc0 <tim8_irq_init>

  usart1_irq_init();
 8000e1e:	f7ff ff47 	bl	8000cb0 <usart1_irq_init>
  usart2_irq_init();
 8000e22:	f7ff ff4d 	bl	8000cc0 <usart2_irq_init>
  usart3_irq_init();
 8000e26:	f7ff ff53 	bl	8000cd0 <usart3_irq_init>
  uart4_irq_init();
 8000e2a:	f7ff ff59 	bl	8000ce0 <uart4_irq_init>
  uart5_irq_init();
 8000e2e:	f7ff ff5f 	bl	8000cf0 <uart5_irq_init>
  lpuart1_irq_init();
 8000e32:	f7ff ff65 	bl	8000d00 <lpuart1_irq_init>
}
 8000e36:	bf00      	nop
 8000e38:	bd08      	pop	{r3, pc}
 8000e3a:	bf00      	nop
 8000e3c:	0000      	movs	r0, r0
	...

08000e40 <lse_init>:
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN;
 8000e40:	4b09      	ldr	r3, [pc, #36]	@ (8000e68 <lse_init+0x28>)
 8000e42:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000e46:	4a08      	ldr	r2, [pc, #32]	@ (8000e68 <lse_init+0x28>)
 8000e48:	f043 0319 	orr.w	r3, r3, #25
 8000e4c:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  while ((RCC->BDCR & (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) !=
 8000e50:	bf00      	nop
 8000e52:	4b05      	ldr	r3, [pc, #20]	@ (8000e68 <lse_init+0x28>)
 8000e54:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000e58:	f003 0302 	and.w	r3, r3, #2
 8000e5c:	2b02      	cmp	r3, #2
 8000e5e:	d1f8      	bne.n	8000e52 <lse_init+0x12>
         (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) {
  }
#endif
#endif
}
 8000e60:	bf00      	nop
 8000e62:	bf00      	nop
 8000e64:	4770      	bx	lr
 8000e66:	bf00      	nop
 8000e68:	40021000 	.word	0x40021000
 8000e6c:	00000000 	.word	0x00000000

08000e70 <lsi_init>:

__STATIC_INLINE void lsi_init(void) {

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= STM32_LSIPRE | RCC_CSR_LSION;
 8000e70:	4b09      	ldr	r3, [pc, #36]	@ (8000e98 <lsi_init+0x28>)
 8000e72:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8000e76:	4a08      	ldr	r2, [pc, #32]	@ (8000e98 <lsi_init+0x28>)
 8000e78:	f043 0301 	orr.w	r3, r3, #1
 8000e7c:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
  while ((RCC->BDCR & RCC_CSR_LSIRDY) == 0U) {
 8000e80:	bf00      	nop
 8000e82:	4b05      	ldr	r3, [pc, #20]	@ (8000e98 <lsi_init+0x28>)
 8000e84:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000e88:	f003 0302 	and.w	r3, r3, #2
 8000e8c:	2b00      	cmp	r3, #0
 8000e8e:	d0f8      	beq.n	8000e82 <lsi_init+0x12>
  }
#endif
}
 8000e90:	bf00      	nop
 8000e92:	bf00      	nop
 8000e94:	4770      	bx	lr
 8000e96:	bf00      	nop
 8000e98:	40021000 	.word	0x40021000
 8000e9c:	00000000 	.word	0x00000000

08000ea0 <msi_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void msi_enable(void) {

  RCC->CR |= RCC_CR_MSION;
 8000ea0:	4b07      	ldr	r3, [pc, #28]	@ (8000ec0 <msi_enable+0x20>)
 8000ea2:	681b      	ldr	r3, [r3, #0]
 8000ea4:	4a06      	ldr	r2, [pc, #24]	@ (8000ec0 <msi_enable+0x20>)
 8000ea6:	f043 0301 	orr.w	r3, r3, #1
 8000eaa:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000eac:	bf00      	nop
 8000eae:	4b04      	ldr	r3, [pc, #16]	@ (8000ec0 <msi_enable+0x20>)
 8000eb0:	681b      	ldr	r3, [r3, #0]
 8000eb2:	f003 0302 	and.w	r3, r3, #2
 8000eb6:	2b00      	cmp	r3, #0
 8000eb8:	d0f9      	beq.n	8000eae <msi_enable+0xe>
    /* Wait until MSI is stable.*/
  }
}
 8000eba:	bf00      	nop
 8000ebc:	bf00      	nop
 8000ebe:	4770      	bx	lr
 8000ec0:	40021000 	.word	0x40021000
	...

08000ed0 <msi_reset>:
__STATIC_INLINE void msi_disable(void) {

  RCC->CR &= ~RCC_CR_MSION;
}

__STATIC_INLINE void msi_reset(void) {
 8000ed0:	b508      	push	{r3, lr}

  /* Resetting MSI defaults.
     Note from RM0432: MSIRANGE can be modified when MSI is OFF (MSION=0)
     or when MSI is ready (MSIRDY=1). MSIRANGE must NOT be modified when
     MSI is ON and NOT ready (MSION=1 and MSIRDY=0).*/
  RCC->CR = (RCC->CR & ~RCC_CR_MSIRANGE_Msk) | RCC_CR_MSIRANGE_6;
 8000ed2:	4b0b      	ldr	r3, [pc, #44]	@ (8000f00 <msi_reset+0x30>)
 8000ed4:	681b      	ldr	r3, [r3, #0]
 8000ed6:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8000eda:	4a09      	ldr	r2, [pc, #36]	@ (8000f00 <msi_reset+0x30>)
 8000edc:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 8000ee0:	6013      	str	r3, [r2, #0]

  /* Making sure MSI is active and ready.*/
  msi_enable();
 8000ee2:	f7ff ffdd 	bl	8000ea0 <msi_enable>

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = RCC_CFGR_SW_MSI;
 8000ee6:	4b06      	ldr	r3, [pc, #24]	@ (8000f00 <msi_reset+0x30>)
 8000ee8:	2200      	movs	r2, #0
 8000eea:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI) {
 8000eec:	bf00      	nop
 8000eee:	4b04      	ldr	r3, [pc, #16]	@ (8000f00 <msi_reset+0x30>)
 8000ef0:	689b      	ldr	r3, [r3, #8]
 8000ef2:	f003 030c 	and.w	r3, r3, #12
 8000ef6:	2b00      	cmp	r3, #0
 8000ef8:	d1f9      	bne.n	8000eee <msi_reset+0x1e>
    /* Wait until MSI is selected.*/
  }
}
 8000efa:	bf00      	nop
 8000efc:	bf00      	nop
 8000efe:	bd08      	pop	{r3, pc}
 8000f00:	40021000 	.word	0x40021000
	...

08000f10 <msi_init>:

__STATIC_INLINE void msi_init(void) {
 8000f10:	b082      	sub	sp, #8
     Trim fields are not altered from reset values.*/

  /* MSIRANGE can be set only when MSI is OFF or READY, it is ready after
     reset.*/
#if STM32_MSIPLL_ENABLED
  cr = STM32_MSIRANGE | RCC_CR_MSIPLLEN | RCC_CR_MSION;
 8000f12:	23b5      	movs	r3, #181	@ 0xb5
 8000f14:	9301      	str	r3, [sp, #4]
#else
  cr = STM32_MSIRANGE | RCC_CR_MSION;
#endif
  RCC->CR = cr;
 8000f16:	4a17      	ldr	r2, [pc, #92]	@ (8000f74 <msi_init+0x64>)
 8000f18:	9b01      	ldr	r3, [sp, #4]
 8000f1a:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000f1c:	bf00      	nop
 8000f1e:	4b15      	ldr	r3, [pc, #84]	@ (8000f74 <msi_init+0x64>)
 8000f20:	681b      	ldr	r3, [r3, #0]
 8000f22:	f003 0302 	and.w	r3, r3, #2
 8000f26:	2b00      	cmp	r3, #0
 8000f28:	d0f9      	beq.n	8000f1e <msi_init+0xe>
    /* Wait until MSI is stable.*/
  }

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0U;
 8000f2a:	4b12      	ldr	r3, [pc, #72]	@ (8000f74 <msi_init+0x64>)
 8000f2c:	2200      	movs	r2, #0
 8000f2e:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8000f30:	bf00      	nop
 8000f32:	4b10      	ldr	r3, [pc, #64]	@ (8000f74 <msi_init+0x64>)
 8000f34:	689b      	ldr	r3, [r3, #8]
 8000f36:	f003 030c 	and.w	r3, r3, #12
 8000f3a:	2b00      	cmp	r3, #0
 8000f3c:	d1f9      	bne.n	8000f32 <msi_init+0x22>
    ;                                       /* Wait until MSI is selected.  */

  /* Updating MSISRANGE value. MSISRANGE can be set only when MSIRGSEL is high.
     This range is used exiting the Standby mode until MSIRGSEL is set.*/
  cr      |= RCC_CR_MSIRGSEL;
 8000f3e:	9b01      	ldr	r3, [sp, #4]
 8000f40:	f043 0308 	orr.w	r3, r3, #8
 8000f44:	9301      	str	r3, [sp, #4]
  RCC->CR  = cr;
 8000f46:	4a0b      	ldr	r2, [pc, #44]	@ (8000f74 <msi_init+0x64>)
 8000f48:	9b01      	ldr	r3, [sp, #4]
 8000f4a:	6013      	str	r3, [r2, #0]

  csr      = RCC->CSR;
 8000f4c:	4b09      	ldr	r3, [pc, #36]	@ (8000f74 <msi_init+0x64>)
 8000f4e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8000f52:	9300      	str	r3, [sp, #0]
  csr     &= ~STM32_MSISRANGE_MASK;
 8000f54:	9b00      	ldr	r3, [sp, #0]
 8000f56:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8000f5a:	9300      	str	r3, [sp, #0]
  csr     |= STM32_MSISRANGE;
 8000f5c:	9b00      	ldr	r3, [sp, #0]
 8000f5e:	f443 63c0 	orr.w	r3, r3, #1536	@ 0x600
 8000f62:	9300      	str	r3, [sp, #0]
  RCC->CSR = csr;
 8000f64:	4a03      	ldr	r2, [pc, #12]	@ (8000f74 <msi_init+0x64>)
 8000f66:	9b00      	ldr	r3, [sp, #0]
 8000f68:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
}
 8000f6c:	bf00      	nop
 8000f6e:	b002      	add	sp, #8
 8000f70:	4770      	bx	lr
 8000f72:	bf00      	nop
 8000f74:	40021000 	.word	0x40021000
	...

08000f80 <hsi16_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void hsi16_enable(void) {

  RCC->CR |= RCC_CR_HSION;
 8000f80:	4b07      	ldr	r3, [pc, #28]	@ (8000fa0 <hsi16_enable+0x20>)
 8000f82:	681b      	ldr	r3, [r3, #0]
 8000f84:	4a06      	ldr	r2, [pc, #24]	@ (8000fa0 <hsi16_enable+0x20>)
 8000f86:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000f8a:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0U) {
 8000f8c:	bf00      	nop
 8000f8e:	4b04      	ldr	r3, [pc, #16]	@ (8000fa0 <hsi16_enable+0x20>)
 8000f90:	681b      	ldr	r3, [r3, #0]
 8000f92:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8000f96:	2b00      	cmp	r3, #0
 8000f98:	d0f9      	beq.n	8000f8e <hsi16_enable+0xe>
    /* Waiting for HSI16 activation.*/
  }
}
 8000f9a:	bf00      	nop
 8000f9c:	bf00      	nop
 8000f9e:	4770      	bx	lr
 8000fa0:	40021000 	.word	0x40021000
	...

08000fb0 <hsi16_init>:
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI) {
    /* Wait until HSI is selected.*/
  }
}

__STATIC_INLINE void hsi16_init(void) {
 8000fb0:	b508      	push	{r3, lr}

#if STM32_HSI16_ENABLED
  /* HSI activation.*/
  hsi16_enable();
 8000fb2:	f7ff ffe5 	bl	8000f80 <hsi16_enable>
#endif
}
 8000fb6:	bf00      	nop
 8000fb8:	bd08      	pop	{r3, pc}
 8000fba:	bf00      	nop
 8000fbc:	0000      	movs	r0, r0
	...

08000fc0 <hsi48_init>:

#if STM32_HSI48_ENABLED
  /* HSI activation.*/
  hsi48_enable();
#endif
}
 8000fc0:	bf00      	nop
 8000fc2:	4770      	bx	lr
	...

08000fd0 <hse_init>:
__STATIC_INLINE void hse_init(void) {

#if STM32_HSE_ENABLED
  hse_enable();
#endif
}
 8000fd0:	bf00      	nop
 8000fd2:	4770      	bx	lr
	...

08000fe0 <pll_not_locked>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE bool pll_not_locked(void) {

  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8000fe0:	4b05      	ldr	r3, [pc, #20]	@ (8000ff8 <pll_not_locked+0x18>)
 8000fe2:	681b      	ldr	r3, [r3, #0]
 8000fe4:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8000fe8:	2b00      	cmp	r3, #0
 8000fea:	bf0c      	ite	eq
 8000fec:	2301      	moveq	r3, #1
 8000fee:	2300      	movne	r3, #0
 8000ff0:	b2db      	uxtb	r3, r3
}
 8000ff2:	4618      	mov	r0, r3
 8000ff4:	4770      	bx	lr
 8000ff6:	bf00      	nop
 8000ff8:	40021000 	.word	0x40021000
 8000ffc:	00000000 	.word	0x00000000

08001000 <pll_wait_lock>:

__STATIC_INLINE void pll_wait_lock(void) {
 8001000:	b508      	push	{r3, lr}

  while (pll_not_locked()) {
 8001002:	bf00      	nop
 8001004:	f7ff ffec 	bl	8000fe0 <pll_not_locked>
 8001008:	4603      	mov	r3, r0
 800100a:	2b00      	cmp	r3, #0
 800100c:	d1fa      	bne.n	8001004 <pll_wait_lock+0x4>
    /* Waiting for PLL lock.*/
  }
}
 800100e:	bf00      	nop
 8001010:	bf00      	nop
 8001012:	bd08      	pop	{r3, pc}
	...

08001020 <pll_init>:

#endif /* STM32_RCC_HAS_PLL */

__STATIC_INLINE void pll_init(void) {
 8001020:	b508      	push	{r3, lr}

#if STM32_RCC_HAS_PLL
#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLPDIV | STM32_PLLR   |
 8001022:	4b06      	ldr	r3, [pc, #24]	@ (800103c <pll_init+0x1c>)
 8001024:	4a06      	ldr	r2, [pc, #24]	@ (8001040 <pll_init+0x20>)
 8001026:	60da      	str	r2, [r3, #12]
                 STM32_PLLREN  | STM32_PLLQ   |
                 STM32_PLLQEN  | STM32_PLLP   |
                 STM32_PLLPEN  | STM32_PLLN   |
                 STM32_PLLM    | STM32_PLLSRC;
  RCC->CR |= RCC_CR_PLLON;
 8001028:	4b04      	ldr	r3, [pc, #16]	@ (800103c <pll_init+0x1c>)
 800102a:	681b      	ldr	r3, [r3, #0]
 800102c:	4a03      	ldr	r2, [pc, #12]	@ (800103c <pll_init+0x1c>)
 800102e:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001032:	6013      	str	r3, [r2, #0]

  pll_wait_lock();
 8001034:	f7ff ffe4 	bl	8001000 <pll_wait_lock>
#endif
#endif
}
 8001038:	bf00      	nop
 800103a:	bd08      	pop	{r3, pc}
 800103c:	40021000 	.word	0x40021000
 8001040:	03405032 	.word	0x03405032
	...

08001050 <pllsai1_init>:
  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0U)
    ;
#endif
#endif
}
 8001050:	bf00      	nop
 8001052:	4770      	bx	lr
	...

08001060 <pllsai2_init>:

  /* Waiting for PLL lock.*/
  pllsai2_wait_lock();
#endif
#endif
}
 8001060:	bf00      	nop
 8001062:	4770      	bx	lr
	...

08001070 <bd_init>:
/*===========================================================================*/

/**
 * @brief   Initializes the backup domain.
 */
__STATIC_INLINE void bd_init(void) {
 8001070:	b082      	sub	sp, #8
  uint32_t bdcr;

  /* Current settings.*/
  bdcr = RCC->BDCR;
 8001072:	4b09      	ldr	r3, [pc, #36]	@ (8001098 <bd_init+0x28>)
 8001074:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8001078:	9301      	str	r3, [sp, #4]
    bdcr |= RCC_BDCR_RTCEN;
  }
#endif

  /* Selectors.*/
  bdcr &= ~(STM32_RTCSEL_MASK | STM32_LSCOSEL_MASK);
 800107a:	9b01      	ldr	r3, [sp, #4]
 800107c:	f023 2303 	bic.w	r3, r3, #50332416	@ 0x3000300
 8001080:	9301      	str	r3, [sp, #4]
  bdcr |= STM32_RTCSEL | STM32_LSCOSEL;
 8001082:	9b01      	ldr	r3, [sp, #4]
 8001084:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001088:	9301      	str	r3, [sp, #4]

  /* Final settings.*/
  RCC->BDCR = bdcr;
 800108a:	4a03      	ldr	r2, [pc, #12]	@ (8001098 <bd_init+0x28>)
 800108c:	9b01      	ldr	r3, [sp, #4]
 800108e:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
}
 8001092:	bf00      	nop
 8001094:	b002      	add	sp, #8
 8001096:	4770      	bx	lr
 8001098:	40021000 	.word	0x40021000
 800109c:	00000000 	.word	0x00000000

080010a0 <bd_reset>:
 *          of the whole BKP domain.
 */
__STATIC_INLINE void bd_reset(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80010a0:	4b09      	ldr	r3, [pc, #36]	@ (80010c8 <bd_reset+0x28>)
 80010a2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80010a6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 80010aa:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80010ae:	d008      	beq.n	80010c2 <bd_reset+0x22>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80010b0:	4b05      	ldr	r3, [pc, #20]	@ (80010c8 <bd_reset+0x28>)
 80010b2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 80010b6:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    RCC->BDCR = 0U;
 80010ba:	4b03      	ldr	r3, [pc, #12]	@ (80010c8 <bd_reset+0x28>)
 80010bc:	2200      	movs	r2, #0
 80010be:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  }
}
 80010c2:	bf00      	nop
 80010c4:	4770      	bx	lr
 80010c6:	bf00      	nop
 80010c8:	40021000 	.word	0x40021000
 80010cc:	00000000 	.word	0x00000000

080010d0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80010d0:	b508      	push	{r3, lr}

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80010d2:	f000 fe3d 	bl	8001d50 <dmaInit>
#endif

  /* NVIC initialization.*/
  nvicInit();
 80010d6:	f7ff fd3b 	bl	8000b50 <nvicInit>

  /* IRQ subsystem initialization.*/
  irqInit();
 80010da:	f7ff fe79 	bl	8000dd0 <irqInit>
}
 80010de:	bf00      	nop
 80010e0:	bd08      	pop	{r3, pc}
 80010e2:	bf00      	nop
	...

080010f0 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 80010f0:	b500      	push	{lr}
 80010f2:	b083      	sub	sp, #12

#if !STM32_NO_INIT
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~0);
 80010f4:	4b63      	ldr	r3, [pc, #396]	@ (8001284 <stm32_clock_init+0x194>)
 80010f6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80010f8:	4b62      	ldr	r3, [pc, #392]	@ (8001284 <stm32_clock_init+0x194>)
 80010fa:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80010fe:	629a      	str	r2, [r3, #40]	@ 0x28
 8001100:	4b60      	ldr	r3, [pc, #384]	@ (8001284 <stm32_clock_init+0x194>)
 8001102:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001104:	4b5f      	ldr	r3, [pc, #380]	@ (8001284 <stm32_clock_init+0x194>)
 8001106:	2200      	movs	r2, #0
 8001108:	629a      	str	r2, [r3, #40]	@ 0x28
 800110a:	4b5e      	ldr	r3, [pc, #376]	@ (8001284 <stm32_clock_init+0x194>)
 800110c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 800110e:	4b5d      	ldr	r3, [pc, #372]	@ (8001284 <stm32_clock_init+0x194>)
 8001110:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001112:	4a5c      	ldr	r2, [pc, #368]	@ (8001284 <stm32_clock_init+0x194>)
 8001114:	f063 03ff 	orn	r3, r3, #255	@ 0xff
 8001118:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800111a:	4b5a      	ldr	r3, [pc, #360]	@ (8001284 <stm32_clock_init+0x194>)
 800111c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800111e:	4a59      	ldr	r2, [pc, #356]	@ (8001284 <stm32_clock_init+0x194>)
 8001120:	b2db      	uxtb	r3, r3
 8001122:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001124:	4b57      	ldr	r3, [pc, #348]	@ (8001284 <stm32_clock_init+0x194>)
 8001126:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccResetAHB3(~0);
 8001128:	4b56      	ldr	r3, [pc, #344]	@ (8001284 <stm32_clock_init+0x194>)
 800112a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800112c:	4b55      	ldr	r3, [pc, #340]	@ (8001284 <stm32_clock_init+0x194>)
 800112e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001132:	631a      	str	r2, [r3, #48]	@ 0x30
 8001134:	4b53      	ldr	r3, [pc, #332]	@ (8001284 <stm32_clock_init+0x194>)
 8001136:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001138:	4b52      	ldr	r3, [pc, #328]	@ (8001284 <stm32_clock_init+0x194>)
 800113a:	2200      	movs	r2, #0
 800113c:	631a      	str	r2, [r3, #48]	@ 0x30
 800113e:	4b51      	ldr	r3, [pc, #324]	@ (8001284 <stm32_clock_init+0x194>)
 8001140:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
  rccResetAPB1R1(~0);
 8001142:	4b50      	ldr	r3, [pc, #320]	@ (8001284 <stm32_clock_init+0x194>)
 8001144:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001146:	4b4f      	ldr	r3, [pc, #316]	@ (8001284 <stm32_clock_init+0x194>)
 8001148:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800114c:	639a      	str	r2, [r3, #56]	@ 0x38
 800114e:	4b4d      	ldr	r3, [pc, #308]	@ (8001284 <stm32_clock_init+0x194>)
 8001150:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001152:	4b4c      	ldr	r3, [pc, #304]	@ (8001284 <stm32_clock_init+0x194>)
 8001154:	2200      	movs	r2, #0
 8001156:	639a      	str	r2, [r3, #56]	@ 0x38
 8001158:	4b4a      	ldr	r3, [pc, #296]	@ (8001284 <stm32_clock_init+0x194>)
 800115a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
  rccResetAPB1R2(~0);
 800115c:	4b49      	ldr	r3, [pc, #292]	@ (8001284 <stm32_clock_init+0x194>)
 800115e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001160:	4b48      	ldr	r3, [pc, #288]	@ (8001284 <stm32_clock_init+0x194>)
 8001162:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001166:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001168:	4b46      	ldr	r3, [pc, #280]	@ (8001284 <stm32_clock_init+0x194>)
 800116a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800116c:	4b45      	ldr	r3, [pc, #276]	@ (8001284 <stm32_clock_init+0x194>)
 800116e:	2200      	movs	r2, #0
 8001170:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001172:	4b44      	ldr	r3, [pc, #272]	@ (8001284 <stm32_clock_init+0x194>)
 8001174:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  rccResetAPB2(~0);
 8001176:	4b43      	ldr	r3, [pc, #268]	@ (8001284 <stm32_clock_init+0x194>)
 8001178:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800117a:	4b42      	ldr	r3, [pc, #264]	@ (8001284 <stm32_clock_init+0x194>)
 800117c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001180:	641a      	str	r2, [r3, #64]	@ 0x40
 8001182:	4b40      	ldr	r3, [pc, #256]	@ (8001284 <stm32_clock_init+0x194>)
 8001184:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001186:	4b3f      	ldr	r3, [pc, #252]	@ (8001284 <stm32_clock_init+0x194>)
 8001188:	2200      	movs	r2, #0
 800118a:	641a      	str	r2, [r3, #64]	@ 0x40
 800118c:	4b3d      	ldr	r3, [pc, #244]	@ (8001284 <stm32_clock_init+0x194>)
 800118e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40

  /* Flash setup for selected MSI speed setting.*/
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 8001190:	4b3d      	ldr	r3, [pc, #244]	@ (8001288 <stm32_clock_init+0x198>)
 8001192:	f240 7202 	movw	r2, #1794	@ 0x702
 8001196:	601a      	str	r2, [r3, #0]
               STM32_MSI_FLASHBITS;

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, false);
 8001198:	4b3a      	ldr	r3, [pc, #232]	@ (8001284 <stm32_clock_init+0x194>)
 800119a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800119c:	4a39      	ldr	r2, [pc, #228]	@ (8001284 <stm32_clock_init+0x194>)
 800119e:	f043 0301 	orr.w	r3, r3, #1
 80011a2:	6613      	str	r3, [r2, #96]	@ 0x60
 80011a4:	4b37      	ldr	r3, [pc, #220]	@ (8001284 <stm32_clock_init+0x194>)
 80011a6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 80011aa:	4a36      	ldr	r2, [pc, #216]	@ (8001284 <stm32_clock_init+0x194>)
 80011ac:	f023 0301 	bic.w	r3, r3, #1
 80011b0:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 80011b4:	4b33      	ldr	r3, [pc, #204]	@ (8001284 <stm32_clock_init+0x194>)
 80011b6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80

  /* PWR clock enabled.*/
  rccEnablePWRInterface(false);
 80011ba:	4b32      	ldr	r3, [pc, #200]	@ (8001284 <stm32_clock_init+0x194>)
 80011bc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80011be:	4a31      	ldr	r2, [pc, #196]	@ (8001284 <stm32_clock_init+0x194>)
 80011c0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80011c4:	6593      	str	r3, [r2, #88]	@ 0x58
 80011c6:	4b2f      	ldr	r3, [pc, #188]	@ (8001284 <stm32_clock_init+0x194>)
 80011c8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80011ca:	4a2e      	ldr	r2, [pc, #184]	@ (8001284 <stm32_clock_init+0x194>)
 80011cc:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80011d0:	6793      	str	r3, [r2, #120]	@ 0x78
 80011d2:	4b2c      	ldr	r3, [pc, #176]	@ (8001284 <stm32_clock_init+0x194>)
 80011d4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
#if (HAL_USE_RTC == TRUE) && defined(RCC_APB1ENR1_RTCAPBEN)
  rccEnableAPB1R1(RCC_APB1ENR1_RTCAPBEN, true)
#endif

  /* Core voltage setup, backup domain access enabled and left open.*/
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 80011d6:	4b2d      	ldr	r3, [pc, #180]	@ (800128c <stm32_clock_init+0x19c>)
 80011d8:	f44f 7240 	mov.w	r2, #768	@ 0x300
 80011dc:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 80011de:	bf00      	nop
 80011e0:	4b2a      	ldr	r3, [pc, #168]	@ (800128c <stm32_clock_init+0x19c>)
 80011e2:	695b      	ldr	r3, [r3, #20]
 80011e4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80011e8:	2b00      	cmp	r3, #0
 80011ea:	d1f9      	bne.n	80011e0 <stm32_clock_init+0xf0>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR2 = PWR_CR2_PVDE | (STM32_PLS & STM32_PLS_MASK);
#else
  PWR->CR2 = 0;
 80011ec:	4b27      	ldr	r3, [pc, #156]	@ (800128c <stm32_clock_init+0x19c>)
 80011ee:	2200      	movs	r2, #0
 80011f0:	605a      	str	r2, [r3, #4]
  PWR->CR2 |= PWR_CR2_USV;
#endif /* HAL_USE_USB */

  /* Enabling independent VDDIO2 required by GPIOG.*/
#if STM32_HAS_GPIOG
  PWR->CR2 |= PWR_CR2_IOSV;
 80011f2:	4b26      	ldr	r3, [pc, #152]	@ (800128c <stm32_clock_init+0x19c>)
 80011f4:	685b      	ldr	r3, [r3, #4]
 80011f6:	4a25      	ldr	r2, [pc, #148]	@ (800128c <stm32_clock_init+0x19c>)
 80011f8:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 80011fc:	6053      	str	r3, [r2, #4]
#endif /* STM32_HAS_GPIOG */

  /* MSI clock reset.*/
  msi_reset();
 80011fe:	f7ff fe67 	bl	8000ed0 <msi_reset>

  /* Backup domain reset.*/
  bd_reset();
 8001202:	f7ff ff4d 	bl	80010a0 <bd_reset>

  /* Clocks setup.*/
  lse_init();
 8001206:	f7ff fe1b 	bl	8000e40 <lse_init>
  lsi_init();
 800120a:	f7ff fe31 	bl	8000e70 <lsi_init>
  msi_init();
 800120e:	f7ff fe7f 	bl	8000f10 <msi_init>
  hsi16_init();
 8001212:	f7ff fecd 	bl	8000fb0 <hsi16_init>
  hsi48_init();
 8001216:	f7ff fed3 	bl	8000fc0 <hsi48_init>
  hse_init();
 800121a:	f7ff fed9 	bl	8000fd0 <hse_init>

  /* Backup domain initializations.*/
  bd_init();
 800121e:	f7ff ff27 	bl	8001070 <bd_init>

  /* PLLs activation, if required.*/
  pll_init();
 8001222:	f7ff fefd 	bl	8001020 <pll_init>
  pllsai1_init();
 8001226:	f7ff ff13 	bl	8001050 <pllsai1_init>
  pllsai2_init();
 800122a:	f7ff ff19 	bl	8001060 <pllsai2_init>

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 800122e:	4b15      	ldr	r3, [pc, #84]	@ (8001284 <stm32_clock_init+0x194>)
 8001230:	2200      	movs	r2, #0
 8001232:	609a      	str	r2, [r3, #8]
              STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;

  /* CCIPR register initialization, note, must take care of the _OFF
     pseudo settings.*/
  {
    uint32_t ccipr = STM32_DFSDMSEL  | STM32_SWPMI1SEL | STM32_ADCSEL    |
 8001234:	4b16      	ldr	r3, [pc, #88]	@ (8001290 <stm32_clock_init+0x1a0>)
 8001236:	9301      	str	r3, [sp, #4]
    ccipr |= STM32_SAI2SEL;
#endif
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
    ccipr |= STM32_SAI1SEL;
#endif
    RCC->CCIPR = ccipr;
 8001238:	4a12      	ldr	r2, [pc, #72]	@ (8001284 <stm32_clock_init+0x194>)
 800123a:	9b01      	ldr	r3, [sp, #4]
 800123c:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  }
#endif

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS) {
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 8001240:	4b11      	ldr	r3, [pc, #68]	@ (8001288 <stm32_clock_init+0x198>)
 8001242:	681b      	ldr	r3, [r3, #0]
 8001244:	f023 0307 	bic.w	r3, r3, #7
 8001248:	4a0f      	ldr	r2, [pc, #60]	@ (8001288 <stm32_clock_init+0x198>)
 800124a:	f043 0304 	orr.w	r3, r3, #4
 800124e:	6013      	str	r3, [r2, #0]
    while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8001250:	bf00      	nop
 8001252:	4b0d      	ldr	r3, [pc, #52]	@ (8001288 <stm32_clock_init+0x198>)
 8001254:	681b      	ldr	r3, [r3, #0]
 8001256:	f003 0307 	and.w	r3, r3, #7
 800125a:	2b04      	cmp	r3, #4
 800125c:	d1f9      	bne.n	8001252 <stm32_clock_init+0x162>
    }
  }

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800125e:	4b09      	ldr	r3, [pc, #36]	@ (8001284 <stm32_clock_init+0x194>)
 8001260:	689b      	ldr	r3, [r3, #8]
 8001262:	4a08      	ldr	r2, [pc, #32]	@ (8001284 <stm32_clock_init+0x194>)
 8001264:	f043 0303 	orr.w	r3, r3, #3
 8001268:	6093      	str	r3, [r2, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800126a:	bf00      	nop
 800126c:	4b05      	ldr	r3, [pc, #20]	@ (8001284 <stm32_clock_init+0x194>)
 800126e:	689b      	ldr	r3, [r3, #8]
 8001270:	f003 030c 	and.w	r3, r3, #12
 8001274:	2b0c      	cmp	r3, #12
 8001276:	d1f9      	bne.n	800126c <stm32_clock_init+0x17c>
    while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
           (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
    }
  }
#endif /* STM32_NO_INIT */
}
 8001278:	bf00      	nop
 800127a:	bf00      	nop
 800127c:	b003      	add	sp, #12
 800127e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001282:	bf00      	nop
 8001284:	40021000 	.word	0x40021000
 8001288:	40022000 	.word	0x40022000
 800128c:	40007000 	.word	0x40007000
 8001290:	3c015555 	.word	0x3c015555
	...

080012a0 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80012a0:	b500      	push	{lr}
 80012a2:	b083      	sub	sp, #12
 80012a4:	2330      	movs	r3, #48	@ 0x30
 80012a6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80012a8:	9b01      	ldr	r3, [sp, #4]
 80012aa:	f383 8811 	msr	BASEPRI, r3
}
 80012ae:	bf00      	nop
}
 80012b0:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 80012b2:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 80012b4:	f001 faf4 	bl	80028a0 <__dbg_check_lock_from_isr>
}
 80012b8:	bf00      	nop
 80012ba:	b003      	add	sp, #12
 80012bc:	f85d fb04 	ldr.w	pc, [sp], #4

080012c0 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80012c0:	b500      	push	{lr}
 80012c2:	b083      	sub	sp, #12

  __dbg_check_unlock_from_isr();
 80012c4:	f001 fb14 	bl	80028f0 <__dbg_check_unlock_from_isr>
 80012c8:	2300      	movs	r3, #0
 80012ca:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80012cc:	9b01      	ldr	r3, [sp, #4]
 80012ce:	f383 8811 	msr	BASEPRI, r3
}
 80012d2:	bf00      	nop
}
 80012d4:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 80012d6:	bf00      	nop
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 80012d8:	bf00      	nop
 80012da:	b003      	add	sp, #12
 80012dc:	f85d fb04 	ldr.w	pc, [sp], #4

080012e0 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 80012e0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80012e2:	f7ff ffdd 	bl	80012a0 <chSysLockFromISR.lto_priv.0>
}
 80012e6:	bf00      	nop
 80012e8:	bd08      	pop	{r3, pc}
 80012ea:	bf00      	nop
 80012ec:	0000      	movs	r0, r0
	...

080012f0 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 80012f0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80012f2:	f7ff ffe5 	bl	80012c0 <chSysUnlockFromISR.lto_priv.0>
}
 80012f6:	bf00      	nop
 80012f8:	bd08      	pop	{r3, pc}
 80012fa:	bf00      	nop
 80012fc:	0000      	movs	r0, r0
	...

08001300 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8001300:	b500      	push	{lr}
 8001302:	b083      	sub	sp, #12
 8001304:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 8001306:	9801      	ldr	r0, [sp, #4]
 8001308:	f001 fa4a 	bl	80027a0 <chSysPolledDelayX>
}
 800130c:	bf00      	nop
 800130e:	b003      	add	sp, #12
 8001310:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001320 <osalThreadResumeI.lto_priv.1>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001320:	b500      	push	{lr}
 8001322:	b083      	sub	sp, #12
 8001324:	9001      	str	r0, [sp, #4]
 8001326:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8001328:	9900      	ldr	r1, [sp, #0]
 800132a:	9801      	ldr	r0, [sp, #4]
 800132c:	f002 fe58 	bl	8003fe0 <chThdResumeI>
}
 8001330:	bf00      	nop
 8001332:	b003      	add	sp, #12
 8001334:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001340 <adc_lld_vreg_on>:
/**
 * @brief   Enables the ADC voltage regulator.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {
 8001340:	b500      	push	{lr}
 8001342:	b083      	sub	sp, #12
 8001344:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR = 0;   /* See RM.*/
 8001346:	9b01      	ldr	r3, [sp, #4]
 8001348:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800134a:	2200      	movs	r2, #0
 800134c:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN;
 800134e:	9b01      	ldr	r3, [sp, #4]
 8001350:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001352:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8001356:	609a      	str	r2, [r3, #8]
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR = STM32_ADC_CR_ADVREGEN;
#endif
  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 8001358:	f44f 60c8 	mov.w	r0, #1600	@ 0x640
 800135c:	f7ff ffd0 	bl	8001300 <osalSysPolledDelayX>
}
 8001360:	bf00      	nop
 8001362:	b003      	add	sp, #12
 8001364:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001370 <adc_lld_calibrate>:
/**
 * @brief   Calibrates an ADC unit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_calibrate(ADCDriver *adcp) {
 8001370:	b500      	push	{lr}
 8001372:	b083      	sub	sp, #12
 8001374:	9001      	str	r0, [sp, #4]

  osalDbgAssert(adcp->adcm->CR == STM32_ADC_CR_ADVREGEN, "invalid register state");
 8001376:	9b01      	ldr	r3, [sp, #4]
 8001378:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800137a:	689b      	ldr	r3, [r3, #8]
 800137c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8001380:	bf14      	ite	ne
 8001382:	2301      	movne	r3, #1
 8001384:	2300      	moveq	r3, #0
 8001386:	b2db      	uxtb	r3, r3
 8001388:	2b00      	cmp	r3, #0
 800138a:	d002      	beq.n	8001392 <adc_lld_calibrate+0x22>
 800138c:	4817      	ldr	r0, [pc, #92]	@ (80013ec <adc_lld_calibrate+0x7c>)
 800138e:	f001 f9af 	bl	80026f0 <chSysHalt>

  /* Differential calibration for master ADC.*/
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCALDIF;
 8001392:	9b01      	ldr	r3, [sp, #4]
 8001394:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001396:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 800139a:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCALDIF | ADC_CR_ADCAL;
 800139c:	9b01      	ldr	r3, [sp, #4]
 800139e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013a0:	f04f 4250 	mov.w	r2, #3489660928	@ 0xd0000000
 80013a4:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 80013a6:	bf00      	nop
 80013a8:	9b01      	ldr	r3, [sp, #4]
 80013aa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013ac:	689b      	ldr	r3, [r3, #8]
 80013ae:	2b00      	cmp	r3, #0
 80013b0:	dbfa      	blt.n	80013a8 <adc_lld_calibrate+0x38>
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 80013b2:	f44f 60c8 	mov.w	r0, #1600	@ 0x640
 80013b6:	f7ff ffa3 	bl	8001300 <osalSysPolledDelayX>

  /* Single-ended calibration for master ADC.*/
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN;
 80013ba:	9b01      	ldr	r3, [sp, #4]
 80013bc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013be:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80013c2:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCAL;
 80013c4:	9b01      	ldr	r3, [sp, #4]
 80013c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013c8:	f04f 4210 	mov.w	r2, #2415919104	@ 0x90000000
 80013cc:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 80013ce:	bf00      	nop
 80013d0:	9b01      	ldr	r3, [sp, #4]
 80013d2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013d4:	689b      	ldr	r3, [r3, #8]
 80013d6:	2b00      	cmp	r3, #0
 80013d8:	dbfa      	blt.n	80013d0 <adc_lld_calibrate+0x60>
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 80013da:	f44f 60c8 	mov.w	r0, #1600	@ 0x640
 80013de:	f7ff ff8f 	bl	8001300 <osalSysPolledDelayX>
  while ((adcp->adcs->CR & ADC_CR_ADCAL) != 0)
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
#endif
}
 80013e2:	bf00      	nop
 80013e4:	b003      	add	sp, #12
 80013e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80013ea:	bf00      	nop
 80013ec:	08005144 	.word	0x08005144

080013f0 <adc_lld_analog_on>:
/**
 * @brief   Enables the ADC analog circuit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_analog_on(ADCDriver *adcp) {
 80013f0:	b082      	sub	sp, #8
 80013f2:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR |= ADC_CR_ADEN;
 80013f4:	9b01      	ldr	r3, [sp, #4]
 80013f6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013f8:	689a      	ldr	r2, [r3, #8]
 80013fa:	9b01      	ldr	r3, [sp, #4]
 80013fc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80013fe:	f042 0201 	orr.w	r2, r2, #1
 8001402:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRDY) == 0)
 8001404:	bf00      	nop
 8001406:	9b01      	ldr	r3, [sp, #4]
 8001408:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800140a:	681b      	ldr	r3, [r3, #0]
 800140c:	f003 0301 	and.w	r3, r3, #1
 8001410:	2b00      	cmp	r3, #0
 8001412:	d0f8      	beq.n	8001406 <adc_lld_analog_on+0x16>
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR |= ADC_CR_ADEN;
  while ((adcp->adcs->ISR & ADC_ISR_ADRDY) == 0)
    ;
#endif
}
 8001414:	bf00      	nop
 8001416:	bf00      	nop
 8001418:	b002      	add	sp, #8
 800141a:	4770      	bx	lr
 800141c:	0000      	movs	r0, r0
	...

08001420 <adc_lld_stop_adc>:
/**
 * @brief   Stops an ongoing conversion, if any.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_stop_adc(ADCDriver *adcp) {
 8001420:	b082      	sub	sp, #8
 8001422:	9001      	str	r0, [sp, #4]

  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8001424:	9b01      	ldr	r3, [sp, #4]
 8001426:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001428:	689b      	ldr	r3, [r3, #8]
 800142a:	f003 0304 	and.w	r3, r3, #4
 800142e:	2b00      	cmp	r3, #0
 8001430:	d013      	beq.n	800145a <adc_lld_stop_adc+0x3a>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8001432:	9b01      	ldr	r3, [sp, #4]
 8001434:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001436:	689a      	ldr	r2, [r3, #8]
 8001438:	9b01      	ldr	r3, [sp, #4]
 800143a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800143c:	f042 0210 	orr.w	r2, r2, #16
 8001440:	609a      	str	r2, [r3, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8001442:	bf00      	nop
 8001444:	9b01      	ldr	r3, [sp, #4]
 8001446:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001448:	689b      	ldr	r3, [r3, #8]
 800144a:	f003 0310 	and.w	r3, r3, #16
 800144e:	2b00      	cmp	r3, #0
 8001450:	d1f8      	bne.n	8001444 <adc_lld_stop_adc+0x24>
      ;
    adcp->adcm->IER = 0;
 8001452:	9b01      	ldr	r3, [sp, #4]
 8001454:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001456:	2200      	movs	r2, #0
 8001458:	605a      	str	r2, [r3, #4]
  }
}
 800145a:	bf00      	nop
 800145c:	b002      	add	sp, #8
 800145e:	4770      	bx	lr

08001460 <adc_lld_serve_dma_interrupt>:
 * @brief   ADC DMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001460:	b500      	push	{lr}
 8001462:	b083      	sub	sp, #12
 8001464:	9001      	str	r0, [sp, #4]
 8001466:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001468:	9b00      	ldr	r3, [sp, #0]
 800146a:	f003 0308 	and.w	r3, r3, #8
 800146e:	2b00      	cmp	r3, #0
 8001470:	d02d      	beq.n	80014ce <adc_lld_serve_dma_interrupt+0x6e>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8001472:	9801      	ldr	r0, [sp, #4]
 8001474:	f000 fb4c 	bl	8001b10 <adc_lld_stop_conversion>
 8001478:	9b01      	ldr	r3, [sp, #4]
 800147a:	691b      	ldr	r3, [r3, #16]
 800147c:	689b      	ldr	r3, [r3, #8]
 800147e:	2b00      	cmp	r3, #0
 8001480:	d013      	beq.n	80014aa <adc_lld_serve_dma_interrupt+0x4a>
 8001482:	9b01      	ldr	r3, [sp, #4]
 8001484:	2205      	movs	r2, #5
 8001486:	701a      	strb	r2, [r3, #0]
 8001488:	9b01      	ldr	r3, [sp, #4]
 800148a:	691b      	ldr	r3, [r3, #16]
 800148c:	689b      	ldr	r3, [r3, #8]
 800148e:	2101      	movs	r1, #1
 8001490:	9801      	ldr	r0, [sp, #4]
 8001492:	4798      	blx	r3
 8001494:	9b01      	ldr	r3, [sp, #4]
 8001496:	781b      	ldrb	r3, [r3, #0]
 8001498:	2b05      	cmp	r3, #5
 800149a:	d10c      	bne.n	80014b6 <adc_lld_serve_dma_interrupt+0x56>
 800149c:	9b01      	ldr	r3, [sp, #4]
 800149e:	2202      	movs	r2, #2
 80014a0:	701a      	strb	r2, [r3, #0]
 80014a2:	9b01      	ldr	r3, [sp, #4]
 80014a4:	2200      	movs	r2, #0
 80014a6:	611a      	str	r2, [r3, #16]
 80014a8:	e005      	b.n	80014b6 <adc_lld_serve_dma_interrupt+0x56>
 80014aa:	9b01      	ldr	r3, [sp, #4]
 80014ac:	2202      	movs	r2, #2
 80014ae:	701a      	strb	r2, [r3, #0]
 80014b0:	9b01      	ldr	r3, [sp, #4]
 80014b2:	2200      	movs	r2, #0
 80014b4:	611a      	str	r2, [r3, #16]
 80014b6:	f7ff ff13 	bl	80012e0 <osalSysLockFromISR.lto_priv.0>
 80014ba:	9b01      	ldr	r3, [sp, #4]
 80014bc:	3314      	adds	r3, #20
 80014be:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 80014c2:	4618      	mov	r0, r3
 80014c4:	f7ff ff2c 	bl	8001320 <osalThreadResumeI.lto_priv.1>
 80014c8:	f7ff ff12 	bl	80012f0 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 80014cc:	e05d      	b.n	800158a <adc_lld_serve_dma_interrupt+0x12a>
    if (adcp->grpp != NULL) {
 80014ce:	9b01      	ldr	r3, [sp, #4]
 80014d0:	691b      	ldr	r3, [r3, #16]
 80014d2:	2b00      	cmp	r3, #0
 80014d4:	d059      	beq.n	800158a <adc_lld_serve_dma_interrupt+0x12a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80014d6:	9b00      	ldr	r3, [sp, #0]
 80014d8:	f003 0302 	and.w	r3, r3, #2
 80014dc:	2b00      	cmp	r3, #0
 80014de:	d045      	beq.n	800156c <adc_lld_serve_dma_interrupt+0x10c>
        _adc_isr_full_code(adcp);
 80014e0:	9b01      	ldr	r3, [sp, #4]
 80014e2:	691b      	ldr	r3, [r3, #16]
 80014e4:	781b      	ldrb	r3, [r3, #0]
 80014e6:	2b00      	cmp	r3, #0
 80014e8:	d014      	beq.n	8001514 <adc_lld_serve_dma_interrupt+0xb4>
 80014ea:	9b01      	ldr	r3, [sp, #4]
 80014ec:	691b      	ldr	r3, [r3, #16]
 80014ee:	685b      	ldr	r3, [r3, #4]
 80014f0:	2b00      	cmp	r3, #0
 80014f2:	d04a      	beq.n	800158a <adc_lld_serve_dma_interrupt+0x12a>
 80014f4:	9b01      	ldr	r3, [sp, #4]
 80014f6:	2204      	movs	r2, #4
 80014f8:	701a      	strb	r2, [r3, #0]
 80014fa:	9b01      	ldr	r3, [sp, #4]
 80014fc:	691b      	ldr	r3, [r3, #16]
 80014fe:	685b      	ldr	r3, [r3, #4]
 8001500:	9801      	ldr	r0, [sp, #4]
 8001502:	4798      	blx	r3
 8001504:	9b01      	ldr	r3, [sp, #4]
 8001506:	781b      	ldrb	r3, [r3, #0]
 8001508:	2b04      	cmp	r3, #4
 800150a:	d13e      	bne.n	800158a <adc_lld_serve_dma_interrupt+0x12a>
 800150c:	9b01      	ldr	r3, [sp, #4]
 800150e:	2203      	movs	r2, #3
 8001510:	701a      	strb	r2, [r3, #0]
}
 8001512:	e03a      	b.n	800158a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_full_code(adcp);
 8001514:	9801      	ldr	r0, [sp, #4]
 8001516:	f000 fafb 	bl	8001b10 <adc_lld_stop_conversion>
 800151a:	9b01      	ldr	r3, [sp, #4]
 800151c:	691b      	ldr	r3, [r3, #16]
 800151e:	685b      	ldr	r3, [r3, #4]
 8001520:	2b00      	cmp	r3, #0
 8001522:	d012      	beq.n	800154a <adc_lld_serve_dma_interrupt+0xea>
 8001524:	9b01      	ldr	r3, [sp, #4]
 8001526:	2204      	movs	r2, #4
 8001528:	701a      	strb	r2, [r3, #0]
 800152a:	9b01      	ldr	r3, [sp, #4]
 800152c:	691b      	ldr	r3, [r3, #16]
 800152e:	685b      	ldr	r3, [r3, #4]
 8001530:	9801      	ldr	r0, [sp, #4]
 8001532:	4798      	blx	r3
 8001534:	9b01      	ldr	r3, [sp, #4]
 8001536:	781b      	ldrb	r3, [r3, #0]
 8001538:	2b04      	cmp	r3, #4
 800153a:	d10c      	bne.n	8001556 <adc_lld_serve_dma_interrupt+0xf6>
 800153c:	9b01      	ldr	r3, [sp, #4]
 800153e:	2202      	movs	r2, #2
 8001540:	701a      	strb	r2, [r3, #0]
 8001542:	9b01      	ldr	r3, [sp, #4]
 8001544:	2200      	movs	r2, #0
 8001546:	611a      	str	r2, [r3, #16]
 8001548:	e005      	b.n	8001556 <adc_lld_serve_dma_interrupt+0xf6>
 800154a:	9b01      	ldr	r3, [sp, #4]
 800154c:	2202      	movs	r2, #2
 800154e:	701a      	strb	r2, [r3, #0]
 8001550:	9b01      	ldr	r3, [sp, #4]
 8001552:	2200      	movs	r2, #0
 8001554:	611a      	str	r2, [r3, #16]
 8001556:	f7ff fec3 	bl	80012e0 <osalSysLockFromISR.lto_priv.0>
 800155a:	9b01      	ldr	r3, [sp, #4]
 800155c:	3314      	adds	r3, #20
 800155e:	2100      	movs	r1, #0
 8001560:	4618      	mov	r0, r3
 8001562:	f7ff fedd 	bl	8001320 <osalThreadResumeI.lto_priv.1>
 8001566:	f7ff fec3 	bl	80012f0 <osalSysUnlockFromISR.lto_priv.0>
}
 800156a:	e00e      	b.n	800158a <adc_lld_serve_dma_interrupt+0x12a>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 800156c:	9b00      	ldr	r3, [sp, #0]
 800156e:	f003 0304 	and.w	r3, r3, #4
 8001572:	2b00      	cmp	r3, #0
 8001574:	d009      	beq.n	800158a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_half_code(adcp);
 8001576:	9b01      	ldr	r3, [sp, #4]
 8001578:	691b      	ldr	r3, [r3, #16]
 800157a:	685b      	ldr	r3, [r3, #4]
 800157c:	2b00      	cmp	r3, #0
 800157e:	d004      	beq.n	800158a <adc_lld_serve_dma_interrupt+0x12a>
 8001580:	9b01      	ldr	r3, [sp, #4]
 8001582:	691b      	ldr	r3, [r3, #16]
 8001584:	685b      	ldr	r3, [r3, #4]
 8001586:	9801      	ldr	r0, [sp, #4]
 8001588:	4798      	blx	r3
}
 800158a:	bf00      	nop
 800158c:	b003      	add	sp, #12
 800158e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001592:	bf00      	nop
	...

080015a0 <adc_lld_serve_interrupt>:
 * @brief   ADC IRQ service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] isr       content of the ISR register
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 80015a0:	b500      	push	{lr}
 80015a2:	b085      	sub	sp, #20
 80015a4:	9001      	str	r0, [sp, #4]
 80015a6:	9100      	str	r1, [sp, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 80015a8:	9b01      	ldr	r3, [sp, #4]
 80015aa:	691b      	ldr	r3, [r3, #16]
 80015ac:	2b00      	cmp	r3, #0
 80015ae:	d059      	beq.n	8001664 <adc_lld_serve_interrupt+0xc4>
    adcerror_t emask = 0U;
 80015b0:	2300      	movs	r3, #0
 80015b2:	9303      	str	r3, [sp, #12]

    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the state is checked too.*/
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 80015b4:	9b00      	ldr	r3, [sp, #0]
 80015b6:	f003 0310 	and.w	r3, r3, #16
 80015ba:	2b00      	cmp	r3, #0
 80015bc:	d007      	beq.n	80015ce <adc_lld_serve_interrupt+0x2e>
 80015be:	9b01      	ldr	r3, [sp, #4]
 80015c0:	781b      	ldrb	r3, [r3, #0]
 80015c2:	2b03      	cmp	r3, #3
 80015c4:	d103      	bne.n	80015ce <adc_lld_serve_interrupt+0x2e>
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
 80015c6:	9b03      	ldr	r3, [sp, #12]
 80015c8:	f043 0302 	orr.w	r3, r3, #2
 80015cc:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD1) {
 80015ce:	9b00      	ldr	r3, [sp, #0]
 80015d0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80015d4:	2b00      	cmp	r3, #0
 80015d6:	d003      	beq.n	80015e0 <adc_lld_serve_interrupt+0x40>
      /* Analog watchdog 1 error.*/
      emask |= ADC_ERR_AWD1;
 80015d8:	9b03      	ldr	r3, [sp, #12]
 80015da:	f043 0304 	orr.w	r3, r3, #4
 80015de:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD2) {
 80015e0:	9b00      	ldr	r3, [sp, #0]
 80015e2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80015e6:	2b00      	cmp	r3, #0
 80015e8:	d003      	beq.n	80015f2 <adc_lld_serve_interrupt+0x52>
      /* Analog watchdog 2 error.*/
      emask |= ADC_ERR_AWD2;
 80015ea:	9b03      	ldr	r3, [sp, #12]
 80015ec:	f043 0308 	orr.w	r3, r3, #8
 80015f0:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD3) {
 80015f2:	9b00      	ldr	r3, [sp, #0]
 80015f4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80015f8:	2b00      	cmp	r3, #0
 80015fa:	d003      	beq.n	8001604 <adc_lld_serve_interrupt+0x64>
      /* Analog watchdog 3 error.*/
      emask |= ADC_ERR_AWD3;
 80015fc:	9b03      	ldr	r3, [sp, #12]
 80015fe:	f043 0310 	orr.w	r3, r3, #16
 8001602:	9303      	str	r3, [sp, #12]
    }
    if (emask != 0U) {
 8001604:	9b03      	ldr	r3, [sp, #12]
 8001606:	2b00      	cmp	r3, #0
 8001608:	d02c      	beq.n	8001664 <adc_lld_serve_interrupt+0xc4>
      _adc_isr_error_code(adcp, emask);
 800160a:	9801      	ldr	r0, [sp, #4]
 800160c:	f000 fa80 	bl	8001b10 <adc_lld_stop_conversion>
 8001610:	9b01      	ldr	r3, [sp, #4]
 8001612:	691b      	ldr	r3, [r3, #16]
 8001614:	689b      	ldr	r3, [r3, #8]
 8001616:	2b00      	cmp	r3, #0
 8001618:	d013      	beq.n	8001642 <adc_lld_serve_interrupt+0xa2>
 800161a:	9b01      	ldr	r3, [sp, #4]
 800161c:	2205      	movs	r2, #5
 800161e:	701a      	strb	r2, [r3, #0]
 8001620:	9b01      	ldr	r3, [sp, #4]
 8001622:	691b      	ldr	r3, [r3, #16]
 8001624:	689b      	ldr	r3, [r3, #8]
 8001626:	9903      	ldr	r1, [sp, #12]
 8001628:	9801      	ldr	r0, [sp, #4]
 800162a:	4798      	blx	r3
 800162c:	9b01      	ldr	r3, [sp, #4]
 800162e:	781b      	ldrb	r3, [r3, #0]
 8001630:	2b05      	cmp	r3, #5
 8001632:	d10c      	bne.n	800164e <adc_lld_serve_interrupt+0xae>
 8001634:	9b01      	ldr	r3, [sp, #4]
 8001636:	2202      	movs	r2, #2
 8001638:	701a      	strb	r2, [r3, #0]
 800163a:	9b01      	ldr	r3, [sp, #4]
 800163c:	2200      	movs	r2, #0
 800163e:	611a      	str	r2, [r3, #16]
 8001640:	e005      	b.n	800164e <adc_lld_serve_interrupt+0xae>
 8001642:	9b01      	ldr	r3, [sp, #4]
 8001644:	2202      	movs	r2, #2
 8001646:	701a      	strb	r2, [r3, #0]
 8001648:	9b01      	ldr	r3, [sp, #4]
 800164a:	2200      	movs	r2, #0
 800164c:	611a      	str	r2, [r3, #16]
 800164e:	f7ff fe47 	bl	80012e0 <osalSysLockFromISR.lto_priv.0>
 8001652:	9b01      	ldr	r3, [sp, #4]
 8001654:	3314      	adds	r3, #20
 8001656:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 800165a:	4618      	mov	r0, r3
 800165c:	f7ff fe60 	bl	8001320 <osalThreadResumeI.lto_priv.1>
 8001660:	f7ff fe46 	bl	80012f0 <osalSysUnlockFromISR.lto_priv.0>
    }
  }
}
 8001664:	bf00      	nop
 8001666:	b005      	add	sp, #20
 8001668:	f85d fb04 	ldr.w	pc, [sp], #4
 800166c:	0000      	movs	r0, r0
	...

08001670 <Vector88>:
/**
 * @brief   ADC1/ADC2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8001670:	b500      	push	{lr}
 8001672:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 8001674:	f001 f964 	bl	8002940 <__dbg_check_enter_isr>
  adc_lld_serve_interrupt(&ADCD1, isr);

#else /* !STM32_ADC_DUAL_MODE */

#if STM32_ADC_USE_ADC1
  isr  = ADC1->ISR;
 8001678:	4b0d      	ldr	r3, [pc, #52]	@ (80016b0 <Vector88+0x40>)
 800167a:	681b      	ldr	r3, [r3, #0]
 800167c:	9301      	str	r3, [sp, #4]
  ADC1->ISR = isr;
 800167e:	4a0c      	ldr	r2, [pc, #48]	@ (80016b0 <Vector88+0x40>)
 8001680:	9b01      	ldr	r3, [sp, #4]
 8001682:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD1, isr);
 8001684:	9901      	ldr	r1, [sp, #4]
 8001686:	480b      	ldr	r0, [pc, #44]	@ (80016b4 <Vector88+0x44>)
 8001688:	f7ff ff8a 	bl	80015a0 <adc_lld_serve_interrupt>
#endif

#if STM32_ADC_USE_ADC2
  isr  = ADC2->ISR;
 800168c:	4b0a      	ldr	r3, [pc, #40]	@ (80016b8 <Vector88+0x48>)
 800168e:	681b      	ldr	r3, [r3, #0]
 8001690:	9301      	str	r3, [sp, #4]
  ADC2->ISR = isr;
 8001692:	4a09      	ldr	r2, [pc, #36]	@ (80016b8 <Vector88+0x48>)
 8001694:	9b01      	ldr	r3, [sp, #4]
 8001696:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC2_IRQ_HOOK)
  STM32_ADC_ADC2_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD2, isr);
 8001698:	9901      	ldr	r1, [sp, #4]
 800169a:	4808      	ldr	r0, [pc, #32]	@ (80016bc <Vector88+0x4c>)
 800169c:	f7ff ff80 	bl	80015a0 <adc_lld_serve_interrupt>
#endif

#endif /* !STM32_ADC_DUAL_MODE */

  OSAL_IRQ_EPILOGUE();
 80016a0:	f001 f986 	bl	80029b0 <__dbg_check_leave_isr>
 80016a4:	f003 fb8c 	bl	8004dc0 <__port_irq_epilogue>
}
 80016a8:	bf00      	nop
 80016aa:	b003      	add	sp, #12
 80016ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80016b0:	50040000 	.word	0x50040000
 80016b4:	20000800 	.word	0x20000800
 80016b8:	50040100 	.word	0x50040100
 80016bc:	20000838 	.word	0x20000838

080016c0 <VectorFC>:
/**
 * @brief   ADC3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC3_HANDLER) {
 80016c0:	b500      	push	{lr}
 80016c2:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 80016c4:	f001 f93c 	bl	8002940 <__dbg_check_enter_isr>

  isr  = ADC3->ISR;
 80016c8:	4b08      	ldr	r3, [pc, #32]	@ (80016ec <VectorFC+0x2c>)
 80016ca:	681b      	ldr	r3, [r3, #0]
 80016cc:	9301      	str	r3, [sp, #4]
  ADC3->ISR = isr;
 80016ce:	4a07      	ldr	r2, [pc, #28]	@ (80016ec <VectorFC+0x2c>)
 80016d0:	9b01      	ldr	r3, [sp, #4]
 80016d2:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC3_IRQ_HOOK)
  STM32_ADC_ADC3_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD3, isr);
 80016d4:	9901      	ldr	r1, [sp, #4]
 80016d6:	4806      	ldr	r0, [pc, #24]	@ (80016f0 <VectorFC+0x30>)
 80016d8:	f7ff ff62 	bl	80015a0 <adc_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80016dc:	f001 f968 	bl	80029b0 <__dbg_check_leave_isr>
 80016e0:	f003 fb6e 	bl	8004dc0 <__port_irq_epilogue>
}
 80016e4:	bf00      	nop
 80016e6:	b003      	add	sp, #12
 80016e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80016ec:	50040200 	.word	0x50040200
 80016f0:	20000870 	.word	0x20000870
	...

08001700 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8001700:	b508      	push	{r3, lr}

  clkmask = 0;
 8001702:	4b35      	ldr	r3, [pc, #212]	@ (80017d8 <adc_lld_init+0xd8>)
 8001704:	2200      	movs	r2, #0
 8001706:	601a      	str	r2, [r3, #0]

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8001708:	4834      	ldr	r0, [pc, #208]	@ (80017dc <adc_lld_init+0xdc>)
 800170a:	f7fe ff69 	bl	80005e0 <adcObjectInit>
#if defined(ADC1_2_COMMON)
  ADCD1.adcc = ADC1_2_COMMON;
#elif defined(ADC12_COMMON)
  ADCD1.adcc = ADC12_COMMON;
#elif defined(ADC123_COMMON)
  ADCD1.adcc = ADC123_COMMON;
 800170e:	4b33      	ldr	r3, [pc, #204]	@ (80017dc <adc_lld_init+0xdc>)
 8001710:	4a33      	ldr	r2, [pc, #204]	@ (80017e0 <adc_lld_init+0xe0>)
 8001712:	62da      	str	r2, [r3, #44]	@ 0x2c
#else
  ADCD1.adcc = ADC1_COMMON;
#endif
  ADCD1.adcm    = ADC1;
 8001714:	4b31      	ldr	r3, [pc, #196]	@ (80017dc <adc_lld_init+0xdc>)
 8001716:	4a33      	ldr	r2, [pc, #204]	@ (80017e4 <adc_lld_init+0xe4>)
 8001718:	629a      	str	r2, [r3, #40]	@ 0x28
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs    = ADC2;
#endif
  ADCD1.dmastp  = NULL;
 800171a:	4b30      	ldr	r3, [pc, #192]	@ (80017dc <adc_lld_init+0xdc>)
 800171c:	2200      	movs	r2, #0
 800171e:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD1.dmamode = ADC_DMA_SIZE |
 8001720:	4b2e      	ldr	r3, [pc, #184]	@ (80017dc <adc_lld_init+0xdc>)
 8001722:	f242 528a 	movw	r2, #9610	@ 0x258a
 8001726:	635a      	str	r2, [r3, #52]	@ 0x34
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
  /* Driver initialization.*/
  adcObjectInit(&ADCD2);
 8001728:	482f      	ldr	r0, [pc, #188]	@ (80017e8 <adc_lld_init+0xe8>)
 800172a:	f7fe ff59 	bl	80005e0 <adcObjectInit>
#if defined(ADC1_2_COMMON)
  ADCD2.adcc = ADC1_2_COMMON;
#elif defined(ADC12_COMMON)
  ADCD2.adcc = ADC12_COMMON;
#elif defined(ADC123_COMMON)
  ADCD2.adcc = ADC123_COMMON;
 800172e:	4b2e      	ldr	r3, [pc, #184]	@ (80017e8 <adc_lld_init+0xe8>)
 8001730:	4a2b      	ldr	r2, [pc, #172]	@ (80017e0 <adc_lld_init+0xe0>)
 8001732:	62da      	str	r2, [r3, #44]	@ 0x2c
#endif
  ADCD2.adcm    = ADC2;
 8001734:	4b2c      	ldr	r3, [pc, #176]	@ (80017e8 <adc_lld_init+0xe8>)
 8001736:	4a2d      	ldr	r2, [pc, #180]	@ (80017ec <adc_lld_init+0xec>)
 8001738:	629a      	str	r2, [r3, #40]	@ 0x28
  ADCD2.dmastp  = NULL;
 800173a:	4b2b      	ldr	r3, [pc, #172]	@ (80017e8 <adc_lld_init+0xe8>)
 800173c:	2200      	movs	r2, #0
 800173e:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD2.dmamode = ADC_DMA_SIZE |
 8001740:	4b29      	ldr	r3, [pc, #164]	@ (80017e8 <adc_lld_init+0xe8>)
 8001742:	f242 528a 	movw	r2, #9610	@ 0x258a
 8001746:	635a      	str	r2, [r3, #52]	@ 0x34
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
 8001748:	4829      	ldr	r0, [pc, #164]	@ (80017f0 <adc_lld_init+0xf0>)
 800174a:	f7fe ff49 	bl	80005e0 <adcObjectInit>
#if defined(ADC3_4_COMMON)
  ADCD3.adcc = ADC3_4_COMMON;
#elif defined(ADC345_COMMON)
  ADCD3.adcc = ADC345_COMMON;
#elif defined(ADC123_COMMON)
  ADCD3.adcc = ADC123_COMMON;
 800174e:	4b28      	ldr	r3, [pc, #160]	@ (80017f0 <adc_lld_init+0xf0>)
 8001750:	4a23      	ldr	r2, [pc, #140]	@ (80017e0 <adc_lld_init+0xe0>)
 8001752:	62da      	str	r2, [r3, #44]	@ 0x2c
#else
  ADCD3.adcc = ADC3_COMMON;
#endif
  ADCD3.adcm    = ADC3;
 8001754:	4b26      	ldr	r3, [pc, #152]	@ (80017f0 <adc_lld_init+0xf0>)
 8001756:	4a27      	ldr	r2, [pc, #156]	@ (80017f4 <adc_lld_init+0xf4>)
 8001758:	629a      	str	r2, [r3, #40]	@ 0x28
#if STM32_ADC_DUAL_MODE
  ADCD3.adcs    = ADC4;
#endif
  ADCD3.dmastp  = NULL;
 800175a:	4b25      	ldr	r3, [pc, #148]	@ (80017f0 <adc_lld_init+0xf0>)
 800175c:	2200      	movs	r2, #0
 800175e:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD3.dmamode = ADC_DMA_SIZE |
 8001760:	4b23      	ldr	r3, [pc, #140]	@ (80017f0 <adc_lld_init+0xf0>)
 8001762:	f242 528a 	movw	r2, #9610	@ 0x258a
 8001766:	635a      	str	r2, [r3, #52]	@ 0x34
  /* IRQs setup.*/
#if STM32_ADC_USE_ADC1 || STM32_ADC_USE_ADC2
#if defined(STM32_ADC_ADC1_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC1_IRQ_PRIORITY);
#elif defined(STM32_ADC_ADC12_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 8001768:	2105      	movs	r1, #5
 800176a:	2012      	movs	r0, #18
 800176c:	f7ff fa18 	bl	8000ba0 <nvicEnableVector>
#endif
#endif
#if STM32_ADC_USE_ADC3
  nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
 8001770:	2105      	movs	r1, #5
 8001772:	202f      	movs	r0, #47	@ 0x2f
 8001774:	f7ff fa14 	bl	8000ba0 <nvicEnableVector>
  rccDisableADC34();
#endif
#endif

#if defined(STM32L4XX) || defined(STM32L4XXP)
  rccResetADC123();
 8001778:	4b1f      	ldr	r3, [pc, #124]	@ (80017f8 <adc_lld_init+0xf8>)
 800177a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800177c:	4a1e      	ldr	r2, [pc, #120]	@ (80017f8 <adc_lld_init+0xf8>)
 800177e:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8001782:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001784:	4b1c      	ldr	r3, [pc, #112]	@ (80017f8 <adc_lld_init+0xf8>)
 8001786:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001788:	4a1b      	ldr	r2, [pc, #108]	@ (80017f8 <adc_lld_init+0xf8>)
 800178a:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 800178e:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001790:	4b19      	ldr	r3, [pc, #100]	@ (80017f8 <adc_lld_init+0xf8>)
 8001792:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableADC123(true);
 8001794:	4b18      	ldr	r3, [pc, #96]	@ (80017f8 <adc_lld_init+0xf8>)
 8001796:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001798:	4a17      	ldr	r2, [pc, #92]	@ (80017f8 <adc_lld_init+0xf8>)
 800179a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800179e:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80017a0:	4b15      	ldr	r3, [pc, #84]	@ (80017f8 <adc_lld_init+0xf8>)
 80017a2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80017a4:	4a14      	ldr	r2, [pc, #80]	@ (80017f8 <adc_lld_init+0xf8>)
 80017a6:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80017aa:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80017ac:	4b12      	ldr	r3, [pc, #72]	@ (80017f8 <adc_lld_init+0xf8>)
 80017ae:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#if defined(ADC1_2_COMMON)
  ADC1_2_COMMON->CCR = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
#elif defined(ADC12_COMMON)
  ADC12_COMMON->CCR = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
#elif defined(ADC123_COMMON)
  ADC123_COMMON->CCR = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
 80017b0:	4b0b      	ldr	r3, [pc, #44]	@ (80017e0 <adc_lld_init+0xe0>)
 80017b2:	f44f 22a0 	mov.w	r2, #327680	@ 0x50000
 80017b6:	609a      	str	r2, [r3, #8]
#else
  ADC1_COMMON->CCR   = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
#endif
  rccDisableADC123();
 80017b8:	4b0f      	ldr	r3, [pc, #60]	@ (80017f8 <adc_lld_init+0xf8>)
 80017ba:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80017bc:	4a0e      	ldr	r2, [pc, #56]	@ (80017f8 <adc_lld_init+0xf8>)
 80017be:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80017c2:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80017c4:	4b0c      	ldr	r3, [pc, #48]	@ (80017f8 <adc_lld_init+0xf8>)
 80017c6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80017c8:	4a0b      	ldr	r2, [pc, #44]	@ (80017f8 <adc_lld_init+0xf8>)
 80017ca:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80017ce:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80017d0:	4b09      	ldr	r3, [pc, #36]	@ (80017f8 <adc_lld_init+0xf8>)
 80017d2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
  rccEnableADC1(true);
  ADC1_COMMON->CCR = STM32_ADC_ADC1_PRESC | STM32_ADC_ADC1_CLOCK_MODE;
  rccDisableADC1();
#endif
#endif
}
 80017d4:	bf00      	nop
 80017d6:	bd08      	pop	{r3, pc}
 80017d8:	200008a8 	.word	0x200008a8
 80017dc:	20000800 	.word	0x20000800
 80017e0:	50040300 	.word	0x50040300
 80017e4:	50040000 	.word	0x50040000
 80017e8:	20000838 	.word	0x20000838
 80017ec:	50040100 	.word	0x50040100
 80017f0:	20000870 	.word	0x20000870
 80017f4:	50040200 	.word	0x50040200
 80017f8:	40021000 	.word	0x40021000
 80017fc:	00000000 	.word	0x00000000

08001800 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8001800:	b500      	push	{lr}
 8001802:	b083      	sub	sp, #12
 8001804:	9001      	str	r0, [sp, #4]

  /* Handling the default configuration.*/
  if (adcp->config == NULL) {
 8001806:	9b01      	ldr	r3, [sp, #4]
 8001808:	685b      	ldr	r3, [r3, #4]
 800180a:	2b00      	cmp	r3, #0
 800180c:	d102      	bne.n	8001814 <adc_lld_start+0x14>
    adcp->config = &default_config;
 800180e:	9b01      	ldr	r3, [sp, #4]
 8001810:	4a54      	ldr	r2, [pc, #336]	@ (8001964 <adc_lld_start+0x164>)
 8001812:	605a      	str	r2, [r3, #4]
  }

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8001814:	9b01      	ldr	r3, [sp, #4]
 8001816:	781b      	ldrb	r3, [r3, #0]
 8001818:	2b01      	cmp	r3, #1
 800181a:	f040 809f 	bne.w	800195c <adc_lld_start+0x15c>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800181e:	9b01      	ldr	r3, [sp, #4]
 8001820:	4a51      	ldr	r2, [pc, #324]	@ (8001968 <adc_lld_start+0x168>)
 8001822:	4293      	cmp	r3, r2
 8001824:	d128      	bne.n	8001878 <adc_lld_start+0x78>

      osalDbgAssert(STM32_ADC1_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 8001826:	9b01      	ldr	r3, [sp, #4]
 8001828:	4a50      	ldr	r2, [pc, #320]	@ (800196c <adc_lld_start+0x16c>)
 800182a:	2105      	movs	r1, #5
 800182c:	2000      	movs	r0, #0
 800182e:	f000 fac7 	bl	8001dc0 <dmaStreamAllocI>
 8001832:	4602      	mov	r2, r0
 8001834:	9b01      	ldr	r3, [sp, #4]
 8001836:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8001838:	9b01      	ldr	r3, [sp, #4]
 800183a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800183c:	2b00      	cmp	r3, #0
 800183e:	bf0c      	ite	eq
 8001840:	2301      	moveq	r3, #1
 8001842:	2300      	movne	r3, #0
 8001844:	b2db      	uxtb	r3, r3
 8001846:	2b00      	cmp	r3, #0
 8001848:	d002      	beq.n	8001850 <adc_lld_start+0x50>
 800184a:	4849      	ldr	r0, [pc, #292]	@ (8001970 <adc_lld_start+0x170>)
 800184c:	f000 ff50 	bl	80026f0 <chSysHalt>

      clkmask |= (1 << 0);
 8001850:	4b48      	ldr	r3, [pc, #288]	@ (8001974 <adc_lld_start+0x174>)
 8001852:	681b      	ldr	r3, [r3, #0]
 8001854:	f043 0301 	orr.w	r3, r3, #1
 8001858:	4a46      	ldr	r2, [pc, #280]	@ (8001974 <adc_lld_start+0x174>)
 800185a:	6013      	str	r3, [r2, #0]
#if defined(STM32F3XX) || defined(STM32G4XX)
      rccEnableADC12(true);
#endif
#if defined(STM32L4XX) || defined(STM32L4XXP)
      rccEnableADC123(true);
 800185c:	4b46      	ldr	r3, [pc, #280]	@ (8001978 <adc_lld_start+0x178>)
 800185e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001860:	4a45      	ldr	r2, [pc, #276]	@ (8001978 <adc_lld_start+0x178>)
 8001862:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8001866:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8001868:	4b43      	ldr	r3, [pc, #268]	@ (8001978 <adc_lld_start+0x178>)
 800186a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800186c:	4a42      	ldr	r2, [pc, #264]	@ (8001978 <adc_lld_start+0x178>)
 800186e:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8001872:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8001874:	4b40      	ldr	r3, [pc, #256]	@ (8001978 <adc_lld_start+0x178>)
 8001876:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
    }
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
    if (&ADCD2 == adcp) {
 8001878:	9b01      	ldr	r3, [sp, #4]
 800187a:	4a40      	ldr	r2, [pc, #256]	@ (800197c <adc_lld_start+0x17c>)
 800187c:	4293      	cmp	r3, r2
 800187e:	d128      	bne.n	80018d2 <adc_lld_start+0xd2>

      osalDbgAssert(STM32_ADC2_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC2_DMA_STREAM,
 8001880:	9b01      	ldr	r3, [sp, #4]
 8001882:	4a3a      	ldr	r2, [pc, #232]	@ (800196c <adc_lld_start+0x16c>)
 8001884:	2105      	movs	r1, #5
 8001886:	2001      	movs	r0, #1
 8001888:	f000 fa9a 	bl	8001dc0 <dmaStreamAllocI>
 800188c:	4602      	mov	r2, r0
 800188e:	9b01      	ldr	r3, [sp, #4]
 8001890:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC2_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8001892:	9b01      	ldr	r3, [sp, #4]
 8001894:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001896:	2b00      	cmp	r3, #0
 8001898:	bf0c      	ite	eq
 800189a:	2301      	moveq	r3, #1
 800189c:	2300      	movne	r3, #0
 800189e:	b2db      	uxtb	r3, r3
 80018a0:	2b00      	cmp	r3, #0
 80018a2:	d002      	beq.n	80018aa <adc_lld_start+0xaa>
 80018a4:	4832      	ldr	r0, [pc, #200]	@ (8001970 <adc_lld_start+0x170>)
 80018a6:	f000 ff23 	bl	80026f0 <chSysHalt>

      clkmask |= (1 << 1);
 80018aa:	4b32      	ldr	r3, [pc, #200]	@ (8001974 <adc_lld_start+0x174>)
 80018ac:	681b      	ldr	r3, [r3, #0]
 80018ae:	f043 0302 	orr.w	r3, r3, #2
 80018b2:	4a30      	ldr	r2, [pc, #192]	@ (8001974 <adc_lld_start+0x174>)
 80018b4:	6013      	str	r3, [r2, #0]
#if defined(STM32F3XX) || defined(STM32G4XX)
      rccEnableADC12(true);
#endif
#if defined(STM32L4XX) || defined(STM32L4XXP)
      rccEnableADC123(true);
 80018b6:	4b30      	ldr	r3, [pc, #192]	@ (8001978 <adc_lld_start+0x178>)
 80018b8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80018ba:	4a2f      	ldr	r2, [pc, #188]	@ (8001978 <adc_lld_start+0x178>)
 80018bc:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80018c0:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80018c2:	4b2d      	ldr	r3, [pc, #180]	@ (8001978 <adc_lld_start+0x178>)
 80018c4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80018c6:	4a2c      	ldr	r2, [pc, #176]	@ (8001978 <adc_lld_start+0x178>)
 80018c8:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80018cc:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80018ce:	4b2a      	ldr	r3, [pc, #168]	@ (8001978 <adc_lld_start+0x178>)
 80018d0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
    }
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
    if (&ADCD3 == adcp) {
 80018d2:	9b01      	ldr	r3, [sp, #4]
 80018d4:	4a2a      	ldr	r2, [pc, #168]	@ (8001980 <adc_lld_start+0x180>)
 80018d6:	4293      	cmp	r3, r2
 80018d8:	d128      	bne.n	800192c <adc_lld_start+0x12c>

      osalDbgAssert(STM32_ADC3_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC3_DMA_STREAM,
 80018da:	9b01      	ldr	r3, [sp, #4]
 80018dc:	4a23      	ldr	r2, [pc, #140]	@ (800196c <adc_lld_start+0x16c>)
 80018de:	2105      	movs	r1, #5
 80018e0:	2002      	movs	r0, #2
 80018e2:	f000 fa6d 	bl	8001dc0 <dmaStreamAllocI>
 80018e6:	4602      	mov	r2, r0
 80018e8:	9b01      	ldr	r3, [sp, #4]
 80018ea:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC3_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 80018ec:	9b01      	ldr	r3, [sp, #4]
 80018ee:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80018f0:	2b00      	cmp	r3, #0
 80018f2:	bf0c      	ite	eq
 80018f4:	2301      	moveq	r3, #1
 80018f6:	2300      	movne	r3, #0
 80018f8:	b2db      	uxtb	r3, r3
 80018fa:	2b00      	cmp	r3, #0
 80018fc:	d002      	beq.n	8001904 <adc_lld_start+0x104>
 80018fe:	481c      	ldr	r0, [pc, #112]	@ (8001970 <adc_lld_start+0x170>)
 8001900:	f000 fef6 	bl	80026f0 <chSysHalt>

      clkmask |= (1 << 2);
 8001904:	4b1b      	ldr	r3, [pc, #108]	@ (8001974 <adc_lld_start+0x174>)
 8001906:	681b      	ldr	r3, [r3, #0]
 8001908:	f043 0304 	orr.w	r3, r3, #4
 800190c:	4a19      	ldr	r2, [pc, #100]	@ (8001974 <adc_lld_start+0x174>)
 800190e:	6013      	str	r3, [r2, #0]
#if defined(STM32F3XX)
      rccEnableADC34(true);
#endif
#if defined(STM32L4XX) || defined(STM32L4XXP)
      rccEnableADC123(true);
 8001910:	4b19      	ldr	r3, [pc, #100]	@ (8001978 <adc_lld_start+0x178>)
 8001912:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001914:	4a18      	ldr	r2, [pc, #96]	@ (8001978 <adc_lld_start+0x178>)
 8001916:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800191a:	64d3      	str	r3, [r2, #76]	@ 0x4c
 800191c:	4b16      	ldr	r3, [pc, #88]	@ (8001978 <adc_lld_start+0x178>)
 800191e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8001920:	4a15      	ldr	r2, [pc, #84]	@ (8001978 <adc_lld_start+0x178>)
 8001922:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8001926:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8001928:	4b13      	ldr	r3, [pc, #76]	@ (8001978 <adc_lld_start+0x178>)
 800192a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c

    /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcc->CDR);
#else
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 800192c:	9b01      	ldr	r3, [sp, #4]
 800192e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001930:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 8001934:	9b01      	ldr	r3, [sp, #4]
 8001936:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001938:	685b      	ldr	r3, [r3, #4]
 800193a:	609a      	str	r2, [r3, #8]
    /* Differential channels setting.*/
#if STM32_ADC_DUAL_MODE
    adcp->adcm->DIFSEL = adcp->config->difsel;
    adcp->adcs->DIFSEL = adcp->config->difsel;
#else
    adcp->adcm->DIFSEL = adcp->config->difsel;
 800193c:	9b01      	ldr	r3, [sp, #4]
 800193e:	685a      	ldr	r2, [r3, #4]
 8001940:	9b01      	ldr	r3, [sp, #4]
 8001942:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001944:	6812      	ldr	r2, [r2, #0]
 8001946:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
#endif

    /* Master ADC calibration.*/
    adc_lld_vreg_on(adcp);
 800194a:	9801      	ldr	r0, [sp, #4]
 800194c:	f7ff fcf8 	bl	8001340 <adc_lld_vreg_on>
    adc_lld_calibrate(adcp);
 8001950:	9801      	ldr	r0, [sp, #4]
 8001952:	f7ff fd0d 	bl	8001370 <adc_lld_calibrate>

    /* Master ADC enabled here in order to reduce conversions latencies.*/
    adc_lld_analog_on(adcp);
 8001956:	9801      	ldr	r0, [sp, #4]
 8001958:	f7ff fd4a 	bl	80013f0 <adc_lld_analog_on>
  }
}
 800195c:	bf00      	nop
 800195e:	b003      	add	sp, #12
 8001960:	f85d fb04 	ldr.w	pc, [sp], #4
 8001964:	08005140 	.word	0x08005140
 8001968:	20000800 	.word	0x20000800
 800196c:	08001461 	.word	0x08001461
 8001970:	08005158 	.word	0x08005158
 8001974:	200008a8 	.word	0x200008a8
 8001978:	40021000 	.word	0x40021000
 800197c:	20000838 	.word	0x20000838
 8001980:	20000870 	.word	0x20000870
	...

08001990 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 8001990:	b086      	sub	sp, #24
 8001992:	9001      	str	r0, [sp, #4]
  uint32_t dmamode, cfgr;
  const ADCConversionGroup *grpp = adcp->grpp;
 8001994:	9b01      	ldr	r3, [sp, #4]
 8001996:	691b      	ldr	r3, [r3, #16]
 8001998:	9303      	str	r3, [sp, #12]

  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
 800199a:	9b01      	ldr	r3, [sp, #4]
 800199c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800199e:	9305      	str	r3, [sp, #20]
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 80019a0:	9b03      	ldr	r3, [sp, #12]
 80019a2:	68db      	ldr	r3, [r3, #12]
 80019a4:	f043 0301 	orr.w	r3, r3, #1
 80019a8:	9304      	str	r3, [sp, #16]
  if (grpp->circular) {
 80019aa:	9b03      	ldr	r3, [sp, #12]
 80019ac:	781b      	ldrb	r3, [r3, #0]
 80019ae:	2b00      	cmp	r3, #0
 80019b0:	d00f      	beq.n	80019d2 <adc_lld_start_conversion+0x42>
    dmamode |= STM32_DMA_CR_CIRC;
 80019b2:	9b05      	ldr	r3, [sp, #20]
 80019b4:	f043 0320 	orr.w	r3, r3, #32
 80019b8:	9305      	str	r3, [sp, #20]
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
#else
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
 80019ba:	9b04      	ldr	r3, [sp, #16]
 80019bc:	f043 0302 	orr.w	r3, r3, #2
 80019c0:	9304      	str	r3, [sp, #16]
#endif
    if (adcp->depth > 1) {
 80019c2:	9b01      	ldr	r3, [sp, #4]
 80019c4:	68db      	ldr	r3, [r3, #12]
 80019c6:	2b01      	cmp	r3, #1
 80019c8:	d903      	bls.n	80019d2 <adc_lld_start_conversion+0x42>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      dmamode |= STM32_DMA_CR_HTIE;
 80019ca:	9b05      	ldr	r3, [sp, #20]
 80019cc:	f043 0304 	orr.w	r3, r3, #4
 80019d0:	9305      	str	r3, [sp, #20]
    }
  }

  /* DMA setup.*/
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 80019d2:	9b01      	ldr	r3, [sp, #4]
 80019d4:	689a      	ldr	r2, [r3, #8]
 80019d6:	9b01      	ldr	r3, [sp, #4]
 80019d8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019da:	685b      	ldr	r3, [r3, #4]
 80019dc:	60da      	str	r2, [r3, #12]
#if STM32_ADC_DUAL_MODE
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels/2) *
                                            (uint32_t)adcp->depth);
#else
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 80019de:	9b03      	ldr	r3, [sp, #12]
 80019e0:	885b      	ldrh	r3, [r3, #2]
 80019e2:	4619      	mov	r1, r3
 80019e4:	9b01      	ldr	r3, [sp, #4]
 80019e6:	68da      	ldr	r2, [r3, #12]
 80019e8:	9b01      	ldr	r3, [sp, #4]
 80019ea:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019ec:	685b      	ldr	r3, [r3, #4]
 80019ee:	fb01 f202 	mul.w	r2, r1, r2
 80019f2:	605a      	str	r2, [r3, #4]
                                            (uint32_t)adcp->depth);
#endif
  dmaStreamSetMode(adcp->dmastp, dmamode);
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019f8:	68db      	ldr	r3, [r3, #12]
 80019fa:	681b      	ldr	r3, [r3, #0]
 80019fc:	9302      	str	r3, [sp, #8]
 80019fe:	9b01      	ldr	r3, [sp, #4]
 8001a00:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a02:	7c1b      	ldrb	r3, [r3, #16]
 8001a04:	461a      	mov	r2, r3
 8001a06:	230f      	movs	r3, #15
 8001a08:	4093      	lsls	r3, r2
 8001a0a:	43db      	mvns	r3, r3
 8001a0c:	9a02      	ldr	r2, [sp, #8]
 8001a0e:	4013      	ands	r3, r2
 8001a10:	9302      	str	r3, [sp, #8]
 8001a12:	9b05      	ldr	r3, [sp, #20]
 8001a14:	0c1b      	lsrs	r3, r3, #16
 8001a16:	9a01      	ldr	r2, [sp, #4]
 8001a18:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 8001a1a:	7c12      	ldrb	r2, [r2, #16]
 8001a1c:	4093      	lsls	r3, r2
 8001a1e:	9a02      	ldr	r2, [sp, #8]
 8001a20:	4313      	orrs	r3, r2
 8001a22:	9302      	str	r3, [sp, #8]
 8001a24:	9b01      	ldr	r3, [sp, #4]
 8001a26:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a28:	68db      	ldr	r3, [r3, #12]
 8001a2a:	9a02      	ldr	r2, [sp, #8]
 8001a2c:	601a      	str	r2, [r3, #0]
 8001a2e:	9b01      	ldr	r3, [sp, #4]
 8001a30:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a32:	685b      	ldr	r3, [r3, #4]
 8001a34:	9a05      	ldr	r2, [sp, #20]
 8001a36:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(adcp->dmastp);
 8001a38:	9b01      	ldr	r3, [sp, #4]
 8001a3a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a3c:	685b      	ldr	r3, [r3, #4]
 8001a3e:	681a      	ldr	r2, [r3, #0]
 8001a40:	9b01      	ldr	r3, [sp, #4]
 8001a42:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a44:	685b      	ldr	r3, [r3, #4]
 8001a46:	f042 0201 	orr.w	r2, r2, #1
 8001a4a:	601a      	str	r2, [r3, #0]

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8001a4c:	9b01      	ldr	r3, [sp, #4]
 8001a4e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001a50:	9b01      	ldr	r3, [sp, #4]
 8001a52:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a54:	6812      	ldr	r2, [r2, #0]
 8001a56:	601a      	str	r2, [r3, #0]
  if (grpp->error_cb != NULL) {
 8001a58:	9b03      	ldr	r3, [sp, #12]
 8001a5a:	689b      	ldr	r3, [r3, #8]
 8001a5c:	2b00      	cmp	r3, #0
 8001a5e:	d01f      	beq.n	8001aa0 <adc_lld_start_conversion+0x110>
    adcp->adcm->IER    = ADC_IER_OVRIE | ADC_IER_AWD1IE
 8001a60:	9b01      	ldr	r3, [sp, #4]
 8001a62:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a64:	f44f 7264 	mov.w	r2, #912	@ 0x390
 8001a68:	605a      	str	r2, [r3, #4]
                                       | ADC_IER_AWD2IE
                                       | ADC_IER_AWD3IE;
    adcp->adcm->TR1    = grpp->tr1;
 8001a6a:	9b01      	ldr	r3, [sp, #4]
 8001a6c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a6e:	9a03      	ldr	r2, [sp, #12]
 8001a70:	6952      	ldr	r2, [r2, #20]
 8001a72:	621a      	str	r2, [r3, #32]
    adcp->adcm->TR2    = grpp->tr2;
 8001a74:	9b01      	ldr	r3, [sp, #4]
 8001a76:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a78:	9a03      	ldr	r2, [sp, #12]
 8001a7a:	6992      	ldr	r2, [r2, #24]
 8001a7c:	625a      	str	r2, [r3, #36]	@ 0x24
    adcp->adcm->TR3    = grpp->tr3;
 8001a7e:	9b01      	ldr	r3, [sp, #4]
 8001a80:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a82:	9a03      	ldr	r2, [sp, #12]
 8001a84:	69d2      	ldr	r2, [r2, #28]
 8001a86:	629a      	str	r2, [r3, #40]	@ 0x28
    adcp->adcm->AWD2CR = grpp->awd2cr;
 8001a88:	9b01      	ldr	r3, [sp, #4]
 8001a8a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a8c:	9a03      	ldr	r2, [sp, #12]
 8001a8e:	6a12      	ldr	r2, [r2, #32]
 8001a90:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    adcp->adcm->AWD3CR = grpp->awd3cr;
 8001a94:	9b01      	ldr	r3, [sp, #4]
 8001a96:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a98:	9a03      	ldr	r2, [sp, #12]
 8001a9a:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8001a9c:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
  adcp->adcs->SQR2  = grpp->ssqr[1];
  adcp->adcs->SQR3  = grpp->ssqr[2];
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
 8001aa0:	9b01      	ldr	r3, [sp, #4]
 8001aa2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001aa4:	9a03      	ldr	r2, [sp, #12]
 8001aa6:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8001aa8:	615a      	str	r2, [r3, #20]
  adcp->adcm->SMPR2 = grpp->smpr[1];
 8001aaa:	9b01      	ldr	r3, [sp, #4]
 8001aac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001aae:	9a03      	ldr	r2, [sp, #12]
 8001ab0:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8001ab2:	619a      	str	r2, [r3, #24]
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8001ab4:	9b03      	ldr	r3, [sp, #12]
 8001ab6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001ab8:	9b03      	ldr	r3, [sp, #12]
 8001aba:	885b      	ldrh	r3, [r3, #2]
 8001abc:	3b01      	subs	r3, #1
 8001abe:	4619      	mov	r1, r3
 8001ac0:	9b01      	ldr	r3, [sp, #4]
 8001ac2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ac4:	430a      	orrs	r2, r1
 8001ac6:	631a      	str	r2, [r3, #48]	@ 0x30
  adcp->adcm->SQR2  = grpp->sqr[1];
 8001ac8:	9b01      	ldr	r3, [sp, #4]
 8001aca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001acc:	9a03      	ldr	r2, [sp, #12]
 8001ace:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 8001ad0:	635a      	str	r2, [r3, #52]	@ 0x34
  adcp->adcm->SQR3  = grpp->sqr[2];
 8001ad2:	9b01      	ldr	r3, [sp, #4]
 8001ad4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ad6:	9a03      	ldr	r2, [sp, #12]
 8001ad8:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 8001ada:	639a      	str	r2, [r3, #56]	@ 0x38
  adcp->adcm->SQR4  = grpp->sqr[3];
 8001adc:	9b01      	ldr	r3, [sp, #4]
 8001ade:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ae0:	9a03      	ldr	r2, [sp, #12]
 8001ae2:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8001ae4:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif /* !STM32_ADC_DUAL_MODE */

  /* ADC configuration.*/
  adcp->adcm->CFGR  = cfgr;
 8001ae6:	9b01      	ldr	r3, [sp, #4]
 8001ae8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001aea:	9a04      	ldr	r2, [sp, #16]
 8001aec:	60da      	str	r2, [r3, #12]
#if (STM32_ADCV3_OVERSAMPLING == TRUE) || defined(__DOXYGEN__)
  adcp->adcm->CFGR2 = grpp->cfgr2;
 8001aee:	9b01      	ldr	r3, [sp, #4]
 8001af0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001af2:	9a03      	ldr	r2, [sp, #12]
 8001af4:	6912      	ldr	r2, [r2, #16]
 8001af6:	611a      	str	r2, [r3, #16]
#endif

  /* Starting conversion.*/
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 8001af8:	9b01      	ldr	r3, [sp, #4]
 8001afa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001afc:	689a      	ldr	r2, [r3, #8]
 8001afe:	9b01      	ldr	r3, [sp, #4]
 8001b00:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b02:	f042 0204 	orr.w	r2, r2, #4
 8001b06:	609a      	str	r2, [r3, #8]
}
 8001b08:	bf00      	nop
 8001b0a:	b006      	add	sp, #24
 8001b0c:	4770      	bx	lr
 8001b0e:	bf00      	nop

08001b10 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8001b10:	b500      	push	{lr}
 8001b12:	b083      	sub	sp, #12
 8001b14:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
 8001b16:	9b01      	ldr	r3, [sp, #4]
 8001b18:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b1a:	685b      	ldr	r3, [r3, #4]
 8001b1c:	681a      	ldr	r2, [r3, #0]
 8001b1e:	9b01      	ldr	r3, [sp, #4]
 8001b20:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b22:	685b      	ldr	r3, [r3, #4]
 8001b24:	f022 020f 	bic.w	r2, r2, #15
 8001b28:	601a      	str	r2, [r3, #0]
 8001b2a:	9b01      	ldr	r3, [sp, #4]
 8001b2c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b2e:	7c1b      	ldrb	r3, [r3, #16]
 8001b30:	461a      	mov	r2, r3
 8001b32:	230e      	movs	r3, #14
 8001b34:	fa03 f202 	lsl.w	r2, r3, r2
 8001b38:	9b01      	ldr	r3, [sp, #4]
 8001b3a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b3c:	681b      	ldr	r3, [r3, #0]
 8001b3e:	605a      	str	r2, [r3, #4]
  adc_lld_stop_adc(adcp);
 8001b40:	9801      	ldr	r0, [sp, #4]
 8001b42:	f7ff fc6d 	bl	8001420 <adc_lld_stop_adc>
}
 8001b46:	bf00      	nop
 8001b48:	b003      	add	sp, #12
 8001b4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b4e:	bf00      	nop

08001b50 <adcSTM32EnableVREF>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableVREF(ADCDriver *adcp) {
 8001b50:	b082      	sub	sp, #8
 8001b52:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_VREFEN;
 8001b54:	9b01      	ldr	r3, [sp, #4]
 8001b56:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b58:	689a      	ldr	r2, [r3, #8]
 8001b5a:	9b01      	ldr	r3, [sp, #4]
 8001b5c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b5e:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8001b62:	609a      	str	r2, [r3, #8]
}
 8001b64:	bf00      	nop
 8001b66:	b002      	add	sp, #8
 8001b68:	4770      	bx	lr
 8001b6a:	bf00      	nop
 8001b6c:	0000      	movs	r0, r0
	...

08001b70 <adcSTM32EnableTS>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {
 8001b70:	b082      	sub	sp, #8
 8001b72:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_TSEN;
 8001b74:	9b01      	ldr	r3, [sp, #4]
 8001b76:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b78:	689a      	ldr	r2, [r3, #8]
 8001b7a:	9b01      	ldr	r3, [sp, #4]
 8001b7c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b7e:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 8001b82:	609a      	str	r2, [r3, #8]
}
 8001b84:	bf00      	nop
 8001b86:	b002      	add	sp, #8
 8001b88:	4770      	bx	lr
 8001b8a:	bf00      	nop
 8001b8c:	0000      	movs	r0, r0
	...

08001b90 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001b90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001b92:	f000 fed5 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8001b96:	4804      	ldr	r0, [pc, #16]	@ (8001ba8 <Vector6C+0x18>)
 8001b98:	f000 f9ba 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001b9c:	f000 ff08 	bl	80029b0 <__dbg_check_leave_isr>
 8001ba0:	f003 f90e 	bl	8004dc0 <__port_irq_epilogue>
}
 8001ba4:	bf00      	nop
 8001ba6:	bd08      	pop	{r3, pc}
 8001ba8:	08005168 	.word	0x08005168
 8001bac:	00000000 	.word	0x00000000

08001bb0 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8001bb0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001bb2:	f000 fec5 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8001bb6:	4804      	ldr	r0, [pc, #16]	@ (8001bc8 <Vector70+0x18>)
 8001bb8:	f000 f9aa 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001bbc:	f000 fef8 	bl	80029b0 <__dbg_check_leave_isr>
 8001bc0:	f003 f8fe 	bl	8004dc0 <__port_irq_epilogue>
}
 8001bc4:	bf00      	nop
 8001bc6:	bd08      	pop	{r3, pc}
 8001bc8:	0800517c 	.word	0x0800517c
 8001bcc:	00000000 	.word	0x00000000

08001bd0 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8001bd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001bd2:	f000 feb5 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8001bd6:	4804      	ldr	r0, [pc, #16]	@ (8001be8 <Vector74+0x18>)
 8001bd8:	f000 f99a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001bdc:	f000 fee8 	bl	80029b0 <__dbg_check_leave_isr>
 8001be0:	f003 f8ee 	bl	8004dc0 <__port_irq_epilogue>
}
 8001be4:	bf00      	nop
 8001be6:	bd08      	pop	{r3, pc}
 8001be8:	08005190 	.word	0x08005190
 8001bec:	00000000 	.word	0x00000000

08001bf0 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001bf0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001bf2:	f000 fea5 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8001bf6:	4804      	ldr	r0, [pc, #16]	@ (8001c08 <Vector78+0x18>)
 8001bf8:	f000 f98a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001bfc:	f000 fed8 	bl	80029b0 <__dbg_check_leave_isr>
 8001c00:	f003 f8de 	bl	8004dc0 <__port_irq_epilogue>
}
 8001c04:	bf00      	nop
 8001c06:	bd08      	pop	{r3, pc}
 8001c08:	080051a4 	.word	0x080051a4
 8001c0c:	00000000 	.word	0x00000000

08001c10 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8001c10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c12:	f000 fe95 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8001c16:	4804      	ldr	r0, [pc, #16]	@ (8001c28 <Vector7C+0x18>)
 8001c18:	f000 f97a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c1c:	f000 fec8 	bl	80029b0 <__dbg_check_leave_isr>
 8001c20:	f003 f8ce 	bl	8004dc0 <__port_irq_epilogue>
}
 8001c24:	bf00      	nop
 8001c26:	bd08      	pop	{r3, pc}
 8001c28:	080051b8 	.word	0x080051b8
 8001c2c:	00000000 	.word	0x00000000

08001c30 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8001c30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c32:	f000 fe85 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8001c36:	4804      	ldr	r0, [pc, #16]	@ (8001c48 <Vector80+0x18>)
 8001c38:	f000 f96a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c3c:	f000 feb8 	bl	80029b0 <__dbg_check_leave_isr>
 8001c40:	f003 f8be 	bl	8004dc0 <__port_irq_epilogue>
}
 8001c44:	bf00      	nop
 8001c46:	bd08      	pop	{r3, pc}
 8001c48:	080051cc 	.word	0x080051cc
 8001c4c:	00000000 	.word	0x00000000

08001c50 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8001c50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c52:	f000 fe75 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8001c56:	4804      	ldr	r0, [pc, #16]	@ (8001c68 <Vector84+0x18>)
 8001c58:	f000 f95a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c5c:	f000 fea8 	bl	80029b0 <__dbg_check_leave_isr>
 8001c60:	f003 f8ae 	bl	8004dc0 <__port_irq_epilogue>
}
 8001c64:	bf00      	nop
 8001c66:	bd08      	pop	{r3, pc}
 8001c68:	080051e0 	.word	0x080051e0
 8001c6c:	00000000 	.word	0x00000000

08001c70 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8001c70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c72:	f000 fe65 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8001c76:	4804      	ldr	r0, [pc, #16]	@ (8001c88 <Vector120+0x18>)
 8001c78:	f000 f94a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c7c:	f000 fe98 	bl	80029b0 <__dbg_check_leave_isr>
 8001c80:	f003 f89e 	bl	8004dc0 <__port_irq_epilogue>
}
 8001c84:	bf00      	nop
 8001c86:	bd08      	pop	{r3, pc}
 8001c88:	080051f4 	.word	0x080051f4
 8001c8c:	00000000 	.word	0x00000000

08001c90 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8001c90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c92:	f000 fe55 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8001c96:	4804      	ldr	r0, [pc, #16]	@ (8001ca8 <Vector124+0x18>)
 8001c98:	f000 f93a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c9c:	f000 fe88 	bl	80029b0 <__dbg_check_leave_isr>
 8001ca0:	f003 f88e 	bl	8004dc0 <__port_irq_epilogue>
}
 8001ca4:	bf00      	nop
 8001ca6:	bd08      	pop	{r3, pc}
 8001ca8:	08005208 	.word	0x08005208
 8001cac:	00000000 	.word	0x00000000

08001cb0 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8001cb0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001cb2:	f000 fe45 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8001cb6:	4804      	ldr	r0, [pc, #16]	@ (8001cc8 <Vector128+0x18>)
 8001cb8:	f000 f92a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001cbc:	f000 fe78 	bl	80029b0 <__dbg_check_leave_isr>
 8001cc0:	f003 f87e 	bl	8004dc0 <__port_irq_epilogue>
}
 8001cc4:	bf00      	nop
 8001cc6:	bd08      	pop	{r3, pc}
 8001cc8:	0800521c 	.word	0x0800521c
 8001ccc:	00000000 	.word	0x00000000

08001cd0 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001cd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001cd2:	f000 fe35 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8001cd6:	4804      	ldr	r0, [pc, #16]	@ (8001ce8 <Vector12C+0x18>)
 8001cd8:	f000 f91a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001cdc:	f000 fe68 	bl	80029b0 <__dbg_check_leave_isr>
 8001ce0:	f003 f86e 	bl	8004dc0 <__port_irq_epilogue>
}
 8001ce4:	bf00      	nop
 8001ce6:	bd08      	pop	{r3, pc}
 8001ce8:	08005230 	.word	0x08005230
 8001cec:	00000000 	.word	0x00000000

08001cf0 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001cf0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001cf2:	f000 fe25 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8001cf6:	4804      	ldr	r0, [pc, #16]	@ (8001d08 <Vector130+0x18>)
 8001cf8:	f000 f90a 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001cfc:	f000 fe58 	bl	80029b0 <__dbg_check_leave_isr>
 8001d00:	f003 f85e 	bl	8004dc0 <__port_irq_epilogue>
}
 8001d04:	bf00      	nop
 8001d06:	bd08      	pop	{r3, pc}
 8001d08:	08005244 	.word	0x08005244
 8001d0c:	00000000 	.word	0x00000000

08001d10 <Vector150>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8001d10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d12:	f000 fe15 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8001d16:	4804      	ldr	r0, [pc, #16]	@ (8001d28 <Vector150+0x18>)
 8001d18:	f000 f8fa 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d1c:	f000 fe48 	bl	80029b0 <__dbg_check_leave_isr>
 8001d20:	f003 f84e 	bl	8004dc0 <__port_irq_epilogue>
}
 8001d24:	bf00      	nop
 8001d26:	bd08      	pop	{r3, pc}
 8001d28:	08005258 	.word	0x08005258
 8001d2c:	00000000 	.word	0x00000000

08001d30 <Vector154>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8001d30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d32:	f000 fe05 	bl	8002940 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 8001d36:	4804      	ldr	r0, [pc, #16]	@ (8001d48 <Vector154+0x18>)
 8001d38:	f000 f8ea 	bl	8001f10 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d3c:	f000 fe38 	bl	80029b0 <__dbg_check_leave_isr>
 8001d40:	f003 f83e 	bl	8004dc0 <__port_irq_epilogue>
}
 8001d44:	bf00      	nop
 8001d46:	bd08      	pop	{r3, pc}
 8001d48:	0800526c 	.word	0x0800526c
 8001d4c:	00000000 	.word	0x00000000

08001d50 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8001d50:	b082      	sub	sp, #8
  int i;

  dma.allocated_mask = 0U;
 8001d52:	4b15      	ldr	r3, [pc, #84]	@ (8001da8 <dmaInit+0x58>)
 8001d54:	2200      	movs	r2, #0
 8001d56:	601a      	str	r2, [r3, #0]
  dma.isr_mask       = 0U;
 8001d58:	4b13      	ldr	r3, [pc, #76]	@ (8001da8 <dmaInit+0x58>)
 8001d5a:	2200      	movs	r2, #0
 8001d5c:	605a      	str	r2, [r3, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001d5e:	2300      	movs	r3, #0
 8001d60:	9301      	str	r3, [sp, #4]
 8001d62:	e013      	b.n	8001d8c <dmaInit+0x3c>
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001d64:	4911      	ldr	r1, [pc, #68]	@ (8001dac <dmaInit+0x5c>)
 8001d66:	9a01      	ldr	r2, [sp, #4]
 8001d68:	4613      	mov	r3, r2
 8001d6a:	009b      	lsls	r3, r3, #2
 8001d6c:	4413      	add	r3, r2
 8001d6e:	009b      	lsls	r3, r3, #2
 8001d70:	440b      	add	r3, r1
 8001d72:	3304      	adds	r3, #4
 8001d74:	681b      	ldr	r3, [r3, #0]
 8001d76:	2200      	movs	r2, #0
 8001d78:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 8001d7a:	4a0b      	ldr	r2, [pc, #44]	@ (8001da8 <dmaInit+0x58>)
 8001d7c:	9b01      	ldr	r3, [sp, #4]
 8001d7e:	3301      	adds	r3, #1
 8001d80:	2100      	movs	r1, #0
 8001d82:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001d86:	9b01      	ldr	r3, [sp, #4]
 8001d88:	3301      	adds	r3, #1
 8001d8a:	9301      	str	r3, [sp, #4]
 8001d8c:	9b01      	ldr	r3, [sp, #4]
 8001d8e:	2b0d      	cmp	r3, #13
 8001d90:	dde8      	ble.n	8001d64 <dmaInit+0x14>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8001d92:	4b07      	ldr	r3, [pc, #28]	@ (8001db0 <dmaInit+0x60>)
 8001d94:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001d98:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8001d9a:	4b06      	ldr	r3, [pc, #24]	@ (8001db4 <dmaInit+0x64>)
 8001d9c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001da0:	605a      	str	r2, [r3, #4]
#endif
}
 8001da2:	bf00      	nop
 8001da4:	b002      	add	sp, #8
 8001da6:	4770      	bx	lr
 8001da8:	200008ac 	.word	0x200008ac
 8001dac:	08005168 	.word	0x08005168
 8001db0:	40020000 	.word	0x40020000
 8001db4:	40020400 	.word	0x40020400
	...

08001dc0 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8001dc0:	b500      	push	{lr}
 8001dc2:	b08b      	sub	sp, #44	@ 0x2c
 8001dc4:	9003      	str	r0, [sp, #12]
 8001dc6:	9102      	str	r1, [sp, #8]
 8001dc8:	9201      	str	r2, [sp, #4]
 8001dca:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 8001dcc:	f000 fe30 	bl	8002a30 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 8001dd0:	9b03      	ldr	r3, [sp, #12]
 8001dd2:	2b0d      	cmp	r3, #13
 8001dd4:	d806      	bhi.n	8001de4 <dmaStreamAllocI+0x24>
    startid = id;
 8001dd6:	9b03      	ldr	r3, [sp, #12]
 8001dd8:	9308      	str	r3, [sp, #32]
    endid   = id;
 8001dda:	9b03      	ldr	r3, [sp, #12]
 8001ddc:	9307      	str	r3, [sp, #28]
  else {
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
 8001dde:	9b08      	ldr	r3, [sp, #32]
 8001de0:	9309      	str	r3, [sp, #36]	@ 0x24
 8001de2:	e080      	b.n	8001ee6 <dmaStreamAllocI+0x126>
    osalDbgCheck(false);
 8001de4:	4845      	ldr	r0, [pc, #276]	@ (8001efc <dmaStreamAllocI+0x13c>)
 8001de6:	f000 fc83 	bl	80026f0 <chSysHalt>
    return NULL;
 8001dea:	2300      	movs	r3, #0
 8001dec:	e081      	b.n	8001ef2 <dmaStreamAllocI+0x132>
    uint32_t mask = (1U << i);
 8001dee:	2201      	movs	r2, #1
 8001df0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001df2:	fa02 f303 	lsl.w	r3, r2, r3
 8001df6:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 8001df8:	4b41      	ldr	r3, [pc, #260]	@ (8001f00 <dmaStreamAllocI+0x140>)
 8001dfa:	681a      	ldr	r2, [r3, #0]
 8001dfc:	9b06      	ldr	r3, [sp, #24]
 8001dfe:	4013      	ands	r3, r2
 8001e00:	2b00      	cmp	r3, #0
 8001e02:	d16d      	bne.n	8001ee0 <dmaStreamAllocI+0x120>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8001e04:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001e06:	4613      	mov	r3, r2
 8001e08:	009b      	lsls	r3, r3, #2
 8001e0a:	4413      	add	r3, r2
 8001e0c:	009b      	lsls	r3, r3, #2
 8001e0e:	4a3d      	ldr	r2, [pc, #244]	@ (8001f04 <dmaStreamAllocI+0x144>)
 8001e10:	4413      	add	r3, r2
 8001e12:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8001e14:	493a      	ldr	r1, [pc, #232]	@ (8001f00 <dmaStreamAllocI+0x140>)
 8001e16:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001e18:	3301      	adds	r3, #1
 8001e1a:	9a01      	ldr	r2, [sp, #4]
 8001e1c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
      dma.streams[i].param = param;
 8001e20:	4a37      	ldr	r2, [pc, #220]	@ (8001f00 <dmaStreamAllocI+0x140>)
 8001e22:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001e24:	3301      	adds	r3, #1
 8001e26:	00db      	lsls	r3, r3, #3
 8001e28:	4413      	add	r3, r2
 8001e2a:	9a00      	ldr	r2, [sp, #0]
 8001e2c:	605a      	str	r2, [r3, #4]
      dma.allocated_mask  |= mask;
 8001e2e:	4b34      	ldr	r3, [pc, #208]	@ (8001f00 <dmaStreamAllocI+0x140>)
 8001e30:	681a      	ldr	r2, [r3, #0]
 8001e32:	9b06      	ldr	r3, [sp, #24]
 8001e34:	4313      	orrs	r3, r2
 8001e36:	4a32      	ldr	r2, [pc, #200]	@ (8001f00 <dmaStreamAllocI+0x140>)
 8001e38:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8001e3a:	9b06      	ldr	r3, [sp, #24]
 8001e3c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8001e40:	2b00      	cmp	r3, #0
 8001e42:	d00d      	beq.n	8001e60 <dmaStreamAllocI+0xa0>
        rccEnableDMA1(true);
 8001e44:	4b30      	ldr	r3, [pc, #192]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e46:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8001e48:	4a2f      	ldr	r2, [pc, #188]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e4a:	f043 0301 	orr.w	r3, r3, #1
 8001e4e:	6493      	str	r3, [r2, #72]	@ 0x48
 8001e50:	4b2d      	ldr	r3, [pc, #180]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e52:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8001e54:	4a2c      	ldr	r2, [pc, #176]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e56:	f043 0301 	orr.w	r3, r3, #1
 8001e5a:	6693      	str	r3, [r2, #104]	@ 0x68
 8001e5c:	4b2a      	ldr	r3, [pc, #168]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e5e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#if STM32_DMA2_NUM_CHANNELS > 0
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 8001e60:	9b06      	ldr	r3, [sp, #24]
 8001e62:	f403 537e 	and.w	r3, r3, #16256	@ 0x3f80
 8001e66:	2b00      	cmp	r3, #0
 8001e68:	d00d      	beq.n	8001e86 <dmaStreamAllocI+0xc6>
        rccEnableDMA2(true);
 8001e6a:	4b27      	ldr	r3, [pc, #156]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e6c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8001e6e:	4a26      	ldr	r2, [pc, #152]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e70:	f043 0302 	orr.w	r3, r3, #2
 8001e74:	6493      	str	r3, [r2, #72]	@ 0x48
 8001e76:	4b24      	ldr	r3, [pc, #144]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e78:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8001e7a:	4a23      	ldr	r2, [pc, #140]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e7c:	f043 0302 	orr.w	r3, r3, #2
 8001e80:	6693      	str	r3, [r2, #104]	@ 0x68
 8001e82:	4b21      	ldr	r3, [pc, #132]	@ (8001f08 <dmaStreamAllocI+0x148>)
 8001e84:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 8001e86:	9b01      	ldr	r3, [sp, #4]
 8001e88:	2b00      	cmp	r3, #0
 8001e8a:	d012      	beq.n	8001eb2 <dmaStreamAllocI+0xf2>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8001e8c:	4b1c      	ldr	r3, [pc, #112]	@ (8001f00 <dmaStreamAllocI+0x140>)
 8001e8e:	685a      	ldr	r2, [r3, #4]
 8001e90:	9b05      	ldr	r3, [sp, #20]
 8001e92:	689b      	ldr	r3, [r3, #8]
 8001e94:	4013      	ands	r3, r2
 8001e96:	2b00      	cmp	r3, #0
 8001e98:	d105      	bne.n	8001ea6 <dmaStreamAllocI+0xe6>
          nvicEnableVector(dmastp->vector, priority);
 8001e9a:	9b05      	ldr	r3, [sp, #20]
 8001e9c:	7c9b      	ldrb	r3, [r3, #18]
 8001e9e:	9902      	ldr	r1, [sp, #8]
 8001ea0:	4618      	mov	r0, r3
 8001ea2:	f7fe fe7d 	bl	8000ba0 <nvicEnableVector>
        }
        dma.isr_mask |= mask;
 8001ea6:	4b16      	ldr	r3, [pc, #88]	@ (8001f00 <dmaStreamAllocI+0x140>)
 8001ea8:	685a      	ldr	r2, [r3, #4]
 8001eaa:	9b06      	ldr	r3, [sp, #24]
 8001eac:	4313      	orrs	r3, r2
 8001eae:	4a14      	ldr	r2, [pc, #80]	@ (8001f00 <dmaStreamAllocI+0x140>)
 8001eb0:	6053      	str	r3, [r2, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 8001eb2:	9b05      	ldr	r3, [sp, #20]
 8001eb4:	685b      	ldr	r3, [r3, #4]
 8001eb6:	681a      	ldr	r2, [r3, #0]
 8001eb8:	9b05      	ldr	r3, [sp, #20]
 8001eba:	685b      	ldr	r3, [r3, #4]
 8001ebc:	f022 020f 	bic.w	r2, r2, #15
 8001ec0:	601a      	str	r2, [r3, #0]
 8001ec2:	9b05      	ldr	r3, [sp, #20]
 8001ec4:	7c1b      	ldrb	r3, [r3, #16]
 8001ec6:	461a      	mov	r2, r3
 8001ec8:	230e      	movs	r3, #14
 8001eca:	fa03 f202 	lsl.w	r2, r3, r2
 8001ece:	9b05      	ldr	r3, [sp, #20]
 8001ed0:	681b      	ldr	r3, [r3, #0]
 8001ed2:	605a      	str	r2, [r3, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001ed4:	9b05      	ldr	r3, [sp, #20]
 8001ed6:	685b      	ldr	r3, [r3, #4]
 8001ed8:	2200      	movs	r2, #0
 8001eda:	601a      	str	r2, [r3, #0]

      return dmastp;
 8001edc:	9b05      	ldr	r3, [sp, #20]
 8001ede:	e008      	b.n	8001ef2 <dmaStreamAllocI+0x132>
  for (i = startid; i <= endid; i++) {
 8001ee0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001ee2:	3301      	adds	r3, #1
 8001ee4:	9309      	str	r3, [sp, #36]	@ 0x24
 8001ee6:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001ee8:	9b07      	ldr	r3, [sp, #28]
 8001eea:	429a      	cmp	r2, r3
 8001eec:	f67f af7f 	bls.w	8001dee <dmaStreamAllocI+0x2e>
    }
  }

  return NULL;
 8001ef0:	2300      	movs	r3, #0
}
 8001ef2:	4618      	mov	r0, r3
 8001ef4:	b00b      	add	sp, #44	@ 0x2c
 8001ef6:	f85d fb04 	ldr.w	pc, [sp], #4
 8001efa:	bf00      	nop
 8001efc:	08005280 	.word	0x08005280
 8001f00:	200008ac 	.word	0x200008ac
 8001f04:	08005168 	.word	0x08005168
 8001f08:	40021000 	.word	0x40021000
 8001f0c:	00000000 	.word	0x00000000

08001f10 <dmaServeInterrupt>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
 8001f10:	b500      	push	{lr}
 8001f12:	b085      	sub	sp, #20
 8001f14:	9001      	str	r0, [sp, #4]
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;
 8001f16:	9b01      	ldr	r3, [sp, #4]
 8001f18:	7c5b      	ldrb	r3, [r3, #17]
 8001f1a:	9303      	str	r3, [sp, #12]

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001f1c:	9b01      	ldr	r3, [sp, #4]
 8001f1e:	681b      	ldr	r3, [r3, #0]
 8001f20:	681b      	ldr	r3, [r3, #0]
 8001f22:	9a01      	ldr	r2, [sp, #4]
 8001f24:	7c12      	ldrb	r2, [r2, #16]
 8001f26:	40d3      	lsrs	r3, r2
 8001f28:	f003 030e 	and.w	r3, r3, #14
 8001f2c:	9302      	str	r3, [sp, #8]
  if (flags & dmastp->channel->CCR) {
 8001f2e:	9b01      	ldr	r3, [sp, #4]
 8001f30:	685b      	ldr	r3, [r3, #4]
 8001f32:	681a      	ldr	r2, [r3, #0]
 8001f34:	9b02      	ldr	r3, [sp, #8]
 8001f36:	4013      	ands	r3, r2
 8001f38:	2b00      	cmp	r3, #0
 8001f3a:	d01c      	beq.n	8001f76 <dmaServeInterrupt+0x66>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8001f3c:	9b01      	ldr	r3, [sp, #4]
 8001f3e:	7c1b      	ldrb	r3, [r3, #16]
 8001f40:	4619      	mov	r1, r3
 8001f42:	9b01      	ldr	r3, [sp, #4]
 8001f44:	681b      	ldr	r3, [r3, #0]
 8001f46:	9a02      	ldr	r2, [sp, #8]
 8001f48:	408a      	lsls	r2, r1
 8001f4a:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8001f4c:	4a0c      	ldr	r2, [pc, #48]	@ (8001f80 <dmaServeInterrupt+0x70>)
 8001f4e:	9b03      	ldr	r3, [sp, #12]
 8001f50:	3301      	adds	r3, #1
 8001f52:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8001f56:	2b00      	cmp	r3, #0
 8001f58:	d00d      	beq.n	8001f76 <dmaServeInterrupt+0x66>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8001f5a:	4a09      	ldr	r2, [pc, #36]	@ (8001f80 <dmaServeInterrupt+0x70>)
 8001f5c:	9b03      	ldr	r3, [sp, #12]
 8001f5e:	3301      	adds	r3, #1
 8001f60:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8001f64:	4906      	ldr	r1, [pc, #24]	@ (8001f80 <dmaServeInterrupt+0x70>)
 8001f66:	9b03      	ldr	r3, [sp, #12]
 8001f68:	3301      	adds	r3, #1
 8001f6a:	00db      	lsls	r3, r3, #3
 8001f6c:	440b      	add	r3, r1
 8001f6e:	685b      	ldr	r3, [r3, #4]
 8001f70:	9902      	ldr	r1, [sp, #8]
 8001f72:	4618      	mov	r0, r3
 8001f74:	4790      	blx	r2
    }
  }
}
 8001f76:	bf00      	nop
 8001f78:	b005      	add	sp, #20
 8001f7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f7e:	bf00      	nop
 8001f80:	200008ac 	.word	0x200008ac
	...

08001f90 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8001f90:	bf00      	nop
 8001f92:	4770      	bx	lr
	...

08001fa0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001fa0:	b090      	sub	sp, #64	@ 0x40
 8001fa2:	9003      	str	r0, [sp, #12]
 8001fa4:	9102      	str	r1, [sp, #8]
 8001fa6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001fa8:	9b01      	ldr	r3, [sp, #4]
 8001faa:	f003 0303 	and.w	r3, r3, #3
 8001fae:	930f      	str	r3, [sp, #60]	@ 0x3c
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001fb0:	9b01      	ldr	r3, [sp, #4]
 8001fb2:	089b      	lsrs	r3, r3, #2
 8001fb4:	f003 0301 	and.w	r3, r3, #1
 8001fb8:	930e      	str	r3, [sp, #56]	@ 0x38
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001fba:	9b01      	ldr	r3, [sp, #4]
 8001fbc:	08db      	lsrs	r3, r3, #3
 8001fbe:	f003 0303 	and.w	r3, r3, #3
 8001fc2:	930d      	str	r3, [sp, #52]	@ 0x34
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001fc4:	9b01      	ldr	r3, [sp, #4]
 8001fc6:	095b      	lsrs	r3, r3, #5
 8001fc8:	f003 0303 	and.w	r3, r3, #3
 8001fcc:	930c      	str	r3, [sp, #48]	@ 0x30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001fce:	9b01      	ldr	r3, [sp, #4]
 8001fd0:	09db      	lsrs	r3, r3, #7
 8001fd2:	f003 030f 	and.w	r3, r3, #15
 8001fd6:	9309      	str	r3, [sp, #36]	@ 0x24
  uint32_t ascr    = (mode & PAL_STM32_ASCR_MASK) >> 11;
 8001fd8:	9b01      	ldr	r3, [sp, #4]
 8001fda:	0adb      	lsrs	r3, r3, #11
 8001fdc:	f003 0301 	and.w	r3, r3, #1
 8001fe0:	930b      	str	r3, [sp, #44]	@ 0x2c
  uint32_t lockr   = (mode & PAL_STM32_LOCKR_MASK) >> 12;
 8001fe2:	9b01      	ldr	r3, [sp, #4]
 8001fe4:	0b1b      	lsrs	r3, r3, #12
 8001fe6:	f003 0301 	and.w	r3, r3, #1
 8001fea:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8001fec:	2300      	movs	r3, #0
 8001fee:	930a      	str	r3, [sp, #40]	@ 0x28
  while (true) {
    if ((mask & 1) != 0) {
 8001ff0:	9b02      	ldr	r3, [sp, #8]
 8001ff2:	f003 0301 	and.w	r3, r3, #1
 8001ff6:	2b00      	cmp	r3, #0
 8001ff8:	f000 808c 	beq.w	8002114 <_pal_lld_setgroupmode+0x174>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001ffc:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8001ffe:	f003 0307 	and.w	r3, r3, #7
 8002002:	009b      	lsls	r3, r3, #2
 8002004:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8002006:	fa02 f303 	lsl.w	r3, r2, r3
 800200a:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 800200c:	2201      	movs	r2, #1
 800200e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002010:	fa02 f303 	lsl.w	r3, r2, r3
 8002014:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8002016:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002018:	005b      	lsls	r3, r3, #1
 800201a:	2203      	movs	r2, #3
 800201c:	fa02 f303 	lsl.w	r3, r2, r3
 8002020:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8002022:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002024:	f003 0307 	and.w	r3, r3, #7
 8002028:	009b      	lsls	r3, r3, #2
 800202a:	220f      	movs	r2, #15
 800202c:	fa02 f303 	lsl.w	r3, r2, r3
 8002030:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8002032:	9b03      	ldr	r3, [sp, #12]
 8002034:	685a      	ldr	r2, [r3, #4]
 8002036:	9b06      	ldr	r3, [sp, #24]
 8002038:	43db      	mvns	r3, r3
 800203a:	401a      	ands	r2, r3
 800203c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 800203e:	431a      	orrs	r2, r3
 8002040:	9b03      	ldr	r3, [sp, #12]
 8002042:	605a      	str	r2, [r3, #4]
      port->ASCR    = (port->ASCR & ~m1) | ascr;
 8002044:	9b03      	ldr	r3, [sp, #12]
 8002046:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8002048:	9b06      	ldr	r3, [sp, #24]
 800204a:	43db      	mvns	r3, r3
 800204c:	401a      	ands	r2, r3
 800204e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8002050:	431a      	orrs	r2, r3
 8002052:	9b03      	ldr	r3, [sp, #12]
 8002054:	62da      	str	r2, [r3, #44]	@ 0x2c
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8002056:	9b03      	ldr	r3, [sp, #12]
 8002058:	689a      	ldr	r2, [r3, #8]
 800205a:	9b05      	ldr	r3, [sp, #20]
 800205c:	43db      	mvns	r3, r3
 800205e:	401a      	ands	r2, r3
 8002060:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8002062:	431a      	orrs	r2, r3
 8002064:	9b03      	ldr	r3, [sp, #12]
 8002066:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8002068:	9b03      	ldr	r3, [sp, #12]
 800206a:	68da      	ldr	r2, [r3, #12]
 800206c:	9b05      	ldr	r3, [sp, #20]
 800206e:	43db      	mvns	r3, r3
 8002070:	401a      	ands	r2, r3
 8002072:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8002074:	431a      	orrs	r2, r3
 8002076:	9b03      	ldr	r3, [sp, #12]
 8002078:	60da      	str	r2, [r3, #12]
       if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800207a:	9b01      	ldr	r3, [sp, #4]
 800207c:	f003 0303 	and.w	r3, r3, #3
 8002080:	2b02      	cmp	r3, #2
 8002082:	d11f      	bne.n	80020c4 <_pal_lld_setgroupmode+0x124>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8002084:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002086:	2b07      	cmp	r3, #7
 8002088:	d809      	bhi.n	800209e <_pal_lld_setgroupmode+0xfe>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800208a:	9b03      	ldr	r3, [sp, #12]
 800208c:	6a1a      	ldr	r2, [r3, #32]
 800208e:	9b04      	ldr	r3, [sp, #16]
 8002090:	43db      	mvns	r3, r3
 8002092:	401a      	ands	r2, r3
 8002094:	9b07      	ldr	r3, [sp, #28]
 8002096:	431a      	orrs	r2, r3
 8002098:	9b03      	ldr	r3, [sp, #12]
 800209a:	621a      	str	r2, [r3, #32]
 800209c:	e008      	b.n	80020b0 <_pal_lld_setgroupmode+0x110>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800209e:	9b03      	ldr	r3, [sp, #12]
 80020a0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80020a2:	9b04      	ldr	r3, [sp, #16]
 80020a4:	43db      	mvns	r3, r3
 80020a6:	401a      	ands	r2, r3
 80020a8:	9b07      	ldr	r3, [sp, #28]
 80020aa:	431a      	orrs	r2, r3
 80020ac:	9b03      	ldr	r3, [sp, #12]
 80020ae:	625a      	str	r2, [r3, #36]	@ 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 80020b0:	9b03      	ldr	r3, [sp, #12]
 80020b2:	681a      	ldr	r2, [r3, #0]
 80020b4:	9b05      	ldr	r3, [sp, #20]
 80020b6:	43db      	mvns	r3, r3
 80020b8:	401a      	ands	r2, r3
 80020ba:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80020bc:	431a      	orrs	r2, r3
 80020be:	9b03      	ldr	r3, [sp, #12]
 80020c0:	601a      	str	r2, [r3, #0]
 80020c2:	e01e      	b.n	8002102 <_pal_lld_setgroupmode+0x162>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80020c4:	9b03      	ldr	r3, [sp, #12]
 80020c6:	681a      	ldr	r2, [r3, #0]
 80020c8:	9b05      	ldr	r3, [sp, #20]
 80020ca:	43db      	mvns	r3, r3
 80020cc:	401a      	ands	r2, r3
 80020ce:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80020d0:	431a      	orrs	r2, r3
 80020d2:	9b03      	ldr	r3, [sp, #12]
 80020d4:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 80020d6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80020d8:	2b07      	cmp	r3, #7
 80020da:	d809      	bhi.n	80020f0 <_pal_lld_setgroupmode+0x150>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80020dc:	9b03      	ldr	r3, [sp, #12]
 80020de:	6a1a      	ldr	r2, [r3, #32]
 80020e0:	9b04      	ldr	r3, [sp, #16]
 80020e2:	43db      	mvns	r3, r3
 80020e4:	401a      	ands	r2, r3
 80020e6:	9b07      	ldr	r3, [sp, #28]
 80020e8:	431a      	orrs	r2, r3
 80020ea:	9b03      	ldr	r3, [sp, #12]
 80020ec:	621a      	str	r2, [r3, #32]
 80020ee:	e008      	b.n	8002102 <_pal_lld_setgroupmode+0x162>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80020f0:	9b03      	ldr	r3, [sp, #12]
 80020f2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80020f4:	9b04      	ldr	r3, [sp, #16]
 80020f6:	43db      	mvns	r3, r3
 80020f8:	401a      	ands	r2, r3
 80020fa:	9b07      	ldr	r3, [sp, #28]
 80020fc:	431a      	orrs	r2, r3
 80020fe:	9b03      	ldr	r3, [sp, #12]
 8002100:	625a      	str	r2, [r3, #36]	@ 0x24
      }
      port->LOCKR   = (port->LOCKR & ~m1) | lockr;
 8002102:	9b03      	ldr	r3, [sp, #12]
 8002104:	69da      	ldr	r2, [r3, #28]
 8002106:	9b06      	ldr	r3, [sp, #24]
 8002108:	43db      	mvns	r3, r3
 800210a:	401a      	ands	r2, r3
 800210c:	9b08      	ldr	r3, [sp, #32]
 800210e:	431a      	orrs	r2, r3
 8002110:	9b03      	ldr	r3, [sp, #12]
 8002112:	61da      	str	r2, [r3, #28]
    }
    mask >>= 1;
 8002114:	9b02      	ldr	r3, [sp, #8]
 8002116:	085b      	lsrs	r3, r3, #1
 8002118:	9302      	str	r3, [sp, #8]
    if (!mask)
 800211a:	9b02      	ldr	r3, [sp, #8]
 800211c:	2b00      	cmp	r3, #0
 800211e:	d012      	beq.n	8002146 <_pal_lld_setgroupmode+0x1a6>
      return;
    otyper <<= 1;
 8002120:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8002122:	005b      	lsls	r3, r3, #1
 8002124:	930e      	str	r3, [sp, #56]	@ 0x38
    ascr <<= 1;
 8002126:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8002128:	005b      	lsls	r3, r3, #1
 800212a:	930b      	str	r3, [sp, #44]	@ 0x2c
    ospeedr <<= 2;
 800212c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800212e:	009b      	lsls	r3, r3, #2
 8002130:	930d      	str	r3, [sp, #52]	@ 0x34
    pupdr <<= 2;
 8002132:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8002134:	009b      	lsls	r3, r3, #2
 8002136:	930c      	str	r3, [sp, #48]	@ 0x30
    moder <<= 2;
 8002138:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800213a:	009b      	lsls	r3, r3, #2
 800213c:	930f      	str	r3, [sp, #60]	@ 0x3c
    bit++;
 800213e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002140:	3301      	adds	r3, #1
 8002142:	930a      	str	r3, [sp, #40]	@ 0x28
    if ((mask & 1) != 0) {
 8002144:	e754      	b.n	8001ff0 <_pal_lld_setgroupmode+0x50>
      return;
 8002146:	bf00      	nop
  }
}
 8002148:	b010      	add	sp, #64	@ 0x40
 800214a:	4770      	bx	lr
 800214c:	0000      	movs	r0, r0
	...

08002150 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 8002150:	b500      	push	{lr}
 8002152:	b083      	sub	sp, #12
 8002154:	2330      	movs	r3, #48	@ 0x30
 8002156:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002158:	9b01      	ldr	r3, [sp, #4]
 800215a:	f383 8811 	msr	BASEPRI, r3
}
 800215e:	bf00      	nop
}
 8002160:	bf00      	nop
}
 8002162:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002164:	f000 fb9c 	bl	80028a0 <__dbg_check_lock_from_isr>
}
 8002168:	bf00      	nop
 800216a:	b003      	add	sp, #12
 800216c:	f85d fb04 	ldr.w	pc, [sp], #4

08002170 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8002170:	b500      	push	{lr}
 8002172:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002174:	f000 fbbc 	bl	80028f0 <__dbg_check_unlock_from_isr>
 8002178:	2300      	movs	r3, #0
 800217a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800217c:	9b01      	ldr	r3, [sp, #4]
 800217e:	f383 8811 	msr	BASEPRI, r3
}
 8002182:	bf00      	nop
}
 8002184:	bf00      	nop
}
 8002186:	bf00      	nop
}
 8002188:	bf00      	nop
 800218a:	b003      	add	sp, #12
 800218c:	f85d fb04 	ldr.w	pc, [sp], #4

08002190 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 8002190:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002192:	f7ff ffdd 	bl	8002150 <chSysLockFromISR.lto_priv.1>
}
 8002196:	bf00      	nop
 8002198:	bd08      	pop	{r3, pc}
 800219a:	bf00      	nop
 800219c:	0000      	movs	r0, r0
	...

080021a0 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 80021a0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80021a2:	f7ff ffe5 	bl	8002170 <chSysUnlockFromISR.lto_priv.1>
}
 80021a6:	bf00      	nop
 80021a8:	bd08      	pop	{r3, pc}
 80021aa:	bf00      	nop
 80021ac:	0000      	movs	r0, r0
	...

080021b0 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 80021b0:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 80021b2:	f000 fad5 	bl	8002760 <chSysTimerHandlerI>
}
 80021b6:	bf00      	nop
 80021b8:	bd08      	pop	{r3, pc}
 80021ba:	bf00      	nop
 80021bc:	0000      	movs	r0, r0
	...

080021c0 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80021c0:	4b1b      	ldr	r3, [pc, #108]	@ (8002230 <st_lld_init+0x70>)
 80021c2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80021c4:	4a1a      	ldr	r2, [pc, #104]	@ (8002230 <st_lld_init+0x70>)
 80021c6:	f043 0301 	orr.w	r3, r3, #1
 80021ca:	6593      	str	r3, [r2, #88]	@ 0x58
 80021cc:	4b18      	ldr	r3, [pc, #96]	@ (8002230 <st_lld_init+0x70>)
 80021ce:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80021d0:	4a17      	ldr	r2, [pc, #92]	@ (8002230 <st_lld_init+0x70>)
 80021d2:	f043 0301 	orr.w	r3, r3, #1
 80021d6:	6793      	str	r3, [r2, #120]	@ 0x78
 80021d8:	4b15      	ldr	r3, [pc, #84]	@ (8002230 <st_lld_init+0x70>)
 80021da:	6f9b      	ldr	r3, [r3, #120]	@ 0x78

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80021dc:	4b15      	ldr	r3, [pc, #84]	@ (8002234 <st_lld_init+0x74>)
 80021de:	689b      	ldr	r3, [r3, #8]
 80021e0:	4a14      	ldr	r2, [pc, #80]	@ (8002234 <st_lld_init+0x74>)
 80021e2:	f043 0301 	orr.w	r3, r3, #1
 80021e6:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80021e8:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80021ec:	f641 723f 	movw	r2, #7999	@ 0x1f3f
 80021f0:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80021f2:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80021f6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80021fa:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80021fc:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002200:	2200      	movs	r2, #0
 8002202:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002204:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002208:	2200      	movs	r2, #0
 800220a:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 800220c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002210:	2200      	movs	r2, #0
 8002212:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002214:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002218:	2200      	movs	r2, #0
 800221a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800221c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002220:	2201      	movs	r2, #1
 8002222:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002224:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002228:	2201      	movs	r2, #1
 800222a:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800222c:	bf00      	nop
 800222e:	4770      	bx	lr
 8002230:	40021000 	.word	0x40021000
 8002234:	e0042000 	.word	0xe0042000
	...

08002240 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8002240:	b500      	push	{lr}
 8002242:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8002244:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002248:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 800224a:	9b01      	ldr	r3, [sp, #4]
 800224c:	691b      	ldr	r3, [r3, #16]
 800224e:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002250:	9b01      	ldr	r3, [sp, #4]
 8002252:	68db      	ldr	r3, [r3, #12]
 8002254:	b2db      	uxtb	r3, r3
 8002256:	9a00      	ldr	r2, [sp, #0]
 8002258:	4013      	ands	r3, r2
 800225a:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 800225c:	9b00      	ldr	r3, [sp, #0]
 800225e:	43da      	mvns	r2, r3
 8002260:	9b01      	ldr	r3, [sp, #4]
 8002262:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8002264:	9b00      	ldr	r3, [sp, #0]
 8002266:	f003 0302 	and.w	r3, r3, #2
 800226a:	2b00      	cmp	r3, #0
 800226c:	d005      	beq.n	800227a <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 800226e:	f7ff ff8f 	bl	8002190 <osalSysLockFromISR.lto_priv.1>
    osalOsTimerHandlerI();
 8002272:	f7ff ff9d 	bl	80021b0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8002276:	f7ff ff93 	bl	80021a0 <osalSysUnlockFromISR.lto_priv.1>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 800227a:	bf00      	nop
 800227c:	b003      	add	sp, #12
 800227e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002282:	bf00      	nop
	...

08002290 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8002290:	b508      	push	{r3, lr}
  gptObjectInit(&GPTD3);
#endif

#if STM32_GPT_USE_TIM4
  /* Driver initialization.*/
  GPTD4.tim = STM32_TIM4;
 8002292:	4b04      	ldr	r3, [pc, #16]	@ (80022a4 <gpt_lld_init+0x14>)
 8002294:	4a04      	ldr	r2, [pc, #16]	@ (80022a8 <gpt_lld_init+0x18>)
 8002296:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD4);
 8002298:	4802      	ldr	r0, [pc, #8]	@ (80022a4 <gpt_lld_init+0x14>)
 800229a:	f7fe fb69 	bl	8000970 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 800229e:	bf00      	nop
 80022a0:	bd08      	pop	{r3, pc}
 80022a2:	bf00      	nop
 80022a4:	20000924 	.word	0x20000924
 80022a8:	40000800 	.word	0x40000800
 80022ac:	00000000 	.word	0x00000000

080022b0 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 80022b0:	b500      	push	{lr}
 80022b2:	b085      	sub	sp, #20
 80022b4:	9001      	str	r0, [sp, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 80022b6:	9b01      	ldr	r3, [sp, #4]
 80022b8:	781b      	ldrb	r3, [r3, #0]
 80022ba:	2b01      	cmp	r3, #1
 80022bc:	d122      	bne.n	8002304 <gpt_lld_start+0x54>
#endif
    }
#endif

#if STM32_GPT_USE_TIM4
    if (&GPTD4 == gptp) {
 80022be:	9b01      	ldr	r3, [sp, #4]
 80022c0:	4a30      	ldr	r2, [pc, #192]	@ (8002384 <gpt_lld_start+0xd4>)
 80022c2:	4293      	cmp	r3, r2
 80022c4:	d11e      	bne.n	8002304 <gpt_lld_start+0x54>
      rccEnableTIM4(true);
 80022c6:	4b30      	ldr	r3, [pc, #192]	@ (8002388 <gpt_lld_start+0xd8>)
 80022c8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80022ca:	4a2f      	ldr	r2, [pc, #188]	@ (8002388 <gpt_lld_start+0xd8>)
 80022cc:	f043 0304 	orr.w	r3, r3, #4
 80022d0:	6593      	str	r3, [r2, #88]	@ 0x58
 80022d2:	4b2d      	ldr	r3, [pc, #180]	@ (8002388 <gpt_lld_start+0xd8>)
 80022d4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80022d6:	4a2c      	ldr	r2, [pc, #176]	@ (8002388 <gpt_lld_start+0xd8>)
 80022d8:	f043 0304 	orr.w	r3, r3, #4
 80022dc:	6793      	str	r3, [r2, #120]	@ 0x78
 80022de:	4b2a      	ldr	r3, [pc, #168]	@ (8002388 <gpt_lld_start+0xd8>)
 80022e0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
      rccResetTIM4();
 80022e2:	4b29      	ldr	r3, [pc, #164]	@ (8002388 <gpt_lld_start+0xd8>)
 80022e4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80022e6:	4a28      	ldr	r2, [pc, #160]	@ (8002388 <gpt_lld_start+0xd8>)
 80022e8:	f043 0304 	orr.w	r3, r3, #4
 80022ec:	6393      	str	r3, [r2, #56]	@ 0x38
 80022ee:	4b26      	ldr	r3, [pc, #152]	@ (8002388 <gpt_lld_start+0xd8>)
 80022f0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80022f2:	4a25      	ldr	r2, [pc, #148]	@ (8002388 <gpt_lld_start+0xd8>)
 80022f4:	f023 0304 	bic.w	r3, r3, #4
 80022f8:	6393      	str	r3, [r2, #56]	@ 0x38
 80022fa:	4b23      	ldr	r3, [pc, #140]	@ (8002388 <gpt_lld_start+0xd8>)
 80022fc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_GPT_TIM4_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM4CLK)
      gptp->clock = STM32_TIM4CLK;
#else
      gptp->clock = STM32_TIMCLK1;
 80022fe:	9b01      	ldr	r3, [sp, #4]
 8002300:	4a22      	ldr	r2, [pc, #136]	@ (800238c <gpt_lld_start+0xdc>)
 8002302:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8002304:	9b01      	ldr	r3, [sp, #4]
 8002306:	689a      	ldr	r2, [r3, #8]
 8002308:	9b01      	ldr	r3, [sp, #4]
 800230a:	685b      	ldr	r3, [r3, #4]
 800230c:	681b      	ldr	r3, [r3, #0]
 800230e:	fbb2 f3f3 	udiv	r3, r2, r3
 8002312:	b29b      	uxth	r3, r3
 8002314:	3b01      	subs	r3, #1
 8002316:	f8ad 300e 	strh.w	r3, [sp, #14]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
 800231a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800231e:	3301      	adds	r3, #1
 8002320:	461a      	mov	r2, r3
 8002322:	9b01      	ldr	r3, [sp, #4]
 8002324:	685b      	ldr	r3, [r3, #4]
 8002326:	681b      	ldr	r3, [r3, #0]
 8002328:	fb03 f202 	mul.w	r2, r3, r2
 800232c:	9b01      	ldr	r3, [sp, #4]
 800232e:	689b      	ldr	r3, [r3, #8]
 8002330:	429a      	cmp	r2, r3
 8002332:	bf14      	ite	ne
 8002334:	2301      	movne	r3, #1
 8002336:	2300      	moveq	r3, #0
 8002338:	b2db      	uxtb	r3, r3
 800233a:	2b00      	cmp	r3, #0
 800233c:	d002      	beq.n	8002344 <gpt_lld_start+0x94>
 800233e:	4814      	ldr	r0, [pc, #80]	@ (8002390 <gpt_lld_start+0xe0>)
 8002340:	f000 f9d6 	bl	80026f0 <chSysHalt>
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0U;                         /* Initially stopped.       */
 8002344:	9b01      	ldr	r3, [sp, #4]
 8002346:	68db      	ldr	r3, [r3, #12]
 8002348:	2200      	movs	r2, #0
 800234a:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 800234c:	9b01      	ldr	r3, [sp, #4]
 800234e:	685a      	ldr	r2, [r3, #4]
 8002350:	9b01      	ldr	r3, [sp, #4]
 8002352:	68db      	ldr	r3, [r3, #12]
 8002354:	6892      	ldr	r2, [r2, #8]
 8002356:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8002358:	9b01      	ldr	r3, [sp, #4]
 800235a:	68db      	ldr	r3, [r3, #12]
 800235c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 8002360:	629a      	str	r2, [r3, #40]	@ 0x28
  gptp->tim->SR   = 0U;                         /* Clear pending IRQs.      */
 8002362:	9b01      	ldr	r3, [sp, #4]
 8002364:	68db      	ldr	r3, [r3, #12]
 8002366:	2200      	movs	r2, #0
 8002368:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 800236a:	9b01      	ldr	r3, [sp, #4]
 800236c:	685b      	ldr	r3, [r3, #4]
 800236e:	68da      	ldr	r2, [r3, #12]
 8002370:	9b01      	ldr	r3, [sp, #4]
 8002372:	68db      	ldr	r3, [r3, #12]
 8002374:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002378:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 800237a:	bf00      	nop
 800237c:	b005      	add	sp, #20
 800237e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002382:	bf00      	nop
 8002384:	20000924 	.word	0x20000924
 8002388:	40021000 	.word	0x40021000
 800238c:	04c4b400 	.word	0x04c4b400
 8002390:	08005290 	.word	0x08005290
	...

080023a0 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 80023a0:	b082      	sub	sp, #8
 80023a2:	9001      	str	r0, [sp, #4]
 80023a4:	9100      	str	r1, [sp, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 80023a6:	9b01      	ldr	r3, [sp, #4]
 80023a8:	68db      	ldr	r3, [r3, #12]
 80023aa:	9a00      	ldr	r2, [sp, #0]
 80023ac:	3a01      	subs	r2, #1
 80023ae:	62da      	str	r2, [r3, #44]	@ 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 80023b0:	9b01      	ldr	r3, [sp, #4]
 80023b2:	68db      	ldr	r3, [r3, #12]
 80023b4:	2201      	movs	r2, #1
 80023b6:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0U;                          /* Reset counter.           */
 80023b8:	9b01      	ldr	r3, [sp, #4]
 80023ba:	68db      	ldr	r3, [r3, #12]
 80023bc:	2200      	movs	r2, #0
 80023be:	625a      	str	r2, [r3, #36]	@ 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 80023c0:	9b01      	ldr	r3, [sp, #4]
 80023c2:	68db      	ldr	r3, [r3, #12]
 80023c4:	2200      	movs	r2, #0
 80023c6:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 80023c8:	9b01      	ldr	r3, [sp, #4]
 80023ca:	685b      	ldr	r3, [r3, #4]
 80023cc:	685b      	ldr	r3, [r3, #4]
 80023ce:	2b00      	cmp	r3, #0
 80023d0:	d007      	beq.n	80023e2 <gpt_lld_start_timer+0x42>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 80023d2:	9b01      	ldr	r3, [sp, #4]
 80023d4:	68db      	ldr	r3, [r3, #12]
 80023d6:	68da      	ldr	r2, [r3, #12]
 80023d8:	9b01      	ldr	r3, [sp, #4]
 80023da:	68db      	ldr	r3, [r3, #12]
 80023dc:	f042 0201 	orr.w	r2, r2, #1
 80023e0:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 80023e2:	9b01      	ldr	r3, [sp, #4]
 80023e4:	68db      	ldr	r3, [r3, #12]
 80023e6:	2285      	movs	r2, #133	@ 0x85
 80023e8:	601a      	str	r2, [r3, #0]
}
 80023ea:	bf00      	nop
 80023ec:	b002      	add	sp, #8
 80023ee:	4770      	bx	lr

080023f0 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 80023f0:	b082      	sub	sp, #8
 80023f2:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1 = 0U;                          /* Initially stopped.       */
 80023f4:	9b01      	ldr	r3, [sp, #4]
 80023f6:	68db      	ldr	r3, [r3, #12]
 80023f8:	2200      	movs	r2, #0
 80023fa:	601a      	str	r2, [r3, #0]
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 80023fc:	9b01      	ldr	r3, [sp, #4]
 80023fe:	68db      	ldr	r3, [r3, #12]
 8002400:	2200      	movs	r2, #0
 8002402:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8002404:	9b01      	ldr	r3, [sp, #4]
 8002406:	68db      	ldr	r3, [r3, #12]
 8002408:	68da      	ldr	r2, [r3, #12]
 800240a:	9b01      	ldr	r3, [sp, #4]
 800240c:	68db      	ldr	r3, [r3, #12]
 800240e:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002412:	60da      	str	r2, [r3, #12]
}
 8002414:	bf00      	nop
 8002416:	b002      	add	sp, #8
 8002418:	4770      	bx	lr
 800241a:	bf00      	nop
 800241c:	0000      	movs	r0, r0
	...

08002420 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 8002420:	b500      	push	{lr}
 8002422:	b085      	sub	sp, #20
 8002424:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 8002426:	9b01      	ldr	r3, [sp, #4]
 8002428:	68db      	ldr	r3, [r3, #12]
 800242a:	691b      	ldr	r3, [r3, #16]
 800242c:	9303      	str	r3, [sp, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800242e:	9b01      	ldr	r3, [sp, #4]
 8002430:	68db      	ldr	r3, [r3, #12]
 8002432:	68db      	ldr	r3, [r3, #12]
 8002434:	b2db      	uxtb	r3, r3
 8002436:	9a03      	ldr	r2, [sp, #12]
 8002438:	4013      	ands	r3, r2
 800243a:	9303      	str	r3, [sp, #12]
  gptp->tim->SR = ~sr;
 800243c:	9b01      	ldr	r3, [sp, #4]
 800243e:	68db      	ldr	r3, [r3, #12]
 8002440:	9a03      	ldr	r2, [sp, #12]
 8002442:	43d2      	mvns	r2, r2
 8002444:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8002446:	9b03      	ldr	r3, [sp, #12]
 8002448:	f003 0301 	and.w	r3, r3, #1
 800244c:	2b00      	cmp	r3, #0
 800244e:	d013      	beq.n	8002478 <gpt_lld_serve_interrupt+0x58>
    _gpt_isr_invoke_cb(gptp);
 8002450:	9b01      	ldr	r3, [sp, #4]
 8002452:	781b      	ldrb	r3, [r3, #0]
 8002454:	2b04      	cmp	r3, #4
 8002456:	d105      	bne.n	8002464 <gpt_lld_serve_interrupt+0x44>
 8002458:	9b01      	ldr	r3, [sp, #4]
 800245a:	2202      	movs	r2, #2
 800245c:	701a      	strb	r2, [r3, #0]
 800245e:	9801      	ldr	r0, [sp, #4]
 8002460:	f7ff ffc6 	bl	80023f0 <gpt_lld_stop_timer>
 8002464:	9b01      	ldr	r3, [sp, #4]
 8002466:	685b      	ldr	r3, [r3, #4]
 8002468:	685b      	ldr	r3, [r3, #4]
 800246a:	2b00      	cmp	r3, #0
 800246c:	d004      	beq.n	8002478 <gpt_lld_serve_interrupt+0x58>
 800246e:	9b01      	ldr	r3, [sp, #4]
 8002470:	685b      	ldr	r3, [r3, #4]
 8002472:	685b      	ldr	r3, [r3, #4]
 8002474:	9801      	ldr	r0, [sp, #4]
 8002476:	4798      	blx	r3
  }
}
 8002478:	bf00      	nop
 800247a:	b005      	add	sp, #20
 800247c:	f85d fb04 	ldr.w	pc, [sp], #4

08002480 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8002480:	b082      	sub	sp, #8
 8002482:	9001      	str	r0, [sp, #4]
 8002484:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8002486:	9b00      	ldr	r3, [sp, #0]
 8002488:	685a      	ldr	r2, [r3, #4]
 800248a:	9b01      	ldr	r3, [sp, #4]
 800248c:	605a      	str	r2, [r3, #4]
  gpiop->ASCR    = config->ascr;
 800248e:	9b00      	ldr	r3, [sp, #0]
 8002490:	69da      	ldr	r2, [r3, #28]
 8002492:	9b01      	ldr	r3, [sp, #4]
 8002494:	62da      	str	r2, [r3, #44]	@ 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8002496:	9b00      	ldr	r3, [sp, #0]
 8002498:	689a      	ldr	r2, [r3, #8]
 800249a:	9b01      	ldr	r3, [sp, #4]
 800249c:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800249e:	9b00      	ldr	r3, [sp, #0]
 80024a0:	68da      	ldr	r2, [r3, #12]
 80024a2:	9b01      	ldr	r3, [sp, #4]
 80024a4:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80024a6:	9b00      	ldr	r3, [sp, #0]
 80024a8:	691a      	ldr	r2, [r3, #16]
 80024aa:	9b01      	ldr	r3, [sp, #4]
 80024ac:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80024ae:	9b00      	ldr	r3, [sp, #0]
 80024b0:	695a      	ldr	r2, [r3, #20]
 80024b2:	9b01      	ldr	r3, [sp, #4]
 80024b4:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80024b6:	9b00      	ldr	r3, [sp, #0]
 80024b8:	699a      	ldr	r2, [r3, #24]
 80024ba:	9b01      	ldr	r3, [sp, #4]
 80024bc:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 80024be:	9b00      	ldr	r3, [sp, #0]
 80024c0:	681a      	ldr	r2, [r3, #0]
 80024c2:	9b01      	ldr	r3, [sp, #4]
 80024c4:	601a      	str	r2, [r3, #0]
  gpiop->LOCKR   = config->lockr;
 80024c6:	9b00      	ldr	r3, [sp, #0]
 80024c8:	6a1a      	ldr	r2, [r3, #32]
 80024ca:	9b01      	ldr	r3, [sp, #4]
 80024cc:	61da      	str	r2, [r3, #28]
}
 80024ce:	bf00      	nop
 80024d0:	b002      	add	sp, #8
 80024d2:	4770      	bx	lr
	...

080024e0 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 80024e0:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB2(STM32_GPIO_EN_MASK);
 80024e2:	4b1f      	ldr	r3, [pc, #124]	@ (8002560 <stm32_gpio_init+0x80>)
 80024e4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80024e6:	4a1e      	ldr	r2, [pc, #120]	@ (8002560 <stm32_gpio_init+0x80>)
 80024e8:	f043 03ff 	orr.w	r3, r3, #255	@ 0xff
 80024ec:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80024ee:	4b1c      	ldr	r3, [pc, #112]	@ (8002560 <stm32_gpio_init+0x80>)
 80024f0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80024f2:	4a1b      	ldr	r2, [pc, #108]	@ (8002560 <stm32_gpio_init+0x80>)
 80024f4:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 80024f8:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80024fa:	4b19      	ldr	r3, [pc, #100]	@ (8002560 <stm32_gpio_init+0x80>)
 80024fc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 80024fe:	4b18      	ldr	r3, [pc, #96]	@ (8002560 <stm32_gpio_init+0x80>)
 8002500:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002502:	4a17      	ldr	r2, [pc, #92]	@ (8002560 <stm32_gpio_init+0x80>)
 8002504:	f043 03ff 	orr.w	r3, r3, #255	@ 0xff
 8002508:	64d3      	str	r3, [r2, #76]	@ 0x4c
 800250a:	4b15      	ldr	r3, [pc, #84]	@ (8002560 <stm32_gpio_init+0x80>)
 800250c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800250e:	4a14      	ldr	r2, [pc, #80]	@ (8002560 <stm32_gpio_init+0x80>)
 8002510:	f043 03ff 	orr.w	r3, r3, #255	@ 0xff
 8002514:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8002516:	4b12      	ldr	r3, [pc, #72]	@ (8002560 <stm32_gpio_init+0x80>)
 8002518:	6edb      	ldr	r3, [r3, #108]	@ 0x6c

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 800251a:	4912      	ldr	r1, [pc, #72]	@ (8002564 <stm32_gpio_init+0x84>)
 800251c:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8002520:	f7ff ffae 	bl	8002480 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8002524:	4910      	ldr	r1, [pc, #64]	@ (8002568 <stm32_gpio_init+0x88>)
 8002526:	4811      	ldr	r0, [pc, #68]	@ (800256c <stm32_gpio_init+0x8c>)
 8002528:	f7ff ffaa 	bl	8002480 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 800252c:	4910      	ldr	r1, [pc, #64]	@ (8002570 <stm32_gpio_init+0x90>)
 800252e:	4811      	ldr	r0, [pc, #68]	@ (8002574 <stm32_gpio_init+0x94>)
 8002530:	f7ff ffa6 	bl	8002480 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8002534:	4910      	ldr	r1, [pc, #64]	@ (8002578 <stm32_gpio_init+0x98>)
 8002536:	4811      	ldr	r0, [pc, #68]	@ (800257c <stm32_gpio_init+0x9c>)
 8002538:	f7ff ffa2 	bl	8002480 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 800253c:	4910      	ldr	r1, [pc, #64]	@ (8002580 <stm32_gpio_init+0xa0>)
 800253e:	4811      	ldr	r0, [pc, #68]	@ (8002584 <stm32_gpio_init+0xa4>)
 8002540:	f7ff ff9e 	bl	8002480 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 8002544:	4910      	ldr	r1, [pc, #64]	@ (8002588 <stm32_gpio_init+0xa8>)
 8002546:	4811      	ldr	r0, [pc, #68]	@ (800258c <stm32_gpio_init+0xac>)
 8002548:	f7ff ff9a 	bl	8002480 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 800254c:	4910      	ldr	r1, [pc, #64]	@ (8002590 <stm32_gpio_init+0xb0>)
 800254e:	4811      	ldr	r0, [pc, #68]	@ (8002594 <stm32_gpio_init+0xb4>)
 8002550:	f7ff ff96 	bl	8002480 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8002554:	4910      	ldr	r1, [pc, #64]	@ (8002598 <stm32_gpio_init+0xb8>)
 8002556:	4811      	ldr	r0, [pc, #68]	@ (800259c <stm32_gpio_init+0xbc>)
 8002558:	f7ff ff92 	bl	8002480 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 800255c:	bf00      	nop
 800255e:	bd08      	pop	{r3, pc}
 8002560:	40021000 	.word	0x40021000
 8002564:	080052a0 	.word	0x080052a0
 8002568:	080052c4 	.word	0x080052c4
 800256c:	48000400 	.word	0x48000400
 8002570:	080052e8 	.word	0x080052e8
 8002574:	48000800 	.word	0x48000800
 8002578:	0800530c 	.word	0x0800530c
 800257c:	48000c00 	.word	0x48000c00
 8002580:	08005330 	.word	0x08005330
 8002584:	48001000 	.word	0x48001000
 8002588:	08005354 	.word	0x08005354
 800258c:	48001400 	.word	0x48001400
 8002590:	08005378 	.word	0x08005378
 8002594:	48001800 	.word	0x48001800
 8002598:	0800539c 	.word	0x0800539c
 800259c:	48001c00 	.word	0x48001c00

080025a0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80025a0:	b508      	push	{r3, lr}

  stm32_gpio_init();
 80025a2:	f7ff ff9d 	bl	80024e0 <stm32_gpio_init>
  stm32_clock_init();
 80025a6:	f7fe fda3 	bl	80010f0 <stm32_clock_init>
}
 80025aa:	bf00      	nop
 80025ac:	bd08      	pop	{r3, pc}
 80025ae:	bf00      	nop

080025b0 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 80025b0:	bf00      	nop
 80025b2:	4770      	bx	lr
	...

080025c0 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 80025c0:	b500      	push	{lr}
 80025c2:	b08b      	sub	sp, #44	@ 0x2c
 80025c4:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 80025c6:	9b01      	ldr	r3, [sp, #4]
 80025c8:	2200      	movs	r2, #0
 80025ca:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 80025cc:	ab02      	add	r3, sp, #8
 80025ce:	4618      	mov	r0, r3
 80025d0:	f001 fd8e 	bl	80040f0 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 80025d4:	2304      	movs	r3, #4
 80025d6:	9309      	str	r3, [sp, #36]	@ 0x24
  do {
    chTMStartMeasurementX(&tm);
 80025d8:	ab02      	add	r3, sp, #8
 80025da:	4618      	mov	r0, r3
 80025dc:	f001 fda8 	bl	8004130 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 80025e0:	ab02      	add	r3, sp, #8
 80025e2:	4618      	mov	r0, r3
 80025e4:	f001 fdb4 	bl	8004150 <chTMStopMeasurementX>
    i--;
 80025e8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80025ea:	3b01      	subs	r3, #1
 80025ec:	9309      	str	r3, [sp, #36]	@ 0x24
  } while (i > 0U);
 80025ee:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80025f0:	2b00      	cmp	r3, #0
 80025f2:	d1f1      	bne.n	80025d8 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
 80025f4:	9a02      	ldr	r2, [sp, #8]
 80025f6:	9b01      	ldr	r3, [sp, #4]
 80025f8:	601a      	str	r2, [r3, #0]
}
 80025fa:	bf00      	nop
 80025fc:	b00b      	add	sp, #44	@ 0x2c
 80025fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8002602:	bf00      	nop
	...

08002610 <chSysUnlock.lto_priv.5>:
static inline void chSysUnlock(void) {
 8002610:	b500      	push	{lr}
 8002612:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8002614:	f000 f91c 	bl	8002850 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8002618:	4b12      	ldr	r3, [pc, #72]	@ (8002664 <chSysUnlock.lto_priv.5+0x54>)
 800261a:	681b      	ldr	r3, [r3, #0]
 800261c:	4a11      	ldr	r2, [pc, #68]	@ (8002664 <chSysUnlock.lto_priv.5+0x54>)
 800261e:	4293      	cmp	r3, r2
 8002620:	bf14      	ite	ne
 8002622:	2301      	movne	r3, #1
 8002624:	2300      	moveq	r3, #0
 8002626:	b2db      	uxtb	r3, r3
 8002628:	2b00      	cmp	r3, #0
 800262a:	d00f      	beq.n	800264c <chSysUnlock.lto_priv.5+0x3c>
 800262c:	4b0d      	ldr	r3, [pc, #52]	@ (8002664 <chSysUnlock.lto_priv.5+0x54>)
 800262e:	68db      	ldr	r3, [r3, #12]
 8002630:	689a      	ldr	r2, [r3, #8]
 8002632:	4b0c      	ldr	r3, [pc, #48]	@ (8002664 <chSysUnlock.lto_priv.5+0x54>)
 8002634:	681b      	ldr	r3, [r3, #0]
 8002636:	689b      	ldr	r3, [r3, #8]
 8002638:	429a      	cmp	r2, r3
 800263a:	bf34      	ite	cc
 800263c:	2301      	movcc	r3, #1
 800263e:	2300      	movcs	r3, #0
 8002640:	b2db      	uxtb	r3, r3
 8002642:	2b00      	cmp	r3, #0
 8002644:	d002      	beq.n	800264c <chSysUnlock.lto_priv.5+0x3c>
 8002646:	4808      	ldr	r0, [pc, #32]	@ (8002668 <chSysUnlock.lto_priv.5+0x58>)
 8002648:	f000 f852 	bl	80026f0 <chSysHalt>
 800264c:	2300      	movs	r3, #0
 800264e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002650:	9b01      	ldr	r3, [sp, #4]
 8002652:	f383 8811 	msr	BASEPRI, r3
}
 8002656:	bf00      	nop
}
 8002658:	bf00      	nop
}
 800265a:	bf00      	nop
 800265c:	b003      	add	sp, #12
 800265e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002662:	bf00      	nop
 8002664:	20000940 	.word	0x20000940
 8002668:	0800543c 	.word	0x0800543c
 800266c:	00000000 	.word	0x00000000

08002670 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 8002670:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 8002672:	f002 f89d 	bl	80047b0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8002676:	f002 f90b 	bl	8004890 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 800267a:	f002 fad1 	bl	8004c20 <__factory_init>
#endif
}
 800267e:	bf00      	nop
 8002680:	bd08      	pop	{r3, pc}
 8002682:	bf00      	nop
	...

08002690 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 8002690:	b500      	push	{lr}
 8002692:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8002694:	4b11      	ldr	r3, [pc, #68]	@ (80026dc <chSysInit+0x4c>)
 8002696:	2201      	movs	r2, #1
 8002698:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 800269a:	2300      	movs	r3, #0
 800269c:	9301      	str	r3, [sp, #4]
 800269e:	e008      	b.n	80026b2 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
 80026a0:	4a0e      	ldr	r2, [pc, #56]	@ (80026dc <chSysInit+0x4c>)
 80026a2:	9b01      	ldr	r3, [sp, #4]
 80026a4:	009b      	lsls	r3, r3, #2
 80026a6:	4413      	add	r3, r2
 80026a8:	2200      	movs	r2, #0
 80026aa:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80026ac:	9b01      	ldr	r3, [sp, #4]
 80026ae:	3301      	adds	r3, #1
 80026b0:	9301      	str	r3, [sp, #4]
 80026b2:	9b01      	ldr	r3, [sp, #4]
 80026b4:	2b00      	cmp	r3, #0
 80026b6:	d0f3      	beq.n	80026a0 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 80026b8:	4809      	ldr	r0, [pc, #36]	@ (80026e0 <chSysInit+0x50>)
 80026ba:	f7ff ff81 	bl	80025c0 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 80026be:	f7ff ffd7 	bl	8002670 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 80026c2:	4908      	ldr	r1, [pc, #32]	@ (80026e4 <chSysInit+0x54>)
 80026c4:	4808      	ldr	r0, [pc, #32]	@ (80026e8 <chSysInit+0x58>)
 80026c6:	f001 f8eb 	bl	80038a0 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 80026ca:	4b04      	ldr	r3, [pc, #16]	@ (80026dc <chSysInit+0x4c>)
 80026cc:	2202      	movs	r2, #2
 80026ce:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 80026d0:	f7ff ff9e 	bl	8002610 <chSysUnlock.lto_priv.5>
}
 80026d4:	bf00      	nop
 80026d6:	b003      	add	sp, #12
 80026d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80026dc:	20000934 	.word	0x20000934
 80026e0:	2000093c 	.word	0x2000093c
 80026e4:	08005428 	.word	0x08005428
 80026e8:	20000940 	.word	0x20000940
 80026ec:	00000000 	.word	0x00000000

080026f0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 80026f0:	b082      	sub	sp, #8
 80026f2:	9001      	str	r0, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 80026f4:	b672      	cpsid	i
}
 80026f6:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 80026f8:	bf00      	nop

  /* Logging the event.*/
  __trace_halt(reason);

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 80026fa:	4a04      	ldr	r2, [pc, #16]	@ (800270c <chSysHalt+0x1c>)
 80026fc:	9b01      	ldr	r3, [sp, #4]
 80026fe:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8002702:	4b03      	ldr	r3, [pc, #12]	@ (8002710 <chSysHalt+0x20>)
 8002704:	2203      	movs	r2, #3
 8002706:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
     asm volatile ("nop");
 8002708:	bf00      	nop
 800270a:	e7fd      	b.n	8002708 <chSysHalt+0x18>
 800270c:	20000940 	.word	0x20000940
 8002710:	20000934 	.word	0x20000934
	...

08002720 <chSysGetIdleThreadX>:
 *
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
 8002720:	b500      	push	{lr}
 8002722:	b083      	sub	sp, #12
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8002724:	4b09      	ldr	r3, [pc, #36]	@ (800274c <chSysGetIdleThreadX+0x2c>)
 8002726:	685b      	ldr	r3, [r3, #4]
 8002728:	9301      	str	r3, [sp, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 800272a:	9b01      	ldr	r3, [sp, #4]
 800272c:	689b      	ldr	r3, [r3, #8]
 800272e:	2b01      	cmp	r3, #1
 8002730:	bf14      	ite	ne
 8002732:	2301      	movne	r3, #1
 8002734:	2300      	moveq	r3, #0
 8002736:	b2db      	uxtb	r3, r3
 8002738:	2b00      	cmp	r3, #0
 800273a:	d002      	beq.n	8002742 <chSysGetIdleThreadX+0x22>
 800273c:	4804      	ldr	r0, [pc, #16]	@ (8002750 <chSysGetIdleThreadX+0x30>)
 800273e:	f7ff ffd7 	bl	80026f0 <chSysHalt>

  return tp;
 8002742:	9b01      	ldr	r3, [sp, #4]
}
 8002744:	4618      	mov	r0, r3
 8002746:	b003      	add	sp, #12
 8002748:	f85d fb04 	ldr.w	pc, [sp], #4
 800274c:	20000940 	.word	0x20000940
 8002750:	08005448 	.word	0x08005448
	...

08002760 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002760:	b508      	push	{r3, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 8002762:	f000 f965 	bl	8002a30 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8002766:	f000 fc83 	bl	8003070 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800276a:	bf00      	nop
 800276c:	bd08      	pop	{r3, pc}
 800276e:	bf00      	nop

08002770 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 8002770:	b084      	sub	sp, #16
 8002772:	9003      	str	r0, [sp, #12]
 8002774:	9102      	str	r1, [sp, #8]
 8002776:	9201      	str	r2, [sp, #4]

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8002778:	9a03      	ldr	r2, [sp, #12]
 800277a:	9b02      	ldr	r3, [sp, #8]
 800277c:	1ad2      	subs	r2, r2, r3
                ((rtcnt_t)end - (rtcnt_t)start));
 800277e:	9901      	ldr	r1, [sp, #4]
 8002780:	9b02      	ldr	r3, [sp, #8]
 8002782:	1acb      	subs	r3, r1, r3
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8002784:	429a      	cmp	r2, r3
 8002786:	bf34      	ite	cc
 8002788:	2301      	movcc	r3, #1
 800278a:	2300      	movcs	r3, #0
 800278c:	b2db      	uxtb	r3, r3
}
 800278e:	4618      	mov	r0, r3
 8002790:	b004      	add	sp, #16
 8002792:	4770      	bx	lr
	...

080027a0 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 80027a0:	b500      	push	{lr}
 80027a2:	b085      	sub	sp, #20
 80027a4:	9001      	str	r0, [sp, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80027a6:	4b0b      	ldr	r3, [pc, #44]	@ (80027d4 <chSysPolledDelayX+0x34>)
 80027a8:	685b      	ldr	r3, [r3, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 80027aa:	9303      	str	r3, [sp, #12]
  rtcnt_t end  = start + cycles;
 80027ac:	9a03      	ldr	r2, [sp, #12]
 80027ae:	9b01      	ldr	r3, [sp, #4]
 80027b0:	4413      	add	r3, r2
 80027b2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80027b4:	bf00      	nop
 80027b6:	4b07      	ldr	r3, [pc, #28]	@ (80027d4 <chSysPolledDelayX+0x34>)
 80027b8:	685b      	ldr	r3, [r3, #4]
 80027ba:	9a02      	ldr	r2, [sp, #8]
 80027bc:	9903      	ldr	r1, [sp, #12]
 80027be:	4618      	mov	r0, r3
 80027c0:	f7ff ffd6 	bl	8002770 <chSysIsCounterWithinX>
 80027c4:	4603      	mov	r3, r0
 80027c6:	2b00      	cmp	r3, #0
 80027c8:	d1f5      	bne.n	80027b6 <chSysPolledDelayX+0x16>
  }
}
 80027ca:	bf00      	nop
 80027cc:	bf00      	nop
 80027ce:	b005      	add	sp, #20
 80027d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80027d4:	e0001000 	.word	0xe0001000
	...

080027e0 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 80027e0:	b082      	sub	sp, #8
 80027e2:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 80027e4:	4b04      	ldr	r3, [pc, #16]	@ (80027f8 <chRFCUCollectFaultsI+0x18>)
 80027e6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80027e8:	9b01      	ldr	r3, [sp, #4]
 80027ea:	4313      	orrs	r3, r2
 80027ec:	4a02      	ldr	r2, [pc, #8]	@ (80027f8 <chRFCUCollectFaultsI+0x18>)
 80027ee:	6353      	str	r3, [r2, #52]	@ 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 80027f0:	bf00      	nop
 80027f2:	b002      	add	sp, #8
 80027f4:	4770      	bx	lr
 80027f6:	bf00      	nop
 80027f8:	20000940 	.word	0x20000940
 80027fc:	00000000 	.word	0x00000000

08002800 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 8002800:	b500      	push	{lr}
 8002802:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002804:	4b10      	ldr	r3, [pc, #64]	@ (8002848 <__dbg_check_lock+0x48>)
 8002806:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002808:	9b01      	ldr	r3, [sp, #4]
 800280a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800280e:	2b00      	cmp	r3, #0
 8002810:	bf14      	ite	ne
 8002812:	2301      	movne	r3, #1
 8002814:	2300      	moveq	r3, #0
 8002816:	b2db      	uxtb	r3, r3
 8002818:	2b00      	cmp	r3, #0
 800281a:	d109      	bne.n	8002830 <__dbg_check_lock+0x30>
 800281c:	9b01      	ldr	r3, [sp, #4]
 800281e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002822:	2b00      	cmp	r3, #0
 8002824:	bf14      	ite	ne
 8002826:	2301      	movne	r3, #1
 8002828:	2300      	moveq	r3, #0
 800282a:	b2db      	uxtb	r3, r3
 800282c:	2b00      	cmp	r3, #0
 800282e:	d002      	beq.n	8002836 <__dbg_check_lock+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 8002830:	4806      	ldr	r0, [pc, #24]	@ (800284c <__dbg_check_lock+0x4c>)
 8002832:	f7ff ff5d 	bl	80026f0 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002836:	9b01      	ldr	r3, [sp, #4]
 8002838:	2201      	movs	r2, #1
 800283a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800283e:	bf00      	nop
 8002840:	b003      	add	sp, #12
 8002842:	f85d fb04 	ldr.w	pc, [sp], #4
 8002846:	bf00      	nop
 8002848:	20000940 	.word	0x20000940
 800284c:	080053c4 	.word	0x080053c4

08002850 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 8002850:	b500      	push	{lr}
 8002852:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002854:	4b10      	ldr	r3, [pc, #64]	@ (8002898 <__dbg_check_unlock+0x48>)
 8002856:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002858:	9b01      	ldr	r3, [sp, #4]
 800285a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800285e:	2b00      	cmp	r3, #0
 8002860:	bf14      	ite	ne
 8002862:	2301      	movne	r3, #1
 8002864:	2300      	moveq	r3, #0
 8002866:	b2db      	uxtb	r3, r3
 8002868:	2b00      	cmp	r3, #0
 800286a:	d109      	bne.n	8002880 <__dbg_check_unlock+0x30>
 800286c:	9b01      	ldr	r3, [sp, #4]
 800286e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002872:	2b00      	cmp	r3, #0
 8002874:	bfd4      	ite	le
 8002876:	2301      	movle	r3, #1
 8002878:	2300      	movgt	r3, #0
 800287a:	b2db      	uxtb	r3, r3
 800287c:	2b00      	cmp	r3, #0
 800287e:	d002      	beq.n	8002886 <__dbg_check_unlock+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 8002880:	4806      	ldr	r0, [pc, #24]	@ (800289c <__dbg_check_unlock+0x4c>)
 8002882:	f7ff ff35 	bl	80026f0 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002886:	9b01      	ldr	r3, [sp, #4]
 8002888:	2200      	movs	r2, #0
 800288a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800288e:	bf00      	nop
 8002890:	b003      	add	sp, #12
 8002892:	f85d fb04 	ldr.w	pc, [sp], #4
 8002896:	bf00      	nop
 8002898:	20000940 	.word	0x20000940
 800289c:	080053cc 	.word	0x080053cc

080028a0 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 80028a0:	b500      	push	{lr}
 80028a2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80028a4:	4b10      	ldr	r3, [pc, #64]	@ (80028e8 <__dbg_check_lock_from_isr+0x48>)
 80028a6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80028a8:	9b01      	ldr	r3, [sp, #4]
 80028aa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80028ae:	2b00      	cmp	r3, #0
 80028b0:	bfd4      	ite	le
 80028b2:	2301      	movle	r3, #1
 80028b4:	2300      	movgt	r3, #0
 80028b6:	b2db      	uxtb	r3, r3
 80028b8:	2b00      	cmp	r3, #0
 80028ba:	d109      	bne.n	80028d0 <__dbg_check_lock_from_isr+0x30>
 80028bc:	9b01      	ldr	r3, [sp, #4]
 80028be:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80028c2:	2b00      	cmp	r3, #0
 80028c4:	bf14      	ite	ne
 80028c6:	2301      	movne	r3, #1
 80028c8:	2300      	moveq	r3, #0
 80028ca:	b2db      	uxtb	r3, r3
 80028cc:	2b00      	cmp	r3, #0
 80028ce:	d002      	beq.n	80028d6 <__dbg_check_lock_from_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 80028d0:	4806      	ldr	r0, [pc, #24]	@ (80028ec <__dbg_check_lock_from_isr+0x4c>)
 80028d2:	f7ff ff0d 	bl	80026f0 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 80028d6:	9b01      	ldr	r3, [sp, #4]
 80028d8:	2201      	movs	r2, #1
 80028da:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 80028de:	bf00      	nop
 80028e0:	b003      	add	sp, #12
 80028e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80028e6:	bf00      	nop
 80028e8:	20000940 	.word	0x20000940
 80028ec:	080053d4 	.word	0x080053d4

080028f0 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 80028f0:	b500      	push	{lr}
 80028f2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80028f4:	4b10      	ldr	r3, [pc, #64]	@ (8002938 <__dbg_check_unlock_from_isr+0x48>)
 80028f6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80028f8:	9b01      	ldr	r3, [sp, #4]
 80028fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80028fe:	2b00      	cmp	r3, #0
 8002900:	bfd4      	ite	le
 8002902:	2301      	movle	r3, #1
 8002904:	2300      	movgt	r3, #0
 8002906:	b2db      	uxtb	r3, r3
 8002908:	2b00      	cmp	r3, #0
 800290a:	d109      	bne.n	8002920 <__dbg_check_unlock_from_isr+0x30>
 800290c:	9b01      	ldr	r3, [sp, #4]
 800290e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002912:	2b00      	cmp	r3, #0
 8002914:	bfd4      	ite	le
 8002916:	2301      	movle	r3, #1
 8002918:	2300      	movgt	r3, #0
 800291a:	b2db      	uxtb	r3, r3
 800291c:	2b00      	cmp	r3, #0
 800291e:	d002      	beq.n	8002926 <__dbg_check_unlock_from_isr+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 8002920:	4806      	ldr	r0, [pc, #24]	@ (800293c <__dbg_check_unlock_from_isr+0x4c>)
 8002922:	f7ff fee5 	bl	80026f0 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002926:	9b01      	ldr	r3, [sp, #4]
 8002928:	2200      	movs	r2, #0
 800292a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800292e:	bf00      	nop
 8002930:	b003      	add	sp, #12
 8002932:	f85d fb04 	ldr.w	pc, [sp], #4
 8002936:	bf00      	nop
 8002938:	20000940 	.word	0x20000940
 800293c:	080053dc 	.word	0x080053dc

08002940 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 8002940:	b500      	push	{lr}
 8002942:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8002944:	4b18      	ldr	r3, [pc, #96]	@ (80029a8 <__dbg_check_enter_isr+0x68>)
 8002946:	9303      	str	r3, [sp, #12]
 8002948:	2330      	movs	r3, #48	@ 0x30
 800294a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800294c:	9b02      	ldr	r3, [sp, #8]
 800294e:	f383 8811 	msr	BASEPRI, r3
}
 8002952:	bf00      	nop
}
 8002954:	bf00      	nop
}
 8002956:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002958:	9b03      	ldr	r3, [sp, #12]
 800295a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800295e:	0fdb      	lsrs	r3, r3, #31
 8002960:	b2db      	uxtb	r3, r3
 8002962:	2b00      	cmp	r3, #0
 8002964:	d109      	bne.n	800297a <__dbg_check_enter_isr+0x3a>
 8002966:	9b03      	ldr	r3, [sp, #12]
 8002968:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800296c:	2b00      	cmp	r3, #0
 800296e:	bf14      	ite	ne
 8002970:	2301      	movne	r3, #1
 8002972:	2300      	moveq	r3, #0
 8002974:	b2db      	uxtb	r3, r3
 8002976:	2b00      	cmp	r3, #0
 8002978:	d002      	beq.n	8002980 <__dbg_check_enter_isr+0x40>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 800297a:	480c      	ldr	r0, [pc, #48]	@ (80029ac <__dbg_check_enter_isr+0x6c>)
 800297c:	f7ff feb8 	bl	80026f0 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 8002980:	9b03      	ldr	r3, [sp, #12]
 8002982:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002986:	1c5a      	adds	r2, r3, #1
 8002988:	9b03      	ldr	r3, [sp, #12]
 800298a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 800298e:	2300      	movs	r3, #0
 8002990:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002992:	9b01      	ldr	r3, [sp, #4]
 8002994:	f383 8811 	msr	BASEPRI, r3
}
 8002998:	bf00      	nop
}
 800299a:	bf00      	nop
}
 800299c:	bf00      	nop
  port_unlock_from_isr();
}
 800299e:	bf00      	nop
 80029a0:	b005      	add	sp, #20
 80029a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80029a6:	bf00      	nop
 80029a8:	20000940 	.word	0x20000940
 80029ac:	080053e4 	.word	0x080053e4

080029b0 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 80029b0:	b500      	push	{lr}
 80029b2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80029b4:	4b19      	ldr	r3, [pc, #100]	@ (8002a1c <__dbg_check_leave_isr+0x6c>)
 80029b6:	9303      	str	r3, [sp, #12]
 80029b8:	2330      	movs	r3, #48	@ 0x30
 80029ba:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80029bc:	9b02      	ldr	r3, [sp, #8]
 80029be:	f383 8811 	msr	BASEPRI, r3
}
 80029c2:	bf00      	nop
}
 80029c4:	bf00      	nop
}
 80029c6:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80029c8:	9b03      	ldr	r3, [sp, #12]
 80029ca:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80029ce:	2b00      	cmp	r3, #0
 80029d0:	bfd4      	ite	le
 80029d2:	2301      	movle	r3, #1
 80029d4:	2300      	movgt	r3, #0
 80029d6:	b2db      	uxtb	r3, r3
 80029d8:	2b00      	cmp	r3, #0
 80029da:	d109      	bne.n	80029f0 <__dbg_check_leave_isr+0x40>
 80029dc:	9b03      	ldr	r3, [sp, #12]
 80029de:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80029e2:	2b00      	cmp	r3, #0
 80029e4:	bf14      	ite	ne
 80029e6:	2301      	movne	r3, #1
 80029e8:	2300      	moveq	r3, #0
 80029ea:	b2db      	uxtb	r3, r3
 80029ec:	2b00      	cmp	r3, #0
 80029ee:	d002      	beq.n	80029f6 <__dbg_check_leave_isr+0x46>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 80029f0:	480b      	ldr	r0, [pc, #44]	@ (8002a20 <__dbg_check_leave_isr+0x70>)
 80029f2:	f7ff fe7d 	bl	80026f0 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 80029f6:	9b03      	ldr	r3, [sp, #12]
 80029f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80029fc:	1e5a      	subs	r2, r3, #1
 80029fe:	9b03      	ldr	r3, [sp, #12]
 8002a00:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8002a04:	2300      	movs	r3, #0
 8002a06:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002a08:	9b01      	ldr	r3, [sp, #4]
 8002a0a:	f383 8811 	msr	BASEPRI, r3
}
 8002a0e:	bf00      	nop
}
 8002a10:	bf00      	nop
}
 8002a12:	bf00      	nop
  port_unlock_from_isr();
}
 8002a14:	bf00      	nop
 8002a16:	b005      	add	sp, #20
 8002a18:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a1c:	20000940 	.word	0x20000940
 8002a20:	080053ec 	.word	0x080053ec
	...

08002a30 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002a30:	b500      	push	{lr}
 8002a32:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002a34:	4b0c      	ldr	r3, [pc, #48]	@ (8002a68 <chDbgCheckClassI+0x38>)
 8002a36:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002a38:	9b01      	ldr	r3, [sp, #4]
 8002a3a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a3e:	0fdb      	lsrs	r3, r3, #31
 8002a40:	b2db      	uxtb	r3, r3
 8002a42:	2b00      	cmp	r3, #0
 8002a44:	d109      	bne.n	8002a5a <chDbgCheckClassI+0x2a>
 8002a46:	9b01      	ldr	r3, [sp, #4]
 8002a48:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002a4c:	2b00      	cmp	r3, #0
 8002a4e:	bfd4      	ite	le
 8002a50:	2301      	movle	r3, #1
 8002a52:	2300      	movgt	r3, #0
 8002a54:	b2db      	uxtb	r3, r3
 8002a56:	2b00      	cmp	r3, #0
 8002a58:	d002      	beq.n	8002a60 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 8002a5a:	4804      	ldr	r0, [pc, #16]	@ (8002a6c <chDbgCheckClassI+0x3c>)
 8002a5c:	f7ff fe48 	bl	80026f0 <chSysHalt>
  }
}
 8002a60:	bf00      	nop
 8002a62:	b003      	add	sp, #12
 8002a64:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a68:	20000940 	.word	0x20000940
 8002a6c:	080053f4 	.word	0x080053f4

08002a70 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002a70:	b500      	push	{lr}
 8002a72:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002a74:	4b0e      	ldr	r3, [pc, #56]	@ (8002ab0 <chDbgCheckClassS+0x40>)
 8002a76:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002a78:	9b01      	ldr	r3, [sp, #4]
 8002a7a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a7e:	2b00      	cmp	r3, #0
 8002a80:	bf14      	ite	ne
 8002a82:	2301      	movne	r3, #1
 8002a84:	2300      	moveq	r3, #0
 8002a86:	b2db      	uxtb	r3, r3
 8002a88:	2b00      	cmp	r3, #0
 8002a8a:	d109      	bne.n	8002aa0 <chDbgCheckClassS+0x30>
 8002a8c:	9b01      	ldr	r3, [sp, #4]
 8002a8e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002a92:	2b00      	cmp	r3, #0
 8002a94:	bfd4      	ite	le
 8002a96:	2301      	movle	r3, #1
 8002a98:	2300      	movgt	r3, #0
 8002a9a:	b2db      	uxtb	r3, r3
 8002a9c:	2b00      	cmp	r3, #0
 8002a9e:	d002      	beq.n	8002aa6 <chDbgCheckClassS+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 8002aa0:	4804      	ldr	r0, [pc, #16]	@ (8002ab4 <chDbgCheckClassS+0x44>)
 8002aa2:	f7ff fe25 	bl	80026f0 <chSysHalt>
  }
}
 8002aa6:	bf00      	nop
 8002aa8:	b003      	add	sp, #12
 8002aaa:	f85d fb04 	ldr.w	pc, [sp], #4
 8002aae:	bf00      	nop
 8002ab0:	20000940 	.word	0x20000940
 8002ab4:	080053fc 	.word	0x080053fc
	...

08002ac0 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8002ac0:	b082      	sub	sp, #8
 8002ac2:	9001      	str	r0, [sp, #4]
 8002ac4:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002ac6:	9a01      	ldr	r2, [sp, #4]
 8002ac8:	9b00      	ldr	r3, [sp, #0]
 8002aca:	4413      	add	r3, r2
}
 8002acc:	4618      	mov	r0, r3
 8002ace:	b002      	add	sp, #8
 8002ad0:	4770      	bx	lr
 8002ad2:	bf00      	nop
	...

08002ae0 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8002ae0:	b082      	sub	sp, #8
 8002ae2:	9001      	str	r0, [sp, #4]
 8002ae4:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002ae6:	9a00      	ldr	r2, [sp, #0]
 8002ae8:	9b01      	ldr	r3, [sp, #4]
 8002aea:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8002aec:	4618      	mov	r0, r3
 8002aee:	b002      	add	sp, #8
 8002af0:	4770      	bx	lr
 8002af2:	bf00      	nop
	...

08002b00 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8002b00:	b082      	sub	sp, #8
 8002b02:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8002b04:	9b01      	ldr	r3, [sp, #4]
 8002b06:	681b      	ldr	r3, [r3, #0]
 8002b08:	9a01      	ldr	r2, [sp, #4]
 8002b0a:	429a      	cmp	r2, r3
 8002b0c:	bf0c      	ite	eq
 8002b0e:	2301      	moveq	r3, #1
 8002b10:	2300      	movne	r3, #0
 8002b12:	b2db      	uxtb	r3, r3
}
 8002b14:	4618      	mov	r0, r3
 8002b16:	b002      	add	sp, #8
 8002b18:	4770      	bx	lr
 8002b1a:	bf00      	nop
 8002b1c:	0000      	movs	r0, r0
	...

08002b20 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8002b20:	b082      	sub	sp, #8
 8002b22:	9001      	str	r0, [sp, #4]
 8002b24:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8002b26:	9b01      	ldr	r3, [sp, #4]
 8002b28:	681b      	ldr	r3, [r3, #0]
 8002b2a:	9a00      	ldr	r2, [sp, #0]
 8002b2c:	429a      	cmp	r2, r3
 8002b2e:	bf0c      	ite	eq
 8002b30:	2301      	moveq	r3, #1
 8002b32:	2300      	movne	r3, #0
 8002b34:	b2db      	uxtb	r3, r3
}
 8002b36:	4618      	mov	r0, r3
 8002b38:	b002      	add	sp, #8
 8002b3a:	4770      	bx	lr
 8002b3c:	0000      	movs	r0, r0
	...

08002b40 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 8002b40:	b084      	sub	sp, #16
 8002b42:	9003      	str	r0, [sp, #12]
 8002b44:	9102      	str	r1, [sp, #8]
 8002b46:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002b48:	9b02      	ldr	r3, [sp, #8]
 8002b4a:	9a01      	ldr	r2, [sp, #4]
 8002b4c:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 8002b4e:	9b02      	ldr	r3, [sp, #8]
 8002b50:	9a03      	ldr	r2, [sp, #12]
 8002b52:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8002b54:	9b02      	ldr	r3, [sp, #8]
 8002b56:	685b      	ldr	r3, [r3, #4]
 8002b58:	681a      	ldr	r2, [r3, #0]
 8002b5a:	9b02      	ldr	r3, [sp, #8]
 8002b5c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 8002b5e:	9b02      	ldr	r3, [sp, #8]
 8002b60:	681b      	ldr	r3, [r3, #0]
 8002b62:	9a02      	ldr	r2, [sp, #8]
 8002b64:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 8002b66:	9b03      	ldr	r3, [sp, #12]
 8002b68:	9a02      	ldr	r2, [sp, #8]
 8002b6a:	601a      	str	r2, [r3, #0]
}
 8002b6c:	bf00      	nop
 8002b6e:	b004      	add	sp, #16
 8002b70:	4770      	bx	lr
 8002b72:	bf00      	nop
	...

08002b80 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 8002b80:	b084      	sub	sp, #16
 8002b82:	9003      	str	r0, [sp, #12]
 8002b84:	9102      	str	r1, [sp, #8]
 8002b86:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002b88:	9b02      	ldr	r3, [sp, #8]
 8002b8a:	9a01      	ldr	r2, [sp, #4]
 8002b8c:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 8002b8e:	9b02      	ldr	r3, [sp, #8]
 8002b90:	9a03      	ldr	r2, [sp, #12]
 8002b92:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8002b94:	9b02      	ldr	r3, [sp, #8]
 8002b96:	681b      	ldr	r3, [r3, #0]
 8002b98:	685a      	ldr	r2, [r3, #4]
 8002b9a:	9b02      	ldr	r3, [sp, #8]
 8002b9c:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 8002b9e:	9b02      	ldr	r3, [sp, #8]
 8002ba0:	685b      	ldr	r3, [r3, #4]
 8002ba2:	9a02      	ldr	r2, [sp, #8]
 8002ba4:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 8002ba6:	9b03      	ldr	r3, [sp, #12]
 8002ba8:	9a02      	ldr	r2, [sp, #8]
 8002baa:	605a      	str	r2, [r3, #4]
}
 8002bac:	bf00      	nop
 8002bae:	b004      	add	sp, #16
 8002bb0:	4770      	bx	lr
 8002bb2:	bf00      	nop
	...

08002bc0 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8002bc0:	b500      	push	{lr}
 8002bc2:	b087      	sub	sp, #28
 8002bc4:	9003      	str	r0, [sp, #12]
 8002bc6:	9102      	str	r1, [sp, #8]
 8002bc8:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 8002bca:	9b03      	ldr	r3, [sp, #12]
 8002bcc:	681b      	ldr	r3, [r3, #0]
 8002bce:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002bd0:	e013      	b.n	8002bfa <ch_dlist_insert+0x3a>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8002bd2:	9a05      	ldr	r2, [sp, #20]
 8002bd4:	9b02      	ldr	r3, [sp, #8]
 8002bd6:	429a      	cmp	r2, r3
 8002bd8:	bf0c      	ite	eq
 8002bda:	2301      	moveq	r3, #1
 8002bdc:	2300      	movne	r3, #0
 8002bde:	b2db      	uxtb	r3, r3
 8002be0:	2b00      	cmp	r3, #0
 8002be2:	d002      	beq.n	8002bea <ch_dlist_insert+0x2a>
 8002be4:	4813      	ldr	r0, [pc, #76]	@ (8002c34 <ch_dlist_insert+0x74>)
 8002be6:	f7ff fd83 	bl	80026f0 <chSysHalt>

    delta -= dlp->delta;
 8002bea:	9b05      	ldr	r3, [sp, #20]
 8002bec:	689b      	ldr	r3, [r3, #8]
 8002bee:	9a01      	ldr	r2, [sp, #4]
 8002bf0:	1ad3      	subs	r3, r2, r3
 8002bf2:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 8002bf4:	9b05      	ldr	r3, [sp, #20]
 8002bf6:	681b      	ldr	r3, [r3, #0]
 8002bf8:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002bfa:	9b05      	ldr	r3, [sp, #20]
 8002bfc:	689b      	ldr	r3, [r3, #8]
 8002bfe:	9a01      	ldr	r2, [sp, #4]
 8002c00:	429a      	cmp	r2, r3
 8002c02:	bf8c      	ite	hi
 8002c04:	2301      	movhi	r3, #1
 8002c06:	2300      	movls	r3, #0
 8002c08:	b2db      	uxtb	r3, r3
 8002c0a:	2b00      	cmp	r3, #0
 8002c0c:	d1e1      	bne.n	8002bd2 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 8002c0e:	9a01      	ldr	r2, [sp, #4]
 8002c10:	9902      	ldr	r1, [sp, #8]
 8002c12:	9805      	ldr	r0, [sp, #20]
 8002c14:	f7ff ffb4 	bl	8002b80 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8002c18:	9b05      	ldr	r3, [sp, #20]
 8002c1a:	689a      	ldr	r2, [r3, #8]
 8002c1c:	9b01      	ldr	r3, [sp, #4]
 8002c1e:	1ad2      	subs	r2, r2, r3
 8002c20:	9b05      	ldr	r3, [sp, #20]
 8002c22:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8002c24:	9b03      	ldr	r3, [sp, #12]
 8002c26:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8002c2a:	609a      	str	r2, [r3, #8]
}
 8002c2c:	bf00      	nop
 8002c2e:	b007      	add	sp, #28
 8002c30:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c34:	0800545c 	.word	0x0800545c
	...

08002c40 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8002c40:	b084      	sub	sp, #16
 8002c42:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8002c44:	9b01      	ldr	r3, [sp, #4]
 8002c46:	681b      	ldr	r3, [r3, #0]
 8002c48:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 8002c4a:	9b03      	ldr	r3, [sp, #12]
 8002c4c:	681a      	ldr	r2, [r3, #0]
 8002c4e:	9b01      	ldr	r3, [sp, #4]
 8002c50:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8002c52:	9b01      	ldr	r3, [sp, #4]
 8002c54:	681b      	ldr	r3, [r3, #0]
 8002c56:	9a01      	ldr	r2, [sp, #4]
 8002c58:	605a      	str	r2, [r3, #4]

  return dlp;
 8002c5a:	9b03      	ldr	r3, [sp, #12]
}
 8002c5c:	4618      	mov	r0, r3
 8002c5e:	b004      	add	sp, #16
 8002c60:	4770      	bx	lr
 8002c62:	bf00      	nop
	...

08002c70 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 8002c70:	b082      	sub	sp, #8
 8002c72:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 8002c74:	9b01      	ldr	r3, [sp, #4]
 8002c76:	685b      	ldr	r3, [r3, #4]
 8002c78:	9a01      	ldr	r2, [sp, #4]
 8002c7a:	6812      	ldr	r2, [r2, #0]
 8002c7c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 8002c7e:	9b01      	ldr	r3, [sp, #4]
 8002c80:	681b      	ldr	r3, [r3, #0]
 8002c82:	9a01      	ldr	r2, [sp, #4]
 8002c84:	6852      	ldr	r2, [r2, #4]
 8002c86:	605a      	str	r2, [r3, #4]

  return dlp;
 8002c88:	9b01      	ldr	r3, [sp, #4]
}
 8002c8a:	4618      	mov	r0, r3
 8002c8c:	b002      	add	sp, #8
 8002c8e:	4770      	bx	lr

08002c90 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8002c90:	b500      	push	{lr}
 8002c92:	b083      	sub	sp, #12
 8002c94:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8002c96:	9801      	ldr	r0, [sp, #4]
 8002c98:	f7fd fbda 	bl	8000450 <stStartAlarm>
}
 8002c9c:	bf00      	nop
 8002c9e:	b003      	add	sp, #12
 8002ca0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002cb0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8002cb0:	b508      	push	{r3, lr}

  stStopAlarm();
 8002cb2:	f7fd fbe5 	bl	8000480 <stStopAlarm>
}
 8002cb6:	bf00      	nop
 8002cb8:	bd08      	pop	{r3, pc}
 8002cba:	bf00      	nop
 8002cbc:	0000      	movs	r0, r0
	...

08002cc0 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8002cc0:	b500      	push	{lr}
 8002cc2:	b083      	sub	sp, #12
 8002cc4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8002cc6:	9801      	ldr	r0, [sp, #4]
 8002cc8:	f7fd fbe2 	bl	8000490 <stSetAlarm>
}
 8002ccc:	bf00      	nop
 8002cce:	b003      	add	sp, #12
 8002cd0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002ce0 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002ce0:	b508      	push	{r3, lr}

  return stGetCounter();
 8002ce2:	f7fd fbad 	bl	8000440 <stGetCounter>
 8002ce6:	4603      	mov	r3, r0
}
 8002ce8:	4618      	mov	r0, r3
 8002cea:	bd08      	pop	{r3, pc}
 8002cec:	0000      	movs	r0, r0
	...

08002cf0 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 8002cf0:	b500      	push	{lr}
 8002cf2:	b083      	sub	sp, #12
 8002cf4:	2330      	movs	r3, #48	@ 0x30
 8002cf6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002cf8:	9b01      	ldr	r3, [sp, #4]
 8002cfa:	f383 8811 	msr	BASEPRI, r3
}
 8002cfe:	bf00      	nop
}
 8002d00:	bf00      	nop
}
 8002d02:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002d04:	f7ff fdcc 	bl	80028a0 <__dbg_check_lock_from_isr>
}
 8002d08:	bf00      	nop
 8002d0a:	b003      	add	sp, #12
 8002d0c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d10 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
 8002d10:	b500      	push	{lr}
 8002d12:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002d14:	f7ff fdec 	bl	80028f0 <__dbg_check_unlock_from_isr>
 8002d18:	2300      	movs	r3, #0
 8002d1a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002d1c:	9b01      	ldr	r3, [sp, #4]
 8002d1e:	f383 8811 	msr	BASEPRI, r3
}
 8002d22:	bf00      	nop
}
 8002d24:	bf00      	nop
}
 8002d26:	bf00      	nop
}
 8002d28:	bf00      	nop
 8002d2a:	b003      	add	sp, #12
 8002d2c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d30 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002d30:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002d32:	f7ff ffd5 	bl	8002ce0 <port_timer_get_time.lto_priv.0>
 8002d36:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002d38:	4618      	mov	r0, r3
 8002d3a:	bd08      	pop	{r3, pc}
 8002d3c:	0000      	movs	r0, r0
	...

08002d40 <chVTIsArmedI.lto_priv.0>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8002d40:	b500      	push	{lr}
 8002d42:	b083      	sub	sp, #12
 8002d44:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002d46:	f7ff fe73 	bl	8002a30 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 8002d4a:	9b01      	ldr	r3, [sp, #4]
 8002d4c:	681b      	ldr	r3, [r3, #0]
 8002d4e:	2b00      	cmp	r3, #0
 8002d50:	bf14      	ite	ne
 8002d52:	2301      	movne	r3, #1
 8002d54:	2300      	moveq	r3, #0
 8002d56:	b2db      	uxtb	r3, r3
}
 8002d58:	4618      	mov	r0, r3
 8002d5a:	b003      	add	sp, #12
 8002d5c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d60 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 8002d60:	b500      	push	{lr}
 8002d62:	b087      	sub	sp, #28
 8002d64:	9001      	str	r0, [sp, #4]
 8002d66:	9100      	str	r1, [sp, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002d68:	2302      	movs	r3, #2
 8002d6a:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 8002d6c:	9a00      	ldr	r2, [sp, #0]
 8002d6e:	9b05      	ldr	r3, [sp, #20]
 8002d70:	429a      	cmp	r2, r3
 8002d72:	d201      	bcs.n	8002d78 <vt_set_alarm+0x18>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002d74:	9b05      	ldr	r3, [sp, #20]
 8002d76:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 8002d78:	9900      	ldr	r1, [sp, #0]
 8002d7a:	9801      	ldr	r0, [sp, #4]
 8002d7c:	f7ff fea0 	bl	8002ac0 <chTimeAddX>
 8002d80:	4603      	mov	r3, r0
 8002d82:	4618      	mov	r0, r3
 8002d84:	f7ff ff9c 	bl	8002cc0 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002d88:	f7ff ffd2 	bl	8002d30 <chVTGetSystemTimeX.lto_priv.0>
 8002d8c:	9004      	str	r0, [sp, #16]
    nowdelta = chTimeDiffX(now, newnow);
 8002d8e:	9904      	ldr	r1, [sp, #16]
 8002d90:	9801      	ldr	r0, [sp, #4]
 8002d92:	f7ff fea5 	bl	8002ae0 <chTimeDiffX.lto_priv.0>
 8002d96:	9003      	str	r0, [sp, #12]
    if (likely(nowdelta < delay)) {
 8002d98:	9a03      	ldr	r2, [sp, #12]
 8002d9a:	9b00      	ldr	r3, [sp, #0]
 8002d9c:	429a      	cmp	r2, r3
 8002d9e:	bf34      	ite	cc
 8002da0:	2301      	movcc	r3, #1
 8002da2:	2300      	movcs	r3, #0
 8002da4:	b2db      	uxtb	r3, r3
 8002da6:	2b00      	cmp	r3, #0
 8002da8:	d107      	bne.n	8002dba <vt_set_alarm+0x5a>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002daa:	9b05      	ldr	r3, [sp, #20]
 8002dac:	3301      	adds	r3, #1
 8002dae:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002db0:	9b04      	ldr	r3, [sp, #16]
 8002db2:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 8002db4:	9b05      	ldr	r3, [sp, #20]
 8002db6:	9300      	str	r3, [sp, #0]
  while (true) {
 8002db8:	e7de      	b.n	8002d78 <vt_set_alarm+0x18>
      break;
 8002dba:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002dbc:	9b05      	ldr	r3, [sp, #20]
 8002dbe:	2b02      	cmp	r3, #2
 8002dc0:	d902      	bls.n	8002dc8 <vt_set_alarm+0x68>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002dc2:	2001      	movs	r0, #1
 8002dc4:	f7ff fd0c 	bl	80027e0 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002dc8:	bf00      	nop
 8002dca:	b007      	add	sp, #28
 8002dcc:	f85d fb04 	ldr.w	pc, [sp], #4

08002dd0 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b087      	sub	sp, #28
 8002dd4:	9003      	str	r0, [sp, #12]
 8002dd6:	9102      	str	r1, [sp, #8]
 8002dd8:	9201      	str	r2, [sp, #4]
 8002dda:	9300      	str	r3, [sp, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8002ddc:	9b03      	ldr	r3, [sp, #12]
 8002dde:	9a01      	ldr	r2, [sp, #4]
 8002de0:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8002de2:	9b03      	ldr	r3, [sp, #12]
 8002de4:	9902      	ldr	r1, [sp, #8]
 8002de6:	9a00      	ldr	r2, [sp, #0]
 8002de8:	4618      	mov	r0, r3
 8002dea:	f7ff fea9 	bl	8002b40 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002dee:	2302      	movs	r3, #2
 8002df0:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8002df2:	9a00      	ldr	r2, [sp, #0]
 8002df4:	9b05      	ldr	r3, [sp, #20]
 8002df6:	429a      	cmp	r2, r3
 8002df8:	d201      	bcs.n	8002dfe <vt_insert_first+0x2e>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002dfa:	9b05      	ldr	r3, [sp, #20]
 8002dfc:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 8002dfe:	9b03      	ldr	r3, [sp, #12]
 8002e00:	68db      	ldr	r3, [r3, #12]
 8002e02:	9900      	ldr	r1, [sp, #0]
 8002e04:	4618      	mov	r0, r3
 8002e06:	f7ff fe5b 	bl	8002ac0 <chTimeAddX>
 8002e0a:	4603      	mov	r3, r0
 8002e0c:	4618      	mov	r0, r3
 8002e0e:	f7ff ff3f 	bl	8002c90 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002e12:	f7ff ff8d 	bl	8002d30 <chVTGetSystemTimeX.lto_priv.0>
 8002e16:	9004      	str	r0, [sp, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8002e18:	9904      	ldr	r1, [sp, #16]
 8002e1a:	9801      	ldr	r0, [sp, #4]
 8002e1c:	f7ff fe60 	bl	8002ae0 <chTimeDiffX.lto_priv.0>
 8002e20:	4602      	mov	r2, r0
 8002e22:	9b00      	ldr	r3, [sp, #0]
 8002e24:	4293      	cmp	r3, r2
 8002e26:	bf8c      	ite	hi
 8002e28:	2301      	movhi	r3, #1
 8002e2a:	2300      	movls	r3, #0
 8002e2c:	b2db      	uxtb	r3, r3
 8002e2e:	2b00      	cmp	r3, #0
 8002e30:	d10f      	bne.n	8002e52 <vt_insert_first+0x82>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002e32:	9b05      	ldr	r3, [sp, #20]
 8002e34:	3301      	adds	r3, #1
 8002e36:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8002e38:	9905      	ldr	r1, [sp, #20]
 8002e3a:	9801      	ldr	r0, [sp, #4]
 8002e3c:	f7ff fe40 	bl	8002ac0 <chTimeAddX>
 8002e40:	4603      	mov	r3, r0
 8002e42:	4618      	mov	r0, r3
 8002e44:	f7ff ff3c 	bl	8002cc0 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002e48:	9b04      	ldr	r3, [sp, #16]
 8002e4a:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 8002e4c:	9b05      	ldr	r3, [sp, #20]
 8002e4e:	9300      	str	r3, [sp, #0]
  while (true) {
 8002e50:	e7df      	b.n	8002e12 <vt_insert_first+0x42>
      break;
 8002e52:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002e54:	9b05      	ldr	r3, [sp, #20]
 8002e56:	2b02      	cmp	r3, #2
 8002e58:	d902      	bls.n	8002e60 <vt_insert_first+0x90>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002e5a:	2001      	movs	r0, #1
 8002e5c:	f7ff fcc0 	bl	80027e0 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002e60:	bf00      	nop
 8002e62:	b007      	add	sp, #28
 8002e64:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002e70 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 8002e70:	b500      	push	{lr}
 8002e72:	b089      	sub	sp, #36	@ 0x24
 8002e74:	9003      	str	r0, [sp, #12]
 8002e76:	9102      	str	r1, [sp, #8]
 8002e78:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 8002e7a:	f7ff ff59 	bl	8002d30 <chVTGetSystemTimeX.lto_priv.0>
 8002e7e:	9006      	str	r0, [sp, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002e80:	9b03      	ldr	r3, [sp, #12]
 8002e82:	4618      	mov	r0, r3
 8002e84:	f7ff fe3c 	bl	8002b00 <ch_dlist_isempty>
 8002e88:	4603      	mov	r3, r0
 8002e8a:	2b00      	cmp	r3, #0
 8002e8c:	d006      	beq.n	8002e9c <vt_enqueue+0x2c>

      vt_insert_first(vtlp, vtp, now, delay);
 8002e8e:	9b01      	ldr	r3, [sp, #4]
 8002e90:	9a06      	ldr	r2, [sp, #24]
 8002e92:	9902      	ldr	r1, [sp, #8]
 8002e94:	9803      	ldr	r0, [sp, #12]
 8002e96:	f7ff ff9b 	bl	8002dd0 <vt_insert_first>

      return;
 8002e9a:	e020      	b.n	8002ede <vt_enqueue+0x6e>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002e9c:	9b03      	ldr	r3, [sp, #12]
 8002e9e:	68db      	ldr	r3, [r3, #12]
 8002ea0:	9906      	ldr	r1, [sp, #24]
 8002ea2:	4618      	mov	r0, r3
 8002ea4:	f7ff fe1c 	bl	8002ae0 <chTimeDiffX.lto_priv.0>
 8002ea8:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
 8002eaa:	9a05      	ldr	r2, [sp, #20]
 8002eac:	9b01      	ldr	r3, [sp, #4]
 8002eae:	4413      	add	r3, r2
 8002eb0:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 8002eb2:	9a07      	ldr	r2, [sp, #28]
 8002eb4:	9b05      	ldr	r3, [sp, #20]
 8002eb6:	429a      	cmp	r2, r3
 8002eb8:	d201      	bcs.n	8002ebe <vt_enqueue+0x4e>
      delta = delay;
 8002eba:	9b01      	ldr	r3, [sp, #4]
 8002ebc:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8002ebe:	9b03      	ldr	r3, [sp, #12]
 8002ec0:	681b      	ldr	r3, [r3, #0]
 8002ec2:	689b      	ldr	r3, [r3, #8]
 8002ec4:	9a07      	ldr	r2, [sp, #28]
 8002ec6:	429a      	cmp	r2, r3
 8002ec8:	d203      	bcs.n	8002ed2 <vt_enqueue+0x62>

      vt_set_alarm(now, delay);
 8002eca:	9901      	ldr	r1, [sp, #4]
 8002ecc:	9806      	ldr	r0, [sp, #24]
 8002ece:	f7ff ff47 	bl	8002d60 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8002ed2:	9b03      	ldr	r3, [sp, #12]
 8002ed4:	9902      	ldr	r1, [sp, #8]
 8002ed6:	9a07      	ldr	r2, [sp, #28]
 8002ed8:	4618      	mov	r0, r3
 8002eda:	f7ff fe71 	bl	8002bc0 <ch_dlist_insert>
}
 8002ede:	b009      	add	sp, #36	@ 0x24
 8002ee0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002ef0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8002ef0:	b500      	push	{lr}
 8002ef2:	b087      	sub	sp, #28
 8002ef4:	9003      	str	r0, [sp, #12]
 8002ef6:	9102      	str	r1, [sp, #8]
 8002ef8:	9201      	str	r2, [sp, #4]
 8002efa:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002efc:	4b1a      	ldr	r3, [pc, #104]	@ (8002f68 <chVTDoSetI+0x78>)
 8002efe:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002f00:	f7ff fd96 	bl	8002a30 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002f04:	9b03      	ldr	r3, [sp, #12]
 8002f06:	2b00      	cmp	r3, #0
 8002f08:	bf0c      	ite	eq
 8002f0a:	2301      	moveq	r3, #1
 8002f0c:	2300      	movne	r3, #0
 8002f0e:	b2db      	uxtb	r3, r3
 8002f10:	2b00      	cmp	r3, #0
 8002f12:	d107      	bne.n	8002f24 <chVTDoSetI+0x34>
 8002f14:	9b01      	ldr	r3, [sp, #4]
 8002f16:	2b00      	cmp	r3, #0
 8002f18:	bf0c      	ite	eq
 8002f1a:	2301      	moveq	r3, #1
 8002f1c:	2300      	movne	r3, #0
 8002f1e:	b2db      	uxtb	r3, r3
 8002f20:	2b00      	cmp	r3, #0
 8002f22:	d001      	beq.n	8002f28 <chVTDoSetI+0x38>
 8002f24:	2301      	movs	r3, #1
 8002f26:	e000      	b.n	8002f2a <chVTDoSetI+0x3a>
 8002f28:	2300      	movs	r3, #0
 8002f2a:	2b00      	cmp	r3, #0
 8002f2c:	d107      	bne.n	8002f3e <chVTDoSetI+0x4e>
 8002f2e:	9b02      	ldr	r3, [sp, #8]
 8002f30:	2b00      	cmp	r3, #0
 8002f32:	bf0c      	ite	eq
 8002f34:	2301      	moveq	r3, #1
 8002f36:	2300      	movne	r3, #0
 8002f38:	b2db      	uxtb	r3, r3
 8002f3a:	2b00      	cmp	r3, #0
 8002f3c:	d002      	beq.n	8002f44 <chVTDoSetI+0x54>
 8002f3e:	480b      	ldr	r0, [pc, #44]	@ (8002f6c <chVTDoSetI+0x7c>)
 8002f40:	f7ff fbd6 	bl	80026f0 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8002f44:	9b03      	ldr	r3, [sp, #12]
 8002f46:	9a00      	ldr	r2, [sp, #0]
 8002f48:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 8002f4a:	9b03      	ldr	r3, [sp, #12]
 8002f4c:	9a01      	ldr	r2, [sp, #4]
 8002f4e:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8002f50:	9b03      	ldr	r3, [sp, #12]
 8002f52:	2200      	movs	r2, #0
 8002f54:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8002f56:	9a02      	ldr	r2, [sp, #8]
 8002f58:	9903      	ldr	r1, [sp, #12]
 8002f5a:	9805      	ldr	r0, [sp, #20]
 8002f5c:	f7ff ff88 	bl	8002e70 <vt_enqueue>
}
 8002f60:	bf00      	nop
 8002f62:	b007      	add	sp, #28
 8002f64:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f68:	20000950 	.word	0x20000950
 8002f6c:	0800546c 	.word	0x0800546c

08002f70 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8002f70:	b500      	push	{lr}
 8002f72:	b087      	sub	sp, #28
 8002f74:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002f76:	4b3a      	ldr	r3, [pc, #232]	@ (8003060 <chVTDoResetI+0xf0>)
 8002f78:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002f7a:	f7ff fd59 	bl	8002a30 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8002f7e:	9b01      	ldr	r3, [sp, #4]
 8002f80:	2b00      	cmp	r3, #0
 8002f82:	bf0c      	ite	eq
 8002f84:	2301      	moveq	r3, #1
 8002f86:	2300      	movne	r3, #0
 8002f88:	b2db      	uxtb	r3, r3
 8002f8a:	2b00      	cmp	r3, #0
 8002f8c:	d002      	beq.n	8002f94 <chVTDoResetI+0x24>
 8002f8e:	4835      	ldr	r0, [pc, #212]	@ (8003064 <chVTDoResetI+0xf4>)
 8002f90:	f7ff fbae 	bl	80026f0 <chSysHalt>
  chDbgAssert(chVTIsArmedI(vtp), "timer not armed");
 8002f94:	9801      	ldr	r0, [sp, #4]
 8002f96:	f7ff fed3 	bl	8002d40 <chVTIsArmedI.lto_priv.0>
 8002f9a:	4603      	mov	r3, r0
 8002f9c:	f083 0301 	eor.w	r3, r3, #1
 8002fa0:	b2db      	uxtb	r3, r3
 8002fa2:	2b00      	cmp	r3, #0
 8002fa4:	d002      	beq.n	8002fac <chVTDoResetI+0x3c>
 8002fa6:	482f      	ldr	r0, [pc, #188]	@ (8003064 <chVTDoResetI+0xf4>)
 8002fa8:	f7ff fba2 	bl	80026f0 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8002fac:	9b05      	ldr	r3, [sp, #20]
 8002fae:	9a01      	ldr	r2, [sp, #4]
 8002fb0:	4611      	mov	r1, r2
 8002fb2:	4618      	mov	r0, r3
 8002fb4:	f7ff fdb4 	bl	8002b20 <ch_dlist_isfirst>
 8002fb8:	4603      	mov	r3, r0
 8002fba:	f083 0301 	eor.w	r3, r3, #1
 8002fbe:	b2db      	uxtb	r3, r3
 8002fc0:	2b00      	cmp	r3, #0
 8002fc2:	d014      	beq.n	8002fee <chVTDoResetI+0x7e>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8002fc4:	9b01      	ldr	r3, [sp, #4]
 8002fc6:	4618      	mov	r0, r3
 8002fc8:	f7ff fe52 	bl	8002c70 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8002fcc:	9b01      	ldr	r3, [sp, #4]
 8002fce:	681b      	ldr	r3, [r3, #0]
 8002fd0:	6899      	ldr	r1, [r3, #8]
 8002fd2:	9b01      	ldr	r3, [sp, #4]
 8002fd4:	689a      	ldr	r2, [r3, #8]
 8002fd6:	9b01      	ldr	r3, [sp, #4]
 8002fd8:	681b      	ldr	r3, [r3, #0]
 8002fda:	440a      	add	r2, r1
 8002fdc:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8002fde:	9b01      	ldr	r3, [sp, #4]
 8002fe0:	2200      	movs	r2, #0
 8002fe2:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8002fe4:	9b05      	ldr	r3, [sp, #20]
 8002fe6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8002fea:	609a      	str	r2, [r3, #8]

    return;
 8002fec:	e035      	b.n	800305a <chVTDoResetI+0xea>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8002fee:	9b05      	ldr	r3, [sp, #20]
 8002ff0:	4618      	mov	r0, r3
 8002ff2:	f7ff fe25 	bl	8002c40 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8002ff6:	9b01      	ldr	r3, [sp, #4]
 8002ff8:	2200      	movs	r2, #0
 8002ffa:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002ffc:	9b05      	ldr	r3, [sp, #20]
 8002ffe:	4618      	mov	r0, r3
 8003000:	f7ff fd7e 	bl	8002b00 <ch_dlist_isempty>
 8003004:	4603      	mov	r3, r0
 8003006:	2b00      	cmp	r3, #0
 8003008:	d002      	beq.n	8003010 <chVTDoResetI+0xa0>

    port_timer_stop_alarm();
 800300a:	f7ff fe51 	bl	8002cb0 <port_timer_stop_alarm>

    return;
 800300e:	e024      	b.n	800305a <chVTDoResetI+0xea>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8003010:	9b05      	ldr	r3, [sp, #20]
 8003012:	681b      	ldr	r3, [r3, #0]
 8003014:	6899      	ldr	r1, [r3, #8]
 8003016:	9b01      	ldr	r3, [sp, #4]
 8003018:	689a      	ldr	r2, [r3, #8]
 800301a:	9b05      	ldr	r3, [sp, #20]
 800301c:	681b      	ldr	r3, [r3, #0]
 800301e:	440a      	add	r2, r1
 8003020:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 8003022:	f7ff fe85 	bl	8002d30 <chVTGetSystemTimeX.lto_priv.0>
 8003026:	9004      	str	r0, [sp, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003028:	9b05      	ldr	r3, [sp, #20]
 800302a:	68db      	ldr	r3, [r3, #12]
 800302c:	9904      	ldr	r1, [sp, #16]
 800302e:	4618      	mov	r0, r3
 8003030:	f7ff fd56 	bl	8002ae0 <chTimeDiffX.lto_priv.0>
 8003034:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8003036:	9b05      	ldr	r3, [sp, #20]
 8003038:	681b      	ldr	r3, [r3, #0]
 800303a:	689b      	ldr	r3, [r3, #8]
 800303c:	9a03      	ldr	r2, [sp, #12]
 800303e:	429a      	cmp	r2, r3
 8003040:	d20a      	bcs.n	8003058 <chVTDoResetI+0xe8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8003042:	9b05      	ldr	r3, [sp, #20]
 8003044:	681b      	ldr	r3, [r3, #0]
 8003046:	689a      	ldr	r2, [r3, #8]
 8003048:	9b03      	ldr	r3, [sp, #12]
 800304a:	1ad3      	subs	r3, r2, r3
 800304c:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 800304e:	9902      	ldr	r1, [sp, #8]
 8003050:	9804      	ldr	r0, [sp, #16]
 8003052:	f7ff fe85 	bl	8002d60 <vt_set_alarm>
 8003056:	e000      	b.n	800305a <chVTDoResetI+0xea>
    return;
 8003058:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800305a:	b007      	add	sp, #28
 800305c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003060:	20000950 	.word	0x20000950
 8003064:	08005478 	.word	0x08005478
	...

08003070 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8003070:	b500      	push	{lr}
 8003072:	b089      	sub	sp, #36	@ 0x24
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003074:	4b4f      	ldr	r3, [pc, #316]	@ (80031b4 <chVTDoTickI+0x144>)
 8003076:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8003078:	f7ff fcda 	bl	8002a30 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 800307c:	9b05      	ldr	r3, [sp, #20]
 800307e:	681b      	ldr	r3, [r3, #0]
 8003080:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 8003082:	f7ff fe55 	bl	8002d30 <chVTGetSystemTimeX.lto_priv.0>
 8003086:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003088:	9b05      	ldr	r3, [sp, #20]
 800308a:	68db      	ldr	r3, [r3, #12]
 800308c:	9903      	ldr	r1, [sp, #12]
 800308e:	4618      	mov	r0, r3
 8003090:	f7ff fd26 	bl	8002ae0 <chTimeDiffX.lto_priv.0>
 8003094:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 8003096:	9b04      	ldr	r3, [sp, #16]
 8003098:	689b      	ldr	r3, [r3, #8]
 800309a:	9a02      	ldr	r2, [sp, #8]
 800309c:	429a      	cmp	r2, r3
 800309e:	d369      	bcc.n	8003174 <chVTDoTickI+0x104>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 80030a0:	9b05      	ldr	r3, [sp, #20]
 80030a2:	68da      	ldr	r2, [r3, #12]
 80030a4:	9b04      	ldr	r3, [sp, #16]
 80030a6:	689b      	ldr	r3, [r3, #8]
 80030a8:	4619      	mov	r1, r3
 80030aa:	4610      	mov	r0, r2
 80030ac:	f7ff fd08 	bl	8002ac0 <chTimeAddX>
 80030b0:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
 80030b2:	9b05      	ldr	r3, [sp, #20]
 80030b4:	9a01      	ldr	r2, [sp, #4]
 80030b6:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 80030b8:	9b04      	ldr	r3, [sp, #16]
 80030ba:	4618      	mov	r0, r3
 80030bc:	f7ff fdd8 	bl	8002c70 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 80030c0:	9b04      	ldr	r3, [sp, #16]
 80030c2:	2200      	movs	r2, #0
 80030c4:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 80030c6:	9b05      	ldr	r3, [sp, #20]
 80030c8:	4618      	mov	r0, r3
 80030ca:	f7ff fd19 	bl	8002b00 <ch_dlist_isempty>
 80030ce:	4603      	mov	r3, r0
 80030d0:	2b00      	cmp	r3, #0
 80030d2:	d001      	beq.n	80030d8 <chVTDoTickI+0x68>
      port_timer_stop_alarm();
 80030d4:	f7ff fdec 	bl	8002cb0 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 80030d8:	f7ff fe1a 	bl	8002d10 <chSysUnlockFromISR.lto_priv.3>

    vtp->func(vtp, vtp->par);
 80030dc:	9b04      	ldr	r3, [sp, #16]
 80030de:	68db      	ldr	r3, [r3, #12]
 80030e0:	9a04      	ldr	r2, [sp, #16]
 80030e2:	6912      	ldr	r2, [r2, #16]
 80030e4:	4611      	mov	r1, r2
 80030e6:	9804      	ldr	r0, [sp, #16]
 80030e8:	4798      	blx	r3

    chSysLockFromISR();
 80030ea:	f7ff fe01 	bl	8002cf0 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 80030ee:	9b04      	ldr	r3, [sp, #16]
 80030f0:	695b      	ldr	r3, [r3, #20]
 80030f2:	2b00      	cmp	r3, #0
 80030f4:	bf14      	ite	ne
 80030f6:	2301      	movne	r3, #1
 80030f8:	2300      	moveq	r3, #0
 80030fa:	b2db      	uxtb	r3, r3
 80030fc:	2b00      	cmp	r3, #0
 80030fe:	d0bd      	beq.n	800307c <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8003100:	f7ff fe16 	bl	8002d30 <chVTGetSystemTimeX.lto_priv.0>
 8003104:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 8003106:	9903      	ldr	r1, [sp, #12]
 8003108:	9801      	ldr	r0, [sp, #4]
 800310a:	f7ff fce9 	bl	8002ae0 <chTimeDiffX.lto_priv.0>
 800310e:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8003110:	9b04      	ldr	r3, [sp, #16]
 8003112:	695b      	ldr	r3, [r3, #20]
 8003114:	9a02      	ldr	r2, [sp, #8]
 8003116:	429a      	cmp	r2, r3
 8003118:	d908      	bls.n	800312c <chVTDoTickI+0xbc>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
 800311a:	4827      	ldr	r0, [pc, #156]	@ (80031b8 <chVTDoTickI+0x148>)
 800311c:	f7ff fae8 	bl	80026f0 <chSysHalt>
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8003120:	2002      	movs	r0, #2
 8003122:	f7ff fb5d 	bl	80027e0 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8003126:	2300      	movs	r3, #0
 8003128:	9306      	str	r3, [sp, #24]
 800312a:	e004      	b.n	8003136 <chVTDoTickI+0xc6>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 800312c:	9b04      	ldr	r3, [sp, #16]
 800312e:	695a      	ldr	r2, [r3, #20]
 8003130:	9b02      	ldr	r3, [sp, #8]
 8003132:	1ad3      	subs	r3, r2, r3
 8003134:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8003136:	9b05      	ldr	r3, [sp, #20]
 8003138:	4618      	mov	r0, r3
 800313a:	f7ff fce1 	bl	8002b00 <ch_dlist_isempty>
 800313e:	4603      	mov	r3, r0
 8003140:	2b00      	cmp	r3, #0
 8003142:	d006      	beq.n	8003152 <chVTDoTickI+0xe2>

        vt_insert_first(vtlp, vtp, now, delay);
 8003144:	9b06      	ldr	r3, [sp, #24]
 8003146:	9a03      	ldr	r2, [sp, #12]
 8003148:	9904      	ldr	r1, [sp, #16]
 800314a:	9805      	ldr	r0, [sp, #20]
 800314c:	f7ff fe40 	bl	8002dd0 <vt_insert_first>

        return;
 8003150:	e02c      	b.n	80031ac <chVTDoTickI+0x13c>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8003152:	9a02      	ldr	r2, [sp, #8]
 8003154:	9b06      	ldr	r3, [sp, #24]
 8003156:	4413      	add	r3, r2
 8003158:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 800315a:	9a07      	ldr	r2, [sp, #28]
 800315c:	9b02      	ldr	r3, [sp, #8]
 800315e:	429a      	cmp	r2, r3
 8003160:	d201      	bcs.n	8003166 <chVTDoTickI+0xf6>
        delta = delay;
 8003162:	9b06      	ldr	r3, [sp, #24]
 8003164:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003166:	9b05      	ldr	r3, [sp, #20]
 8003168:	9904      	ldr	r1, [sp, #16]
 800316a:	9a07      	ldr	r2, [sp, #28]
 800316c:	4618      	mov	r0, r3
 800316e:	f7ff fd27 	bl	8002bc0 <ch_dlist_insert>
  while (true) {
 8003172:	e783      	b.n	800307c <chVTDoTickI+0xc>
      break;
 8003174:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003176:	9b05      	ldr	r3, [sp, #20]
 8003178:	4618      	mov	r0, r3
 800317a:	f7ff fcc1 	bl	8002b00 <ch_dlist_isempty>
 800317e:	4603      	mov	r3, r0
 8003180:	2b00      	cmp	r3, #0
 8003182:	d112      	bne.n	80031aa <chVTDoTickI+0x13a>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 8003184:	9b05      	ldr	r3, [sp, #20]
 8003186:	68da      	ldr	r2, [r3, #12]
 8003188:	9b02      	ldr	r3, [sp, #8]
 800318a:	441a      	add	r2, r3
 800318c:	9b05      	ldr	r3, [sp, #20]
 800318e:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 8003190:	9b04      	ldr	r3, [sp, #16]
 8003192:	689a      	ldr	r2, [r3, #8]
 8003194:	9b02      	ldr	r3, [sp, #8]
 8003196:	1ad2      	subs	r2, r2, r3
 8003198:	9b04      	ldr	r3, [sp, #16]
 800319a:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 800319c:	9b04      	ldr	r3, [sp, #16]
 800319e:	689b      	ldr	r3, [r3, #8]
 80031a0:	4619      	mov	r1, r3
 80031a2:	9803      	ldr	r0, [sp, #12]
 80031a4:	f7ff fddc 	bl	8002d60 <vt_set_alarm>
 80031a8:	e000      	b.n	80031ac <chVTDoTickI+0x13c>
    return;
 80031aa:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80031ac:	b009      	add	sp, #36	@ 0x24
 80031ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80031b2:	bf00      	nop
 80031b4:	20000950 	.word	0x20000950
 80031b8:	08005488 	.word	0x08005488
 80031bc:	00000000 	.word	0x00000000

080031c0 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80031c0:	b082      	sub	sp, #8
 80031c2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80031c4:	9b01      	ldr	r3, [sp, #4]
 80031c6:	685b      	ldr	r3, [r3, #4]
 80031c8:	9a01      	ldr	r2, [sp, #4]
 80031ca:	6812      	ldr	r2, [r2, #0]
 80031cc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	681b      	ldr	r3, [r3, #0]
 80031d2:	9a01      	ldr	r2, [sp, #4]
 80031d4:	6852      	ldr	r2, [r2, #4]
 80031d6:	605a      	str	r2, [r3, #4]
  return p;
 80031d8:	9b01      	ldr	r3, [sp, #4]
}
 80031da:	4618      	mov	r0, r3
 80031dc:	b002      	add	sp, #8
 80031de:	4770      	bx	lr

080031e0 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 80031e0:	b084      	sub	sp, #16
 80031e2:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 80031e4:	9b01      	ldr	r3, [sp, #4]
 80031e6:	681b      	ldr	r3, [r3, #0]
 80031e8:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 80031ea:	9b03      	ldr	r3, [sp, #12]
 80031ec:	681a      	ldr	r2, [r3, #0]
 80031ee:	9b01      	ldr	r3, [sp, #4]
 80031f0:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 80031f2:	9b01      	ldr	r3, [sp, #4]
 80031f4:	681b      	ldr	r3, [r3, #0]
 80031f6:	9a01      	ldr	r2, [sp, #4]
 80031f8:	605a      	str	r2, [r3, #4]
  return p;
 80031fa:	9b03      	ldr	r3, [sp, #12]
}
 80031fc:	4618      	mov	r0, r3
 80031fe:	b004      	add	sp, #16
 8003200:	4770      	bx	lr
 8003202:	bf00      	nop
	...

08003210 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8003210:	b082      	sub	sp, #8
 8003212:	9001      	str	r0, [sp, #4]
 8003214:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003216:	9b01      	ldr	r3, [sp, #4]
 8003218:	681b      	ldr	r3, [r3, #0]
 800321a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 800321c:	9b01      	ldr	r3, [sp, #4]
 800321e:	689a      	ldr	r2, [r3, #8]
 8003220:	9b00      	ldr	r3, [sp, #0]
 8003222:	689b      	ldr	r3, [r3, #8]
 8003224:	429a      	cmp	r2, r3
 8003226:	bf2c      	ite	cs
 8003228:	2301      	movcs	r3, #1
 800322a:	2300      	movcc	r3, #0
 800322c:	b2db      	uxtb	r3, r3
 800322e:	2b00      	cmp	r3, #0
 8003230:	d1f1      	bne.n	8003216 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8003232:	9b00      	ldr	r3, [sp, #0]
 8003234:	9a01      	ldr	r2, [sp, #4]
 8003236:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003238:	9b01      	ldr	r3, [sp, #4]
 800323a:	685a      	ldr	r2, [r3, #4]
 800323c:	9b00      	ldr	r3, [sp, #0]
 800323e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003240:	9b00      	ldr	r3, [sp, #0]
 8003242:	685b      	ldr	r3, [r3, #4]
 8003244:	9a00      	ldr	r2, [sp, #0]
 8003246:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003248:	9b01      	ldr	r3, [sp, #4]
 800324a:	9a00      	ldr	r2, [sp, #0]
 800324c:	605a      	str	r2, [r3, #4]
  return p;
 800324e:	9b00      	ldr	r3, [sp, #0]
}
 8003250:	4618      	mov	r0, r3
 8003252:	b002      	add	sp, #8
 8003254:	4770      	bx	lr
 8003256:	bf00      	nop
	...

08003260 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8003260:	b082      	sub	sp, #8
 8003262:	9001      	str	r0, [sp, #4]
 8003264:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003266:	9b01      	ldr	r3, [sp, #4]
 8003268:	681b      	ldr	r3, [r3, #0]
 800326a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 800326c:	9b01      	ldr	r3, [sp, #4]
 800326e:	689a      	ldr	r2, [r3, #8]
 8003270:	9b00      	ldr	r3, [sp, #0]
 8003272:	689b      	ldr	r3, [r3, #8]
 8003274:	429a      	cmp	r2, r3
 8003276:	bf8c      	ite	hi
 8003278:	2301      	movhi	r3, #1
 800327a:	2300      	movls	r3, #0
 800327c:	b2db      	uxtb	r3, r3
 800327e:	2b00      	cmp	r3, #0
 8003280:	d1f1      	bne.n	8003266 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 8003282:	9b00      	ldr	r3, [sp, #0]
 8003284:	9a01      	ldr	r2, [sp, #4]
 8003286:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003288:	9b01      	ldr	r3, [sp, #4]
 800328a:	685a      	ldr	r2, [r3, #4]
 800328c:	9b00      	ldr	r3, [sp, #0]
 800328e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003290:	9b00      	ldr	r3, [sp, #0]
 8003292:	685b      	ldr	r3, [r3, #4]
 8003294:	9a00      	ldr	r2, [sp, #0]
 8003296:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003298:	9b01      	ldr	r3, [sp, #4]
 800329a:	9a00      	ldr	r2, [sp, #0]
 800329c:	605a      	str	r2, [r3, #4]
  return p;
 800329e:	9b00      	ldr	r3, [sp, #0]
}
 80032a0:	4618      	mov	r0, r3
 80032a2:	b002      	add	sp, #8
 80032a4:	4770      	bx	lr
 80032a6:	bf00      	nop
	...

080032b0 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 80032b0:	b500      	push	{lr}
 80032b2:	b083      	sub	sp, #12
 80032b4:	2330      	movs	r3, #48	@ 0x30
 80032b6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80032b8:	9b01      	ldr	r3, [sp, #4]
 80032ba:	f383 8811 	msr	BASEPRI, r3
}
 80032be:	bf00      	nop
}
 80032c0:	bf00      	nop
}
 80032c2:	bf00      	nop
  __dbg_check_lock_from_isr();
 80032c4:	f7ff faec 	bl	80028a0 <__dbg_check_lock_from_isr>
}
 80032c8:	bf00      	nop
 80032ca:	b003      	add	sp, #12
 80032cc:	f85d fb04 	ldr.w	pc, [sp], #4

080032d0 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 80032d0:	b500      	push	{lr}
 80032d2:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 80032d4:	f7ff fb0c 	bl	80028f0 <__dbg_check_unlock_from_isr>
 80032d8:	2300      	movs	r3, #0
 80032da:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80032dc:	9b01      	ldr	r3, [sp, #4]
 80032de:	f383 8811 	msr	BASEPRI, r3
}
 80032e2:	bf00      	nop
}
 80032e4:	bf00      	nop
}
 80032e6:	bf00      	nop
}
 80032e8:	bf00      	nop
 80032ea:	b003      	add	sp, #12
 80032ec:	f85d fb04 	ldr.w	pc, [sp], #4

080032f0 <chVTIsArmedI.lto_priv.1>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 80032f0:	b500      	push	{lr}
 80032f2:	b083      	sub	sp, #12
 80032f4:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 80032f6:	f7ff fb9b 	bl	8002a30 <chDbgCheckClassI>
  return (bool)(vtp->dlist.next != NULL);
 80032fa:	9b01      	ldr	r3, [sp, #4]
 80032fc:	681b      	ldr	r3, [r3, #0]
 80032fe:	2b00      	cmp	r3, #0
 8003300:	bf14      	ite	ne
 8003302:	2301      	movne	r3, #1
 8003304:	2300      	moveq	r3, #0
 8003306:	b2db      	uxtb	r3, r3
}
 8003308:	4618      	mov	r0, r3
 800330a:	b003      	add	sp, #12
 800330c:	f85d fb04 	ldr.w	pc, [sp], #4

08003310 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8003310:	b500      	push	{lr}
 8003312:	b083      	sub	sp, #12
 8003314:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003316:	f7ff fb8b 	bl	8002a30 <chDbgCheckClassI>

  sp->cnt++;
 800331a:	9b01      	ldr	r3, [sp, #4]
 800331c:	689b      	ldr	r3, [r3, #8]
 800331e:	1c5a      	adds	r2, r3, #1
 8003320:	9b01      	ldr	r3, [sp, #4]
 8003322:	609a      	str	r2, [r3, #8]
}
 8003324:	bf00      	nop
 8003326:	b003      	add	sp, #12
 8003328:	f85d fb04 	ldr.w	pc, [sp], #4
 800332c:	0000      	movs	r0, r0
	...

08003330 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8003330:	b500      	push	{lr}
 8003332:	b083      	sub	sp, #12
 8003334:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003336:	9b01      	ldr	r3, [sp, #4]
 8003338:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800333c:	2b00      	cmp	r3, #0
 800333e:	bf0c      	ite	eq
 8003340:	2301      	moveq	r3, #1
 8003342:	2300      	movne	r3, #0
 8003344:	b2db      	uxtb	r3, r3
 8003346:	2b00      	cmp	r3, #0
 8003348:	d109      	bne.n	800335e <__sch_ready_behind+0x2e>
 800334a:	9b01      	ldr	r3, [sp, #4]
 800334c:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003350:	2b0f      	cmp	r3, #15
 8003352:	bf0c      	ite	eq
 8003354:	2301      	moveq	r3, #1
 8003356:	2300      	movne	r3, #0
 8003358:	b2db      	uxtb	r3, r3
 800335a:	2b00      	cmp	r3, #0
 800335c:	d002      	beq.n	8003364 <__sch_ready_behind+0x34>
 800335e:	480a      	ldr	r0, [pc, #40]	@ (8003388 <__sch_ready_behind+0x58>)
 8003360:	f7ff f9c6 	bl	80026f0 <chSysHalt>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003364:	9b01      	ldr	r3, [sp, #4]
 8003366:	2200      	movs	r2, #0
 8003368:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800336c:	9b01      	ldr	r3, [sp, #4]
 800336e:	699b      	ldr	r3, [r3, #24]
 8003370:	461a      	mov	r2, r3
 8003372:	9b01      	ldr	r3, [sp, #4]
 8003374:	4619      	mov	r1, r3
 8003376:	4610      	mov	r0, r2
 8003378:	f7ff ff4a 	bl	8003210 <ch_pqueue_insert_behind>
 800337c:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
 800337e:	4618      	mov	r0, r3
 8003380:	b003      	add	sp, #12
 8003382:	f85d fb04 	ldr.w	pc, [sp], #4
 8003386:	bf00      	nop
 8003388:	08005494 	.word	0x08005494
 800338c:	00000000 	.word	0x00000000

08003390 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8003390:	b500      	push	{lr}
 8003392:	b083      	sub	sp, #12
 8003394:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003396:	9b01      	ldr	r3, [sp, #4]
 8003398:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800339c:	2b00      	cmp	r3, #0
 800339e:	bf0c      	ite	eq
 80033a0:	2301      	moveq	r3, #1
 80033a2:	2300      	movne	r3, #0
 80033a4:	b2db      	uxtb	r3, r3
 80033a6:	2b00      	cmp	r3, #0
 80033a8:	d109      	bne.n	80033be <__sch_ready_ahead+0x2e>
 80033aa:	9b01      	ldr	r3, [sp, #4]
 80033ac:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 80033b0:	2b0f      	cmp	r3, #15
 80033b2:	bf0c      	ite	eq
 80033b4:	2301      	moveq	r3, #1
 80033b6:	2300      	movne	r3, #0
 80033b8:	b2db      	uxtb	r3, r3
 80033ba:	2b00      	cmp	r3, #0
 80033bc:	d002      	beq.n	80033c4 <__sch_ready_ahead+0x34>
 80033be:	480a      	ldr	r0, [pc, #40]	@ (80033e8 <__sch_ready_ahead+0x58>)
 80033c0:	f7ff f996 	bl	80026f0 <chSysHalt>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80033c4:	9b01      	ldr	r3, [sp, #4]
 80033c6:	2200      	movs	r2, #0
 80033c8:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 80033cc:	9b01      	ldr	r3, [sp, #4]
 80033ce:	699b      	ldr	r3, [r3, #24]
 80033d0:	461a      	mov	r2, r3
 80033d2:	9b01      	ldr	r3, [sp, #4]
 80033d4:	4619      	mov	r1, r3
 80033d6:	4610      	mov	r0, r2
 80033d8:	f7ff ff42 	bl	8003260 <ch_pqueue_insert_ahead>
 80033dc:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
 80033de:	4618      	mov	r0, r3
 80033e0:	b003      	add	sp, #12
 80033e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80033e6:	bf00      	nop
 80033e8:	080054a8 	.word	0x080054a8
 80033ec:	00000000 	.word	0x00000000

080033f0 <__sch_reschedule_ahead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_ahead(void) {
 80033f0:	b500      	push	{lr}
 80033f2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80033f4:	4b0e      	ldr	r3, [pc, #56]	@ (8003430 <__sch_reschedule_ahead+0x40>)
 80033f6:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 80033f8:	9b03      	ldr	r3, [sp, #12]
 80033fa:	68db      	ldr	r3, [r3, #12]
 80033fc:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 80033fe:	9b03      	ldr	r3, [sp, #12]
 8003400:	4618      	mov	r0, r3
 8003402:	f7ff feed 	bl	80031e0 <ch_pqueue_remove_highest>
 8003406:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 8003408:	9b01      	ldr	r3, [sp, #4]
 800340a:	2201      	movs	r2, #1
 800340c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8003410:	9b03      	ldr	r3, [sp, #12]
 8003412:	9a01      	ldr	r2, [sp, #4]
 8003414:	60da      	str	r2, [r3, #12]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = __sch_ready_ahead(otp);
 8003416:	9802      	ldr	r0, [sp, #8]
 8003418:	f7ff ffba 	bl	8003390 <__sch_ready_ahead>
 800341c:	9002      	str	r0, [sp, #8]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800341e:	9902      	ldr	r1, [sp, #8]
 8003420:	9801      	ldr	r0, [sp, #4]
 8003422:	f7fc ff2d 	bl	8000280 <__port_switch>
}
 8003426:	bf00      	nop
 8003428:	b005      	add	sp, #20
 800342a:	f85d fb04 	ldr.w	pc, [sp], #4
 800342e:	bf00      	nop
 8003430:	20000940 	.word	0x20000940
	...

08003440 <__sch_wakeup>:

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8003440:	b500      	push	{lr}
 8003442:	b085      	sub	sp, #20
 8003444:	9001      	str	r0, [sp, #4]
 8003446:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 8003448:	9b00      	ldr	r3, [sp, #0]
 800344a:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 800344c:	f7ff ff30 	bl	80032b0 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
 8003450:	9b03      	ldr	r3, [sp, #12]
 8003452:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003456:	2b0c      	cmp	r3, #12
 8003458:	d82e      	bhi.n	80034b8 <__sch_wakeup+0x78>
 800345a:	a201      	add	r2, pc, #4	@ (adr r2, 8003460 <__sch_wakeup+0x20>)
 800345c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003460:	08003495 	.word	0x08003495
 8003464:	080034b9 	.word	0x080034b9
 8003468:	080034b9 	.word	0x080034b9
 800346c:	0800349b 	.word	0x0800349b
 8003470:	080034af 	.word	0x080034af
 8003474:	080034a5 	.word	0x080034a5
 8003478:	080034b9 	.word	0x080034b9
 800347c:	080034af 	.word	0x080034af
 8003480:	080034b9 	.word	0x080034b9
 8003484:	080034b9 	.word	0x080034b9
 8003488:	080034b9 	.word	0x080034b9
 800348c:	080034b9 	.word	0x080034b9
 8003490:	080034af 	.word	0x080034af
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8003494:	f7ff ff1c 	bl	80032d0 <chSysUnlockFromISR.lto_priv.4>
    return;
 8003498:	e019      	b.n	80034ce <__sch_wakeup+0x8e>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800349a:	9b03      	ldr	r3, [sp, #12]
 800349c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800349e:	2200      	movs	r2, #0
 80034a0:	601a      	str	r2, [r3, #0]
    break;
 80034a2:	e00a      	b.n	80034ba <__sch_wakeup+0x7a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80034a4:	9b03      	ldr	r3, [sp, #12]
 80034a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80034a8:	4618      	mov	r0, r3
 80034aa:	f7ff ff31 	bl	8003310 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 80034ae:	9b03      	ldr	r3, [sp, #12]
 80034b0:	4618      	mov	r0, r3
 80034b2:	f7ff fe85 	bl	80031c0 <ch_queue_dequeue.lto_priv.0>
    break;
 80034b6:	e000      	b.n	80034ba <__sch_wakeup+0x7a>
  default:
    /* Any other state, nothing to do.*/
    break;
 80034b8:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 80034ba:	9b03      	ldr	r3, [sp, #12]
 80034bc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80034c0:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 80034c2:	9803      	ldr	r0, [sp, #12]
 80034c4:	f7ff ff34 	bl	8003330 <__sch_ready_behind>
  chSysUnlockFromISR();
 80034c8:	f7ff ff02 	bl	80032d0 <chSysUnlockFromISR.lto_priv.4>

  return;
 80034cc:	bf00      	nop
}
 80034ce:	b005      	add	sp, #20
 80034d0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080034e0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80034e0:	b500      	push	{lr}
 80034e2:	b083      	sub	sp, #12
 80034e4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80034e6:	f7ff faa3 	bl	8002a30 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80034ea:	9b01      	ldr	r3, [sp, #4]
 80034ec:	2b00      	cmp	r3, #0
 80034ee:	bf0c      	ite	eq
 80034f0:	2301      	moveq	r3, #1
 80034f2:	2300      	movne	r3, #0
 80034f4:	b2db      	uxtb	r3, r3
 80034f6:	2b00      	cmp	r3, #0
 80034f8:	d002      	beq.n	8003500 <chSchReadyI+0x20>
 80034fa:	4805      	ldr	r0, [pc, #20]	@ (8003510 <chSchReadyI+0x30>)
 80034fc:	f7ff f8f8 	bl	80026f0 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 8003500:	9801      	ldr	r0, [sp, #4]
 8003502:	f7ff ff15 	bl	8003330 <__sch_ready_behind>
 8003506:	4603      	mov	r3, r0
}
 8003508:	4618      	mov	r0, r3
 800350a:	b003      	add	sp, #12
 800350c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003510:	080054bc 	.word	0x080054bc
	...

08003520 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003520:	b500      	push	{lr}
 8003522:	b087      	sub	sp, #28
 8003524:	4603      	mov	r3, r0
 8003526:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
 800352a:	4b1d      	ldr	r3, [pc, #116]	@ (80035a0 <chSchGoSleepS+0x80>)
 800352c:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 800352e:	9b05      	ldr	r3, [sp, #20]
 8003530:	68db      	ldr	r3, [r3, #12]
 8003532:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  chDbgCheckClassS();
 8003534:	f7ff fa9c 	bl	8002a70 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 8003538:	f7ff f8f2 	bl	8002720 <chSysGetIdleThreadX>
 800353c:	4602      	mov	r2, r0
 800353e:	9b04      	ldr	r3, [sp, #16]
 8003540:	4293      	cmp	r3, r2
 8003542:	bf0c      	ite	eq
 8003544:	2301      	moveq	r3, #1
 8003546:	2300      	movne	r3, #0
 8003548:	b2db      	uxtb	r3, r3
 800354a:	2b00      	cmp	r3, #0
 800354c:	d002      	beq.n	8003554 <chSchGoSleepS+0x34>
 800354e:	4815      	ldr	r0, [pc, #84]	@ (80035a4 <chSchGoSleepS+0x84>)
 8003550:	f7ff f8ce 	bl	80026f0 <chSysHalt>
  chDbgAssert(otp->owner == oip, "invalid core");
 8003554:	9b04      	ldr	r3, [sp, #16]
 8003556:	699b      	ldr	r3, [r3, #24]
 8003558:	9a05      	ldr	r2, [sp, #20]
 800355a:	429a      	cmp	r2, r3
 800355c:	bf14      	ite	ne
 800355e:	2301      	movne	r3, #1
 8003560:	2300      	moveq	r3, #0
 8003562:	b2db      	uxtb	r3, r3
 8003564:	2b00      	cmp	r3, #0
 8003566:	d002      	beq.n	800356e <chSchGoSleepS+0x4e>
 8003568:	480e      	ldr	r0, [pc, #56]	@ (80035a4 <chSchGoSleepS+0x84>)
 800356a:	f7ff f8c1 	bl	80026f0 <chSysHalt>

  /* New state.*/
  otp->state = newstate;
 800356e:	9b04      	ldr	r3, [sp, #16]
 8003570:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8003574:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8003578:	9b05      	ldr	r3, [sp, #20]
 800357a:	4618      	mov	r0, r3
 800357c:	f7ff fe30 	bl	80031e0 <ch_pqueue_remove_highest>
 8003580:	9003      	str	r0, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 8003582:	9b03      	ldr	r3, [sp, #12]
 8003584:	2201      	movs	r2, #1
 8003586:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 800358a:	9b05      	ldr	r3, [sp, #20]
 800358c:	9a03      	ldr	r2, [sp, #12]
 800358e:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8003590:	9904      	ldr	r1, [sp, #16]
 8003592:	9803      	ldr	r0, [sp, #12]
 8003594:	f7fc fe74 	bl	8000280 <__port_switch>
}
 8003598:	bf00      	nop
 800359a:	b007      	add	sp, #28
 800359c:	f85d fb04 	ldr.w	pc, [sp], #4
 80035a0:	20000940 	.word	0x20000940
 80035a4:	080054c8 	.word	0x080054c8
	...

080035b0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80035b0:	b500      	push	{lr}
 80035b2:	b08b      	sub	sp, #44	@ 0x2c
 80035b4:	4603      	mov	r3, r0
 80035b6:	9100      	str	r1, [sp, #0]
 80035b8:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 80035bc:	4b15      	ldr	r3, [pc, #84]	@ (8003614 <chSchGoSleepTimeoutS+0x64>)
 80035be:	68db      	ldr	r3, [r3, #12]
 80035c0:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();
 80035c2:	f7ff fa55 	bl	8002a70 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 80035c6:	9b00      	ldr	r3, [sp, #0]
 80035c8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80035cc:	d016      	beq.n	80035fc <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 80035ce:	a803      	add	r0, sp, #12
 80035d0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80035d2:	4a11      	ldr	r2, [pc, #68]	@ (8003618 <chSchGoSleepTimeoutS+0x68>)
 80035d4:	9900      	ldr	r1, [sp, #0]
 80035d6:	f7ff fc8b 	bl	8002ef0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80035da:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80035de:	4618      	mov	r0, r3
 80035e0:	f7ff ff9e 	bl	8003520 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80035e4:	ab03      	add	r3, sp, #12
 80035e6:	4618      	mov	r0, r3
 80035e8:	f7ff fe82 	bl	80032f0 <chVTIsArmedI.lto_priv.1>
 80035ec:	4603      	mov	r3, r0
 80035ee:	2b00      	cmp	r3, #0
 80035f0:	d009      	beq.n	8003606 <chSchGoSleepTimeoutS+0x56>
      chVTDoResetI(&vt);
 80035f2:	ab03      	add	r3, sp, #12
 80035f4:	4618      	mov	r0, r3
 80035f6:	f7ff fcbb 	bl	8002f70 <chVTDoResetI>
 80035fa:	e004      	b.n	8003606 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
 80035fc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003600:	4618      	mov	r0, r3
 8003602:	f7ff ff8d 	bl	8003520 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 8003606:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003608:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
}
 800360a:	4618      	mov	r0, r3
 800360c:	b00b      	add	sp, #44	@ 0x2c
 800360e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003612:	bf00      	nop
 8003614:	20000940 	.word	0x20000940
 8003618:	08003441 	.word	0x08003441
 800361c:	00000000 	.word	0x00000000

08003620 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003620:	b500      	push	{lr}
 8003622:	b085      	sub	sp, #20
 8003624:	9001      	str	r0, [sp, #4]
 8003626:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8003628:	4b22      	ldr	r3, [pc, #136]	@ (80036b4 <chSchWakeupS+0x94>)
 800362a:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 800362c:	9b03      	ldr	r3, [sp, #12]
 800362e:	68db      	ldr	r3, [r3, #12]
 8003630:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 8003632:	f7ff fa1d 	bl	8002a70 <chDbgCheckClassS>

  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8003636:	9b03      	ldr	r3, [sp, #12]
 8003638:	681a      	ldr	r2, [r3, #0]
 800363a:	9b03      	ldr	r3, [sp, #12]
 800363c:	429a      	cmp	r2, r3
 800363e:	bf14      	ite	ne
 8003640:	2301      	movne	r3, #1
 8003642:	2300      	moveq	r3, #0
 8003644:	b2db      	uxtb	r3, r3
 8003646:	2b00      	cmp	r3, #0
 8003648:	d00f      	beq.n	800366a <chSchWakeupS+0x4a>
 800364a:	9b03      	ldr	r3, [sp, #12]
 800364c:	68db      	ldr	r3, [r3, #12]
 800364e:	689a      	ldr	r2, [r3, #8]
 8003650:	9b03      	ldr	r3, [sp, #12]
 8003652:	681b      	ldr	r3, [r3, #0]
 8003654:	689b      	ldr	r3, [r3, #8]
 8003656:	429a      	cmp	r2, r3
 8003658:	bf34      	ite	cc
 800365a:	2301      	movcc	r3, #1
 800365c:	2300      	movcs	r3, #0
 800365e:	b2db      	uxtb	r3, r3
 8003660:	2b00      	cmp	r3, #0
 8003662:	d002      	beq.n	800366a <chSchWakeupS+0x4a>
 8003664:	4814      	ldr	r0, [pc, #80]	@ (80036b8 <chSchWakeupS+0x98>)
 8003666:	f7ff f843 	bl	80026f0 <chSysHalt>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800366a:	9b01      	ldr	r3, [sp, #4]
 800366c:	9a00      	ldr	r2, [sp, #0]
 800366e:	629a      	str	r2, [r3, #40]	@ 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8003670:	9b01      	ldr	r3, [sp, #4]
 8003672:	689a      	ldr	r2, [r3, #8]
 8003674:	9b02      	ldr	r3, [sp, #8]
 8003676:	689b      	ldr	r3, [r3, #8]
 8003678:	429a      	cmp	r2, r3
 800367a:	bf94      	ite	ls
 800367c:	2301      	movls	r3, #1
 800367e:	2300      	movhi	r3, #0
 8003680:	b2db      	uxtb	r3, r3
 8003682:	2b00      	cmp	r3, #0
 8003684:	d003      	beq.n	800368e <chSchWakeupS+0x6e>
    (void) __sch_ready_behind(ntp);
 8003686:	9801      	ldr	r0, [sp, #4]
 8003688:	f7ff fe52 	bl	8003330 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 800368c:	e00e      	b.n	80036ac <chSchWakeupS+0x8c>
    otp = __sch_ready_ahead(otp);
 800368e:	9802      	ldr	r0, [sp, #8]
 8003690:	f7ff fe7e 	bl	8003390 <__sch_ready_ahead>
 8003694:	9002      	str	r0, [sp, #8]
    ntp->state = CH_STATE_CURRENT;
 8003696:	9b01      	ldr	r3, [sp, #4]
 8003698:	2201      	movs	r2, #1
 800369a:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    __instance_set_currthread(oip, ntp);
 800369e:	9b03      	ldr	r3, [sp, #12]
 80036a0:	9a01      	ldr	r2, [sp, #4]
 80036a2:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 80036a4:	9902      	ldr	r1, [sp, #8]
 80036a6:	9801      	ldr	r0, [sp, #4]
 80036a8:	f7fc fdea 	bl	8000280 <__port_switch>
}
 80036ac:	bf00      	nop
 80036ae:	b005      	add	sp, #20
 80036b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80036b4:	20000940 	.word	0x20000940
 80036b8:	080054d8 	.word	0x080054d8
 80036bc:	00000000 	.word	0x00000000

080036c0 <chSchRescheduleS>:
 * @note    Only local threads are considered, other cores are signaled
 *          and perform a reschedule locally.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 80036c0:	b500      	push	{lr}
 80036c2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80036c4:	4b0c      	ldr	r3, [pc, #48]	@ (80036f8 <chSchRescheduleS+0x38>)
 80036c6:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
 80036c8:	9b01      	ldr	r3, [sp, #4]
 80036ca:	68db      	ldr	r3, [r3, #12]
 80036cc:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();
 80036ce:	f7ff f9cf 	bl	8002a70 <chDbgCheckClassS>

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 80036d2:	9b01      	ldr	r3, [sp, #4]
 80036d4:	681b      	ldr	r3, [r3, #0]
 80036d6:	689a      	ldr	r2, [r3, #8]
 80036d8:	9b00      	ldr	r3, [sp, #0]
 80036da:	689b      	ldr	r3, [r3, #8]
 80036dc:	429a      	cmp	r2, r3
 80036de:	bf8c      	ite	hi
 80036e0:	2301      	movhi	r3, #1
 80036e2:	2300      	movls	r3, #0
 80036e4:	b2db      	uxtb	r3, r3
 80036e6:	2b00      	cmp	r3, #0
 80036e8:	d001      	beq.n	80036ee <chSchRescheduleS+0x2e>
    __sch_reschedule_ahead();
 80036ea:	f7ff fe81 	bl	80033f0 <__sch_reschedule_ahead>
  }
}
 80036ee:	bf00      	nop
 80036f0:	b003      	add	sp, #12
 80036f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80036f6:	bf00      	nop
 80036f8:	20000940 	.word	0x20000940
 80036fc:	00000000 	.word	0x00000000

08003700 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8003700:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 8003702:	4b0b      	ldr	r3, [pc, #44]	@ (8003730 <chSchIsPreemptionRequired+0x30>)
 8003704:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 8003706:	9b03      	ldr	r3, [sp, #12]
 8003708:	68db      	ldr	r3, [r3, #12]
 800370a:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 800370c:	9b03      	ldr	r3, [sp, #12]
 800370e:	681b      	ldr	r3, [r3, #0]
 8003710:	689b      	ldr	r3, [r3, #8]
 8003712:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8003714:	9b02      	ldr	r3, [sp, #8]
 8003716:	689b      	ldr	r3, [r3, #8]
 8003718:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800371a:	9a01      	ldr	r2, [sp, #4]
 800371c:	9b00      	ldr	r3, [sp, #0]
 800371e:	429a      	cmp	r2, r3
 8003720:	bf8c      	ite	hi
 8003722:	2301      	movhi	r3, #1
 8003724:	2300      	movls	r3, #0
 8003726:	b2db      	uxtb	r3, r3
#endif
}
 8003728:	4618      	mov	r0, r3
 800372a:	b004      	add	sp, #16
 800372c:	4770      	bx	lr
 800372e:	bf00      	nop
 8003730:	20000940 	.word	0x20000940
	...

08003740 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8003740:	b500      	push	{lr}
 8003742:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8003744:	4b0e      	ldr	r3, [pc, #56]	@ (8003780 <chSchDoPreemption+0x40>)
 8003746:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 8003748:	9b03      	ldr	r3, [sp, #12]
 800374a:	68db      	ldr	r3, [r3, #12]
 800374c:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800374e:	9b03      	ldr	r3, [sp, #12]
 8003750:	4618      	mov	r0, r3
 8003752:	f7ff fd45 	bl	80031e0 <ch_pqueue_remove_highest>
 8003756:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 8003758:	9b01      	ldr	r3, [sp, #4]
 800375a:	2201      	movs	r2, #1
 800375c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8003760:	9b03      	ldr	r3, [sp, #12]
 8003762:	9a01      	ldr	r2, [sp, #4]
 8003764:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 8003766:	9802      	ldr	r0, [sp, #8]
 8003768:	f7ff fe12 	bl	8003390 <__sch_ready_ahead>
 800376c:	9002      	str	r0, [sp, #8]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800376e:	9902      	ldr	r1, [sp, #8]
 8003770:	9801      	ldr	r0, [sp, #4]
 8003772:	f7fc fd85 	bl	8000280 <__port_switch>
}
 8003776:	bf00      	nop
 8003778:	b005      	add	sp, #20
 800377a:	f85d fb04 	ldr.w	pc, [sp], #4
 800377e:	bf00      	nop
 8003780:	20000940 	.word	0x20000940
	...

08003790 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 8003790:	b082      	sub	sp, #8
 8003792:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 8003794:	9b01      	ldr	r3, [sp, #4]
 8003796:	2200      	movs	r2, #0
 8003798:	601a      	str	r2, [r3, #0]
}
 800379a:	bf00      	nop
 800379c:	b002      	add	sp, #8
 800379e:	4770      	bx	lr

080037a0 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 80037a0:	b082      	sub	sp, #8
 80037a2:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 80037a4:	9b01      	ldr	r3, [sp, #4]
 80037a6:	2200      	movs	r2, #0
 80037a8:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 80037aa:	9b01      	ldr	r3, [sp, #4]
 80037ac:	2200      	movs	r2, #0
 80037ae:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 80037b0:	9b01      	ldr	r3, [sp, #4]
 80037b2:	2201      	movs	r2, #1
 80037b4:	609a      	str	r2, [r3, #8]
#endif
}
 80037b6:	bf00      	nop
 80037b8:	b002      	add	sp, #8
 80037ba:	4770      	bx	lr
 80037bc:	0000      	movs	r0, r0
	...

080037c0 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80037c0:	b082      	sub	sp, #8
 80037c2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80037c4:	9b01      	ldr	r3, [sp, #4]
 80037c6:	9a01      	ldr	r2, [sp, #4]
 80037c8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80037ca:	9b01      	ldr	r3, [sp, #4]
 80037cc:	9a01      	ldr	r2, [sp, #4]
 80037ce:	605a      	str	r2, [r3, #4]
}
 80037d0:	bf00      	nop
 80037d2:	b002      	add	sp, #8
 80037d4:	4770      	bx	lr
 80037d6:	bf00      	nop
	...

080037e0 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 80037e0:	b082      	sub	sp, #8
 80037e2:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 80037e4:	9b01      	ldr	r3, [sp, #4]
 80037e6:	9a01      	ldr	r2, [sp, #4]
 80037e8:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 80037ea:	9b01      	ldr	r3, [sp, #4]
 80037ec:	9a01      	ldr	r2, [sp, #4]
 80037ee:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 80037f0:	9b01      	ldr	r3, [sp, #4]
 80037f2:	2200      	movs	r2, #0
 80037f4:	609a      	str	r2, [r3, #8]
}
 80037f6:	bf00      	nop
 80037f8:	b002      	add	sp, #8
 80037fa:	4770      	bx	lr
 80037fc:	0000      	movs	r0, r0
	...

08003800 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 8003800:	b082      	sub	sp, #8
 8003802:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 8003804:	9b01      	ldr	r3, [sp, #4]
 8003806:	9a01      	ldr	r2, [sp, #4]
 8003808:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 800380a:	9b01      	ldr	r3, [sp, #4]
 800380c:	9a01      	ldr	r2, [sp, #4]
 800380e:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 8003810:	9b01      	ldr	r3, [sp, #4]
 8003812:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003816:	609a      	str	r2, [r3, #8]
}
 8003818:	bf00      	nop
 800381a:	b002      	add	sp, #8
 800381c:	4770      	bx	lr
 800381e:	bf00      	nop

08003820 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 8003820:	b508      	push	{r3, lr}
  return stGetCounter();
 8003822:	f7fc fe0d 	bl	8000440 <stGetCounter>
 8003826:	4603      	mov	r3, r0
}
 8003828:	4618      	mov	r0, r3
 800382a:	bd08      	pop	{r3, pc}
 800382c:	0000      	movs	r0, r0
	...

08003830 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003830:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8003832:	f7ff fff5 	bl	8003820 <port_timer_get_time.lto_priv.1>
 8003836:	4603      	mov	r3, r0
}
 8003838:	4618      	mov	r0, r3
 800383a:	bd08      	pop	{r3, pc}
 800383c:	0000      	movs	r0, r0
	...

08003840 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 8003840:	b530      	push	{r4, r5, lr}
 8003842:	b083      	sub	sp, #12
 8003844:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 8003846:	9b01      	ldr	r3, [sp, #4]
 8003848:	4618      	mov	r0, r3
 800384a:	f7ff ffd9 	bl	8003800 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 800384e:	9b01      	ldr	r3, [sp, #4]
 8003850:	2200      	movs	r2, #0
 8003852:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003854:	f7ff ffec 	bl	8003830 <chVTGetSystemTimeX.lto_priv.1>
 8003858:	4603      	mov	r3, r0
 800385a:	2200      	movs	r2, #0
 800385c:	461c      	mov	r4, r3
 800385e:	4615      	mov	r5, r2
 8003860:	9b01      	ldr	r3, [sp, #4]
 8003862:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 8003866:	bf00      	nop
 8003868:	b003      	add	sp, #12
 800386a:	bd30      	pop	{r4, r5, pc}
 800386c:	0000      	movs	r0, r0
	...

08003870 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8003870:	b500      	push	{lr}
 8003872:	b083      	sub	sp, #12
 8003874:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 8003876:	9b01      	ldr	r3, [sp, #4]
 8003878:	4618      	mov	r0, r3
 800387a:	f7ff ffa1 	bl	80037c0 <ch_queue_init.lto_priv.2>
}
 800387e:	bf00      	nop
 8003880:	b003      	add	sp, #12
 8003882:	f85d fb04 	ldr.w	pc, [sp], #4
 8003886:	bf00      	nop
	...

08003890 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8003890:	b082      	sub	sp, #8
 8003892:	9001      	str	r0, [sp, #4]
}
 8003894:	bf00      	nop
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
    asm volatile ("nop");
 8003896:	bf00      	nop
    port_wait_for_interrupt();
 8003898:	bf00      	nop
 800389a:	e7fb      	b.n	8003894 <__idle_thread+0x4>
 800389c:	0000      	movs	r0, r0
	...

080038a0 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 80038a0:	b500      	push	{lr}
 80038a2:	b08b      	sub	sp, #44	@ 0x2c
 80038a4:	9001      	str	r0, [sp, #4]
 80038a6:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 80038a8:	2300      	movs	r3, #0
 80038aa:	9309      	str	r3, [sp, #36]	@ 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 80038ac:	4a30      	ldr	r2, [pc, #192]	@ (8003970 <chInstanceObjectInit+0xd0>)
 80038ae:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80038b0:	009b      	lsls	r3, r3, #2
 80038b2:	4413      	add	r3, r2
 80038b4:	685b      	ldr	r3, [r3, #4]
 80038b6:	2b00      	cmp	r3, #0
 80038b8:	bf14      	ite	ne
 80038ba:	2301      	movne	r3, #1
 80038bc:	2300      	moveq	r3, #0
 80038be:	b2db      	uxtb	r3, r3
 80038c0:	2b00      	cmp	r3, #0
 80038c2:	d002      	beq.n	80038ca <chInstanceObjectInit+0x2a>
 80038c4:	482b      	ldr	r0, [pc, #172]	@ (8003974 <chInstanceObjectInit+0xd4>)
 80038c6:	f7fe ff13 	bl	80026f0 <chSysHalt>
  ch_system.instances[core_id] = oip;
 80038ca:	4a29      	ldr	r2, [pc, #164]	@ (8003970 <chInstanceObjectInit+0xd0>)
 80038cc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80038ce:	009b      	lsls	r3, r3, #2
 80038d0:	4413      	add	r3, r2
 80038d2:	9a01      	ldr	r2, [sp, #4]
 80038d4:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 80038d6:	9b01      	ldr	r3, [sp, #4]
 80038d8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80038da:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 80038dc:	9b01      	ldr	r3, [sp, #4]
 80038de:	9a00      	ldr	r2, [sp, #0]
 80038e0:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 80038e2:	9801      	ldr	r0, [sp, #4]
 80038e4:	f001 fa3c 	bl	8004d60 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 80038e8:	9b01      	ldr	r3, [sp, #4]
 80038ea:	4618      	mov	r0, r3
 80038ec:	f7ff ff78 	bl	80037e0 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 80038f0:	9b01      	ldr	r3, [sp, #4]
 80038f2:	3328      	adds	r3, #40	@ 0x28
 80038f4:	4618      	mov	r0, r3
 80038f6:	f7ff ffbb 	bl	8003870 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 80038fa:	9b01      	ldr	r3, [sp, #4]
 80038fc:	3334      	adds	r3, #52	@ 0x34
 80038fe:	4618      	mov	r0, r3
 8003900:	f7ff ff46 	bl	8003790 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8003904:	9b01      	ldr	r3, [sp, #4]
 8003906:	3310      	adds	r3, #16
 8003908:	4618      	mov	r0, r3
 800390a:	f7ff ff99 	bl	8003840 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 800390e:	9b01      	ldr	r3, [sp, #4]
 8003910:	3384      	adds	r3, #132	@ 0x84
 8003912:	4618      	mov	r0, r3
 8003914:	f7ff ff44 	bl	80037a0 <__dbg_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8003918:	9b01      	ldr	r3, [sp, #4]
 800391a:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800391e:	2380      	movs	r3, #128	@ 0x80
 8003920:	4a15      	ldr	r2, [pc, #84]	@ (8003978 <chInstanceObjectInit+0xd8>)
 8003922:	9801      	ldr	r0, [sp, #4]
 8003924:	f000 f8fc 	bl	8003b20 <__thd_object_init>
 8003928:	4602      	mov	r2, r0
 800392a:	9b01      	ldr	r3, [sp, #4]
 800392c:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 800392e:	9b01      	ldr	r3, [sp, #4]
 8003930:	68db      	ldr	r3, [r3, #12]
 8003932:	9a00      	ldr	r2, [sp, #0]
 8003934:	6852      	ldr	r2, [r2, #4]
 8003936:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8003938:	9b01      	ldr	r3, [sp, #4]
 800393a:	68db      	ldr	r3, [r3, #12]
 800393c:	2201      	movs	r2, #1
 800393e:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 8003942:	4b0e      	ldr	r3, [pc, #56]	@ (800397c <chInstanceObjectInit+0xdc>)
 8003944:	9303      	str	r3, [sp, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8003946:	9b00      	ldr	r3, [sp, #0]
 8003948:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 800394a:	9304      	str	r3, [sp, #16]
      .wend     = oicp->idlethread_end,
 800394c:	9b00      	ldr	r3, [sp, #0]
 800394e:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 8003950:	9305      	str	r3, [sp, #20]
 8003952:	2301      	movs	r3, #1
 8003954:	9306      	str	r3, [sp, #24]
 8003956:	4b0a      	ldr	r3, [pc, #40]	@ (8003980 <chInstanceObjectInit+0xe0>)
 8003958:	9307      	str	r3, [sp, #28]
 800395a:	2300      	movs	r3, #0
 800395c:	9308      	str	r3, [sp, #32]
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 800395e:	ab03      	add	r3, sp, #12
 8003960:	4618      	mov	r0, r3
 8003962:	f000 f9ad 	bl	8003cc0 <chThdCreateI>
  }
#endif
}
 8003966:	bf00      	nop
 8003968:	b00b      	add	sp, #44	@ 0x2c
 800396a:	f85d fb04 	ldr.w	pc, [sp], #4
 800396e:	bf00      	nop
 8003970:	20000934 	.word	0x20000934
 8003974:	080054e8 	.word	0x080054e8
 8003978:	08005598 	.word	0x08005598
 800397c:	08005404 	.word	0x08005404
 8003980:	08003891 	.word	0x08003891
	...

08003990 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 8003990:	b082      	sub	sp, #8
 8003992:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 8003994:	9b01      	ldr	r3, [sp, #4]
 8003996:	9a01      	ldr	r2, [sp, #4]
 8003998:	601a      	str	r2, [r3, #0]
}
 800399a:	bf00      	nop
 800399c:	b002      	add	sp, #8
 800399e:	4770      	bx	lr

080039a0 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 80039a0:	b082      	sub	sp, #8
 80039a2:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 80039a4:	9b01      	ldr	r3, [sp, #4]
 80039a6:	681b      	ldr	r3, [r3, #0]
 80039a8:	9a01      	ldr	r2, [sp, #4]
 80039aa:	429a      	cmp	r2, r3
 80039ac:	bf14      	ite	ne
 80039ae:	2301      	movne	r3, #1
 80039b0:	2300      	moveq	r3, #0
 80039b2:	b2db      	uxtb	r3, r3
}
 80039b4:	4618      	mov	r0, r3
 80039b6:	b002      	add	sp, #8
 80039b8:	4770      	bx	lr
 80039ba:	bf00      	nop
 80039bc:	0000      	movs	r0, r0
	...

080039c0 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 80039c0:	b084      	sub	sp, #16
 80039c2:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 80039c4:	9b01      	ldr	r3, [sp, #4]
 80039c6:	681b      	ldr	r3, [r3, #0]
 80039c8:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 80039ca:	9b03      	ldr	r3, [sp, #12]
 80039cc:	681a      	ldr	r2, [r3, #0]
 80039ce:	9b01      	ldr	r3, [sp, #4]
 80039d0:	601a      	str	r2, [r3, #0]
  return p;
 80039d2:	9b03      	ldr	r3, [sp, #12]
}
 80039d4:	4618      	mov	r0, r3
 80039d6:	b004      	add	sp, #16
 80039d8:	4770      	bx	lr
 80039da:	bf00      	nop
 80039dc:	0000      	movs	r0, r0
	...

080039e0 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80039e0:	b082      	sub	sp, #8
 80039e2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80039e4:	9b01      	ldr	r3, [sp, #4]
 80039e6:	9a01      	ldr	r2, [sp, #4]
 80039e8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80039ea:	9b01      	ldr	r3, [sp, #4]
 80039ec:	9a01      	ldr	r2, [sp, #4]
 80039ee:	605a      	str	r2, [r3, #4]
}
 80039f0:	bf00      	nop
 80039f2:	b002      	add	sp, #8
 80039f4:	4770      	bx	lr
 80039f6:	bf00      	nop
	...

08003a00 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8003a00:	b082      	sub	sp, #8
 8003a02:	9001      	str	r0, [sp, #4]
 8003a04:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 8003a06:	9b00      	ldr	r3, [sp, #0]
 8003a08:	9a01      	ldr	r2, [sp, #4]
 8003a0a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 8003a0c:	9b01      	ldr	r3, [sp, #4]
 8003a0e:	685a      	ldr	r2, [r3, #4]
 8003a10:	9b00      	ldr	r3, [sp, #0]
 8003a12:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003a14:	9b00      	ldr	r3, [sp, #0]
 8003a16:	685b      	ldr	r3, [r3, #4]
 8003a18:	9a00      	ldr	r2, [sp, #0]
 8003a1a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 8003a1c:	9b01      	ldr	r3, [sp, #4]
 8003a1e:	9a00      	ldr	r2, [sp, #0]
 8003a20:	605a      	str	r2, [r3, #4]
}
 8003a22:	bf00      	nop
 8003a24:	b002      	add	sp, #8
 8003a26:	4770      	bx	lr
	...

08003a30 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003a30:	b082      	sub	sp, #8
 8003a32:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003a34:	9b01      	ldr	r3, [sp, #4]
 8003a36:	685b      	ldr	r3, [r3, #4]
 8003a38:	9a01      	ldr	r2, [sp, #4]
 8003a3a:	6812      	ldr	r2, [r2, #0]
 8003a3c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8003a3e:	9b01      	ldr	r3, [sp, #4]
 8003a40:	681b      	ldr	r3, [r3, #0]
 8003a42:	9a01      	ldr	r2, [sp, #4]
 8003a44:	6852      	ldr	r2, [r2, #4]
 8003a46:	605a      	str	r2, [r3, #4]
  return p;
 8003a48:	9b01      	ldr	r3, [sp, #4]
}
 8003a4a:	4618      	mov	r0, r3
 8003a4c:	b002      	add	sp, #8
 8003a4e:	4770      	bx	lr

08003a50 <chSysLock.lto_priv.6>:
static inline void chSysLock(void) {
 8003a50:	b500      	push	{lr}
 8003a52:	b083      	sub	sp, #12
 8003a54:	2330      	movs	r3, #48	@ 0x30
 8003a56:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003a58:	9b01      	ldr	r3, [sp, #4]
 8003a5a:	f383 8811 	msr	BASEPRI, r3
}
 8003a5e:	bf00      	nop
}
 8003a60:	bf00      	nop
  __dbg_check_lock();
 8003a62:	f7fe fecd 	bl	8002800 <__dbg_check_lock>
}
 8003a66:	bf00      	nop
 8003a68:	b003      	add	sp, #12
 8003a6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a6e:	bf00      	nop

08003a70 <chSysUnlock.lto_priv.6>:
static inline void chSysUnlock(void) {
 8003a70:	b500      	push	{lr}
 8003a72:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8003a74:	f7fe feec 	bl	8002850 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003a78:	4b12      	ldr	r3, [pc, #72]	@ (8003ac4 <chSysUnlock.lto_priv.6+0x54>)
 8003a7a:	681b      	ldr	r3, [r3, #0]
 8003a7c:	4a11      	ldr	r2, [pc, #68]	@ (8003ac4 <chSysUnlock.lto_priv.6+0x54>)
 8003a7e:	4293      	cmp	r3, r2
 8003a80:	bf14      	ite	ne
 8003a82:	2301      	movne	r3, #1
 8003a84:	2300      	moveq	r3, #0
 8003a86:	b2db      	uxtb	r3, r3
 8003a88:	2b00      	cmp	r3, #0
 8003a8a:	d00f      	beq.n	8003aac <chSysUnlock.lto_priv.6+0x3c>
 8003a8c:	4b0d      	ldr	r3, [pc, #52]	@ (8003ac4 <chSysUnlock.lto_priv.6+0x54>)
 8003a8e:	68db      	ldr	r3, [r3, #12]
 8003a90:	689a      	ldr	r2, [r3, #8]
 8003a92:	4b0c      	ldr	r3, [pc, #48]	@ (8003ac4 <chSysUnlock.lto_priv.6+0x54>)
 8003a94:	681b      	ldr	r3, [r3, #0]
 8003a96:	689b      	ldr	r3, [r3, #8]
 8003a98:	429a      	cmp	r2, r3
 8003a9a:	bf34      	ite	cc
 8003a9c:	2301      	movcc	r3, #1
 8003a9e:	2300      	movcs	r3, #0
 8003aa0:	b2db      	uxtb	r3, r3
 8003aa2:	2b00      	cmp	r3, #0
 8003aa4:	d002      	beq.n	8003aac <chSysUnlock.lto_priv.6+0x3c>
 8003aa6:	4808      	ldr	r0, [pc, #32]	@ (8003ac8 <chSysUnlock.lto_priv.6+0x58>)
 8003aa8:	f7fe fe22 	bl	80026f0 <chSysHalt>
 8003aac:	2300      	movs	r3, #0
 8003aae:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003ab0:	9b01      	ldr	r3, [sp, #4]
 8003ab2:	f383 8811 	msr	BASEPRI, r3
}
 8003ab6:	bf00      	nop
}
 8003ab8:	bf00      	nop
}
 8003aba:	bf00      	nop
 8003abc:	b003      	add	sp, #12
 8003abe:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ac2:	bf00      	nop
 8003ac4:	20000940 	.word	0x20000940
 8003ac8:	08005518 	.word	0x08005518
 8003acc:	00000000 	.word	0x00000000

08003ad0 <chThdGetSelfX.lto_priv.0>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8003ad0:	4b01      	ldr	r3, [pc, #4]	@ (8003ad8 <chThdGetSelfX.lto_priv.0+0x8>)
 8003ad2:	68db      	ldr	r3, [r3, #12]
}
 8003ad4:	4618      	mov	r0, r3
 8003ad6:	4770      	bx	lr
 8003ad8:	20000940 	.word	0x20000940
 8003adc:	00000000 	.word	0x00000000

08003ae0 <chThdGetWorkingAreaX.lto_priv.0>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8003ae0:	b082      	sub	sp, #8
 8003ae2:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 8003ae4:	9b01      	ldr	r3, [sp, #4]
 8003ae6:	6a1b      	ldr	r3, [r3, #32]
}
 8003ae8:	4618      	mov	r0, r3
 8003aea:	b002      	add	sp, #8
 8003aec:	4770      	bx	lr
 8003aee:	bf00      	nop

08003af0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 8003af0:	b500      	push	{lr}
 8003af2:	b083      	sub	sp, #12
 8003af4:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8003af6:	9b01      	ldr	r3, [sp, #4]
 8003af8:	2b00      	cmp	r3, #0
 8003afa:	bf0c      	ite	eq
 8003afc:	2301      	moveq	r3, #1
 8003afe:	2300      	movne	r3, #0
 8003b00:	b2db      	uxtb	r3, r3
 8003b02:	2b00      	cmp	r3, #0
 8003b04:	d002      	beq.n	8003b0c <chThdSleepS+0x1c>
 8003b06:	4805      	ldr	r0, [pc, #20]	@ (8003b1c <chThdSleepS+0x2c>)
 8003b08:	f7fe fdf2 	bl	80026f0 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8003b0c:	9901      	ldr	r1, [sp, #4]
 8003b0e:	2008      	movs	r0, #8
 8003b10:	f7ff fd4e 	bl	80035b0 <chSchGoSleepTimeoutS>
}
 8003b14:	bf00      	nop
 8003b16:	b003      	add	sp, #12
 8003b18:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b1c:	08005554 	.word	0x08005554

08003b20 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8003b20:	b500      	push	{lr}
 8003b22:	b085      	sub	sp, #20
 8003b24:	9003      	str	r0, [sp, #12]
 8003b26:	9102      	str	r1, [sp, #8]
 8003b28:	9201      	str	r2, [sp, #4]
 8003b2a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 8003b2c:	9b02      	ldr	r3, [sp, #8]
 8003b2e:	9a00      	ldr	r2, [sp, #0]
 8003b30:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8003b32:	9b02      	ldr	r3, [sp, #8]
 8003b34:	2202      	movs	r2, #2
 8003b36:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 8003b3a:	9b02      	ldr	r3, [sp, #8]
 8003b3c:	2200      	movs	r2, #0
 8003b3e:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  tp->owner             = oip;
 8003b42:	9b02      	ldr	r3, [sp, #8]
 8003b44:	9a03      	ldr	r2, [sp, #12]
 8003b46:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8003b48:	9b02      	ldr	r3, [sp, #8]
 8003b4a:	9a00      	ldr	r2, [sp, #0]
 8003b4c:	641a      	str	r2, [r3, #64]	@ 0x40
  tp->mtxlist           = NULL;
 8003b4e:	9b02      	ldr	r3, [sp, #8]
 8003b50:	2200      	movs	r2, #0
 8003b52:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8003b54:	9b02      	ldr	r3, [sp, #8]
 8003b56:	2200      	movs	r2, #0
 8003b58:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 8003b5a:	9b02      	ldr	r3, [sp, #8]
 8003b5c:	2201      	movs	r2, #1
 8003b5e:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
  tp->name              = name;
 8003b62:	9b02      	ldr	r3, [sp, #8]
 8003b64:	9a01      	ldr	r2, [sp, #4]
 8003b66:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 8003b68:	9b03      	ldr	r3, [sp, #12]
 8003b6a:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 8003b6e:	9b02      	ldr	r3, [sp, #8]
 8003b70:	3310      	adds	r3, #16
 8003b72:	4619      	mov	r1, r3
 8003b74:	4610      	mov	r0, r2
 8003b76:	f7ff ff43 	bl	8003a00 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 8003b7a:	9b02      	ldr	r3, [sp, #8]
 8003b7c:	332c      	adds	r3, #44	@ 0x2c
 8003b7e:	4618      	mov	r0, r3
 8003b80:	f7ff ff06 	bl	8003990 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8003b84:	9b02      	ldr	r3, [sp, #8]
 8003b86:	3330      	adds	r3, #48	@ 0x30
 8003b88:	4618      	mov	r0, r3
 8003b8a:	f7ff ff29 	bl	80039e0 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8003b8e:	9b02      	ldr	r3, [sp, #8]
}
 8003b90:	4618      	mov	r0, r3
 8003b92:	b005      	add	sp, #20
 8003b94:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003ba0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8003ba0:	b500      	push	{lr}
 8003ba2:	b085      	sub	sp, #20
 8003ba4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8003ba6:	f7fe ff43 	bl	8002a30 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8003baa:	9b01      	ldr	r3, [sp, #4]
 8003bac:	2b00      	cmp	r3, #0
 8003bae:	bf0c      	ite	eq
 8003bb0:	2301      	moveq	r3, #1
 8003bb2:	2300      	movne	r3, #0
 8003bb4:	b2db      	uxtb	r3, r3
 8003bb6:	2b00      	cmp	r3, #0
 8003bb8:	d002      	beq.n	8003bc0 <chThdCreateSuspendedI+0x20>
 8003bba:	483d      	ldr	r0, [pc, #244]	@ (8003cb0 <chThdCreateSuspendedI+0x110>)
 8003bbc:	f7fe fd98 	bl	80026f0 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8003bc0:	9b01      	ldr	r3, [sp, #4]
 8003bc2:	685b      	ldr	r3, [r3, #4]
 8003bc4:	f003 0307 	and.w	r3, r3, #7
 8003bc8:	2b00      	cmp	r3, #0
 8003bca:	bf14      	ite	ne
 8003bcc:	2301      	movne	r3, #1
 8003bce:	2300      	moveq	r3, #0
 8003bd0:	b2db      	uxtb	r3, r3
 8003bd2:	2b00      	cmp	r3, #0
 8003bd4:	d10a      	bne.n	8003bec <chThdCreateSuspendedI+0x4c>
 8003bd6:	9b01      	ldr	r3, [sp, #4]
 8003bd8:	689b      	ldr	r3, [r3, #8]
 8003bda:	f003 0307 	and.w	r3, r3, #7
 8003bde:	2b00      	cmp	r3, #0
 8003be0:	bf14      	ite	ne
 8003be2:	2301      	movne	r3, #1
 8003be4:	2300      	moveq	r3, #0
 8003be6:	b2db      	uxtb	r3, r3
 8003be8:	2b00      	cmp	r3, #0
 8003bea:	d001      	beq.n	8003bf0 <chThdCreateSuspendedI+0x50>
 8003bec:	2301      	movs	r3, #1
 8003bee:	e000      	b.n	8003bf2 <chThdCreateSuspendedI+0x52>
 8003bf0:	2300      	movs	r3, #0
 8003bf2:	2b00      	cmp	r3, #0
 8003bf4:	d10a      	bne.n	8003c0c <chThdCreateSuspendedI+0x6c>
 8003bf6:	9b01      	ldr	r3, [sp, #4]
 8003bf8:	689a      	ldr	r2, [r3, #8]
 8003bfa:	9b01      	ldr	r3, [sp, #4]
 8003bfc:	685b      	ldr	r3, [r3, #4]
 8003bfe:	429a      	cmp	r2, r3
 8003c00:	bf94      	ite	ls
 8003c02:	2301      	movls	r3, #1
 8003c04:	2300      	movhi	r3, #0
 8003c06:	b2db      	uxtb	r3, r3
 8003c08:	2b00      	cmp	r3, #0
 8003c0a:	d001      	beq.n	8003c10 <chThdCreateSuspendedI+0x70>
 8003c0c:	2301      	movs	r3, #1
 8003c0e:	e000      	b.n	8003c12 <chThdCreateSuspendedI+0x72>
 8003c10:	2300      	movs	r3, #0
 8003c12:	2b00      	cmp	r3, #0
 8003c14:	d10c      	bne.n	8003c30 <chThdCreateSuspendedI+0x90>
 8003c16:	9b01      	ldr	r3, [sp, #4]
 8003c18:	689b      	ldr	r3, [r3, #8]
 8003c1a:	461a      	mov	r2, r3
 8003c1c:	9b01      	ldr	r3, [sp, #4]
 8003c1e:	685b      	ldr	r3, [r3, #4]
 8003c20:	1ad3      	subs	r3, r2, r3
 8003c22:	2bef      	cmp	r3, #239	@ 0xef
 8003c24:	bf94      	ite	ls
 8003c26:	2301      	movls	r3, #1
 8003c28:	2300      	movhi	r3, #0
 8003c2a:	b2db      	uxtb	r3, r3
 8003c2c:	2b00      	cmp	r3, #0
 8003c2e:	d002      	beq.n	8003c36 <chThdCreateSuspendedI+0x96>
 8003c30:	481f      	ldr	r0, [pc, #124]	@ (8003cb0 <chThdCreateSuspendedI+0x110>)
 8003c32:	f7fe fd5d 	bl	80026f0 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8003c36:	9b01      	ldr	r3, [sp, #4]
 8003c38:	68db      	ldr	r3, [r3, #12]
 8003c3a:	2bff      	cmp	r3, #255	@ 0xff
 8003c3c:	bf8c      	ite	hi
 8003c3e:	2301      	movhi	r3, #1
 8003c40:	2300      	movls	r3, #0
 8003c42:	b2db      	uxtb	r3, r3
 8003c44:	2b00      	cmp	r3, #0
 8003c46:	d108      	bne.n	8003c5a <chThdCreateSuspendedI+0xba>
 8003c48:	9b01      	ldr	r3, [sp, #4]
 8003c4a:	691b      	ldr	r3, [r3, #16]
 8003c4c:	2b00      	cmp	r3, #0
 8003c4e:	bf0c      	ite	eq
 8003c50:	2301      	moveq	r3, #1
 8003c52:	2300      	movne	r3, #0
 8003c54:	b2db      	uxtb	r3, r3
 8003c56:	2b00      	cmp	r3, #0
 8003c58:	d002      	beq.n	8003c60 <chThdCreateSuspendedI+0xc0>
 8003c5a:	4815      	ldr	r0, [pc, #84]	@ (8003cb0 <chThdCreateSuspendedI+0x110>)
 8003c5c:	f7fe fd48 	bl	80026f0 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 8003c60:	9b01      	ldr	r3, [sp, #4]
 8003c62:	689b      	ldr	r3, [r3, #8]
 8003c64:	3b48      	subs	r3, #72	@ 0x48
 8003c66:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8003c68:	9b01      	ldr	r3, [sp, #4]
 8003c6a:	685a      	ldr	r2, [r3, #4]
 8003c6c:	9b03      	ldr	r3, [sp, #12]
 8003c6e:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003c70:	9b03      	ldr	r3, [sp, #12]
 8003c72:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8003c76:	9b03      	ldr	r3, [sp, #12]
 8003c78:	60da      	str	r2, [r3, #12]
 8003c7a:	9b01      	ldr	r3, [sp, #4]
 8003c7c:	691a      	ldr	r2, [r3, #16]
 8003c7e:	9b03      	ldr	r3, [sp, #12]
 8003c80:	68db      	ldr	r3, [r3, #12]
 8003c82:	601a      	str	r2, [r3, #0]
 8003c84:	9b01      	ldr	r3, [sp, #4]
 8003c86:	695a      	ldr	r2, [r3, #20]
 8003c88:	9b03      	ldr	r3, [sp, #12]
 8003c8a:	68db      	ldr	r3, [r3, #12]
 8003c8c:	605a      	str	r2, [r3, #4]
 8003c8e:	9b03      	ldr	r3, [sp, #12]
 8003c90:	68db      	ldr	r3, [r3, #12]
 8003c92:	4a08      	ldr	r2, [pc, #32]	@ (8003cb4 <chThdCreateSuspendedI+0x114>)
 8003c94:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8003c96:	9b01      	ldr	r3, [sp, #4]
 8003c98:	681a      	ldr	r2, [r3, #0]
 8003c9a:	9b01      	ldr	r3, [sp, #4]
 8003c9c:	68db      	ldr	r3, [r3, #12]
 8003c9e:	9903      	ldr	r1, [sp, #12]
 8003ca0:	4805      	ldr	r0, [pc, #20]	@ (8003cb8 <chThdCreateSuspendedI+0x118>)
 8003ca2:	f7ff ff3d 	bl	8003b20 <__thd_object_init>
 8003ca6:	4603      	mov	r3, r0
}
 8003ca8:	4618      	mov	r0, r3
 8003caa:	b005      	add	sp, #20
 8003cac:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cb0:	08005500 	.word	0x08005500
 8003cb4:	08000291 	.word	0x08000291
 8003cb8:	20000940 	.word	0x20000940
 8003cbc:	00000000 	.word	0x00000000

08003cc0 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8003cc0:	b500      	push	{lr}
 8003cc2:	b083      	sub	sp, #12
 8003cc4:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8003cc6:	9801      	ldr	r0, [sp, #4]
 8003cc8:	f7ff ff6a 	bl	8003ba0 <chThdCreateSuspendedI>
 8003ccc:	4603      	mov	r3, r0
 8003cce:	4618      	mov	r0, r3
 8003cd0:	f7ff fc06 	bl	80034e0 <chSchReadyI>
 8003cd4:	4603      	mov	r3, r0
}
 8003cd6:	4618      	mov	r0, r3
 8003cd8:	b003      	add	sp, #12
 8003cda:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cde:	bf00      	nop

08003ce0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003ce0:	b500      	push	{lr}
 8003ce2:	b087      	sub	sp, #28
 8003ce4:	9003      	str	r0, [sp, #12]
 8003ce6:	9102      	str	r1, [sp, #8]
 8003ce8:	9201      	str	r2, [sp, #4]
 8003cea:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 8003cec:	9b03      	ldr	r3, [sp, #12]
 8003cee:	2b00      	cmp	r3, #0
 8003cf0:	bf0c      	ite	eq
 8003cf2:	2301      	moveq	r3, #1
 8003cf4:	2300      	movne	r3, #0
 8003cf6:	b2db      	uxtb	r3, r3
 8003cf8:	2b00      	cmp	r3, #0
 8003cfa:	d109      	bne.n	8003d10 <chThdCreateStatic+0x30>
 8003cfc:	9b03      	ldr	r3, [sp, #12]
 8003cfe:	f003 0307 	and.w	r3, r3, #7
 8003d02:	2b00      	cmp	r3, #0
 8003d04:	bf14      	ite	ne
 8003d06:	2301      	movne	r3, #1
 8003d08:	2300      	moveq	r3, #0
 8003d0a:	b2db      	uxtb	r3, r3
 8003d0c:	2b00      	cmp	r3, #0
 8003d0e:	d001      	beq.n	8003d14 <chThdCreateStatic+0x34>
 8003d10:	2301      	movs	r3, #1
 8003d12:	e000      	b.n	8003d16 <chThdCreateStatic+0x36>
 8003d14:	2300      	movs	r3, #0
 8003d16:	2b00      	cmp	r3, #0
 8003d18:	d107      	bne.n	8003d2a <chThdCreateStatic+0x4a>
 8003d1a:	9b02      	ldr	r3, [sp, #8]
 8003d1c:	2bef      	cmp	r3, #239	@ 0xef
 8003d1e:	bf94      	ite	ls
 8003d20:	2301      	movls	r3, #1
 8003d22:	2300      	movhi	r3, #0
 8003d24:	b2db      	uxtb	r3, r3
 8003d26:	2b00      	cmp	r3, #0
 8003d28:	d001      	beq.n	8003d2e <chThdCreateStatic+0x4e>
 8003d2a:	2301      	movs	r3, #1
 8003d2c:	e000      	b.n	8003d30 <chThdCreateStatic+0x50>
 8003d2e:	2300      	movs	r3, #0
 8003d30:	2b00      	cmp	r3, #0
 8003d32:	d109      	bne.n	8003d48 <chThdCreateStatic+0x68>
 8003d34:	9b02      	ldr	r3, [sp, #8]
 8003d36:	f003 0307 	and.w	r3, r3, #7
 8003d3a:	2b00      	cmp	r3, #0
 8003d3c:	bf14      	ite	ne
 8003d3e:	2301      	movne	r3, #1
 8003d40:	2300      	moveq	r3, #0
 8003d42:	b2db      	uxtb	r3, r3
 8003d44:	2b00      	cmp	r3, #0
 8003d46:	d001      	beq.n	8003d4c <chThdCreateStatic+0x6c>
 8003d48:	2301      	movs	r3, #1
 8003d4a:	e000      	b.n	8003d4e <chThdCreateStatic+0x6e>
 8003d4c:	2300      	movs	r3, #0
 8003d4e:	2b00      	cmp	r3, #0
 8003d50:	d107      	bne.n	8003d62 <chThdCreateStatic+0x82>
 8003d52:	9b01      	ldr	r3, [sp, #4]
 8003d54:	2bff      	cmp	r3, #255	@ 0xff
 8003d56:	bf8c      	ite	hi
 8003d58:	2301      	movhi	r3, #1
 8003d5a:	2300      	movls	r3, #0
 8003d5c:	b2db      	uxtb	r3, r3
 8003d5e:	2b00      	cmp	r3, #0
 8003d60:	d001      	beq.n	8003d66 <chThdCreateStatic+0x86>
 8003d62:	2301      	movs	r3, #1
 8003d64:	e000      	b.n	8003d68 <chThdCreateStatic+0x88>
 8003d66:	2300      	movs	r3, #0
 8003d68:	2b00      	cmp	r3, #0
 8003d6a:	d107      	bne.n	8003d7c <chThdCreateStatic+0x9c>
 8003d6c:	9b00      	ldr	r3, [sp, #0]
 8003d6e:	2b00      	cmp	r3, #0
 8003d70:	bf0c      	ite	eq
 8003d72:	2301      	moveq	r3, #1
 8003d74:	2300      	movne	r3, #0
 8003d76:	b2db      	uxtb	r3, r3
 8003d78:	2b00      	cmp	r3, #0
 8003d7a:	d002      	beq.n	8003d82 <chThdCreateStatic+0xa2>
 8003d7c:	481e      	ldr	r0, [pc, #120]	@ (8003df8 <chThdCreateStatic+0x118>)
 8003d7e:	f7fe fcb7 	bl	80026f0 <chSysHalt>
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8003d82:	9803      	ldr	r0, [sp, #12]
 8003d84:	f000 fa9c 	bl	80042c0 <chRegFindThreadByWorkingArea>
 8003d88:	4603      	mov	r3, r0
 8003d8a:	2b00      	cmp	r3, #0
 8003d8c:	bf14      	ite	ne
 8003d8e:	2301      	movne	r3, #1
 8003d90:	2300      	moveq	r3, #0
 8003d92:	b2db      	uxtb	r3, r3
 8003d94:	2b00      	cmp	r3, #0
 8003d96:	d002      	beq.n	8003d9e <chThdCreateStatic+0xbe>
 8003d98:	4817      	ldr	r0, [pc, #92]	@ (8003df8 <chThdCreateStatic+0x118>)
 8003d9a:	f7fe fca9 	bl	80026f0 <chSysHalt>

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wsp, (uint8_t *)wsp + size);
#endif

  chSysLock();
 8003d9e:	f7ff fe57 	bl	8003a50 <chSysLock.lto_priv.6>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 8003da2:	9b02      	ldr	r3, [sp, #8]
 8003da4:	3b48      	subs	r3, #72	@ 0x48
 8003da6:	9a03      	ldr	r2, [sp, #12]
 8003da8:	4413      	add	r3, r2
 8003daa:	9305      	str	r3, [sp, #20]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8003dac:	9b05      	ldr	r3, [sp, #20]
 8003dae:	9a03      	ldr	r2, [sp, #12]
 8003db0:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003db2:	9b05      	ldr	r3, [sp, #20]
 8003db4:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8003db8:	9b05      	ldr	r3, [sp, #20]
 8003dba:	60da      	str	r2, [r3, #12]
 8003dbc:	9b05      	ldr	r3, [sp, #20]
 8003dbe:	68db      	ldr	r3, [r3, #12]
 8003dc0:	9a00      	ldr	r2, [sp, #0]
 8003dc2:	601a      	str	r2, [r3, #0]
 8003dc4:	9b05      	ldr	r3, [sp, #20]
 8003dc6:	68db      	ldr	r3, [r3, #12]
 8003dc8:	9a08      	ldr	r2, [sp, #32]
 8003dca:	605a      	str	r2, [r3, #4]
 8003dcc:	9b05      	ldr	r3, [sp, #20]
 8003dce:	68db      	ldr	r3, [r3, #12]
 8003dd0:	4a0a      	ldr	r2, [pc, #40]	@ (8003dfc <chThdCreateStatic+0x11c>)
 8003dd2:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 8003dd4:	9b01      	ldr	r3, [sp, #4]
 8003dd6:	4a0a      	ldr	r2, [pc, #40]	@ (8003e00 <chThdCreateStatic+0x120>)
 8003dd8:	9905      	ldr	r1, [sp, #20]
 8003dda:	480a      	ldr	r0, [pc, #40]	@ (8003e04 <chThdCreateStatic+0x124>)
 8003ddc:	f7ff fea0 	bl	8003b20 <__thd_object_init>
 8003de0:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8003de2:	2100      	movs	r1, #0
 8003de4:	9805      	ldr	r0, [sp, #20]
 8003de6:	f7ff fc1b 	bl	8003620 <chSchWakeupS>
  chSysUnlock();
 8003dea:	f7ff fe41 	bl	8003a70 <chSysUnlock.lto_priv.6>

  return tp;
 8003dee:	9b05      	ldr	r3, [sp, #20]
}
 8003df0:	4618      	mov	r0, r3
 8003df2:	b007      	add	sp, #28
 8003df4:	f85d fb04 	ldr.w	pc, [sp], #4
 8003df8:	08005524 	.word	0x08005524
 8003dfc:	08000291 	.word	0x08000291
 8003e00:	0800540c 	.word	0x0800540c
 8003e04:	20000940 	.word	0x20000940
	...

08003e10 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8003e10:	b510      	push	{r4, lr}
 8003e12:	b082      	sub	sp, #8
 8003e14:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003e16:	f7ff fe1b 	bl	8003a50 <chSysLock.lto_priv.6>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8003e1a:	9b01      	ldr	r3, [sp, #4]
 8003e1c:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003e20:	2b00      	cmp	r3, #0
 8003e22:	bf0c      	ite	eq
 8003e24:	2301      	moveq	r3, #1
 8003e26:	2300      	movne	r3, #0
 8003e28:	b2db      	uxtb	r3, r3
 8003e2a:	2b00      	cmp	r3, #0
 8003e2c:	d002      	beq.n	8003e34 <chThdRelease+0x24>
 8003e2e:	481f      	ldr	r0, [pc, #124]	@ (8003eac <chThdRelease+0x9c>)
 8003e30:	f7fe fc5e 	bl	80026f0 <chSysHalt>
  tp->refs--;
 8003e34:	9b01      	ldr	r3, [sp, #4]
 8003e36:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003e3a:	3b01      	subs	r3, #1
 8003e3c:	b2da      	uxtb	r2, r3
 8003e3e:	9b01      	ldr	r3, [sp, #4]
 8003e40:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8003e44:	9b01      	ldr	r3, [sp, #4]
 8003e46:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003e4a:	2b00      	cmp	r3, #0
 8003e4c:	d129      	bne.n	8003ea2 <chThdRelease+0x92>
 8003e4e:	9b01      	ldr	r3, [sp, #4]
 8003e50:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003e54:	2b0f      	cmp	r3, #15
 8003e56:	d124      	bne.n	8003ea2 <chThdRelease+0x92>
    REG_REMOVE(tp);
 8003e58:	9b01      	ldr	r3, [sp, #4]
 8003e5a:	3310      	adds	r3, #16
 8003e5c:	4618      	mov	r0, r3
 8003e5e:	f7ff fde7 	bl	8003a30 <ch_queue_dequeue.lto_priv.1>
    chSysUnlock();
 8003e62:	f7ff fe05 	bl	8003a70 <chSysUnlock.lto_priv.6>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8003e66:	9b01      	ldr	r3, [sp, #4]
 8003e68:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8003e6c:	f003 0303 	and.w	r3, r3, #3
 8003e70:	2b01      	cmp	r3, #1
 8003e72:	d002      	beq.n	8003e7a <chThdRelease+0x6a>
 8003e74:	2b02      	cmp	r3, #2
 8003e76:	d008      	beq.n	8003e8a <chThdRelease+0x7a>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
      /* Nothing else to do for static threads.*/
      break;
 8003e78:	e012      	b.n	8003ea0 <chThdRelease+0x90>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8003e7a:	9801      	ldr	r0, [sp, #4]
 8003e7c:	f7ff fe30 	bl	8003ae0 <chThdGetWorkingAreaX.lto_priv.0>
 8003e80:	4603      	mov	r3, r0
 8003e82:	4618      	mov	r0, r3
 8003e84:	f000 fd1c 	bl	80048c0 <chHeapFree>
      break;
 8003e88:	e00a      	b.n	8003ea0 <chThdRelease+0x90>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8003e8a:	9b01      	ldr	r3, [sp, #4]
 8003e8c:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
 8003e8e:	9801      	ldr	r0, [sp, #4]
 8003e90:	f7ff fe26 	bl	8003ae0 <chThdGetWorkingAreaX.lto_priv.0>
 8003e94:	4603      	mov	r3, r0
 8003e96:	4619      	mov	r1, r3
 8003e98:	4620      	mov	r0, r4
 8003e9a:	f000 fe89 	bl	8004bb0 <chPoolFree>
      break;
 8003e9e:	bf00      	nop
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
 8003ea0:	e001      	b.n	8003ea6 <chThdRelease+0x96>
  }
  chSysUnlock();
 8003ea2:	f7ff fde5 	bl	8003a70 <chSysUnlock.lto_priv.6>
}
 8003ea6:	b002      	add	sp, #8
 8003ea8:	bd10      	pop	{r4, pc}
 8003eaa:	bf00      	nop
 8003eac:	08005538 	.word	0x08005538

08003eb0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8003eb0:	b500      	push	{lr}
 8003eb2:	b083      	sub	sp, #12
 8003eb4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003eb6:	f7ff fdcb 	bl	8003a50 <chSysLock.lto_priv.6>
  chThdExitS(msg);
 8003eba:	9801      	ldr	r0, [sp, #4]
 8003ebc:	f000 f808 	bl	8003ed0 <chThdExitS>
  /* The thread never returns here.*/
}
 8003ec0:	bf00      	nop
 8003ec2:	b003      	add	sp, #12
 8003ec4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003ed0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8003ed0:	b500      	push	{lr}
 8003ed2:	b085      	sub	sp, #20
 8003ed4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8003ed6:	f7ff fdfb 	bl	8003ad0 <chThdGetSelfX.lto_priv.0>
 8003eda:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 8003edc:	9b03      	ldr	r3, [sp, #12]
 8003ede:	9a01      	ldr	r2, [sp, #4]
 8003ee0:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003ee2:	e008      	b.n	8003ef6 <chThdExitS+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8003ee4:	9b03      	ldr	r3, [sp, #12]
 8003ee6:	332c      	adds	r3, #44	@ 0x2c
 8003ee8:	4618      	mov	r0, r3
 8003eea:	f7ff fd69 	bl	80039c0 <ch_list_unlink>
 8003eee:	4603      	mov	r3, r0
 8003ef0:	4618      	mov	r0, r3
 8003ef2:	f7ff faf5 	bl	80034e0 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003ef6:	9b03      	ldr	r3, [sp, #12]
 8003ef8:	332c      	adds	r3, #44	@ 0x2c
 8003efa:	4618      	mov	r0, r3
 8003efc:	f7ff fd50 	bl	80039a0 <ch_list_notempty>
 8003f00:	4603      	mov	r3, r0
 8003f02:	2b00      	cmp	r3, #0
 8003f04:	d1ee      	bne.n	8003ee4 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8003f06:	9b03      	ldr	r3, [sp, #12]
 8003f08:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003f0c:	2b00      	cmp	r3, #0
 8003f0e:	bf0c      	ite	eq
 8003f10:	2301      	moveq	r3, #1
 8003f12:	2300      	movne	r3, #0
 8003f14:	b2db      	uxtb	r3, r3
 8003f16:	2b00      	cmp	r3, #0
 8003f18:	d010      	beq.n	8003f3c <chThdExitS+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8003f1a:	9b03      	ldr	r3, [sp, #12]
 8003f1c:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8003f20:	f003 0303 	and.w	r3, r3, #3
 8003f24:	2b00      	cmp	r3, #0
 8003f26:	bf0c      	ite	eq
 8003f28:	2301      	moveq	r3, #1
 8003f2a:	2300      	movne	r3, #0
 8003f2c:	b2db      	uxtb	r3, r3
 8003f2e:	2b00      	cmp	r3, #0
 8003f30:	d004      	beq.n	8003f3c <chThdExitS+0x6c>
      REG_REMOVE(currtp);
 8003f32:	9b03      	ldr	r3, [sp, #12]
 8003f34:	3310      	adds	r3, #16
 8003f36:	4618      	mov	r0, r3
 8003f38:	f7ff fd7a 	bl	8003a30 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003f3c:	200f      	movs	r0, #15
 8003f3e:	f7ff faef 	bl	8003520 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8003f42:	4803      	ldr	r0, [pc, #12]	@ (8003f50 <chThdExitS+0x80>)
 8003f44:	f7fe fbd4 	bl	80026f0 <chSysHalt>
}
 8003f48:	bf00      	nop
 8003f4a:	b005      	add	sp, #20
 8003f4c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f50:	08005548 	.word	0x08005548
	...

08003f60 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8003f60:	b500      	push	{lr}
 8003f62:	b083      	sub	sp, #12
 8003f64:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003f66:	f7ff fd73 	bl	8003a50 <chSysLock.lto_priv.6>
  chThdSleepS(time);
 8003f6a:	9801      	ldr	r0, [sp, #4]
 8003f6c:	f7ff fdc0 	bl	8003af0 <chThdSleepS>
  chSysUnlock();
 8003f70:	f7ff fd7e 	bl	8003a70 <chSysUnlock.lto_priv.6>
}
 8003f74:	bf00      	nop
 8003f76:	b003      	add	sp, #12
 8003f78:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f7c:	0000      	movs	r0, r0
	...

08003f80 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8003f80:	b500      	push	{lr}
 8003f82:	b085      	sub	sp, #20
 8003f84:	9001      	str	r0, [sp, #4]
 8003f86:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8003f88:	f7ff fda2 	bl	8003ad0 <chThdGetSelfX.lto_priv.0>
 8003f8c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 8003f8e:	9b01      	ldr	r3, [sp, #4]
 8003f90:	681b      	ldr	r3, [r3, #0]
 8003f92:	2b00      	cmp	r3, #0
 8003f94:	bf14      	ite	ne
 8003f96:	2301      	movne	r3, #1
 8003f98:	2300      	moveq	r3, #0
 8003f9a:	b2db      	uxtb	r3, r3
 8003f9c:	2b00      	cmp	r3, #0
 8003f9e:	d002      	beq.n	8003fa6 <chThdSuspendTimeoutS+0x26>
 8003fa0:	480e      	ldr	r0, [pc, #56]	@ (8003fdc <chThdSuspendTimeoutS+0x5c>)
 8003fa2:	f7fe fba5 	bl	80026f0 <chSysHalt>

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8003fa6:	9b00      	ldr	r3, [sp, #0]
 8003fa8:	2b00      	cmp	r3, #0
 8003faa:	bf0c      	ite	eq
 8003fac:	2301      	moveq	r3, #1
 8003fae:	2300      	movne	r3, #0
 8003fb0:	b2db      	uxtb	r3, r3
 8003fb2:	2b00      	cmp	r3, #0
 8003fb4:	d002      	beq.n	8003fbc <chThdSuspendTimeoutS+0x3c>
    return MSG_TIMEOUT;
 8003fb6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8003fba:	e00a      	b.n	8003fd2 <chThdSuspendTimeoutS+0x52>
  }

  *trp = tp;
 8003fbc:	9b01      	ldr	r3, [sp, #4]
 8003fbe:	9a03      	ldr	r2, [sp, #12]
 8003fc0:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8003fc2:	9b03      	ldr	r3, [sp, #12]
 8003fc4:	9a01      	ldr	r2, [sp, #4]
 8003fc6:	629a      	str	r2, [r3, #40]	@ 0x28

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003fc8:	9900      	ldr	r1, [sp, #0]
 8003fca:	2003      	movs	r0, #3
 8003fcc:	f7ff faf0 	bl	80035b0 <chSchGoSleepTimeoutS>
 8003fd0:	4603      	mov	r3, r0
}
 8003fd2:	4618      	mov	r0, r3
 8003fd4:	b005      	add	sp, #20
 8003fd6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fda:	bf00      	nop
 8003fdc:	08005560 	.word	0x08005560

08003fe0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8003fe0:	b500      	push	{lr}
 8003fe2:	b085      	sub	sp, #20
 8003fe4:	9001      	str	r0, [sp, #4]
 8003fe6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8003fe8:	9b01      	ldr	r3, [sp, #4]
 8003fea:	681b      	ldr	r3, [r3, #0]
 8003fec:	2b00      	cmp	r3, #0
 8003fee:	d018      	beq.n	8004022 <chThdResumeI+0x42>
    thread_t *tp = *trp;
 8003ff0:	9b01      	ldr	r3, [sp, #4]
 8003ff2:	681b      	ldr	r3, [r3, #0]
 8003ff4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8003ff6:	9b03      	ldr	r3, [sp, #12]
 8003ff8:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003ffc:	2b03      	cmp	r3, #3
 8003ffe:	bf14      	ite	ne
 8004000:	2301      	movne	r3, #1
 8004002:	2300      	moveq	r3, #0
 8004004:	b2db      	uxtb	r3, r3
 8004006:	2b00      	cmp	r3, #0
 8004008:	d002      	beq.n	8004010 <chThdResumeI+0x30>
 800400a:	4808      	ldr	r0, [pc, #32]	@ (800402c <chThdResumeI+0x4c>)
 800400c:	f7fe fb70 	bl	80026f0 <chSysHalt>

    *trp = NULL;
 8004010:	9b01      	ldr	r3, [sp, #4]
 8004012:	2200      	movs	r2, #0
 8004014:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8004016:	9b03      	ldr	r3, [sp, #12]
 8004018:	9a00      	ldr	r2, [sp, #0]
 800401a:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 800401c:	9803      	ldr	r0, [sp, #12]
 800401e:	f7ff fa5f 	bl	80034e0 <chSchReadyI>
  }
}
 8004022:	bf00      	nop
 8004024:	b005      	add	sp, #20
 8004026:	f85d fb04 	ldr.w	pc, [sp], #4
 800402a:	bf00      	nop
 800402c:	08005578 	.word	0x08005578

08004030 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8004030:	b500      	push	{lr}
 8004032:	b085      	sub	sp, #20
 8004034:	9001      	str	r0, [sp, #4]
 8004036:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8004038:	9b01      	ldr	r3, [sp, #4]
 800403a:	681b      	ldr	r3, [r3, #0]
 800403c:	2b00      	cmp	r3, #0
 800403e:	d016      	beq.n	800406e <chThdResumeS+0x3e>
    thread_t *tp = *trp;
 8004040:	9b01      	ldr	r3, [sp, #4]
 8004042:	681b      	ldr	r3, [r3, #0]
 8004044:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004046:	9b03      	ldr	r3, [sp, #12]
 8004048:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800404c:	2b03      	cmp	r3, #3
 800404e:	bf14      	ite	ne
 8004050:	2301      	movne	r3, #1
 8004052:	2300      	moveq	r3, #0
 8004054:	b2db      	uxtb	r3, r3
 8004056:	2b00      	cmp	r3, #0
 8004058:	d002      	beq.n	8004060 <chThdResumeS+0x30>
 800405a:	4807      	ldr	r0, [pc, #28]	@ (8004078 <chThdResumeS+0x48>)
 800405c:	f7fe fb48 	bl	80026f0 <chSysHalt>

    *trp = NULL;
 8004060:	9b01      	ldr	r3, [sp, #4]
 8004062:	2200      	movs	r2, #0
 8004064:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 8004066:	9900      	ldr	r1, [sp, #0]
 8004068:	9803      	ldr	r0, [sp, #12]
 800406a:	f7ff fad9 	bl	8003620 <chSchWakeupS>
  }
}
 800406e:	bf00      	nop
 8004070:	b005      	add	sp, #20
 8004072:	f85d fb04 	ldr.w	pc, [sp], #4
 8004076:	bf00      	nop
 8004078:	08005588 	.word	0x08005588
 800407c:	00000000 	.word	0x00000000

08004080 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8004080:	b4f0      	push	{r4, r5, r6, r7}
 8004082:	b084      	sub	sp, #16
 8004084:	9003      	str	r0, [sp, #12]
 8004086:	9102      	str	r1, [sp, #8]
 8004088:	9201      	str	r2, [sp, #4]

  tmp->n++;
 800408a:	9b03      	ldr	r3, [sp, #12]
 800408c:	68db      	ldr	r3, [r3, #12]
 800408e:	1c5a      	adds	r2, r3, #1
 8004090:	9b03      	ldr	r3, [sp, #12]
 8004092:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8004094:	9b03      	ldr	r3, [sp, #12]
 8004096:	689b      	ldr	r3, [r3, #8]
 8004098:	9a02      	ldr	r2, [sp, #8]
 800409a:	1ad2      	subs	r2, r2, r3
 800409c:	9b01      	ldr	r3, [sp, #4]
 800409e:	1ad2      	subs	r2, r2, r3
 80040a0:	9b03      	ldr	r3, [sp, #12]
 80040a2:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80040a4:	9b03      	ldr	r3, [sp, #12]
 80040a6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80040aa:	9903      	ldr	r1, [sp, #12]
 80040ac:	6889      	ldr	r1, [r1, #8]
 80040ae:	2000      	movs	r0, #0
 80040b0:	460c      	mov	r4, r1
 80040b2:	4605      	mov	r5, r0
 80040b4:	1916      	adds	r6, r2, r4
 80040b6:	eb43 0705 	adc.w	r7, r3, r5
 80040ba:	9b03      	ldr	r3, [sp, #12]
 80040bc:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
 80040c0:	9b03      	ldr	r3, [sp, #12]
 80040c2:	689a      	ldr	r2, [r3, #8]
 80040c4:	9b03      	ldr	r3, [sp, #12]
 80040c6:	685b      	ldr	r3, [r3, #4]
 80040c8:	429a      	cmp	r2, r3
 80040ca:	d903      	bls.n	80040d4 <tm_stop+0x54>
    tmp->worst = tmp->last;
 80040cc:	9b03      	ldr	r3, [sp, #12]
 80040ce:	689a      	ldr	r2, [r3, #8]
 80040d0:	9b03      	ldr	r3, [sp, #12]
 80040d2:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 80040d4:	9b03      	ldr	r3, [sp, #12]
 80040d6:	689a      	ldr	r2, [r3, #8]
 80040d8:	9b03      	ldr	r3, [sp, #12]
 80040da:	681b      	ldr	r3, [r3, #0]
 80040dc:	429a      	cmp	r2, r3
 80040de:	d203      	bcs.n	80040e8 <tm_stop+0x68>
    tmp->best = tmp->last;
 80040e0:	9b03      	ldr	r3, [sp, #12]
 80040e2:	689a      	ldr	r2, [r3, #8]
 80040e4:	9b03      	ldr	r3, [sp, #12]
 80040e6:	601a      	str	r2, [r3, #0]
  }
}
 80040e8:	bf00      	nop
 80040ea:	b004      	add	sp, #16
 80040ec:	bcf0      	pop	{r4, r5, r6, r7}
 80040ee:	4770      	bx	lr

080040f0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80040f0:	b082      	sub	sp, #8
 80040f2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80040f4:	9b01      	ldr	r3, [sp, #4]
 80040f6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80040fa:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80040fc:	9b01      	ldr	r3, [sp, #4]
 80040fe:	2200      	movs	r2, #0
 8004100:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8004102:	9b01      	ldr	r3, [sp, #4]
 8004104:	2200      	movs	r2, #0
 8004106:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8004108:	9b01      	ldr	r3, [sp, #4]
 800410a:	2200      	movs	r2, #0
 800410c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 800410e:	9901      	ldr	r1, [sp, #4]
 8004110:	f04f 0200 	mov.w	r2, #0
 8004114:	f04f 0300 	mov.w	r3, #0
 8004118:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 800411c:	bf00      	nop
 800411e:	b002      	add	sp, #8
 8004120:	4770      	bx	lr
 8004122:	bf00      	nop
	...

08004130 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8004130:	b082      	sub	sp, #8
 8004132:	9001      	str	r0, [sp, #4]
  return DWT->CYCCNT;
 8004134:	4b03      	ldr	r3, [pc, #12]	@ (8004144 <chTMStartMeasurementX+0x14>)
 8004136:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8004138:	9b01      	ldr	r3, [sp, #4]
 800413a:	609a      	str	r2, [r3, #8]
}
 800413c:	bf00      	nop
 800413e:	b002      	add	sp, #8
 8004140:	4770      	bx	lr
 8004142:	bf00      	nop
 8004144:	e0001000 	.word	0xe0001000
	...

08004150 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8004150:	b500      	push	{lr}
 8004152:	b083      	sub	sp, #12
 8004154:	9001      	str	r0, [sp, #4]
 8004156:	4b06      	ldr	r3, [pc, #24]	@ (8004170 <chTMStopMeasurementX+0x20>)
 8004158:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 800415a:	4a06      	ldr	r2, [pc, #24]	@ (8004174 <chTMStopMeasurementX+0x24>)
 800415c:	6892      	ldr	r2, [r2, #8]
 800415e:	4619      	mov	r1, r3
 8004160:	9801      	ldr	r0, [sp, #4]
 8004162:	f7ff ff8d 	bl	8004080 <tm_stop>
}
 8004166:	bf00      	nop
 8004168:	b003      	add	sp, #12
 800416a:	f85d fb04 	ldr.w	pc, [sp], #4
 800416e:	bf00      	nop
 8004170:	e0001000 	.word	0xe0001000
 8004174:	20000934 	.word	0x20000934
	...

08004180 <chSysLock.lto_priv.7>:
static inline void chSysLock(void) {
 8004180:	b500      	push	{lr}
 8004182:	b083      	sub	sp, #12
 8004184:	2330      	movs	r3, #48	@ 0x30
 8004186:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004188:	9b01      	ldr	r3, [sp, #4]
 800418a:	f383 8811 	msr	BASEPRI, r3
}
 800418e:	bf00      	nop
}
 8004190:	bf00      	nop
  __dbg_check_lock();
 8004192:	f7fe fb35 	bl	8002800 <__dbg_check_lock>
}
 8004196:	bf00      	nop
 8004198:	b003      	add	sp, #12
 800419a:	f85d fb04 	ldr.w	pc, [sp], #4
 800419e:	bf00      	nop

080041a0 <chSysUnlock.lto_priv.7>:
static inline void chSysUnlock(void) {
 80041a0:	b500      	push	{lr}
 80041a2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80041a4:	f7fe fb54 	bl	8002850 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80041a8:	4b12      	ldr	r3, [pc, #72]	@ (80041f4 <chSysUnlock.lto_priv.7+0x54>)
 80041aa:	681b      	ldr	r3, [r3, #0]
 80041ac:	4a11      	ldr	r2, [pc, #68]	@ (80041f4 <chSysUnlock.lto_priv.7+0x54>)
 80041ae:	4293      	cmp	r3, r2
 80041b0:	bf14      	ite	ne
 80041b2:	2301      	movne	r3, #1
 80041b4:	2300      	moveq	r3, #0
 80041b6:	b2db      	uxtb	r3, r3
 80041b8:	2b00      	cmp	r3, #0
 80041ba:	d00f      	beq.n	80041dc <chSysUnlock.lto_priv.7+0x3c>
 80041bc:	4b0d      	ldr	r3, [pc, #52]	@ (80041f4 <chSysUnlock.lto_priv.7+0x54>)
 80041be:	68db      	ldr	r3, [r3, #12]
 80041c0:	689a      	ldr	r2, [r3, #8]
 80041c2:	4b0c      	ldr	r3, [pc, #48]	@ (80041f4 <chSysUnlock.lto_priv.7+0x54>)
 80041c4:	681b      	ldr	r3, [r3, #0]
 80041c6:	689b      	ldr	r3, [r3, #8]
 80041c8:	429a      	cmp	r2, r3
 80041ca:	bf34      	ite	cc
 80041cc:	2301      	movcc	r3, #1
 80041ce:	2300      	movcs	r3, #0
 80041d0:	b2db      	uxtb	r3, r3
 80041d2:	2b00      	cmp	r3, #0
 80041d4:	d002      	beq.n	80041dc <chSysUnlock.lto_priv.7+0x3c>
 80041d6:	4808      	ldr	r0, [pc, #32]	@ (80041f8 <chSysUnlock.lto_priv.7+0x58>)
 80041d8:	f7fe fa8a 	bl	80026f0 <chSysHalt>
 80041dc:	2300      	movs	r3, #0
 80041de:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80041e0:	9b01      	ldr	r3, [sp, #4]
 80041e2:	f383 8811 	msr	BASEPRI, r3
}
 80041e6:	bf00      	nop
}
 80041e8:	bf00      	nop
}
 80041ea:	bf00      	nop
 80041ec:	b003      	add	sp, #12
 80041ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80041f2:	bf00      	nop
 80041f4:	20000940 	.word	0x20000940
 80041f8:	080055c4 	.word	0x080055c4
 80041fc:	00000000 	.word	0x00000000

08004200 <chThdGetWorkingAreaX.lto_priv.1>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8004200:	b082      	sub	sp, #8
 8004202:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8004204:	9b01      	ldr	r3, [sp, #4]
 8004206:	6a1b      	ldr	r3, [r3, #32]
}
 8004208:	4618      	mov	r0, r3
 800420a:	b002      	add	sp, #8
 800420c:	4770      	bx	lr
 800420e:	bf00      	nop

08004210 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8004210:	b500      	push	{lr}
 8004212:	b083      	sub	sp, #12
  thread_t *tp;
  uint8_t *p;

  chSysLock();
 8004214:	f7ff ffb4 	bl	8004180 <chSysLock.lto_priv.7>
  p = (uint8_t *)REG_HEADER(currcore)->next;
 8004218:	4b0a      	ldr	r3, [pc, #40]	@ (8004244 <chRegFirstThread+0x34>)
 800421a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800421c:	9301      	str	r3, [sp, #4]
  /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 800421e:	9b01      	ldr	r3, [sp, #4]
 8004220:	3b10      	subs	r3, #16
 8004222:	9300      	str	r3, [sp, #0]
  /*lint -restore*/
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8004224:	9b00      	ldr	r3, [sp, #0]
 8004226:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800422a:	3301      	adds	r3, #1
 800422c:	b2da      	uxtb	r2, r3
 800422e:	9b00      	ldr	r3, [sp, #0]
 8004230:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
#endif
  chSysUnlock();
 8004234:	f7ff ffb4 	bl	80041a0 <chSysUnlock.lto_priv.7>

  return tp;
 8004238:	9b00      	ldr	r3, [sp, #0]
}
 800423a:	4618      	mov	r0, r3
 800423c:	b003      	add	sp, #12
 800423e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004242:	bf00      	nop
 8004244:	20000940 	.word	0x20000940
	...

08004250 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8004250:	b500      	push	{lr}
 8004252:	b087      	sub	sp, #28
 8004254:	9001      	str	r0, [sp, #4]
  thread_t *ntp;
  ch_queue_t *nqp;

  chSysLock();
 8004256:	f7ff ff93 	bl	8004180 <chSysLock.lto_priv.7>

  /* Next element in the registry queue.*/
  nqp = tp->rqueue.next;
 800425a:	9b01      	ldr	r3, [sp, #4]
 800425c:	691b      	ldr	r3, [r3, #16]
 800425e:	9304      	str	r3, [sp, #16]
  if (nqp == REG_HEADER(currcore)) {
 8004260:	9b04      	ldr	r3, [sp, #16]
 8004262:	4a15      	ldr	r2, [pc, #84]	@ (80042b8 <chRegNextThread+0x68>)
 8004264:	4293      	cmp	r3, r2
 8004266:	d102      	bne.n	800426e <chRegNextThread+0x1e>
    ntp = NULL;
 8004268:	2300      	movs	r3, #0
 800426a:	9305      	str	r3, [sp, #20]
 800426c:	e019      	b.n	80042a2 <chRegNextThread+0x52>
  }
  else {
    uint8_t *p = (uint8_t *)nqp;
 800426e:	9b04      	ldr	r3, [sp, #16]
 8004270:	9303      	str	r3, [sp, #12]
    /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8004272:	9b03      	ldr	r3, [sp, #12]
 8004274:	3b10      	subs	r3, #16
 8004276:	9305      	str	r3, [sp, #20]
    /*lint -restore*/

#if CH_CFG_USE_DYNAMIC == TRUE
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8004278:	9b05      	ldr	r3, [sp, #20]
 800427a:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800427e:	2bff      	cmp	r3, #255	@ 0xff
 8004280:	bf0c      	ite	eq
 8004282:	2301      	moveq	r3, #1
 8004284:	2300      	movne	r3, #0
 8004286:	b2db      	uxtb	r3, r3
 8004288:	2b00      	cmp	r3, #0
 800428a:	d002      	beq.n	8004292 <chRegNextThread+0x42>
 800428c:	480b      	ldr	r0, [pc, #44]	@ (80042bc <chRegNextThread+0x6c>)
 800428e:	f7fe fa2f 	bl	80026f0 <chSysHalt>

    ntp->refs++;
 8004292:	9b05      	ldr	r3, [sp, #20]
 8004294:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8004298:	3301      	adds	r3, #1
 800429a:	b2da      	uxtb	r2, r3
 800429c:	9b05      	ldr	r3, [sp, #20]
 800429e:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
#endif
  }
  chSysUnlock();
 80042a2:	f7ff ff7d 	bl	80041a0 <chSysUnlock.lto_priv.7>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80042a6:	9801      	ldr	r0, [sp, #4]
 80042a8:	f7ff fdb2 	bl	8003e10 <chThdRelease>
#endif

  return ntp;
 80042ac:	9b05      	ldr	r3, [sp, #20]
}
 80042ae:	4618      	mov	r0, r3
 80042b0:	b007      	add	sp, #28
 80042b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80042b6:	bf00      	nop
 80042b8:	20000968 	.word	0x20000968
 80042bc:	080055d0 	.word	0x080055d0

080042c0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 80042c0:	b500      	push	{lr}
 80042c2:	b085      	sub	sp, #20
 80042c4:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 80042c6:	f7ff ffa3 	bl	8004210 <chRegFirstThread>
 80042ca:	9003      	str	r0, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80042cc:	9803      	ldr	r0, [sp, #12]
 80042ce:	f7ff ff97 	bl	8004200 <chThdGetWorkingAreaX.lto_priv.1>
 80042d2:	4602      	mov	r2, r0
 80042d4:	9b01      	ldr	r3, [sp, #4]
 80042d6:	4293      	cmp	r3, r2
 80042d8:	d101      	bne.n	80042de <chRegFindThreadByWorkingArea+0x1e>
      return ctp;
 80042da:	9b03      	ldr	r3, [sp, #12]
 80042dc:	e007      	b.n	80042ee <chRegFindThreadByWorkingArea+0x2e>
    }
    ctp = chRegNextThread(ctp);
 80042de:	9803      	ldr	r0, [sp, #12]
 80042e0:	f7ff ffb6 	bl	8004250 <chRegNextThread>
 80042e4:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 80042e6:	9b03      	ldr	r3, [sp, #12]
 80042e8:	2b00      	cmp	r3, #0
 80042ea:	d1ef      	bne.n	80042cc <chRegFindThreadByWorkingArea+0xc>

  return NULL;
 80042ec:	2300      	movs	r3, #0
}
 80042ee:	4618      	mov	r0, r3
 80042f0:	b005      	add	sp, #20
 80042f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80042f6:	bf00      	nop
	...

08004300 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004300:	b082      	sub	sp, #8
 8004302:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004304:	9b01      	ldr	r3, [sp, #4]
 8004306:	9a01      	ldr	r2, [sp, #4]
 8004308:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800430a:	9b01      	ldr	r3, [sp, #4]
 800430c:	9a01      	ldr	r2, [sp, #4]
 800430e:	605a      	str	r2, [r3, #4]
}
 8004310:	bf00      	nop
 8004312:	b002      	add	sp, #8
 8004314:	4770      	bx	lr
 8004316:	bf00      	nop
	...

08004320 <ch_queue_notempty.lto_priv.2>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 8004320:	b082      	sub	sp, #8
 8004322:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 8004324:	9b01      	ldr	r3, [sp, #4]
 8004326:	681b      	ldr	r3, [r3, #0]
 8004328:	9a01      	ldr	r2, [sp, #4]
 800432a:	429a      	cmp	r2, r3
 800432c:	bf14      	ite	ne
 800432e:	2301      	movne	r3, #1
 8004330:	2300      	moveq	r3, #0
 8004332:	b2db      	uxtb	r3, r3
}
 8004334:	4618      	mov	r0, r3
 8004336:	b002      	add	sp, #8
 8004338:	4770      	bx	lr
 800433a:	bf00      	nop
 800433c:	0000      	movs	r0, r0
	...

08004340 <ch_queue_fifo_remove.lto_priv.2>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 8004340:	b084      	sub	sp, #16
 8004342:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 8004344:	9b01      	ldr	r3, [sp, #4]
 8004346:	681b      	ldr	r3, [r3, #0]
 8004348:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 800434a:	9b03      	ldr	r3, [sp, #12]
 800434c:	681a      	ldr	r2, [r3, #0]
 800434e:	9b01      	ldr	r3, [sp, #4]
 8004350:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 8004352:	9b01      	ldr	r3, [sp, #4]
 8004354:	681b      	ldr	r3, [r3, #0]
 8004356:	9a01      	ldr	r2, [sp, #4]
 8004358:	605a      	str	r2, [r3, #4]
  return p;
 800435a:	9b03      	ldr	r3, [sp, #12]
}
 800435c:	4618      	mov	r0, r3
 800435e:	b004      	add	sp, #16
 8004360:	4770      	bx	lr
 8004362:	bf00      	nop
	...

08004370 <ch_queue_dequeue.lto_priv.2>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8004370:	b082      	sub	sp, #8
 8004372:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8004374:	9b01      	ldr	r3, [sp, #4]
 8004376:	685b      	ldr	r3, [r3, #4]
 8004378:	9a01      	ldr	r2, [sp, #4]
 800437a:	6812      	ldr	r2, [r2, #0]
 800437c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800437e:	9b01      	ldr	r3, [sp, #4]
 8004380:	681b      	ldr	r3, [r3, #0]
 8004382:	9a01      	ldr	r2, [sp, #4]
 8004384:	6852      	ldr	r2, [r2, #4]
 8004386:	605a      	str	r2, [r3, #4]
  return p;
 8004388:	9b01      	ldr	r3, [sp, #4]
}
 800438a:	4618      	mov	r0, r3
 800438c:	b002      	add	sp, #8
 800438e:	4770      	bx	lr

08004390 <chSysLock.lto_priv.9>:
static inline void chSysLock(void) {
 8004390:	b500      	push	{lr}
 8004392:	b083      	sub	sp, #12
 8004394:	2330      	movs	r3, #48	@ 0x30
 8004396:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004398:	9b01      	ldr	r3, [sp, #4]
 800439a:	f383 8811 	msr	BASEPRI, r3
}
 800439e:	bf00      	nop
}
 80043a0:	bf00      	nop
  __dbg_check_lock();
 80043a2:	f7fe fa2d 	bl	8002800 <__dbg_check_lock>
}
 80043a6:	bf00      	nop
 80043a8:	b003      	add	sp, #12
 80043aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80043ae:	bf00      	nop

080043b0 <chSysUnlock.lto_priv.9>:
static inline void chSysUnlock(void) {
 80043b0:	b500      	push	{lr}
 80043b2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80043b4:	f7fe fa4c 	bl	8002850 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80043b8:	4b12      	ldr	r3, [pc, #72]	@ (8004404 <chSysUnlock.lto_priv.9+0x54>)
 80043ba:	681b      	ldr	r3, [r3, #0]
 80043bc:	4a11      	ldr	r2, [pc, #68]	@ (8004404 <chSysUnlock.lto_priv.9+0x54>)
 80043be:	4293      	cmp	r3, r2
 80043c0:	bf14      	ite	ne
 80043c2:	2301      	movne	r3, #1
 80043c4:	2300      	moveq	r3, #0
 80043c6:	b2db      	uxtb	r3, r3
 80043c8:	2b00      	cmp	r3, #0
 80043ca:	d00f      	beq.n	80043ec <chSysUnlock.lto_priv.9+0x3c>
 80043cc:	4b0d      	ldr	r3, [pc, #52]	@ (8004404 <chSysUnlock.lto_priv.9+0x54>)
 80043ce:	68db      	ldr	r3, [r3, #12]
 80043d0:	689a      	ldr	r2, [r3, #8]
 80043d2:	4b0c      	ldr	r3, [pc, #48]	@ (8004404 <chSysUnlock.lto_priv.9+0x54>)
 80043d4:	681b      	ldr	r3, [r3, #0]
 80043d6:	689b      	ldr	r3, [r3, #8]
 80043d8:	429a      	cmp	r2, r3
 80043da:	bf34      	ite	cc
 80043dc:	2301      	movcc	r3, #1
 80043de:	2300      	movcs	r3, #0
 80043e0:	b2db      	uxtb	r3, r3
 80043e2:	2b00      	cmp	r3, #0
 80043e4:	d002      	beq.n	80043ec <chSysUnlock.lto_priv.9+0x3c>
 80043e6:	4808      	ldr	r0, [pc, #32]	@ (8004408 <chSysUnlock.lto_priv.9+0x58>)
 80043e8:	f7fe f982 	bl	80026f0 <chSysHalt>
 80043ec:	2300      	movs	r3, #0
 80043ee:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80043f0:	9b01      	ldr	r3, [sp, #4]
 80043f2:	f383 8811 	msr	BASEPRI, r3
}
 80043f6:	bf00      	nop
}
 80043f8:	bf00      	nop
}
 80043fa:	bf00      	nop
 80043fc:	b003      	add	sp, #12
 80043fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004402:	bf00      	nop
 8004404:	20000940 	.word	0x20000940
 8004408:	080055f0 	.word	0x080055f0
 800440c:	00000000 	.word	0x00000000

08004410 <ch_sch_prio_insert.lto_priv.0>:
/*===========================================================================*/

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 8004410:	b084      	sub	sp, #16
 8004412:	9001      	str	r0, [sp, #4]
 8004414:	9100      	str	r1, [sp, #0]

  ch_queue_t *cp = qp;
 8004416:	9b01      	ldr	r3, [sp, #4]
 8004418:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->next;
 800441a:	9b03      	ldr	r3, [sp, #12]
 800441c:	681b      	ldr	r3, [r3, #0]
 800441e:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
 8004420:	9a03      	ldr	r2, [sp, #12]
 8004422:	9b01      	ldr	r3, [sp, #4]
 8004424:	429a      	cmp	r2, r3
 8004426:	d005      	beq.n	8004434 <ch_sch_prio_insert.lto_priv.0+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8004428:	9b03      	ldr	r3, [sp, #12]
 800442a:	689a      	ldr	r2, [r3, #8]
 800442c:	9b00      	ldr	r3, [sp, #0]
 800442e:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
 8004430:	429a      	cmp	r2, r3
 8004432:	d2f2      	bcs.n	800441a <ch_sch_prio_insert.lto_priv.0+0xa>
  tp->next       = cp;
 8004434:	9b00      	ldr	r3, [sp, #0]
 8004436:	9a03      	ldr	r2, [sp, #12]
 8004438:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
 800443a:	9b03      	ldr	r3, [sp, #12]
 800443c:	685a      	ldr	r2, [r3, #4]
 800443e:	9b00      	ldr	r3, [sp, #0]
 8004440:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
 8004442:	9b00      	ldr	r3, [sp, #0]
 8004444:	685b      	ldr	r3, [r3, #4]
 8004446:	9a00      	ldr	r2, [sp, #0]
 8004448:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
 800444a:	9b03      	ldr	r3, [sp, #12]
 800444c:	9a00      	ldr	r2, [sp, #0]
 800444e:	605a      	str	r2, [r3, #4]
}
 8004450:	bf00      	nop
 8004452:	b004      	add	sp, #16
 8004454:	4770      	bx	lr
 8004456:	bf00      	nop
	...

08004460 <chThdGetSelfX.lto_priv.2>:
  return __sch_get_currthread();
 8004460:	4b01      	ldr	r3, [pc, #4]	@ (8004468 <chThdGetSelfX.lto_priv.2+0x8>)
 8004462:	68db      	ldr	r3, [r3, #12]
}
 8004464:	4618      	mov	r0, r3
 8004466:	4770      	bx	lr
 8004468:	20000940 	.word	0x20000940
 800446c:	00000000 	.word	0x00000000

08004470 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8004470:	b500      	push	{lr}
 8004472:	b083      	sub	sp, #12
 8004474:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8004476:	f7fe fafb 	bl	8002a70 <chDbgCheckClassS>

  return ch_queue_notempty(&mp->queue);
 800447a:	9b01      	ldr	r3, [sp, #4]
 800447c:	4618      	mov	r0, r3
 800447e:	f7ff ff4f 	bl	8004320 <ch_queue_notempty.lto_priv.2>
 8004482:	4603      	mov	r3, r0
}
 8004484:	4618      	mov	r0, r3
 8004486:	b003      	add	sp, #12
 8004488:	f85d fb04 	ldr.w	pc, [sp], #4
 800448c:	0000      	movs	r0, r0
	...

08004490 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8004490:	b500      	push	{lr}
 8004492:	b083      	sub	sp, #12
 8004494:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8004496:	9b01      	ldr	r3, [sp, #4]
 8004498:	2b00      	cmp	r3, #0
 800449a:	bf0c      	ite	eq
 800449c:	2301      	moveq	r3, #1
 800449e:	2300      	movne	r3, #0
 80044a0:	b2db      	uxtb	r3, r3
 80044a2:	2b00      	cmp	r3, #0
 80044a4:	d002      	beq.n	80044ac <chMtxObjectInit+0x1c>
 80044a6:	4807      	ldr	r0, [pc, #28]	@ (80044c4 <chMtxObjectInit+0x34>)
 80044a8:	f7fe f922 	bl	80026f0 <chSysHalt>

  ch_queue_init(&mp->queue);
 80044ac:	9b01      	ldr	r3, [sp, #4]
 80044ae:	4618      	mov	r0, r3
 80044b0:	f7ff ff26 	bl	8004300 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 80044b4:	9b01      	ldr	r3, [sp, #4]
 80044b6:	2200      	movs	r2, #0
 80044b8:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 80044ba:	bf00      	nop
 80044bc:	b003      	add	sp, #12
 80044be:	f85d fb04 	ldr.w	pc, [sp], #4
 80044c2:	bf00      	nop
 80044c4:	080055e0 	.word	0x080055e0
	...

080044d0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80044d0:	b500      	push	{lr}
 80044d2:	b083      	sub	sp, #12
 80044d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80044d6:	f7ff ff5b 	bl	8004390 <chSysLock.lto_priv.9>
  chMtxLockS(mp);
 80044da:	9801      	ldr	r0, [sp, #4]
 80044dc:	f000 f808 	bl	80044f0 <chMtxLockS>
  chSysUnlock();
 80044e0:	f7ff ff66 	bl	80043b0 <chSysUnlock.lto_priv.9>
}
 80044e4:	bf00      	nop
 80044e6:	b003      	add	sp, #12
 80044e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80044ec:	0000      	movs	r0, r0
	...

080044f0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80044f0:	b510      	push	{r4, lr}
 80044f2:	b084      	sub	sp, #16
 80044f4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 80044f6:	f7ff ffb3 	bl	8004460 <chThdGetSelfX.lto_priv.2>
 80044fa:	9002      	str	r0, [sp, #8]

  chDbgCheckClassS();
 80044fc:	f7fe fab8 	bl	8002a70 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8004500:	9b01      	ldr	r3, [sp, #4]
 8004502:	2b00      	cmp	r3, #0
 8004504:	bf0c      	ite	eq
 8004506:	2301      	moveq	r3, #1
 8004508:	2300      	movne	r3, #0
 800450a:	b2db      	uxtb	r3, r3
 800450c:	2b00      	cmp	r3, #0
 800450e:	d002      	beq.n	8004516 <chMtxLockS+0x26>
 8004510:	4840      	ldr	r0, [pc, #256]	@ (8004614 <chMtxLockS+0x124>)
 8004512:	f7fe f8ed 	bl	80026f0 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8004516:	9b01      	ldr	r3, [sp, #4]
 8004518:	689b      	ldr	r3, [r3, #8]
 800451a:	2b00      	cmp	r3, #0
 800451c:	d06c      	beq.n	80045f8 <chMtxLockS+0x108>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 800451e:	9b01      	ldr	r3, [sp, #4]
 8004520:	689b      	ldr	r3, [r3, #8]
 8004522:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8004524:	e03b      	b.n	800459e <chMtxLockS+0xae>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8004526:	9b02      	ldr	r3, [sp, #8]
 8004528:	689a      	ldr	r2, [r3, #8]
 800452a:	9b03      	ldr	r3, [sp, #12]
 800452c:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800452e:	9b03      	ldr	r3, [sp, #12]
 8004530:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004534:	2b07      	cmp	r3, #7
 8004536:	d016      	beq.n	8004566 <chMtxLockS+0x76>
 8004538:	2b07      	cmp	r3, #7
 800453a:	dc2e      	bgt.n	800459a <chMtxLockS+0xaa>
 800453c:	2b00      	cmp	r3, #0
 800453e:	d01f      	beq.n	8004580 <chMtxLockS+0x90>
 8004540:	2b06      	cmp	r3, #6
 8004542:	d12a      	bne.n	800459a <chMtxLockS+0xaa>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004544:	9b03      	ldr	r3, [sp, #12]
 8004546:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004548:	461c      	mov	r4, r3
 800454a:	9b03      	ldr	r3, [sp, #12]
 800454c:	4618      	mov	r0, r3
 800454e:	f7ff ff0f 	bl	8004370 <ch_queue_dequeue.lto_priv.2>
 8004552:	4603      	mov	r3, r0
 8004554:	4619      	mov	r1, r3
 8004556:	4620      	mov	r0, r4
 8004558:	f7ff ff5a 	bl	8004410 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          tp = tp->u.wtmtxp->owner;
 800455c:	9b03      	ldr	r3, [sp, #12]
 800455e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004560:	689b      	ldr	r3, [r3, #8]
 8004562:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8004564:	e01b      	b.n	800459e <chMtxLockS+0xae>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004566:	9b03      	ldr	r3, [sp, #12]
 8004568:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800456a:	461c      	mov	r4, r3
 800456c:	9b03      	ldr	r3, [sp, #12]
 800456e:	4618      	mov	r0, r3
 8004570:	f7ff fefe 	bl	8004370 <ch_queue_dequeue.lto_priv.2>
 8004574:	4603      	mov	r3, r0
 8004576:	4619      	mov	r1, r3
 8004578:	4620      	mov	r0, r4
 800457a:	f7ff ff49 	bl	8004410 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          break;
 800457e:	e00d      	b.n	800459c <chMtxLockS+0xac>
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8004580:	9b03      	ldr	r3, [sp, #12]
 8004582:	2201      	movs	r2, #1
 8004584:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 8004588:	9b03      	ldr	r3, [sp, #12]
 800458a:	4618      	mov	r0, r3
 800458c:	f7ff fef0 	bl	8004370 <ch_queue_dequeue.lto_priv.2>
 8004590:	4603      	mov	r3, r0
 8004592:	4618      	mov	r0, r3
 8004594:	f7fe ffa4 	bl	80034e0 <chSchReadyI>
          break;
 8004598:	e000      	b.n	800459c <chMtxLockS+0xac>
        default:
          /* Nothing to do for other states.*/
          break;
 800459a:	bf00      	nop
        }
        break;
 800459c:	e005      	b.n	80045aa <chMtxLockS+0xba>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 800459e:	9b03      	ldr	r3, [sp, #12]
 80045a0:	689a      	ldr	r2, [r3, #8]
 80045a2:	9b02      	ldr	r3, [sp, #8]
 80045a4:	689b      	ldr	r3, [r3, #8]
 80045a6:	429a      	cmp	r2, r3
 80045a8:	d3bd      	bcc.n	8004526 <chMtxLockS+0x36>
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
 80045aa:	9b01      	ldr	r3, [sp, #4]
 80045ac:	9a02      	ldr	r2, [sp, #8]
 80045ae:	4611      	mov	r1, r2
 80045b0:	4618      	mov	r0, r3
 80045b2:	f7ff ff2d 	bl	8004410 <ch_sch_prio_insert.lto_priv.0>
      currtp->u.wtmtxp = mp;
 80045b6:	9b02      	ldr	r3, [sp, #8]
 80045b8:	9a01      	ldr	r2, [sp, #4]
 80045ba:	629a      	str	r2, [r3, #40]	@ 0x28
      chSchGoSleepS(CH_STATE_WTMTX);
 80045bc:	2006      	movs	r0, #6
 80045be:	f7fe ffaf 	bl	8003520 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 80045c2:	9b01      	ldr	r3, [sp, #4]
 80045c4:	689b      	ldr	r3, [r3, #8]
 80045c6:	9a02      	ldr	r2, [sp, #8]
 80045c8:	429a      	cmp	r2, r3
 80045ca:	bf14      	ite	ne
 80045cc:	2301      	movne	r3, #1
 80045ce:	2300      	moveq	r3, #0
 80045d0:	b2db      	uxtb	r3, r3
 80045d2:	2b00      	cmp	r3, #0
 80045d4:	d002      	beq.n	80045dc <chMtxLockS+0xec>
 80045d6:	480f      	ldr	r0, [pc, #60]	@ (8004614 <chMtxLockS+0x124>)
 80045d8:	f7fe f88a 	bl	80026f0 <chSysHalt>
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 80045dc:	9b02      	ldr	r3, [sp, #8]
 80045de:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80045e0:	9a01      	ldr	r2, [sp, #4]
 80045e2:	429a      	cmp	r2, r3
 80045e4:	bf14      	ite	ne
 80045e6:	2301      	movne	r3, #1
 80045e8:	2300      	moveq	r3, #0
 80045ea:	b2db      	uxtb	r3, r3
 80045ec:	2b00      	cmp	r3, #0
 80045ee:	d00d      	beq.n	800460c <chMtxLockS+0x11c>
 80045f0:	4808      	ldr	r0, [pc, #32]	@ (8004614 <chMtxLockS+0x124>)
 80045f2:	f7fe f87d 	bl	80026f0 <chSysHalt>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 80045f6:	e009      	b.n	800460c <chMtxLockS+0x11c>
    mp->owner = currtp;
 80045f8:	9b01      	ldr	r3, [sp, #4]
 80045fa:	9a02      	ldr	r2, [sp, #8]
 80045fc:	609a      	str	r2, [r3, #8]
    mp->next = currtp->mtxlist;
 80045fe:	9b02      	ldr	r3, [sp, #8]
 8004600:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8004602:	9b01      	ldr	r3, [sp, #4]
 8004604:	60da      	str	r2, [r3, #12]
    currtp->mtxlist = mp;
 8004606:	9b02      	ldr	r3, [sp, #8]
 8004608:	9a01      	ldr	r2, [sp, #4]
 800460a:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 800460c:	bf00      	nop
 800460e:	b004      	add	sp, #16
 8004610:	bd10      	pop	{r4, pc}
 8004612:	bf00      	nop
 8004614:	080055fc 	.word	0x080055fc
	...

08004620 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8004620:	b500      	push	{lr}
 8004622:	b087      	sub	sp, #28
 8004624:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004626:	f7ff ff1b 	bl	8004460 <chThdGetSelfX.lto_priv.2>
 800462a:	9003      	str	r0, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800462c:	9b01      	ldr	r3, [sp, #4]
 800462e:	2b00      	cmp	r3, #0
 8004630:	bf0c      	ite	eq
 8004632:	2301      	moveq	r3, #1
 8004634:	2300      	movne	r3, #0
 8004636:	b2db      	uxtb	r3, r3
 8004638:	2b00      	cmp	r3, #0
 800463a:	d002      	beq.n	8004642 <chMtxUnlock+0x22>
 800463c:	4839      	ldr	r0, [pc, #228]	@ (8004724 <chMtxUnlock+0x104>)
 800463e:	f7fe f857 	bl	80026f0 <chSysHalt>

  chSysLock();
 8004642:	f7ff fea5 	bl	8004390 <chSysLock.lto_priv.9>

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8004646:	9b03      	ldr	r3, [sp, #12]
 8004648:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800464a:	2b00      	cmp	r3, #0
 800464c:	bf0c      	ite	eq
 800464e:	2301      	moveq	r3, #1
 8004650:	2300      	movne	r3, #0
 8004652:	b2db      	uxtb	r3, r3
 8004654:	2b00      	cmp	r3, #0
 8004656:	d002      	beq.n	800465e <chMtxUnlock+0x3e>
 8004658:	4832      	ldr	r0, [pc, #200]	@ (8004724 <chMtxUnlock+0x104>)
 800465a:	f7fe f849 	bl	80026f0 <chSysHalt>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 800465e:	9b03      	ldr	r3, [sp, #12]
 8004660:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8004662:	689b      	ldr	r3, [r3, #8]
 8004664:	9a03      	ldr	r2, [sp, #12]
 8004666:	429a      	cmp	r2, r3
 8004668:	bf14      	ite	ne
 800466a:	2301      	movne	r3, #1
 800466c:	2300      	moveq	r3, #0
 800466e:	b2db      	uxtb	r3, r3
 8004670:	2b00      	cmp	r3, #0
 8004672:	d002      	beq.n	800467a <chMtxUnlock+0x5a>
 8004674:	482b      	ldr	r0, [pc, #172]	@ (8004724 <chMtxUnlock+0x104>)
 8004676:	f7fe f83b 	bl	80026f0 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 800467a:	9b03      	ldr	r3, [sp, #12]
 800467c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800467e:	9a01      	ldr	r2, [sp, #4]
 8004680:	429a      	cmp	r2, r3
 8004682:	bf14      	ite	ne
 8004684:	2301      	movne	r3, #1
 8004686:	2300      	moveq	r3, #0
 8004688:	b2db      	uxtb	r3, r3
 800468a:	2b00      	cmp	r3, #0
 800468c:	d002      	beq.n	8004694 <chMtxUnlock+0x74>
 800468e:	4825      	ldr	r0, [pc, #148]	@ (8004724 <chMtxUnlock+0x104>)
 8004690:	f7fe f82e 	bl	80026f0 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 8004694:	9b01      	ldr	r3, [sp, #4]
 8004696:	68da      	ldr	r2, [r3, #12]
 8004698:	9b03      	ldr	r3, [sp, #12]
 800469a:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800469c:	9801      	ldr	r0, [sp, #4]
 800469e:	f7ff fee7 	bl	8004470 <chMtxQueueNotEmptyS>
 80046a2:	4603      	mov	r3, r0
 80046a4:	2b00      	cmp	r3, #0
 80046a6:	d034      	beq.n	8004712 <chMtxUnlock+0xf2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 80046a8:	9b03      	ldr	r3, [sp, #12]
 80046aa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80046ac:	9304      	str	r3, [sp, #16]
      lmp = currtp->mtxlist;
 80046ae:	9b03      	ldr	r3, [sp, #12]
 80046b0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80046b2:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80046b4:	e012      	b.n	80046dc <chMtxUnlock+0xbc>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80046b6:	9805      	ldr	r0, [sp, #20]
 80046b8:	f7ff feda 	bl	8004470 <chMtxQueueNotEmptyS>
 80046bc:	4603      	mov	r3, r0
 80046be:	2b00      	cmp	r3, #0
 80046c0:	d009      	beq.n	80046d6 <chMtxUnlock+0xb6>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 80046c2:	9b05      	ldr	r3, [sp, #20]
 80046c4:	681b      	ldr	r3, [r3, #0]
 80046c6:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 80046c8:	9a04      	ldr	r2, [sp, #16]
 80046ca:	429a      	cmp	r2, r3
 80046cc:	d203      	bcs.n	80046d6 <chMtxUnlock+0xb6>
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
 80046ce:	9b05      	ldr	r3, [sp, #20]
 80046d0:	681b      	ldr	r3, [r3, #0]
 80046d2:	689b      	ldr	r3, [r3, #8]
 80046d4:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 80046d6:	9b05      	ldr	r3, [sp, #20]
 80046d8:	68db      	ldr	r3, [r3, #12]
 80046da:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80046dc:	9b05      	ldr	r3, [sp, #20]
 80046de:	2b00      	cmp	r3, #0
 80046e0:	d1e9      	bne.n	80046b6 <chMtxUnlock+0x96>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 80046e2:	9b03      	ldr	r3, [sp, #12]
 80046e4:	9a04      	ldr	r2, [sp, #16]
 80046e6:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
 80046e8:	9b01      	ldr	r3, [sp, #4]
 80046ea:	4618      	mov	r0, r3
 80046ec:	f7ff fe28 	bl	8004340 <ch_queue_fifo_remove.lto_priv.2>
 80046f0:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 80046f2:	9b01      	ldr	r3, [sp, #4]
 80046f4:	9a02      	ldr	r2, [sp, #8]
 80046f6:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 80046f8:	9b02      	ldr	r3, [sp, #8]
 80046fa:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80046fc:	9b01      	ldr	r3, [sp, #4]
 80046fe:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8004700:	9b02      	ldr	r3, [sp, #8]
 8004702:	9a01      	ldr	r2, [sp, #4]
 8004704:	63da      	str	r2, [r3, #60]	@ 0x3c

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8004706:	9802      	ldr	r0, [sp, #8]
 8004708:	f7fe feea 	bl	80034e0 <chSchReadyI>
      chSchRescheduleS();
 800470c:	f7fe ffd8 	bl	80036c0 <chSchRescheduleS>
 8004710:	e002      	b.n	8004718 <chMtxUnlock+0xf8>
    }
    else {
      mp->owner = NULL;
 8004712:	9b01      	ldr	r3, [sp, #4]
 8004714:	2200      	movs	r2, #0
 8004716:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8004718:	f7ff fe4a 	bl	80043b0 <chSysUnlock.lto_priv.9>
}
 800471c:	bf00      	nop
 800471e:	b007      	add	sp, #28
 8004720:	f85d fb04 	ldr.w	pc, [sp], #4
 8004724:	08005608 	.word	0x08005608
	...

08004730 <chSysLock.lto_priv.15>:
static inline void chSysLock(void) {
 8004730:	b500      	push	{lr}
 8004732:	b083      	sub	sp, #12
 8004734:	2330      	movs	r3, #48	@ 0x30
 8004736:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004738:	9b01      	ldr	r3, [sp, #4]
 800473a:	f383 8811 	msr	BASEPRI, r3
}
 800473e:	bf00      	nop
}
 8004740:	bf00      	nop
  __dbg_check_lock();
 8004742:	f7fe f85d 	bl	8002800 <__dbg_check_lock>
}
 8004746:	bf00      	nop
 8004748:	b003      	add	sp, #12
 800474a:	f85d fb04 	ldr.w	pc, [sp], #4
 800474e:	bf00      	nop

08004750 <chSysUnlock.lto_priv.15>:
static inline void chSysUnlock(void) {
 8004750:	b500      	push	{lr}
 8004752:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004754:	f7fe f87c 	bl	8002850 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004758:	4b12      	ldr	r3, [pc, #72]	@ (80047a4 <chSysUnlock.lto_priv.15+0x54>)
 800475a:	681b      	ldr	r3, [r3, #0]
 800475c:	4a11      	ldr	r2, [pc, #68]	@ (80047a4 <chSysUnlock.lto_priv.15+0x54>)
 800475e:	4293      	cmp	r3, r2
 8004760:	bf14      	ite	ne
 8004762:	2301      	movne	r3, #1
 8004764:	2300      	moveq	r3, #0
 8004766:	b2db      	uxtb	r3, r3
 8004768:	2b00      	cmp	r3, #0
 800476a:	d00f      	beq.n	800478c <chSysUnlock.lto_priv.15+0x3c>
 800476c:	4b0d      	ldr	r3, [pc, #52]	@ (80047a4 <chSysUnlock.lto_priv.15+0x54>)
 800476e:	68db      	ldr	r3, [r3, #12]
 8004770:	689a      	ldr	r2, [r3, #8]
 8004772:	4b0c      	ldr	r3, [pc, #48]	@ (80047a4 <chSysUnlock.lto_priv.15+0x54>)
 8004774:	681b      	ldr	r3, [r3, #0]
 8004776:	689b      	ldr	r3, [r3, #8]
 8004778:	429a      	cmp	r2, r3
 800477a:	bf34      	ite	cc
 800477c:	2301      	movcc	r3, #1
 800477e:	2300      	movcs	r3, #0
 8004780:	b2db      	uxtb	r3, r3
 8004782:	2b00      	cmp	r3, #0
 8004784:	d002      	beq.n	800478c <chSysUnlock.lto_priv.15+0x3c>
 8004786:	4808      	ldr	r0, [pc, #32]	@ (80047a8 <chSysUnlock.lto_priv.15+0x58>)
 8004788:	f7fd ffb2 	bl	80026f0 <chSysHalt>
 800478c:	2300      	movs	r3, #0
 800478e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004790:	9b01      	ldr	r3, [sp, #4]
 8004792:	f383 8811 	msr	BASEPRI, r3
}
 8004796:	bf00      	nop
}
 8004798:	bf00      	nop
}
 800479a:	bf00      	nop
 800479c:	b003      	add	sp, #12
 800479e:	f85d fb04 	ldr.w	pc, [sp], #4
 80047a2:	bf00      	nop
 80047a4:	20000940 	.word	0x20000940
 80047a8:	08005628 	.word	0x08005628
 80047ac:	00000000 	.word	0x00000000

080047b0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 80047b0:	4b03      	ldr	r3, [pc, #12]	@ (80047c0 <__core_init+0x10>)
 80047b2:	4a04      	ldr	r2, [pc, #16]	@ (80047c4 <__core_init+0x14>)
 80047b4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 80047b6:	4b02      	ldr	r3, [pc, #8]	@ (80047c0 <__core_init+0x10>)
 80047b8:	4a03      	ldr	r2, [pc, #12]	@ (80047c8 <__core_init+0x18>)
 80047ba:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 80047bc:	bf00      	nop
 80047be:	4770      	bx	lr
 80047c0:	20000b00 	.word	0x20000b00
 80047c4:	20000df0 	.word	0x20000df0
 80047c8:	20018000 	.word	0x20018000
 80047cc:	00000000 	.word	0x00000000

080047d0 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 80047d0:	b500      	push	{lr}
 80047d2:	b087      	sub	sp, #28
 80047d4:	9003      	str	r0, [sp, #12]
 80047d6:	9102      	str	r1, [sp, #8]
 80047d8:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 80047da:	f7fe f929 	bl	8002a30 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80047de:	9b02      	ldr	r3, [sp, #8]
 80047e0:	2b00      	cmp	r3, #0
 80047e2:	bf0c      	ite	eq
 80047e4:	2301      	moveq	r3, #1
 80047e6:	2300      	movne	r3, #0
 80047e8:	b2db      	uxtb	r3, r3
 80047ea:	2b00      	cmp	r3, #0
 80047ec:	d10a      	bne.n	8004804 <chCoreAllocFromTopI+0x34>
 80047ee:	9b02      	ldr	r3, [sp, #8]
 80047f0:	1e5a      	subs	r2, r3, #1
 80047f2:	9b02      	ldr	r3, [sp, #8]
 80047f4:	4013      	ands	r3, r2
 80047f6:	2b00      	cmp	r3, #0
 80047f8:	bf14      	ite	ne
 80047fa:	2301      	movne	r3, #1
 80047fc:	2300      	moveq	r3, #0
 80047fe:	b2db      	uxtb	r3, r3
 8004800:	2b00      	cmp	r3, #0
 8004802:	d002      	beq.n	800480a <chCoreAllocFromTopI+0x3a>
 8004804:	4812      	ldr	r0, [pc, #72]	@ (8004850 <chCoreAllocFromTopI+0x80>)
 8004806:	f7fd ff73 	bl	80026f0 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 800480a:	4b12      	ldr	r3, [pc, #72]	@ (8004854 <chCoreAllocFromTopI+0x84>)
 800480c:	685a      	ldr	r2, [r3, #4]
 800480e:	9b03      	ldr	r3, [sp, #12]
 8004810:	425b      	negs	r3, r3
 8004812:	4413      	add	r3, r2
 8004814:	461a      	mov	r2, r3
 8004816:	9b02      	ldr	r3, [sp, #8]
 8004818:	425b      	negs	r3, r3
 800481a:	4013      	ands	r3, r2
 800481c:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 800481e:	9b01      	ldr	r3, [sp, #4]
 8004820:	425b      	negs	r3, r3
 8004822:	9a05      	ldr	r2, [sp, #20]
 8004824:	4413      	add	r3, r2
 8004826:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8004828:	4b0a      	ldr	r3, [pc, #40]	@ (8004854 <chCoreAllocFromTopI+0x84>)
 800482a:	681b      	ldr	r3, [r3, #0]
 800482c:	9a04      	ldr	r2, [sp, #16]
 800482e:	429a      	cmp	r2, r3
 8004830:	d304      	bcc.n	800483c <chCoreAllocFromTopI+0x6c>
 8004832:	4b08      	ldr	r3, [pc, #32]	@ (8004854 <chCoreAllocFromTopI+0x84>)
 8004834:	685b      	ldr	r3, [r3, #4]
 8004836:	9a04      	ldr	r2, [sp, #16]
 8004838:	429a      	cmp	r2, r3
 800483a:	d901      	bls.n	8004840 <chCoreAllocFromTopI+0x70>
    return NULL;
 800483c:	2300      	movs	r3, #0
 800483e:	e003      	b.n	8004848 <chCoreAllocFromTopI+0x78>
  }

  ch_memcore.topmem = prev;
 8004840:	4a04      	ldr	r2, [pc, #16]	@ (8004854 <chCoreAllocFromTopI+0x84>)
 8004842:	9b04      	ldr	r3, [sp, #16]
 8004844:	6053      	str	r3, [r2, #4]

  return p;
 8004846:	9b05      	ldr	r3, [sp, #20]
}
 8004848:	4618      	mov	r0, r3
 800484a:	b007      	add	sp, #28
 800484c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004850:	08005614 	.word	0x08005614
 8004854:	20000b00 	.word	0x20000b00
	...

08004860 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8004860:	b500      	push	{lr}
 8004862:	b087      	sub	sp, #28
 8004864:	9003      	str	r0, [sp, #12]
 8004866:	9102      	str	r1, [sp, #8]
 8004868:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 800486a:	f7ff ff61 	bl	8004730 <chSysLock.lto_priv.15>
  p = chCoreAllocFromTopI(size, align, offset);
 800486e:	9a01      	ldr	r2, [sp, #4]
 8004870:	9902      	ldr	r1, [sp, #8]
 8004872:	9803      	ldr	r0, [sp, #12]
 8004874:	f7ff ffac 	bl	80047d0 <chCoreAllocFromTopI>
 8004878:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800487a:	f7ff ff69 	bl	8004750 <chSysUnlock.lto_priv.15>

  return p;
 800487e:	9b05      	ldr	r3, [sp, #20]
}
 8004880:	4618      	mov	r0, r3
 8004882:	b007      	add	sp, #28
 8004884:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004890 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 8004890:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8004892:	4b07      	ldr	r3, [pc, #28]	@ (80048b0 <__heap_init+0x20>)
 8004894:	4a07      	ldr	r2, [pc, #28]	@ (80048b4 <__heap_init+0x24>)
 8004896:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8004898:	4b05      	ldr	r3, [pc, #20]	@ (80048b0 <__heap_init+0x20>)
 800489a:	2200      	movs	r2, #0
 800489c:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 800489e:	4b04      	ldr	r3, [pc, #16]	@ (80048b0 <__heap_init+0x20>)
 80048a0:	2200      	movs	r2, #0
 80048a2:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80048a4:	4804      	ldr	r0, [pc, #16]	@ (80048b8 <__heap_init+0x28>)
 80048a6:	f7ff fdf3 	bl	8004490 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 80048aa:	bf00      	nop
 80048ac:	bd08      	pop	{r3, pc}
 80048ae:	bf00      	nop
 80048b0:	20000b08 	.word	0x20000b08
 80048b4:	08004861 	.word	0x08004861
 80048b8:	20000b14 	.word	0x20000b14
 80048bc:	00000000 	.word	0x00000000

080048c0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80048c0:	b500      	push	{lr}
 80048c2:	b087      	sub	sp, #28
 80048c4:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80048c6:	9b01      	ldr	r3, [sp, #4]
 80048c8:	2b00      	cmp	r3, #0
 80048ca:	bf0c      	ite	eq
 80048cc:	2301      	moveq	r3, #1
 80048ce:	2300      	movne	r3, #0
 80048d0:	b2db      	uxtb	r3, r3
 80048d2:	2b00      	cmp	r3, #0
 80048d4:	d109      	bne.n	80048ea <chHeapFree+0x2a>
 80048d6:	9b01      	ldr	r3, [sp, #4]
 80048d8:	f003 0307 	and.w	r3, r3, #7
 80048dc:	2b00      	cmp	r3, #0
 80048de:	bf14      	ite	ne
 80048e0:	2301      	movne	r3, #1
 80048e2:	2300      	moveq	r3, #0
 80048e4:	b2db      	uxtb	r3, r3
 80048e6:	2b00      	cmp	r3, #0
 80048e8:	d002      	beq.n	80048f0 <chHeapFree+0x30>
 80048ea:	4843      	ldr	r0, [pc, #268]	@ (80049f8 <chHeapFree+0x138>)
 80048ec:	f7fd ff00 	bl	80026f0 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 80048f0:	9b01      	ldr	r3, [sp, #4]
 80048f2:	3b08      	subs	r3, #8
 80048f4:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 80048f6:	9b04      	ldr	r3, [sp, #16]
 80048f8:	681b      	ldr	r3, [r3, #0]
 80048fa:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 80048fc:	9b03      	ldr	r3, [sp, #12]
 80048fe:	3304      	adds	r3, #4
 8004900:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8004902:	9b04      	ldr	r3, [sp, #16]
 8004904:	685b      	ldr	r3, [r3, #4]
 8004906:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8004908:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800490a:	9b04      	ldr	r3, [sp, #16]
 800490c:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800490e:	9b03      	ldr	r3, [sp, #12]
 8004910:	330c      	adds	r3, #12
 8004912:	4618      	mov	r0, r3
 8004914:	f7ff fddc 	bl	80044d0 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8004918:	9a04      	ldr	r2, [sp, #16]
 800491a:	9b05      	ldr	r3, [sp, #20]
 800491c:	429a      	cmp	r2, r3
 800491e:	bf2c      	ite	cs
 8004920:	2301      	movcs	r3, #1
 8004922:	2300      	movcc	r3, #0
 8004924:	b2db      	uxtb	r3, r3
 8004926:	2b00      	cmp	r3, #0
 8004928:	d010      	beq.n	800494c <chHeapFree+0x8c>
 800492a:	9b05      	ldr	r3, [sp, #20]
 800492c:	685b      	ldr	r3, [r3, #4]
 800492e:	3301      	adds	r3, #1
 8004930:	00db      	lsls	r3, r3, #3
 8004932:	9a05      	ldr	r2, [sp, #20]
 8004934:	4413      	add	r3, r2
 8004936:	9a04      	ldr	r2, [sp, #16]
 8004938:	429a      	cmp	r2, r3
 800493a:	bf34      	ite	cc
 800493c:	2301      	movcc	r3, #1
 800493e:	2300      	movcs	r3, #0
 8004940:	b2db      	uxtb	r3, r3
 8004942:	2b00      	cmp	r3, #0
 8004944:	d002      	beq.n	800494c <chHeapFree+0x8c>
 8004946:	482c      	ldr	r0, [pc, #176]	@ (80049f8 <chHeapFree+0x138>)
 8004948:	f7fd fed2 	bl	80026f0 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 800494c:	9b03      	ldr	r3, [sp, #12]
 800494e:	3304      	adds	r3, #4
 8004950:	9a05      	ldr	r2, [sp, #20]
 8004952:	429a      	cmp	r2, r3
 8004954:	d003      	beq.n	800495e <chHeapFree+0x9e>
 8004956:	9a04      	ldr	r2, [sp, #16]
 8004958:	9b05      	ldr	r3, [sp, #20]
 800495a:	429a      	cmp	r2, r3
 800495c:	d93d      	bls.n	80049da <chHeapFree+0x11a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800495e:	9b05      	ldr	r3, [sp, #20]
 8004960:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8004962:	2b00      	cmp	r3, #0
 8004964:	d004      	beq.n	8004970 <chHeapFree+0xb0>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8004966:	9b05      	ldr	r3, [sp, #20]
 8004968:	681b      	ldr	r3, [r3, #0]
 800496a:	9a04      	ldr	r2, [sp, #16]
 800496c:	429a      	cmp	r2, r3
 800496e:	d234      	bcs.n	80049da <chHeapFree+0x11a>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8004970:	9b05      	ldr	r3, [sp, #20]
 8004972:	681a      	ldr	r2, [r3, #0]
 8004974:	9b04      	ldr	r3, [sp, #16]
 8004976:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8004978:	9b05      	ldr	r3, [sp, #20]
 800497a:	9a04      	ldr	r2, [sp, #16]
 800497c:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800497e:	9b04      	ldr	r3, [sp, #16]
 8004980:	685b      	ldr	r3, [r3, #4]
 8004982:	3301      	adds	r3, #1
 8004984:	00db      	lsls	r3, r3, #3
 8004986:	9a04      	ldr	r2, [sp, #16]
 8004988:	441a      	add	r2, r3
 800498a:	9b04      	ldr	r3, [sp, #16]
 800498c:	681b      	ldr	r3, [r3, #0]
 800498e:	429a      	cmp	r2, r3
 8004990:	d10d      	bne.n	80049ae <chHeapFree+0xee>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8004992:	9b04      	ldr	r3, [sp, #16]
 8004994:	685a      	ldr	r2, [r3, #4]
 8004996:	9b04      	ldr	r3, [sp, #16]
 8004998:	681b      	ldr	r3, [r3, #0]
 800499a:	685b      	ldr	r3, [r3, #4]
 800499c:	4413      	add	r3, r2
 800499e:	1c5a      	adds	r2, r3, #1
 80049a0:	9b04      	ldr	r3, [sp, #16]
 80049a2:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80049a4:	9b04      	ldr	r3, [sp, #16]
 80049a6:	681b      	ldr	r3, [r3, #0]
 80049a8:	681a      	ldr	r2, [r3, #0]
 80049aa:	9b04      	ldr	r3, [sp, #16]
 80049ac:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 80049ae:	9b05      	ldr	r3, [sp, #20]
 80049b0:	685b      	ldr	r3, [r3, #4]
 80049b2:	3301      	adds	r3, #1
 80049b4:	00db      	lsls	r3, r3, #3
 80049b6:	9a05      	ldr	r2, [sp, #20]
 80049b8:	4413      	add	r3, r2
 80049ba:	9a04      	ldr	r2, [sp, #16]
 80049bc:	429a      	cmp	r2, r3
 80049be:	d110      	bne.n	80049e2 <chHeapFree+0x122>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80049c0:	9b05      	ldr	r3, [sp, #20]
 80049c2:	685a      	ldr	r2, [r3, #4]
 80049c4:	9b04      	ldr	r3, [sp, #16]
 80049c6:	685b      	ldr	r3, [r3, #4]
 80049c8:	4413      	add	r3, r2
 80049ca:	1c5a      	adds	r2, r3, #1
 80049cc:	9b05      	ldr	r3, [sp, #20]
 80049ce:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 80049d0:	9b04      	ldr	r3, [sp, #16]
 80049d2:	681a      	ldr	r2, [r3, #0]
 80049d4:	9b05      	ldr	r3, [sp, #20]
 80049d6:	601a      	str	r2, [r3, #0]
      }
      break;
 80049d8:	e003      	b.n	80049e2 <chHeapFree+0x122>
    }
    qp = H_NEXT(qp);
 80049da:	9b05      	ldr	r3, [sp, #20]
 80049dc:	681b      	ldr	r3, [r3, #0]
 80049de:	9305      	str	r3, [sp, #20]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 80049e0:	e79a      	b.n	8004918 <chHeapFree+0x58>
      break;
 80049e2:	bf00      	nop
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80049e4:	9b03      	ldr	r3, [sp, #12]
 80049e6:	330c      	adds	r3, #12
 80049e8:	4618      	mov	r0, r3
 80049ea:	f7ff fe19 	bl	8004620 <chMtxUnlock>

  return;
 80049ee:	bf00      	nop
}
 80049f0:	b007      	add	sp, #28
 80049f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80049f6:	bf00      	nop
 80049f8:	08005634 	.word	0x08005634
 80049fc:	00000000 	.word	0x00000000

08004a00 <chSysLock.lto_priv.16>:
static inline void chSysLock(void) {
 8004a00:	b500      	push	{lr}
 8004a02:	b083      	sub	sp, #12
 8004a04:	2330      	movs	r3, #48	@ 0x30
 8004a06:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004a08:	9b01      	ldr	r3, [sp, #4]
 8004a0a:	f383 8811 	msr	BASEPRI, r3
}
 8004a0e:	bf00      	nop
}
 8004a10:	bf00      	nop
  __dbg_check_lock();
 8004a12:	f7fd fef5 	bl	8002800 <__dbg_check_lock>
}
 8004a16:	bf00      	nop
 8004a18:	b003      	add	sp, #12
 8004a1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a1e:	bf00      	nop

08004a20 <chSysUnlock.lto_priv.16>:
static inline void chSysUnlock(void) {
 8004a20:	b500      	push	{lr}
 8004a22:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004a24:	f7fd ff14 	bl	8002850 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004a28:	4b12      	ldr	r3, [pc, #72]	@ (8004a74 <chSysUnlock.lto_priv.16+0x54>)
 8004a2a:	681b      	ldr	r3, [r3, #0]
 8004a2c:	4a11      	ldr	r2, [pc, #68]	@ (8004a74 <chSysUnlock.lto_priv.16+0x54>)
 8004a2e:	4293      	cmp	r3, r2
 8004a30:	bf14      	ite	ne
 8004a32:	2301      	movne	r3, #1
 8004a34:	2300      	moveq	r3, #0
 8004a36:	b2db      	uxtb	r3, r3
 8004a38:	2b00      	cmp	r3, #0
 8004a3a:	d00f      	beq.n	8004a5c <chSysUnlock.lto_priv.16+0x3c>
 8004a3c:	4b0d      	ldr	r3, [pc, #52]	@ (8004a74 <chSysUnlock.lto_priv.16+0x54>)
 8004a3e:	68db      	ldr	r3, [r3, #12]
 8004a40:	689a      	ldr	r2, [r3, #8]
 8004a42:	4b0c      	ldr	r3, [pc, #48]	@ (8004a74 <chSysUnlock.lto_priv.16+0x54>)
 8004a44:	681b      	ldr	r3, [r3, #0]
 8004a46:	689b      	ldr	r3, [r3, #8]
 8004a48:	429a      	cmp	r2, r3
 8004a4a:	bf34      	ite	cc
 8004a4c:	2301      	movcc	r3, #1
 8004a4e:	2300      	movcs	r3, #0
 8004a50:	b2db      	uxtb	r3, r3
 8004a52:	2b00      	cmp	r3, #0
 8004a54:	d002      	beq.n	8004a5c <chSysUnlock.lto_priv.16+0x3c>
 8004a56:	4808      	ldr	r0, [pc, #32]	@ (8004a78 <chSysUnlock.lto_priv.16+0x58>)
 8004a58:	f7fd fe4a 	bl	80026f0 <chSysHalt>
 8004a5c:	2300      	movs	r3, #0
 8004a5e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004a60:	9b01      	ldr	r3, [sp, #4]
 8004a62:	f383 8811 	msr	BASEPRI, r3
}
 8004a66:	bf00      	nop
}
 8004a68:	bf00      	nop
}
 8004a6a:	bf00      	nop
 8004a6c:	b003      	add	sp, #12
 8004a6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a72:	bf00      	nop
 8004a74:	20000940 	.word	0x20000940
 8004a78:	08005658 	.word	0x08005658
 8004a7c:	00000000 	.word	0x00000000

08004a80 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8004a80:	b500      	push	{lr}
 8004a82:	b085      	sub	sp, #20
 8004a84:	9003      	str	r0, [sp, #12]
 8004a86:	9102      	str	r1, [sp, #8]
 8004a88:	9201      	str	r2, [sp, #4]
 8004a8a:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 8004a8c:	9b03      	ldr	r3, [sp, #12]
 8004a8e:	2b00      	cmp	r3, #0
 8004a90:	bf0c      	ite	eq
 8004a92:	2301      	moveq	r3, #1
 8004a94:	2300      	movne	r3, #0
 8004a96:	b2db      	uxtb	r3, r3
 8004a98:	2b00      	cmp	r3, #0
 8004a9a:	d107      	bne.n	8004aac <chPoolObjectInitAligned+0x2c>
 8004a9c:	9b02      	ldr	r3, [sp, #8]
 8004a9e:	2b03      	cmp	r3, #3
 8004aa0:	bf94      	ite	ls
 8004aa2:	2301      	movls	r3, #1
 8004aa4:	2300      	movhi	r3, #0
 8004aa6:	b2db      	uxtb	r3, r3
 8004aa8:	2b00      	cmp	r3, #0
 8004aaa:	d001      	beq.n	8004ab0 <chPoolObjectInitAligned+0x30>
 8004aac:	2301      	movs	r3, #1
 8004aae:	e000      	b.n	8004ab2 <chPoolObjectInitAligned+0x32>
 8004ab0:	2300      	movs	r3, #0
 8004ab2:	2b00      	cmp	r3, #0
 8004ab4:	d107      	bne.n	8004ac6 <chPoolObjectInitAligned+0x46>
 8004ab6:	9b01      	ldr	r3, [sp, #4]
 8004ab8:	2b03      	cmp	r3, #3
 8004aba:	bf94      	ite	ls
 8004abc:	2301      	movls	r3, #1
 8004abe:	2300      	movhi	r3, #0
 8004ac0:	b2db      	uxtb	r3, r3
 8004ac2:	2b00      	cmp	r3, #0
 8004ac4:	d001      	beq.n	8004aca <chPoolObjectInitAligned+0x4a>
 8004ac6:	2301      	movs	r3, #1
 8004ac8:	e000      	b.n	8004acc <chPoolObjectInitAligned+0x4c>
 8004aca:	2300      	movs	r3, #0
 8004acc:	2b00      	cmp	r3, #0
 8004ace:	d117      	bne.n	8004b00 <chPoolObjectInitAligned+0x80>
 8004ad0:	9b01      	ldr	r3, [sp, #4]
 8004ad2:	2b00      	cmp	r3, #0
 8004ad4:	bf0c      	ite	eq
 8004ad6:	2301      	moveq	r3, #1
 8004ad8:	2300      	movne	r3, #0
 8004ada:	b2db      	uxtb	r3, r3
 8004adc:	2b00      	cmp	r3, #0
 8004ade:	d10a      	bne.n	8004af6 <chPoolObjectInitAligned+0x76>
 8004ae0:	9b01      	ldr	r3, [sp, #4]
 8004ae2:	1e5a      	subs	r2, r3, #1
 8004ae4:	9b01      	ldr	r3, [sp, #4]
 8004ae6:	4013      	ands	r3, r2
 8004ae8:	2b00      	cmp	r3, #0
 8004aea:	bf14      	ite	ne
 8004aec:	2301      	movne	r3, #1
 8004aee:	2300      	moveq	r3, #0
 8004af0:	b2db      	uxtb	r3, r3
 8004af2:	2b00      	cmp	r3, #0
 8004af4:	d001      	beq.n	8004afa <chPoolObjectInitAligned+0x7a>
 8004af6:	2301      	movs	r3, #1
 8004af8:	e000      	b.n	8004afc <chPoolObjectInitAligned+0x7c>
 8004afa:	2300      	movs	r3, #0
 8004afc:	2b00      	cmp	r3, #0
 8004afe:	d002      	beq.n	8004b06 <chPoolObjectInitAligned+0x86>
 8004b00:	4809      	ldr	r0, [pc, #36]	@ (8004b28 <chPoolObjectInitAligned+0xa8>)
 8004b02:	f7fd fdf5 	bl	80026f0 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8004b06:	9b03      	ldr	r3, [sp, #12]
 8004b08:	2200      	movs	r2, #0
 8004b0a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8004b0c:	9b03      	ldr	r3, [sp, #12]
 8004b0e:	9a02      	ldr	r2, [sp, #8]
 8004b10:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8004b12:	9b03      	ldr	r3, [sp, #12]
 8004b14:	9a01      	ldr	r2, [sp, #4]
 8004b16:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8004b18:	9b03      	ldr	r3, [sp, #12]
 8004b1a:	9a00      	ldr	r2, [sp, #0]
 8004b1c:	60da      	str	r2, [r3, #12]
}
 8004b1e:	bf00      	nop
 8004b20:	b005      	add	sp, #20
 8004b22:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b26:	bf00      	nop
 8004b28:	08005640 	.word	0x08005640
 8004b2c:	00000000 	.word	0x00000000

08004b30 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8004b30:	b500      	push	{lr}
 8004b32:	b085      	sub	sp, #20
 8004b34:	9001      	str	r0, [sp, #4]
 8004b36:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8004b38:	9b00      	ldr	r3, [sp, #0]
 8004b3a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 8004b3c:	f7fd ff78 	bl	8002a30 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8004b40:	9b01      	ldr	r3, [sp, #4]
 8004b42:	2b00      	cmp	r3, #0
 8004b44:	bf0c      	ite	eq
 8004b46:	2301      	moveq	r3, #1
 8004b48:	2300      	movne	r3, #0
 8004b4a:	b2db      	uxtb	r3, r3
 8004b4c:	2b00      	cmp	r3, #0
 8004b4e:	d107      	bne.n	8004b60 <chPoolFreeI+0x30>
 8004b50:	9b00      	ldr	r3, [sp, #0]
 8004b52:	2b00      	cmp	r3, #0
 8004b54:	bf0c      	ite	eq
 8004b56:	2301      	moveq	r3, #1
 8004b58:	2300      	movne	r3, #0
 8004b5a:	b2db      	uxtb	r3, r3
 8004b5c:	2b00      	cmp	r3, #0
 8004b5e:	d001      	beq.n	8004b64 <chPoolFreeI+0x34>
 8004b60:	2301      	movs	r3, #1
 8004b62:	e000      	b.n	8004b66 <chPoolFreeI+0x36>
 8004b64:	2300      	movs	r3, #0
 8004b66:	2b00      	cmp	r3, #0
 8004b68:	d10b      	bne.n	8004b82 <chPoolFreeI+0x52>
 8004b6a:	9b01      	ldr	r3, [sp, #4]
 8004b6c:	689b      	ldr	r3, [r3, #8]
 8004b6e:	1e5a      	subs	r2, r3, #1
 8004b70:	9b00      	ldr	r3, [sp, #0]
 8004b72:	4013      	ands	r3, r2
 8004b74:	2b00      	cmp	r3, #0
 8004b76:	bf14      	ite	ne
 8004b78:	2301      	movne	r3, #1
 8004b7a:	2300      	moveq	r3, #0
 8004b7c:	b2db      	uxtb	r3, r3
 8004b7e:	2b00      	cmp	r3, #0
 8004b80:	d002      	beq.n	8004b88 <chPoolFreeI+0x58>
 8004b82:	4807      	ldr	r0, [pc, #28]	@ (8004ba0 <chPoolFreeI+0x70>)
 8004b84:	f7fd fdb4 	bl	80026f0 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8004b88:	9b01      	ldr	r3, [sp, #4]
 8004b8a:	681a      	ldr	r2, [r3, #0]
 8004b8c:	9b03      	ldr	r3, [sp, #12]
 8004b8e:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8004b90:	9b01      	ldr	r3, [sp, #4]
 8004b92:	9a03      	ldr	r2, [sp, #12]
 8004b94:	601a      	str	r2, [r3, #0]
}
 8004b96:	bf00      	nop
 8004b98:	b005      	add	sp, #20
 8004b9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b9e:	bf00      	nop
 8004ba0:	08005664 	.word	0x08005664
	...

08004bb0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8004bb0:	b500      	push	{lr}
 8004bb2:	b083      	sub	sp, #12
 8004bb4:	9001      	str	r0, [sp, #4]
 8004bb6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8004bb8:	f7ff ff22 	bl	8004a00 <chSysLock.lto_priv.16>
  chPoolFreeI(mp, objp);
 8004bbc:	9900      	ldr	r1, [sp, #0]
 8004bbe:	9801      	ldr	r0, [sp, #4]
 8004bc0:	f7ff ffb6 	bl	8004b30 <chPoolFreeI>
  chSysUnlock();
 8004bc4:	f7ff ff2c 	bl	8004a20 <chSysUnlock.lto_priv.16>
}
 8004bc8:	bf00      	nop
 8004bca:	b003      	add	sp, #12
 8004bcc:	f85d fb04 	ldr.w	pc, [sp], #4

08004bd0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8004bd0:	b500      	push	{lr}
 8004bd2:	b083      	sub	sp, #12
 8004bd4:	9001      	str	r0, [sp, #4]
 8004bd6:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8004bd8:	2200      	movs	r2, #0
 8004bda:	9900      	ldr	r1, [sp, #0]
 8004bdc:	9801      	ldr	r0, [sp, #4]
 8004bde:	f7ff fdf7 	bl	80047d0 <chCoreAllocFromTopI>
 8004be2:	4603      	mov	r3, r0
}
 8004be4:	4618      	mov	r0, r3
 8004be6:	b003      	add	sp, #12
 8004be8:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bec:	0000      	movs	r0, r0
	...

08004bf0 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8004bf0:	b500      	push	{lr}
 8004bf2:	b085      	sub	sp, #20
 8004bf4:	9003      	str	r0, [sp, #12]
 8004bf6:	9102      	str	r1, [sp, #8]
 8004bf8:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8004bfa:	9b01      	ldr	r3, [sp, #4]
 8004bfc:	2204      	movs	r2, #4
 8004bfe:	9902      	ldr	r1, [sp, #8]
 8004c00:	9803      	ldr	r0, [sp, #12]
 8004c02:	f7ff ff3d 	bl	8004a80 <chPoolObjectInitAligned>
}
 8004c06:	bf00      	nop
 8004c08:	b005      	add	sp, #20
 8004c0a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c0e:	bf00      	nop

08004c10 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8004c10:	b082      	sub	sp, #8
 8004c12:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8004c14:	9b01      	ldr	r3, [sp, #4]
 8004c16:	9a01      	ldr	r2, [sp, #4]
 8004c18:	601a      	str	r2, [r3, #0]
}
 8004c1a:	bf00      	nop
 8004c1c:	b002      	add	sp, #8
 8004c1e:	4770      	bx	lr

08004c20 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8004c20:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8004c22:	4810      	ldr	r0, [pc, #64]	@ (8004c64 <__factory_init+0x44>)
 8004c24:	f7ff fc34 	bl	8004490 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8004c28:	480f      	ldr	r0, [pc, #60]	@ (8004c68 <__factory_init+0x48>)
 8004c2a:	f7ff fff1 	bl	8004c10 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8004c2e:	4a0f      	ldr	r2, [pc, #60]	@ (8004c6c <__factory_init+0x4c>)
 8004c30:	2114      	movs	r1, #20
 8004c32:	480f      	ldr	r0, [pc, #60]	@ (8004c70 <__factory_init+0x50>)
 8004c34:	f7ff ffdc 	bl	8004bf0 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8004c38:	480e      	ldr	r0, [pc, #56]	@ (8004c74 <__factory_init+0x54>)
 8004c3a:	f7ff ffe9 	bl	8004c10 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8004c3e:	480e      	ldr	r0, [pc, #56]	@ (8004c78 <__factory_init+0x58>)
 8004c40:	f7ff ffe6 	bl	8004c10 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8004c44:	4a09      	ldr	r2, [pc, #36]	@ (8004c6c <__factory_init+0x4c>)
 8004c46:	211c      	movs	r1, #28
 8004c48:	480c      	ldr	r0, [pc, #48]	@ (8004c7c <__factory_init+0x5c>)
 8004c4a:	f7ff ffd1 	bl	8004bf0 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8004c4e:	480c      	ldr	r0, [pc, #48]	@ (8004c80 <__factory_init+0x60>)
 8004c50:	f7ff ffde 	bl	8004c10 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8004c54:	480b      	ldr	r0, [pc, #44]	@ (8004c84 <__factory_init+0x64>)
 8004c56:	f7ff ffdb 	bl	8004c10 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 8004c5a:	480b      	ldr	r0, [pc, #44]	@ (8004c88 <__factory_init+0x68>)
 8004c5c:	f7ff ffd8 	bl	8004c10 <dyn_list_init>
#endif
}
 8004c60:	bf00      	nop
 8004c62:	bd08      	pop	{r3, pc}
 8004c64:	20000b24 	.word	0x20000b24
 8004c68:	20000b34 	.word	0x20000b34
 8004c6c:	08004bd1 	.word	0x08004bd1
 8004c70:	20000b38 	.word	0x20000b38
 8004c74:	20000b48 	.word	0x20000b48
 8004c78:	20000b4c 	.word	0x20000b4c
 8004c7c:	20000b50 	.word	0x20000b50
 8004c80:	20000b60 	.word	0x20000b60
 8004c84:	20000b64 	.word	0x20000b64
 8004c88:	20000b68 	.word	0x20000b68
 8004c8c:	00000000 	.word	0x00000000

08004c90 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8004c90:	b084      	sub	sp, #16
 8004c92:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8004c94:	9b01      	ldr	r3, [sp, #4]
 8004c96:	f003 0307 	and.w	r3, r3, #7
 8004c9a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004c9c:	4b0b      	ldr	r3, [pc, #44]	@ (8004ccc <__NVIC_SetPriorityGrouping+0x3c>)
 8004c9e:	68db      	ldr	r3, [r3, #12]
 8004ca0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8004ca2:	9a02      	ldr	r2, [sp, #8]
 8004ca4:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8004ca8:	4013      	ands	r3, r2
 8004caa:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8004cac:	9b03      	ldr	r3, [sp, #12]
 8004cae:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8004cb0:	9b02      	ldr	r3, [sp, #8]
 8004cb2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8004cb4:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8004cb8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004cbc:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 8004cbe:	4a03      	ldr	r2, [pc, #12]	@ (8004ccc <__NVIC_SetPriorityGrouping+0x3c>)
 8004cc0:	9b02      	ldr	r3, [sp, #8]
 8004cc2:	60d3      	str	r3, [r2, #12]
}
 8004cc4:	bf00      	nop
 8004cc6:	b004      	add	sp, #16
 8004cc8:	4770      	bx	lr
 8004cca:	bf00      	nop
 8004ccc:	e000ed00 	.word	0xe000ed00

08004cd0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8004cd0:	b082      	sub	sp, #8
 8004cd2:	4603      	mov	r3, r0
 8004cd4:	9100      	str	r1, [sp, #0]
 8004cd6:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 8004cda:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004cde:	2b00      	cmp	r3, #0
 8004ce0:	db0a      	blt.n	8004cf8 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004ce2:	9b00      	ldr	r3, [sp, #0]
 8004ce4:	b2da      	uxtb	r2, r3
 8004ce6:	490c      	ldr	r1, [pc, #48]	@ (8004d18 <__NVIC_SetPriority+0x48>)
 8004ce8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004cec:	0112      	lsls	r2, r2, #4
 8004cee:	b2d2      	uxtb	r2, r2
 8004cf0:	440b      	add	r3, r1
 8004cf2:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8004cf6:	e00b      	b.n	8004d10 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004cf8:	9b00      	ldr	r3, [sp, #0]
 8004cfa:	b2da      	uxtb	r2, r3
 8004cfc:	4907      	ldr	r1, [pc, #28]	@ (8004d1c <__NVIC_SetPriority+0x4c>)
 8004cfe:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004d02:	f003 030f 	and.w	r3, r3, #15
 8004d06:	3b04      	subs	r3, #4
 8004d08:	0112      	lsls	r2, r2, #4
 8004d0a:	b2d2      	uxtb	r2, r2
 8004d0c:	440b      	add	r3, r1
 8004d0e:	761a      	strb	r2, [r3, #24]
}
 8004d10:	bf00      	nop
 8004d12:	b002      	add	sp, #8
 8004d14:	4770      	bx	lr
 8004d16:	bf00      	nop
 8004d18:	e000e100 	.word	0xe000e100
 8004d1c:	e000ed00 	.word	0xe000ed00

08004d20 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004d20:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004d22:	f3ef 8309 	mrs	r3, PSP
 8004d26:	9300      	str	r3, [sp, #0]
  return(result);
 8004d28:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 8004d2a:	9303      	str	r3, [sp, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8004d2c:	9b03      	ldr	r3, [sp, #12]
 8004d2e:	3320      	adds	r3, #32
 8004d30:	9303      	str	r3, [sp, #12]
 8004d32:	9b03      	ldr	r3, [sp, #12]
 8004d34:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004d36:	9b01      	ldr	r3, [sp, #4]
 8004d38:	f383 8809 	msr	PSP, r3
}
 8004d3c:	bf00      	nop
 8004d3e:	2300      	movs	r3, #0
 8004d40:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004d42:	9b02      	ldr	r3, [sp, #8]
 8004d44:	f383 8811 	msr	BASEPRI, r3
}
 8004d48:	bf00      	nop
 8004d4a:	bf00      	nop
}
 8004d4c:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8004d4e:	bf00      	nop
 8004d50:	b004      	add	sp, #16
 8004d52:	4770      	bx	lr
	...

08004d60 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004d60:	b500      	push	{lr}
 8004d62:	b085      	sub	sp, #20
 8004d64:	9001      	str	r0, [sp, #4]
 8004d66:	2330      	movs	r3, #48	@ 0x30
 8004d68:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004d6a:	9b03      	ldr	r3, [sp, #12]
 8004d6c:	f383 8811 	msr	BASEPRI, r3
}
 8004d70:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8004d72:	b662      	cpsie	i
}
 8004d74:	bf00      	nop
}
 8004d76:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8004d78:	2003      	movs	r0, #3
 8004d7a:	f7ff ff89 	bl	8004c90 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8004d7e:	4b0d      	ldr	r3, [pc, #52]	@ (8004db4 <port_init+0x54>)
 8004d80:	68db      	ldr	r3, [r3, #12]
 8004d82:	4a0c      	ldr	r2, [pc, #48]	@ (8004db4 <port_init+0x54>)
 8004d84:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004d88:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8004d8a:	4b0b      	ldr	r3, [pc, #44]	@ (8004db8 <port_init+0x58>)
 8004d8c:	681b      	ldr	r3, [r3, #0]
 8004d8e:	4a0a      	ldr	r2, [pc, #40]	@ (8004db8 <port_init+0x58>)
 8004d90:	f043 0301 	orr.w	r3, r3, #1
 8004d94:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8004d96:	2102      	movs	r1, #2
 8004d98:	f06f 0004 	mvn.w	r0, #4
 8004d9c:	f7ff ff98 	bl	8004cd0 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004da0:	2103      	movs	r1, #3
 8004da2:	f06f 0001 	mvn.w	r0, #1
 8004da6:	f7ff ff93 	bl	8004cd0 <__NVIC_SetPriority>

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 8004daa:	bf00      	nop
 8004dac:	b005      	add	sp, #20
 8004dae:	f85d fb04 	ldr.w	pc, [sp], #4
 8004db2:	bf00      	nop
 8004db4:	e000edf0 	.word	0xe000edf0
 8004db8:	e0001000 	.word	0xe0001000
 8004dbc:	00000000 	.word	0x00000000

08004dc0 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 8004dc0:	b500      	push	{lr}
 8004dc2:	b087      	sub	sp, #28
 8004dc4:	2330      	movs	r3, #48	@ 0x30
 8004dc6:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004dc8:	9b03      	ldr	r3, [sp, #12]
 8004dca:	f383 8811 	msr	BASEPRI, r3
}
 8004dce:	bf00      	nop
}
 8004dd0:	bf00      	nop
}
 8004dd2:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004dd4:	4b18      	ldr	r3, [pc, #96]	@ (8004e38 <__port_irq_epilogue+0x78>)
 8004dd6:	685b      	ldr	r3, [r3, #4]
 8004dd8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8004ddc:	2b00      	cmp	r3, #0
 8004dde:	d020      	beq.n	8004e22 <__port_irq_epilogue+0x62>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004de0:	f3ef 8309 	mrs	r3, PSP
 8004de4:	9301      	str	r3, [sp, #4]
  return(result);
 8004de6:	9b01      	ldr	r3, [sp, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 8004de8:	9305      	str	r3, [sp, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 8004dea:	9b05      	ldr	r3, [sp, #20]
 8004dec:	3b20      	subs	r3, #32
 8004dee:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 8004df0:	9b05      	ldr	r3, [sp, #20]
 8004df2:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8004df4:	9b04      	ldr	r3, [sp, #16]
 8004df6:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 8004dfa:	61da      	str	r2, [r3, #28]
 8004dfc:	9b05      	ldr	r3, [sp, #20]
 8004dfe:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004e00:	9b02      	ldr	r3, [sp, #8]
 8004e02:	f383 8809 	msr	PSP, r3
}
 8004e06:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004e08:	f7fe fc7a 	bl	8003700 <chSchIsPreemptionRequired>
 8004e0c:	4603      	mov	r3, r0
 8004e0e:	2b00      	cmp	r3, #0
 8004e10:	d003      	beq.n	8004e1a <__port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8004e12:	4a0a      	ldr	r2, [pc, #40]	@ (8004e3c <__port_irq_epilogue+0x7c>)
 8004e14:	9b04      	ldr	r3, [sp, #16]
 8004e16:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8004e18:	e00b      	b.n	8004e32 <__port_irq_epilogue+0x72>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8004e1a:	4a09      	ldr	r2, [pc, #36]	@ (8004e40 <__port_irq_epilogue+0x80>)
 8004e1c:	9b04      	ldr	r3, [sp, #16]
 8004e1e:	619a      	str	r2, [r3, #24]
    return;
 8004e20:	e007      	b.n	8004e32 <__port_irq_epilogue+0x72>
 8004e22:	2300      	movs	r3, #0
 8004e24:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004e26:	9b00      	ldr	r3, [sp, #0]
 8004e28:	f383 8811 	msr	BASEPRI, r3
}
 8004e2c:	bf00      	nop
}
 8004e2e:	bf00      	nop
}
 8004e30:	bf00      	nop
  }
  port_unlock_from_isr();
}
 8004e32:	b007      	add	sp, #28
 8004e34:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e38:	e000ed00 	.word	0xe000ed00
 8004e3c:	080002a7 	.word	0x080002a7
 8004e40:	080002b2 	.word	0x080002b2
	...

08004e50 <portab_setup>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

void portab_setup(void) {
 8004e50:	b508      	push	{r3, lr}

  /* ADC inputs.*/
  palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG);
 8004e52:	f640 0203 	movw	r2, #2051	@ 0x803
 8004e56:	2101      	movs	r1, #1
 8004e58:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8004e5c:	f7fd f8a0 	bl	8001fa0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 1, PAL_MODE_INPUT_ANALOG);
 8004e60:	f640 0203 	movw	r2, #2051	@ 0x803
 8004e64:	2102      	movs	r1, #2
 8004e66:	4802      	ldr	r0, [pc, #8]	@ (8004e70 <portab_setup+0x20>)
 8004e68:	f7fd f89a 	bl	8001fa0 <_pal_lld_setgroupmode>
}
 8004e6c:	bf00      	nop
 8004e6e:	bd08      	pop	{r3, pc}
 8004e70:	48000400 	.word	0x48000400
	...

08004e80 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8004e80:	b082      	sub	sp, #8
 8004e82:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8004e84:	4b03      	ldr	r3, [pc, #12]	@ (8004e94 <chRegSetThreadName+0x14>)
 8004e86:	68db      	ldr	r3, [r3, #12]
 8004e88:	9a01      	ldr	r2, [sp, #4]
 8004e8a:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 8004e8c:	bf00      	nop
 8004e8e:	b002      	add	sp, #8
 8004e90:	4770      	bx	lr
 8004e92:	bf00      	nop
 8004e94:	20000940 	.word	0x20000940
	...

08004ea0 <adccallback>:

/*
 * ADC streaming callback.
 */
size_t n= 0, nx = 0, ny = 0;
void adccallback(ADCDriver *adcp) {
 8004ea0:	b082      	sub	sp, #8
 8004ea2:	9001      	str	r0, [sp, #4]

  /* Updating counters.*/
  n++;
 8004ea4:	4b14      	ldr	r3, [pc, #80]	@ (8004ef8 <adccallback+0x58>)
 8004ea6:	681b      	ldr	r3, [r3, #0]
 8004ea8:	3301      	adds	r3, #1
 8004eaa:	4a13      	ldr	r2, [pc, #76]	@ (8004ef8 <adccallback+0x58>)
 8004eac:	6013      	str	r3, [r2, #0]
  if (adcIsBufferComplete(adcp)) {
 8004eae:	9b01      	ldr	r3, [sp, #4]
 8004eb0:	781b      	ldrb	r3, [r3, #0]
 8004eb2:	2b04      	cmp	r3, #4
 8004eb4:	d105      	bne.n	8004ec2 <adccallback+0x22>
    nx += 1;
 8004eb6:	4b11      	ldr	r3, [pc, #68]	@ (8004efc <adccallback+0x5c>)
 8004eb8:	681b      	ldr	r3, [r3, #0]
 8004eba:	3301      	adds	r3, #1
 8004ebc:	4a0f      	ldr	r2, [pc, #60]	@ (8004efc <adccallback+0x5c>)
 8004ebe:	6013      	str	r3, [r2, #0]
 8004ec0:	e004      	b.n	8004ecc <adccallback+0x2c>
  }
  else {
    ny += 1;
 8004ec2:	4b0f      	ldr	r3, [pc, #60]	@ (8004f00 <adccallback+0x60>)
 8004ec4:	681b      	ldr	r3, [r3, #0]
 8004ec6:	3301      	adds	r3, #1
 8004ec8:	4a0d      	ldr	r2, [pc, #52]	@ (8004f00 <adccallback+0x60>)
 8004eca:	6013      	str	r3, [r2, #0]
  }

  if ((n % 200) == 0U) {
 8004ecc:	4b0a      	ldr	r3, [pc, #40]	@ (8004ef8 <adccallback+0x58>)
 8004ece:	681a      	ldr	r2, [r3, #0]
 8004ed0:	4b0c      	ldr	r3, [pc, #48]	@ (8004f04 <adccallback+0x64>)
 8004ed2:	fba3 1302 	umull	r1, r3, r3, r2
 8004ed6:	099b      	lsrs	r3, r3, #6
 8004ed8:	21c8      	movs	r1, #200	@ 0xc8
 8004eda:	fb01 f303 	mul.w	r3, r1, r3
 8004ede:	1ad3      	subs	r3, r2, r3
 8004ee0:	2b00      	cmp	r3, #0
 8004ee2:	d105      	bne.n	8004ef0 <adccallback+0x50>
#if defined(PORTAB_LINE_LED2)
    palToggleLine(PORTAB_LINE_LED2);
 8004ee4:	4b08      	ldr	r3, [pc, #32]	@ (8004f08 <adccallback+0x68>)
 8004ee6:	695b      	ldr	r3, [r3, #20]
 8004ee8:	4a07      	ldr	r2, [pc, #28]	@ (8004f08 <adccallback+0x68>)
 8004eea:	f083 0304 	eor.w	r3, r3, #4
 8004eee:	6153      	str	r3, [r2, #20]
#endif
  }
}
 8004ef0:	bf00      	nop
 8004ef2:	b002      	add	sp, #8
 8004ef4:	4770      	bx	lr
 8004ef6:	bf00      	nop
 8004ef8:	20000c74 	.word	0x20000c74
 8004efc:	20000c78 	.word	0x20000c78
 8004f00:	20000c7c 	.word	0x20000c7c
 8004f04:	51eb851f 	.word	0x51eb851f
 8004f08:	48000400 	.word	0x48000400
 8004f0c:	00000000 	.word	0x00000000

08004f10 <adcerrorcallback>:

/*
 * ADC errors callback, should never happen.
 */
void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8004f10:	b500      	push	{lr}
 8004f12:	b083      	sub	sp, #12
 8004f14:	9001      	str	r0, [sp, #4]
 8004f16:	9100      	str	r1, [sp, #0]

  (void)adcp;
  (void)err;

  chSysHalt("it happened");
 8004f18:	4803      	ldr	r0, [pc, #12]	@ (8004f28 <adcerrorcallback+0x18>)
 8004f1a:	f7fd fbe9 	bl	80026f0 <chSysHalt>
}
 8004f1e:	bf00      	nop
 8004f20:	b003      	add	sp, #12
 8004f22:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f26:	bf00      	nop
 8004f28:	08005414 	.word	0x08005414
 8004f2c:	00000000 	.word	0x00000000

08004f30 <Thread1>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED attached to TP1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8004f30:	b500      	push	{lr}
 8004f32:	b083      	sub	sp, #12
 8004f34:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 8004f36:	480a      	ldr	r0, [pc, #40]	@ (8004f60 <Thread1+0x30>)
 8004f38:	f7ff ffa2 	bl	8004e80 <chRegSetThreadName>
  while (true) {
    palSetLine(PORTAB_LINE_LED1);
 8004f3c:	4b09      	ldr	r3, [pc, #36]	@ (8004f64 <Thread1+0x34>)
 8004f3e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8004f42:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8004f44:	f241 3088 	movw	r0, #5000	@ 0x1388
 8004f48:	f7ff f80a 	bl	8003f60 <chThdSleep>
    palClearLine(PORTAB_LINE_LED1);
 8004f4c:	4b05      	ldr	r3, [pc, #20]	@ (8004f64 <Thread1+0x34>)
 8004f4e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8004f52:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8004f54:	f241 3088 	movw	r0, #5000	@ 0x1388
 8004f58:	f7ff f802 	bl	8003f60 <chThdSleep>
    palSetLine(PORTAB_LINE_LED1);
 8004f5c:	bf00      	nop
 8004f5e:	e7ed      	b.n	8004f3c <Thread1+0xc>
 8004f60:	08005420 	.word	0x08005420
 8004f64:	48001000 	.word	0x48001000
	...

08004f70 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8004f70:	b500      	push	{lr}
 8004f72:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8004f74:	f7fb f9fc 	bl	8000370 <halInit>
  chSysInit();
 8004f78:	f7fd fb8a 	bl	8002690 <chSysInit>

  /* Board-dependent GPIO setup code.*/
  portab_setup();
 8004f7c:	f7ff ff68 	bl	8004e50 <portab_setup>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8004f80:	2300      	movs	r3, #0
 8004f82:	9300      	str	r3, [sp, #0]
 8004f84:	4b1b      	ldr	r3, [pc, #108]	@ (8004ff4 <main+0x84>)
 8004f86:	2280      	movs	r2, #128	@ 0x80
 8004f88:	f44f 71b8 	mov.w	r1, #368	@ 0x170
 8004f8c:	481a      	ldr	r0, [pc, #104]	@ (8004ff8 <main+0x88>)
 8004f8e:	f7fe fea7 	bl	8003ce0 <chThdCreateStatic>

  /*
   * Starting PORTAB_ADC1 driver and the temperature sensor.
   */
  adcStart(&PORTAB_ADC1, &portab_adccfg1);
 8004f92:	491a      	ldr	r1, [pc, #104]	@ (8004ffc <main+0x8c>)
 8004f94:	481a      	ldr	r0, [pc, #104]	@ (8005000 <main+0x90>)
 8004f96:	f7fb fb43 	bl	8000620 <adcStart>
  adcSTM32EnableVREF(&PORTAB_ADC1);
 8004f9a:	4819      	ldr	r0, [pc, #100]	@ (8005000 <main+0x90>)
 8004f9c:	f7fc fdd8 	bl	8001b50 <adcSTM32EnableVREF>
  adcSTM32EnableTS(&PORTAB_ADC1);
 8004fa0:	4817      	ldr	r0, [pc, #92]	@ (8005000 <main+0x90>)
 8004fa2:	f7fc fde5 	bl	8001b70 <adcSTM32EnableTS>

  /* Performing a one-shot conversion on two channels.*/
  adcConvert(&PORTAB_ADC1, &portab_adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
 8004fa6:	2302      	movs	r3, #2
 8004fa8:	4a16      	ldr	r2, [pc, #88]	@ (8005004 <main+0x94>)
 8004faa:	4917      	ldr	r1, [pc, #92]	@ (8005008 <main+0x98>)
 8004fac:	4814      	ldr	r0, [pc, #80]	@ (8005000 <main+0x90>)
 8004fae:	f7fb fc57 	bl	8000860 <adcConvert>
  cacheBufferInvalidate(samples1, sizeof (samples1) / sizeof (adcsample_t));

  /*
   * Starting PORTAB_GPT1 driver, it is used for triggering the ADC.
   */
  gptStart(&PORTAB_GPT1, &portab_gptcfg1);
 8004fb2:	4916      	ldr	r1, [pc, #88]	@ (800500c <main+0x9c>)
 8004fb4:	4816      	ldr	r0, [pc, #88]	@ (8005010 <main+0xa0>)
 8004fb6:	f7fb fceb 	bl	8000990 <gptStart>

  /*
   * Starting an ADC continuous conversion triggered with a period of
   * 1/10000 second.
   */
  adcStartConversion(&PORTAB_ADC1, &portab_adcgrpcfg2,
 8004fba:	2340      	movs	r3, #64	@ 0x40
 8004fbc:	4a15      	ldr	r2, [pc, #84]	@ (8005014 <main+0xa4>)
 8004fbe:	4916      	ldr	r1, [pc, #88]	@ (8005018 <main+0xa8>)
 8004fc0:	480f      	ldr	r0, [pc, #60]	@ (8005000 <main+0x90>)
 8004fc2:	f7fb fb75 	bl	80006b0 <adcStartConversion>
                     samples2, ADC_GRP2_BUF_DEPTH);
  gptStartContinuous(&PORTAB_GPT1, 100U);
 8004fc6:	2164      	movs	r1, #100	@ 0x64
 8004fc8:	4811      	ldr	r0, [pc, #68]	@ (8005010 <main+0xa0>)
 8004fca:	f7fb fd31 	bl	8000a30 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the
   * conversion is stopped.
   */
  while (true) {
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8004fce:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8004fd2:	691b      	ldr	r3, [r3, #16]
 8004fd4:	f003 0301 	and.w	r3, r3, #1
 8004fd8:	2b01      	cmp	r3, #1
 8004fda:	d105      	bne.n	8004fe8 <main+0x78>
      gptStopTimer(&PORTAB_GPT1);
 8004fdc:	480c      	ldr	r0, [pc, #48]	@ (8005010 <main+0xa0>)
 8004fde:	f7fb fd67 	bl	8000ab0 <gptStopTimer>
      adcStopConversion(&PORTAB_ADC1);
 8004fe2:	4807      	ldr	r0, [pc, #28]	@ (8005000 <main+0x90>)
 8004fe4:	f7fb fbf4 	bl	80007d0 <adcStopConversion>
    }
    chThdSleepMilliseconds(500);
 8004fe8:	f241 3088 	movw	r0, #5000	@ 0x1388
 8004fec:	f7fe ffb8 	bl	8003f60 <chThdSleep>
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8004ff0:	e7ed      	b.n	8004fce <main+0x5e>
 8004ff2:	bf00      	nop
 8004ff4:	08004f31 	.word	0x08004f31
 8004ff8:	20000c80 	.word	0x20000c80
 8004ffc:	08005680 	.word	0x08005680
 8005000:	20000800 	.word	0x20000800
 8005004:	20000b6c 	.word	0x20000b6c
 8005008:	08005684 	.word	0x08005684
 800500c:	08005670 	.word	0x08005670
 8005010:	20000924 	.word	0x20000924
 8005014:	20000b74 	.word	0x20000b74
 8005018:	080056c4 	.word	0x080056c4
