
build/stm32l4r5zi_nucleo144/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000299 	.word	0x08000299
 8000008:	0800029b 	.word	0x0800029b
 800000c:	0800029b 	.word	0x0800029b
 8000010:	0800029b 	.word	0x0800029b
 8000014:	0800029b 	.word	0x0800029b
 8000018:	0800029b 	.word	0x0800029b
 800001c:	0800029b 	.word	0x0800029b
 8000020:	0800029b 	.word	0x0800029b
 8000024:	0800029b 	.word	0x0800029b
 8000028:	0800029b 	.word	0x0800029b
 800002c:	08004d31 	.word	0x08004d31
 8000030:	0800029b 	.word	0x0800029b
 8000034:	0800029b 	.word	0x0800029b
 8000038:	0800029b 	.word	0x0800029b
 800003c:	0800029b 	.word	0x0800029b
 8000040:	0800029b 	.word	0x0800029b
 8000044:	0800029b 	.word	0x0800029b
 8000048:	0800029b 	.word	0x0800029b
 800004c:	0800029b 	.word	0x0800029b
 8000050:	0800029b 	.word	0x0800029b
 8000054:	0800029b 	.word	0x0800029b
 8000058:	0800029b 	.word	0x0800029b
 800005c:	0800029b 	.word	0x0800029b
 8000060:	0800029b 	.word	0x0800029b
 8000064:	0800029b 	.word	0x0800029b
 8000068:	0800029b 	.word	0x0800029b
 800006c:	08001af1 	.word	0x08001af1
 8000070:	08001b11 	.word	0x08001b11
 8000074:	08001b31 	.word	0x08001b31
 8000078:	08001b51 	.word	0x08001b51
 800007c:	08001b71 	.word	0x08001b71
 8000080:	08001b91 	.word	0x08001b91
 8000084:	08001bb1 	.word	0x08001bb1
 8000088:	08001751 	.word	0x08001751
 800008c:	0800029b 	.word	0x0800029b
 8000090:	0800029b 	.word	0x0800029b
 8000094:	0800029b 	.word	0x0800029b
 8000098:	0800029b 	.word	0x0800029b
 800009c:	0800029b 	.word	0x0800029b
 80000a0:	0800029b 	.word	0x0800029b
 80000a4:	0800029b 	.word	0x0800029b
 80000a8:	0800029b 	.word	0x0800029b
 80000ac:	0800029b 	.word	0x0800029b
 80000b0:	08000d61 	.word	0x08000d61
 80000b4:	0800029b 	.word	0x0800029b
 80000b8:	08000da1 	.word	0x08000da1
 80000bc:	0800029b 	.word	0x0800029b
 80000c0:	0800029b 	.word	0x0800029b
 80000c4:	0800029b 	.word	0x0800029b
 80000c8:	0800029b 	.word	0x0800029b
 80000cc:	0800029b 	.word	0x0800029b
 80000d0:	0800029b 	.word	0x0800029b
 80000d4:	0800029b 	.word	0x0800029b
 80000d8:	0800029b 	.word	0x0800029b
 80000dc:	0800029b 	.word	0x0800029b
 80000e0:	0800029b 	.word	0x0800029b
 80000e4:	0800029b 	.word	0x0800029b
 80000e8:	0800029b 	.word	0x0800029b
 80000ec:	0800029b 	.word	0x0800029b
 80000f0:	0800029b 	.word	0x0800029b
 80000f4:	0800029b 	.word	0x0800029b
 80000f8:	0800029b 	.word	0x0800029b
 80000fc:	0800029b 	.word	0x0800029b
 8000100:	0800029b 	.word	0x0800029b
 8000104:	0800029b 	.word	0x0800029b
 8000108:	0800029b 	.word	0x0800029b
 800010c:	0800029b 	.word	0x0800029b
 8000110:	0800029b 	.word	0x0800029b
 8000114:	0800029b 	.word	0x0800029b
 8000118:	0800029b 	.word	0x0800029b
 800011c:	0800029b 	.word	0x0800029b
 8000120:	08001bd1 	.word	0x08001bd1
 8000124:	08001bf1 	.word	0x08001bf1
 8000128:	08001c11 	.word	0x08001c11
 800012c:	08001c31 	.word	0x08001c31
 8000130:	08001c51 	.word	0x08001c51
 8000134:	0800029b 	.word	0x0800029b
 8000138:	0800029b 	.word	0x0800029b
 800013c:	0800029b 	.word	0x0800029b
 8000140:	0800029b 	.word	0x0800029b
 8000144:	0800029b 	.word	0x0800029b
 8000148:	0800029b 	.word	0x0800029b
 800014c:	0800029b 	.word	0x0800029b
 8000150:	08001c71 	.word	0x08001c71
 8000154:	08001c91 	.word	0x08001c91
 8000158:	0800029b 	.word	0x0800029b
 800015c:	0800029b 	.word	0x0800029b
 8000160:	0800029b 	.word	0x0800029b
 8000164:	0800029b 	.word	0x0800029b
 8000168:	0800029b 	.word	0x0800029b
 800016c:	0800029b 	.word	0x0800029b
 8000170:	0800029b 	.word	0x0800029b
 8000174:	0800029b 	.word	0x0800029b
 8000178:	0800029b 	.word	0x0800029b
 800017c:	0800029b 	.word	0x0800029b
 8000180:	0800029b 	.word	0x0800029b
 8000184:	0800029b 	.word	0x0800029b
 8000188:	0800029b 	.word	0x0800029b
 800018c:	0800029b 	.word	0x0800029b
 8000190:	0800029b 	.word	0x0800029b
 8000194:	0800029b 	.word	0x0800029b
 8000198:	0800029b 	.word	0x0800029b
 800019c:	0800029b 	.word	0x0800029b
 80001a0:	0800029b 	.word	0x0800029b
 80001a4:	0800029b 	.word	0x0800029b
 80001a8:	0800029b 	.word	0x0800029b
 80001ac:	0800029b 	.word	0x0800029b
 80001b0:	0800029b 	.word	0x0800029b
 80001b4:	0800029b 	.word	0x0800029b
 80001b8:	0800029b 	.word	0x0800029b
 80001bc:	0800029b 	.word	0x0800029b

Disassembly of section .text:

080001c0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001c0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001c2:	4826      	ldr	r0, [pc, #152]	@ (800025c <endfiniloop+0x6>)
                msr     MSP, r0
 80001c4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001c8:	4825      	ldr	r0, [pc, #148]	@ (8000260 <endfiniloop+0xa>)
                msr     PSP, r0
 80001ca:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80001ce:	4825      	ldr	r0, [pc, #148]	@ (8000264 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 80001d0:	4925      	ldr	r1, [pc, #148]	@ (8000268 <endfiniloop+0x12>)
                str     r0, [r1]
 80001d2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001d4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001d6:	f380 8814 	msr	CONTROL, r0
                isb
 80001da:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001de:	f000 f87f 	bl	80002e0 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 80001e2:	f002 f9e5 	bl	80025b0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80001e6:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80001ea:	4920      	ldr	r1, [pc, #128]	@ (800026c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 80001ec:	4a1b      	ldr	r2, [pc, #108]	@ (800025c <endfiniloop+0x6>)

080001ee <msloop>:
msloop:
                cmp     r1, r2
 80001ee:	4291      	cmp	r1, r2
                itt     lo
 80001f0:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001f2:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 80001f6:	e7fa      	bcc.n	80001ee <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80001f8:	491d      	ldr	r1, [pc, #116]	@ (8000270 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 80001fa:	4a19      	ldr	r2, [pc, #100]	@ (8000260 <endfiniloop+0xa>)

080001fc <psloop>:
psloop:
                cmp     r1, r2
 80001fc:	4291      	cmp	r1, r2
                itt     lo
 80001fe:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000200:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000204:	e7fa      	bcc.n	80001fc <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000206:	491b      	ldr	r1, [pc, #108]	@ (8000274 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000208:	4a1b      	ldr	r2, [pc, #108]	@ (8000278 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800020a:	4b1c      	ldr	r3, [pc, #112]	@ (800027c <endfiniloop+0x26>)

0800020c <dloop>:
dloop:
                cmp     r2, r3
 800020c:	429a      	cmp	r2, r3
                ittt    lo
 800020e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000210:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000214:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000218:	e7f8      	bcc.n	800020c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800021a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800021c:	4918      	ldr	r1, [pc, #96]	@ (8000280 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800021e:	4a19      	ldr	r2, [pc, #100]	@ (8000284 <endfiniloop+0x2e>)

08000220 <bloop>:
bloop:
                cmp     r1, r2
 8000220:	4291      	cmp	r1, r2
                itt     lo
 8000222:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000228:	e7fa      	bcc.n	8000220 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800022a:	f000 f871 	bl	8000310 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800022e:	f000 f85f 	bl	80002f0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000232:	4c15      	ldr	r4, [pc, #84]	@ (8000288 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000234:	4d15      	ldr	r5, [pc, #84]	@ (800028c <endfiniloop+0x36>)

08000236 <initloop>:
initloop:
                cmp     r4, r5
 8000236:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000238:	da03      	bge.n	8000242 <endinitloop>
                ldr     r1, [r4], #4
 800023a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800023e:	4788      	blx	r1
                b       initloop
 8000240:	e7f9      	b.n	8000236 <initloop>

08000242 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000242:	f004 fe9d 	bl	8004f80 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000246:	4c12      	ldr	r4, [pc, #72]	@ (8000290 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000248:	4d12      	ldr	r5, [pc, #72]	@ (8000294 <endfiniloop+0x3e>)

0800024a <finiloop>:
finiloop:
                cmp     r4, r5
 800024a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800024c:	da03      	bge.n	8000256 <endfiniloop>
                ldr     r1, [r4], #4
 800024e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000252:	4788      	blx	r1
                b       finiloop
 8000254:	e7f9      	b.n	800024a <finiloop>

08000256 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000256:	f000 b853 	b.w	8000300 <__default_exit>
 800025a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800025c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000260:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000264:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000268:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800026c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000270:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000274:	08005750 	.word	0x08005750
                ldr     r2, =__data_base__
 8000278:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800027c:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 8000280:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 8000284:	20000d80 	.word	0x20000d80
                ldr     r4, =__init_array_base__
 8000288:	080001c0 	.word	0x080001c0
                ldr     r5, =__init_array_end__
 800028c:	080001c0 	.word	0x080001c0
                ldr     r4, =__fini_array_base__
 8000290:	080001c0 	.word	0x080001c0
                ldr     r5, =__fini_array_end__
 8000294:	080001c0 	.word	0x080001c0

08000298 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000298:	e792      	b.n	80001c0 <_crt0_entry>

0800029a <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 800029a:	f000 f800 	bl	800029e <_unhandled_exception>

0800029e <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 800029e:	e7fe      	b.n	800029e <_unhandled_exception>

080002a0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002a4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002a8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002aa:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002b0 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002b0:	f002 fad6 	bl	8002860 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002b4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002b6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002ba:	4628      	mov	r0, r5
                blx     r4
 80002bc:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002be:	2000      	movs	r0, #0
                bl      chThdExit
 80002c0:	f003 fdfe 	bl	8003ec0 <chThdExit>

080002c4 <.zombies>:
.zombies:       b       .zombies
 80002c4:	e7fe      	b.n	80002c4 <.zombies>

080002c6 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 80002c6:	f002 faa3 	bl	8002810 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 80002ca:	f003 fa41 	bl	8003750 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002ce:	f002 fac7 	bl	8002860 <__dbg_check_unlock>

080002d2 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002d2:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002d4:	e7fe      	b.n	80002d4 <__port_exit_from_isr+0x2>
	...

080002e0 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80002e0:	bf00      	nop
 80002e2:	4770      	bx	lr
	...

080002f0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80002f0:	bf00      	nop
 80002f2:	4770      	bx	lr
	...

08000300 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
     asm volatile ("nop");
 8000300:	bf00      	nop
 8000302:	e7fd      	b.n	8000300 <__default_exit>
	...

08000310 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000310:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000312:	4b17      	ldr	r3, [pc, #92]	@ (8000370 <__init_ram_areas+0x60>)
 8000314:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000316:	9b03      	ldr	r3, [sp, #12]
 8000318:	681b      	ldr	r3, [r3, #0]
 800031a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800031c:	9b03      	ldr	r3, [sp, #12]
 800031e:	685b      	ldr	r3, [r3, #4]
 8000320:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000322:	e009      	b.n	8000338 <__init_ram_areas+0x28>
      *p = *tp;
 8000324:	9b02      	ldr	r3, [sp, #8]
 8000326:	681a      	ldr	r2, [r3, #0]
 8000328:	9b01      	ldr	r3, [sp, #4]
 800032a:	601a      	str	r2, [r3, #0]
      p++;
 800032c:	9b01      	ldr	r3, [sp, #4]
 800032e:	3304      	adds	r3, #4
 8000330:	9301      	str	r3, [sp, #4]
      tp++;
 8000332:	9b02      	ldr	r3, [sp, #8]
 8000334:	3304      	adds	r3, #4
 8000336:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8000338:	9b03      	ldr	r3, [sp, #12]
 800033a:	689b      	ldr	r3, [r3, #8]
 800033c:	9a01      	ldr	r2, [sp, #4]
 800033e:	429a      	cmp	r2, r3
 8000340:	d3f0      	bcc.n	8000324 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000342:	e005      	b.n	8000350 <__init_ram_areas+0x40>
      *p = 0;
 8000344:	9b01      	ldr	r3, [sp, #4]
 8000346:	2200      	movs	r2, #0
 8000348:	601a      	str	r2, [r3, #0]
      p++;
 800034a:	9b01      	ldr	r3, [sp, #4]
 800034c:	3304      	adds	r3, #4
 800034e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8000350:	9b03      	ldr	r3, [sp, #12]
 8000352:	68db      	ldr	r3, [r3, #12]
 8000354:	9a01      	ldr	r2, [sp, #4]
 8000356:	429a      	cmp	r2, r3
 8000358:	d3f4      	bcc.n	8000344 <__init_ram_areas+0x34>
    }
    rap++;
 800035a:	9b03      	ldr	r3, [sp, #12]
 800035c:	3310      	adds	r3, #16
 800035e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000360:	9b03      	ldr	r3, [sp, #12]
 8000362:	4a04      	ldr	r2, [pc, #16]	@ (8000374 <__init_ram_areas+0x64>)
 8000364:	4293      	cmp	r3, r2
 8000366:	d3d6      	bcc.n	8000316 <__init_ram_areas+0x6>
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8000368:	bf00      	nop
 800036a:	bf00      	nop
 800036c:	b004      	add	sp, #16
 800036e:	4770      	bx	lr
 8000370:	08005030 	.word	0x08005030
 8000374:	080050b0 	.word	0x080050b0
	...

08000380 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000380:	bf00      	nop
 8000382:	4770      	bx	lr
	...

08000390 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000390:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000392:	f7ff fff5 	bl	8000380 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000396:	f000 ff2b 	bl	80011f0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 800039a:	f001 fdf1 	bl	8001f80 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800039e:	f000 f927 	bl	80005f0 <adcInit>
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 80003a2:	f000 faed 	bl	8000980 <gptInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 80003a6:	f002 f90b 	bl	80025c0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80003aa:	f000 f851 	bl	8000450 <stInit>
#endif
}
 80003ae:	bf00      	nop
 80003b0:	bd08      	pop	{r3, pc}
 80003b2:	bf00      	nop
	...

080003c0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80003c0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
}
 80003c6:	4618      	mov	r0, r3
 80003c8:	4770      	bx	lr
 80003ca:	bf00      	nop
 80003cc:	0000      	movs	r0, r0
	...

080003d0 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 80003d0:	b082      	sub	sp, #8
 80003d2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003d4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80003d8:	9b01      	ldr	r3, [sp, #4]
 80003da:	6353      	str	r3, [r2, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 80003dc:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003e0:	2200      	movs	r2, #0
 80003e2:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80003e4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003e8:	2202      	movs	r2, #2
 80003ea:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 80003ec:	bf00      	nop
 80003ee:	b002      	add	sp, #8
 80003f0:	4770      	bx	lr
 80003f2:	bf00      	nop
	...

08000400 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8000400:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000404:	2200      	movs	r2, #0
 8000406:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 8000408:	bf00      	nop
 800040a:	4770      	bx	lr
 800040c:	0000      	movs	r0, r0
	...

08000410 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 8000410:	b082      	sub	sp, #8
 8000412:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000414:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000418:	9b01      	ldr	r3, [sp, #4]
 800041a:	6353      	str	r3, [r2, #52]	@ 0x34
}
 800041c:	bf00      	nop
 800041e:	b002      	add	sp, #8
 8000420:	4770      	bx	lr
 8000422:	bf00      	nop
	...

08000430 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000430:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000434:	68db      	ldr	r3, [r3, #12]
 8000436:	f003 0302 	and.w	r3, r3, #2
 800043a:	2b00      	cmp	r3, #0
 800043c:	bf14      	ite	ne
 800043e:	2301      	movne	r3, #1
 8000440:	2300      	moveq	r3, #0
 8000442:	b2db      	uxtb	r3, r3
}
 8000444:	4618      	mov	r0, r3
 8000446:	4770      	bx	lr
	...

08000450 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000450:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 8000452:	f001 fead 	bl	80021b0 <st_lld_init>
}
 8000456:	bf00      	nop
 8000458:	bd08      	pop	{r3, pc}
 800045a:	bf00      	nop
 800045c:	0000      	movs	r0, r0
	...

08000460 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 8000460:	b508      	push	{r3, lr}

  return st_lld_get_counter();
 8000462:	f7ff ffad 	bl	80003c0 <st_lld_get_counter>
 8000466:	4603      	mov	r3, r0
}
 8000468:	4618      	mov	r0, r3
 800046a:	bd08      	pop	{r3, pc}
 800046c:	0000      	movs	r0, r0
	...

08000470 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000470:	b500      	push	{lr}
 8000472:	b083      	sub	sp, #12
 8000474:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000476:	f000 f833 	bl	80004e0 <stIsAlarmActive>
 800047a:	4603      	mov	r3, r0
 800047c:	2b00      	cmp	r3, #0
 800047e:	d002      	beq.n	8000486 <stStartAlarm+0x16>
 8000480:	4804      	ldr	r0, [pc, #16]	@ (8000494 <stStartAlarm+0x24>)
 8000482:	f002 f93d 	bl	8002700 <chSysHalt>

  st_lld_start_alarm(abstime);
 8000486:	9801      	ldr	r0, [sp, #4]
 8000488:	f7ff ffa2 	bl	80003d0 <st_lld_start_alarm>
}
 800048c:	bf00      	nop
 800048e:	b003      	add	sp, #12
 8000490:	f85d fb04 	ldr.w	pc, [sp], #4
 8000494:	080050b0 	.word	0x080050b0
	...

080004a0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 80004a0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 80004a2:	f7ff ffad 	bl	8000400 <st_lld_stop_alarm>
}
 80004a6:	bf00      	nop
 80004a8:	bd08      	pop	{r3, pc}
 80004aa:	bf00      	nop
 80004ac:	0000      	movs	r0, r0
	...

080004b0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80004b0:	b500      	push	{lr}
 80004b2:	b083      	sub	sp, #12
 80004b4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80004b6:	f000 f813 	bl	80004e0 <stIsAlarmActive>
 80004ba:	4603      	mov	r3, r0
 80004bc:	f083 0301 	eor.w	r3, r3, #1
 80004c0:	b2db      	uxtb	r3, r3
 80004c2:	2b00      	cmp	r3, #0
 80004c4:	d002      	beq.n	80004cc <stSetAlarm+0x1c>
 80004c6:	4805      	ldr	r0, [pc, #20]	@ (80004dc <stSetAlarm+0x2c>)
 80004c8:	f002 f91a 	bl	8002700 <chSysHalt>

  st_lld_set_alarm(abstime);
 80004cc:	9801      	ldr	r0, [sp, #4]
 80004ce:	f7ff ff9f 	bl	8000410 <st_lld_set_alarm>
}
 80004d2:	bf00      	nop
 80004d4:	b003      	add	sp, #12
 80004d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80004da:	bf00      	nop
 80004dc:	080050c0 	.word	0x080050c0

080004e0 <stIsAlarmActive>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @api
 */
bool stIsAlarmActive(void) {
 80004e0:	b508      	push	{r3, lr}

  return st_lld_is_alarm_active();
 80004e2:	f7ff ffa5 	bl	8000430 <st_lld_is_alarm_active>
 80004e6:	4603      	mov	r3, r0
}
 80004e8:	4618      	mov	r0, r3
 80004ea:	bd08      	pop	{r3, pc}
 80004ec:	0000      	movs	r0, r0
	...

080004f0 <chSysLock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 80004f0:	b500      	push	{lr}
 80004f2:	b083      	sub	sp, #12
 80004f4:	2330      	movs	r3, #48	@ 0x30
 80004f6:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80004f8:	9b01      	ldr	r3, [sp, #4]
 80004fa:	f383 8811 	msr	BASEPRI, r3
}
 80004fe:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000500:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 8000502:	f002 f985 	bl	8002810 <__dbg_check_lock>
}
 8000506:	bf00      	nop
 8000508:	b003      	add	sp, #12
 800050a:	f85d fb04 	ldr.w	pc, [sp], #4
 800050e:	bf00      	nop

08000510 <chSysUnlock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000510:	b500      	push	{lr}
 8000512:	b083      	sub	sp, #12

  __dbg_check_unlock();
 8000514:	f002 f9a4 	bl	8002860 <__dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000518:	4b12      	ldr	r3, [pc, #72]	@ (8000564 <chSysUnlock.lto_priv.2+0x54>)
 800051a:	681b      	ldr	r3, [r3, #0]
 800051c:	4a11      	ldr	r2, [pc, #68]	@ (8000564 <chSysUnlock.lto_priv.2+0x54>)
 800051e:	4293      	cmp	r3, r2
 8000520:	bf14      	ite	ne
 8000522:	2301      	movne	r3, #1
 8000524:	2300      	moveq	r3, #0
 8000526:	b2db      	uxtb	r3, r3
 8000528:	2b00      	cmp	r3, #0
 800052a:	d00f      	beq.n	800054c <chSysUnlock.lto_priv.2+0x3c>
 800052c:	4b0d      	ldr	r3, [pc, #52]	@ (8000564 <chSysUnlock.lto_priv.2+0x54>)
 800052e:	68db      	ldr	r3, [r3, #12]
 8000530:	689a      	ldr	r2, [r3, #8]
 8000532:	4b0c      	ldr	r3, [pc, #48]	@ (8000564 <chSysUnlock.lto_priv.2+0x54>)
 8000534:	681b      	ldr	r3, [r3, #0]
 8000536:	689b      	ldr	r3, [r3, #8]
 8000538:	429a      	cmp	r2, r3
 800053a:	bf34      	ite	cc
 800053c:	2301      	movcc	r3, #1
 800053e:	2300      	movcs	r3, #0
 8000540:	b2db      	uxtb	r3, r3
 8000542:	2b00      	cmp	r3, #0
 8000544:	d002      	beq.n	800054c <chSysUnlock.lto_priv.2+0x3c>
 8000546:	4808      	ldr	r0, [pc, #32]	@ (8000568 <chSysUnlock.lto_priv.2+0x58>)
 8000548:	f002 f8da 	bl	8002700 <chSysHalt>
 800054c:	2300      	movs	r3, #0
 800054e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000550:	9b01      	ldr	r3, [sp, #4]
 8000552:	f383 8811 	msr	BASEPRI, r3
}
 8000556:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000558:	bf00      	nop
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 800055a:	bf00      	nop
 800055c:	b003      	add	sp, #12
 800055e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000562:	bf00      	nop
 8000564:	200008d0 	.word	0x200008d0
 8000568:	080050d8 	.word	0x080050d8
 800056c:	00000000 	.word	0x00000000

08000570 <osalSysLock.lto_priv.2>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000570:	b508      	push	{r3, lr}

  chSysLock();
 8000572:	f7ff ffbd 	bl	80004f0 <chSysLock.lto_priv.2>
}
 8000576:	bf00      	nop
 8000578:	bd08      	pop	{r3, pc}
 800057a:	bf00      	nop
 800057c:	0000      	movs	r0, r0
	...

08000580 <osalSysUnlock.lto_priv.2>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8000580:	b508      	push	{r3, lr}

  chSysUnlock();
 8000582:	f7ff ffc5 	bl	8000510 <chSysUnlock.lto_priv.2>
}
 8000586:	bf00      	nop
 8000588:	bd08      	pop	{r3, pc}
 800058a:	bf00      	nop
 800058c:	0000      	movs	r0, r0
	...

08000590 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8000590:	b500      	push	{lr}
 8000592:	b083      	sub	sp, #12
 8000594:	9001      	str	r0, [sp, #4]

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8000596:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 800059a:	9801      	ldr	r0, [sp, #4]
 800059c:	f003 fcf8 	bl	8003f90 <chThdSuspendTimeoutS>
 80005a0:	4603      	mov	r3, r0
}
 80005a2:	4618      	mov	r0, r3
 80005a4:	b003      	add	sp, #12
 80005a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80005aa:	bf00      	nop
 80005ac:	0000      	movs	r0, r0
	...

080005b0 <osalThreadResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 80005b0:	b500      	push	{lr}
 80005b2:	b083      	sub	sp, #12
 80005b4:	9001      	str	r0, [sp, #4]
 80005b6:	9100      	str	r1, [sp, #0]

  chThdResumeS(trp, msg);
 80005b8:	9900      	ldr	r1, [sp, #0]
 80005ba:	9801      	ldr	r0, [sp, #4]
 80005bc:	f003 fd40 	bl	8004040 <chThdResumeS>
}
 80005c0:	bf00      	nop
 80005c2:	b003      	add	sp, #12
 80005c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080005d0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80005d0:	b500      	push	{lr}
 80005d2:	b083      	sub	sp, #12
 80005d4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80005d6:	9801      	ldr	r0, [sp, #4]
 80005d8:	f003 ff62 	bl	80044a0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80005dc:	bf00      	nop
 80005de:	b003      	add	sp, #12
 80005e0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080005f0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 80005f0:	b508      	push	{r3, lr}

  adc_lld_init();
 80005f2:	f001 f8cd 	bl	8001790 <adc_lld_init>
}
 80005f6:	bf00      	nop
 80005f8:	bd08      	pop	{r3, pc}
 80005fa:	bf00      	nop
 80005fc:	0000      	movs	r0, r0
	...

08000600 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 8000600:	b500      	push	{lr}
 8000602:	b083      	sub	sp, #12
 8000604:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 8000606:	9b01      	ldr	r3, [sp, #4]
 8000608:	2201      	movs	r2, #1
 800060a:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 800060c:	9b01      	ldr	r3, [sp, #4]
 800060e:	2200      	movs	r2, #0
 8000610:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 8000612:	9b01      	ldr	r3, [sp, #4]
 8000614:	2200      	movs	r2, #0
 8000616:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 8000618:	9b01      	ldr	r3, [sp, #4]
 800061a:	2200      	movs	r2, #0
 800061c:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 800061e:	9b01      	ldr	r3, [sp, #4]
 8000620:	2200      	movs	r2, #0
 8000622:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8000624:	9b01      	ldr	r3, [sp, #4]
 8000626:	2200      	movs	r2, #0
 8000628:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 800062a:	9b01      	ldr	r3, [sp, #4]
 800062c:	3318      	adds	r3, #24
 800062e:	4618      	mov	r0, r3
 8000630:	f7ff ffce 	bl	80005d0 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 8000634:	bf00      	nop
 8000636:	b003      	add	sp, #12
 8000638:	f85d fb04 	ldr.w	pc, [sp], #4
 800063c:	0000      	movs	r0, r0
	...

08000640 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8000640:	b500      	push	{lr}
 8000642:	b085      	sub	sp, #20
 8000644:	9001      	str	r0, [sp, #4]
 8000646:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(adcp != NULL);
 8000648:	9b01      	ldr	r3, [sp, #4]
 800064a:	2b00      	cmp	r3, #0
 800064c:	bf0c      	ite	eq
 800064e:	2301      	moveq	r3, #1
 8000650:	2300      	movne	r3, #0
 8000652:	b2db      	uxtb	r3, r3
 8000654:	2b00      	cmp	r3, #0
 8000656:	d002      	beq.n	800065e <adcStart+0x1e>
 8000658:	4819      	ldr	r0, [pc, #100]	@ (80006c0 <adcStart+0x80>)
 800065a:	f002 f851 	bl	8002700 <chSysHalt>

  osalSysLock();
 800065e:	f7ff ff87 	bl	8000570 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 8000662:	9b01      	ldr	r3, [sp, #4]
 8000664:	781b      	ldrb	r3, [r3, #0]
 8000666:	2b01      	cmp	r3, #1
 8000668:	bf14      	ite	ne
 800066a:	2301      	movne	r3, #1
 800066c:	2300      	moveq	r3, #0
 800066e:	b2db      	uxtb	r3, r3
 8000670:	2b00      	cmp	r3, #0
 8000672:	d00b      	beq.n	800068c <adcStart+0x4c>
 8000674:	9b01      	ldr	r3, [sp, #4]
 8000676:	781b      	ldrb	r3, [r3, #0]
 8000678:	2b02      	cmp	r3, #2
 800067a:	bf14      	ite	ne
 800067c:	2301      	movne	r3, #1
 800067e:	2300      	moveq	r3, #0
 8000680:	b2db      	uxtb	r3, r3
 8000682:	2b00      	cmp	r3, #0
 8000684:	d002      	beq.n	800068c <adcStart+0x4c>
 8000686:	480e      	ldr	r0, [pc, #56]	@ (80006c0 <adcStart+0x80>)
 8000688:	f002 f83a 	bl	8002700 <chSysHalt>
                "invalid state");
  adcp->config = config;
 800068c:	9b01      	ldr	r3, [sp, #4]
 800068e:	9a00      	ldr	r2, [sp, #0]
 8000690:	605a      	str	r2, [r3, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
#else
  adc_lld_start(adcp);
 8000692:	9801      	ldr	r0, [sp, #4]
 8000694:	f001 f8d4 	bl	8001840 <adc_lld_start>
  msg = HAL_RET_SUCCESS;
 8000698:	2300      	movs	r3, #0
 800069a:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 800069c:	9b03      	ldr	r3, [sp, #12]
 800069e:	2b00      	cmp	r3, #0
 80006a0:	d103      	bne.n	80006aa <adcStart+0x6a>
    adcp->state = ADC_READY;
 80006a2:	9b01      	ldr	r3, [sp, #4]
 80006a4:	2202      	movs	r2, #2
 80006a6:	701a      	strb	r2, [r3, #0]
 80006a8:	e002      	b.n	80006b0 <adcStart+0x70>
  }
  else {
    adcp->state = ADC_STOP;
 80006aa:	9b01      	ldr	r3, [sp, #4]
 80006ac:	2201      	movs	r2, #1
 80006ae:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 80006b0:	f7ff ff66 	bl	8000580 <osalSysUnlock.lto_priv.2>

  return msg;
 80006b4:	9b03      	ldr	r3, [sp, #12]
}
 80006b6:	4618      	mov	r0, r3
 80006b8:	b005      	add	sp, #20
 80006ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80006be:	bf00      	nop
 80006c0:	080050cc 	.word	0x080050cc
	...

080006d0 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 80006d0:	b500      	push	{lr}
 80006d2:	b085      	sub	sp, #20
 80006d4:	9003      	str	r0, [sp, #12]
 80006d6:	9102      	str	r1, [sp, #8]
 80006d8:	9201      	str	r2, [sp, #4]
 80006da:	9300      	str	r3, [sp, #0]

  osalSysLock();
 80006dc:	f7ff ff48 	bl	8000570 <osalSysLock.lto_priv.2>
  adcStartConversionI(adcp, grpp, samples, depth);
 80006e0:	9b00      	ldr	r3, [sp, #0]
 80006e2:	9a01      	ldr	r2, [sp, #4]
 80006e4:	9902      	ldr	r1, [sp, #8]
 80006e6:	9803      	ldr	r0, [sp, #12]
 80006e8:	f000 f80a 	bl	8000700 <adcStartConversionI>
  osalSysUnlock();
 80006ec:	f7ff ff48 	bl	8000580 <osalSysUnlock.lto_priv.2>
}
 80006f0:	bf00      	nop
 80006f2:	b005      	add	sp, #20
 80006f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000700 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
 8000700:	b500      	push	{lr}
 8000702:	b085      	sub	sp, #20
 8000704:	9003      	str	r0, [sp, #12]
 8000706:	9102      	str	r1, [sp, #8]
 8000708:	9201      	str	r2, [sp, #4]
 800070a:	9300      	str	r3, [sp, #0]

  osalDbgCheckClassI();
 800070c:	f002 f998 	bl	8002a40 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
 8000710:	9b03      	ldr	r3, [sp, #12]
 8000712:	2b00      	cmp	r3, #0
 8000714:	bf0c      	ite	eq
 8000716:	2301      	moveq	r3, #1
 8000718:	2300      	movne	r3, #0
 800071a:	b2db      	uxtb	r3, r3
 800071c:	2b00      	cmp	r3, #0
 800071e:	d107      	bne.n	8000730 <adcStartConversionI+0x30>
 8000720:	9b02      	ldr	r3, [sp, #8]
 8000722:	2b00      	cmp	r3, #0
 8000724:	bf0c      	ite	eq
 8000726:	2301      	moveq	r3, #1
 8000728:	2300      	movne	r3, #0
 800072a:	b2db      	uxtb	r3, r3
 800072c:	2b00      	cmp	r3, #0
 800072e:	d001      	beq.n	8000734 <adcStartConversionI+0x34>
 8000730:	2301      	movs	r3, #1
 8000732:	e000      	b.n	8000736 <adcStartConversionI+0x36>
 8000734:	2300      	movs	r3, #0
 8000736:	2b00      	cmp	r3, #0
 8000738:	d107      	bne.n	800074a <adcStartConversionI+0x4a>
 800073a:	9b01      	ldr	r3, [sp, #4]
 800073c:	2b00      	cmp	r3, #0
 800073e:	bf0c      	ite	eq
 8000740:	2301      	moveq	r3, #1
 8000742:	2300      	movne	r3, #0
 8000744:	b2db      	uxtb	r3, r3
 8000746:	2b00      	cmp	r3, #0
 8000748:	d001      	beq.n	800074e <adcStartConversionI+0x4e>
 800074a:	2301      	movs	r3, #1
 800074c:	e000      	b.n	8000750 <adcStartConversionI+0x50>
 800074e:	2300      	movs	r3, #0
 8000750:	2b00      	cmp	r3, #0
 8000752:	d107      	bne.n	8000764 <adcStartConversionI+0x64>
 8000754:	9b00      	ldr	r3, [sp, #0]
 8000756:	2b00      	cmp	r3, #0
 8000758:	bf0c      	ite	eq
 800075a:	2301      	moveq	r3, #1
 800075c:	2300      	movne	r3, #0
 800075e:	b2db      	uxtb	r3, r3
 8000760:	2b00      	cmp	r3, #0
 8000762:	d001      	beq.n	8000768 <adcStartConversionI+0x68>
 8000764:	2301      	movs	r3, #1
 8000766:	e000      	b.n	800076a <adcStartConversionI+0x6a>
 8000768:	2300      	movs	r3, #0
 800076a:	2b00      	cmp	r3, #0
 800076c:	d111      	bne.n	8000792 <adcStartConversionI+0x92>
 800076e:	9b00      	ldr	r3, [sp, #0]
 8000770:	2b01      	cmp	r3, #1
 8000772:	bf14      	ite	ne
 8000774:	2301      	movne	r3, #1
 8000776:	2300      	moveq	r3, #0
 8000778:	b2db      	uxtb	r3, r3
 800077a:	2b00      	cmp	r3, #0
 800077c:	d006      	beq.n	800078c <adcStartConversionI+0x8c>
 800077e:	9b00      	ldr	r3, [sp, #0]
 8000780:	f003 0301 	and.w	r3, r3, #1
 8000784:	2b00      	cmp	r3, #0
 8000786:	d001      	beq.n	800078c <adcStartConversionI+0x8c>
 8000788:	2301      	movs	r3, #1
 800078a:	e000      	b.n	800078e <adcStartConversionI+0x8e>
 800078c:	2300      	movs	r3, #0
 800078e:	2b00      	cmp	r3, #0
 8000790:	d002      	beq.n	8000798 <adcStartConversionI+0x98>
 8000792:	4815      	ldr	r0, [pc, #84]	@ (80007e8 <adcStartConversionI+0xe8>)
 8000794:	f001 ffb4 	bl	8002700 <chSysHalt>
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
 8000798:	9b03      	ldr	r3, [sp, #12]
 800079a:	781b      	ldrb	r3, [r3, #0]
 800079c:	2b02      	cmp	r3, #2
 800079e:	bf14      	ite	ne
 80007a0:	2301      	movne	r3, #1
 80007a2:	2300      	moveq	r3, #0
 80007a4:	b2db      	uxtb	r3, r3
 80007a6:	2b00      	cmp	r3, #0
 80007a8:	d00b      	beq.n	80007c2 <adcStartConversionI+0xc2>
 80007aa:	9b03      	ldr	r3, [sp, #12]
 80007ac:	781b      	ldrb	r3, [r3, #0]
 80007ae:	2b05      	cmp	r3, #5
 80007b0:	bf14      	ite	ne
 80007b2:	2301      	movne	r3, #1
 80007b4:	2300      	moveq	r3, #0
 80007b6:	b2db      	uxtb	r3, r3
 80007b8:	2b00      	cmp	r3, #0
 80007ba:	d002      	beq.n	80007c2 <adcStartConversionI+0xc2>
 80007bc:	480a      	ldr	r0, [pc, #40]	@ (80007e8 <adcStartConversionI+0xe8>)
 80007be:	f001 ff9f 	bl	8002700 <chSysHalt>
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 80007c2:	9b03      	ldr	r3, [sp, #12]
 80007c4:	9a01      	ldr	r2, [sp, #4]
 80007c6:	609a      	str	r2, [r3, #8]
  adcp->depth    = depth;
 80007c8:	9b03      	ldr	r3, [sp, #12]
 80007ca:	9a00      	ldr	r2, [sp, #0]
 80007cc:	60da      	str	r2, [r3, #12]
  adcp->grpp     = grpp;
 80007ce:	9b03      	ldr	r3, [sp, #12]
 80007d0:	9a02      	ldr	r2, [sp, #8]
 80007d2:	611a      	str	r2, [r3, #16]
  adcp->state    = ADC_ACTIVE;
 80007d4:	9b03      	ldr	r3, [sp, #12]
 80007d6:	2203      	movs	r2, #3
 80007d8:	701a      	strb	r2, [r3, #0]
  adc_lld_start_conversion(adcp);
 80007da:	9803      	ldr	r0, [sp, #12]
 80007dc:	f001 f8a0 	bl	8001920 <adc_lld_start_conversion>
}
 80007e0:	bf00      	nop
 80007e2:	b005      	add	sp, #20
 80007e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80007e8:	080050e4 	.word	0x080050e4
 80007ec:	00000000 	.word	0x00000000

080007f0 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
 80007f0:	b500      	push	{lr}
 80007f2:	b083      	sub	sp, #12
 80007f4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(adcp != NULL);
 80007f6:	9b01      	ldr	r3, [sp, #4]
 80007f8:	2b00      	cmp	r3, #0
 80007fa:	bf0c      	ite	eq
 80007fc:	2301      	moveq	r3, #1
 80007fe:	2300      	movne	r3, #0
 8000800:	b2db      	uxtb	r3, r3
 8000802:	2b00      	cmp	r3, #0
 8000804:	d002      	beq.n	800080c <adcStopConversion+0x1c>
 8000806:	481a      	ldr	r0, [pc, #104]	@ (8000870 <adcStopConversion+0x80>)
 8000808:	f001 ff7a 	bl	8002700 <chSysHalt>

  osalSysLock();
 800080c:	f7ff feb0 	bl	8000570 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_READY) || (adcp->state == ADC_ACTIVE),
 8000810:	9b01      	ldr	r3, [sp, #4]
 8000812:	781b      	ldrb	r3, [r3, #0]
 8000814:	2b02      	cmp	r3, #2
 8000816:	bf14      	ite	ne
 8000818:	2301      	movne	r3, #1
 800081a:	2300      	moveq	r3, #0
 800081c:	b2db      	uxtb	r3, r3
 800081e:	2b00      	cmp	r3, #0
 8000820:	d00b      	beq.n	800083a <adcStopConversion+0x4a>
 8000822:	9b01      	ldr	r3, [sp, #4]
 8000824:	781b      	ldrb	r3, [r3, #0]
 8000826:	2b03      	cmp	r3, #3
 8000828:	bf14      	ite	ne
 800082a:	2301      	movne	r3, #1
 800082c:	2300      	moveq	r3, #0
 800082e:	b2db      	uxtb	r3, r3
 8000830:	2b00      	cmp	r3, #0
 8000832:	d002      	beq.n	800083a <adcStopConversion+0x4a>
 8000834:	480e      	ldr	r0, [pc, #56]	@ (8000870 <adcStopConversion+0x80>)
 8000836:	f001 ff63 	bl	8002700 <chSysHalt>
                "invalid state");
  if (adcp->state != ADC_READY) {
 800083a:	9b01      	ldr	r3, [sp, #4]
 800083c:	781b      	ldrb	r3, [r3, #0]
 800083e:	2b02      	cmp	r3, #2
 8000840:	d00f      	beq.n	8000862 <adcStopConversion+0x72>
    adc_lld_stop_conversion(adcp);
 8000842:	9801      	ldr	r0, [sp, #4]
 8000844:	f001 f914 	bl	8001a70 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
 8000848:	9b01      	ldr	r3, [sp, #4]
 800084a:	2200      	movs	r2, #0
 800084c:	611a      	str	r2, [r3, #16]
    adcp->state = ADC_READY;
 800084e:	9b01      	ldr	r3, [sp, #4]
 8000850:	2202      	movs	r2, #2
 8000852:	701a      	strb	r2, [r3, #0]
    _adc_reset_s(adcp);
 8000854:	9b01      	ldr	r3, [sp, #4]
 8000856:	3314      	adds	r3, #20
 8000858:	f06f 0101 	mvn.w	r1, #1
 800085c:	4618      	mov	r0, r3
 800085e:	f7ff fea7 	bl	80005b0 <osalThreadResumeS>
  }
  osalSysUnlock();
 8000862:	f7ff fe8d 	bl	8000580 <osalSysUnlock.lto_priv.2>
}
 8000866:	bf00      	nop
 8000868:	b003      	add	sp, #12
 800086a:	f85d fb04 	ldr.w	pc, [sp], #4
 800086e:	bf00      	nop
 8000870:	080050f8 	.word	0x080050f8
	...

08000880 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8000880:	b500      	push	{lr}
 8000882:	b087      	sub	sp, #28
 8000884:	9003      	str	r0, [sp, #12]
 8000886:	9102      	str	r1, [sp, #8]
 8000888:	9201      	str	r2, [sp, #4]
 800088a:	9300      	str	r3, [sp, #0]
  msg_t msg;

  osalSysLock();
 800088c:	f7ff fe70 	bl	8000570 <osalSysLock.lto_priv.2>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
 8000890:	9b03      	ldr	r3, [sp, #12]
 8000892:	695b      	ldr	r3, [r3, #20]
 8000894:	2b00      	cmp	r3, #0
 8000896:	bf14      	ite	ne
 8000898:	2301      	movne	r3, #1
 800089a:	2300      	moveq	r3, #0
 800089c:	b2db      	uxtb	r3, r3
 800089e:	2b00      	cmp	r3, #0
 80008a0:	d002      	beq.n	80008a8 <adcConvert+0x28>
 80008a2:	480b      	ldr	r0, [pc, #44]	@ (80008d0 <adcConvert+0x50>)
 80008a4:	f001 ff2c 	bl	8002700 <chSysHalt>
  adcStartConversionI(adcp, grpp, samples, depth);
 80008a8:	9b00      	ldr	r3, [sp, #0]
 80008aa:	9a01      	ldr	r2, [sp, #4]
 80008ac:	9902      	ldr	r1, [sp, #8]
 80008ae:	9803      	ldr	r0, [sp, #12]
 80008b0:	f7ff ff26 	bl	8000700 <adcStartConversionI>
  msg = osalThreadSuspendS(&adcp->thread);
 80008b4:	9b03      	ldr	r3, [sp, #12]
 80008b6:	3314      	adds	r3, #20
 80008b8:	4618      	mov	r0, r3
 80008ba:	f7ff fe69 	bl	8000590 <osalThreadSuspendS>
 80008be:	9005      	str	r0, [sp, #20]
  osalSysUnlock();
 80008c0:	f7ff fe5e 	bl	8000580 <osalSysUnlock.lto_priv.2>
  return msg;
 80008c4:	9b05      	ldr	r3, [sp, #20]
}
 80008c6:	4618      	mov	r0, r3
 80008c8:	b007      	add	sp, #28
 80008ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80008ce:	bf00      	nop
 80008d0:	0800510c 	.word	0x0800510c
	...

080008e0 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
 80008e0:	b500      	push	{lr}
 80008e2:	b083      	sub	sp, #12
 80008e4:	2330      	movs	r3, #48	@ 0x30
 80008e6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80008e8:	9b01      	ldr	r3, [sp, #4]
 80008ea:	f383 8811 	msr	BASEPRI, r3
}
 80008ee:	bf00      	nop
}
 80008f0:	bf00      	nop
  __dbg_check_lock();
 80008f2:	f001 ff8d 	bl	8002810 <__dbg_check_lock>
}
 80008f6:	bf00      	nop
 80008f8:	b003      	add	sp, #12
 80008fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80008fe:	bf00      	nop

08000900 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
 8000900:	b500      	push	{lr}
 8000902:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8000904:	f001 ffac 	bl	8002860 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000908:	4b12      	ldr	r3, [pc, #72]	@ (8000954 <chSysUnlock.lto_priv.3+0x54>)
 800090a:	681b      	ldr	r3, [r3, #0]
 800090c:	4a11      	ldr	r2, [pc, #68]	@ (8000954 <chSysUnlock.lto_priv.3+0x54>)
 800090e:	4293      	cmp	r3, r2
 8000910:	bf14      	ite	ne
 8000912:	2301      	movne	r3, #1
 8000914:	2300      	moveq	r3, #0
 8000916:	b2db      	uxtb	r3, r3
 8000918:	2b00      	cmp	r3, #0
 800091a:	d00f      	beq.n	800093c <chSysUnlock.lto_priv.3+0x3c>
 800091c:	4b0d      	ldr	r3, [pc, #52]	@ (8000954 <chSysUnlock.lto_priv.3+0x54>)
 800091e:	68db      	ldr	r3, [r3, #12]
 8000920:	689a      	ldr	r2, [r3, #8]
 8000922:	4b0c      	ldr	r3, [pc, #48]	@ (8000954 <chSysUnlock.lto_priv.3+0x54>)
 8000924:	681b      	ldr	r3, [r3, #0]
 8000926:	689b      	ldr	r3, [r3, #8]
 8000928:	429a      	cmp	r2, r3
 800092a:	bf34      	ite	cc
 800092c:	2301      	movcc	r3, #1
 800092e:	2300      	movcs	r3, #0
 8000930:	b2db      	uxtb	r3, r3
 8000932:	2b00      	cmp	r3, #0
 8000934:	d002      	beq.n	800093c <chSysUnlock.lto_priv.3+0x3c>
 8000936:	4808      	ldr	r0, [pc, #32]	@ (8000958 <chSysUnlock.lto_priv.3+0x58>)
 8000938:	f001 fee2 	bl	8002700 <chSysHalt>
 800093c:	2300      	movs	r3, #0
 800093e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000940:	9b01      	ldr	r3, [sp, #4]
 8000942:	f383 8811 	msr	BASEPRI, r3
}
 8000946:	bf00      	nop
}
 8000948:	bf00      	nop
}
 800094a:	bf00      	nop
 800094c:	b003      	add	sp, #12
 800094e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000952:	bf00      	nop
 8000954:	200008d0 	.word	0x200008d0
 8000958:	08005124 	.word	0x08005124
 800095c:	00000000 	.word	0x00000000

08000960 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
 8000960:	b508      	push	{r3, lr}
  chSysLock();
 8000962:	f7ff ffbd 	bl	80008e0 <chSysLock.lto_priv.3>
}
 8000966:	bf00      	nop
 8000968:	bd08      	pop	{r3, pc}
 800096a:	bf00      	nop
 800096c:	0000      	movs	r0, r0
	...

08000970 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
 8000970:	b508      	push	{r3, lr}
  chSysUnlock();
 8000972:	f7ff ffc5 	bl	8000900 <chSysUnlock.lto_priv.3>
}
 8000976:	bf00      	nop
 8000978:	bd08      	pop	{r3, pc}
 800097a:	bf00      	nop
 800097c:	0000      	movs	r0, r0
	...

08000980 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8000980:	b508      	push	{r3, lr}

  gpt_lld_init();
 8000982:	f001 fc7d 	bl	8002280 <gpt_lld_init>
}
 8000986:	bf00      	nop
 8000988:	bd08      	pop	{r3, pc}
 800098a:	bf00      	nop
 800098c:	0000      	movs	r0, r0
	...

08000990 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8000990:	b082      	sub	sp, #8
 8000992:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 8000994:	9b01      	ldr	r3, [sp, #4]
 8000996:	2201      	movs	r2, #1
 8000998:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 800099a:	9b01      	ldr	r3, [sp, #4]
 800099c:	2200      	movs	r2, #0
 800099e:	605a      	str	r2, [r3, #4]
}
 80009a0:	bf00      	nop
 80009a2:	b002      	add	sp, #8
 80009a4:	4770      	bx	lr
 80009a6:	bf00      	nop
	...

080009b0 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 80009b0:	b500      	push	{lr}
 80009b2:	b085      	sub	sp, #20
 80009b4:	9001      	str	r0, [sp, #4]
 80009b6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 80009b8:	9b01      	ldr	r3, [sp, #4]
 80009ba:	2b00      	cmp	r3, #0
 80009bc:	bf0c      	ite	eq
 80009be:	2301      	moveq	r3, #1
 80009c0:	2300      	movne	r3, #0
 80009c2:	b2db      	uxtb	r3, r3
 80009c4:	2b00      	cmp	r3, #0
 80009c6:	d107      	bne.n	80009d8 <gptStart+0x28>
 80009c8:	9b00      	ldr	r3, [sp, #0]
 80009ca:	2b00      	cmp	r3, #0
 80009cc:	bf0c      	ite	eq
 80009ce:	2301      	moveq	r3, #1
 80009d0:	2300      	movne	r3, #0
 80009d2:	b2db      	uxtb	r3, r3
 80009d4:	2b00      	cmp	r3, #0
 80009d6:	d002      	beq.n	80009de <gptStart+0x2e>
 80009d8:	4819      	ldr	r0, [pc, #100]	@ (8000a40 <gptStart+0x90>)
 80009da:	f001 fe91 	bl	8002700 <chSysHalt>

  osalSysLock();
 80009de:	f7ff ffbf 	bl	8000960 <osalSysLock.lto_priv.3>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
 80009e2:	9b01      	ldr	r3, [sp, #4]
 80009e4:	781b      	ldrb	r3, [r3, #0]
 80009e6:	2b01      	cmp	r3, #1
 80009e8:	bf14      	ite	ne
 80009ea:	2301      	movne	r3, #1
 80009ec:	2300      	moveq	r3, #0
 80009ee:	b2db      	uxtb	r3, r3
 80009f0:	2b00      	cmp	r3, #0
 80009f2:	d00b      	beq.n	8000a0c <gptStart+0x5c>
 80009f4:	9b01      	ldr	r3, [sp, #4]
 80009f6:	781b      	ldrb	r3, [r3, #0]
 80009f8:	2b02      	cmp	r3, #2
 80009fa:	bf14      	ite	ne
 80009fc:	2301      	movne	r3, #1
 80009fe:	2300      	moveq	r3, #0
 8000a00:	b2db      	uxtb	r3, r3
 8000a02:	2b00      	cmp	r3, #0
 8000a04:	d002      	beq.n	8000a0c <gptStart+0x5c>
 8000a06:	480e      	ldr	r0, [pc, #56]	@ (8000a40 <gptStart+0x90>)
 8000a08:	f001 fe7a 	bl	8002700 <chSysHalt>
              "invalid state");

  gptp->config = config;
 8000a0c:	9b01      	ldr	r3, [sp, #4]
 8000a0e:	9a00      	ldr	r2, [sp, #0]
 8000a10:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 8000a12:	9801      	ldr	r0, [sp, #4]
 8000a14:	f001 fc44 	bl	80022a0 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 8000a18:	2300      	movs	r3, #0
 8000a1a:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 8000a1c:	9b03      	ldr	r3, [sp, #12]
 8000a1e:	2b00      	cmp	r3, #0
 8000a20:	d103      	bne.n	8000a2a <gptStart+0x7a>
    gptp->state = GPT_READY;
 8000a22:	9b01      	ldr	r3, [sp, #4]
 8000a24:	2202      	movs	r2, #2
 8000a26:	701a      	strb	r2, [r3, #0]
 8000a28:	e002      	b.n	8000a30 <gptStart+0x80>
  }
  else {
    gptp->state = GPT_STOP;
 8000a2a:	9b01      	ldr	r3, [sp, #4]
 8000a2c:	2201      	movs	r2, #1
 8000a2e:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000a30:	f7ff ff9e 	bl	8000970 <osalSysUnlock.lto_priv.3>

  return msg;
 8000a34:	9b03      	ldr	r3, [sp, #12]
}
 8000a36:	4618      	mov	r0, r3
 8000a38:	b005      	add	sp, #20
 8000a3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a3e:	bf00      	nop
 8000a40:	08005118 	.word	0x08005118
	...

08000a50 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 8000a50:	b500      	push	{lr}
 8000a52:	b083      	sub	sp, #12
 8000a54:	9001      	str	r0, [sp, #4]
 8000a56:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8000a58:	f7ff ff82 	bl	8000960 <osalSysLock.lto_priv.3>
  gptStartContinuousI(gptp, interval);
 8000a5c:	9900      	ldr	r1, [sp, #0]
 8000a5e:	9801      	ldr	r0, [sp, #4]
 8000a60:	f000 f806 	bl	8000a70 <gptStartContinuousI>
  osalSysUnlock();
 8000a64:	f7ff ff84 	bl	8000970 <osalSysUnlock.lto_priv.3>
}
 8000a68:	bf00      	nop
 8000a6a:	b003      	add	sp, #12
 8000a6c:	f85d fb04 	ldr.w	pc, [sp], #4

08000a70 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 8000a70:	b500      	push	{lr}
 8000a72:	b083      	sub	sp, #12
 8000a74:	9001      	str	r0, [sp, #4]
 8000a76:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8000a78:	f001 ffe2 	bl	8002a40 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000a7c:	9b01      	ldr	r3, [sp, #4]
 8000a7e:	2b00      	cmp	r3, #0
 8000a80:	bf0c      	ite	eq
 8000a82:	2301      	moveq	r3, #1
 8000a84:	2300      	movne	r3, #0
 8000a86:	b2db      	uxtb	r3, r3
 8000a88:	2b00      	cmp	r3, #0
 8000a8a:	d002      	beq.n	8000a92 <gptStartContinuousI+0x22>
 8000a8c:	480c      	ldr	r0, [pc, #48]	@ (8000ac0 <gptStartContinuousI+0x50>)
 8000a8e:	f001 fe37 	bl	8002700 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
 8000a92:	9b01      	ldr	r3, [sp, #4]
 8000a94:	781b      	ldrb	r3, [r3, #0]
 8000a96:	2b02      	cmp	r3, #2
 8000a98:	bf14      	ite	ne
 8000a9a:	2301      	movne	r3, #1
 8000a9c:	2300      	moveq	r3, #0
 8000a9e:	b2db      	uxtb	r3, r3
 8000aa0:	2b00      	cmp	r3, #0
 8000aa2:	d002      	beq.n	8000aaa <gptStartContinuousI+0x3a>
 8000aa4:	4806      	ldr	r0, [pc, #24]	@ (8000ac0 <gptStartContinuousI+0x50>)
 8000aa6:	f001 fe2b 	bl	8002700 <chSysHalt>
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000aaa:	9b01      	ldr	r3, [sp, #4]
 8000aac:	2203      	movs	r2, #3
 8000aae:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 8000ab0:	9900      	ldr	r1, [sp, #0]
 8000ab2:	9801      	ldr	r0, [sp, #4]
 8000ab4:	f001 fc6c 	bl	8002390 <gpt_lld_start_timer>
}
 8000ab8:	bf00      	nop
 8000aba:	b003      	add	sp, #12
 8000abc:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ac0:	08005130 	.word	0x08005130
	...

08000ad0 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000ad0:	b500      	push	{lr}
 8000ad2:	b083      	sub	sp, #12
 8000ad4:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8000ad6:	f7ff ff43 	bl	8000960 <osalSysLock.lto_priv.3>
  gptStopTimerI(gptp);
 8000ada:	9801      	ldr	r0, [sp, #4]
 8000adc:	f000 f808 	bl	8000af0 <gptStopTimerI>
  osalSysUnlock();
 8000ae0:	f7ff ff46 	bl	8000970 <osalSysUnlock.lto_priv.3>
}
 8000ae4:	bf00      	nop
 8000ae6:	b003      	add	sp, #12
 8000ae8:	f85d fb04 	ldr.w	pc, [sp], #4
 8000aec:	0000      	movs	r0, r0
	...

08000af0 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000af0:	b500      	push	{lr}
 8000af2:	b083      	sub	sp, #12
 8000af4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8000af6:	f001 ffa3 	bl	8002a40 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000afa:	9b01      	ldr	r3, [sp, #4]
 8000afc:	2b00      	cmp	r3, #0
 8000afe:	bf0c      	ite	eq
 8000b00:	2301      	moveq	r3, #1
 8000b02:	2300      	movne	r3, #0
 8000b04:	b2db      	uxtb	r3, r3
 8000b06:	2b00      	cmp	r3, #0
 8000b08:	d002      	beq.n	8000b10 <gptStopTimerI+0x20>
 8000b0a:	4818      	ldr	r0, [pc, #96]	@ (8000b6c <gptStopTimerI+0x7c>)
 8000b0c:	f001 fdf8 	bl	8002700 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
 8000b10:	9b01      	ldr	r3, [sp, #4]
 8000b12:	781b      	ldrb	r3, [r3, #0]
 8000b14:	2b02      	cmp	r3, #2
 8000b16:	bf14      	ite	ne
 8000b18:	2301      	movne	r3, #1
 8000b1a:	2300      	moveq	r3, #0
 8000b1c:	b2db      	uxtb	r3, r3
 8000b1e:	2b00      	cmp	r3, #0
 8000b20:	d00a      	beq.n	8000b38 <gptStopTimerI+0x48>
 8000b22:	9b01      	ldr	r3, [sp, #4]
 8000b24:	781b      	ldrb	r3, [r3, #0]
 8000b26:	2b03      	cmp	r3, #3
 8000b28:	bf14      	ite	ne
 8000b2a:	2301      	movne	r3, #1
 8000b2c:	2300      	moveq	r3, #0
 8000b2e:	b2db      	uxtb	r3, r3
 8000b30:	2b00      	cmp	r3, #0
 8000b32:	d001      	beq.n	8000b38 <gptStopTimerI+0x48>
 8000b34:	2301      	movs	r3, #1
 8000b36:	e000      	b.n	8000b3a <gptStopTimerI+0x4a>
 8000b38:	2300      	movs	r3, #0
 8000b3a:	2b00      	cmp	r3, #0
 8000b3c:	d00b      	beq.n	8000b56 <gptStopTimerI+0x66>
 8000b3e:	9b01      	ldr	r3, [sp, #4]
 8000b40:	781b      	ldrb	r3, [r3, #0]
 8000b42:	2b04      	cmp	r3, #4
 8000b44:	bf14      	ite	ne
 8000b46:	2301      	movne	r3, #1
 8000b48:	2300      	moveq	r3, #0
 8000b4a:	b2db      	uxtb	r3, r3
 8000b4c:	2b00      	cmp	r3, #0
 8000b4e:	d002      	beq.n	8000b56 <gptStopTimerI+0x66>
 8000b50:	4806      	ldr	r0, [pc, #24]	@ (8000b6c <gptStopTimerI+0x7c>)
 8000b52:	f001 fdd5 	bl	8002700 <chSysHalt>
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000b56:	9b01      	ldr	r3, [sp, #4]
 8000b58:	2202      	movs	r2, #2
 8000b5a:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000b5c:	9801      	ldr	r0, [sp, #4]
 8000b5e:	f001 fc3f 	bl	80023e0 <gpt_lld_stop_timer>
}
 8000b62:	bf00      	nop
 8000b64:	b003      	add	sp, #12
 8000b66:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b6a:	bf00      	nop
 8000b6c:	08005144 	.word	0x08005144

08000b70 <nvicInit>:
/*===========================================================================*/

/**
 * @brief   NVIC clearing and initialization.
 */
void nvicInit(void) {
 8000b70:	b082      	sub	sp, #8
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
#else
  uint32_t n = SCnSCB->ICTR;
 8000b72:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8000b76:	685b      	ldr	r3, [r3, #4]
 8000b78:	9300      	str	r3, [sp, #0]
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 8000b7a:	2300      	movs	r3, #0
 8000b7c:	9301      	str	r3, [sp, #4]
 8000b7e:	e010      	b.n	8000ba2 <nvicInit+0x32>
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8000b80:	4a0c      	ldr	r2, [pc, #48]	@ (8000bb4 <nvicInit+0x44>)
 8000b82:	9b01      	ldr	r3, [sp, #4]
 8000b84:	3320      	adds	r3, #32
 8000b86:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8000b8a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 8000b8e:	4a09      	ldr	r2, [pc, #36]	@ (8000bb4 <nvicInit+0x44>)
 8000b90:	9b01      	ldr	r3, [sp, #4]
 8000b92:	3360      	adds	r3, #96	@ 0x60
 8000b94:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8000b98:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  for (uint32_t i = 0U; i <= n; i++) {
 8000b9c:	9b01      	ldr	r3, [sp, #4]
 8000b9e:	3301      	adds	r3, #1
 8000ba0:	9301      	str	r3, [sp, #4]
 8000ba2:	9a01      	ldr	r2, [sp, #4]
 8000ba4:	9b00      	ldr	r3, [sp, #0]
 8000ba6:	429a      	cmp	r2, r3
 8000ba8:	d9ea      	bls.n	8000b80 <nvicInit+0x10>
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
    NVIC->__ITNS[i] = 0xFFFFFFFFU;
#endif
  }
}
 8000baa:	bf00      	nop
 8000bac:	bf00      	nop
 8000bae:	b002      	add	sp, #8
 8000bb0:	4770      	bx	lr
 8000bb2:	bf00      	nop
 8000bb4:	e000e100 	.word	0xe000e100
	...

08000bc0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000bc0:	b082      	sub	sp, #8
 8000bc2:	9001      	str	r0, [sp, #4]
 8000bc4:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8000bc6:	9b00      	ldr	r3, [sp, #0]
 8000bc8:	b2db      	uxtb	r3, r3
 8000bca:	4a11      	ldr	r2, [pc, #68]	@ (8000c10 <nvicEnableVector+0x50>)
 8000bcc:	011b      	lsls	r3, r3, #4
 8000bce:	b2d9      	uxtb	r1, r3
 8000bd0:	9b01      	ldr	r3, [sp, #4]
 8000bd2:	4413      	add	r3, r2
 8000bd4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8000bd8:	460a      	mov	r2, r1
 8000bda:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000bdc:	9b01      	ldr	r3, [sp, #4]
 8000bde:	f003 021f 	and.w	r2, r3, #31
 8000be2:	490b      	ldr	r1, [pc, #44]	@ (8000c10 <nvicEnableVector+0x50>)
 8000be4:	9b01      	ldr	r3, [sp, #4]
 8000be6:	095b      	lsrs	r3, r3, #5
 8000be8:	2001      	movs	r0, #1
 8000bea:	fa00 f202 	lsl.w	r2, r0, r2
 8000bee:	3360      	adds	r3, #96	@ 0x60
 8000bf0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000bf4:	9b01      	ldr	r3, [sp, #4]
 8000bf6:	f003 021f 	and.w	r2, r3, #31
 8000bfa:	4905      	ldr	r1, [pc, #20]	@ (8000c10 <nvicEnableVector+0x50>)
 8000bfc:	9b01      	ldr	r3, [sp, #4]
 8000bfe:	095b      	lsrs	r3, r3, #5
 8000c00:	2001      	movs	r0, #1
 8000c02:	fa00 f202 	lsl.w	r2, r0, r2
 8000c06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000c0a:	bf00      	nop
 8000c0c:	b002      	add	sp, #8
 8000c0e:	4770      	bx	lr
 8000c10:	e000e100 	.word	0xe000e100
	...

08000c20 <exti0_irq_init>:

static inline void exti0_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
 8000c20:	bf00      	nop
 8000c22:	4770      	bx	lr
	...

08000c30 <exti1_irq_init>:

static inline void exti1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
 8000c30:	bf00      	nop
 8000c32:	4770      	bx	lr
	...

08000c40 <exti2_irq_init>:

static inline void exti2_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
 8000c40:	bf00      	nop
 8000c42:	4770      	bx	lr
	...

08000c50 <exti3_irq_init>:

static inline void exti3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
 8000c50:	bf00      	nop
 8000c52:	4770      	bx	lr
	...

08000c60 <exti4_irq_init>:

static inline void exti4_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
 8000c60:	bf00      	nop
 8000c62:	4770      	bx	lr
	...

08000c70 <exti5_9_irq_init>:

static inline void exti5_9_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
 8000c70:	bf00      	nop
 8000c72:	4770      	bx	lr
	...

08000c80 <exti10_15_irq_init>:

static inline void exti10_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
 8000c80:	bf00      	nop
 8000c82:	4770      	bx	lr
	...

08000c90 <exti16_exti35_38_irq_init>:
#if defined(STM32_EXTI16_IS_USED) || defined(STM32_EXTI35_IS_USED) ||       \
    defined(STM32_EXTI36_IS_USED) || defined(STM32_EXTI37_IS_USED) ||       \
    defined(STM32_EXTI38_IS_USED)
  nvicEnableVector(STM32_EXTI1635_38_NUMBER, STM32_IRQ_EXTI1635_38_PRIORITY);
#endif
}
 8000c90:	bf00      	nop
 8000c92:	4770      	bx	lr
	...

08000ca0 <exti18_irq_init>:

static inline void exti18_irq_init(void) {
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
 8000ca0:	bf00      	nop
 8000ca2:	4770      	bx	lr
	...

08000cb0 <exti19_irq_init>:

static inline void exti19_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
 8000cb0:	bf00      	nop
 8000cb2:	4770      	bx	lr
	...

08000cc0 <exti21_22_irq_init>:

static inline void exti21_22_irq_init(void) {
#if defined(STM32_EXTI21_IS_USED) || defined(STM32_EXTI22_IS_USED)
  nvicEnableVector(STM32_EXTI21_22_NUMBER, STM32_IRQ_EXTI21_22_PRIORITY);
#endif
}
 8000cc0:	bf00      	nop
 8000cc2:	4770      	bx	lr
	...

08000cd0 <sdmmc1_irq_init>:

static inline void sdmmc1_irq_init(void) {
#if STM32_SDMMC1_IS_USED
  nvicEnableVector(STM32_SDMMC1_NUMBER, STM32_IRQ_SDMMC1_PRIORITY);
#endif
}
 8000cd0:	bf00      	nop
 8000cd2:	4770      	bx	lr
	...

08000ce0 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000ce0:	bf00      	nop
 8000ce2:	4770      	bx	lr
	...

08000cf0 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000cf0:	bf00      	nop
 8000cf2:	4770      	bx	lr
	...

08000d00 <usart3_irq_init>:

static inline void usart3_irq_init(void) {
#if defined(STM32_USART3_IS_USED)
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
#endif
}
 8000d00:	bf00      	nop
 8000d02:	4770      	bx	lr
	...

08000d10 <uart4_irq_init>:

static inline void uart4_irq_init(void) {
#if defined(STM32_UART4_IS_USED)
  nvicEnableVector(STM32_UART4_NUMBER, STM32_IRQ_UART4_PRIORITY);
#endif
}
 8000d10:	bf00      	nop
 8000d12:	4770      	bx	lr
	...

08000d20 <uart5_irq_init>:

static inline void uart5_irq_init(void) {
#if defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_IRQ_UART5_PRIORITY);
#endif
}
 8000d20:	bf00      	nop
 8000d22:	4770      	bx	lr
	...

08000d30 <lpuart1_irq_init>:

static inline void lpuart1_irq_init(void) {
#if defined(STM32_LPUART1_IS_USED)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_IRQ_LPUART1_PRIORITY);
#endif
}
 8000d30:	bf00      	nop
 8000d32:	4770      	bx	lr
	...

08000d40 <tim1_tim15_tim16_tim17_irq_init>:
#endif
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_CC_NUMBER,
                   STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8000d40:	bf00      	nop
 8000d42:	4770      	bx	lr
	...

08000d50 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8000d50:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8000d52:	2107      	movs	r1, #7
 8000d54:	201c      	movs	r0, #28
 8000d56:	f7ff ff33 	bl	8000bc0 <nvicEnableVector>
#endif
}
 8000d5a:	bf00      	nop
 8000d5c:	bd08      	pop	{r3, pc}
 8000d5e:	bf00      	nop

08000d60 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000d60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000d62:	f001 fdf5 	bl	8002950 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000d66:	f001 fa63 	bl	8002230 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000d6a:	f001 fe29 	bl	80029c0 <__dbg_check_leave_isr>
 8000d6e:	f004 f82f 	bl	8004dd0 <__port_irq_epilogue>
}
 8000d72:	bf00      	nop
 8000d74:	bd08      	pop	{r3, pc}
 8000d76:	bf00      	nop
	...

08000d80 <tim3_irq_init>:

static inline void tim3_irq_init(void) {
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
 8000d80:	bf00      	nop
 8000d82:	4770      	bx	lr
	...

08000d90 <tim4_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim4_irq_init(void) {
 8000d90:	b508      	push	{r3, lr}
#if defined(STM32_TIM4_IS_USED)
  nvicEnableVector(STM32_TIM4_NUMBER, STM32_IRQ_TIM4_PRIORITY);
 8000d92:	2107      	movs	r1, #7
 8000d94:	201e      	movs	r0, #30
 8000d96:	f7ff ff13 	bl	8000bc0 <nvicEnableVector>
#endif
}
 8000d9a:	bf00      	nop
 8000d9c:	bd08      	pop	{r3, pc}
 8000d9e:	bf00      	nop

08000da0 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8000da0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000da2:	f001 fdd5 	bl	8002950 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM4
  gpt_lld_serve_interrupt(&GPTD4);
 8000da6:	4804      	ldr	r0, [pc, #16]	@ (8000db8 <VectorB8+0x18>)
 8000da8:	f001 fb32 	bl	8002410 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM4
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000dac:	f001 fe08 	bl	80029c0 <__dbg_check_leave_isr>
 8000db0:	f004 f80e 	bl	8004dd0 <__port_irq_epilogue>
}
 8000db4:	bf00      	nop
 8000db6:	bd08      	pop	{r3, pc}
 8000db8:	200008b4 	.word	0x200008b4
 8000dbc:	00000000 	.word	0x00000000

08000dc0 <tim5_irq_init>:

static inline void tim5_irq_init(void) {
#if defined(STM32_TIM5_IS_USED)
  nvicEnableVector(STM32_TIM5_NUMBER, STM32_IRQ_TIM5_PRIORITY);
#endif
}
 8000dc0:	bf00      	nop
 8000dc2:	4770      	bx	lr
	...

08000dd0 <tim6_irq_init>:

static inline void tim6_irq_init(void) {
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
#endif
}
 8000dd0:	bf00      	nop
 8000dd2:	4770      	bx	lr
	...

08000de0 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 8000de0:	bf00      	nop
 8000de2:	4770      	bx	lr
	...

08000df0 <tim8_irq_init>:
static inline void tim8_irq_init(void) {
#if defined(STM32_TIM8_IS_USED)
  nvicEnableVector(STM32_TIM8_UP_NUMBER, STM32_IRQ_TIM8_UP_PRIORITY);
  nvicEnableVector(STM32_TIM8_CC_NUMBER, STM32_IRQ_TIM8_CC_PRIORITY);
#endif
}
 8000df0:	bf00      	nop
 8000df2:	4770      	bx	lr
	...

08000e00 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000e00:	b508      	push	{r3, lr}

  exti0_irq_init();
 8000e02:	f7ff ff0d 	bl	8000c20 <exti0_irq_init>
  exti1_irq_init();
 8000e06:	f7ff ff13 	bl	8000c30 <exti1_irq_init>
  exti2_irq_init();
 8000e0a:	f7ff ff19 	bl	8000c40 <exti2_irq_init>
  exti3_irq_init();
 8000e0e:	f7ff ff1f 	bl	8000c50 <exti3_irq_init>
  exti4_irq_init();
 8000e12:	f7ff ff25 	bl	8000c60 <exti4_irq_init>
  exti5_9_irq_init();
 8000e16:	f7ff ff2b 	bl	8000c70 <exti5_9_irq_init>
  exti10_15_irq_init();
 8000e1a:	f7ff ff31 	bl	8000c80 <exti10_15_irq_init>
  exti16_exti35_38_irq_init();
 8000e1e:	f7ff ff37 	bl	8000c90 <exti16_exti35_38_irq_init>
  exti18_irq_init();
 8000e22:	f7ff ff3d 	bl	8000ca0 <exti18_irq_init>
  exti19_irq_init();
 8000e26:	f7ff ff43 	bl	8000cb0 <exti19_irq_init>
  exti21_22_irq_init();
 8000e2a:	f7ff ff49 	bl	8000cc0 <exti21_22_irq_init>

  sdmmc1_irq_init();
 8000e2e:	f7ff ff4f 	bl	8000cd0 <sdmmc1_irq_init>

  tim1_tim15_tim16_tim17_irq_init();
 8000e32:	f7ff ff85 	bl	8000d40 <tim1_tim15_tim16_tim17_irq_init>
  tim2_irq_init();
 8000e36:	f7ff ff8b 	bl	8000d50 <tim2_irq_init>
  tim3_irq_init();
 8000e3a:	f7ff ffa1 	bl	8000d80 <tim3_irq_init>
  tim4_irq_init();
 8000e3e:	f7ff ffa7 	bl	8000d90 <tim4_irq_init>
  tim5_irq_init();
 8000e42:	f7ff ffbd 	bl	8000dc0 <tim5_irq_init>
  tim6_irq_init();
 8000e46:	f7ff ffc3 	bl	8000dd0 <tim6_irq_init>
  tim7_irq_init();
 8000e4a:	f7ff ffc9 	bl	8000de0 <tim7_irq_init>
  tim8_irq_init();
 8000e4e:	f7ff ffcf 	bl	8000df0 <tim8_irq_init>

  usart1_irq_init();
 8000e52:	f7ff ff45 	bl	8000ce0 <usart1_irq_init>
  usart2_irq_init();
 8000e56:	f7ff ff4b 	bl	8000cf0 <usart2_irq_init>
  usart3_irq_init();
 8000e5a:	f7ff ff51 	bl	8000d00 <usart3_irq_init>
  uart4_irq_init();
 8000e5e:	f7ff ff57 	bl	8000d10 <uart4_irq_init>
  uart5_irq_init();
 8000e62:	f7ff ff5d 	bl	8000d20 <uart5_irq_init>
  lpuart1_irq_init();
 8000e66:	f7ff ff63 	bl	8000d30 <lpuart1_irq_init>
}
 8000e6a:	bf00      	nop
 8000e6c:	bd08      	pop	{r3, pc}
 8000e6e:	bf00      	nop

08000e70 <lse_init>:
  while ((RCC->BDCR & (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) !=
         (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) {
  }
#endif
#endif
}
 8000e70:	bf00      	nop
 8000e72:	4770      	bx	lr
	...

08000e80 <lsi_init>:

__STATIC_INLINE void lsi_init(void) {

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= STM32_LSIPRE | RCC_CSR_LSION;
 8000e80:	4b09      	ldr	r3, [pc, #36]	@ (8000ea8 <lsi_init+0x28>)
 8000e82:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8000e86:	4a08      	ldr	r2, [pc, #32]	@ (8000ea8 <lsi_init+0x28>)
 8000e88:	f043 0301 	orr.w	r3, r3, #1
 8000e8c:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
  while ((RCC->BDCR & RCC_CSR_LSIRDY) == 0U) {
 8000e90:	bf00      	nop
 8000e92:	4b05      	ldr	r3, [pc, #20]	@ (8000ea8 <lsi_init+0x28>)
 8000e94:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000e98:	f003 0302 	and.w	r3, r3, #2
 8000e9c:	2b00      	cmp	r3, #0
 8000e9e:	d0f8      	beq.n	8000e92 <lsi_init+0x12>
  }
#endif
}
 8000ea0:	bf00      	nop
 8000ea2:	bf00      	nop
 8000ea4:	4770      	bx	lr
 8000ea6:	bf00      	nop
 8000ea8:	40021000 	.word	0x40021000
 8000eac:	00000000 	.word	0x00000000

08000eb0 <msi_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void msi_enable(void) {

  RCC->CR |= RCC_CR_MSION;
 8000eb0:	4b07      	ldr	r3, [pc, #28]	@ (8000ed0 <msi_enable+0x20>)
 8000eb2:	681b      	ldr	r3, [r3, #0]
 8000eb4:	4a06      	ldr	r2, [pc, #24]	@ (8000ed0 <msi_enable+0x20>)
 8000eb6:	f043 0301 	orr.w	r3, r3, #1
 8000eba:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000ebc:	bf00      	nop
 8000ebe:	4b04      	ldr	r3, [pc, #16]	@ (8000ed0 <msi_enable+0x20>)
 8000ec0:	681b      	ldr	r3, [r3, #0]
 8000ec2:	f003 0302 	and.w	r3, r3, #2
 8000ec6:	2b00      	cmp	r3, #0
 8000ec8:	d0f9      	beq.n	8000ebe <msi_enable+0xe>
    /* Wait until MSI is stable.*/
  }
}
 8000eca:	bf00      	nop
 8000ecc:	bf00      	nop
 8000ece:	4770      	bx	lr
 8000ed0:	40021000 	.word	0x40021000
	...

08000ee0 <msi_reset>:
__STATIC_INLINE void msi_disable(void) {

  RCC->CR &= ~RCC_CR_MSION;
}

__STATIC_INLINE void msi_reset(void) {
 8000ee0:	b508      	push	{r3, lr}

  /* Resetting MSI defaults.
     Note from RM0432: MSIRANGE can be modified when MSI is OFF (MSION=0)
     or when MSI is ready (MSIRDY=1). MSIRANGE must NOT be modified when
     MSI is ON and NOT ready (MSION=1 and MSIRDY=0).*/
  RCC->CR = (RCC->CR & ~RCC_CR_MSIRANGE_Msk) | RCC_CR_MSIRANGE_6;
 8000ee2:	4b0b      	ldr	r3, [pc, #44]	@ (8000f10 <msi_reset+0x30>)
 8000ee4:	681b      	ldr	r3, [r3, #0]
 8000ee6:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8000eea:	4a09      	ldr	r2, [pc, #36]	@ (8000f10 <msi_reset+0x30>)
 8000eec:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 8000ef0:	6013      	str	r3, [r2, #0]

  /* Making sure MSI is active and ready.*/
  msi_enable();
 8000ef2:	f7ff ffdd 	bl	8000eb0 <msi_enable>

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = RCC_CFGR_SW_MSI;
 8000ef6:	4b06      	ldr	r3, [pc, #24]	@ (8000f10 <msi_reset+0x30>)
 8000ef8:	2200      	movs	r2, #0
 8000efa:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI) {
 8000efc:	bf00      	nop
 8000efe:	4b04      	ldr	r3, [pc, #16]	@ (8000f10 <msi_reset+0x30>)
 8000f00:	689b      	ldr	r3, [r3, #8]
 8000f02:	f003 030c 	and.w	r3, r3, #12
 8000f06:	2b00      	cmp	r3, #0
 8000f08:	d1f9      	bne.n	8000efe <msi_reset+0x1e>
    /* Wait until MSI is selected.*/
  }
}
 8000f0a:	bf00      	nop
 8000f0c:	bf00      	nop
 8000f0e:	bd08      	pop	{r3, pc}
 8000f10:	40021000 	.word	0x40021000
	...

08000f20 <msi_init>:

__STATIC_INLINE void msi_init(void) {
 8000f20:	b082      	sub	sp, #8
  /* MSIRANGE can be set only when MSI is OFF or READY, it is ready after
     reset.*/
#if STM32_MSIPLL_ENABLED
  cr = STM32_MSIRANGE | RCC_CR_MSIPLLEN | RCC_CR_MSION;
#else
  cr = STM32_MSIRANGE | RCC_CR_MSION;
 8000f22:	2361      	movs	r3, #97	@ 0x61
 8000f24:	9301      	str	r3, [sp, #4]
#endif
  RCC->CR = cr;
 8000f26:	4a17      	ldr	r2, [pc, #92]	@ (8000f84 <msi_init+0x64>)
 8000f28:	9b01      	ldr	r3, [sp, #4]
 8000f2a:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000f2c:	bf00      	nop
 8000f2e:	4b15      	ldr	r3, [pc, #84]	@ (8000f84 <msi_init+0x64>)
 8000f30:	681b      	ldr	r3, [r3, #0]
 8000f32:	f003 0302 	and.w	r3, r3, #2
 8000f36:	2b00      	cmp	r3, #0
 8000f38:	d0f9      	beq.n	8000f2e <msi_init+0xe>
    /* Wait until MSI is stable.*/
  }

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0U;
 8000f3a:	4b12      	ldr	r3, [pc, #72]	@ (8000f84 <msi_init+0x64>)
 8000f3c:	2200      	movs	r2, #0
 8000f3e:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8000f40:	bf00      	nop
 8000f42:	4b10      	ldr	r3, [pc, #64]	@ (8000f84 <msi_init+0x64>)
 8000f44:	689b      	ldr	r3, [r3, #8]
 8000f46:	f003 030c 	and.w	r3, r3, #12
 8000f4a:	2b00      	cmp	r3, #0
 8000f4c:	d1f9      	bne.n	8000f42 <msi_init+0x22>
    ;                                       /* Wait until MSI is selected.  */

  /* Updating MSISRANGE value. MSISRANGE can be set only when MSIRGSEL is high.
     This range is used exiting the Standby mode until MSIRGSEL is set.*/
  cr      |= RCC_CR_MSIRGSEL;
 8000f4e:	9b01      	ldr	r3, [sp, #4]
 8000f50:	f043 0308 	orr.w	r3, r3, #8
 8000f54:	9301      	str	r3, [sp, #4]
  RCC->CR  = cr;
 8000f56:	4a0b      	ldr	r2, [pc, #44]	@ (8000f84 <msi_init+0x64>)
 8000f58:	9b01      	ldr	r3, [sp, #4]
 8000f5a:	6013      	str	r3, [r2, #0]

  csr      = RCC->CSR;
 8000f5c:	4b09      	ldr	r3, [pc, #36]	@ (8000f84 <msi_init+0x64>)
 8000f5e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8000f62:	9300      	str	r3, [sp, #0]
  csr     &= ~STM32_MSISRANGE_MASK;
 8000f64:	9b00      	ldr	r3, [sp, #0]
 8000f66:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8000f6a:	9300      	str	r3, [sp, #0]
  csr     |= STM32_MSISRANGE;
 8000f6c:	9b00      	ldr	r3, [sp, #0]
 8000f6e:	f443 63c0 	orr.w	r3, r3, #1536	@ 0x600
 8000f72:	9300      	str	r3, [sp, #0]
  RCC->CSR = csr;
 8000f74:	4a03      	ldr	r2, [pc, #12]	@ (8000f84 <msi_init+0x64>)
 8000f76:	9b00      	ldr	r3, [sp, #0]
 8000f78:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
}
 8000f7c:	bf00      	nop
 8000f7e:	b002      	add	sp, #8
 8000f80:	4770      	bx	lr
 8000f82:	bf00      	nop
 8000f84:	40021000 	.word	0x40021000
	...

08000f90 <hsi16_init>:

#if STM32_HSI16_ENABLED
  /* HSI activation.*/
  hsi16_enable();
#endif
}
 8000f90:	bf00      	nop
 8000f92:	4770      	bx	lr
	...

08000fa0 <hsi48_init>:

#if STM32_HSI48_ENABLED
  /* HSI activation.*/
  hsi48_enable();
#endif
}
 8000fa0:	bf00      	nop
 8000fa2:	4770      	bx	lr
	...

08000fb0 <hse_init>:
__STATIC_INLINE void hse_init(void) {

#if STM32_HSE_ENABLED
  hse_enable();
#endif
}
 8000fb0:	bf00      	nop
 8000fb2:	4770      	bx	lr
	...

08000fc0 <pll_not_locked>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE bool pll_not_locked(void) {

  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8000fc0:	4b05      	ldr	r3, [pc, #20]	@ (8000fd8 <pll_not_locked+0x18>)
 8000fc2:	681b      	ldr	r3, [r3, #0]
 8000fc4:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8000fc8:	2b00      	cmp	r3, #0
 8000fca:	bf0c      	ite	eq
 8000fcc:	2301      	moveq	r3, #1
 8000fce:	2300      	movne	r3, #0
 8000fd0:	b2db      	uxtb	r3, r3
}
 8000fd2:	4618      	mov	r0, r3
 8000fd4:	4770      	bx	lr
 8000fd6:	bf00      	nop
 8000fd8:	40021000 	.word	0x40021000
 8000fdc:	00000000 	.word	0x00000000

08000fe0 <pll_wait_lock>:

__STATIC_INLINE void pll_wait_lock(void) {
 8000fe0:	b508      	push	{r3, lr}

  while (pll_not_locked()) {
 8000fe2:	bf00      	nop
 8000fe4:	f7ff ffec 	bl	8000fc0 <pll_not_locked>
 8000fe8:	4603      	mov	r3, r0
 8000fea:	2b00      	cmp	r3, #0
 8000fec:	d1fa      	bne.n	8000fe4 <pll_wait_lock+0x4>
    /* Waiting for PLL lock.*/
  }
}
 8000fee:	bf00      	nop
 8000ff0:	bf00      	nop
 8000ff2:	bd08      	pop	{r3, pc}
	...

08001000 <pll_init>:

#endif /* STM32_RCC_HAS_PLL */

__STATIC_INLINE void pll_init(void) {
 8001000:	b508      	push	{r3, lr}

#if STM32_RCC_HAS_PLL
#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLPDIV | STM32_PLLR   |
 8001002:	4b06      	ldr	r3, [pc, #24]	@ (800101c <pll_init+0x1c>)
 8001004:	4a06      	ldr	r2, [pc, #24]	@ (8001020 <pll_init+0x20>)
 8001006:	60da      	str	r2, [r3, #12]
                 STM32_PLLREN  | STM32_PLLQ   |
                 STM32_PLLQEN  | STM32_PLLP   |
                 STM32_PLLPEN  | STM32_PLLN   |
                 STM32_PLLM    | STM32_PLLSRC;
  RCC->CR |= RCC_CR_PLLON;
 8001008:	4b04      	ldr	r3, [pc, #16]	@ (800101c <pll_init+0x1c>)
 800100a:	681b      	ldr	r3, [r3, #0]
 800100c:	4a03      	ldr	r2, [pc, #12]	@ (800101c <pll_init+0x1c>)
 800100e:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001012:	6013      	str	r3, [r2, #0]

  pll_wait_lock();
 8001014:	f7ff ffe4 	bl	8000fe0 <pll_wait_lock>
#endif
#endif
}
 8001018:	bf00      	nop
 800101a:	bd08      	pop	{r3, pc}
 800101c:	40021000 	.word	0x40021000
 8001020:	01203c01 	.word	0x01203c01
	...

08001030 <pllsai1_init>:
__STATIC_INLINE void pllsai1_init(void) {

#if STM32_RCC_HAS_PLLSAI1
#if STM32_ACTIVATE_PLLSAI1
  /* PLLSAI1 activation.*/
  RCC->PLLSAI1CFGR = STM32_PLLSAI1PDIV | STM32_PLLSAI1R   |
 8001030:	4b09      	ldr	r3, [pc, #36]	@ (8001058 <pllsai1_init+0x28>)
 8001032:	4a0a      	ldr	r2, [pc, #40]	@ (800105c <pllsai1_init+0x2c>)
 8001034:	611a      	str	r2, [r3, #16]
                     STM32_PLLSAI1REN  | STM32_PLLSAI1Q   |
                     STM32_PLLSAI1QEN  | STM32_PLLSAI1P   |
                     STM32_PLLSAI1PEN  | STM32_PLLSAI1N   |
                     STM32_PLLSAI1M;
  RCC->CR |= RCC_CR_PLLSAI1ON;
 8001036:	4b08      	ldr	r3, [pc, #32]	@ (8001058 <pllsai1_init+0x28>)
 8001038:	681b      	ldr	r3, [r3, #0]
 800103a:	4a07      	ldr	r2, [pc, #28]	@ (8001058 <pllsai1_init+0x28>)
 800103c:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8001040:	6013      	str	r3, [r2, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0U)
 8001042:	bf00      	nop
 8001044:	4b04      	ldr	r3, [pc, #16]	@ (8001058 <pllsai1_init+0x28>)
 8001046:	681b      	ldr	r3, [r3, #0]
 8001048:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800104c:	2b00      	cmp	r3, #0
 800104e:	d0f9      	beq.n	8001044 <pllsai1_init+0x14>
    ;
#endif
#endif
}
 8001050:	bf00      	nop
 8001052:	bf00      	nop
 8001054:	4770      	bx	lr
 8001056:	bf00      	nop
 8001058:	40021000 	.word	0x40021000
 800105c:	34503c00 	.word	0x34503c00

08001060 <pllsai2_init>:

  /* Waiting for PLL lock.*/
  pllsai2_wait_lock();
#endif
#endif
}
 8001060:	bf00      	nop
 8001062:	4770      	bx	lr
	...

08001070 <bd_init>:
/*===========================================================================*/

/**
 * @brief   Initializes the backup domain.
 */
__STATIC_INLINE void bd_init(void) {
 8001070:	b082      	sub	sp, #8
  uint32_t bdcr;

  /* Current settings.*/
  bdcr = RCC->BDCR;
 8001072:	4b09      	ldr	r3, [pc, #36]	@ (8001098 <bd_init+0x28>)
 8001074:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8001078:	9301      	str	r3, [sp, #4]
    bdcr |= RCC_BDCR_RTCEN;
  }
#endif

  /* Selectors.*/
  bdcr &= ~(STM32_RTCSEL_MASK | STM32_LSCOSEL_MASK);
 800107a:	9b01      	ldr	r3, [sp, #4]
 800107c:	f023 2303 	bic.w	r3, r3, #50332416	@ 0x3000300
 8001080:	9301      	str	r3, [sp, #4]
  bdcr |= STM32_RTCSEL | STM32_LSCOSEL;
 8001082:	9b01      	ldr	r3, [sp, #4]
 8001084:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001088:	9301      	str	r3, [sp, #4]

  /* Final settings.*/
  RCC->BDCR = bdcr;
 800108a:	4a03      	ldr	r2, [pc, #12]	@ (8001098 <bd_init+0x28>)
 800108c:	9b01      	ldr	r3, [sp, #4]
 800108e:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
}
 8001092:	bf00      	nop
 8001094:	b002      	add	sp, #8
 8001096:	4770      	bx	lr
 8001098:	40021000 	.word	0x40021000
 800109c:	00000000 	.word	0x00000000

080010a0 <bd_reset>:
 *          of the whole BKP domain.
 */
__STATIC_INLINE void bd_reset(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80010a0:	4b09      	ldr	r3, [pc, #36]	@ (80010c8 <bd_reset+0x28>)
 80010a2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80010a6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 80010aa:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80010ae:	d008      	beq.n	80010c2 <bd_reset+0x22>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80010b0:	4b05      	ldr	r3, [pc, #20]	@ (80010c8 <bd_reset+0x28>)
 80010b2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 80010b6:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    RCC->BDCR = 0U;
 80010ba:	4b03      	ldr	r3, [pc, #12]	@ (80010c8 <bd_reset+0x28>)
 80010bc:	2200      	movs	r2, #0
 80010be:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  }
}
 80010c2:	bf00      	nop
 80010c4:	4770      	bx	lr
 80010c6:	bf00      	nop
 80010c8:	40021000 	.word	0x40021000
 80010cc:	00000000 	.word	0x00000000

080010d0 <flash_set_acr>:
/**
 * @brief   Safe setting of flash ACR register.
 *
 * @param[in] acr       value for the ACR register
 */
__STATIC_INLINE void flash_set_acr(uint32_t acr) {
 80010d0:	b082      	sub	sp, #8
 80010d2:	9001      	str	r0, [sp, #4]

  FLASH->ACR = acr;
 80010d4:	4a07      	ldr	r2, [pc, #28]	@ (80010f4 <flash_set_acr+0x24>)
 80010d6:	9b01      	ldr	r3, [sp, #4]
 80010d8:	6013      	str	r3, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) != (acr & FLASH_ACR_LATENCY_Msk)) {
 80010da:	bf00      	nop
 80010dc:	4b05      	ldr	r3, [pc, #20]	@ (80010f4 <flash_set_acr+0x24>)
 80010de:	681a      	ldr	r2, [r3, #0]
 80010e0:	9b01      	ldr	r3, [sp, #4]
 80010e2:	4053      	eors	r3, r2
 80010e4:	f003 030f 	and.w	r3, r3, #15
 80010e8:	2b00      	cmp	r3, #0
 80010ea:	d1f7      	bne.n	80010dc <flash_set_acr+0xc>
    /* Waiting for flash wait states setup.*/
  }
}
 80010ec:	bf00      	nop
 80010ee:	bf00      	nop
 80010f0:	b002      	add	sp, #8
 80010f2:	4770      	bx	lr
 80010f4:	40022000 	.word	0x40022000
	...

08001100 <hal_lld_set_static_pwr>:
 * @note    CR1, CR2 and CR5 are not initialized inside this function.
 */
__STATIC_INLINE void hal_lld_set_static_pwr(void) {

  /* PWR clock enabled.*/
  rccEnablePWRInterface(false);
 8001100:	4b26      	ldr	r3, [pc, #152]	@ (800119c <hal_lld_set_static_pwr+0x9c>)
 8001102:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8001104:	4a25      	ldr	r2, [pc, #148]	@ (800119c <hal_lld_set_static_pwr+0x9c>)
 8001106:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800110a:	6593      	str	r3, [r2, #88]	@ 0x58
 800110c:	4b23      	ldr	r3, [pc, #140]	@ (800119c <hal_lld_set_static_pwr+0x9c>)
 800110e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8001110:	4a22      	ldr	r2, [pc, #136]	@ (800119c <hal_lld_set_static_pwr+0x9c>)
 8001112:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8001116:	6793      	str	r3, [r2, #120]	@ 0x78
 8001118:	4b20      	ldr	r3, [pc, #128]	@ (800119c <hal_lld_set_static_pwr+0x9c>)
 800111a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78

  /* Static PWR configurations.*/
  PWR->CR3   = STM32_PWR_CR3;
 800111c:	4b20      	ldr	r3, [pc, #128]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 800111e:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8001122:	609a      	str	r2, [r3, #8]
  PWR->CR4   = STM32_PWR_CR4;
 8001124:	4b1e      	ldr	r3, [pc, #120]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001126:	2200      	movs	r2, #0
 8001128:	60da      	str	r2, [r3, #12]
  PWR->PUCRA = STM32_PWR_PUCRA;
 800112a:	4b1d      	ldr	r3, [pc, #116]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 800112c:	2200      	movs	r2, #0
 800112e:	621a      	str	r2, [r3, #32]
  PWR->PDCRA = STM32_PWR_PDCRA;
 8001130:	4b1b      	ldr	r3, [pc, #108]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001132:	2200      	movs	r2, #0
 8001134:	625a      	str	r2, [r3, #36]	@ 0x24
  PWR->PUCRB = STM32_PWR_PUCRB;
 8001136:	4b1a      	ldr	r3, [pc, #104]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001138:	2200      	movs	r2, #0
 800113a:	629a      	str	r2, [r3, #40]	@ 0x28
  PWR->PDCRB = STM32_PWR_PDCRB;
 800113c:	4b18      	ldr	r3, [pc, #96]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 800113e:	2200      	movs	r2, #0
 8001140:	62da      	str	r2, [r3, #44]	@ 0x2c
  PWR->PUCRC = STM32_PWR_PUCRC;
 8001142:	4b17      	ldr	r3, [pc, #92]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001144:	2200      	movs	r2, #0
 8001146:	631a      	str	r2, [r3, #48]	@ 0x30
  PWR->PDCRC = STM32_PWR_PDCRC;
 8001148:	4b15      	ldr	r3, [pc, #84]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 800114a:	2200      	movs	r2, #0
 800114c:	635a      	str	r2, [r3, #52]	@ 0x34
#if STM32_HAS_GPIOD
  PWR->PUCRD = STM32_PWR_PUCRD;
 800114e:	4b14      	ldr	r3, [pc, #80]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001150:	2200      	movs	r2, #0
 8001152:	639a      	str	r2, [r3, #56]	@ 0x38
  PWR->PDCRD = STM32_PWR_PDCRD;
 8001154:	4b12      	ldr	r3, [pc, #72]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001156:	2200      	movs	r2, #0
 8001158:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if STM32_HAS_GPIOE
  PWR->PUCRE = STM32_PWR_PUCRE;
 800115a:	4b11      	ldr	r3, [pc, #68]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 800115c:	2200      	movs	r2, #0
 800115e:	641a      	str	r2, [r3, #64]	@ 0x40
  PWR->PDCRE = STM32_PWR_PDCRE;
 8001160:	4b0f      	ldr	r3, [pc, #60]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001162:	2200      	movs	r2, #0
 8001164:	645a      	str	r2, [r3, #68]	@ 0x44
#endif
#if STM32_HAS_GPIOF
  PWR->PUCRF = STM32_PWR_PUCRF;
 8001166:	4b0e      	ldr	r3, [pc, #56]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001168:	2200      	movs	r2, #0
 800116a:	649a      	str	r2, [r3, #72]	@ 0x48
  PWR->PDCRF = STM32_PWR_PDCRF;
 800116c:	4b0c      	ldr	r3, [pc, #48]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 800116e:	2200      	movs	r2, #0
 8001170:	64da      	str	r2, [r3, #76]	@ 0x4c
#endif
#if STM32_HAS_GPIOG
  PWR->PUCRG = STM32_PWR_PUCRG;
 8001172:	4b0b      	ldr	r3, [pc, #44]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001174:	2200      	movs	r2, #0
 8001176:	651a      	str	r2, [r3, #80]	@ 0x50
  PWR->PDCRG = STM32_PWR_PDCRG;
 8001178:	4b09      	ldr	r3, [pc, #36]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 800117a:	2200      	movs	r2, #0
 800117c:	655a      	str	r2, [r3, #84]	@ 0x54
#endif
#if STM32_HAS_GPIOH
  PWR->PUCRH = STM32_PWR_PUCRH;
 800117e:	4b08      	ldr	r3, [pc, #32]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001180:	2200      	movs	r2, #0
 8001182:	659a      	str	r2, [r3, #88]	@ 0x58
  PWR->PDCRH = STM32_PWR_PDCRH;
 8001184:	4b06      	ldr	r3, [pc, #24]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001186:	2200      	movs	r2, #0
 8001188:	65da      	str	r2, [r3, #92]	@ 0x5c
#endif
#if STM32_HAS_GPIOI
  PWR->PUCRI = STM32_PWR_PUCRI;
 800118a:	4b05      	ldr	r3, [pc, #20]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 800118c:	2200      	movs	r2, #0
 800118e:	661a      	str	r2, [r3, #96]	@ 0x60
  PWR->PDCRI = STM32_PWR_PDCRI;
 8001190:	4b03      	ldr	r3, [pc, #12]	@ (80011a0 <hal_lld_set_static_pwr+0xa0>)
 8001192:	2200      	movs	r2, #0
 8001194:	665a      	str	r2, [r3, #100]	@ 0x64
#endif
}
 8001196:	bf00      	nop
 8001198:	4770      	bx	lr
 800119a:	bf00      	nop
 800119c:	40021000 	.word	0x40021000
 80011a0:	40007000 	.word	0x40007000
	...

080011b0 <hal_lld_set_static_clocks>:

/**
 * @brief   Initializes static muxes and dividers.
 */
__STATIC_INLINE void hal_lld_set_static_clocks(void) {
 80011b0:	b082      	sub	sp, #8
  uint32_t ccipr;

  /* Clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 80011b2:	4b09      	ldr	r3, [pc, #36]	@ (80011d8 <hal_lld_set_static_clocks+0x28>)
 80011b4:	2200      	movs	r2, #0
 80011b6:	609a      	str	r2, [r3, #8]
              STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;

  /* CCIPR register initialization, note, must take care of the _OFF
     pseudo settings.*/
  ccipr =                                      STM32_ADCSEL    |
 80011b8:	4b08      	ldr	r3, [pc, #32]	@ (80011dc <hal_lld_set_static_clocks+0x2c>)
 80011ba:	9301      	str	r3, [sp, #4]
          STM32_CLK48SEL   | STM32_LPTIM2SEL | STM32_LPTIM1SEL |
          STM32_I2C3SEL    | STM32_I2C2SEL   | STM32_I2C1SEL   |
          STM32_LPUART1SEL | STM32_UART5SEL  | STM32_UART4SEL  |
          STM32_USART3SEL  | STM32_USART2SEL | STM32_USART1SEL;
  RCC->CCIPR = ccipr;
 80011bc:	4a06      	ldr	r2, [pc, #24]	@ (80011d8 <hal_lld_set_static_clocks+0x28>)
 80011be:	9b01      	ldr	r3, [sp, #4]
 80011c0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* CCIPR2 register initialization, note, must take care of the _OFF
     pseudo settings.*/
  ccipr = STM32_OSPISEL    | STM32_PLLSAI2DIVR |
 80011c4:	4b06      	ldr	r3, [pc, #24]	@ (80011e0 <hal_lld_set_static_clocks+0x30>)
 80011c6:	9301      	str	r3, [sp, #4]
  ccipr |= STM32_SAI2SEL;
#endif
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
  ccipr |= STM32_SAI1SEL;
#endif
  RCC->CCIPR2 = ccipr;
 80011c8:	4a03      	ldr	r2, [pc, #12]	@ (80011d8 <hal_lld_set_static_clocks+0x28>)
 80011ca:	9b01      	ldr	r3, [sp, #4]
 80011cc:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
}
 80011d0:	bf00      	nop
 80011d2:	b002      	add	sp, #8
 80011d4:	4770      	bx	lr
 80011d6:	bf00      	nop
 80011d8:	40021000 	.word	0x40021000
 80011dc:	34015555 	.word	0x34015555
 80011e0:	00030001 	.word	0x00030001
	...

080011f0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80011f0:	b508      	push	{r3, lr}

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80011f2:	f000 fd5d 	bl	8001cb0 <dmaInit>
#endif

  /* NVIC initialization.*/
  nvicInit();
 80011f6:	f7ff fcbb 	bl	8000b70 <nvicInit>

  /* IRQ subsystem initialization.*/
  irqInit();
 80011fa:	f7ff fe01 	bl	8000e00 <irqInit>
}
 80011fe:	bf00      	nop
 8001200:	bd08      	pop	{r3, pc}
 8001202:	bf00      	nop
	...

08001210 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8001210:	b508      	push	{r3, lr}

#if !STM32_NO_INIT
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~0);
 8001212:	4b57      	ldr	r3, [pc, #348]	@ (8001370 <stm32_clock_init+0x160>)
 8001214:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001216:	4b56      	ldr	r3, [pc, #344]	@ (8001370 <stm32_clock_init+0x160>)
 8001218:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800121c:	629a      	str	r2, [r3, #40]	@ 0x28
 800121e:	4b54      	ldr	r3, [pc, #336]	@ (8001370 <stm32_clock_init+0x160>)
 8001220:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001222:	4b53      	ldr	r3, [pc, #332]	@ (8001370 <stm32_clock_init+0x160>)
 8001224:	2200      	movs	r2, #0
 8001226:	629a      	str	r2, [r3, #40]	@ 0x28
 8001228:	4b51      	ldr	r3, [pc, #324]	@ (8001370 <stm32_clock_init+0x160>)
 800122a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 800122c:	4b50      	ldr	r3, [pc, #320]	@ (8001370 <stm32_clock_init+0x160>)
 800122e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001230:	4a4f      	ldr	r2, [pc, #316]	@ (8001370 <stm32_clock_init+0x160>)
 8001232:	ea6f 53c3 	mvn.w	r3, r3, lsl #23
 8001236:	ea6f 53d3 	mvn.w	r3, r3, lsr #23
 800123a:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800123c:	4b4c      	ldr	r3, [pc, #304]	@ (8001370 <stm32_clock_init+0x160>)
 800123e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001240:	4a4b      	ldr	r2, [pc, #300]	@ (8001370 <stm32_clock_init+0x160>)
 8001242:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001246:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001248:	4b49      	ldr	r3, [pc, #292]	@ (8001370 <stm32_clock_init+0x160>)
 800124a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccResetAHB3(~0);
 800124c:	4b48      	ldr	r3, [pc, #288]	@ (8001370 <stm32_clock_init+0x160>)
 800124e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001250:	4b47      	ldr	r3, [pc, #284]	@ (8001370 <stm32_clock_init+0x160>)
 8001252:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001256:	631a      	str	r2, [r3, #48]	@ 0x30
 8001258:	4b45      	ldr	r3, [pc, #276]	@ (8001370 <stm32_clock_init+0x160>)
 800125a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800125c:	4b44      	ldr	r3, [pc, #272]	@ (8001370 <stm32_clock_init+0x160>)
 800125e:	2200      	movs	r2, #0
 8001260:	631a      	str	r2, [r3, #48]	@ 0x30
 8001262:	4b43      	ldr	r3, [pc, #268]	@ (8001370 <stm32_clock_init+0x160>)
 8001264:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
  rccResetAPB1R1(~0);
 8001266:	4b42      	ldr	r3, [pc, #264]	@ (8001370 <stm32_clock_init+0x160>)
 8001268:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800126a:	4b41      	ldr	r3, [pc, #260]	@ (8001370 <stm32_clock_init+0x160>)
 800126c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001270:	639a      	str	r2, [r3, #56]	@ 0x38
 8001272:	4b3f      	ldr	r3, [pc, #252]	@ (8001370 <stm32_clock_init+0x160>)
 8001274:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001276:	4b3e      	ldr	r3, [pc, #248]	@ (8001370 <stm32_clock_init+0x160>)
 8001278:	2200      	movs	r2, #0
 800127a:	639a      	str	r2, [r3, #56]	@ 0x38
 800127c:	4b3c      	ldr	r3, [pc, #240]	@ (8001370 <stm32_clock_init+0x160>)
 800127e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
  rccResetAPB1R2(~0);
 8001280:	4b3b      	ldr	r3, [pc, #236]	@ (8001370 <stm32_clock_init+0x160>)
 8001282:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001284:	4b3a      	ldr	r3, [pc, #232]	@ (8001370 <stm32_clock_init+0x160>)
 8001286:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800128a:	63da      	str	r2, [r3, #60]	@ 0x3c
 800128c:	4b38      	ldr	r3, [pc, #224]	@ (8001370 <stm32_clock_init+0x160>)
 800128e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001290:	4b37      	ldr	r3, [pc, #220]	@ (8001370 <stm32_clock_init+0x160>)
 8001292:	2200      	movs	r2, #0
 8001294:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001296:	4b36      	ldr	r3, [pc, #216]	@ (8001370 <stm32_clock_init+0x160>)
 8001298:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  rccResetAPB2(~0);
 800129a:	4b35      	ldr	r3, [pc, #212]	@ (8001370 <stm32_clock_init+0x160>)
 800129c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800129e:	4b34      	ldr	r3, [pc, #208]	@ (8001370 <stm32_clock_init+0x160>)
 80012a0:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80012a4:	641a      	str	r2, [r3, #64]	@ 0x40
 80012a6:	4b32      	ldr	r3, [pc, #200]	@ (8001370 <stm32_clock_init+0x160>)
 80012a8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80012aa:	4b31      	ldr	r3, [pc, #196]	@ (8001370 <stm32_clock_init+0x160>)
 80012ac:	2200      	movs	r2, #0
 80012ae:	641a      	str	r2, [r3, #64]	@ 0x40
 80012b0:	4b2f      	ldr	r3, [pc, #188]	@ (8001370 <stm32_clock_init+0x160>)
 80012b2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40

  /* Flash setup for selected MSI speed setting.*/
  flash_set_acr(FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 80012b4:	f44f 60e0 	mov.w	r0, #1792	@ 0x700
 80012b8:	f7ff ff0a 	bl	80010d0 <flash_set_acr>
                STM32_MSI_FLASHBITS);

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, false);
 80012bc:	4b2c      	ldr	r3, [pc, #176]	@ (8001370 <stm32_clock_init+0x160>)
 80012be:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80012c0:	4a2b      	ldr	r2, [pc, #172]	@ (8001370 <stm32_clock_init+0x160>)
 80012c2:	f043 0301 	orr.w	r3, r3, #1
 80012c6:	6613      	str	r3, [r2, #96]	@ 0x60
 80012c8:	4b29      	ldr	r3, [pc, #164]	@ (8001370 <stm32_clock_init+0x160>)
 80012ca:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 80012ce:	4a28      	ldr	r2, [pc, #160]	@ (8001370 <stm32_clock_init+0x160>)
 80012d0:	f023 0301 	bic.w	r3, r3, #1
 80012d4:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 80012d8:	4b25      	ldr	r3, [pc, #148]	@ (8001370 <stm32_clock_init+0x160>)
 80012da:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
#if (HAL_USE_RTC == TRUE) && defined(RCC_APB1ENR1_RTCAPBEN)
  rccEnableAPB1R1(RCC_APB1ENR1_RTCAPBEN, true)
#endif

  /* Static PWR configurations.*/
  hal_lld_set_static_pwr();
 80012de:	f7ff ff0f 	bl	8001100 <hal_lld_set_static_pwr>

  /* Additional PWR configurations.*/
  PWR->CR2  = STM32_PWR_CR2;
 80012e2:	4b24      	ldr	r3, [pc, #144]	@ (8001374 <stm32_clock_init+0x164>)
 80012e4:	f44f 62c0 	mov.w	r2, #1536	@ 0x600
 80012e8:	605a      	str	r2, [r3, #4]
  PWR->CR5  = STM32_CR5BITS;
 80012ea:	4b22      	ldr	r3, [pc, #136]	@ (8001374 <stm32_clock_init+0x164>)
 80012ec:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80012f0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  /* Core voltage setup, backup domain access enabled and left open.*/
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 80012f4:	4b1f      	ldr	r3, [pc, #124]	@ (8001374 <stm32_clock_init+0x164>)
 80012f6:	f44f 7240 	mov.w	r2, #768	@ 0x300
 80012fa:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 80012fc:	bf00      	nop
 80012fe:	4b1d      	ldr	r3, [pc, #116]	@ (8001374 <stm32_clock_init+0x164>)
 8001300:	695b      	ldr	r3, [r3, #20]
 8001302:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8001306:	2b00      	cmp	r3, #0
 8001308:	d1f9      	bne.n	80012fe <stm32_clock_init+0xee>
    ;                                       /* stable.                      */

  /* MSI clock reset.*/
  msi_reset();
 800130a:	f7ff fde9 	bl	8000ee0 <msi_reset>

  /* Backup domain reset.*/
  bd_reset();
 800130e:	f7ff fec7 	bl	80010a0 <bd_reset>

  /* Clocks setup.*/
  lse_init();
 8001312:	f7ff fdad 	bl	8000e70 <lse_init>
  lsi_init();
 8001316:	f7ff fdb3 	bl	8000e80 <lsi_init>
  msi_init();
 800131a:	f7ff fe01 	bl	8000f20 <msi_init>
  hsi16_init();
 800131e:	f7ff fe37 	bl	8000f90 <hsi16_init>
  hsi48_init();
 8001322:	f7ff fe3d 	bl	8000fa0 <hsi48_init>
  hse_init();
 8001326:	f7ff fe43 	bl	8000fb0 <hse_init>

  /* Backup domain initializations.*/
  bd_init();
 800132a:	f7ff fea1 	bl	8001070 <bd_init>

  /* PLLs activation, if required.*/
  pll_init();
 800132e:	f7ff fe67 	bl	8001000 <pll_init>
  pllsai1_init();
 8001332:	f7ff fe7d 	bl	8001030 <pllsai1_init>
  pllsai2_init();
 8001336:	f7ff fe93 	bl	8001060 <pllsai2_init>

  /* Static clocks setup.*/
  hal_lld_set_static_clocks();
 800133a:	f7ff ff39 	bl	80011b0 <hal_lld_set_static_clocks>

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS) {
    flash_set_acr((FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS);
 800133e:	4b0e      	ldr	r3, [pc, #56]	@ (8001378 <stm32_clock_init+0x168>)
 8001340:	681b      	ldr	r3, [r3, #0]
 8001342:	f023 030f 	bic.w	r3, r3, #15
 8001346:	f043 0305 	orr.w	r3, r3, #5
 800134a:	4618      	mov	r0, r3
 800134c:	f7ff fec0 	bl	80010d0 <flash_set_acr>
  }

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001350:	4b07      	ldr	r3, [pc, #28]	@ (8001370 <stm32_clock_init+0x160>)
 8001352:	689b      	ldr	r3, [r3, #8]
 8001354:	4a06      	ldr	r2, [pc, #24]	@ (8001370 <stm32_clock_init+0x160>)
 8001356:	f043 0303 	orr.w	r3, r3, #3
 800135a:	6093      	str	r3, [r2, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800135c:	bf00      	nop
 800135e:	4b04      	ldr	r3, [pc, #16]	@ (8001370 <stm32_clock_init+0x160>)
 8001360:	689b      	ldr	r3, [r3, #8]
 8001362:	f003 030c 	and.w	r3, r3, #12
 8001366:	2b0c      	cmp	r3, #12
 8001368:	d1f9      	bne.n	800135e <stm32_clock_init+0x14e>
  /* Reduce the flash WS's for SYSCLK source if they are less than MSI WSs */
  if (STM32_FLASHBITS < STM32_MSI_FLASHBITS) {
    flash_set_acr((FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS);
  }
#endif /* STM32_NO_INIT */
}
 800136a:	bf00      	nop
 800136c:	bf00      	nop
 800136e:	bd08      	pop	{r3, pc}
 8001370:	40021000 	.word	0x40021000
 8001374:	40007000 	.word	0x40007000
 8001378:	40022000 	.word	0x40022000
 800137c:	00000000 	.word	0x00000000

08001380 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001380:	b500      	push	{lr}
 8001382:	b083      	sub	sp, #12
 8001384:	2330      	movs	r3, #48	@ 0x30
 8001386:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001388:	9b01      	ldr	r3, [sp, #4]
 800138a:	f383 8811 	msr	BASEPRI, r3
}
 800138e:	bf00      	nop
}
 8001390:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 8001392:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 8001394:	f001 fa8c 	bl	80028b0 <__dbg_check_lock_from_isr>
}
 8001398:	bf00      	nop
 800139a:	b003      	add	sp, #12
 800139c:	f85d fb04 	ldr.w	pc, [sp], #4

080013a0 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80013a0:	b500      	push	{lr}
 80013a2:	b083      	sub	sp, #12

  __dbg_check_unlock_from_isr();
 80013a4:	f001 faac 	bl	8002900 <__dbg_check_unlock_from_isr>
 80013a8:	2300      	movs	r3, #0
 80013aa:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80013ac:	9b01      	ldr	r3, [sp, #4]
 80013ae:	f383 8811 	msr	BASEPRI, r3
}
 80013b2:	bf00      	nop
}
 80013b4:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 80013b6:	bf00      	nop
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 80013b8:	bf00      	nop
 80013ba:	b003      	add	sp, #12
 80013bc:	f85d fb04 	ldr.w	pc, [sp], #4

080013c0 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 80013c0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80013c2:	f7ff ffdd 	bl	8001380 <chSysLockFromISR.lto_priv.0>
}
 80013c6:	bf00      	nop
 80013c8:	bd08      	pop	{r3, pc}
 80013ca:	bf00      	nop
 80013cc:	0000      	movs	r0, r0
	...

080013d0 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 80013d0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80013d2:	f7ff ffe5 	bl	80013a0 <chSysUnlockFromISR.lto_priv.0>
}
 80013d6:	bf00      	nop
 80013d8:	bd08      	pop	{r3, pc}
 80013da:	bf00      	nop
 80013dc:	0000      	movs	r0, r0
	...

080013e0 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 80013e0:	b500      	push	{lr}
 80013e2:	b083      	sub	sp, #12
 80013e4:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 80013e6:	9801      	ldr	r0, [sp, #4]
 80013e8:	f001 f9e2 	bl	80027b0 <chSysPolledDelayX>
}
 80013ec:	bf00      	nop
 80013ee:	b003      	add	sp, #12
 80013f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001400 <osalThreadResumeI.lto_priv.1>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001400:	b500      	push	{lr}
 8001402:	b083      	sub	sp, #12
 8001404:	9001      	str	r0, [sp, #4]
 8001406:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8001408:	9900      	ldr	r1, [sp, #0]
 800140a:	9801      	ldr	r0, [sp, #4]
 800140c:	f002 fdf0 	bl	8003ff0 <chThdResumeI>
}
 8001410:	bf00      	nop
 8001412:	b003      	add	sp, #12
 8001414:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001420 <adc_lld_vreg_on>:
/**
 * @brief   Enables the ADC voltage regulator.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {
 8001420:	b500      	push	{lr}
 8001422:	b083      	sub	sp, #12
 8001424:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR = 0;   /* See RM.*/
 8001426:	9b01      	ldr	r3, [sp, #4]
 8001428:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800142a:	2200      	movs	r2, #0
 800142c:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN;
 800142e:	9b01      	ldr	r3, [sp, #4]
 8001430:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001432:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8001436:	609a      	str	r2, [r3, #8]
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR = STM32_ADC_CR_ADVREGEN;
#endif
  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 8001438:	f44f 6016 	mov.w	r0, #2400	@ 0x960
 800143c:	f7ff ffd0 	bl	80013e0 <osalSysPolledDelayX>
}
 8001440:	bf00      	nop
 8001442:	b003      	add	sp, #12
 8001444:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001450 <adc_lld_calibrate>:
/**
 * @brief   Calibrates an ADC unit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_calibrate(ADCDriver *adcp) {
 8001450:	b500      	push	{lr}
 8001452:	b083      	sub	sp, #12
 8001454:	9001      	str	r0, [sp, #4]

  osalDbgAssert(adcp->adcm->CR == STM32_ADC_CR_ADVREGEN, "invalid register state");
 8001456:	9b01      	ldr	r3, [sp, #4]
 8001458:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800145a:	689b      	ldr	r3, [r3, #8]
 800145c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8001460:	bf14      	ite	ne
 8001462:	2301      	movne	r3, #1
 8001464:	2300      	moveq	r3, #0
 8001466:	b2db      	uxtb	r3, r3
 8001468:	2b00      	cmp	r3, #0
 800146a:	d002      	beq.n	8001472 <adc_lld_calibrate+0x22>
 800146c:	4817      	ldr	r0, [pc, #92]	@ (80014cc <adc_lld_calibrate+0x7c>)
 800146e:	f001 f947 	bl	8002700 <chSysHalt>

  /* Differential calibration for master ADC.*/
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCALDIF;
 8001472:	9b01      	ldr	r3, [sp, #4]
 8001474:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001476:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 800147a:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCALDIF | ADC_CR_ADCAL;
 800147c:	9b01      	ldr	r3, [sp, #4]
 800147e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001480:	f04f 4250 	mov.w	r2, #3489660928	@ 0xd0000000
 8001484:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 8001486:	bf00      	nop
 8001488:	9b01      	ldr	r3, [sp, #4]
 800148a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800148c:	689b      	ldr	r3, [r3, #8]
 800148e:	2b00      	cmp	r3, #0
 8001490:	dbfa      	blt.n	8001488 <adc_lld_calibrate+0x38>
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 8001492:	f44f 6016 	mov.w	r0, #2400	@ 0x960
 8001496:	f7ff ffa3 	bl	80013e0 <osalSysPolledDelayX>

  /* Single-ended calibration for master ADC.*/
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN;
 800149a:	9b01      	ldr	r3, [sp, #4]
 800149c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800149e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80014a2:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCAL;
 80014a4:	9b01      	ldr	r3, [sp, #4]
 80014a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014a8:	f04f 4210 	mov.w	r2, #2415919104	@ 0x90000000
 80014ac:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 80014ae:	bf00      	nop
 80014b0:	9b01      	ldr	r3, [sp, #4]
 80014b2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014b4:	689b      	ldr	r3, [r3, #8]
 80014b6:	2b00      	cmp	r3, #0
 80014b8:	dbfa      	blt.n	80014b0 <adc_lld_calibrate+0x60>
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 80014ba:	f44f 6016 	mov.w	r0, #2400	@ 0x960
 80014be:	f7ff ff8f 	bl	80013e0 <osalSysPolledDelayX>
  while ((adcp->adcs->CR & ADC_CR_ADCAL) != 0)
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
#endif
}
 80014c2:	bf00      	nop
 80014c4:	b003      	add	sp, #12
 80014c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80014ca:	bf00      	nop
 80014cc:	08005158 	.word	0x08005158

080014d0 <adc_lld_analog_on>:
/**
 * @brief   Enables the ADC analog circuit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_analog_on(ADCDriver *adcp) {
 80014d0:	b082      	sub	sp, #8
 80014d2:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR |= ADC_CR_ADEN;
 80014d4:	9b01      	ldr	r3, [sp, #4]
 80014d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014d8:	689a      	ldr	r2, [r3, #8]
 80014da:	9b01      	ldr	r3, [sp, #4]
 80014dc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014de:	f042 0201 	orr.w	r2, r2, #1
 80014e2:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRDY) == 0)
 80014e4:	bf00      	nop
 80014e6:	9b01      	ldr	r3, [sp, #4]
 80014e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014ea:	681b      	ldr	r3, [r3, #0]
 80014ec:	f003 0301 	and.w	r3, r3, #1
 80014f0:	2b00      	cmp	r3, #0
 80014f2:	d0f8      	beq.n	80014e6 <adc_lld_analog_on+0x16>
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR |= ADC_CR_ADEN;
  while ((adcp->adcs->ISR & ADC_ISR_ADRDY) == 0)
    ;
#endif
}
 80014f4:	bf00      	nop
 80014f6:	bf00      	nop
 80014f8:	b002      	add	sp, #8
 80014fa:	4770      	bx	lr
 80014fc:	0000      	movs	r0, r0
	...

08001500 <adc_lld_stop_adc>:
/**
 * @brief   Stops an ongoing conversion, if any.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_stop_adc(ADCDriver *adcp) {
 8001500:	b082      	sub	sp, #8
 8001502:	9001      	str	r0, [sp, #4]

  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8001504:	9b01      	ldr	r3, [sp, #4]
 8001506:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001508:	689b      	ldr	r3, [r3, #8]
 800150a:	f003 0304 	and.w	r3, r3, #4
 800150e:	2b00      	cmp	r3, #0
 8001510:	d013      	beq.n	800153a <adc_lld_stop_adc+0x3a>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8001512:	9b01      	ldr	r3, [sp, #4]
 8001514:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001516:	689a      	ldr	r2, [r3, #8]
 8001518:	9b01      	ldr	r3, [sp, #4]
 800151a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800151c:	f042 0210 	orr.w	r2, r2, #16
 8001520:	609a      	str	r2, [r3, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8001522:	bf00      	nop
 8001524:	9b01      	ldr	r3, [sp, #4]
 8001526:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001528:	689b      	ldr	r3, [r3, #8]
 800152a:	f003 0310 	and.w	r3, r3, #16
 800152e:	2b00      	cmp	r3, #0
 8001530:	d1f8      	bne.n	8001524 <adc_lld_stop_adc+0x24>
      ;
    adcp->adcm->IER = 0;
 8001532:	9b01      	ldr	r3, [sp, #4]
 8001534:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001536:	2200      	movs	r2, #0
 8001538:	605a      	str	r2, [r3, #4]
  }
}
 800153a:	bf00      	nop
 800153c:	b002      	add	sp, #8
 800153e:	4770      	bx	lr

08001540 <adc_lld_serve_dma_interrupt>:
 * @brief   ADC DMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001540:	b500      	push	{lr}
 8001542:	b083      	sub	sp, #12
 8001544:	9001      	str	r0, [sp, #4]
 8001546:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001548:	9b00      	ldr	r3, [sp, #0]
 800154a:	f003 0308 	and.w	r3, r3, #8
 800154e:	2b00      	cmp	r3, #0
 8001550:	d02d      	beq.n	80015ae <adc_lld_serve_dma_interrupt+0x6e>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8001552:	9801      	ldr	r0, [sp, #4]
 8001554:	f000 fa8c 	bl	8001a70 <adc_lld_stop_conversion>
 8001558:	9b01      	ldr	r3, [sp, #4]
 800155a:	691b      	ldr	r3, [r3, #16]
 800155c:	689b      	ldr	r3, [r3, #8]
 800155e:	2b00      	cmp	r3, #0
 8001560:	d013      	beq.n	800158a <adc_lld_serve_dma_interrupt+0x4a>
 8001562:	9b01      	ldr	r3, [sp, #4]
 8001564:	2205      	movs	r2, #5
 8001566:	701a      	strb	r2, [r3, #0]
 8001568:	9b01      	ldr	r3, [sp, #4]
 800156a:	691b      	ldr	r3, [r3, #16]
 800156c:	689b      	ldr	r3, [r3, #8]
 800156e:	2101      	movs	r1, #1
 8001570:	9801      	ldr	r0, [sp, #4]
 8001572:	4798      	blx	r3
 8001574:	9b01      	ldr	r3, [sp, #4]
 8001576:	781b      	ldrb	r3, [r3, #0]
 8001578:	2b05      	cmp	r3, #5
 800157a:	d10c      	bne.n	8001596 <adc_lld_serve_dma_interrupt+0x56>
 800157c:	9b01      	ldr	r3, [sp, #4]
 800157e:	2202      	movs	r2, #2
 8001580:	701a      	strb	r2, [r3, #0]
 8001582:	9b01      	ldr	r3, [sp, #4]
 8001584:	2200      	movs	r2, #0
 8001586:	611a      	str	r2, [r3, #16]
 8001588:	e005      	b.n	8001596 <adc_lld_serve_dma_interrupt+0x56>
 800158a:	9b01      	ldr	r3, [sp, #4]
 800158c:	2202      	movs	r2, #2
 800158e:	701a      	strb	r2, [r3, #0]
 8001590:	9b01      	ldr	r3, [sp, #4]
 8001592:	2200      	movs	r2, #0
 8001594:	611a      	str	r2, [r3, #16]
 8001596:	f7ff ff13 	bl	80013c0 <osalSysLockFromISR.lto_priv.0>
 800159a:	9b01      	ldr	r3, [sp, #4]
 800159c:	3314      	adds	r3, #20
 800159e:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 80015a2:	4618      	mov	r0, r3
 80015a4:	f7ff ff2c 	bl	8001400 <osalThreadResumeI.lto_priv.1>
 80015a8:	f7ff ff12 	bl	80013d0 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 80015ac:	e05d      	b.n	800166a <adc_lld_serve_dma_interrupt+0x12a>
    if (adcp->grpp != NULL) {
 80015ae:	9b01      	ldr	r3, [sp, #4]
 80015b0:	691b      	ldr	r3, [r3, #16]
 80015b2:	2b00      	cmp	r3, #0
 80015b4:	d059      	beq.n	800166a <adc_lld_serve_dma_interrupt+0x12a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80015b6:	9b00      	ldr	r3, [sp, #0]
 80015b8:	f003 0302 	and.w	r3, r3, #2
 80015bc:	2b00      	cmp	r3, #0
 80015be:	d045      	beq.n	800164c <adc_lld_serve_dma_interrupt+0x10c>
        _adc_isr_full_code(adcp);
 80015c0:	9b01      	ldr	r3, [sp, #4]
 80015c2:	691b      	ldr	r3, [r3, #16]
 80015c4:	781b      	ldrb	r3, [r3, #0]
 80015c6:	2b00      	cmp	r3, #0
 80015c8:	d014      	beq.n	80015f4 <adc_lld_serve_dma_interrupt+0xb4>
 80015ca:	9b01      	ldr	r3, [sp, #4]
 80015cc:	691b      	ldr	r3, [r3, #16]
 80015ce:	685b      	ldr	r3, [r3, #4]
 80015d0:	2b00      	cmp	r3, #0
 80015d2:	d04a      	beq.n	800166a <adc_lld_serve_dma_interrupt+0x12a>
 80015d4:	9b01      	ldr	r3, [sp, #4]
 80015d6:	2204      	movs	r2, #4
 80015d8:	701a      	strb	r2, [r3, #0]
 80015da:	9b01      	ldr	r3, [sp, #4]
 80015dc:	691b      	ldr	r3, [r3, #16]
 80015de:	685b      	ldr	r3, [r3, #4]
 80015e0:	9801      	ldr	r0, [sp, #4]
 80015e2:	4798      	blx	r3
 80015e4:	9b01      	ldr	r3, [sp, #4]
 80015e6:	781b      	ldrb	r3, [r3, #0]
 80015e8:	2b04      	cmp	r3, #4
 80015ea:	d13e      	bne.n	800166a <adc_lld_serve_dma_interrupt+0x12a>
 80015ec:	9b01      	ldr	r3, [sp, #4]
 80015ee:	2203      	movs	r2, #3
 80015f0:	701a      	strb	r2, [r3, #0]
}
 80015f2:	e03a      	b.n	800166a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_full_code(adcp);
 80015f4:	9801      	ldr	r0, [sp, #4]
 80015f6:	f000 fa3b 	bl	8001a70 <adc_lld_stop_conversion>
 80015fa:	9b01      	ldr	r3, [sp, #4]
 80015fc:	691b      	ldr	r3, [r3, #16]
 80015fe:	685b      	ldr	r3, [r3, #4]
 8001600:	2b00      	cmp	r3, #0
 8001602:	d012      	beq.n	800162a <adc_lld_serve_dma_interrupt+0xea>
 8001604:	9b01      	ldr	r3, [sp, #4]
 8001606:	2204      	movs	r2, #4
 8001608:	701a      	strb	r2, [r3, #0]
 800160a:	9b01      	ldr	r3, [sp, #4]
 800160c:	691b      	ldr	r3, [r3, #16]
 800160e:	685b      	ldr	r3, [r3, #4]
 8001610:	9801      	ldr	r0, [sp, #4]
 8001612:	4798      	blx	r3
 8001614:	9b01      	ldr	r3, [sp, #4]
 8001616:	781b      	ldrb	r3, [r3, #0]
 8001618:	2b04      	cmp	r3, #4
 800161a:	d10c      	bne.n	8001636 <adc_lld_serve_dma_interrupt+0xf6>
 800161c:	9b01      	ldr	r3, [sp, #4]
 800161e:	2202      	movs	r2, #2
 8001620:	701a      	strb	r2, [r3, #0]
 8001622:	9b01      	ldr	r3, [sp, #4]
 8001624:	2200      	movs	r2, #0
 8001626:	611a      	str	r2, [r3, #16]
 8001628:	e005      	b.n	8001636 <adc_lld_serve_dma_interrupt+0xf6>
 800162a:	9b01      	ldr	r3, [sp, #4]
 800162c:	2202      	movs	r2, #2
 800162e:	701a      	strb	r2, [r3, #0]
 8001630:	9b01      	ldr	r3, [sp, #4]
 8001632:	2200      	movs	r2, #0
 8001634:	611a      	str	r2, [r3, #16]
 8001636:	f7ff fec3 	bl	80013c0 <osalSysLockFromISR.lto_priv.0>
 800163a:	9b01      	ldr	r3, [sp, #4]
 800163c:	3314      	adds	r3, #20
 800163e:	2100      	movs	r1, #0
 8001640:	4618      	mov	r0, r3
 8001642:	f7ff fedd 	bl	8001400 <osalThreadResumeI.lto_priv.1>
 8001646:	f7ff fec3 	bl	80013d0 <osalSysUnlockFromISR.lto_priv.0>
}
 800164a:	e00e      	b.n	800166a <adc_lld_serve_dma_interrupt+0x12a>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 800164c:	9b00      	ldr	r3, [sp, #0]
 800164e:	f003 0304 	and.w	r3, r3, #4
 8001652:	2b00      	cmp	r3, #0
 8001654:	d009      	beq.n	800166a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_half_code(adcp);
 8001656:	9b01      	ldr	r3, [sp, #4]
 8001658:	691b      	ldr	r3, [r3, #16]
 800165a:	685b      	ldr	r3, [r3, #4]
 800165c:	2b00      	cmp	r3, #0
 800165e:	d004      	beq.n	800166a <adc_lld_serve_dma_interrupt+0x12a>
 8001660:	9b01      	ldr	r3, [sp, #4]
 8001662:	691b      	ldr	r3, [r3, #16]
 8001664:	685b      	ldr	r3, [r3, #4]
 8001666:	9801      	ldr	r0, [sp, #4]
 8001668:	4798      	blx	r3
}
 800166a:	bf00      	nop
 800166c:	b003      	add	sp, #12
 800166e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001672:	bf00      	nop
	...

08001680 <adc_lld_serve_interrupt>:
 * @brief   ADC IRQ service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] isr       content of the ISR register
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 8001680:	b500      	push	{lr}
 8001682:	b085      	sub	sp, #20
 8001684:	9001      	str	r0, [sp, #4]
 8001686:	9100      	str	r1, [sp, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8001688:	9b01      	ldr	r3, [sp, #4]
 800168a:	691b      	ldr	r3, [r3, #16]
 800168c:	2b00      	cmp	r3, #0
 800168e:	d059      	beq.n	8001744 <adc_lld_serve_interrupt+0xc4>
    adcerror_t emask = 0U;
 8001690:	2300      	movs	r3, #0
 8001692:	9303      	str	r3, [sp, #12]

    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the state is checked too.*/
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8001694:	9b00      	ldr	r3, [sp, #0]
 8001696:	f003 0310 	and.w	r3, r3, #16
 800169a:	2b00      	cmp	r3, #0
 800169c:	d007      	beq.n	80016ae <adc_lld_serve_interrupt+0x2e>
 800169e:	9b01      	ldr	r3, [sp, #4]
 80016a0:	781b      	ldrb	r3, [r3, #0]
 80016a2:	2b03      	cmp	r3, #3
 80016a4:	d103      	bne.n	80016ae <adc_lld_serve_interrupt+0x2e>
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
 80016a6:	9b03      	ldr	r3, [sp, #12]
 80016a8:	f043 0302 	orr.w	r3, r3, #2
 80016ac:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD1) {
 80016ae:	9b00      	ldr	r3, [sp, #0]
 80016b0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80016b4:	2b00      	cmp	r3, #0
 80016b6:	d003      	beq.n	80016c0 <adc_lld_serve_interrupt+0x40>
      /* Analog watchdog 1 error.*/
      emask |= ADC_ERR_AWD1;
 80016b8:	9b03      	ldr	r3, [sp, #12]
 80016ba:	f043 0304 	orr.w	r3, r3, #4
 80016be:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD2) {
 80016c0:	9b00      	ldr	r3, [sp, #0]
 80016c2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80016c6:	2b00      	cmp	r3, #0
 80016c8:	d003      	beq.n	80016d2 <adc_lld_serve_interrupt+0x52>
      /* Analog watchdog 2 error.*/
      emask |= ADC_ERR_AWD2;
 80016ca:	9b03      	ldr	r3, [sp, #12]
 80016cc:	f043 0308 	orr.w	r3, r3, #8
 80016d0:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD3) {
 80016d2:	9b00      	ldr	r3, [sp, #0]
 80016d4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80016d8:	2b00      	cmp	r3, #0
 80016da:	d003      	beq.n	80016e4 <adc_lld_serve_interrupt+0x64>
      /* Analog watchdog 3 error.*/
      emask |= ADC_ERR_AWD3;
 80016dc:	9b03      	ldr	r3, [sp, #12]
 80016de:	f043 0310 	orr.w	r3, r3, #16
 80016e2:	9303      	str	r3, [sp, #12]
    }
    if (emask != 0U) {
 80016e4:	9b03      	ldr	r3, [sp, #12]
 80016e6:	2b00      	cmp	r3, #0
 80016e8:	d02c      	beq.n	8001744 <adc_lld_serve_interrupt+0xc4>
      _adc_isr_error_code(adcp, emask);
 80016ea:	9801      	ldr	r0, [sp, #4]
 80016ec:	f000 f9c0 	bl	8001a70 <adc_lld_stop_conversion>
 80016f0:	9b01      	ldr	r3, [sp, #4]
 80016f2:	691b      	ldr	r3, [r3, #16]
 80016f4:	689b      	ldr	r3, [r3, #8]
 80016f6:	2b00      	cmp	r3, #0
 80016f8:	d013      	beq.n	8001722 <adc_lld_serve_interrupt+0xa2>
 80016fa:	9b01      	ldr	r3, [sp, #4]
 80016fc:	2205      	movs	r2, #5
 80016fe:	701a      	strb	r2, [r3, #0]
 8001700:	9b01      	ldr	r3, [sp, #4]
 8001702:	691b      	ldr	r3, [r3, #16]
 8001704:	689b      	ldr	r3, [r3, #8]
 8001706:	9903      	ldr	r1, [sp, #12]
 8001708:	9801      	ldr	r0, [sp, #4]
 800170a:	4798      	blx	r3
 800170c:	9b01      	ldr	r3, [sp, #4]
 800170e:	781b      	ldrb	r3, [r3, #0]
 8001710:	2b05      	cmp	r3, #5
 8001712:	d10c      	bne.n	800172e <adc_lld_serve_interrupt+0xae>
 8001714:	9b01      	ldr	r3, [sp, #4]
 8001716:	2202      	movs	r2, #2
 8001718:	701a      	strb	r2, [r3, #0]
 800171a:	9b01      	ldr	r3, [sp, #4]
 800171c:	2200      	movs	r2, #0
 800171e:	611a      	str	r2, [r3, #16]
 8001720:	e005      	b.n	800172e <adc_lld_serve_interrupt+0xae>
 8001722:	9b01      	ldr	r3, [sp, #4]
 8001724:	2202      	movs	r2, #2
 8001726:	701a      	strb	r2, [r3, #0]
 8001728:	9b01      	ldr	r3, [sp, #4]
 800172a:	2200      	movs	r2, #0
 800172c:	611a      	str	r2, [r3, #16]
 800172e:	f7ff fe47 	bl	80013c0 <osalSysLockFromISR.lto_priv.0>
 8001732:	9b01      	ldr	r3, [sp, #4]
 8001734:	3314      	adds	r3, #20
 8001736:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 800173a:	4618      	mov	r0, r3
 800173c:	f7ff fe60 	bl	8001400 <osalThreadResumeI.lto_priv.1>
 8001740:	f7ff fe46 	bl	80013d0 <osalSysUnlockFromISR.lto_priv.0>
    }
  }
}
 8001744:	bf00      	nop
 8001746:	b005      	add	sp, #20
 8001748:	f85d fb04 	ldr.w	pc, [sp], #4
 800174c:	0000      	movs	r0, r0
	...

08001750 <Vector88>:
/**
 * @brief   ADC1/ADC2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8001750:	b500      	push	{lr}
 8001752:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 8001754:	f001 f8fc 	bl	8002950 <__dbg_check_enter_isr>
  adc_lld_serve_interrupt(&ADCD1, isr);

#else /* !STM32_ADC_DUAL_MODE */

#if STM32_ADC_USE_ADC1
  isr  = ADC1->ISR;
 8001758:	4b08      	ldr	r3, [pc, #32]	@ (800177c <Vector88+0x2c>)
 800175a:	681b      	ldr	r3, [r3, #0]
 800175c:	9301      	str	r3, [sp, #4]
  ADC1->ISR = isr;
 800175e:	4a07      	ldr	r2, [pc, #28]	@ (800177c <Vector88+0x2c>)
 8001760:	9b01      	ldr	r3, [sp, #4]
 8001762:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD1, isr);
 8001764:	9901      	ldr	r1, [sp, #4]
 8001766:	4806      	ldr	r0, [pc, #24]	@ (8001780 <Vector88+0x30>)
 8001768:	f7ff ff8a 	bl	8001680 <adc_lld_serve_interrupt>
  adc_lld_serve_interrupt(&ADCD2, isr);
#endif

#endif /* !STM32_ADC_DUAL_MODE */

  OSAL_IRQ_EPILOGUE();
 800176c:	f001 f928 	bl	80029c0 <__dbg_check_leave_isr>
 8001770:	f003 fb2e 	bl	8004dd0 <__port_irq_epilogue>
}
 8001774:	bf00      	nop
 8001776:	b003      	add	sp, #12
 8001778:	f85d fb04 	ldr.w	pc, [sp], #4
 800177c:	50040000 	.word	0x50040000
 8001780:	20000800 	.word	0x20000800
	...

08001790 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8001790:	b508      	push	{r3, lr}

  clkmask = 0;
 8001792:	4b23      	ldr	r3, [pc, #140]	@ (8001820 <adc_lld_init+0x90>)
 8001794:	2200      	movs	r2, #0
 8001796:	601a      	str	r2, [r3, #0]

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8001798:	4822      	ldr	r0, [pc, #136]	@ (8001824 <adc_lld_init+0x94>)
 800179a:	f7fe ff31 	bl	8000600 <adcObjectInit>
#elif defined(ADC12_COMMON)
  ADCD1.adcc = ADC12_COMMON;
#elif defined(ADC123_COMMON)
  ADCD1.adcc = ADC123_COMMON;
#else
  ADCD1.adcc = ADC1_COMMON;
 800179e:	4b21      	ldr	r3, [pc, #132]	@ (8001824 <adc_lld_init+0x94>)
 80017a0:	4a21      	ldr	r2, [pc, #132]	@ (8001828 <adc_lld_init+0x98>)
 80017a2:	62da      	str	r2, [r3, #44]	@ 0x2c
#endif
  ADCD1.adcm    = ADC1;
 80017a4:	4b1f      	ldr	r3, [pc, #124]	@ (8001824 <adc_lld_init+0x94>)
 80017a6:	4a21      	ldr	r2, [pc, #132]	@ (800182c <adc_lld_init+0x9c>)
 80017a8:	629a      	str	r2, [r3, #40]	@ 0x28
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs    = ADC2;
#endif
  ADCD1.dmastp  = NULL;
 80017aa:	4b1e      	ldr	r3, [pc, #120]	@ (8001824 <adc_lld_init+0x94>)
 80017ac:	2200      	movs	r2, #0
 80017ae:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD1.dmamode = ADC_DMA_SIZE |
 80017b0:	4b1c      	ldr	r3, [pc, #112]	@ (8001824 <adc_lld_init+0x94>)
 80017b2:	f242 528a 	movw	r2, #9610	@ 0x258a
 80017b6:	635a      	str	r2, [r3, #52]	@ 0x34
  /* IRQs setup.*/
#if STM32_ADC_USE_ADC1 || STM32_ADC_USE_ADC2
#if defined(STM32_ADC_ADC1_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC1_IRQ_PRIORITY);
#elif defined(STM32_ADC_ADC12_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 80017b8:	2105      	movs	r1, #5
 80017ba:	2012      	movs	r0, #18
 80017bc:	f7ff fa00 	bl	8000bc0 <nvicEnableVector>
  rccDisableADC34();
#endif
#endif

#if defined(STM32L4XX) || defined(STM32L4XXP)
  rccResetADC123();
 80017c0:	4b1b      	ldr	r3, [pc, #108]	@ (8001830 <adc_lld_init+0xa0>)
 80017c2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80017c4:	4a1a      	ldr	r2, [pc, #104]	@ (8001830 <adc_lld_init+0xa0>)
 80017c6:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80017ca:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80017cc:	4b18      	ldr	r3, [pc, #96]	@ (8001830 <adc_lld_init+0xa0>)
 80017ce:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80017d0:	4a17      	ldr	r2, [pc, #92]	@ (8001830 <adc_lld_init+0xa0>)
 80017d2:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80017d6:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80017d8:	4b15      	ldr	r3, [pc, #84]	@ (8001830 <adc_lld_init+0xa0>)
 80017da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableADC123(true);
 80017dc:	4b14      	ldr	r3, [pc, #80]	@ (8001830 <adc_lld_init+0xa0>)
 80017de:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80017e0:	4a13      	ldr	r2, [pc, #76]	@ (8001830 <adc_lld_init+0xa0>)
 80017e2:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80017e6:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80017e8:	4b11      	ldr	r3, [pc, #68]	@ (8001830 <adc_lld_init+0xa0>)
 80017ea:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80017ec:	4a10      	ldr	r2, [pc, #64]	@ (8001830 <adc_lld_init+0xa0>)
 80017ee:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80017f2:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80017f4:	4b0e      	ldr	r3, [pc, #56]	@ (8001830 <adc_lld_init+0xa0>)
 80017f6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#elif defined(ADC12_COMMON)
  ADC12_COMMON->CCR = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
#elif defined(ADC123_COMMON)
  ADC123_COMMON->CCR = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
#else
  ADC1_COMMON->CCR   = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
 80017f8:	4b0b      	ldr	r3, [pc, #44]	@ (8001828 <adc_lld_init+0x98>)
 80017fa:	f44f 22c0 	mov.w	r2, #393216	@ 0x60000
 80017fe:	609a      	str	r2, [r3, #8]
#endif
  rccDisableADC123();
 8001800:	4b0b      	ldr	r3, [pc, #44]	@ (8001830 <adc_lld_init+0xa0>)
 8001802:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001804:	4a0a      	ldr	r2, [pc, #40]	@ (8001830 <adc_lld_init+0xa0>)
 8001806:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 800180a:	64d3      	str	r3, [r2, #76]	@ 0x4c
 800180c:	4b08      	ldr	r3, [pc, #32]	@ (8001830 <adc_lld_init+0xa0>)
 800180e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8001810:	4a07      	ldr	r2, [pc, #28]	@ (8001830 <adc_lld_init+0xa0>)
 8001812:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 8001816:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8001818:	4b05      	ldr	r3, [pc, #20]	@ (8001830 <adc_lld_init+0xa0>)
 800181a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
  rccEnableADC1(true);
  ADC1_COMMON->CCR = STM32_ADC_ADC1_PRESC | STM32_ADC_ADC1_CLOCK_MODE;
  rccDisableADC1();
#endif
#endif
}
 800181c:	bf00      	nop
 800181e:	bd08      	pop	{r3, pc}
 8001820:	20000838 	.word	0x20000838
 8001824:	20000800 	.word	0x20000800
 8001828:	50040300 	.word	0x50040300
 800182c:	50040000 	.word	0x50040000
 8001830:	40021000 	.word	0x40021000
	...

08001840 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8001840:	b500      	push	{lr}
 8001842:	b083      	sub	sp, #12
 8001844:	9001      	str	r0, [sp, #4]

  /* Handling the default configuration.*/
  if (adcp->config == NULL) {
 8001846:	9b01      	ldr	r3, [sp, #4]
 8001848:	685b      	ldr	r3, [r3, #4]
 800184a:	2b00      	cmp	r3, #0
 800184c:	d102      	bne.n	8001854 <adc_lld_start+0x14>
    adcp->config = &default_config;
 800184e:	9b01      	ldr	r3, [sp, #4]
 8001850:	4a2a      	ldr	r2, [pc, #168]	@ (80018fc <adc_lld_start+0xbc>)
 8001852:	605a      	str	r2, [r3, #4]
  }

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8001854:	9b01      	ldr	r3, [sp, #4]
 8001856:	781b      	ldrb	r3, [r3, #0]
 8001858:	2b01      	cmp	r3, #1
 800185a:	d14a      	bne.n	80018f2 <adc_lld_start+0xb2>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800185c:	9b01      	ldr	r3, [sp, #4]
 800185e:	4a28      	ldr	r2, [pc, #160]	@ (8001900 <adc_lld_start+0xc0>)
 8001860:	4293      	cmp	r3, r2
 8001862:	d12e      	bne.n	80018c2 <adc_lld_start+0x82>

      osalDbgAssert(STM32_ADC1_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 8001864:	9b01      	ldr	r3, [sp, #4]
 8001866:	4a27      	ldr	r2, [pc, #156]	@ (8001904 <adc_lld_start+0xc4>)
 8001868:	2105      	movs	r1, #5
 800186a:	200e      	movs	r0, #14
 800186c:	f000 fa58 	bl	8001d20 <dmaStreamAllocI>
 8001870:	4602      	mov	r2, r0
 8001872:	9b01      	ldr	r3, [sp, #4]
 8001874:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8001876:	9b01      	ldr	r3, [sp, #4]
 8001878:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800187a:	2b00      	cmp	r3, #0
 800187c:	bf0c      	ite	eq
 800187e:	2301      	moveq	r3, #1
 8001880:	2300      	movne	r3, #0
 8001882:	b2db      	uxtb	r3, r3
 8001884:	2b00      	cmp	r3, #0
 8001886:	d002      	beq.n	800188e <adc_lld_start+0x4e>
 8001888:	481f      	ldr	r0, [pc, #124]	@ (8001908 <adc_lld_start+0xc8>)
 800188a:	f000 ff39 	bl	8002700 <chSysHalt>

      clkmask |= (1 << 0);
 800188e:	4b1f      	ldr	r3, [pc, #124]	@ (800190c <adc_lld_start+0xcc>)
 8001890:	681b      	ldr	r3, [r3, #0]
 8001892:	f043 0301 	orr.w	r3, r3, #1
 8001896:	4a1d      	ldr	r2, [pc, #116]	@ (800190c <adc_lld_start+0xcc>)
 8001898:	6013      	str	r3, [r2, #0]
#if defined(STM32F3XX) || defined(STM32G4XX)
      rccEnableADC12(true);
#endif
#if defined(STM32L4XX) || defined(STM32L4XXP)
      rccEnableADC123(true);
 800189a:	4b1d      	ldr	r3, [pc, #116]	@ (8001910 <adc_lld_start+0xd0>)
 800189c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800189e:	4a1c      	ldr	r2, [pc, #112]	@ (8001910 <adc_lld_start+0xd0>)
 80018a0:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80018a4:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80018a6:	4b1a      	ldr	r3, [pc, #104]	@ (8001910 <adc_lld_start+0xd0>)
 80018a8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80018aa:	4a19      	ldr	r2, [pc, #100]	@ (8001910 <adc_lld_start+0xd0>)
 80018ac:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80018b0:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80018b2:	4b17      	ldr	r3, [pc, #92]	@ (8001910 <adc_lld_start+0xd0>)
 80018b4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
#if defined(STM32WBXX)
      rccEnableADC1(true);
#endif
#if STM32_DMA_SUPPORTS_DMAMUX
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC1);
 80018b6:	9b01      	ldr	r3, [sp, #4]
 80018b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80018ba:	2105      	movs	r1, #5
 80018bc:	4618      	mov	r0, r3
 80018be:	f000 fb3f 	bl	8001f40 <dmaSetRequestSource>

    /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcc->CDR);
#else
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 80018c2:	9b01      	ldr	r3, [sp, #4]
 80018c4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80018c6:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 80018ca:	9b01      	ldr	r3, [sp, #4]
 80018cc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80018ce:	685b      	ldr	r3, [r3, #4]
 80018d0:	609a      	str	r2, [r3, #8]
    /* Differential channels setting.*/
#if STM32_ADC_DUAL_MODE
    adcp->adcm->DIFSEL = adcp->config->difsel;
    adcp->adcs->DIFSEL = adcp->config->difsel;
#else
    adcp->adcm->DIFSEL = adcp->config->difsel;
 80018d2:	9b01      	ldr	r3, [sp, #4]
 80018d4:	685a      	ldr	r2, [r3, #4]
 80018d6:	9b01      	ldr	r3, [sp, #4]
 80018d8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80018da:	6812      	ldr	r2, [r2, #0]
 80018dc:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
#endif

    /* Master ADC calibration.*/
    adc_lld_vreg_on(adcp);
 80018e0:	9801      	ldr	r0, [sp, #4]
 80018e2:	f7ff fd9d 	bl	8001420 <adc_lld_vreg_on>
    adc_lld_calibrate(adcp);
 80018e6:	9801      	ldr	r0, [sp, #4]
 80018e8:	f7ff fdb2 	bl	8001450 <adc_lld_calibrate>

    /* Master ADC enabled here in order to reduce conversions latencies.*/
    adc_lld_analog_on(adcp);
 80018ec:	9801      	ldr	r0, [sp, #4]
 80018ee:	f7ff fdef 	bl	80014d0 <adc_lld_analog_on>
  }
}
 80018f2:	bf00      	nop
 80018f4:	b003      	add	sp, #12
 80018f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80018fa:	bf00      	nop
 80018fc:	08005154 	.word	0x08005154
 8001900:	20000800 	.word	0x20000800
 8001904:	08001541 	.word	0x08001541
 8001908:	0800516c 	.word	0x0800516c
 800190c:	20000838 	.word	0x20000838
 8001910:	40021000 	.word	0x40021000
	...

08001920 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 8001920:	b086      	sub	sp, #24
 8001922:	9001      	str	r0, [sp, #4]
  uint32_t dmamode, cfgr;
  const ADCConversionGroup *grpp = adcp->grpp;
 8001924:	9b01      	ldr	r3, [sp, #4]
 8001926:	691b      	ldr	r3, [r3, #16]
 8001928:	9303      	str	r3, [sp, #12]

  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
 800192a:	9b01      	ldr	r3, [sp, #4]
 800192c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800192e:	9305      	str	r3, [sp, #20]
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 8001930:	9b03      	ldr	r3, [sp, #12]
 8001932:	68db      	ldr	r3, [r3, #12]
 8001934:	f043 0301 	orr.w	r3, r3, #1
 8001938:	9304      	str	r3, [sp, #16]
  if (grpp->circular) {
 800193a:	9b03      	ldr	r3, [sp, #12]
 800193c:	781b      	ldrb	r3, [r3, #0]
 800193e:	2b00      	cmp	r3, #0
 8001940:	d00f      	beq.n	8001962 <adc_lld_start_conversion+0x42>
    dmamode |= STM32_DMA_CR_CIRC;
 8001942:	9b05      	ldr	r3, [sp, #20]
 8001944:	f043 0320 	orr.w	r3, r3, #32
 8001948:	9305      	str	r3, [sp, #20]
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
#else
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
 800194a:	9b04      	ldr	r3, [sp, #16]
 800194c:	f043 0302 	orr.w	r3, r3, #2
 8001950:	9304      	str	r3, [sp, #16]
#endif
    if (adcp->depth > 1) {
 8001952:	9b01      	ldr	r3, [sp, #4]
 8001954:	68db      	ldr	r3, [r3, #12]
 8001956:	2b01      	cmp	r3, #1
 8001958:	d903      	bls.n	8001962 <adc_lld_start_conversion+0x42>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      dmamode |= STM32_DMA_CR_HTIE;
 800195a:	9b05      	ldr	r3, [sp, #20]
 800195c:	f043 0304 	orr.w	r3, r3, #4
 8001960:	9305      	str	r3, [sp, #20]
    }
  }

  /* DMA setup.*/
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8001962:	9b01      	ldr	r3, [sp, #4]
 8001964:	689a      	ldr	r2, [r3, #8]
 8001966:	9b01      	ldr	r3, [sp, #4]
 8001968:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800196a:	685b      	ldr	r3, [r3, #4]
 800196c:	60da      	str	r2, [r3, #12]
#if STM32_ADC_DUAL_MODE
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels/2) *
                                            (uint32_t)adcp->depth);
#else
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800196e:	9b03      	ldr	r3, [sp, #12]
 8001970:	885b      	ldrh	r3, [r3, #2]
 8001972:	4619      	mov	r1, r3
 8001974:	9b01      	ldr	r3, [sp, #4]
 8001976:	68da      	ldr	r2, [r3, #12]
 8001978:	9b01      	ldr	r3, [sp, #4]
 800197a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800197c:	685b      	ldr	r3, [r3, #4]
 800197e:	fb01 f202 	mul.w	r2, r1, r2
 8001982:	605a      	str	r2, [r3, #4]
                                            (uint32_t)adcp->depth);
#endif
  dmaStreamSetMode(adcp->dmastp, dmamode);
 8001984:	9b01      	ldr	r3, [sp, #4]
 8001986:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001988:	685b      	ldr	r3, [r3, #4]
 800198a:	9a05      	ldr	r2, [sp, #20]
 800198c:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(adcp->dmastp);
 800198e:	9b01      	ldr	r3, [sp, #4]
 8001990:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001992:	685b      	ldr	r3, [r3, #4]
 8001994:	681a      	ldr	r2, [r3, #0]
 8001996:	9b01      	ldr	r3, [sp, #4]
 8001998:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800199a:	685b      	ldr	r3, [r3, #4]
 800199c:	f042 0201 	orr.w	r2, r2, #1
 80019a0:	601a      	str	r2, [r3, #0]

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
 80019a2:	9b01      	ldr	r3, [sp, #4]
 80019a4:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80019a6:	9b01      	ldr	r3, [sp, #4]
 80019a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019aa:	6812      	ldr	r2, [r2, #0]
 80019ac:	601a      	str	r2, [r3, #0]
  if (grpp->error_cb != NULL) {
 80019ae:	9b03      	ldr	r3, [sp, #12]
 80019b0:	689b      	ldr	r3, [r3, #8]
 80019b2:	2b00      	cmp	r3, #0
 80019b4:	d01f      	beq.n	80019f6 <adc_lld_start_conversion+0xd6>
    adcp->adcm->IER    = ADC_IER_OVRIE | ADC_IER_AWD1IE
 80019b6:	9b01      	ldr	r3, [sp, #4]
 80019b8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019ba:	f44f 7264 	mov.w	r2, #912	@ 0x390
 80019be:	605a      	str	r2, [r3, #4]
                                       | ADC_IER_AWD2IE
                                       | ADC_IER_AWD3IE;
    adcp->adcm->TR1    = grpp->tr1;
 80019c0:	9b01      	ldr	r3, [sp, #4]
 80019c2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019c4:	9a03      	ldr	r2, [sp, #12]
 80019c6:	6952      	ldr	r2, [r2, #20]
 80019c8:	621a      	str	r2, [r3, #32]
    adcp->adcm->TR2    = grpp->tr2;
 80019ca:	9b01      	ldr	r3, [sp, #4]
 80019cc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019ce:	9a03      	ldr	r2, [sp, #12]
 80019d0:	6992      	ldr	r2, [r2, #24]
 80019d2:	625a      	str	r2, [r3, #36]	@ 0x24
    adcp->adcm->TR3    = grpp->tr3;
 80019d4:	9b01      	ldr	r3, [sp, #4]
 80019d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019d8:	9a03      	ldr	r2, [sp, #12]
 80019da:	69d2      	ldr	r2, [r2, #28]
 80019dc:	629a      	str	r2, [r3, #40]	@ 0x28
    adcp->adcm->AWD2CR = grpp->awd2cr;
 80019de:	9b01      	ldr	r3, [sp, #4]
 80019e0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019e2:	9a03      	ldr	r2, [sp, #12]
 80019e4:	6a12      	ldr	r2, [r2, #32]
 80019e6:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    adcp->adcm->AWD3CR = grpp->awd3cr;
 80019ea:	9b01      	ldr	r3, [sp, #4]
 80019ec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019ee:	9a03      	ldr	r2, [sp, #12]
 80019f0:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80019f2:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
  adcp->adcs->SQR2  = grpp->ssqr[1];
  adcp->adcs->SQR3  = grpp->ssqr[2];
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
 80019f6:	9b01      	ldr	r3, [sp, #4]
 80019f8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019fa:	9a03      	ldr	r2, [sp, #12]
 80019fc:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 80019fe:	615a      	str	r2, [r3, #20]
  adcp->adcm->SMPR2 = grpp->smpr[1];
 8001a00:	9b01      	ldr	r3, [sp, #4]
 8001a02:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a04:	9a03      	ldr	r2, [sp, #12]
 8001a06:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8001a08:	619a      	str	r2, [r3, #24]
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8001a0a:	9b03      	ldr	r3, [sp, #12]
 8001a0c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001a0e:	9b03      	ldr	r3, [sp, #12]
 8001a10:	885b      	ldrh	r3, [r3, #2]
 8001a12:	3b01      	subs	r3, #1
 8001a14:	4619      	mov	r1, r3
 8001a16:	9b01      	ldr	r3, [sp, #4]
 8001a18:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a1a:	430a      	orrs	r2, r1
 8001a1c:	631a      	str	r2, [r3, #48]	@ 0x30
  adcp->adcm->SQR2  = grpp->sqr[1];
 8001a1e:	9b01      	ldr	r3, [sp, #4]
 8001a20:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a22:	9a03      	ldr	r2, [sp, #12]
 8001a24:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 8001a26:	635a      	str	r2, [r3, #52]	@ 0x34
  adcp->adcm->SQR3  = grpp->sqr[2];
 8001a28:	9b01      	ldr	r3, [sp, #4]
 8001a2a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a2c:	9a03      	ldr	r2, [sp, #12]
 8001a2e:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 8001a30:	639a      	str	r2, [r3, #56]	@ 0x38
  adcp->adcm->SQR4  = grpp->sqr[3];
 8001a32:	9b01      	ldr	r3, [sp, #4]
 8001a34:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a36:	9a03      	ldr	r2, [sp, #12]
 8001a38:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8001a3a:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif /* !STM32_ADC_DUAL_MODE */

  /* ADC configuration.*/
  adcp->adcm->CFGR  = cfgr;
 8001a3c:	9b01      	ldr	r3, [sp, #4]
 8001a3e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a40:	9a04      	ldr	r2, [sp, #16]
 8001a42:	60da      	str	r2, [r3, #12]
#if (STM32_ADCV3_OVERSAMPLING == TRUE) || defined(__DOXYGEN__)
  adcp->adcm->CFGR2 = grpp->cfgr2;
 8001a44:	9b01      	ldr	r3, [sp, #4]
 8001a46:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a48:	9a03      	ldr	r2, [sp, #12]
 8001a4a:	6912      	ldr	r2, [r2, #16]
 8001a4c:	611a      	str	r2, [r3, #16]
#endif

  /* Starting conversion.*/
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a52:	689a      	ldr	r2, [r3, #8]
 8001a54:	9b01      	ldr	r3, [sp, #4]
 8001a56:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a58:	f042 0204 	orr.w	r2, r2, #4
 8001a5c:	609a      	str	r2, [r3, #8]
}
 8001a5e:	bf00      	nop
 8001a60:	b006      	add	sp, #24
 8001a62:	4770      	bx	lr
	...

08001a70 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8001a70:	b500      	push	{lr}
 8001a72:	b083      	sub	sp, #12
 8001a74:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
 8001a76:	9b01      	ldr	r3, [sp, #4]
 8001a78:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a7a:	685b      	ldr	r3, [r3, #4]
 8001a7c:	681a      	ldr	r2, [r3, #0]
 8001a7e:	9b01      	ldr	r3, [sp, #4]
 8001a80:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a82:	685b      	ldr	r3, [r3, #4]
 8001a84:	f022 020f 	bic.w	r2, r2, #15
 8001a88:	601a      	str	r2, [r3, #0]
 8001a8a:	9b01      	ldr	r3, [sp, #4]
 8001a8c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a8e:	7c1b      	ldrb	r3, [r3, #16]
 8001a90:	461a      	mov	r2, r3
 8001a92:	230e      	movs	r3, #14
 8001a94:	fa03 f202 	lsl.w	r2, r3, r2
 8001a98:	9b01      	ldr	r3, [sp, #4]
 8001a9a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a9c:	681b      	ldr	r3, [r3, #0]
 8001a9e:	605a      	str	r2, [r3, #4]
  adc_lld_stop_adc(adcp);
 8001aa0:	9801      	ldr	r0, [sp, #4]
 8001aa2:	f7ff fd2d 	bl	8001500 <adc_lld_stop_adc>
}
 8001aa6:	bf00      	nop
 8001aa8:	b003      	add	sp, #12
 8001aaa:	f85d fb04 	ldr.w	pc, [sp], #4
 8001aae:	bf00      	nop

08001ab0 <adcSTM32EnableVREF>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableVREF(ADCDriver *adcp) {
 8001ab0:	b082      	sub	sp, #8
 8001ab2:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_VREFEN;
 8001ab4:	9b01      	ldr	r3, [sp, #4]
 8001ab6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001ab8:	689a      	ldr	r2, [r3, #8]
 8001aba:	9b01      	ldr	r3, [sp, #4]
 8001abc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001abe:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8001ac2:	609a      	str	r2, [r3, #8]
}
 8001ac4:	bf00      	nop
 8001ac6:	b002      	add	sp, #8
 8001ac8:	4770      	bx	lr
 8001aca:	bf00      	nop
 8001acc:	0000      	movs	r0, r0
	...

08001ad0 <adcSTM32EnableTS>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {
 8001ad0:	b082      	sub	sp, #8
 8001ad2:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_TSEN;
 8001ad4:	9b01      	ldr	r3, [sp, #4]
 8001ad6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001ad8:	689a      	ldr	r2, [r3, #8]
 8001ada:	9b01      	ldr	r3, [sp, #4]
 8001adc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001ade:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 8001ae2:	609a      	str	r2, [r3, #8]
}
 8001ae4:	bf00      	nop
 8001ae6:	b002      	add	sp, #8
 8001ae8:	4770      	bx	lr
 8001aea:	bf00      	nop
 8001aec:	0000      	movs	r0, r0
	...

08001af0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001af0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001af2:	f000 ff2d 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8001af6:	4804      	ldr	r0, [pc, #16]	@ (8001b08 <Vector6C+0x18>)
 8001af8:	f000 f9e2 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001afc:	f000 ff60 	bl	80029c0 <__dbg_check_leave_isr>
 8001b00:	f003 f966 	bl	8004dd0 <__port_irq_epilogue>
}
 8001b04:	bf00      	nop
 8001b06:	bd08      	pop	{r3, pc}
 8001b08:	0800517c 	.word	0x0800517c
 8001b0c:	00000000 	.word	0x00000000

08001b10 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8001b10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001b12:	f000 ff1d 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8001b16:	4804      	ldr	r0, [pc, #16]	@ (8001b28 <Vector70+0x18>)
 8001b18:	f000 f9d2 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001b1c:	f000 ff50 	bl	80029c0 <__dbg_check_leave_isr>
 8001b20:	f003 f956 	bl	8004dd0 <__port_irq_epilogue>
}
 8001b24:	bf00      	nop
 8001b26:	bd08      	pop	{r3, pc}
 8001b28:	08005190 	.word	0x08005190
 8001b2c:	00000000 	.word	0x00000000

08001b30 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8001b30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001b32:	f000 ff0d 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8001b36:	4804      	ldr	r0, [pc, #16]	@ (8001b48 <Vector74+0x18>)
 8001b38:	f000 f9c2 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001b3c:	f000 ff40 	bl	80029c0 <__dbg_check_leave_isr>
 8001b40:	f003 f946 	bl	8004dd0 <__port_irq_epilogue>
}
 8001b44:	bf00      	nop
 8001b46:	bd08      	pop	{r3, pc}
 8001b48:	080051a4 	.word	0x080051a4
 8001b4c:	00000000 	.word	0x00000000

08001b50 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001b50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001b52:	f000 fefd 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8001b56:	4804      	ldr	r0, [pc, #16]	@ (8001b68 <Vector78+0x18>)
 8001b58:	f000 f9b2 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001b5c:	f000 ff30 	bl	80029c0 <__dbg_check_leave_isr>
 8001b60:	f003 f936 	bl	8004dd0 <__port_irq_epilogue>
}
 8001b64:	bf00      	nop
 8001b66:	bd08      	pop	{r3, pc}
 8001b68:	080051b8 	.word	0x080051b8
 8001b6c:	00000000 	.word	0x00000000

08001b70 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8001b70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001b72:	f000 feed 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8001b76:	4804      	ldr	r0, [pc, #16]	@ (8001b88 <Vector7C+0x18>)
 8001b78:	f000 f9a2 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001b7c:	f000 ff20 	bl	80029c0 <__dbg_check_leave_isr>
 8001b80:	f003 f926 	bl	8004dd0 <__port_irq_epilogue>
}
 8001b84:	bf00      	nop
 8001b86:	bd08      	pop	{r3, pc}
 8001b88:	080051cc 	.word	0x080051cc
 8001b8c:	00000000 	.word	0x00000000

08001b90 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8001b90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001b92:	f000 fedd 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8001b96:	4804      	ldr	r0, [pc, #16]	@ (8001ba8 <Vector80+0x18>)
 8001b98:	f000 f992 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001b9c:	f000 ff10 	bl	80029c0 <__dbg_check_leave_isr>
 8001ba0:	f003 f916 	bl	8004dd0 <__port_irq_epilogue>
}
 8001ba4:	bf00      	nop
 8001ba6:	bd08      	pop	{r3, pc}
 8001ba8:	080051e0 	.word	0x080051e0
 8001bac:	00000000 	.word	0x00000000

08001bb0 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8001bb0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001bb2:	f000 fecd 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8001bb6:	4804      	ldr	r0, [pc, #16]	@ (8001bc8 <Vector84+0x18>)
 8001bb8:	f000 f982 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001bbc:	f000 ff00 	bl	80029c0 <__dbg_check_leave_isr>
 8001bc0:	f003 f906 	bl	8004dd0 <__port_irq_epilogue>
}
 8001bc4:	bf00      	nop
 8001bc6:	bd08      	pop	{r3, pc}
 8001bc8:	080051f4 	.word	0x080051f4
 8001bcc:	00000000 	.word	0x00000000

08001bd0 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8001bd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001bd2:	f000 febd 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8001bd6:	4804      	ldr	r0, [pc, #16]	@ (8001be8 <Vector120+0x18>)
 8001bd8:	f000 f972 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001bdc:	f000 fef0 	bl	80029c0 <__dbg_check_leave_isr>
 8001be0:	f003 f8f6 	bl	8004dd0 <__port_irq_epilogue>
}
 8001be4:	bf00      	nop
 8001be6:	bd08      	pop	{r3, pc}
 8001be8:	08005208 	.word	0x08005208
 8001bec:	00000000 	.word	0x00000000

08001bf0 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8001bf0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001bf2:	f000 fead 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8001bf6:	4804      	ldr	r0, [pc, #16]	@ (8001c08 <Vector124+0x18>)
 8001bf8:	f000 f962 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001bfc:	f000 fee0 	bl	80029c0 <__dbg_check_leave_isr>
 8001c00:	f003 f8e6 	bl	8004dd0 <__port_irq_epilogue>
}
 8001c04:	bf00      	nop
 8001c06:	bd08      	pop	{r3, pc}
 8001c08:	0800521c 	.word	0x0800521c
 8001c0c:	00000000 	.word	0x00000000

08001c10 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8001c10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c12:	f000 fe9d 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8001c16:	4804      	ldr	r0, [pc, #16]	@ (8001c28 <Vector128+0x18>)
 8001c18:	f000 f952 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c1c:	f000 fed0 	bl	80029c0 <__dbg_check_leave_isr>
 8001c20:	f003 f8d6 	bl	8004dd0 <__port_irq_epilogue>
}
 8001c24:	bf00      	nop
 8001c26:	bd08      	pop	{r3, pc}
 8001c28:	08005230 	.word	0x08005230
 8001c2c:	00000000 	.word	0x00000000

08001c30 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001c30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c32:	f000 fe8d 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8001c36:	4804      	ldr	r0, [pc, #16]	@ (8001c48 <Vector12C+0x18>)
 8001c38:	f000 f942 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c3c:	f000 fec0 	bl	80029c0 <__dbg_check_leave_isr>
 8001c40:	f003 f8c6 	bl	8004dd0 <__port_irq_epilogue>
}
 8001c44:	bf00      	nop
 8001c46:	bd08      	pop	{r3, pc}
 8001c48:	08005244 	.word	0x08005244
 8001c4c:	00000000 	.word	0x00000000

08001c50 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001c50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c52:	f000 fe7d 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8001c56:	4804      	ldr	r0, [pc, #16]	@ (8001c68 <Vector130+0x18>)
 8001c58:	f000 f932 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c5c:	f000 feb0 	bl	80029c0 <__dbg_check_leave_isr>
 8001c60:	f003 f8b6 	bl	8004dd0 <__port_irq_epilogue>
}
 8001c64:	bf00      	nop
 8001c66:	bd08      	pop	{r3, pc}
 8001c68:	08005258 	.word	0x08005258
 8001c6c:	00000000 	.word	0x00000000

08001c70 <Vector150>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8001c70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c72:	f000 fe6d 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8001c76:	4804      	ldr	r0, [pc, #16]	@ (8001c88 <Vector150+0x18>)
 8001c78:	f000 f922 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c7c:	f000 fea0 	bl	80029c0 <__dbg_check_leave_isr>
 8001c80:	f003 f8a6 	bl	8004dd0 <__port_irq_epilogue>
}
 8001c84:	bf00      	nop
 8001c86:	bd08      	pop	{r3, pc}
 8001c88:	0800526c 	.word	0x0800526c
 8001c8c:	00000000 	.word	0x00000000

08001c90 <Vector154>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8001c90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001c92:	f000 fe5d 	bl	8002950 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 8001c96:	4804      	ldr	r0, [pc, #16]	@ (8001ca8 <Vector154+0x18>)
 8001c98:	f000 f912 	bl	8001ec0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001c9c:	f000 fe90 	bl	80029c0 <__dbg_check_leave_isr>
 8001ca0:	f003 f896 	bl	8004dd0 <__port_irq_epilogue>
}
 8001ca4:	bf00      	nop
 8001ca6:	bd08      	pop	{r3, pc}
 8001ca8:	08005280 	.word	0x08005280
 8001cac:	00000000 	.word	0x00000000

08001cb0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8001cb0:	b082      	sub	sp, #8
  int i;

  dma.allocated_mask = 0U;
 8001cb2:	4b15      	ldr	r3, [pc, #84]	@ (8001d08 <dmaInit+0x58>)
 8001cb4:	2200      	movs	r2, #0
 8001cb6:	601a      	str	r2, [r3, #0]
  dma.isr_mask       = 0U;
 8001cb8:	4b13      	ldr	r3, [pc, #76]	@ (8001d08 <dmaInit+0x58>)
 8001cba:	2200      	movs	r2, #0
 8001cbc:	605a      	str	r2, [r3, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001cbe:	2300      	movs	r3, #0
 8001cc0:	9301      	str	r3, [sp, #4]
 8001cc2:	e013      	b.n	8001cec <dmaInit+0x3c>
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001cc4:	4911      	ldr	r1, [pc, #68]	@ (8001d0c <dmaInit+0x5c>)
 8001cc6:	9a01      	ldr	r2, [sp, #4]
 8001cc8:	4613      	mov	r3, r2
 8001cca:	009b      	lsls	r3, r3, #2
 8001ccc:	4413      	add	r3, r2
 8001cce:	009b      	lsls	r3, r3, #2
 8001cd0:	440b      	add	r3, r1
 8001cd2:	3304      	adds	r3, #4
 8001cd4:	681b      	ldr	r3, [r3, #0]
 8001cd6:	2200      	movs	r2, #0
 8001cd8:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 8001cda:	4a0b      	ldr	r2, [pc, #44]	@ (8001d08 <dmaInit+0x58>)
 8001cdc:	9b01      	ldr	r3, [sp, #4]
 8001cde:	3301      	adds	r3, #1
 8001ce0:	2100      	movs	r1, #0
 8001ce2:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001ce6:	9b01      	ldr	r3, [sp, #4]
 8001ce8:	3301      	adds	r3, #1
 8001cea:	9301      	str	r3, [sp, #4]
 8001cec:	9b01      	ldr	r3, [sp, #4]
 8001cee:	2b0d      	cmp	r3, #13
 8001cf0:	dde8      	ble.n	8001cc4 <dmaInit+0x14>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8001cf2:	4b07      	ldr	r3, [pc, #28]	@ (8001d10 <dmaInit+0x60>)
 8001cf4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001cf8:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8001cfa:	4b06      	ldr	r3, [pc, #24]	@ (8001d14 <dmaInit+0x64>)
 8001cfc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001d00:	605a      	str	r2, [r3, #4]
#endif
}
 8001d02:	bf00      	nop
 8001d04:	b002      	add	sp, #8
 8001d06:	4770      	bx	lr
 8001d08:	2000083c 	.word	0x2000083c
 8001d0c:	0800517c 	.word	0x0800517c
 8001d10:	40020000 	.word	0x40020000
 8001d14:	40020400 	.word	0x40020400
	...

08001d20 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8001d20:	b500      	push	{lr}
 8001d22:	b08b      	sub	sp, #44	@ 0x2c
 8001d24:	9003      	str	r0, [sp, #12]
 8001d26:	9102      	str	r1, [sp, #8]
 8001d28:	9201      	str	r2, [sp, #4]
 8001d2a:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 8001d2c:	f000 fe88 	bl	8002a40 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 8001d30:	9b03      	ldr	r3, [sp, #12]
 8001d32:	2b0d      	cmp	r3, #13
 8001d34:	d804      	bhi.n	8001d40 <dmaStreamAllocI+0x20>
    startid = id;
 8001d36:	9b03      	ldr	r3, [sp, #12]
 8001d38:	9308      	str	r3, [sp, #32]
    endid   = id;
 8001d3a:	9b03      	ldr	r3, [sp, #12]
 8001d3c:	9307      	str	r3, [sp, #28]
 8001d3e:	e01c      	b.n	8001d7a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA_SUPPORTS_DMAMUX == TRUE
  else if (id == STM32_DMA_STREAM_ID_ANY) {
 8001d40:	9b03      	ldr	r3, [sp, #12]
 8001d42:	2b0e      	cmp	r3, #14
 8001d44:	d104      	bne.n	8001d50 <dmaStreamAllocI+0x30>
    startid = 0U;
 8001d46:	2300      	movs	r3, #0
 8001d48:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 8001d4a:	230d      	movs	r3, #13
 8001d4c:	9307      	str	r3, [sp, #28]
 8001d4e:	e014      	b.n	8001d7a <dmaStreamAllocI+0x5a>
  }
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA1) {
 8001d50:	9b03      	ldr	r3, [sp, #12]
 8001d52:	2b0f      	cmp	r3, #15
 8001d54:	d104      	bne.n	8001d60 <dmaStreamAllocI+0x40>
    startid = 0U;
 8001d56:	2300      	movs	r3, #0
 8001d58:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA1_NUM_CHANNELS - 1U;
 8001d5a:	2306      	movs	r3, #6
 8001d5c:	9307      	str	r3, [sp, #28]
 8001d5e:	e00c      	b.n	8001d7a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA2) {
 8001d60:	9b03      	ldr	r3, [sp, #12]
 8001d62:	2b10      	cmp	r3, #16
 8001d64:	d104      	bne.n	8001d70 <dmaStreamAllocI+0x50>
    startid = STM32_DMA1_NUM_CHANNELS;
 8001d66:	2307      	movs	r3, #7
 8001d68:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 8001d6a:	230d      	movs	r3, #13
 8001d6c:	9307      	str	r3, [sp, #28]
 8001d6e:	e004      	b.n	8001d7a <dmaStreamAllocI+0x5a>
  }
#endif
#endif
  else {
    osalDbgCheck(false);
 8001d70:	484f      	ldr	r0, [pc, #316]	@ (8001eb0 <dmaStreamAllocI+0x190>)
 8001d72:	f000 fcc5 	bl	8002700 <chSysHalt>
    return NULL;
 8001d76:	2300      	movs	r3, #0
 8001d78:	e096      	b.n	8001ea8 <dmaStreamAllocI+0x188>
  }

  for (i = startid; i <= endid; i++) {
 8001d7a:	9b08      	ldr	r3, [sp, #32]
 8001d7c:	9309      	str	r3, [sp, #36]	@ 0x24
 8001d7e:	e08d      	b.n	8001e9c <dmaStreamAllocI+0x17c>
    uint32_t mask = (1U << i);
 8001d80:	2201      	movs	r2, #1
 8001d82:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001d84:	fa02 f303 	lsl.w	r3, r2, r3
 8001d88:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 8001d8a:	4b4a      	ldr	r3, [pc, #296]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001d8c:	681a      	ldr	r2, [r3, #0]
 8001d8e:	9b06      	ldr	r3, [sp, #24]
 8001d90:	4013      	ands	r3, r2
 8001d92:	2b00      	cmp	r3, #0
 8001d94:	d17f      	bne.n	8001e96 <dmaStreamAllocI+0x176>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8001d96:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001d98:	4613      	mov	r3, r2
 8001d9a:	009b      	lsls	r3, r3, #2
 8001d9c:	4413      	add	r3, r2
 8001d9e:	009b      	lsls	r3, r3, #2
 8001da0:	4a45      	ldr	r2, [pc, #276]	@ (8001eb8 <dmaStreamAllocI+0x198>)
 8001da2:	4413      	add	r3, r2
 8001da4:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8001da6:	4943      	ldr	r1, [pc, #268]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001da8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001daa:	3301      	adds	r3, #1
 8001dac:	9a01      	ldr	r2, [sp, #4]
 8001dae:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
      dma.streams[i].param = param;
 8001db2:	4a40      	ldr	r2, [pc, #256]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001db4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001db6:	3301      	adds	r3, #1
 8001db8:	00db      	lsls	r3, r3, #3
 8001dba:	4413      	add	r3, r2
 8001dbc:	9a00      	ldr	r2, [sp, #0]
 8001dbe:	605a      	str	r2, [r3, #4]
      dma.allocated_mask  |= mask;
 8001dc0:	4b3c      	ldr	r3, [pc, #240]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001dc2:	681a      	ldr	r2, [r3, #0]
 8001dc4:	9b06      	ldr	r3, [sp, #24]
 8001dc6:	4313      	orrs	r3, r2
 8001dc8:	4a3a      	ldr	r2, [pc, #232]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001dca:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8001dcc:	9b06      	ldr	r3, [sp, #24]
 8001dce:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8001dd2:	2b00      	cmp	r3, #0
 8001dd4:	d00d      	beq.n	8001df2 <dmaStreamAllocI+0xd2>
        rccEnableDMA1(true);
 8001dd6:	4b39      	ldr	r3, [pc, #228]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001dd8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8001dda:	4a38      	ldr	r2, [pc, #224]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001ddc:	f043 0301 	orr.w	r3, r3, #1
 8001de0:	6493      	str	r3, [r2, #72]	@ 0x48
 8001de2:	4b36      	ldr	r3, [pc, #216]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001de4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8001de6:	4a35      	ldr	r2, [pc, #212]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001de8:	f043 0301 	orr.w	r3, r3, #1
 8001dec:	6693      	str	r3, [r2, #104]	@ 0x68
 8001dee:	4b33      	ldr	r3, [pc, #204]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001df0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#if STM32_DMA2_NUM_CHANNELS > 0
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 8001df2:	9b06      	ldr	r3, [sp, #24]
 8001df4:	f403 537e 	and.w	r3, r3, #16256	@ 0x3f80
 8001df8:	2b00      	cmp	r3, #0
 8001dfa:	d00d      	beq.n	8001e18 <dmaStreamAllocI+0xf8>
        rccEnableDMA2(true);
 8001dfc:	4b2f      	ldr	r3, [pc, #188]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001dfe:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8001e00:	4a2e      	ldr	r2, [pc, #184]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e02:	f043 0302 	orr.w	r3, r3, #2
 8001e06:	6493      	str	r3, [r2, #72]	@ 0x48
 8001e08:	4b2c      	ldr	r3, [pc, #176]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e0a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8001e0c:	4a2b      	ldr	r2, [pc, #172]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e0e:	f043 0302 	orr.w	r3, r3, #2
 8001e12:	6693      	str	r3, [r2, #104]	@ 0x68
 8001e14:	4b29      	ldr	r3, [pc, #164]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e16:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

#if (STM32_DMA_SUPPORTS_DMAMUX == TRUE) && defined(rccEnableDMAMUX)
      /* Enabling DMAMUX if present.*/
      if (dma.allocated_mask != 0U) {
 8001e18:	4b26      	ldr	r3, [pc, #152]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001e1a:	681b      	ldr	r3, [r3, #0]
 8001e1c:	2b00      	cmp	r3, #0
 8001e1e:	d00d      	beq.n	8001e3c <dmaStreamAllocI+0x11c>
        rccEnableDMAMUX(true);
 8001e20:	4b26      	ldr	r3, [pc, #152]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e22:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8001e24:	4a25      	ldr	r2, [pc, #148]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e26:	f043 0304 	orr.w	r3, r3, #4
 8001e2a:	6493      	str	r3, [r2, #72]	@ 0x48
 8001e2c:	4b23      	ldr	r3, [pc, #140]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e2e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8001e30:	4a22      	ldr	r2, [pc, #136]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e32:	f043 0304 	orr.w	r3, r3, #4
 8001e36:	6693      	str	r3, [r2, #104]	@ 0x68
 8001e38:	4b20      	ldr	r3, [pc, #128]	@ (8001ebc <dmaStreamAllocI+0x19c>)
 8001e3a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 8001e3c:	9b01      	ldr	r3, [sp, #4]
 8001e3e:	2b00      	cmp	r3, #0
 8001e40:	d012      	beq.n	8001e68 <dmaStreamAllocI+0x148>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8001e42:	4b1c      	ldr	r3, [pc, #112]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001e44:	685a      	ldr	r2, [r3, #4]
 8001e46:	9b05      	ldr	r3, [sp, #20]
 8001e48:	689b      	ldr	r3, [r3, #8]
 8001e4a:	4013      	ands	r3, r2
 8001e4c:	2b00      	cmp	r3, #0
 8001e4e:	d105      	bne.n	8001e5c <dmaStreamAllocI+0x13c>
          nvicEnableVector(dmastp->vector, priority);
 8001e50:	9b05      	ldr	r3, [sp, #20]
 8001e52:	7c9b      	ldrb	r3, [r3, #18]
 8001e54:	9902      	ldr	r1, [sp, #8]
 8001e56:	4618      	mov	r0, r3
 8001e58:	f7fe feb2 	bl	8000bc0 <nvicEnableVector>
        }
        dma.isr_mask |= mask;
 8001e5c:	4b15      	ldr	r3, [pc, #84]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001e5e:	685a      	ldr	r2, [r3, #4]
 8001e60:	9b06      	ldr	r3, [sp, #24]
 8001e62:	4313      	orrs	r3, r2
 8001e64:	4a13      	ldr	r2, [pc, #76]	@ (8001eb4 <dmaStreamAllocI+0x194>)
 8001e66:	6053      	str	r3, [r2, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 8001e68:	9b05      	ldr	r3, [sp, #20]
 8001e6a:	685b      	ldr	r3, [r3, #4]
 8001e6c:	681a      	ldr	r2, [r3, #0]
 8001e6e:	9b05      	ldr	r3, [sp, #20]
 8001e70:	685b      	ldr	r3, [r3, #4]
 8001e72:	f022 020f 	bic.w	r2, r2, #15
 8001e76:	601a      	str	r2, [r3, #0]
 8001e78:	9b05      	ldr	r3, [sp, #20]
 8001e7a:	7c1b      	ldrb	r3, [r3, #16]
 8001e7c:	461a      	mov	r2, r3
 8001e7e:	230e      	movs	r3, #14
 8001e80:	fa03 f202 	lsl.w	r2, r3, r2
 8001e84:	9b05      	ldr	r3, [sp, #20]
 8001e86:	681b      	ldr	r3, [r3, #0]
 8001e88:	605a      	str	r2, [r3, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001e8a:	9b05      	ldr	r3, [sp, #20]
 8001e8c:	685b      	ldr	r3, [r3, #4]
 8001e8e:	2200      	movs	r2, #0
 8001e90:	601a      	str	r2, [r3, #0]

      return dmastp;
 8001e92:	9b05      	ldr	r3, [sp, #20]
 8001e94:	e008      	b.n	8001ea8 <dmaStreamAllocI+0x188>
  for (i = startid; i <= endid; i++) {
 8001e96:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001e98:	3301      	adds	r3, #1
 8001e9a:	9309      	str	r3, [sp, #36]	@ 0x24
 8001e9c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001e9e:	9b07      	ldr	r3, [sp, #28]
 8001ea0:	429a      	cmp	r2, r3
 8001ea2:	f67f af6d 	bls.w	8001d80 <dmaStreamAllocI+0x60>
    }
  }

  return NULL;
 8001ea6:	2300      	movs	r3, #0
}
 8001ea8:	4618      	mov	r0, r3
 8001eaa:	b00b      	add	sp, #44	@ 0x2c
 8001eac:	f85d fb04 	ldr.w	pc, [sp], #4
 8001eb0:	08005294 	.word	0x08005294
 8001eb4:	2000083c 	.word	0x2000083c
 8001eb8:	0800517c 	.word	0x0800517c
 8001ebc:	40021000 	.word	0x40021000

08001ec0 <dmaServeInterrupt>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
 8001ec0:	b500      	push	{lr}
 8001ec2:	b085      	sub	sp, #20
 8001ec4:	9001      	str	r0, [sp, #4]
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;
 8001ec6:	9b01      	ldr	r3, [sp, #4]
 8001ec8:	7c5b      	ldrb	r3, [r3, #17]
 8001eca:	9303      	str	r3, [sp, #12]

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001ecc:	9b01      	ldr	r3, [sp, #4]
 8001ece:	681b      	ldr	r3, [r3, #0]
 8001ed0:	681b      	ldr	r3, [r3, #0]
 8001ed2:	9a01      	ldr	r2, [sp, #4]
 8001ed4:	7c12      	ldrb	r2, [r2, #16]
 8001ed6:	40d3      	lsrs	r3, r2
 8001ed8:	f003 030e 	and.w	r3, r3, #14
 8001edc:	9302      	str	r3, [sp, #8]
  if (flags & dmastp->channel->CCR) {
 8001ede:	9b01      	ldr	r3, [sp, #4]
 8001ee0:	685b      	ldr	r3, [r3, #4]
 8001ee2:	681a      	ldr	r2, [r3, #0]
 8001ee4:	9b02      	ldr	r3, [sp, #8]
 8001ee6:	4013      	ands	r3, r2
 8001ee8:	2b00      	cmp	r3, #0
 8001eea:	d01c      	beq.n	8001f26 <dmaServeInterrupt+0x66>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8001eec:	9b01      	ldr	r3, [sp, #4]
 8001eee:	7c1b      	ldrb	r3, [r3, #16]
 8001ef0:	4619      	mov	r1, r3
 8001ef2:	9b01      	ldr	r3, [sp, #4]
 8001ef4:	681b      	ldr	r3, [r3, #0]
 8001ef6:	9a02      	ldr	r2, [sp, #8]
 8001ef8:	408a      	lsls	r2, r1
 8001efa:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8001efc:	4a0c      	ldr	r2, [pc, #48]	@ (8001f30 <dmaServeInterrupt+0x70>)
 8001efe:	9b03      	ldr	r3, [sp, #12]
 8001f00:	3301      	adds	r3, #1
 8001f02:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8001f06:	2b00      	cmp	r3, #0
 8001f08:	d00d      	beq.n	8001f26 <dmaServeInterrupt+0x66>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8001f0a:	4a09      	ldr	r2, [pc, #36]	@ (8001f30 <dmaServeInterrupt+0x70>)
 8001f0c:	9b03      	ldr	r3, [sp, #12]
 8001f0e:	3301      	adds	r3, #1
 8001f10:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8001f14:	4906      	ldr	r1, [pc, #24]	@ (8001f30 <dmaServeInterrupt+0x70>)
 8001f16:	9b03      	ldr	r3, [sp, #12]
 8001f18:	3301      	adds	r3, #1
 8001f1a:	00db      	lsls	r3, r3, #3
 8001f1c:	440b      	add	r3, r1
 8001f1e:	685b      	ldr	r3, [r3, #4]
 8001f20:	9902      	ldr	r1, [sp, #8]
 8001f22:	4618      	mov	r0, r3
 8001f24:	4790      	blx	r2
    }
  }
}
 8001f26:	bf00      	nop
 8001f28:	b005      	add	sp, #20
 8001f2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f2e:	bf00      	nop
 8001f30:	2000083c 	.word	0x2000083c
	...

08001f40 <dmaSetRequestSource>:
 * @param[in] dmastp    pointer to a @p stm32_dma_stream_t structure
 * @param[in] per       peripheral identifier
 *
 * @special
 */
void dmaSetRequestSource(const stm32_dma_stream_t *dmastp, uint32_t per) {
 8001f40:	b500      	push	{lr}
 8001f42:	b083      	sub	sp, #12
 8001f44:	9001      	str	r0, [sp, #4]
 8001f46:	9100      	str	r1, [sp, #0]

  osalDbgCheck(per < 256U);
 8001f48:	9b00      	ldr	r3, [sp, #0]
 8001f4a:	2bff      	cmp	r3, #255	@ 0xff
 8001f4c:	bf8c      	ite	hi
 8001f4e:	2301      	movhi	r3, #1
 8001f50:	2300      	movls	r3, #0
 8001f52:	b2db      	uxtb	r3, r3
 8001f54:	2b00      	cmp	r3, #0
 8001f56:	d002      	beq.n	8001f5e <dmaSetRequestSource+0x1e>
 8001f58:	4805      	ldr	r0, [pc, #20]	@ (8001f70 <dmaSetRequestSource+0x30>)
 8001f5a:	f000 fbd1 	bl	8002700 <chSysHalt>

  dmastp->mux->CCR = per;
 8001f5e:	9b01      	ldr	r3, [sp, #4]
 8001f60:	68db      	ldr	r3, [r3, #12]
 8001f62:	9a00      	ldr	r2, [sp, #0]
 8001f64:	601a      	str	r2, [r3, #0]
}
 8001f66:	bf00      	nop
 8001f68:	b003      	add	sp, #12
 8001f6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f6e:	bf00      	nop
 8001f70:	080052a4 	.word	0x080052a4
	...

08001f80 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8001f80:	bf00      	nop
 8001f82:	4770      	bx	lr
	...

08001f90 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001f90:	b090      	sub	sp, #64	@ 0x40
 8001f92:	9003      	str	r0, [sp, #12]
 8001f94:	9102      	str	r1, [sp, #8]
 8001f96:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001f98:	9b01      	ldr	r3, [sp, #4]
 8001f9a:	f003 0303 	and.w	r3, r3, #3
 8001f9e:	930f      	str	r3, [sp, #60]	@ 0x3c
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001fa0:	9b01      	ldr	r3, [sp, #4]
 8001fa2:	089b      	lsrs	r3, r3, #2
 8001fa4:	f003 0301 	and.w	r3, r3, #1
 8001fa8:	930e      	str	r3, [sp, #56]	@ 0x38
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001faa:	9b01      	ldr	r3, [sp, #4]
 8001fac:	08db      	lsrs	r3, r3, #3
 8001fae:	f003 0303 	and.w	r3, r3, #3
 8001fb2:	930d      	str	r3, [sp, #52]	@ 0x34
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001fb4:	9b01      	ldr	r3, [sp, #4]
 8001fb6:	095b      	lsrs	r3, r3, #5
 8001fb8:	f003 0303 	and.w	r3, r3, #3
 8001fbc:	930c      	str	r3, [sp, #48]	@ 0x30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001fbe:	9b01      	ldr	r3, [sp, #4]
 8001fc0:	09db      	lsrs	r3, r3, #7
 8001fc2:	f003 030f 	and.w	r3, r3, #15
 8001fc6:	9309      	str	r3, [sp, #36]	@ 0x24
  uint32_t ascr    = (mode & PAL_STM32_ASCR_MASK) >> 11;
 8001fc8:	9b01      	ldr	r3, [sp, #4]
 8001fca:	0adb      	lsrs	r3, r3, #11
 8001fcc:	f003 0301 	and.w	r3, r3, #1
 8001fd0:	930b      	str	r3, [sp, #44]	@ 0x2c
  uint32_t lockr   = (mode & PAL_STM32_LOCKR_MASK) >> 12;
 8001fd2:	9b01      	ldr	r3, [sp, #4]
 8001fd4:	0b1b      	lsrs	r3, r3, #12
 8001fd6:	f003 0301 	and.w	r3, r3, #1
 8001fda:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8001fdc:	2300      	movs	r3, #0
 8001fde:	930a      	str	r3, [sp, #40]	@ 0x28
  while (true) {
    if ((mask & 1) != 0) {
 8001fe0:	9b02      	ldr	r3, [sp, #8]
 8001fe2:	f003 0301 	and.w	r3, r3, #1
 8001fe6:	2b00      	cmp	r3, #0
 8001fe8:	f000 808c 	beq.w	8002104 <_pal_lld_setgroupmode+0x174>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001fec:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8001fee:	f003 0307 	and.w	r3, r3, #7
 8001ff2:	009b      	lsls	r3, r3, #2
 8001ff4:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001ff6:	fa02 f303 	lsl.w	r3, r2, r3
 8001ffa:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8001ffc:	2201      	movs	r2, #1
 8001ffe:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002000:	fa02 f303 	lsl.w	r3, r2, r3
 8002004:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8002006:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002008:	005b      	lsls	r3, r3, #1
 800200a:	2203      	movs	r2, #3
 800200c:	fa02 f303 	lsl.w	r3, r2, r3
 8002010:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8002012:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002014:	f003 0307 	and.w	r3, r3, #7
 8002018:	009b      	lsls	r3, r3, #2
 800201a:	220f      	movs	r2, #15
 800201c:	fa02 f303 	lsl.w	r3, r2, r3
 8002020:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8002022:	9b03      	ldr	r3, [sp, #12]
 8002024:	685a      	ldr	r2, [r3, #4]
 8002026:	9b06      	ldr	r3, [sp, #24]
 8002028:	43db      	mvns	r3, r3
 800202a:	401a      	ands	r2, r3
 800202c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 800202e:	431a      	orrs	r2, r3
 8002030:	9b03      	ldr	r3, [sp, #12]
 8002032:	605a      	str	r2, [r3, #4]
      port->ASCR    = (port->ASCR & ~m1) | ascr;
 8002034:	9b03      	ldr	r3, [sp, #12]
 8002036:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8002038:	9b06      	ldr	r3, [sp, #24]
 800203a:	43db      	mvns	r3, r3
 800203c:	401a      	ands	r2, r3
 800203e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8002040:	431a      	orrs	r2, r3
 8002042:	9b03      	ldr	r3, [sp, #12]
 8002044:	62da      	str	r2, [r3, #44]	@ 0x2c
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8002046:	9b03      	ldr	r3, [sp, #12]
 8002048:	689a      	ldr	r2, [r3, #8]
 800204a:	9b05      	ldr	r3, [sp, #20]
 800204c:	43db      	mvns	r3, r3
 800204e:	401a      	ands	r2, r3
 8002050:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8002052:	431a      	orrs	r2, r3
 8002054:	9b03      	ldr	r3, [sp, #12]
 8002056:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8002058:	9b03      	ldr	r3, [sp, #12]
 800205a:	68da      	ldr	r2, [r3, #12]
 800205c:	9b05      	ldr	r3, [sp, #20]
 800205e:	43db      	mvns	r3, r3
 8002060:	401a      	ands	r2, r3
 8002062:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8002064:	431a      	orrs	r2, r3
 8002066:	9b03      	ldr	r3, [sp, #12]
 8002068:	60da      	str	r2, [r3, #12]
       if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800206a:	9b01      	ldr	r3, [sp, #4]
 800206c:	f003 0303 	and.w	r3, r3, #3
 8002070:	2b02      	cmp	r3, #2
 8002072:	d11f      	bne.n	80020b4 <_pal_lld_setgroupmode+0x124>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8002074:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002076:	2b07      	cmp	r3, #7
 8002078:	d809      	bhi.n	800208e <_pal_lld_setgroupmode+0xfe>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800207a:	9b03      	ldr	r3, [sp, #12]
 800207c:	6a1a      	ldr	r2, [r3, #32]
 800207e:	9b04      	ldr	r3, [sp, #16]
 8002080:	43db      	mvns	r3, r3
 8002082:	401a      	ands	r2, r3
 8002084:	9b07      	ldr	r3, [sp, #28]
 8002086:	431a      	orrs	r2, r3
 8002088:	9b03      	ldr	r3, [sp, #12]
 800208a:	621a      	str	r2, [r3, #32]
 800208c:	e008      	b.n	80020a0 <_pal_lld_setgroupmode+0x110>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800208e:	9b03      	ldr	r3, [sp, #12]
 8002090:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8002092:	9b04      	ldr	r3, [sp, #16]
 8002094:	43db      	mvns	r3, r3
 8002096:	401a      	ands	r2, r3
 8002098:	9b07      	ldr	r3, [sp, #28]
 800209a:	431a      	orrs	r2, r3
 800209c:	9b03      	ldr	r3, [sp, #12]
 800209e:	625a      	str	r2, [r3, #36]	@ 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 80020a0:	9b03      	ldr	r3, [sp, #12]
 80020a2:	681a      	ldr	r2, [r3, #0]
 80020a4:	9b05      	ldr	r3, [sp, #20]
 80020a6:	43db      	mvns	r3, r3
 80020a8:	401a      	ands	r2, r3
 80020aa:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80020ac:	431a      	orrs	r2, r3
 80020ae:	9b03      	ldr	r3, [sp, #12]
 80020b0:	601a      	str	r2, [r3, #0]
 80020b2:	e01e      	b.n	80020f2 <_pal_lld_setgroupmode+0x162>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80020b4:	9b03      	ldr	r3, [sp, #12]
 80020b6:	681a      	ldr	r2, [r3, #0]
 80020b8:	9b05      	ldr	r3, [sp, #20]
 80020ba:	43db      	mvns	r3, r3
 80020bc:	401a      	ands	r2, r3
 80020be:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80020c0:	431a      	orrs	r2, r3
 80020c2:	9b03      	ldr	r3, [sp, #12]
 80020c4:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 80020c6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80020c8:	2b07      	cmp	r3, #7
 80020ca:	d809      	bhi.n	80020e0 <_pal_lld_setgroupmode+0x150>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80020cc:	9b03      	ldr	r3, [sp, #12]
 80020ce:	6a1a      	ldr	r2, [r3, #32]
 80020d0:	9b04      	ldr	r3, [sp, #16]
 80020d2:	43db      	mvns	r3, r3
 80020d4:	401a      	ands	r2, r3
 80020d6:	9b07      	ldr	r3, [sp, #28]
 80020d8:	431a      	orrs	r2, r3
 80020da:	9b03      	ldr	r3, [sp, #12]
 80020dc:	621a      	str	r2, [r3, #32]
 80020de:	e008      	b.n	80020f2 <_pal_lld_setgroupmode+0x162>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80020e0:	9b03      	ldr	r3, [sp, #12]
 80020e2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80020e4:	9b04      	ldr	r3, [sp, #16]
 80020e6:	43db      	mvns	r3, r3
 80020e8:	401a      	ands	r2, r3
 80020ea:	9b07      	ldr	r3, [sp, #28]
 80020ec:	431a      	orrs	r2, r3
 80020ee:	9b03      	ldr	r3, [sp, #12]
 80020f0:	625a      	str	r2, [r3, #36]	@ 0x24
      }
      port->LOCKR   = (port->LOCKR & ~m1) | lockr;
 80020f2:	9b03      	ldr	r3, [sp, #12]
 80020f4:	69da      	ldr	r2, [r3, #28]
 80020f6:	9b06      	ldr	r3, [sp, #24]
 80020f8:	43db      	mvns	r3, r3
 80020fa:	401a      	ands	r2, r3
 80020fc:	9b08      	ldr	r3, [sp, #32]
 80020fe:	431a      	orrs	r2, r3
 8002100:	9b03      	ldr	r3, [sp, #12]
 8002102:	61da      	str	r2, [r3, #28]
    }
    mask >>= 1;
 8002104:	9b02      	ldr	r3, [sp, #8]
 8002106:	085b      	lsrs	r3, r3, #1
 8002108:	9302      	str	r3, [sp, #8]
    if (!mask)
 800210a:	9b02      	ldr	r3, [sp, #8]
 800210c:	2b00      	cmp	r3, #0
 800210e:	d012      	beq.n	8002136 <_pal_lld_setgroupmode+0x1a6>
      return;
    otyper <<= 1;
 8002110:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8002112:	005b      	lsls	r3, r3, #1
 8002114:	930e      	str	r3, [sp, #56]	@ 0x38
    ascr <<= 1;
 8002116:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8002118:	005b      	lsls	r3, r3, #1
 800211a:	930b      	str	r3, [sp, #44]	@ 0x2c
    ospeedr <<= 2;
 800211c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800211e:	009b      	lsls	r3, r3, #2
 8002120:	930d      	str	r3, [sp, #52]	@ 0x34
    pupdr <<= 2;
 8002122:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8002124:	009b      	lsls	r3, r3, #2
 8002126:	930c      	str	r3, [sp, #48]	@ 0x30
    moder <<= 2;
 8002128:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800212a:	009b      	lsls	r3, r3, #2
 800212c:	930f      	str	r3, [sp, #60]	@ 0x3c
    bit++;
 800212e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002130:	3301      	adds	r3, #1
 8002132:	930a      	str	r3, [sp, #40]	@ 0x28
    if ((mask & 1) != 0) {
 8002134:	e754      	b.n	8001fe0 <_pal_lld_setgroupmode+0x50>
      return;
 8002136:	bf00      	nop
  }
}
 8002138:	b010      	add	sp, #64	@ 0x40
 800213a:	4770      	bx	lr
 800213c:	0000      	movs	r0, r0
	...

08002140 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 8002140:	b500      	push	{lr}
 8002142:	b083      	sub	sp, #12
 8002144:	2330      	movs	r3, #48	@ 0x30
 8002146:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002148:	9b01      	ldr	r3, [sp, #4]
 800214a:	f383 8811 	msr	BASEPRI, r3
}
 800214e:	bf00      	nop
}
 8002150:	bf00      	nop
}
 8002152:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002154:	f000 fbac 	bl	80028b0 <__dbg_check_lock_from_isr>
}
 8002158:	bf00      	nop
 800215a:	b003      	add	sp, #12
 800215c:	f85d fb04 	ldr.w	pc, [sp], #4

08002160 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8002160:	b500      	push	{lr}
 8002162:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002164:	f000 fbcc 	bl	8002900 <__dbg_check_unlock_from_isr>
 8002168:	2300      	movs	r3, #0
 800216a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800216c:	9b01      	ldr	r3, [sp, #4]
 800216e:	f383 8811 	msr	BASEPRI, r3
}
 8002172:	bf00      	nop
}
 8002174:	bf00      	nop
}
 8002176:	bf00      	nop
}
 8002178:	bf00      	nop
 800217a:	b003      	add	sp, #12
 800217c:	f85d fb04 	ldr.w	pc, [sp], #4

08002180 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 8002180:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002182:	f7ff ffdd 	bl	8002140 <chSysLockFromISR.lto_priv.1>
}
 8002186:	bf00      	nop
 8002188:	bd08      	pop	{r3, pc}
 800218a:	bf00      	nop
 800218c:	0000      	movs	r0, r0
	...

08002190 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 8002190:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002192:	f7ff ffe5 	bl	8002160 <chSysUnlockFromISR.lto_priv.1>
}
 8002196:	bf00      	nop
 8002198:	bd08      	pop	{r3, pc}
 800219a:	bf00      	nop
 800219c:	0000      	movs	r0, r0
	...

080021a0 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 80021a0:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 80021a2:	f000 fae5 	bl	8002770 <chSysTimerHandlerI>
}
 80021a6:	bf00      	nop
 80021a8:	bd08      	pop	{r3, pc}
 80021aa:	bf00      	nop
 80021ac:	0000      	movs	r0, r0
	...

080021b0 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80021b0:	4b1b      	ldr	r3, [pc, #108]	@ (8002220 <st_lld_init+0x70>)
 80021b2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80021b4:	4a1a      	ldr	r2, [pc, #104]	@ (8002220 <st_lld_init+0x70>)
 80021b6:	f043 0301 	orr.w	r3, r3, #1
 80021ba:	6593      	str	r3, [r2, #88]	@ 0x58
 80021bc:	4b18      	ldr	r3, [pc, #96]	@ (8002220 <st_lld_init+0x70>)
 80021be:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80021c0:	4a17      	ldr	r2, [pc, #92]	@ (8002220 <st_lld_init+0x70>)
 80021c2:	f043 0301 	orr.w	r3, r3, #1
 80021c6:	6793      	str	r3, [r2, #120]	@ 0x78
 80021c8:	4b15      	ldr	r3, [pc, #84]	@ (8002220 <st_lld_init+0x70>)
 80021ca:	6f9b      	ldr	r3, [r3, #120]	@ 0x78

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80021cc:	4b15      	ldr	r3, [pc, #84]	@ (8002224 <st_lld_init+0x74>)
 80021ce:	689b      	ldr	r3, [r3, #8]
 80021d0:	4a14      	ldr	r2, [pc, #80]	@ (8002224 <st_lld_init+0x74>)
 80021d2:	f043 0301 	orr.w	r3, r3, #1
 80021d6:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80021d8:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80021dc:	f642 62df 	movw	r2, #11999	@ 0x2edf
 80021e0:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80021e2:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80021e6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80021ea:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80021ec:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80021f0:	2200      	movs	r2, #0
 80021f2:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80021f4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80021f8:	2200      	movs	r2, #0
 80021fa:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 80021fc:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002200:	2200      	movs	r2, #0
 8002202:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002204:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002208:	2200      	movs	r2, #0
 800220a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800220c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002210:	2201      	movs	r2, #1
 8002212:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002214:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002218:	2201      	movs	r2, #1
 800221a:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800221c:	bf00      	nop
 800221e:	4770      	bx	lr
 8002220:	40021000 	.word	0x40021000
 8002224:	e0042000 	.word	0xe0042000
	...

08002230 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8002230:	b500      	push	{lr}
 8002232:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8002234:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002238:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 800223a:	9b01      	ldr	r3, [sp, #4]
 800223c:	691b      	ldr	r3, [r3, #16]
 800223e:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002240:	9b01      	ldr	r3, [sp, #4]
 8002242:	68db      	ldr	r3, [r3, #12]
 8002244:	b2db      	uxtb	r3, r3
 8002246:	9a00      	ldr	r2, [sp, #0]
 8002248:	4013      	ands	r3, r2
 800224a:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 800224c:	9b00      	ldr	r3, [sp, #0]
 800224e:	43da      	mvns	r2, r3
 8002250:	9b01      	ldr	r3, [sp, #4]
 8002252:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8002254:	9b00      	ldr	r3, [sp, #0]
 8002256:	f003 0302 	and.w	r3, r3, #2
 800225a:	2b00      	cmp	r3, #0
 800225c:	d005      	beq.n	800226a <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 800225e:	f7ff ff8f 	bl	8002180 <osalSysLockFromISR.lto_priv.1>
    osalOsTimerHandlerI();
 8002262:	f7ff ff9d 	bl	80021a0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8002266:	f7ff ff93 	bl	8002190 <osalSysUnlockFromISR.lto_priv.1>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 800226a:	bf00      	nop
 800226c:	b003      	add	sp, #12
 800226e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002272:	bf00      	nop
	...

08002280 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8002280:	b508      	push	{r3, lr}
  gptObjectInit(&GPTD3);
#endif

#if STM32_GPT_USE_TIM4
  /* Driver initialization.*/
  GPTD4.tim = STM32_TIM4;
 8002282:	4b04      	ldr	r3, [pc, #16]	@ (8002294 <gpt_lld_init+0x14>)
 8002284:	4a04      	ldr	r2, [pc, #16]	@ (8002298 <gpt_lld_init+0x18>)
 8002286:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD4);
 8002288:	4802      	ldr	r0, [pc, #8]	@ (8002294 <gpt_lld_init+0x14>)
 800228a:	f7fe fb81 	bl	8000990 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 800228e:	bf00      	nop
 8002290:	bd08      	pop	{r3, pc}
 8002292:	bf00      	nop
 8002294:	200008b4 	.word	0x200008b4
 8002298:	40000800 	.word	0x40000800
 800229c:	00000000 	.word	0x00000000

080022a0 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 80022a0:	b500      	push	{lr}
 80022a2:	b085      	sub	sp, #20
 80022a4:	9001      	str	r0, [sp, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 80022a6:	9b01      	ldr	r3, [sp, #4]
 80022a8:	781b      	ldrb	r3, [r3, #0]
 80022aa:	2b01      	cmp	r3, #1
 80022ac:	d122      	bne.n	80022f4 <gpt_lld_start+0x54>
#endif
    }
#endif

#if STM32_GPT_USE_TIM4
    if (&GPTD4 == gptp) {
 80022ae:	9b01      	ldr	r3, [sp, #4]
 80022b0:	4a30      	ldr	r2, [pc, #192]	@ (8002374 <gpt_lld_start+0xd4>)
 80022b2:	4293      	cmp	r3, r2
 80022b4:	d11e      	bne.n	80022f4 <gpt_lld_start+0x54>
      rccEnableTIM4(true);
 80022b6:	4b30      	ldr	r3, [pc, #192]	@ (8002378 <gpt_lld_start+0xd8>)
 80022b8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80022ba:	4a2f      	ldr	r2, [pc, #188]	@ (8002378 <gpt_lld_start+0xd8>)
 80022bc:	f043 0304 	orr.w	r3, r3, #4
 80022c0:	6593      	str	r3, [r2, #88]	@ 0x58
 80022c2:	4b2d      	ldr	r3, [pc, #180]	@ (8002378 <gpt_lld_start+0xd8>)
 80022c4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80022c6:	4a2c      	ldr	r2, [pc, #176]	@ (8002378 <gpt_lld_start+0xd8>)
 80022c8:	f043 0304 	orr.w	r3, r3, #4
 80022cc:	6793      	str	r3, [r2, #120]	@ 0x78
 80022ce:	4b2a      	ldr	r3, [pc, #168]	@ (8002378 <gpt_lld_start+0xd8>)
 80022d0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
      rccResetTIM4();
 80022d2:	4b29      	ldr	r3, [pc, #164]	@ (8002378 <gpt_lld_start+0xd8>)
 80022d4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80022d6:	4a28      	ldr	r2, [pc, #160]	@ (8002378 <gpt_lld_start+0xd8>)
 80022d8:	f043 0304 	orr.w	r3, r3, #4
 80022dc:	6393      	str	r3, [r2, #56]	@ 0x38
 80022de:	4b26      	ldr	r3, [pc, #152]	@ (8002378 <gpt_lld_start+0xd8>)
 80022e0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80022e2:	4a25      	ldr	r2, [pc, #148]	@ (8002378 <gpt_lld_start+0xd8>)
 80022e4:	f023 0304 	bic.w	r3, r3, #4
 80022e8:	6393      	str	r3, [r2, #56]	@ 0x38
 80022ea:	4b23      	ldr	r3, [pc, #140]	@ (8002378 <gpt_lld_start+0xd8>)
 80022ec:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_GPT_TIM4_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM4CLK)
      gptp->clock = STM32_TIM4CLK;
#else
      gptp->clock = STM32_TIMCLK1;
 80022ee:	9b01      	ldr	r3, [sp, #4]
 80022f0:	4a22      	ldr	r2, [pc, #136]	@ (800237c <gpt_lld_start+0xdc>)
 80022f2:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 80022f4:	9b01      	ldr	r3, [sp, #4]
 80022f6:	689a      	ldr	r2, [r3, #8]
 80022f8:	9b01      	ldr	r3, [sp, #4]
 80022fa:	685b      	ldr	r3, [r3, #4]
 80022fc:	681b      	ldr	r3, [r3, #0]
 80022fe:	fbb2 f3f3 	udiv	r3, r2, r3
 8002302:	b29b      	uxth	r3, r3
 8002304:	3b01      	subs	r3, #1
 8002306:	f8ad 300e 	strh.w	r3, [sp, #14]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
 800230a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800230e:	3301      	adds	r3, #1
 8002310:	461a      	mov	r2, r3
 8002312:	9b01      	ldr	r3, [sp, #4]
 8002314:	685b      	ldr	r3, [r3, #4]
 8002316:	681b      	ldr	r3, [r3, #0]
 8002318:	fb03 f202 	mul.w	r2, r3, r2
 800231c:	9b01      	ldr	r3, [sp, #4]
 800231e:	689b      	ldr	r3, [r3, #8]
 8002320:	429a      	cmp	r2, r3
 8002322:	bf14      	ite	ne
 8002324:	2301      	movne	r3, #1
 8002326:	2300      	moveq	r3, #0
 8002328:	b2db      	uxtb	r3, r3
 800232a:	2b00      	cmp	r3, #0
 800232c:	d002      	beq.n	8002334 <gpt_lld_start+0x94>
 800232e:	4814      	ldr	r0, [pc, #80]	@ (8002380 <gpt_lld_start+0xe0>)
 8002330:	f000 f9e6 	bl	8002700 <chSysHalt>
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0U;                         /* Initially stopped.       */
 8002334:	9b01      	ldr	r3, [sp, #4]
 8002336:	68db      	ldr	r3, [r3, #12]
 8002338:	2200      	movs	r2, #0
 800233a:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 800233c:	9b01      	ldr	r3, [sp, #4]
 800233e:	685a      	ldr	r2, [r3, #4]
 8002340:	9b01      	ldr	r3, [sp, #4]
 8002342:	68db      	ldr	r3, [r3, #12]
 8002344:	6892      	ldr	r2, [r2, #8]
 8002346:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8002348:	9b01      	ldr	r3, [sp, #4]
 800234a:	68db      	ldr	r3, [r3, #12]
 800234c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 8002350:	629a      	str	r2, [r3, #40]	@ 0x28
  gptp->tim->SR   = 0U;                         /* Clear pending IRQs.      */
 8002352:	9b01      	ldr	r3, [sp, #4]
 8002354:	68db      	ldr	r3, [r3, #12]
 8002356:	2200      	movs	r2, #0
 8002358:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 800235a:	9b01      	ldr	r3, [sp, #4]
 800235c:	685b      	ldr	r3, [r3, #4]
 800235e:	68da      	ldr	r2, [r3, #12]
 8002360:	9b01      	ldr	r3, [sp, #4]
 8002362:	68db      	ldr	r3, [r3, #12]
 8002364:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002368:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 800236a:	bf00      	nop
 800236c:	b005      	add	sp, #20
 800236e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002372:	bf00      	nop
 8002374:	200008b4 	.word	0x200008b4
 8002378:	40021000 	.word	0x40021000
 800237c:	07270e00 	.word	0x07270e00
 8002380:	080052b8 	.word	0x080052b8
	...

08002390 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 8002390:	b082      	sub	sp, #8
 8002392:	9001      	str	r0, [sp, #4]
 8002394:	9100      	str	r1, [sp, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8002396:	9b01      	ldr	r3, [sp, #4]
 8002398:	68db      	ldr	r3, [r3, #12]
 800239a:	9a00      	ldr	r2, [sp, #0]
 800239c:	3a01      	subs	r2, #1
 800239e:	62da      	str	r2, [r3, #44]	@ 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 80023a0:	9b01      	ldr	r3, [sp, #4]
 80023a2:	68db      	ldr	r3, [r3, #12]
 80023a4:	2201      	movs	r2, #1
 80023a6:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0U;                          /* Reset counter.           */
 80023a8:	9b01      	ldr	r3, [sp, #4]
 80023aa:	68db      	ldr	r3, [r3, #12]
 80023ac:	2200      	movs	r2, #0
 80023ae:	625a      	str	r2, [r3, #36]	@ 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 80023b0:	9b01      	ldr	r3, [sp, #4]
 80023b2:	68db      	ldr	r3, [r3, #12]
 80023b4:	2200      	movs	r2, #0
 80023b6:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 80023b8:	9b01      	ldr	r3, [sp, #4]
 80023ba:	685b      	ldr	r3, [r3, #4]
 80023bc:	685b      	ldr	r3, [r3, #4]
 80023be:	2b00      	cmp	r3, #0
 80023c0:	d007      	beq.n	80023d2 <gpt_lld_start_timer+0x42>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 80023c2:	9b01      	ldr	r3, [sp, #4]
 80023c4:	68db      	ldr	r3, [r3, #12]
 80023c6:	68da      	ldr	r2, [r3, #12]
 80023c8:	9b01      	ldr	r3, [sp, #4]
 80023ca:	68db      	ldr	r3, [r3, #12]
 80023cc:	f042 0201 	orr.w	r2, r2, #1
 80023d0:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 80023d2:	9b01      	ldr	r3, [sp, #4]
 80023d4:	68db      	ldr	r3, [r3, #12]
 80023d6:	2285      	movs	r2, #133	@ 0x85
 80023d8:	601a      	str	r2, [r3, #0]
}
 80023da:	bf00      	nop
 80023dc:	b002      	add	sp, #8
 80023de:	4770      	bx	lr

080023e0 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 80023e0:	b082      	sub	sp, #8
 80023e2:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1 = 0U;                          /* Initially stopped.       */
 80023e4:	9b01      	ldr	r3, [sp, #4]
 80023e6:	68db      	ldr	r3, [r3, #12]
 80023e8:	2200      	movs	r2, #0
 80023ea:	601a      	str	r2, [r3, #0]
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 80023ec:	9b01      	ldr	r3, [sp, #4]
 80023ee:	68db      	ldr	r3, [r3, #12]
 80023f0:	2200      	movs	r2, #0
 80023f2:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 80023f4:	9b01      	ldr	r3, [sp, #4]
 80023f6:	68db      	ldr	r3, [r3, #12]
 80023f8:	68da      	ldr	r2, [r3, #12]
 80023fa:	9b01      	ldr	r3, [sp, #4]
 80023fc:	68db      	ldr	r3, [r3, #12]
 80023fe:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002402:	60da      	str	r2, [r3, #12]
}
 8002404:	bf00      	nop
 8002406:	b002      	add	sp, #8
 8002408:	4770      	bx	lr
 800240a:	bf00      	nop
 800240c:	0000      	movs	r0, r0
	...

08002410 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 8002410:	b500      	push	{lr}
 8002412:	b085      	sub	sp, #20
 8002414:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 8002416:	9b01      	ldr	r3, [sp, #4]
 8002418:	68db      	ldr	r3, [r3, #12]
 800241a:	691b      	ldr	r3, [r3, #16]
 800241c:	9303      	str	r3, [sp, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800241e:	9b01      	ldr	r3, [sp, #4]
 8002420:	68db      	ldr	r3, [r3, #12]
 8002422:	68db      	ldr	r3, [r3, #12]
 8002424:	b2db      	uxtb	r3, r3
 8002426:	9a03      	ldr	r2, [sp, #12]
 8002428:	4013      	ands	r3, r2
 800242a:	9303      	str	r3, [sp, #12]
  gptp->tim->SR = ~sr;
 800242c:	9b01      	ldr	r3, [sp, #4]
 800242e:	68db      	ldr	r3, [r3, #12]
 8002430:	9a03      	ldr	r2, [sp, #12]
 8002432:	43d2      	mvns	r2, r2
 8002434:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8002436:	9b03      	ldr	r3, [sp, #12]
 8002438:	f003 0301 	and.w	r3, r3, #1
 800243c:	2b00      	cmp	r3, #0
 800243e:	d013      	beq.n	8002468 <gpt_lld_serve_interrupt+0x58>
    _gpt_isr_invoke_cb(gptp);
 8002440:	9b01      	ldr	r3, [sp, #4]
 8002442:	781b      	ldrb	r3, [r3, #0]
 8002444:	2b04      	cmp	r3, #4
 8002446:	d105      	bne.n	8002454 <gpt_lld_serve_interrupt+0x44>
 8002448:	9b01      	ldr	r3, [sp, #4]
 800244a:	2202      	movs	r2, #2
 800244c:	701a      	strb	r2, [r3, #0]
 800244e:	9801      	ldr	r0, [sp, #4]
 8002450:	f7ff ffc6 	bl	80023e0 <gpt_lld_stop_timer>
 8002454:	9b01      	ldr	r3, [sp, #4]
 8002456:	685b      	ldr	r3, [r3, #4]
 8002458:	685b      	ldr	r3, [r3, #4]
 800245a:	2b00      	cmp	r3, #0
 800245c:	d004      	beq.n	8002468 <gpt_lld_serve_interrupt+0x58>
 800245e:	9b01      	ldr	r3, [sp, #4]
 8002460:	685b      	ldr	r3, [r3, #4]
 8002462:	685b      	ldr	r3, [r3, #4]
 8002464:	9801      	ldr	r0, [sp, #4]
 8002466:	4798      	blx	r3
  }
}
 8002468:	bf00      	nop
 800246a:	b005      	add	sp, #20
 800246c:	f85d fb04 	ldr.w	pc, [sp], #4

08002470 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8002470:	b082      	sub	sp, #8
 8002472:	9001      	str	r0, [sp, #4]
 8002474:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8002476:	9b00      	ldr	r3, [sp, #0]
 8002478:	685a      	ldr	r2, [r3, #4]
 800247a:	9b01      	ldr	r3, [sp, #4]
 800247c:	605a      	str	r2, [r3, #4]
  gpiop->ASCR    = config->ascr;
 800247e:	9b00      	ldr	r3, [sp, #0]
 8002480:	69da      	ldr	r2, [r3, #28]
 8002482:	9b01      	ldr	r3, [sp, #4]
 8002484:	62da      	str	r2, [r3, #44]	@ 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8002486:	9b00      	ldr	r3, [sp, #0]
 8002488:	689a      	ldr	r2, [r3, #8]
 800248a:	9b01      	ldr	r3, [sp, #4]
 800248c:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800248e:	9b00      	ldr	r3, [sp, #0]
 8002490:	68da      	ldr	r2, [r3, #12]
 8002492:	9b01      	ldr	r3, [sp, #4]
 8002494:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8002496:	9b00      	ldr	r3, [sp, #0]
 8002498:	691a      	ldr	r2, [r3, #16]
 800249a:	9b01      	ldr	r3, [sp, #4]
 800249c:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800249e:	9b00      	ldr	r3, [sp, #0]
 80024a0:	695a      	ldr	r2, [r3, #20]
 80024a2:	9b01      	ldr	r3, [sp, #4]
 80024a4:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80024a6:	9b00      	ldr	r3, [sp, #0]
 80024a8:	699a      	ldr	r2, [r3, #24]
 80024aa:	9b01      	ldr	r3, [sp, #4]
 80024ac:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 80024ae:	9b00      	ldr	r3, [sp, #0]
 80024b0:	681a      	ldr	r2, [r3, #0]
 80024b2:	9b01      	ldr	r3, [sp, #4]
 80024b4:	601a      	str	r2, [r3, #0]
  gpiop->LOCKR   = config->lockr;
 80024b6:	9b00      	ldr	r3, [sp, #0]
 80024b8:	6a1a      	ldr	r2, [r3, #32]
 80024ba:	9b01      	ldr	r3, [sp, #4]
 80024bc:	61da      	str	r2, [r3, #28]
}
 80024be:	bf00      	nop
 80024c0:	b002      	add	sp, #8
 80024c2:	4770      	bx	lr
	...

080024d0 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 80024d0:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB2(STM32_GPIO_EN_MASK);
 80024d2:	4b25      	ldr	r3, [pc, #148]	@ (8002568 <stm32_gpio_init+0x98>)
 80024d4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80024d6:	4a24      	ldr	r2, [pc, #144]	@ (8002568 <stm32_gpio_init+0x98>)
 80024d8:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 80024dc:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 80024e0:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80024e2:	4b21      	ldr	r3, [pc, #132]	@ (8002568 <stm32_gpio_init+0x98>)
 80024e4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80024e6:	4a20      	ldr	r2, [pc, #128]	@ (8002568 <stm32_gpio_init+0x98>)
 80024e8:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
 80024ec:	f023 0301 	bic.w	r3, r3, #1
 80024f0:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80024f2:	4b1d      	ldr	r3, [pc, #116]	@ (8002568 <stm32_gpio_init+0x98>)
 80024f4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 80024f6:	4b1c      	ldr	r3, [pc, #112]	@ (8002568 <stm32_gpio_init+0x98>)
 80024f8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80024fa:	4a1b      	ldr	r2, [pc, #108]	@ (8002568 <stm32_gpio_init+0x98>)
 80024fc:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8002500:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8002504:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8002506:	4b18      	ldr	r3, [pc, #96]	@ (8002568 <stm32_gpio_init+0x98>)
 8002508:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800250a:	4a17      	ldr	r2, [pc, #92]	@ (8002568 <stm32_gpio_init+0x98>)
 800250c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8002510:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8002514:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8002516:	4b14      	ldr	r3, [pc, #80]	@ (8002568 <stm32_gpio_init+0x98>)
 8002518:	6edb      	ldr	r3, [r3, #108]	@ 0x6c

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 800251a:	4914      	ldr	r1, [pc, #80]	@ (800256c <stm32_gpio_init+0x9c>)
 800251c:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8002520:	f7ff ffa6 	bl	8002470 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8002524:	4912      	ldr	r1, [pc, #72]	@ (8002570 <stm32_gpio_init+0xa0>)
 8002526:	4813      	ldr	r0, [pc, #76]	@ (8002574 <stm32_gpio_init+0xa4>)
 8002528:	f7ff ffa2 	bl	8002470 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 800252c:	4912      	ldr	r1, [pc, #72]	@ (8002578 <stm32_gpio_init+0xa8>)
 800252e:	4813      	ldr	r0, [pc, #76]	@ (800257c <stm32_gpio_init+0xac>)
 8002530:	f7ff ff9e 	bl	8002470 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8002534:	4912      	ldr	r1, [pc, #72]	@ (8002580 <stm32_gpio_init+0xb0>)
 8002536:	4813      	ldr	r0, [pc, #76]	@ (8002584 <stm32_gpio_init+0xb4>)
 8002538:	f7ff ff9a 	bl	8002470 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 800253c:	4912      	ldr	r1, [pc, #72]	@ (8002588 <stm32_gpio_init+0xb8>)
 800253e:	4813      	ldr	r0, [pc, #76]	@ (800258c <stm32_gpio_init+0xbc>)
 8002540:	f7ff ff96 	bl	8002470 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 8002544:	4912      	ldr	r1, [pc, #72]	@ (8002590 <stm32_gpio_init+0xc0>)
 8002546:	4813      	ldr	r0, [pc, #76]	@ (8002594 <stm32_gpio_init+0xc4>)
 8002548:	f7ff ff92 	bl	8002470 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 800254c:	4912      	ldr	r1, [pc, #72]	@ (8002598 <stm32_gpio_init+0xc8>)
 800254e:	4813      	ldr	r0, [pc, #76]	@ (800259c <stm32_gpio_init+0xcc>)
 8002550:	f7ff ff8e 	bl	8002470 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8002554:	4912      	ldr	r1, [pc, #72]	@ (80025a0 <stm32_gpio_init+0xd0>)
 8002556:	4813      	ldr	r0, [pc, #76]	@ (80025a4 <stm32_gpio_init+0xd4>)
 8002558:	f7ff ff8a 	bl	8002470 <gpio_init>
#endif
#if STM32_HAS_GPIOI
  gpio_init(GPIOI, &gpio_default_config.PIData);
 800255c:	4912      	ldr	r1, [pc, #72]	@ (80025a8 <stm32_gpio_init+0xd8>)
 800255e:	4813      	ldr	r0, [pc, #76]	@ (80025ac <stm32_gpio_init+0xdc>)
 8002560:	f7ff ff86 	bl	8002470 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8002564:	bf00      	nop
 8002566:	bd08      	pop	{r3, pc}
 8002568:	40021000 	.word	0x40021000
 800256c:	080052c8 	.word	0x080052c8
 8002570:	080052ec 	.word	0x080052ec
 8002574:	48000400 	.word	0x48000400
 8002578:	08005310 	.word	0x08005310
 800257c:	48000800 	.word	0x48000800
 8002580:	08005334 	.word	0x08005334
 8002584:	48000c00 	.word	0x48000c00
 8002588:	08005358 	.word	0x08005358
 800258c:	48001000 	.word	0x48001000
 8002590:	0800537c 	.word	0x0800537c
 8002594:	48001400 	.word	0x48001400
 8002598:	080053a0 	.word	0x080053a0
 800259c:	48001800 	.word	0x48001800
 80025a0:	080053c4 	.word	0x080053c4
 80025a4:	48001c00 	.word	0x48001c00
 80025a8:	080053e8 	.word	0x080053e8
 80025ac:	48002000 	.word	0x48002000

080025b0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80025b0:	b508      	push	{r3, lr}

  stm32_gpio_init();
 80025b2:	f7ff ff8d 	bl	80024d0 <stm32_gpio_init>
  stm32_clock_init();
 80025b6:	f7fe fe2b 	bl	8001210 <stm32_clock_init>
}
 80025ba:	bf00      	nop
 80025bc:	bd08      	pop	{r3, pc}
 80025be:	bf00      	nop

080025c0 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 80025c0:	bf00      	nop
 80025c2:	4770      	bx	lr
	...

080025d0 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 80025d0:	b500      	push	{lr}
 80025d2:	b08b      	sub	sp, #44	@ 0x2c
 80025d4:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 80025d6:	9b01      	ldr	r3, [sp, #4]
 80025d8:	2200      	movs	r2, #0
 80025da:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 80025dc:	ab02      	add	r3, sp, #8
 80025de:	4618      	mov	r0, r3
 80025e0:	f001 fd8e 	bl	8004100 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 80025e4:	2304      	movs	r3, #4
 80025e6:	9309      	str	r3, [sp, #36]	@ 0x24
  do {
    chTMStartMeasurementX(&tm);
 80025e8:	ab02      	add	r3, sp, #8
 80025ea:	4618      	mov	r0, r3
 80025ec:	f001 fda8 	bl	8004140 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 80025f0:	ab02      	add	r3, sp, #8
 80025f2:	4618      	mov	r0, r3
 80025f4:	f001 fdb4 	bl	8004160 <chTMStopMeasurementX>
    i--;
 80025f8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80025fa:	3b01      	subs	r3, #1
 80025fc:	9309      	str	r3, [sp, #36]	@ 0x24
  } while (i > 0U);
 80025fe:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002600:	2b00      	cmp	r3, #0
 8002602:	d1f1      	bne.n	80025e8 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
 8002604:	9a02      	ldr	r2, [sp, #8]
 8002606:	9b01      	ldr	r3, [sp, #4]
 8002608:	601a      	str	r2, [r3, #0]
}
 800260a:	bf00      	nop
 800260c:	b00b      	add	sp, #44	@ 0x2c
 800260e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002612:	bf00      	nop
	...

08002620 <chSysUnlock.lto_priv.5>:
static inline void chSysUnlock(void) {
 8002620:	b500      	push	{lr}
 8002622:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8002624:	f000 f91c 	bl	8002860 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8002628:	4b12      	ldr	r3, [pc, #72]	@ (8002674 <chSysUnlock.lto_priv.5+0x54>)
 800262a:	681b      	ldr	r3, [r3, #0]
 800262c:	4a11      	ldr	r2, [pc, #68]	@ (8002674 <chSysUnlock.lto_priv.5+0x54>)
 800262e:	4293      	cmp	r3, r2
 8002630:	bf14      	ite	ne
 8002632:	2301      	movne	r3, #1
 8002634:	2300      	moveq	r3, #0
 8002636:	b2db      	uxtb	r3, r3
 8002638:	2b00      	cmp	r3, #0
 800263a:	d00f      	beq.n	800265c <chSysUnlock.lto_priv.5+0x3c>
 800263c:	4b0d      	ldr	r3, [pc, #52]	@ (8002674 <chSysUnlock.lto_priv.5+0x54>)
 800263e:	68db      	ldr	r3, [r3, #12]
 8002640:	689a      	ldr	r2, [r3, #8]
 8002642:	4b0c      	ldr	r3, [pc, #48]	@ (8002674 <chSysUnlock.lto_priv.5+0x54>)
 8002644:	681b      	ldr	r3, [r3, #0]
 8002646:	689b      	ldr	r3, [r3, #8]
 8002648:	429a      	cmp	r2, r3
 800264a:	bf34      	ite	cc
 800264c:	2301      	movcc	r3, #1
 800264e:	2300      	movcs	r3, #0
 8002650:	b2db      	uxtb	r3, r3
 8002652:	2b00      	cmp	r3, #0
 8002654:	d002      	beq.n	800265c <chSysUnlock.lto_priv.5+0x3c>
 8002656:	4808      	ldr	r0, [pc, #32]	@ (8002678 <chSysUnlock.lto_priv.5+0x58>)
 8002658:	f000 f852 	bl	8002700 <chSysHalt>
 800265c:	2300      	movs	r3, #0
 800265e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002660:	9b01      	ldr	r3, [sp, #4]
 8002662:	f383 8811 	msr	BASEPRI, r3
}
 8002666:	bf00      	nop
}
 8002668:	bf00      	nop
}
 800266a:	bf00      	nop
 800266c:	b003      	add	sp, #12
 800266e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002672:	bf00      	nop
 8002674:	200008d0 	.word	0x200008d0
 8002678:	08005488 	.word	0x08005488
 800267c:	00000000 	.word	0x00000000

08002680 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 8002680:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 8002682:	f002 f89d 	bl	80047c0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8002686:	f002 f90b 	bl	80048a0 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 800268a:	f002 fad1 	bl	8004c30 <__factory_init>
#endif
}
 800268e:	bf00      	nop
 8002690:	bd08      	pop	{r3, pc}
 8002692:	bf00      	nop
	...

080026a0 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 80026a0:	b500      	push	{lr}
 80026a2:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 80026a4:	4b11      	ldr	r3, [pc, #68]	@ (80026ec <chSysInit+0x4c>)
 80026a6:	2201      	movs	r2, #1
 80026a8:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80026aa:	2300      	movs	r3, #0
 80026ac:	9301      	str	r3, [sp, #4]
 80026ae:	e008      	b.n	80026c2 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
 80026b0:	4a0e      	ldr	r2, [pc, #56]	@ (80026ec <chSysInit+0x4c>)
 80026b2:	9b01      	ldr	r3, [sp, #4]
 80026b4:	009b      	lsls	r3, r3, #2
 80026b6:	4413      	add	r3, r2
 80026b8:	2200      	movs	r2, #0
 80026ba:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80026bc:	9b01      	ldr	r3, [sp, #4]
 80026be:	3301      	adds	r3, #1
 80026c0:	9301      	str	r3, [sp, #4]
 80026c2:	9b01      	ldr	r3, [sp, #4]
 80026c4:	2b00      	cmp	r3, #0
 80026c6:	d0f3      	beq.n	80026b0 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 80026c8:	4809      	ldr	r0, [pc, #36]	@ (80026f0 <chSysInit+0x50>)
 80026ca:	f7ff ff81 	bl	80025d0 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 80026ce:	f7ff ffd7 	bl	8002680 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 80026d2:	4908      	ldr	r1, [pc, #32]	@ (80026f4 <chSysInit+0x54>)
 80026d4:	4808      	ldr	r0, [pc, #32]	@ (80026f8 <chSysInit+0x58>)
 80026d6:	f001 f8eb 	bl	80038b0 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 80026da:	4b04      	ldr	r3, [pc, #16]	@ (80026ec <chSysInit+0x4c>)
 80026dc:	2202      	movs	r2, #2
 80026de:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 80026e0:	f7ff ff9e 	bl	8002620 <chSysUnlock.lto_priv.5>
}
 80026e4:	bf00      	nop
 80026e6:	b003      	add	sp, #12
 80026e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80026ec:	200008c4 	.word	0x200008c4
 80026f0:	200008cc 	.word	0x200008cc
 80026f4:	08005474 	.word	0x08005474
 80026f8:	200008d0 	.word	0x200008d0
 80026fc:	00000000 	.word	0x00000000

08002700 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002700:	b082      	sub	sp, #8
 8002702:	9001      	str	r0, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8002704:	b672      	cpsid	i
}
 8002706:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 8002708:	bf00      	nop

  /* Logging the event.*/
  __trace_halt(reason);

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 800270a:	4a04      	ldr	r2, [pc, #16]	@ (800271c <chSysHalt+0x1c>)
 800270c:	9b01      	ldr	r3, [sp, #4]
 800270e:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8002712:	4b03      	ldr	r3, [pc, #12]	@ (8002720 <chSysHalt+0x20>)
 8002714:	2203      	movs	r2, #3
 8002716:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
     asm volatile ("nop");
 8002718:	bf00      	nop
 800271a:	e7fd      	b.n	8002718 <chSysHalt+0x18>
 800271c:	200008d0 	.word	0x200008d0
 8002720:	200008c4 	.word	0x200008c4
	...

08002730 <chSysGetIdleThreadX>:
 *
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
 8002730:	b500      	push	{lr}
 8002732:	b083      	sub	sp, #12
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8002734:	4b09      	ldr	r3, [pc, #36]	@ (800275c <chSysGetIdleThreadX+0x2c>)
 8002736:	685b      	ldr	r3, [r3, #4]
 8002738:	9301      	str	r3, [sp, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 800273a:	9b01      	ldr	r3, [sp, #4]
 800273c:	689b      	ldr	r3, [r3, #8]
 800273e:	2b01      	cmp	r3, #1
 8002740:	bf14      	ite	ne
 8002742:	2301      	movne	r3, #1
 8002744:	2300      	moveq	r3, #0
 8002746:	b2db      	uxtb	r3, r3
 8002748:	2b00      	cmp	r3, #0
 800274a:	d002      	beq.n	8002752 <chSysGetIdleThreadX+0x22>
 800274c:	4804      	ldr	r0, [pc, #16]	@ (8002760 <chSysGetIdleThreadX+0x30>)
 800274e:	f7ff ffd7 	bl	8002700 <chSysHalt>

  return tp;
 8002752:	9b01      	ldr	r3, [sp, #4]
}
 8002754:	4618      	mov	r0, r3
 8002756:	b003      	add	sp, #12
 8002758:	f85d fb04 	ldr.w	pc, [sp], #4
 800275c:	200008d0 	.word	0x200008d0
 8002760:	08005494 	.word	0x08005494
	...

08002770 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002770:	b508      	push	{r3, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 8002772:	f000 f965 	bl	8002a40 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8002776:	f000 fc83 	bl	8003080 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800277a:	bf00      	nop
 800277c:	bd08      	pop	{r3, pc}
 800277e:	bf00      	nop

08002780 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 8002780:	b084      	sub	sp, #16
 8002782:	9003      	str	r0, [sp, #12]
 8002784:	9102      	str	r1, [sp, #8]
 8002786:	9201      	str	r2, [sp, #4]

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8002788:	9a03      	ldr	r2, [sp, #12]
 800278a:	9b02      	ldr	r3, [sp, #8]
 800278c:	1ad2      	subs	r2, r2, r3
                ((rtcnt_t)end - (rtcnt_t)start));
 800278e:	9901      	ldr	r1, [sp, #4]
 8002790:	9b02      	ldr	r3, [sp, #8]
 8002792:	1acb      	subs	r3, r1, r3
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8002794:	429a      	cmp	r2, r3
 8002796:	bf34      	ite	cc
 8002798:	2301      	movcc	r3, #1
 800279a:	2300      	movcs	r3, #0
 800279c:	b2db      	uxtb	r3, r3
}
 800279e:	4618      	mov	r0, r3
 80027a0:	b004      	add	sp, #16
 80027a2:	4770      	bx	lr
	...

080027b0 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 80027b0:	b500      	push	{lr}
 80027b2:	b085      	sub	sp, #20
 80027b4:	9001      	str	r0, [sp, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80027b6:	4b0b      	ldr	r3, [pc, #44]	@ (80027e4 <chSysPolledDelayX+0x34>)
 80027b8:	685b      	ldr	r3, [r3, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 80027ba:	9303      	str	r3, [sp, #12]
  rtcnt_t end  = start + cycles;
 80027bc:	9a03      	ldr	r2, [sp, #12]
 80027be:	9b01      	ldr	r3, [sp, #4]
 80027c0:	4413      	add	r3, r2
 80027c2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80027c4:	bf00      	nop
 80027c6:	4b07      	ldr	r3, [pc, #28]	@ (80027e4 <chSysPolledDelayX+0x34>)
 80027c8:	685b      	ldr	r3, [r3, #4]
 80027ca:	9a02      	ldr	r2, [sp, #8]
 80027cc:	9903      	ldr	r1, [sp, #12]
 80027ce:	4618      	mov	r0, r3
 80027d0:	f7ff ffd6 	bl	8002780 <chSysIsCounterWithinX>
 80027d4:	4603      	mov	r3, r0
 80027d6:	2b00      	cmp	r3, #0
 80027d8:	d1f5      	bne.n	80027c6 <chSysPolledDelayX+0x16>
  }
}
 80027da:	bf00      	nop
 80027dc:	bf00      	nop
 80027de:	b005      	add	sp, #20
 80027e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80027e4:	e0001000 	.word	0xe0001000
	...

080027f0 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 80027f0:	b082      	sub	sp, #8
 80027f2:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 80027f4:	4b04      	ldr	r3, [pc, #16]	@ (8002808 <chRFCUCollectFaultsI+0x18>)
 80027f6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80027f8:	9b01      	ldr	r3, [sp, #4]
 80027fa:	4313      	orrs	r3, r2
 80027fc:	4a02      	ldr	r2, [pc, #8]	@ (8002808 <chRFCUCollectFaultsI+0x18>)
 80027fe:	6353      	str	r3, [r2, #52]	@ 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8002800:	bf00      	nop
 8002802:	b002      	add	sp, #8
 8002804:	4770      	bx	lr
 8002806:	bf00      	nop
 8002808:	200008d0 	.word	0x200008d0
 800280c:	00000000 	.word	0x00000000

08002810 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 8002810:	b500      	push	{lr}
 8002812:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002814:	4b10      	ldr	r3, [pc, #64]	@ (8002858 <__dbg_check_lock+0x48>)
 8002816:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002818:	9b01      	ldr	r3, [sp, #4]
 800281a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800281e:	2b00      	cmp	r3, #0
 8002820:	bf14      	ite	ne
 8002822:	2301      	movne	r3, #1
 8002824:	2300      	moveq	r3, #0
 8002826:	b2db      	uxtb	r3, r3
 8002828:	2b00      	cmp	r3, #0
 800282a:	d109      	bne.n	8002840 <__dbg_check_lock+0x30>
 800282c:	9b01      	ldr	r3, [sp, #4]
 800282e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002832:	2b00      	cmp	r3, #0
 8002834:	bf14      	ite	ne
 8002836:	2301      	movne	r3, #1
 8002838:	2300      	moveq	r3, #0
 800283a:	b2db      	uxtb	r3, r3
 800283c:	2b00      	cmp	r3, #0
 800283e:	d002      	beq.n	8002846 <__dbg_check_lock+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 8002840:	4806      	ldr	r0, [pc, #24]	@ (800285c <__dbg_check_lock+0x4c>)
 8002842:	f7ff ff5d 	bl	8002700 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002846:	9b01      	ldr	r3, [sp, #4]
 8002848:	2201      	movs	r2, #1
 800284a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800284e:	bf00      	nop
 8002850:	b003      	add	sp, #12
 8002852:	f85d fb04 	ldr.w	pc, [sp], #4
 8002856:	bf00      	nop
 8002858:	200008d0 	.word	0x200008d0
 800285c:	08005410 	.word	0x08005410

08002860 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 8002860:	b500      	push	{lr}
 8002862:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002864:	4b10      	ldr	r3, [pc, #64]	@ (80028a8 <__dbg_check_unlock+0x48>)
 8002866:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002868:	9b01      	ldr	r3, [sp, #4]
 800286a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800286e:	2b00      	cmp	r3, #0
 8002870:	bf14      	ite	ne
 8002872:	2301      	movne	r3, #1
 8002874:	2300      	moveq	r3, #0
 8002876:	b2db      	uxtb	r3, r3
 8002878:	2b00      	cmp	r3, #0
 800287a:	d109      	bne.n	8002890 <__dbg_check_unlock+0x30>
 800287c:	9b01      	ldr	r3, [sp, #4]
 800287e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002882:	2b00      	cmp	r3, #0
 8002884:	bfd4      	ite	le
 8002886:	2301      	movle	r3, #1
 8002888:	2300      	movgt	r3, #0
 800288a:	b2db      	uxtb	r3, r3
 800288c:	2b00      	cmp	r3, #0
 800288e:	d002      	beq.n	8002896 <__dbg_check_unlock+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 8002890:	4806      	ldr	r0, [pc, #24]	@ (80028ac <__dbg_check_unlock+0x4c>)
 8002892:	f7ff ff35 	bl	8002700 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002896:	9b01      	ldr	r3, [sp, #4]
 8002898:	2200      	movs	r2, #0
 800289a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800289e:	bf00      	nop
 80028a0:	b003      	add	sp, #12
 80028a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80028a6:	bf00      	nop
 80028a8:	200008d0 	.word	0x200008d0
 80028ac:	08005418 	.word	0x08005418

080028b0 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 80028b0:	b500      	push	{lr}
 80028b2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80028b4:	4b10      	ldr	r3, [pc, #64]	@ (80028f8 <__dbg_check_lock_from_isr+0x48>)
 80028b6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80028b8:	9b01      	ldr	r3, [sp, #4]
 80028ba:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80028be:	2b00      	cmp	r3, #0
 80028c0:	bfd4      	ite	le
 80028c2:	2301      	movle	r3, #1
 80028c4:	2300      	movgt	r3, #0
 80028c6:	b2db      	uxtb	r3, r3
 80028c8:	2b00      	cmp	r3, #0
 80028ca:	d109      	bne.n	80028e0 <__dbg_check_lock_from_isr+0x30>
 80028cc:	9b01      	ldr	r3, [sp, #4]
 80028ce:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80028d2:	2b00      	cmp	r3, #0
 80028d4:	bf14      	ite	ne
 80028d6:	2301      	movne	r3, #1
 80028d8:	2300      	moveq	r3, #0
 80028da:	b2db      	uxtb	r3, r3
 80028dc:	2b00      	cmp	r3, #0
 80028de:	d002      	beq.n	80028e6 <__dbg_check_lock_from_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 80028e0:	4806      	ldr	r0, [pc, #24]	@ (80028fc <__dbg_check_lock_from_isr+0x4c>)
 80028e2:	f7ff ff0d 	bl	8002700 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 80028e6:	9b01      	ldr	r3, [sp, #4]
 80028e8:	2201      	movs	r2, #1
 80028ea:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 80028ee:	bf00      	nop
 80028f0:	b003      	add	sp, #12
 80028f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80028f6:	bf00      	nop
 80028f8:	200008d0 	.word	0x200008d0
 80028fc:	08005420 	.word	0x08005420

08002900 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 8002900:	b500      	push	{lr}
 8002902:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002904:	4b10      	ldr	r3, [pc, #64]	@ (8002948 <__dbg_check_unlock_from_isr+0x48>)
 8002906:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002908:	9b01      	ldr	r3, [sp, #4]
 800290a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800290e:	2b00      	cmp	r3, #0
 8002910:	bfd4      	ite	le
 8002912:	2301      	movle	r3, #1
 8002914:	2300      	movgt	r3, #0
 8002916:	b2db      	uxtb	r3, r3
 8002918:	2b00      	cmp	r3, #0
 800291a:	d109      	bne.n	8002930 <__dbg_check_unlock_from_isr+0x30>
 800291c:	9b01      	ldr	r3, [sp, #4]
 800291e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002922:	2b00      	cmp	r3, #0
 8002924:	bfd4      	ite	le
 8002926:	2301      	movle	r3, #1
 8002928:	2300      	movgt	r3, #0
 800292a:	b2db      	uxtb	r3, r3
 800292c:	2b00      	cmp	r3, #0
 800292e:	d002      	beq.n	8002936 <__dbg_check_unlock_from_isr+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 8002930:	4806      	ldr	r0, [pc, #24]	@ (800294c <__dbg_check_unlock_from_isr+0x4c>)
 8002932:	f7ff fee5 	bl	8002700 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002936:	9b01      	ldr	r3, [sp, #4]
 8002938:	2200      	movs	r2, #0
 800293a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800293e:	bf00      	nop
 8002940:	b003      	add	sp, #12
 8002942:	f85d fb04 	ldr.w	pc, [sp], #4
 8002946:	bf00      	nop
 8002948:	200008d0 	.word	0x200008d0
 800294c:	08005428 	.word	0x08005428

08002950 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 8002950:	b500      	push	{lr}
 8002952:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8002954:	4b18      	ldr	r3, [pc, #96]	@ (80029b8 <__dbg_check_enter_isr+0x68>)
 8002956:	9303      	str	r3, [sp, #12]
 8002958:	2330      	movs	r3, #48	@ 0x30
 800295a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800295c:	9b02      	ldr	r3, [sp, #8]
 800295e:	f383 8811 	msr	BASEPRI, r3
}
 8002962:	bf00      	nop
}
 8002964:	bf00      	nop
}
 8002966:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002968:	9b03      	ldr	r3, [sp, #12]
 800296a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800296e:	0fdb      	lsrs	r3, r3, #31
 8002970:	b2db      	uxtb	r3, r3
 8002972:	2b00      	cmp	r3, #0
 8002974:	d109      	bne.n	800298a <__dbg_check_enter_isr+0x3a>
 8002976:	9b03      	ldr	r3, [sp, #12]
 8002978:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800297c:	2b00      	cmp	r3, #0
 800297e:	bf14      	ite	ne
 8002980:	2301      	movne	r3, #1
 8002982:	2300      	moveq	r3, #0
 8002984:	b2db      	uxtb	r3, r3
 8002986:	2b00      	cmp	r3, #0
 8002988:	d002      	beq.n	8002990 <__dbg_check_enter_isr+0x40>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 800298a:	480c      	ldr	r0, [pc, #48]	@ (80029bc <__dbg_check_enter_isr+0x6c>)
 800298c:	f7ff feb8 	bl	8002700 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 8002990:	9b03      	ldr	r3, [sp, #12]
 8002992:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002996:	1c5a      	adds	r2, r3, #1
 8002998:	9b03      	ldr	r3, [sp, #12]
 800299a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 800299e:	2300      	movs	r3, #0
 80029a0:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80029a2:	9b01      	ldr	r3, [sp, #4]
 80029a4:	f383 8811 	msr	BASEPRI, r3
}
 80029a8:	bf00      	nop
}
 80029aa:	bf00      	nop
}
 80029ac:	bf00      	nop
  port_unlock_from_isr();
}
 80029ae:	bf00      	nop
 80029b0:	b005      	add	sp, #20
 80029b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80029b6:	bf00      	nop
 80029b8:	200008d0 	.word	0x200008d0
 80029bc:	08005430 	.word	0x08005430

080029c0 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 80029c0:	b500      	push	{lr}
 80029c2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80029c4:	4b19      	ldr	r3, [pc, #100]	@ (8002a2c <__dbg_check_leave_isr+0x6c>)
 80029c6:	9303      	str	r3, [sp, #12]
 80029c8:	2330      	movs	r3, #48	@ 0x30
 80029ca:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80029cc:	9b02      	ldr	r3, [sp, #8]
 80029ce:	f383 8811 	msr	BASEPRI, r3
}
 80029d2:	bf00      	nop
}
 80029d4:	bf00      	nop
}
 80029d6:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80029d8:	9b03      	ldr	r3, [sp, #12]
 80029da:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80029de:	2b00      	cmp	r3, #0
 80029e0:	bfd4      	ite	le
 80029e2:	2301      	movle	r3, #1
 80029e4:	2300      	movgt	r3, #0
 80029e6:	b2db      	uxtb	r3, r3
 80029e8:	2b00      	cmp	r3, #0
 80029ea:	d109      	bne.n	8002a00 <__dbg_check_leave_isr+0x40>
 80029ec:	9b03      	ldr	r3, [sp, #12]
 80029ee:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80029f2:	2b00      	cmp	r3, #0
 80029f4:	bf14      	ite	ne
 80029f6:	2301      	movne	r3, #1
 80029f8:	2300      	moveq	r3, #0
 80029fa:	b2db      	uxtb	r3, r3
 80029fc:	2b00      	cmp	r3, #0
 80029fe:	d002      	beq.n	8002a06 <__dbg_check_leave_isr+0x46>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 8002a00:	480b      	ldr	r0, [pc, #44]	@ (8002a30 <__dbg_check_leave_isr+0x70>)
 8002a02:	f7ff fe7d 	bl	8002700 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 8002a06:	9b03      	ldr	r3, [sp, #12]
 8002a08:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a0c:	1e5a      	subs	r2, r3, #1
 8002a0e:	9b03      	ldr	r3, [sp, #12]
 8002a10:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8002a14:	2300      	movs	r3, #0
 8002a16:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002a18:	9b01      	ldr	r3, [sp, #4]
 8002a1a:	f383 8811 	msr	BASEPRI, r3
}
 8002a1e:	bf00      	nop
}
 8002a20:	bf00      	nop
}
 8002a22:	bf00      	nop
  port_unlock_from_isr();
}
 8002a24:	bf00      	nop
 8002a26:	b005      	add	sp, #20
 8002a28:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a2c:	200008d0 	.word	0x200008d0
 8002a30:	08005438 	.word	0x08005438
	...

08002a40 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002a40:	b500      	push	{lr}
 8002a42:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002a44:	4b0c      	ldr	r3, [pc, #48]	@ (8002a78 <chDbgCheckClassI+0x38>)
 8002a46:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002a48:	9b01      	ldr	r3, [sp, #4]
 8002a4a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a4e:	0fdb      	lsrs	r3, r3, #31
 8002a50:	b2db      	uxtb	r3, r3
 8002a52:	2b00      	cmp	r3, #0
 8002a54:	d109      	bne.n	8002a6a <chDbgCheckClassI+0x2a>
 8002a56:	9b01      	ldr	r3, [sp, #4]
 8002a58:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002a5c:	2b00      	cmp	r3, #0
 8002a5e:	bfd4      	ite	le
 8002a60:	2301      	movle	r3, #1
 8002a62:	2300      	movgt	r3, #0
 8002a64:	b2db      	uxtb	r3, r3
 8002a66:	2b00      	cmp	r3, #0
 8002a68:	d002      	beq.n	8002a70 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 8002a6a:	4804      	ldr	r0, [pc, #16]	@ (8002a7c <chDbgCheckClassI+0x3c>)
 8002a6c:	f7ff fe48 	bl	8002700 <chSysHalt>
  }
}
 8002a70:	bf00      	nop
 8002a72:	b003      	add	sp, #12
 8002a74:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a78:	200008d0 	.word	0x200008d0
 8002a7c:	08005440 	.word	0x08005440

08002a80 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002a80:	b500      	push	{lr}
 8002a82:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002a84:	4b0e      	ldr	r3, [pc, #56]	@ (8002ac0 <chDbgCheckClassS+0x40>)
 8002a86:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002a88:	9b01      	ldr	r3, [sp, #4]
 8002a8a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	bf14      	ite	ne
 8002a92:	2301      	movne	r3, #1
 8002a94:	2300      	moveq	r3, #0
 8002a96:	b2db      	uxtb	r3, r3
 8002a98:	2b00      	cmp	r3, #0
 8002a9a:	d109      	bne.n	8002ab0 <chDbgCheckClassS+0x30>
 8002a9c:	9b01      	ldr	r3, [sp, #4]
 8002a9e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002aa2:	2b00      	cmp	r3, #0
 8002aa4:	bfd4      	ite	le
 8002aa6:	2301      	movle	r3, #1
 8002aa8:	2300      	movgt	r3, #0
 8002aaa:	b2db      	uxtb	r3, r3
 8002aac:	2b00      	cmp	r3, #0
 8002aae:	d002      	beq.n	8002ab6 <chDbgCheckClassS+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 8002ab0:	4804      	ldr	r0, [pc, #16]	@ (8002ac4 <chDbgCheckClassS+0x44>)
 8002ab2:	f7ff fe25 	bl	8002700 <chSysHalt>
  }
}
 8002ab6:	bf00      	nop
 8002ab8:	b003      	add	sp, #12
 8002aba:	f85d fb04 	ldr.w	pc, [sp], #4
 8002abe:	bf00      	nop
 8002ac0:	200008d0 	.word	0x200008d0
 8002ac4:	08005448 	.word	0x08005448
	...

08002ad0 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8002ad0:	b082      	sub	sp, #8
 8002ad2:	9001      	str	r0, [sp, #4]
 8002ad4:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002ad6:	9a01      	ldr	r2, [sp, #4]
 8002ad8:	9b00      	ldr	r3, [sp, #0]
 8002ada:	4413      	add	r3, r2
}
 8002adc:	4618      	mov	r0, r3
 8002ade:	b002      	add	sp, #8
 8002ae0:	4770      	bx	lr
 8002ae2:	bf00      	nop
	...

08002af0 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8002af0:	b082      	sub	sp, #8
 8002af2:	9001      	str	r0, [sp, #4]
 8002af4:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002af6:	9a00      	ldr	r2, [sp, #0]
 8002af8:	9b01      	ldr	r3, [sp, #4]
 8002afa:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8002afc:	4618      	mov	r0, r3
 8002afe:	b002      	add	sp, #8
 8002b00:	4770      	bx	lr
 8002b02:	bf00      	nop
	...

08002b10 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8002b10:	b082      	sub	sp, #8
 8002b12:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8002b14:	9b01      	ldr	r3, [sp, #4]
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	9a01      	ldr	r2, [sp, #4]
 8002b1a:	429a      	cmp	r2, r3
 8002b1c:	bf0c      	ite	eq
 8002b1e:	2301      	moveq	r3, #1
 8002b20:	2300      	movne	r3, #0
 8002b22:	b2db      	uxtb	r3, r3
}
 8002b24:	4618      	mov	r0, r3
 8002b26:	b002      	add	sp, #8
 8002b28:	4770      	bx	lr
 8002b2a:	bf00      	nop
 8002b2c:	0000      	movs	r0, r0
	...

08002b30 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8002b30:	b082      	sub	sp, #8
 8002b32:	9001      	str	r0, [sp, #4]
 8002b34:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8002b36:	9b01      	ldr	r3, [sp, #4]
 8002b38:	681b      	ldr	r3, [r3, #0]
 8002b3a:	9a00      	ldr	r2, [sp, #0]
 8002b3c:	429a      	cmp	r2, r3
 8002b3e:	bf0c      	ite	eq
 8002b40:	2301      	moveq	r3, #1
 8002b42:	2300      	movne	r3, #0
 8002b44:	b2db      	uxtb	r3, r3
}
 8002b46:	4618      	mov	r0, r3
 8002b48:	b002      	add	sp, #8
 8002b4a:	4770      	bx	lr
 8002b4c:	0000      	movs	r0, r0
	...

08002b50 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 8002b50:	b084      	sub	sp, #16
 8002b52:	9003      	str	r0, [sp, #12]
 8002b54:	9102      	str	r1, [sp, #8]
 8002b56:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002b58:	9b02      	ldr	r3, [sp, #8]
 8002b5a:	9a01      	ldr	r2, [sp, #4]
 8002b5c:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 8002b5e:	9b02      	ldr	r3, [sp, #8]
 8002b60:	9a03      	ldr	r2, [sp, #12]
 8002b62:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8002b64:	9b02      	ldr	r3, [sp, #8]
 8002b66:	685b      	ldr	r3, [r3, #4]
 8002b68:	681a      	ldr	r2, [r3, #0]
 8002b6a:	9b02      	ldr	r3, [sp, #8]
 8002b6c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 8002b6e:	9b02      	ldr	r3, [sp, #8]
 8002b70:	681b      	ldr	r3, [r3, #0]
 8002b72:	9a02      	ldr	r2, [sp, #8]
 8002b74:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 8002b76:	9b03      	ldr	r3, [sp, #12]
 8002b78:	9a02      	ldr	r2, [sp, #8]
 8002b7a:	601a      	str	r2, [r3, #0]
}
 8002b7c:	bf00      	nop
 8002b7e:	b004      	add	sp, #16
 8002b80:	4770      	bx	lr
 8002b82:	bf00      	nop
	...

08002b90 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 8002b90:	b084      	sub	sp, #16
 8002b92:	9003      	str	r0, [sp, #12]
 8002b94:	9102      	str	r1, [sp, #8]
 8002b96:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002b98:	9b02      	ldr	r3, [sp, #8]
 8002b9a:	9a01      	ldr	r2, [sp, #4]
 8002b9c:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 8002b9e:	9b02      	ldr	r3, [sp, #8]
 8002ba0:	9a03      	ldr	r2, [sp, #12]
 8002ba2:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8002ba4:	9b02      	ldr	r3, [sp, #8]
 8002ba6:	681b      	ldr	r3, [r3, #0]
 8002ba8:	685a      	ldr	r2, [r3, #4]
 8002baa:	9b02      	ldr	r3, [sp, #8]
 8002bac:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 8002bae:	9b02      	ldr	r3, [sp, #8]
 8002bb0:	685b      	ldr	r3, [r3, #4]
 8002bb2:	9a02      	ldr	r2, [sp, #8]
 8002bb4:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 8002bb6:	9b03      	ldr	r3, [sp, #12]
 8002bb8:	9a02      	ldr	r2, [sp, #8]
 8002bba:	605a      	str	r2, [r3, #4]
}
 8002bbc:	bf00      	nop
 8002bbe:	b004      	add	sp, #16
 8002bc0:	4770      	bx	lr
 8002bc2:	bf00      	nop
	...

08002bd0 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8002bd0:	b500      	push	{lr}
 8002bd2:	b087      	sub	sp, #28
 8002bd4:	9003      	str	r0, [sp, #12]
 8002bd6:	9102      	str	r1, [sp, #8]
 8002bd8:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 8002bda:	9b03      	ldr	r3, [sp, #12]
 8002bdc:	681b      	ldr	r3, [r3, #0]
 8002bde:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002be0:	e013      	b.n	8002c0a <ch_dlist_insert+0x3a>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8002be2:	9a05      	ldr	r2, [sp, #20]
 8002be4:	9b02      	ldr	r3, [sp, #8]
 8002be6:	429a      	cmp	r2, r3
 8002be8:	bf0c      	ite	eq
 8002bea:	2301      	moveq	r3, #1
 8002bec:	2300      	movne	r3, #0
 8002bee:	b2db      	uxtb	r3, r3
 8002bf0:	2b00      	cmp	r3, #0
 8002bf2:	d002      	beq.n	8002bfa <ch_dlist_insert+0x2a>
 8002bf4:	4813      	ldr	r0, [pc, #76]	@ (8002c44 <ch_dlist_insert+0x74>)
 8002bf6:	f7ff fd83 	bl	8002700 <chSysHalt>

    delta -= dlp->delta;
 8002bfa:	9b05      	ldr	r3, [sp, #20]
 8002bfc:	689b      	ldr	r3, [r3, #8]
 8002bfe:	9a01      	ldr	r2, [sp, #4]
 8002c00:	1ad3      	subs	r3, r2, r3
 8002c02:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 8002c04:	9b05      	ldr	r3, [sp, #20]
 8002c06:	681b      	ldr	r3, [r3, #0]
 8002c08:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002c0a:	9b05      	ldr	r3, [sp, #20]
 8002c0c:	689b      	ldr	r3, [r3, #8]
 8002c0e:	9a01      	ldr	r2, [sp, #4]
 8002c10:	429a      	cmp	r2, r3
 8002c12:	bf8c      	ite	hi
 8002c14:	2301      	movhi	r3, #1
 8002c16:	2300      	movls	r3, #0
 8002c18:	b2db      	uxtb	r3, r3
 8002c1a:	2b00      	cmp	r3, #0
 8002c1c:	d1e1      	bne.n	8002be2 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 8002c1e:	9a01      	ldr	r2, [sp, #4]
 8002c20:	9902      	ldr	r1, [sp, #8]
 8002c22:	9805      	ldr	r0, [sp, #20]
 8002c24:	f7ff ffb4 	bl	8002b90 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8002c28:	9b05      	ldr	r3, [sp, #20]
 8002c2a:	689a      	ldr	r2, [r3, #8]
 8002c2c:	9b01      	ldr	r3, [sp, #4]
 8002c2e:	1ad2      	subs	r2, r2, r3
 8002c30:	9b05      	ldr	r3, [sp, #20]
 8002c32:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8002c34:	9b03      	ldr	r3, [sp, #12]
 8002c36:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8002c3a:	609a      	str	r2, [r3, #8]
}
 8002c3c:	bf00      	nop
 8002c3e:	b007      	add	sp, #28
 8002c40:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c44:	080054a8 	.word	0x080054a8
	...

08002c50 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8002c50:	b084      	sub	sp, #16
 8002c52:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8002c54:	9b01      	ldr	r3, [sp, #4]
 8002c56:	681b      	ldr	r3, [r3, #0]
 8002c58:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 8002c5a:	9b03      	ldr	r3, [sp, #12]
 8002c5c:	681a      	ldr	r2, [r3, #0]
 8002c5e:	9b01      	ldr	r3, [sp, #4]
 8002c60:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8002c62:	9b01      	ldr	r3, [sp, #4]
 8002c64:	681b      	ldr	r3, [r3, #0]
 8002c66:	9a01      	ldr	r2, [sp, #4]
 8002c68:	605a      	str	r2, [r3, #4]

  return dlp;
 8002c6a:	9b03      	ldr	r3, [sp, #12]
}
 8002c6c:	4618      	mov	r0, r3
 8002c6e:	b004      	add	sp, #16
 8002c70:	4770      	bx	lr
 8002c72:	bf00      	nop
	...

08002c80 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 8002c80:	b082      	sub	sp, #8
 8002c82:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 8002c84:	9b01      	ldr	r3, [sp, #4]
 8002c86:	685b      	ldr	r3, [r3, #4]
 8002c88:	9a01      	ldr	r2, [sp, #4]
 8002c8a:	6812      	ldr	r2, [r2, #0]
 8002c8c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 8002c8e:	9b01      	ldr	r3, [sp, #4]
 8002c90:	681b      	ldr	r3, [r3, #0]
 8002c92:	9a01      	ldr	r2, [sp, #4]
 8002c94:	6852      	ldr	r2, [r2, #4]
 8002c96:	605a      	str	r2, [r3, #4]

  return dlp;
 8002c98:	9b01      	ldr	r3, [sp, #4]
}
 8002c9a:	4618      	mov	r0, r3
 8002c9c:	b002      	add	sp, #8
 8002c9e:	4770      	bx	lr

08002ca0 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8002ca0:	b500      	push	{lr}
 8002ca2:	b083      	sub	sp, #12
 8002ca4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8002ca6:	9801      	ldr	r0, [sp, #4]
 8002ca8:	f7fd fbe2 	bl	8000470 <stStartAlarm>
}
 8002cac:	bf00      	nop
 8002cae:	b003      	add	sp, #12
 8002cb0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002cc0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8002cc0:	b508      	push	{r3, lr}

  stStopAlarm();
 8002cc2:	f7fd fbed 	bl	80004a0 <stStopAlarm>
}
 8002cc6:	bf00      	nop
 8002cc8:	bd08      	pop	{r3, pc}
 8002cca:	bf00      	nop
 8002ccc:	0000      	movs	r0, r0
	...

08002cd0 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8002cd0:	b500      	push	{lr}
 8002cd2:	b083      	sub	sp, #12
 8002cd4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8002cd6:	9801      	ldr	r0, [sp, #4]
 8002cd8:	f7fd fbea 	bl	80004b0 <stSetAlarm>
}
 8002cdc:	bf00      	nop
 8002cde:	b003      	add	sp, #12
 8002ce0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002cf0 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002cf0:	b508      	push	{r3, lr}

  return stGetCounter();
 8002cf2:	f7fd fbb5 	bl	8000460 <stGetCounter>
 8002cf6:	4603      	mov	r3, r0
}
 8002cf8:	4618      	mov	r0, r3
 8002cfa:	bd08      	pop	{r3, pc}
 8002cfc:	0000      	movs	r0, r0
	...

08002d00 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 8002d00:	b500      	push	{lr}
 8002d02:	b083      	sub	sp, #12
 8002d04:	2330      	movs	r3, #48	@ 0x30
 8002d06:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002d08:	9b01      	ldr	r3, [sp, #4]
 8002d0a:	f383 8811 	msr	BASEPRI, r3
}
 8002d0e:	bf00      	nop
}
 8002d10:	bf00      	nop
}
 8002d12:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002d14:	f7ff fdcc 	bl	80028b0 <__dbg_check_lock_from_isr>
}
 8002d18:	bf00      	nop
 8002d1a:	b003      	add	sp, #12
 8002d1c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d20 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
 8002d20:	b500      	push	{lr}
 8002d22:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002d24:	f7ff fdec 	bl	8002900 <__dbg_check_unlock_from_isr>
 8002d28:	2300      	movs	r3, #0
 8002d2a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002d2c:	9b01      	ldr	r3, [sp, #4]
 8002d2e:	f383 8811 	msr	BASEPRI, r3
}
 8002d32:	bf00      	nop
}
 8002d34:	bf00      	nop
}
 8002d36:	bf00      	nop
}
 8002d38:	bf00      	nop
 8002d3a:	b003      	add	sp, #12
 8002d3c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d40 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002d40:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002d42:	f7ff ffd5 	bl	8002cf0 <port_timer_get_time.lto_priv.0>
 8002d46:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002d48:	4618      	mov	r0, r3
 8002d4a:	bd08      	pop	{r3, pc}
 8002d4c:	0000      	movs	r0, r0
	...

08002d50 <chVTIsArmedI.lto_priv.0>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8002d50:	b500      	push	{lr}
 8002d52:	b083      	sub	sp, #12
 8002d54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002d56:	f7ff fe73 	bl	8002a40 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 8002d5a:	9b01      	ldr	r3, [sp, #4]
 8002d5c:	681b      	ldr	r3, [r3, #0]
 8002d5e:	2b00      	cmp	r3, #0
 8002d60:	bf14      	ite	ne
 8002d62:	2301      	movne	r3, #1
 8002d64:	2300      	moveq	r3, #0
 8002d66:	b2db      	uxtb	r3, r3
}
 8002d68:	4618      	mov	r0, r3
 8002d6a:	b003      	add	sp, #12
 8002d6c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d70 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 8002d70:	b500      	push	{lr}
 8002d72:	b087      	sub	sp, #28
 8002d74:	9001      	str	r0, [sp, #4]
 8002d76:	9100      	str	r1, [sp, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002d78:	2302      	movs	r3, #2
 8002d7a:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 8002d7c:	9a00      	ldr	r2, [sp, #0]
 8002d7e:	9b05      	ldr	r3, [sp, #20]
 8002d80:	429a      	cmp	r2, r3
 8002d82:	d201      	bcs.n	8002d88 <vt_set_alarm+0x18>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002d84:	9b05      	ldr	r3, [sp, #20]
 8002d86:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 8002d88:	9900      	ldr	r1, [sp, #0]
 8002d8a:	9801      	ldr	r0, [sp, #4]
 8002d8c:	f7ff fea0 	bl	8002ad0 <chTimeAddX>
 8002d90:	4603      	mov	r3, r0
 8002d92:	4618      	mov	r0, r3
 8002d94:	f7ff ff9c 	bl	8002cd0 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002d98:	f7ff ffd2 	bl	8002d40 <chVTGetSystemTimeX.lto_priv.0>
 8002d9c:	9004      	str	r0, [sp, #16]
    nowdelta = chTimeDiffX(now, newnow);
 8002d9e:	9904      	ldr	r1, [sp, #16]
 8002da0:	9801      	ldr	r0, [sp, #4]
 8002da2:	f7ff fea5 	bl	8002af0 <chTimeDiffX.lto_priv.0>
 8002da6:	9003      	str	r0, [sp, #12]
    if (likely(nowdelta < delay)) {
 8002da8:	9a03      	ldr	r2, [sp, #12]
 8002daa:	9b00      	ldr	r3, [sp, #0]
 8002dac:	429a      	cmp	r2, r3
 8002dae:	bf34      	ite	cc
 8002db0:	2301      	movcc	r3, #1
 8002db2:	2300      	movcs	r3, #0
 8002db4:	b2db      	uxtb	r3, r3
 8002db6:	2b00      	cmp	r3, #0
 8002db8:	d107      	bne.n	8002dca <vt_set_alarm+0x5a>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002dba:	9b05      	ldr	r3, [sp, #20]
 8002dbc:	3301      	adds	r3, #1
 8002dbe:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002dc0:	9b04      	ldr	r3, [sp, #16]
 8002dc2:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 8002dc4:	9b05      	ldr	r3, [sp, #20]
 8002dc6:	9300      	str	r3, [sp, #0]
  while (true) {
 8002dc8:	e7de      	b.n	8002d88 <vt_set_alarm+0x18>
      break;
 8002dca:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002dcc:	9b05      	ldr	r3, [sp, #20]
 8002dce:	2b02      	cmp	r3, #2
 8002dd0:	d902      	bls.n	8002dd8 <vt_set_alarm+0x68>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002dd2:	2001      	movs	r0, #1
 8002dd4:	f7ff fd0c 	bl	80027f0 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002dd8:	bf00      	nop
 8002dda:	b007      	add	sp, #28
 8002ddc:	f85d fb04 	ldr.w	pc, [sp], #4

08002de0 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8002de0:	b500      	push	{lr}
 8002de2:	b087      	sub	sp, #28
 8002de4:	9003      	str	r0, [sp, #12]
 8002de6:	9102      	str	r1, [sp, #8]
 8002de8:	9201      	str	r2, [sp, #4]
 8002dea:	9300      	str	r3, [sp, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8002dec:	9b03      	ldr	r3, [sp, #12]
 8002dee:	9a01      	ldr	r2, [sp, #4]
 8002df0:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8002df2:	9b03      	ldr	r3, [sp, #12]
 8002df4:	9902      	ldr	r1, [sp, #8]
 8002df6:	9a00      	ldr	r2, [sp, #0]
 8002df8:	4618      	mov	r0, r3
 8002dfa:	f7ff fea9 	bl	8002b50 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002dfe:	2302      	movs	r3, #2
 8002e00:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8002e02:	9a00      	ldr	r2, [sp, #0]
 8002e04:	9b05      	ldr	r3, [sp, #20]
 8002e06:	429a      	cmp	r2, r3
 8002e08:	d201      	bcs.n	8002e0e <vt_insert_first+0x2e>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002e0a:	9b05      	ldr	r3, [sp, #20]
 8002e0c:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 8002e0e:	9b03      	ldr	r3, [sp, #12]
 8002e10:	68db      	ldr	r3, [r3, #12]
 8002e12:	9900      	ldr	r1, [sp, #0]
 8002e14:	4618      	mov	r0, r3
 8002e16:	f7ff fe5b 	bl	8002ad0 <chTimeAddX>
 8002e1a:	4603      	mov	r3, r0
 8002e1c:	4618      	mov	r0, r3
 8002e1e:	f7ff ff3f 	bl	8002ca0 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002e22:	f7ff ff8d 	bl	8002d40 <chVTGetSystemTimeX.lto_priv.0>
 8002e26:	9004      	str	r0, [sp, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8002e28:	9904      	ldr	r1, [sp, #16]
 8002e2a:	9801      	ldr	r0, [sp, #4]
 8002e2c:	f7ff fe60 	bl	8002af0 <chTimeDiffX.lto_priv.0>
 8002e30:	4602      	mov	r2, r0
 8002e32:	9b00      	ldr	r3, [sp, #0]
 8002e34:	4293      	cmp	r3, r2
 8002e36:	bf8c      	ite	hi
 8002e38:	2301      	movhi	r3, #1
 8002e3a:	2300      	movls	r3, #0
 8002e3c:	b2db      	uxtb	r3, r3
 8002e3e:	2b00      	cmp	r3, #0
 8002e40:	d10f      	bne.n	8002e62 <vt_insert_first+0x82>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002e42:	9b05      	ldr	r3, [sp, #20]
 8002e44:	3301      	adds	r3, #1
 8002e46:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8002e48:	9905      	ldr	r1, [sp, #20]
 8002e4a:	9801      	ldr	r0, [sp, #4]
 8002e4c:	f7ff fe40 	bl	8002ad0 <chTimeAddX>
 8002e50:	4603      	mov	r3, r0
 8002e52:	4618      	mov	r0, r3
 8002e54:	f7ff ff3c 	bl	8002cd0 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002e58:	9b04      	ldr	r3, [sp, #16]
 8002e5a:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 8002e5c:	9b05      	ldr	r3, [sp, #20]
 8002e5e:	9300      	str	r3, [sp, #0]
  while (true) {
 8002e60:	e7df      	b.n	8002e22 <vt_insert_first+0x42>
      break;
 8002e62:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002e64:	9b05      	ldr	r3, [sp, #20]
 8002e66:	2b02      	cmp	r3, #2
 8002e68:	d902      	bls.n	8002e70 <vt_insert_first+0x90>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002e6a:	2001      	movs	r0, #1
 8002e6c:	f7ff fcc0 	bl	80027f0 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002e70:	bf00      	nop
 8002e72:	b007      	add	sp, #28
 8002e74:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002e80 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 8002e80:	b500      	push	{lr}
 8002e82:	b089      	sub	sp, #36	@ 0x24
 8002e84:	9003      	str	r0, [sp, #12]
 8002e86:	9102      	str	r1, [sp, #8]
 8002e88:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 8002e8a:	f7ff ff59 	bl	8002d40 <chVTGetSystemTimeX.lto_priv.0>
 8002e8e:	9006      	str	r0, [sp, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002e90:	9b03      	ldr	r3, [sp, #12]
 8002e92:	4618      	mov	r0, r3
 8002e94:	f7ff fe3c 	bl	8002b10 <ch_dlist_isempty>
 8002e98:	4603      	mov	r3, r0
 8002e9a:	2b00      	cmp	r3, #0
 8002e9c:	d006      	beq.n	8002eac <vt_enqueue+0x2c>

      vt_insert_first(vtlp, vtp, now, delay);
 8002e9e:	9b01      	ldr	r3, [sp, #4]
 8002ea0:	9a06      	ldr	r2, [sp, #24]
 8002ea2:	9902      	ldr	r1, [sp, #8]
 8002ea4:	9803      	ldr	r0, [sp, #12]
 8002ea6:	f7ff ff9b 	bl	8002de0 <vt_insert_first>

      return;
 8002eaa:	e020      	b.n	8002eee <vt_enqueue+0x6e>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002eac:	9b03      	ldr	r3, [sp, #12]
 8002eae:	68db      	ldr	r3, [r3, #12]
 8002eb0:	9906      	ldr	r1, [sp, #24]
 8002eb2:	4618      	mov	r0, r3
 8002eb4:	f7ff fe1c 	bl	8002af0 <chTimeDiffX.lto_priv.0>
 8002eb8:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
 8002eba:	9a05      	ldr	r2, [sp, #20]
 8002ebc:	9b01      	ldr	r3, [sp, #4]
 8002ebe:	4413      	add	r3, r2
 8002ec0:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 8002ec2:	9a07      	ldr	r2, [sp, #28]
 8002ec4:	9b05      	ldr	r3, [sp, #20]
 8002ec6:	429a      	cmp	r2, r3
 8002ec8:	d201      	bcs.n	8002ece <vt_enqueue+0x4e>
      delta = delay;
 8002eca:	9b01      	ldr	r3, [sp, #4]
 8002ecc:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8002ece:	9b03      	ldr	r3, [sp, #12]
 8002ed0:	681b      	ldr	r3, [r3, #0]
 8002ed2:	689b      	ldr	r3, [r3, #8]
 8002ed4:	9a07      	ldr	r2, [sp, #28]
 8002ed6:	429a      	cmp	r2, r3
 8002ed8:	d203      	bcs.n	8002ee2 <vt_enqueue+0x62>

      vt_set_alarm(now, delay);
 8002eda:	9901      	ldr	r1, [sp, #4]
 8002edc:	9806      	ldr	r0, [sp, #24]
 8002ede:	f7ff ff47 	bl	8002d70 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8002ee2:	9b03      	ldr	r3, [sp, #12]
 8002ee4:	9902      	ldr	r1, [sp, #8]
 8002ee6:	9a07      	ldr	r2, [sp, #28]
 8002ee8:	4618      	mov	r0, r3
 8002eea:	f7ff fe71 	bl	8002bd0 <ch_dlist_insert>
}
 8002eee:	b009      	add	sp, #36	@ 0x24
 8002ef0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002f00 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8002f00:	b500      	push	{lr}
 8002f02:	b087      	sub	sp, #28
 8002f04:	9003      	str	r0, [sp, #12]
 8002f06:	9102      	str	r1, [sp, #8]
 8002f08:	9201      	str	r2, [sp, #4]
 8002f0a:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002f0c:	4b1a      	ldr	r3, [pc, #104]	@ (8002f78 <chVTDoSetI+0x78>)
 8002f0e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002f10:	f7ff fd96 	bl	8002a40 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002f14:	9b03      	ldr	r3, [sp, #12]
 8002f16:	2b00      	cmp	r3, #0
 8002f18:	bf0c      	ite	eq
 8002f1a:	2301      	moveq	r3, #1
 8002f1c:	2300      	movne	r3, #0
 8002f1e:	b2db      	uxtb	r3, r3
 8002f20:	2b00      	cmp	r3, #0
 8002f22:	d107      	bne.n	8002f34 <chVTDoSetI+0x34>
 8002f24:	9b01      	ldr	r3, [sp, #4]
 8002f26:	2b00      	cmp	r3, #0
 8002f28:	bf0c      	ite	eq
 8002f2a:	2301      	moveq	r3, #1
 8002f2c:	2300      	movne	r3, #0
 8002f2e:	b2db      	uxtb	r3, r3
 8002f30:	2b00      	cmp	r3, #0
 8002f32:	d001      	beq.n	8002f38 <chVTDoSetI+0x38>
 8002f34:	2301      	movs	r3, #1
 8002f36:	e000      	b.n	8002f3a <chVTDoSetI+0x3a>
 8002f38:	2300      	movs	r3, #0
 8002f3a:	2b00      	cmp	r3, #0
 8002f3c:	d107      	bne.n	8002f4e <chVTDoSetI+0x4e>
 8002f3e:	9b02      	ldr	r3, [sp, #8]
 8002f40:	2b00      	cmp	r3, #0
 8002f42:	bf0c      	ite	eq
 8002f44:	2301      	moveq	r3, #1
 8002f46:	2300      	movne	r3, #0
 8002f48:	b2db      	uxtb	r3, r3
 8002f4a:	2b00      	cmp	r3, #0
 8002f4c:	d002      	beq.n	8002f54 <chVTDoSetI+0x54>
 8002f4e:	480b      	ldr	r0, [pc, #44]	@ (8002f7c <chVTDoSetI+0x7c>)
 8002f50:	f7ff fbd6 	bl	8002700 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8002f54:	9b03      	ldr	r3, [sp, #12]
 8002f56:	9a00      	ldr	r2, [sp, #0]
 8002f58:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 8002f5a:	9b03      	ldr	r3, [sp, #12]
 8002f5c:	9a01      	ldr	r2, [sp, #4]
 8002f5e:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8002f60:	9b03      	ldr	r3, [sp, #12]
 8002f62:	2200      	movs	r2, #0
 8002f64:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8002f66:	9a02      	ldr	r2, [sp, #8]
 8002f68:	9903      	ldr	r1, [sp, #12]
 8002f6a:	9805      	ldr	r0, [sp, #20]
 8002f6c:	f7ff ff88 	bl	8002e80 <vt_enqueue>
}
 8002f70:	bf00      	nop
 8002f72:	b007      	add	sp, #28
 8002f74:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f78:	200008e0 	.word	0x200008e0
 8002f7c:	080054b8 	.word	0x080054b8

08002f80 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8002f80:	b500      	push	{lr}
 8002f82:	b087      	sub	sp, #28
 8002f84:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002f86:	4b3a      	ldr	r3, [pc, #232]	@ (8003070 <chVTDoResetI+0xf0>)
 8002f88:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002f8a:	f7ff fd59 	bl	8002a40 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8002f8e:	9b01      	ldr	r3, [sp, #4]
 8002f90:	2b00      	cmp	r3, #0
 8002f92:	bf0c      	ite	eq
 8002f94:	2301      	moveq	r3, #1
 8002f96:	2300      	movne	r3, #0
 8002f98:	b2db      	uxtb	r3, r3
 8002f9a:	2b00      	cmp	r3, #0
 8002f9c:	d002      	beq.n	8002fa4 <chVTDoResetI+0x24>
 8002f9e:	4835      	ldr	r0, [pc, #212]	@ (8003074 <chVTDoResetI+0xf4>)
 8002fa0:	f7ff fbae 	bl	8002700 <chSysHalt>
  chDbgAssert(chVTIsArmedI(vtp), "timer not armed");
 8002fa4:	9801      	ldr	r0, [sp, #4]
 8002fa6:	f7ff fed3 	bl	8002d50 <chVTIsArmedI.lto_priv.0>
 8002faa:	4603      	mov	r3, r0
 8002fac:	f083 0301 	eor.w	r3, r3, #1
 8002fb0:	b2db      	uxtb	r3, r3
 8002fb2:	2b00      	cmp	r3, #0
 8002fb4:	d002      	beq.n	8002fbc <chVTDoResetI+0x3c>
 8002fb6:	482f      	ldr	r0, [pc, #188]	@ (8003074 <chVTDoResetI+0xf4>)
 8002fb8:	f7ff fba2 	bl	8002700 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8002fbc:	9b05      	ldr	r3, [sp, #20]
 8002fbe:	9a01      	ldr	r2, [sp, #4]
 8002fc0:	4611      	mov	r1, r2
 8002fc2:	4618      	mov	r0, r3
 8002fc4:	f7ff fdb4 	bl	8002b30 <ch_dlist_isfirst>
 8002fc8:	4603      	mov	r3, r0
 8002fca:	f083 0301 	eor.w	r3, r3, #1
 8002fce:	b2db      	uxtb	r3, r3
 8002fd0:	2b00      	cmp	r3, #0
 8002fd2:	d014      	beq.n	8002ffe <chVTDoResetI+0x7e>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8002fd4:	9b01      	ldr	r3, [sp, #4]
 8002fd6:	4618      	mov	r0, r3
 8002fd8:	f7ff fe52 	bl	8002c80 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8002fdc:	9b01      	ldr	r3, [sp, #4]
 8002fde:	681b      	ldr	r3, [r3, #0]
 8002fe0:	6899      	ldr	r1, [r3, #8]
 8002fe2:	9b01      	ldr	r3, [sp, #4]
 8002fe4:	689a      	ldr	r2, [r3, #8]
 8002fe6:	9b01      	ldr	r3, [sp, #4]
 8002fe8:	681b      	ldr	r3, [r3, #0]
 8002fea:	440a      	add	r2, r1
 8002fec:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8002fee:	9b01      	ldr	r3, [sp, #4]
 8002ff0:	2200      	movs	r2, #0
 8002ff2:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8002ff4:	9b05      	ldr	r3, [sp, #20]
 8002ff6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8002ffa:	609a      	str	r2, [r3, #8]

    return;
 8002ffc:	e035      	b.n	800306a <chVTDoResetI+0xea>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8002ffe:	9b05      	ldr	r3, [sp, #20]
 8003000:	4618      	mov	r0, r3
 8003002:	f7ff fe25 	bl	8002c50 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8003006:	9b01      	ldr	r3, [sp, #4]
 8003008:	2200      	movs	r2, #0
 800300a:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 800300c:	9b05      	ldr	r3, [sp, #20]
 800300e:	4618      	mov	r0, r3
 8003010:	f7ff fd7e 	bl	8002b10 <ch_dlist_isempty>
 8003014:	4603      	mov	r3, r0
 8003016:	2b00      	cmp	r3, #0
 8003018:	d002      	beq.n	8003020 <chVTDoResetI+0xa0>

    port_timer_stop_alarm();
 800301a:	f7ff fe51 	bl	8002cc0 <port_timer_stop_alarm>

    return;
 800301e:	e024      	b.n	800306a <chVTDoResetI+0xea>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8003020:	9b05      	ldr	r3, [sp, #20]
 8003022:	681b      	ldr	r3, [r3, #0]
 8003024:	6899      	ldr	r1, [r3, #8]
 8003026:	9b01      	ldr	r3, [sp, #4]
 8003028:	689a      	ldr	r2, [r3, #8]
 800302a:	9b05      	ldr	r3, [sp, #20]
 800302c:	681b      	ldr	r3, [r3, #0]
 800302e:	440a      	add	r2, r1
 8003030:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 8003032:	f7ff fe85 	bl	8002d40 <chVTGetSystemTimeX.lto_priv.0>
 8003036:	9004      	str	r0, [sp, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003038:	9b05      	ldr	r3, [sp, #20]
 800303a:	68db      	ldr	r3, [r3, #12]
 800303c:	9904      	ldr	r1, [sp, #16]
 800303e:	4618      	mov	r0, r3
 8003040:	f7ff fd56 	bl	8002af0 <chTimeDiffX.lto_priv.0>
 8003044:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8003046:	9b05      	ldr	r3, [sp, #20]
 8003048:	681b      	ldr	r3, [r3, #0]
 800304a:	689b      	ldr	r3, [r3, #8]
 800304c:	9a03      	ldr	r2, [sp, #12]
 800304e:	429a      	cmp	r2, r3
 8003050:	d20a      	bcs.n	8003068 <chVTDoResetI+0xe8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8003052:	9b05      	ldr	r3, [sp, #20]
 8003054:	681b      	ldr	r3, [r3, #0]
 8003056:	689a      	ldr	r2, [r3, #8]
 8003058:	9b03      	ldr	r3, [sp, #12]
 800305a:	1ad3      	subs	r3, r2, r3
 800305c:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 800305e:	9902      	ldr	r1, [sp, #8]
 8003060:	9804      	ldr	r0, [sp, #16]
 8003062:	f7ff fe85 	bl	8002d70 <vt_set_alarm>
 8003066:	e000      	b.n	800306a <chVTDoResetI+0xea>
    return;
 8003068:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800306a:	b007      	add	sp, #28
 800306c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003070:	200008e0 	.word	0x200008e0
 8003074:	080054c4 	.word	0x080054c4
	...

08003080 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8003080:	b500      	push	{lr}
 8003082:	b089      	sub	sp, #36	@ 0x24
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003084:	4b4f      	ldr	r3, [pc, #316]	@ (80031c4 <chVTDoTickI+0x144>)
 8003086:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8003088:	f7ff fcda 	bl	8002a40 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 800308c:	9b05      	ldr	r3, [sp, #20]
 800308e:	681b      	ldr	r3, [r3, #0]
 8003090:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 8003092:	f7ff fe55 	bl	8002d40 <chVTGetSystemTimeX.lto_priv.0>
 8003096:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003098:	9b05      	ldr	r3, [sp, #20]
 800309a:	68db      	ldr	r3, [r3, #12]
 800309c:	9903      	ldr	r1, [sp, #12]
 800309e:	4618      	mov	r0, r3
 80030a0:	f7ff fd26 	bl	8002af0 <chTimeDiffX.lto_priv.0>
 80030a4:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 80030a6:	9b04      	ldr	r3, [sp, #16]
 80030a8:	689b      	ldr	r3, [r3, #8]
 80030aa:	9a02      	ldr	r2, [sp, #8]
 80030ac:	429a      	cmp	r2, r3
 80030ae:	d369      	bcc.n	8003184 <chVTDoTickI+0x104>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 80030b0:	9b05      	ldr	r3, [sp, #20]
 80030b2:	68da      	ldr	r2, [r3, #12]
 80030b4:	9b04      	ldr	r3, [sp, #16]
 80030b6:	689b      	ldr	r3, [r3, #8]
 80030b8:	4619      	mov	r1, r3
 80030ba:	4610      	mov	r0, r2
 80030bc:	f7ff fd08 	bl	8002ad0 <chTimeAddX>
 80030c0:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
 80030c2:	9b05      	ldr	r3, [sp, #20]
 80030c4:	9a01      	ldr	r2, [sp, #4]
 80030c6:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 80030c8:	9b04      	ldr	r3, [sp, #16]
 80030ca:	4618      	mov	r0, r3
 80030cc:	f7ff fdd8 	bl	8002c80 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 80030d0:	9b04      	ldr	r3, [sp, #16]
 80030d2:	2200      	movs	r2, #0
 80030d4:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 80030d6:	9b05      	ldr	r3, [sp, #20]
 80030d8:	4618      	mov	r0, r3
 80030da:	f7ff fd19 	bl	8002b10 <ch_dlist_isempty>
 80030de:	4603      	mov	r3, r0
 80030e0:	2b00      	cmp	r3, #0
 80030e2:	d001      	beq.n	80030e8 <chVTDoTickI+0x68>
      port_timer_stop_alarm();
 80030e4:	f7ff fdec 	bl	8002cc0 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 80030e8:	f7ff fe1a 	bl	8002d20 <chSysUnlockFromISR.lto_priv.3>

    vtp->func(vtp, vtp->par);
 80030ec:	9b04      	ldr	r3, [sp, #16]
 80030ee:	68db      	ldr	r3, [r3, #12]
 80030f0:	9a04      	ldr	r2, [sp, #16]
 80030f2:	6912      	ldr	r2, [r2, #16]
 80030f4:	4611      	mov	r1, r2
 80030f6:	9804      	ldr	r0, [sp, #16]
 80030f8:	4798      	blx	r3

    chSysLockFromISR();
 80030fa:	f7ff fe01 	bl	8002d00 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 80030fe:	9b04      	ldr	r3, [sp, #16]
 8003100:	695b      	ldr	r3, [r3, #20]
 8003102:	2b00      	cmp	r3, #0
 8003104:	bf14      	ite	ne
 8003106:	2301      	movne	r3, #1
 8003108:	2300      	moveq	r3, #0
 800310a:	b2db      	uxtb	r3, r3
 800310c:	2b00      	cmp	r3, #0
 800310e:	d0bd      	beq.n	800308c <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8003110:	f7ff fe16 	bl	8002d40 <chVTGetSystemTimeX.lto_priv.0>
 8003114:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 8003116:	9903      	ldr	r1, [sp, #12]
 8003118:	9801      	ldr	r0, [sp, #4]
 800311a:	f7ff fce9 	bl	8002af0 <chTimeDiffX.lto_priv.0>
 800311e:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8003120:	9b04      	ldr	r3, [sp, #16]
 8003122:	695b      	ldr	r3, [r3, #20]
 8003124:	9a02      	ldr	r2, [sp, #8]
 8003126:	429a      	cmp	r2, r3
 8003128:	d908      	bls.n	800313c <chVTDoTickI+0xbc>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
 800312a:	4827      	ldr	r0, [pc, #156]	@ (80031c8 <chVTDoTickI+0x148>)
 800312c:	f7ff fae8 	bl	8002700 <chSysHalt>
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8003130:	2002      	movs	r0, #2
 8003132:	f7ff fb5d 	bl	80027f0 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8003136:	2300      	movs	r3, #0
 8003138:	9306      	str	r3, [sp, #24]
 800313a:	e004      	b.n	8003146 <chVTDoTickI+0xc6>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 800313c:	9b04      	ldr	r3, [sp, #16]
 800313e:	695a      	ldr	r2, [r3, #20]
 8003140:	9b02      	ldr	r3, [sp, #8]
 8003142:	1ad3      	subs	r3, r2, r3
 8003144:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8003146:	9b05      	ldr	r3, [sp, #20]
 8003148:	4618      	mov	r0, r3
 800314a:	f7ff fce1 	bl	8002b10 <ch_dlist_isempty>
 800314e:	4603      	mov	r3, r0
 8003150:	2b00      	cmp	r3, #0
 8003152:	d006      	beq.n	8003162 <chVTDoTickI+0xe2>

        vt_insert_first(vtlp, vtp, now, delay);
 8003154:	9b06      	ldr	r3, [sp, #24]
 8003156:	9a03      	ldr	r2, [sp, #12]
 8003158:	9904      	ldr	r1, [sp, #16]
 800315a:	9805      	ldr	r0, [sp, #20]
 800315c:	f7ff fe40 	bl	8002de0 <vt_insert_first>

        return;
 8003160:	e02c      	b.n	80031bc <chVTDoTickI+0x13c>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8003162:	9a02      	ldr	r2, [sp, #8]
 8003164:	9b06      	ldr	r3, [sp, #24]
 8003166:	4413      	add	r3, r2
 8003168:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 800316a:	9a07      	ldr	r2, [sp, #28]
 800316c:	9b02      	ldr	r3, [sp, #8]
 800316e:	429a      	cmp	r2, r3
 8003170:	d201      	bcs.n	8003176 <chVTDoTickI+0xf6>
        delta = delay;
 8003172:	9b06      	ldr	r3, [sp, #24]
 8003174:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003176:	9b05      	ldr	r3, [sp, #20]
 8003178:	9904      	ldr	r1, [sp, #16]
 800317a:	9a07      	ldr	r2, [sp, #28]
 800317c:	4618      	mov	r0, r3
 800317e:	f7ff fd27 	bl	8002bd0 <ch_dlist_insert>
  while (true) {
 8003182:	e783      	b.n	800308c <chVTDoTickI+0xc>
      break;
 8003184:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003186:	9b05      	ldr	r3, [sp, #20]
 8003188:	4618      	mov	r0, r3
 800318a:	f7ff fcc1 	bl	8002b10 <ch_dlist_isempty>
 800318e:	4603      	mov	r3, r0
 8003190:	2b00      	cmp	r3, #0
 8003192:	d112      	bne.n	80031ba <chVTDoTickI+0x13a>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 8003194:	9b05      	ldr	r3, [sp, #20]
 8003196:	68da      	ldr	r2, [r3, #12]
 8003198:	9b02      	ldr	r3, [sp, #8]
 800319a:	441a      	add	r2, r3
 800319c:	9b05      	ldr	r3, [sp, #20]
 800319e:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 80031a0:	9b04      	ldr	r3, [sp, #16]
 80031a2:	689a      	ldr	r2, [r3, #8]
 80031a4:	9b02      	ldr	r3, [sp, #8]
 80031a6:	1ad2      	subs	r2, r2, r3
 80031a8:	9b04      	ldr	r3, [sp, #16]
 80031aa:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 80031ac:	9b04      	ldr	r3, [sp, #16]
 80031ae:	689b      	ldr	r3, [r3, #8]
 80031b0:	4619      	mov	r1, r3
 80031b2:	9803      	ldr	r0, [sp, #12]
 80031b4:	f7ff fddc 	bl	8002d70 <vt_set_alarm>
 80031b8:	e000      	b.n	80031bc <chVTDoTickI+0x13c>
    return;
 80031ba:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80031bc:	b009      	add	sp, #36	@ 0x24
 80031be:	f85d fb04 	ldr.w	pc, [sp], #4
 80031c2:	bf00      	nop
 80031c4:	200008e0 	.word	0x200008e0
 80031c8:	080054d4 	.word	0x080054d4
 80031cc:	00000000 	.word	0x00000000

080031d0 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80031d0:	b082      	sub	sp, #8
 80031d2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80031d4:	9b01      	ldr	r3, [sp, #4]
 80031d6:	685b      	ldr	r3, [r3, #4]
 80031d8:	9a01      	ldr	r2, [sp, #4]
 80031da:	6812      	ldr	r2, [r2, #0]
 80031dc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80031de:	9b01      	ldr	r3, [sp, #4]
 80031e0:	681b      	ldr	r3, [r3, #0]
 80031e2:	9a01      	ldr	r2, [sp, #4]
 80031e4:	6852      	ldr	r2, [r2, #4]
 80031e6:	605a      	str	r2, [r3, #4]
  return p;
 80031e8:	9b01      	ldr	r3, [sp, #4]
}
 80031ea:	4618      	mov	r0, r3
 80031ec:	b002      	add	sp, #8
 80031ee:	4770      	bx	lr

080031f0 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 80031f0:	b084      	sub	sp, #16
 80031f2:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 80031f4:	9b01      	ldr	r3, [sp, #4]
 80031f6:	681b      	ldr	r3, [r3, #0]
 80031f8:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 80031fa:	9b03      	ldr	r3, [sp, #12]
 80031fc:	681a      	ldr	r2, [r3, #0]
 80031fe:	9b01      	ldr	r3, [sp, #4]
 8003200:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 8003202:	9b01      	ldr	r3, [sp, #4]
 8003204:	681b      	ldr	r3, [r3, #0]
 8003206:	9a01      	ldr	r2, [sp, #4]
 8003208:	605a      	str	r2, [r3, #4]
  return p;
 800320a:	9b03      	ldr	r3, [sp, #12]
}
 800320c:	4618      	mov	r0, r3
 800320e:	b004      	add	sp, #16
 8003210:	4770      	bx	lr
 8003212:	bf00      	nop
	...

08003220 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8003220:	b082      	sub	sp, #8
 8003222:	9001      	str	r0, [sp, #4]
 8003224:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003226:	9b01      	ldr	r3, [sp, #4]
 8003228:	681b      	ldr	r3, [r3, #0]
 800322a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 800322c:	9b01      	ldr	r3, [sp, #4]
 800322e:	689a      	ldr	r2, [r3, #8]
 8003230:	9b00      	ldr	r3, [sp, #0]
 8003232:	689b      	ldr	r3, [r3, #8]
 8003234:	429a      	cmp	r2, r3
 8003236:	bf2c      	ite	cs
 8003238:	2301      	movcs	r3, #1
 800323a:	2300      	movcc	r3, #0
 800323c:	b2db      	uxtb	r3, r3
 800323e:	2b00      	cmp	r3, #0
 8003240:	d1f1      	bne.n	8003226 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8003242:	9b00      	ldr	r3, [sp, #0]
 8003244:	9a01      	ldr	r2, [sp, #4]
 8003246:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003248:	9b01      	ldr	r3, [sp, #4]
 800324a:	685a      	ldr	r2, [r3, #4]
 800324c:	9b00      	ldr	r3, [sp, #0]
 800324e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003250:	9b00      	ldr	r3, [sp, #0]
 8003252:	685b      	ldr	r3, [r3, #4]
 8003254:	9a00      	ldr	r2, [sp, #0]
 8003256:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003258:	9b01      	ldr	r3, [sp, #4]
 800325a:	9a00      	ldr	r2, [sp, #0]
 800325c:	605a      	str	r2, [r3, #4]
  return p;
 800325e:	9b00      	ldr	r3, [sp, #0]
}
 8003260:	4618      	mov	r0, r3
 8003262:	b002      	add	sp, #8
 8003264:	4770      	bx	lr
 8003266:	bf00      	nop
	...

08003270 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8003270:	b082      	sub	sp, #8
 8003272:	9001      	str	r0, [sp, #4]
 8003274:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003276:	9b01      	ldr	r3, [sp, #4]
 8003278:	681b      	ldr	r3, [r3, #0]
 800327a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 800327c:	9b01      	ldr	r3, [sp, #4]
 800327e:	689a      	ldr	r2, [r3, #8]
 8003280:	9b00      	ldr	r3, [sp, #0]
 8003282:	689b      	ldr	r3, [r3, #8]
 8003284:	429a      	cmp	r2, r3
 8003286:	bf8c      	ite	hi
 8003288:	2301      	movhi	r3, #1
 800328a:	2300      	movls	r3, #0
 800328c:	b2db      	uxtb	r3, r3
 800328e:	2b00      	cmp	r3, #0
 8003290:	d1f1      	bne.n	8003276 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 8003292:	9b00      	ldr	r3, [sp, #0]
 8003294:	9a01      	ldr	r2, [sp, #4]
 8003296:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003298:	9b01      	ldr	r3, [sp, #4]
 800329a:	685a      	ldr	r2, [r3, #4]
 800329c:	9b00      	ldr	r3, [sp, #0]
 800329e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 80032a0:	9b00      	ldr	r3, [sp, #0]
 80032a2:	685b      	ldr	r3, [r3, #4]
 80032a4:	9a00      	ldr	r2, [sp, #0]
 80032a6:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 80032a8:	9b01      	ldr	r3, [sp, #4]
 80032aa:	9a00      	ldr	r2, [sp, #0]
 80032ac:	605a      	str	r2, [r3, #4]
  return p;
 80032ae:	9b00      	ldr	r3, [sp, #0]
}
 80032b0:	4618      	mov	r0, r3
 80032b2:	b002      	add	sp, #8
 80032b4:	4770      	bx	lr
 80032b6:	bf00      	nop
	...

080032c0 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 80032c0:	b500      	push	{lr}
 80032c2:	b083      	sub	sp, #12
 80032c4:	2330      	movs	r3, #48	@ 0x30
 80032c6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80032c8:	9b01      	ldr	r3, [sp, #4]
 80032ca:	f383 8811 	msr	BASEPRI, r3
}
 80032ce:	bf00      	nop
}
 80032d0:	bf00      	nop
}
 80032d2:	bf00      	nop
  __dbg_check_lock_from_isr();
 80032d4:	f7ff faec 	bl	80028b0 <__dbg_check_lock_from_isr>
}
 80032d8:	bf00      	nop
 80032da:	b003      	add	sp, #12
 80032dc:	f85d fb04 	ldr.w	pc, [sp], #4

080032e0 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 80032e0:	b500      	push	{lr}
 80032e2:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 80032e4:	f7ff fb0c 	bl	8002900 <__dbg_check_unlock_from_isr>
 80032e8:	2300      	movs	r3, #0
 80032ea:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80032ec:	9b01      	ldr	r3, [sp, #4]
 80032ee:	f383 8811 	msr	BASEPRI, r3
}
 80032f2:	bf00      	nop
}
 80032f4:	bf00      	nop
}
 80032f6:	bf00      	nop
}
 80032f8:	bf00      	nop
 80032fa:	b003      	add	sp, #12
 80032fc:	f85d fb04 	ldr.w	pc, [sp], #4

08003300 <chVTIsArmedI.lto_priv.1>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8003300:	b500      	push	{lr}
 8003302:	b083      	sub	sp, #12
 8003304:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8003306:	f7ff fb9b 	bl	8002a40 <chDbgCheckClassI>
  return (bool)(vtp->dlist.next != NULL);
 800330a:	9b01      	ldr	r3, [sp, #4]
 800330c:	681b      	ldr	r3, [r3, #0]
 800330e:	2b00      	cmp	r3, #0
 8003310:	bf14      	ite	ne
 8003312:	2301      	movne	r3, #1
 8003314:	2300      	moveq	r3, #0
 8003316:	b2db      	uxtb	r3, r3
}
 8003318:	4618      	mov	r0, r3
 800331a:	b003      	add	sp, #12
 800331c:	f85d fb04 	ldr.w	pc, [sp], #4

08003320 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8003320:	b500      	push	{lr}
 8003322:	b083      	sub	sp, #12
 8003324:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003326:	f7ff fb8b 	bl	8002a40 <chDbgCheckClassI>

  sp->cnt++;
 800332a:	9b01      	ldr	r3, [sp, #4]
 800332c:	689b      	ldr	r3, [r3, #8]
 800332e:	1c5a      	adds	r2, r3, #1
 8003330:	9b01      	ldr	r3, [sp, #4]
 8003332:	609a      	str	r2, [r3, #8]
}
 8003334:	bf00      	nop
 8003336:	b003      	add	sp, #12
 8003338:	f85d fb04 	ldr.w	pc, [sp], #4
 800333c:	0000      	movs	r0, r0
	...

08003340 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8003340:	b500      	push	{lr}
 8003342:	b083      	sub	sp, #12
 8003344:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003346:	9b01      	ldr	r3, [sp, #4]
 8003348:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800334c:	2b00      	cmp	r3, #0
 800334e:	bf0c      	ite	eq
 8003350:	2301      	moveq	r3, #1
 8003352:	2300      	movne	r3, #0
 8003354:	b2db      	uxtb	r3, r3
 8003356:	2b00      	cmp	r3, #0
 8003358:	d109      	bne.n	800336e <__sch_ready_behind+0x2e>
 800335a:	9b01      	ldr	r3, [sp, #4]
 800335c:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003360:	2b0f      	cmp	r3, #15
 8003362:	bf0c      	ite	eq
 8003364:	2301      	moveq	r3, #1
 8003366:	2300      	movne	r3, #0
 8003368:	b2db      	uxtb	r3, r3
 800336a:	2b00      	cmp	r3, #0
 800336c:	d002      	beq.n	8003374 <__sch_ready_behind+0x34>
 800336e:	480a      	ldr	r0, [pc, #40]	@ (8003398 <__sch_ready_behind+0x58>)
 8003370:	f7ff f9c6 	bl	8002700 <chSysHalt>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003374:	9b01      	ldr	r3, [sp, #4]
 8003376:	2200      	movs	r2, #0
 8003378:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800337c:	9b01      	ldr	r3, [sp, #4]
 800337e:	699b      	ldr	r3, [r3, #24]
 8003380:	461a      	mov	r2, r3
 8003382:	9b01      	ldr	r3, [sp, #4]
 8003384:	4619      	mov	r1, r3
 8003386:	4610      	mov	r0, r2
 8003388:	f7ff ff4a 	bl	8003220 <ch_pqueue_insert_behind>
 800338c:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
 800338e:	4618      	mov	r0, r3
 8003390:	b003      	add	sp, #12
 8003392:	f85d fb04 	ldr.w	pc, [sp], #4
 8003396:	bf00      	nop
 8003398:	080054e0 	.word	0x080054e0
 800339c:	00000000 	.word	0x00000000

080033a0 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 80033a0:	b500      	push	{lr}
 80033a2:	b083      	sub	sp, #12
 80033a4:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 80033a6:	9b01      	ldr	r3, [sp, #4]
 80033a8:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 80033ac:	2b00      	cmp	r3, #0
 80033ae:	bf0c      	ite	eq
 80033b0:	2301      	moveq	r3, #1
 80033b2:	2300      	movne	r3, #0
 80033b4:	b2db      	uxtb	r3, r3
 80033b6:	2b00      	cmp	r3, #0
 80033b8:	d109      	bne.n	80033ce <__sch_ready_ahead+0x2e>
 80033ba:	9b01      	ldr	r3, [sp, #4]
 80033bc:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 80033c0:	2b0f      	cmp	r3, #15
 80033c2:	bf0c      	ite	eq
 80033c4:	2301      	moveq	r3, #1
 80033c6:	2300      	movne	r3, #0
 80033c8:	b2db      	uxtb	r3, r3
 80033ca:	2b00      	cmp	r3, #0
 80033cc:	d002      	beq.n	80033d4 <__sch_ready_ahead+0x34>
 80033ce:	480a      	ldr	r0, [pc, #40]	@ (80033f8 <__sch_ready_ahead+0x58>)
 80033d0:	f7ff f996 	bl	8002700 <chSysHalt>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80033d4:	9b01      	ldr	r3, [sp, #4]
 80033d6:	2200      	movs	r2, #0
 80033d8:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 80033dc:	9b01      	ldr	r3, [sp, #4]
 80033de:	699b      	ldr	r3, [r3, #24]
 80033e0:	461a      	mov	r2, r3
 80033e2:	9b01      	ldr	r3, [sp, #4]
 80033e4:	4619      	mov	r1, r3
 80033e6:	4610      	mov	r0, r2
 80033e8:	f7ff ff42 	bl	8003270 <ch_pqueue_insert_ahead>
 80033ec:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
 80033ee:	4618      	mov	r0, r3
 80033f0:	b003      	add	sp, #12
 80033f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80033f6:	bf00      	nop
 80033f8:	080054f4 	.word	0x080054f4
 80033fc:	00000000 	.word	0x00000000

08003400 <__sch_reschedule_ahead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_ahead(void) {
 8003400:	b500      	push	{lr}
 8003402:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8003404:	4b0e      	ldr	r3, [pc, #56]	@ (8003440 <__sch_reschedule_ahead+0x40>)
 8003406:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 8003408:	9b03      	ldr	r3, [sp, #12]
 800340a:	68db      	ldr	r3, [r3, #12]
 800340c:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800340e:	9b03      	ldr	r3, [sp, #12]
 8003410:	4618      	mov	r0, r3
 8003412:	f7ff feed 	bl	80031f0 <ch_pqueue_remove_highest>
 8003416:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 8003418:	9b01      	ldr	r3, [sp, #4]
 800341a:	2201      	movs	r2, #1
 800341c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8003420:	9b03      	ldr	r3, [sp, #12]
 8003422:	9a01      	ldr	r2, [sp, #4]
 8003424:	60da      	str	r2, [r3, #12]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = __sch_ready_ahead(otp);
 8003426:	9802      	ldr	r0, [sp, #8]
 8003428:	f7ff ffba 	bl	80033a0 <__sch_ready_ahead>
 800342c:	9002      	str	r0, [sp, #8]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800342e:	9902      	ldr	r1, [sp, #8]
 8003430:	9801      	ldr	r0, [sp, #4]
 8003432:	f7fc ff35 	bl	80002a0 <__port_switch>
}
 8003436:	bf00      	nop
 8003438:	b005      	add	sp, #20
 800343a:	f85d fb04 	ldr.w	pc, [sp], #4
 800343e:	bf00      	nop
 8003440:	200008d0 	.word	0x200008d0
	...

08003450 <__sch_wakeup>:

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8003450:	b500      	push	{lr}
 8003452:	b085      	sub	sp, #20
 8003454:	9001      	str	r0, [sp, #4]
 8003456:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 8003458:	9b00      	ldr	r3, [sp, #0]
 800345a:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 800345c:	f7ff ff30 	bl	80032c0 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
 8003460:	9b03      	ldr	r3, [sp, #12]
 8003462:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003466:	2b0c      	cmp	r3, #12
 8003468:	d82e      	bhi.n	80034c8 <__sch_wakeup+0x78>
 800346a:	a201      	add	r2, pc, #4	@ (adr r2, 8003470 <__sch_wakeup+0x20>)
 800346c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003470:	080034a5 	.word	0x080034a5
 8003474:	080034c9 	.word	0x080034c9
 8003478:	080034c9 	.word	0x080034c9
 800347c:	080034ab 	.word	0x080034ab
 8003480:	080034bf 	.word	0x080034bf
 8003484:	080034b5 	.word	0x080034b5
 8003488:	080034c9 	.word	0x080034c9
 800348c:	080034bf 	.word	0x080034bf
 8003490:	080034c9 	.word	0x080034c9
 8003494:	080034c9 	.word	0x080034c9
 8003498:	080034c9 	.word	0x080034c9
 800349c:	080034c9 	.word	0x080034c9
 80034a0:	080034bf 	.word	0x080034bf
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 80034a4:	f7ff ff1c 	bl	80032e0 <chSysUnlockFromISR.lto_priv.4>
    return;
 80034a8:	e019      	b.n	80034de <__sch_wakeup+0x8e>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80034aa:	9b03      	ldr	r3, [sp, #12]
 80034ac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80034ae:	2200      	movs	r2, #0
 80034b0:	601a      	str	r2, [r3, #0]
    break;
 80034b2:	e00a      	b.n	80034ca <__sch_wakeup+0x7a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80034b4:	9b03      	ldr	r3, [sp, #12]
 80034b6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80034b8:	4618      	mov	r0, r3
 80034ba:	f7ff ff31 	bl	8003320 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 80034be:	9b03      	ldr	r3, [sp, #12]
 80034c0:	4618      	mov	r0, r3
 80034c2:	f7ff fe85 	bl	80031d0 <ch_queue_dequeue.lto_priv.0>
    break;
 80034c6:	e000      	b.n	80034ca <__sch_wakeup+0x7a>
  default:
    /* Any other state, nothing to do.*/
    break;
 80034c8:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 80034ca:	9b03      	ldr	r3, [sp, #12]
 80034cc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80034d0:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 80034d2:	9803      	ldr	r0, [sp, #12]
 80034d4:	f7ff ff34 	bl	8003340 <__sch_ready_behind>
  chSysUnlockFromISR();
 80034d8:	f7ff ff02 	bl	80032e0 <chSysUnlockFromISR.lto_priv.4>

  return;
 80034dc:	bf00      	nop
}
 80034de:	b005      	add	sp, #20
 80034e0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080034f0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80034f0:	b500      	push	{lr}
 80034f2:	b083      	sub	sp, #12
 80034f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80034f6:	f7ff faa3 	bl	8002a40 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80034fa:	9b01      	ldr	r3, [sp, #4]
 80034fc:	2b00      	cmp	r3, #0
 80034fe:	bf0c      	ite	eq
 8003500:	2301      	moveq	r3, #1
 8003502:	2300      	movne	r3, #0
 8003504:	b2db      	uxtb	r3, r3
 8003506:	2b00      	cmp	r3, #0
 8003508:	d002      	beq.n	8003510 <chSchReadyI+0x20>
 800350a:	4805      	ldr	r0, [pc, #20]	@ (8003520 <chSchReadyI+0x30>)
 800350c:	f7ff f8f8 	bl	8002700 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 8003510:	9801      	ldr	r0, [sp, #4]
 8003512:	f7ff ff15 	bl	8003340 <__sch_ready_behind>
 8003516:	4603      	mov	r3, r0
}
 8003518:	4618      	mov	r0, r3
 800351a:	b003      	add	sp, #12
 800351c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003520:	08005508 	.word	0x08005508
	...

08003530 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003530:	b500      	push	{lr}
 8003532:	b087      	sub	sp, #28
 8003534:	4603      	mov	r3, r0
 8003536:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
 800353a:	4b1d      	ldr	r3, [pc, #116]	@ (80035b0 <chSchGoSleepS+0x80>)
 800353c:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 800353e:	9b05      	ldr	r3, [sp, #20]
 8003540:	68db      	ldr	r3, [r3, #12]
 8003542:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  chDbgCheckClassS();
 8003544:	f7ff fa9c 	bl	8002a80 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 8003548:	f7ff f8f2 	bl	8002730 <chSysGetIdleThreadX>
 800354c:	4602      	mov	r2, r0
 800354e:	9b04      	ldr	r3, [sp, #16]
 8003550:	4293      	cmp	r3, r2
 8003552:	bf0c      	ite	eq
 8003554:	2301      	moveq	r3, #1
 8003556:	2300      	movne	r3, #0
 8003558:	b2db      	uxtb	r3, r3
 800355a:	2b00      	cmp	r3, #0
 800355c:	d002      	beq.n	8003564 <chSchGoSleepS+0x34>
 800355e:	4815      	ldr	r0, [pc, #84]	@ (80035b4 <chSchGoSleepS+0x84>)
 8003560:	f7ff f8ce 	bl	8002700 <chSysHalt>
  chDbgAssert(otp->owner == oip, "invalid core");
 8003564:	9b04      	ldr	r3, [sp, #16]
 8003566:	699b      	ldr	r3, [r3, #24]
 8003568:	9a05      	ldr	r2, [sp, #20]
 800356a:	429a      	cmp	r2, r3
 800356c:	bf14      	ite	ne
 800356e:	2301      	movne	r3, #1
 8003570:	2300      	moveq	r3, #0
 8003572:	b2db      	uxtb	r3, r3
 8003574:	2b00      	cmp	r3, #0
 8003576:	d002      	beq.n	800357e <chSchGoSleepS+0x4e>
 8003578:	480e      	ldr	r0, [pc, #56]	@ (80035b4 <chSchGoSleepS+0x84>)
 800357a:	f7ff f8c1 	bl	8002700 <chSysHalt>

  /* New state.*/
  otp->state = newstate;
 800357e:	9b04      	ldr	r3, [sp, #16]
 8003580:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8003584:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8003588:	9b05      	ldr	r3, [sp, #20]
 800358a:	4618      	mov	r0, r3
 800358c:	f7ff fe30 	bl	80031f0 <ch_pqueue_remove_highest>
 8003590:	9003      	str	r0, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 8003592:	9b03      	ldr	r3, [sp, #12]
 8003594:	2201      	movs	r2, #1
 8003596:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 800359a:	9b05      	ldr	r3, [sp, #20]
 800359c:	9a03      	ldr	r2, [sp, #12]
 800359e:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80035a0:	9904      	ldr	r1, [sp, #16]
 80035a2:	9803      	ldr	r0, [sp, #12]
 80035a4:	f7fc fe7c 	bl	80002a0 <__port_switch>
}
 80035a8:	bf00      	nop
 80035aa:	b007      	add	sp, #28
 80035ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80035b0:	200008d0 	.word	0x200008d0
 80035b4:	08005514 	.word	0x08005514
	...

080035c0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80035c0:	b500      	push	{lr}
 80035c2:	b08b      	sub	sp, #44	@ 0x2c
 80035c4:	4603      	mov	r3, r0
 80035c6:	9100      	str	r1, [sp, #0]
 80035c8:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 80035cc:	4b15      	ldr	r3, [pc, #84]	@ (8003624 <chSchGoSleepTimeoutS+0x64>)
 80035ce:	68db      	ldr	r3, [r3, #12]
 80035d0:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();
 80035d2:	f7ff fa55 	bl	8002a80 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 80035d6:	9b00      	ldr	r3, [sp, #0]
 80035d8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80035dc:	d016      	beq.n	800360c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 80035de:	a803      	add	r0, sp, #12
 80035e0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80035e2:	4a11      	ldr	r2, [pc, #68]	@ (8003628 <chSchGoSleepTimeoutS+0x68>)
 80035e4:	9900      	ldr	r1, [sp, #0]
 80035e6:	f7ff fc8b 	bl	8002f00 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80035ea:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80035ee:	4618      	mov	r0, r3
 80035f0:	f7ff ff9e 	bl	8003530 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80035f4:	ab03      	add	r3, sp, #12
 80035f6:	4618      	mov	r0, r3
 80035f8:	f7ff fe82 	bl	8003300 <chVTIsArmedI.lto_priv.1>
 80035fc:	4603      	mov	r3, r0
 80035fe:	2b00      	cmp	r3, #0
 8003600:	d009      	beq.n	8003616 <chSchGoSleepTimeoutS+0x56>
      chVTDoResetI(&vt);
 8003602:	ab03      	add	r3, sp, #12
 8003604:	4618      	mov	r0, r3
 8003606:	f7ff fcbb 	bl	8002f80 <chVTDoResetI>
 800360a:	e004      	b.n	8003616 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
 800360c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003610:	4618      	mov	r0, r3
 8003612:	f7ff ff8d 	bl	8003530 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 8003616:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003618:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
}
 800361a:	4618      	mov	r0, r3
 800361c:	b00b      	add	sp, #44	@ 0x2c
 800361e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003622:	bf00      	nop
 8003624:	200008d0 	.word	0x200008d0
 8003628:	08003451 	.word	0x08003451
 800362c:	00000000 	.word	0x00000000

08003630 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003630:	b500      	push	{lr}
 8003632:	b085      	sub	sp, #20
 8003634:	9001      	str	r0, [sp, #4]
 8003636:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8003638:	4b22      	ldr	r3, [pc, #136]	@ (80036c4 <chSchWakeupS+0x94>)
 800363a:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 800363c:	9b03      	ldr	r3, [sp, #12]
 800363e:	68db      	ldr	r3, [r3, #12]
 8003640:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 8003642:	f7ff fa1d 	bl	8002a80 <chDbgCheckClassS>

  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8003646:	9b03      	ldr	r3, [sp, #12]
 8003648:	681a      	ldr	r2, [r3, #0]
 800364a:	9b03      	ldr	r3, [sp, #12]
 800364c:	429a      	cmp	r2, r3
 800364e:	bf14      	ite	ne
 8003650:	2301      	movne	r3, #1
 8003652:	2300      	moveq	r3, #0
 8003654:	b2db      	uxtb	r3, r3
 8003656:	2b00      	cmp	r3, #0
 8003658:	d00f      	beq.n	800367a <chSchWakeupS+0x4a>
 800365a:	9b03      	ldr	r3, [sp, #12]
 800365c:	68db      	ldr	r3, [r3, #12]
 800365e:	689a      	ldr	r2, [r3, #8]
 8003660:	9b03      	ldr	r3, [sp, #12]
 8003662:	681b      	ldr	r3, [r3, #0]
 8003664:	689b      	ldr	r3, [r3, #8]
 8003666:	429a      	cmp	r2, r3
 8003668:	bf34      	ite	cc
 800366a:	2301      	movcc	r3, #1
 800366c:	2300      	movcs	r3, #0
 800366e:	b2db      	uxtb	r3, r3
 8003670:	2b00      	cmp	r3, #0
 8003672:	d002      	beq.n	800367a <chSchWakeupS+0x4a>
 8003674:	4814      	ldr	r0, [pc, #80]	@ (80036c8 <chSchWakeupS+0x98>)
 8003676:	f7ff f843 	bl	8002700 <chSysHalt>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800367a:	9b01      	ldr	r3, [sp, #4]
 800367c:	9a00      	ldr	r2, [sp, #0]
 800367e:	629a      	str	r2, [r3, #40]	@ 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8003680:	9b01      	ldr	r3, [sp, #4]
 8003682:	689a      	ldr	r2, [r3, #8]
 8003684:	9b02      	ldr	r3, [sp, #8]
 8003686:	689b      	ldr	r3, [r3, #8]
 8003688:	429a      	cmp	r2, r3
 800368a:	bf94      	ite	ls
 800368c:	2301      	movls	r3, #1
 800368e:	2300      	movhi	r3, #0
 8003690:	b2db      	uxtb	r3, r3
 8003692:	2b00      	cmp	r3, #0
 8003694:	d003      	beq.n	800369e <chSchWakeupS+0x6e>
    (void) __sch_ready_behind(ntp);
 8003696:	9801      	ldr	r0, [sp, #4]
 8003698:	f7ff fe52 	bl	8003340 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 800369c:	e00e      	b.n	80036bc <chSchWakeupS+0x8c>
    otp = __sch_ready_ahead(otp);
 800369e:	9802      	ldr	r0, [sp, #8]
 80036a0:	f7ff fe7e 	bl	80033a0 <__sch_ready_ahead>
 80036a4:	9002      	str	r0, [sp, #8]
    ntp->state = CH_STATE_CURRENT;
 80036a6:	9b01      	ldr	r3, [sp, #4]
 80036a8:	2201      	movs	r2, #1
 80036aa:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    __instance_set_currthread(oip, ntp);
 80036ae:	9b03      	ldr	r3, [sp, #12]
 80036b0:	9a01      	ldr	r2, [sp, #4]
 80036b2:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 80036b4:	9902      	ldr	r1, [sp, #8]
 80036b6:	9801      	ldr	r0, [sp, #4]
 80036b8:	f7fc fdf2 	bl	80002a0 <__port_switch>
}
 80036bc:	bf00      	nop
 80036be:	b005      	add	sp, #20
 80036c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80036c4:	200008d0 	.word	0x200008d0
 80036c8:	08005524 	.word	0x08005524
 80036cc:	00000000 	.word	0x00000000

080036d0 <chSchRescheduleS>:
 * @note    Only local threads are considered, other cores are signaled
 *          and perform a reschedule locally.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 80036d0:	b500      	push	{lr}
 80036d2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80036d4:	4b0c      	ldr	r3, [pc, #48]	@ (8003708 <chSchRescheduleS+0x38>)
 80036d6:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
 80036d8:	9b01      	ldr	r3, [sp, #4]
 80036da:	68db      	ldr	r3, [r3, #12]
 80036dc:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();
 80036de:	f7ff f9cf 	bl	8002a80 <chDbgCheckClassS>

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 80036e2:	9b01      	ldr	r3, [sp, #4]
 80036e4:	681b      	ldr	r3, [r3, #0]
 80036e6:	689a      	ldr	r2, [r3, #8]
 80036e8:	9b00      	ldr	r3, [sp, #0]
 80036ea:	689b      	ldr	r3, [r3, #8]
 80036ec:	429a      	cmp	r2, r3
 80036ee:	bf8c      	ite	hi
 80036f0:	2301      	movhi	r3, #1
 80036f2:	2300      	movls	r3, #0
 80036f4:	b2db      	uxtb	r3, r3
 80036f6:	2b00      	cmp	r3, #0
 80036f8:	d001      	beq.n	80036fe <chSchRescheduleS+0x2e>
    __sch_reschedule_ahead();
 80036fa:	f7ff fe81 	bl	8003400 <__sch_reschedule_ahead>
  }
}
 80036fe:	bf00      	nop
 8003700:	b003      	add	sp, #12
 8003702:	f85d fb04 	ldr.w	pc, [sp], #4
 8003706:	bf00      	nop
 8003708:	200008d0 	.word	0x200008d0
 800370c:	00000000 	.word	0x00000000

08003710 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8003710:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 8003712:	4b0b      	ldr	r3, [pc, #44]	@ (8003740 <chSchIsPreemptionRequired+0x30>)
 8003714:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 8003716:	9b03      	ldr	r3, [sp, #12]
 8003718:	68db      	ldr	r3, [r3, #12]
 800371a:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 800371c:	9b03      	ldr	r3, [sp, #12]
 800371e:	681b      	ldr	r3, [r3, #0]
 8003720:	689b      	ldr	r3, [r3, #8]
 8003722:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8003724:	9b02      	ldr	r3, [sp, #8]
 8003726:	689b      	ldr	r3, [r3, #8]
 8003728:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800372a:	9a01      	ldr	r2, [sp, #4]
 800372c:	9b00      	ldr	r3, [sp, #0]
 800372e:	429a      	cmp	r2, r3
 8003730:	bf8c      	ite	hi
 8003732:	2301      	movhi	r3, #1
 8003734:	2300      	movls	r3, #0
 8003736:	b2db      	uxtb	r3, r3
#endif
}
 8003738:	4618      	mov	r0, r3
 800373a:	b004      	add	sp, #16
 800373c:	4770      	bx	lr
 800373e:	bf00      	nop
 8003740:	200008d0 	.word	0x200008d0
	...

08003750 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8003750:	b500      	push	{lr}
 8003752:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8003754:	4b0e      	ldr	r3, [pc, #56]	@ (8003790 <chSchDoPreemption+0x40>)
 8003756:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 8003758:	9b03      	ldr	r3, [sp, #12]
 800375a:	68db      	ldr	r3, [r3, #12]
 800375c:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800375e:	9b03      	ldr	r3, [sp, #12]
 8003760:	4618      	mov	r0, r3
 8003762:	f7ff fd45 	bl	80031f0 <ch_pqueue_remove_highest>
 8003766:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 8003768:	9b01      	ldr	r3, [sp, #4]
 800376a:	2201      	movs	r2, #1
 800376c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8003770:	9b03      	ldr	r3, [sp, #12]
 8003772:	9a01      	ldr	r2, [sp, #4]
 8003774:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 8003776:	9802      	ldr	r0, [sp, #8]
 8003778:	f7ff fe12 	bl	80033a0 <__sch_ready_ahead>
 800377c:	9002      	str	r0, [sp, #8]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800377e:	9902      	ldr	r1, [sp, #8]
 8003780:	9801      	ldr	r0, [sp, #4]
 8003782:	f7fc fd8d 	bl	80002a0 <__port_switch>
}
 8003786:	bf00      	nop
 8003788:	b005      	add	sp, #20
 800378a:	f85d fb04 	ldr.w	pc, [sp], #4
 800378e:	bf00      	nop
 8003790:	200008d0 	.word	0x200008d0
	...

080037a0 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 80037a0:	b082      	sub	sp, #8
 80037a2:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 80037a4:	9b01      	ldr	r3, [sp, #4]
 80037a6:	2200      	movs	r2, #0
 80037a8:	601a      	str	r2, [r3, #0]
}
 80037aa:	bf00      	nop
 80037ac:	b002      	add	sp, #8
 80037ae:	4770      	bx	lr

080037b0 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 80037b0:	b082      	sub	sp, #8
 80037b2:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 80037b4:	9b01      	ldr	r3, [sp, #4]
 80037b6:	2200      	movs	r2, #0
 80037b8:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 80037ba:	9b01      	ldr	r3, [sp, #4]
 80037bc:	2200      	movs	r2, #0
 80037be:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 80037c0:	9b01      	ldr	r3, [sp, #4]
 80037c2:	2201      	movs	r2, #1
 80037c4:	609a      	str	r2, [r3, #8]
#endif
}
 80037c6:	bf00      	nop
 80037c8:	b002      	add	sp, #8
 80037ca:	4770      	bx	lr
 80037cc:	0000      	movs	r0, r0
	...

080037d0 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80037d0:	b082      	sub	sp, #8
 80037d2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80037d4:	9b01      	ldr	r3, [sp, #4]
 80037d6:	9a01      	ldr	r2, [sp, #4]
 80037d8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80037da:	9b01      	ldr	r3, [sp, #4]
 80037dc:	9a01      	ldr	r2, [sp, #4]
 80037de:	605a      	str	r2, [r3, #4]
}
 80037e0:	bf00      	nop
 80037e2:	b002      	add	sp, #8
 80037e4:	4770      	bx	lr
 80037e6:	bf00      	nop
	...

080037f0 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 80037f0:	b082      	sub	sp, #8
 80037f2:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 80037f4:	9b01      	ldr	r3, [sp, #4]
 80037f6:	9a01      	ldr	r2, [sp, #4]
 80037f8:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 80037fa:	9b01      	ldr	r3, [sp, #4]
 80037fc:	9a01      	ldr	r2, [sp, #4]
 80037fe:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 8003800:	9b01      	ldr	r3, [sp, #4]
 8003802:	2200      	movs	r2, #0
 8003804:	609a      	str	r2, [r3, #8]
}
 8003806:	bf00      	nop
 8003808:	b002      	add	sp, #8
 800380a:	4770      	bx	lr
 800380c:	0000      	movs	r0, r0
	...

08003810 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 8003810:	b082      	sub	sp, #8
 8003812:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 8003814:	9b01      	ldr	r3, [sp, #4]
 8003816:	9a01      	ldr	r2, [sp, #4]
 8003818:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 800381a:	9b01      	ldr	r3, [sp, #4]
 800381c:	9a01      	ldr	r2, [sp, #4]
 800381e:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 8003820:	9b01      	ldr	r3, [sp, #4]
 8003822:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003826:	609a      	str	r2, [r3, #8]
}
 8003828:	bf00      	nop
 800382a:	b002      	add	sp, #8
 800382c:	4770      	bx	lr
 800382e:	bf00      	nop

08003830 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 8003830:	b508      	push	{r3, lr}
  return stGetCounter();
 8003832:	f7fc fe15 	bl	8000460 <stGetCounter>
 8003836:	4603      	mov	r3, r0
}
 8003838:	4618      	mov	r0, r3
 800383a:	bd08      	pop	{r3, pc}
 800383c:	0000      	movs	r0, r0
	...

08003840 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003840:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8003842:	f7ff fff5 	bl	8003830 <port_timer_get_time.lto_priv.1>
 8003846:	4603      	mov	r3, r0
}
 8003848:	4618      	mov	r0, r3
 800384a:	bd08      	pop	{r3, pc}
 800384c:	0000      	movs	r0, r0
	...

08003850 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 8003850:	b530      	push	{r4, r5, lr}
 8003852:	b083      	sub	sp, #12
 8003854:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 8003856:	9b01      	ldr	r3, [sp, #4]
 8003858:	4618      	mov	r0, r3
 800385a:	f7ff ffd9 	bl	8003810 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 800385e:	9b01      	ldr	r3, [sp, #4]
 8003860:	2200      	movs	r2, #0
 8003862:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003864:	f7ff ffec 	bl	8003840 <chVTGetSystemTimeX.lto_priv.1>
 8003868:	4603      	mov	r3, r0
 800386a:	2200      	movs	r2, #0
 800386c:	461c      	mov	r4, r3
 800386e:	4615      	mov	r5, r2
 8003870:	9b01      	ldr	r3, [sp, #4]
 8003872:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 8003876:	bf00      	nop
 8003878:	b003      	add	sp, #12
 800387a:	bd30      	pop	{r4, r5, pc}
 800387c:	0000      	movs	r0, r0
	...

08003880 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8003880:	b500      	push	{lr}
 8003882:	b083      	sub	sp, #12
 8003884:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 8003886:	9b01      	ldr	r3, [sp, #4]
 8003888:	4618      	mov	r0, r3
 800388a:	f7ff ffa1 	bl	80037d0 <ch_queue_init.lto_priv.2>
}
 800388e:	bf00      	nop
 8003890:	b003      	add	sp, #12
 8003892:	f85d fb04 	ldr.w	pc, [sp], #4
 8003896:	bf00      	nop
	...

080038a0 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 80038a0:	b082      	sub	sp, #8
 80038a2:	9001      	str	r0, [sp, #4]
}
 80038a4:	bf00      	nop
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
    asm volatile ("nop");
 80038a6:	bf00      	nop
    port_wait_for_interrupt();
 80038a8:	bf00      	nop
 80038aa:	e7fb      	b.n	80038a4 <__idle_thread+0x4>
 80038ac:	0000      	movs	r0, r0
	...

080038b0 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 80038b0:	b500      	push	{lr}
 80038b2:	b08b      	sub	sp, #44	@ 0x2c
 80038b4:	9001      	str	r0, [sp, #4]
 80038b6:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 80038b8:	2300      	movs	r3, #0
 80038ba:	9309      	str	r3, [sp, #36]	@ 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 80038bc:	4a30      	ldr	r2, [pc, #192]	@ (8003980 <chInstanceObjectInit+0xd0>)
 80038be:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80038c0:	009b      	lsls	r3, r3, #2
 80038c2:	4413      	add	r3, r2
 80038c4:	685b      	ldr	r3, [r3, #4]
 80038c6:	2b00      	cmp	r3, #0
 80038c8:	bf14      	ite	ne
 80038ca:	2301      	movne	r3, #1
 80038cc:	2300      	moveq	r3, #0
 80038ce:	b2db      	uxtb	r3, r3
 80038d0:	2b00      	cmp	r3, #0
 80038d2:	d002      	beq.n	80038da <chInstanceObjectInit+0x2a>
 80038d4:	482b      	ldr	r0, [pc, #172]	@ (8003984 <chInstanceObjectInit+0xd4>)
 80038d6:	f7fe ff13 	bl	8002700 <chSysHalt>
  ch_system.instances[core_id] = oip;
 80038da:	4a29      	ldr	r2, [pc, #164]	@ (8003980 <chInstanceObjectInit+0xd0>)
 80038dc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80038de:	009b      	lsls	r3, r3, #2
 80038e0:	4413      	add	r3, r2
 80038e2:	9a01      	ldr	r2, [sp, #4]
 80038e4:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 80038e6:	9b01      	ldr	r3, [sp, #4]
 80038e8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80038ea:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 80038ec:	9b01      	ldr	r3, [sp, #4]
 80038ee:	9a00      	ldr	r2, [sp, #0]
 80038f0:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 80038f2:	9801      	ldr	r0, [sp, #4]
 80038f4:	f001 fa3c 	bl	8004d70 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 80038f8:	9b01      	ldr	r3, [sp, #4]
 80038fa:	4618      	mov	r0, r3
 80038fc:	f7ff ff78 	bl	80037f0 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 8003900:	9b01      	ldr	r3, [sp, #4]
 8003902:	3328      	adds	r3, #40	@ 0x28
 8003904:	4618      	mov	r0, r3
 8003906:	f7ff ffbb 	bl	8003880 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 800390a:	9b01      	ldr	r3, [sp, #4]
 800390c:	3334      	adds	r3, #52	@ 0x34
 800390e:	4618      	mov	r0, r3
 8003910:	f7ff ff46 	bl	80037a0 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8003914:	9b01      	ldr	r3, [sp, #4]
 8003916:	3310      	adds	r3, #16
 8003918:	4618      	mov	r0, r3
 800391a:	f7ff ff99 	bl	8003850 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 800391e:	9b01      	ldr	r3, [sp, #4]
 8003920:	3384      	adds	r3, #132	@ 0x84
 8003922:	4618      	mov	r0, r3
 8003924:	f7ff ff44 	bl	80037b0 <__dbg_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8003928:	9b01      	ldr	r3, [sp, #4]
 800392a:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800392e:	2380      	movs	r3, #128	@ 0x80
 8003930:	4a15      	ldr	r2, [pc, #84]	@ (8003988 <chInstanceObjectInit+0xd8>)
 8003932:	9801      	ldr	r0, [sp, #4]
 8003934:	f000 f8fc 	bl	8003b30 <__thd_object_init>
 8003938:	4602      	mov	r2, r0
 800393a:	9b01      	ldr	r3, [sp, #4]
 800393c:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 800393e:	9b01      	ldr	r3, [sp, #4]
 8003940:	68db      	ldr	r3, [r3, #12]
 8003942:	9a00      	ldr	r2, [sp, #0]
 8003944:	6852      	ldr	r2, [r2, #4]
 8003946:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8003948:	9b01      	ldr	r3, [sp, #4]
 800394a:	68db      	ldr	r3, [r3, #12]
 800394c:	2201      	movs	r2, #1
 800394e:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 8003952:	4b0e      	ldr	r3, [pc, #56]	@ (800398c <chInstanceObjectInit+0xdc>)
 8003954:	9303      	str	r3, [sp, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8003956:	9b00      	ldr	r3, [sp, #0]
 8003958:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 800395a:	9304      	str	r3, [sp, #16]
      .wend     = oicp->idlethread_end,
 800395c:	9b00      	ldr	r3, [sp, #0]
 800395e:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 8003960:	9305      	str	r3, [sp, #20]
 8003962:	2301      	movs	r3, #1
 8003964:	9306      	str	r3, [sp, #24]
 8003966:	4b0a      	ldr	r3, [pc, #40]	@ (8003990 <chInstanceObjectInit+0xe0>)
 8003968:	9307      	str	r3, [sp, #28]
 800396a:	2300      	movs	r3, #0
 800396c:	9308      	str	r3, [sp, #32]
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 800396e:	ab03      	add	r3, sp, #12
 8003970:	4618      	mov	r0, r3
 8003972:	f000 f9ad 	bl	8003cd0 <chThdCreateI>
  }
#endif
}
 8003976:	bf00      	nop
 8003978:	b00b      	add	sp, #44	@ 0x2c
 800397a:	f85d fb04 	ldr.w	pc, [sp], #4
 800397e:	bf00      	nop
 8003980:	200008c4 	.word	0x200008c4
 8003984:	08005534 	.word	0x08005534
 8003988:	080055e4 	.word	0x080055e4
 800398c:	08005450 	.word	0x08005450
 8003990:	080038a1 	.word	0x080038a1
	...

080039a0 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 80039a0:	b082      	sub	sp, #8
 80039a2:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 80039a4:	9b01      	ldr	r3, [sp, #4]
 80039a6:	9a01      	ldr	r2, [sp, #4]
 80039a8:	601a      	str	r2, [r3, #0]
}
 80039aa:	bf00      	nop
 80039ac:	b002      	add	sp, #8
 80039ae:	4770      	bx	lr

080039b0 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 80039b0:	b082      	sub	sp, #8
 80039b2:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 80039b4:	9b01      	ldr	r3, [sp, #4]
 80039b6:	681b      	ldr	r3, [r3, #0]
 80039b8:	9a01      	ldr	r2, [sp, #4]
 80039ba:	429a      	cmp	r2, r3
 80039bc:	bf14      	ite	ne
 80039be:	2301      	movne	r3, #1
 80039c0:	2300      	moveq	r3, #0
 80039c2:	b2db      	uxtb	r3, r3
}
 80039c4:	4618      	mov	r0, r3
 80039c6:	b002      	add	sp, #8
 80039c8:	4770      	bx	lr
 80039ca:	bf00      	nop
 80039cc:	0000      	movs	r0, r0
	...

080039d0 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 80039d0:	b084      	sub	sp, #16
 80039d2:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 80039d4:	9b01      	ldr	r3, [sp, #4]
 80039d6:	681b      	ldr	r3, [r3, #0]
 80039d8:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 80039da:	9b03      	ldr	r3, [sp, #12]
 80039dc:	681a      	ldr	r2, [r3, #0]
 80039de:	9b01      	ldr	r3, [sp, #4]
 80039e0:	601a      	str	r2, [r3, #0]
  return p;
 80039e2:	9b03      	ldr	r3, [sp, #12]
}
 80039e4:	4618      	mov	r0, r3
 80039e6:	b004      	add	sp, #16
 80039e8:	4770      	bx	lr
 80039ea:	bf00      	nop
 80039ec:	0000      	movs	r0, r0
	...

080039f0 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80039f0:	b082      	sub	sp, #8
 80039f2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80039f4:	9b01      	ldr	r3, [sp, #4]
 80039f6:	9a01      	ldr	r2, [sp, #4]
 80039f8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80039fa:	9b01      	ldr	r3, [sp, #4]
 80039fc:	9a01      	ldr	r2, [sp, #4]
 80039fe:	605a      	str	r2, [r3, #4]
}
 8003a00:	bf00      	nop
 8003a02:	b002      	add	sp, #8
 8003a04:	4770      	bx	lr
 8003a06:	bf00      	nop
	...

08003a10 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8003a10:	b082      	sub	sp, #8
 8003a12:	9001      	str	r0, [sp, #4]
 8003a14:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 8003a16:	9b00      	ldr	r3, [sp, #0]
 8003a18:	9a01      	ldr	r2, [sp, #4]
 8003a1a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 8003a1c:	9b01      	ldr	r3, [sp, #4]
 8003a1e:	685a      	ldr	r2, [r3, #4]
 8003a20:	9b00      	ldr	r3, [sp, #0]
 8003a22:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003a24:	9b00      	ldr	r3, [sp, #0]
 8003a26:	685b      	ldr	r3, [r3, #4]
 8003a28:	9a00      	ldr	r2, [sp, #0]
 8003a2a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 8003a2c:	9b01      	ldr	r3, [sp, #4]
 8003a2e:	9a00      	ldr	r2, [sp, #0]
 8003a30:	605a      	str	r2, [r3, #4]
}
 8003a32:	bf00      	nop
 8003a34:	b002      	add	sp, #8
 8003a36:	4770      	bx	lr
	...

08003a40 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003a40:	b082      	sub	sp, #8
 8003a42:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003a44:	9b01      	ldr	r3, [sp, #4]
 8003a46:	685b      	ldr	r3, [r3, #4]
 8003a48:	9a01      	ldr	r2, [sp, #4]
 8003a4a:	6812      	ldr	r2, [r2, #0]
 8003a4c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8003a4e:	9b01      	ldr	r3, [sp, #4]
 8003a50:	681b      	ldr	r3, [r3, #0]
 8003a52:	9a01      	ldr	r2, [sp, #4]
 8003a54:	6852      	ldr	r2, [r2, #4]
 8003a56:	605a      	str	r2, [r3, #4]
  return p;
 8003a58:	9b01      	ldr	r3, [sp, #4]
}
 8003a5a:	4618      	mov	r0, r3
 8003a5c:	b002      	add	sp, #8
 8003a5e:	4770      	bx	lr

08003a60 <chSysLock.lto_priv.6>:
static inline void chSysLock(void) {
 8003a60:	b500      	push	{lr}
 8003a62:	b083      	sub	sp, #12
 8003a64:	2330      	movs	r3, #48	@ 0x30
 8003a66:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003a68:	9b01      	ldr	r3, [sp, #4]
 8003a6a:	f383 8811 	msr	BASEPRI, r3
}
 8003a6e:	bf00      	nop
}
 8003a70:	bf00      	nop
  __dbg_check_lock();
 8003a72:	f7fe fecd 	bl	8002810 <__dbg_check_lock>
}
 8003a76:	bf00      	nop
 8003a78:	b003      	add	sp, #12
 8003a7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a7e:	bf00      	nop

08003a80 <chSysUnlock.lto_priv.6>:
static inline void chSysUnlock(void) {
 8003a80:	b500      	push	{lr}
 8003a82:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8003a84:	f7fe feec 	bl	8002860 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003a88:	4b12      	ldr	r3, [pc, #72]	@ (8003ad4 <chSysUnlock.lto_priv.6+0x54>)
 8003a8a:	681b      	ldr	r3, [r3, #0]
 8003a8c:	4a11      	ldr	r2, [pc, #68]	@ (8003ad4 <chSysUnlock.lto_priv.6+0x54>)
 8003a8e:	4293      	cmp	r3, r2
 8003a90:	bf14      	ite	ne
 8003a92:	2301      	movne	r3, #1
 8003a94:	2300      	moveq	r3, #0
 8003a96:	b2db      	uxtb	r3, r3
 8003a98:	2b00      	cmp	r3, #0
 8003a9a:	d00f      	beq.n	8003abc <chSysUnlock.lto_priv.6+0x3c>
 8003a9c:	4b0d      	ldr	r3, [pc, #52]	@ (8003ad4 <chSysUnlock.lto_priv.6+0x54>)
 8003a9e:	68db      	ldr	r3, [r3, #12]
 8003aa0:	689a      	ldr	r2, [r3, #8]
 8003aa2:	4b0c      	ldr	r3, [pc, #48]	@ (8003ad4 <chSysUnlock.lto_priv.6+0x54>)
 8003aa4:	681b      	ldr	r3, [r3, #0]
 8003aa6:	689b      	ldr	r3, [r3, #8]
 8003aa8:	429a      	cmp	r2, r3
 8003aaa:	bf34      	ite	cc
 8003aac:	2301      	movcc	r3, #1
 8003aae:	2300      	movcs	r3, #0
 8003ab0:	b2db      	uxtb	r3, r3
 8003ab2:	2b00      	cmp	r3, #0
 8003ab4:	d002      	beq.n	8003abc <chSysUnlock.lto_priv.6+0x3c>
 8003ab6:	4808      	ldr	r0, [pc, #32]	@ (8003ad8 <chSysUnlock.lto_priv.6+0x58>)
 8003ab8:	f7fe fe22 	bl	8002700 <chSysHalt>
 8003abc:	2300      	movs	r3, #0
 8003abe:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003ac0:	9b01      	ldr	r3, [sp, #4]
 8003ac2:	f383 8811 	msr	BASEPRI, r3
}
 8003ac6:	bf00      	nop
}
 8003ac8:	bf00      	nop
}
 8003aca:	bf00      	nop
 8003acc:	b003      	add	sp, #12
 8003ace:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ad2:	bf00      	nop
 8003ad4:	200008d0 	.word	0x200008d0
 8003ad8:	08005564 	.word	0x08005564
 8003adc:	00000000 	.word	0x00000000

08003ae0 <chThdGetSelfX.lto_priv.0>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8003ae0:	4b01      	ldr	r3, [pc, #4]	@ (8003ae8 <chThdGetSelfX.lto_priv.0+0x8>)
 8003ae2:	68db      	ldr	r3, [r3, #12]
}
 8003ae4:	4618      	mov	r0, r3
 8003ae6:	4770      	bx	lr
 8003ae8:	200008d0 	.word	0x200008d0
 8003aec:	00000000 	.word	0x00000000

08003af0 <chThdGetWorkingAreaX.lto_priv.0>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8003af0:	b082      	sub	sp, #8
 8003af2:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 8003af4:	9b01      	ldr	r3, [sp, #4]
 8003af6:	6a1b      	ldr	r3, [r3, #32]
}
 8003af8:	4618      	mov	r0, r3
 8003afa:	b002      	add	sp, #8
 8003afc:	4770      	bx	lr
 8003afe:	bf00      	nop

08003b00 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 8003b00:	b500      	push	{lr}
 8003b02:	b083      	sub	sp, #12
 8003b04:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8003b06:	9b01      	ldr	r3, [sp, #4]
 8003b08:	2b00      	cmp	r3, #0
 8003b0a:	bf0c      	ite	eq
 8003b0c:	2301      	moveq	r3, #1
 8003b0e:	2300      	movne	r3, #0
 8003b10:	b2db      	uxtb	r3, r3
 8003b12:	2b00      	cmp	r3, #0
 8003b14:	d002      	beq.n	8003b1c <chThdSleepS+0x1c>
 8003b16:	4805      	ldr	r0, [pc, #20]	@ (8003b2c <chThdSleepS+0x2c>)
 8003b18:	f7fe fdf2 	bl	8002700 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8003b1c:	9901      	ldr	r1, [sp, #4]
 8003b1e:	2008      	movs	r0, #8
 8003b20:	f7ff fd4e 	bl	80035c0 <chSchGoSleepTimeoutS>
}
 8003b24:	bf00      	nop
 8003b26:	b003      	add	sp, #12
 8003b28:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b2c:	080055a0 	.word	0x080055a0

08003b30 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8003b30:	b500      	push	{lr}
 8003b32:	b085      	sub	sp, #20
 8003b34:	9003      	str	r0, [sp, #12]
 8003b36:	9102      	str	r1, [sp, #8]
 8003b38:	9201      	str	r2, [sp, #4]
 8003b3a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 8003b3c:	9b02      	ldr	r3, [sp, #8]
 8003b3e:	9a00      	ldr	r2, [sp, #0]
 8003b40:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8003b42:	9b02      	ldr	r3, [sp, #8]
 8003b44:	2202      	movs	r2, #2
 8003b46:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 8003b4a:	9b02      	ldr	r3, [sp, #8]
 8003b4c:	2200      	movs	r2, #0
 8003b4e:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  tp->owner             = oip;
 8003b52:	9b02      	ldr	r3, [sp, #8]
 8003b54:	9a03      	ldr	r2, [sp, #12]
 8003b56:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8003b58:	9b02      	ldr	r3, [sp, #8]
 8003b5a:	9a00      	ldr	r2, [sp, #0]
 8003b5c:	641a      	str	r2, [r3, #64]	@ 0x40
  tp->mtxlist           = NULL;
 8003b5e:	9b02      	ldr	r3, [sp, #8]
 8003b60:	2200      	movs	r2, #0
 8003b62:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8003b64:	9b02      	ldr	r3, [sp, #8]
 8003b66:	2200      	movs	r2, #0
 8003b68:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 8003b6a:	9b02      	ldr	r3, [sp, #8]
 8003b6c:	2201      	movs	r2, #1
 8003b6e:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
  tp->name              = name;
 8003b72:	9b02      	ldr	r3, [sp, #8]
 8003b74:	9a01      	ldr	r2, [sp, #4]
 8003b76:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 8003b78:	9b03      	ldr	r3, [sp, #12]
 8003b7a:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 8003b7e:	9b02      	ldr	r3, [sp, #8]
 8003b80:	3310      	adds	r3, #16
 8003b82:	4619      	mov	r1, r3
 8003b84:	4610      	mov	r0, r2
 8003b86:	f7ff ff43 	bl	8003a10 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 8003b8a:	9b02      	ldr	r3, [sp, #8]
 8003b8c:	332c      	adds	r3, #44	@ 0x2c
 8003b8e:	4618      	mov	r0, r3
 8003b90:	f7ff ff06 	bl	80039a0 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8003b94:	9b02      	ldr	r3, [sp, #8]
 8003b96:	3330      	adds	r3, #48	@ 0x30
 8003b98:	4618      	mov	r0, r3
 8003b9a:	f7ff ff29 	bl	80039f0 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8003b9e:	9b02      	ldr	r3, [sp, #8]
}
 8003ba0:	4618      	mov	r0, r3
 8003ba2:	b005      	add	sp, #20
 8003ba4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003bb0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8003bb0:	b500      	push	{lr}
 8003bb2:	b085      	sub	sp, #20
 8003bb4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8003bb6:	f7fe ff43 	bl	8002a40 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8003bba:	9b01      	ldr	r3, [sp, #4]
 8003bbc:	2b00      	cmp	r3, #0
 8003bbe:	bf0c      	ite	eq
 8003bc0:	2301      	moveq	r3, #1
 8003bc2:	2300      	movne	r3, #0
 8003bc4:	b2db      	uxtb	r3, r3
 8003bc6:	2b00      	cmp	r3, #0
 8003bc8:	d002      	beq.n	8003bd0 <chThdCreateSuspendedI+0x20>
 8003bca:	483d      	ldr	r0, [pc, #244]	@ (8003cc0 <chThdCreateSuspendedI+0x110>)
 8003bcc:	f7fe fd98 	bl	8002700 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8003bd0:	9b01      	ldr	r3, [sp, #4]
 8003bd2:	685b      	ldr	r3, [r3, #4]
 8003bd4:	f003 0307 	and.w	r3, r3, #7
 8003bd8:	2b00      	cmp	r3, #0
 8003bda:	bf14      	ite	ne
 8003bdc:	2301      	movne	r3, #1
 8003bde:	2300      	moveq	r3, #0
 8003be0:	b2db      	uxtb	r3, r3
 8003be2:	2b00      	cmp	r3, #0
 8003be4:	d10a      	bne.n	8003bfc <chThdCreateSuspendedI+0x4c>
 8003be6:	9b01      	ldr	r3, [sp, #4]
 8003be8:	689b      	ldr	r3, [r3, #8]
 8003bea:	f003 0307 	and.w	r3, r3, #7
 8003bee:	2b00      	cmp	r3, #0
 8003bf0:	bf14      	ite	ne
 8003bf2:	2301      	movne	r3, #1
 8003bf4:	2300      	moveq	r3, #0
 8003bf6:	b2db      	uxtb	r3, r3
 8003bf8:	2b00      	cmp	r3, #0
 8003bfa:	d001      	beq.n	8003c00 <chThdCreateSuspendedI+0x50>
 8003bfc:	2301      	movs	r3, #1
 8003bfe:	e000      	b.n	8003c02 <chThdCreateSuspendedI+0x52>
 8003c00:	2300      	movs	r3, #0
 8003c02:	2b00      	cmp	r3, #0
 8003c04:	d10a      	bne.n	8003c1c <chThdCreateSuspendedI+0x6c>
 8003c06:	9b01      	ldr	r3, [sp, #4]
 8003c08:	689a      	ldr	r2, [r3, #8]
 8003c0a:	9b01      	ldr	r3, [sp, #4]
 8003c0c:	685b      	ldr	r3, [r3, #4]
 8003c0e:	429a      	cmp	r2, r3
 8003c10:	bf94      	ite	ls
 8003c12:	2301      	movls	r3, #1
 8003c14:	2300      	movhi	r3, #0
 8003c16:	b2db      	uxtb	r3, r3
 8003c18:	2b00      	cmp	r3, #0
 8003c1a:	d001      	beq.n	8003c20 <chThdCreateSuspendedI+0x70>
 8003c1c:	2301      	movs	r3, #1
 8003c1e:	e000      	b.n	8003c22 <chThdCreateSuspendedI+0x72>
 8003c20:	2300      	movs	r3, #0
 8003c22:	2b00      	cmp	r3, #0
 8003c24:	d10c      	bne.n	8003c40 <chThdCreateSuspendedI+0x90>
 8003c26:	9b01      	ldr	r3, [sp, #4]
 8003c28:	689b      	ldr	r3, [r3, #8]
 8003c2a:	461a      	mov	r2, r3
 8003c2c:	9b01      	ldr	r3, [sp, #4]
 8003c2e:	685b      	ldr	r3, [r3, #4]
 8003c30:	1ad3      	subs	r3, r2, r3
 8003c32:	2bef      	cmp	r3, #239	@ 0xef
 8003c34:	bf94      	ite	ls
 8003c36:	2301      	movls	r3, #1
 8003c38:	2300      	movhi	r3, #0
 8003c3a:	b2db      	uxtb	r3, r3
 8003c3c:	2b00      	cmp	r3, #0
 8003c3e:	d002      	beq.n	8003c46 <chThdCreateSuspendedI+0x96>
 8003c40:	481f      	ldr	r0, [pc, #124]	@ (8003cc0 <chThdCreateSuspendedI+0x110>)
 8003c42:	f7fe fd5d 	bl	8002700 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8003c46:	9b01      	ldr	r3, [sp, #4]
 8003c48:	68db      	ldr	r3, [r3, #12]
 8003c4a:	2bff      	cmp	r3, #255	@ 0xff
 8003c4c:	bf8c      	ite	hi
 8003c4e:	2301      	movhi	r3, #1
 8003c50:	2300      	movls	r3, #0
 8003c52:	b2db      	uxtb	r3, r3
 8003c54:	2b00      	cmp	r3, #0
 8003c56:	d108      	bne.n	8003c6a <chThdCreateSuspendedI+0xba>
 8003c58:	9b01      	ldr	r3, [sp, #4]
 8003c5a:	691b      	ldr	r3, [r3, #16]
 8003c5c:	2b00      	cmp	r3, #0
 8003c5e:	bf0c      	ite	eq
 8003c60:	2301      	moveq	r3, #1
 8003c62:	2300      	movne	r3, #0
 8003c64:	b2db      	uxtb	r3, r3
 8003c66:	2b00      	cmp	r3, #0
 8003c68:	d002      	beq.n	8003c70 <chThdCreateSuspendedI+0xc0>
 8003c6a:	4815      	ldr	r0, [pc, #84]	@ (8003cc0 <chThdCreateSuspendedI+0x110>)
 8003c6c:	f7fe fd48 	bl	8002700 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 8003c70:	9b01      	ldr	r3, [sp, #4]
 8003c72:	689b      	ldr	r3, [r3, #8]
 8003c74:	3b48      	subs	r3, #72	@ 0x48
 8003c76:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8003c78:	9b01      	ldr	r3, [sp, #4]
 8003c7a:	685a      	ldr	r2, [r3, #4]
 8003c7c:	9b03      	ldr	r3, [sp, #12]
 8003c7e:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003c80:	9b03      	ldr	r3, [sp, #12]
 8003c82:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8003c86:	9b03      	ldr	r3, [sp, #12]
 8003c88:	60da      	str	r2, [r3, #12]
 8003c8a:	9b01      	ldr	r3, [sp, #4]
 8003c8c:	691a      	ldr	r2, [r3, #16]
 8003c8e:	9b03      	ldr	r3, [sp, #12]
 8003c90:	68db      	ldr	r3, [r3, #12]
 8003c92:	601a      	str	r2, [r3, #0]
 8003c94:	9b01      	ldr	r3, [sp, #4]
 8003c96:	695a      	ldr	r2, [r3, #20]
 8003c98:	9b03      	ldr	r3, [sp, #12]
 8003c9a:	68db      	ldr	r3, [r3, #12]
 8003c9c:	605a      	str	r2, [r3, #4]
 8003c9e:	9b03      	ldr	r3, [sp, #12]
 8003ca0:	68db      	ldr	r3, [r3, #12]
 8003ca2:	4a08      	ldr	r2, [pc, #32]	@ (8003cc4 <chThdCreateSuspendedI+0x114>)
 8003ca4:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8003ca6:	9b01      	ldr	r3, [sp, #4]
 8003ca8:	681a      	ldr	r2, [r3, #0]
 8003caa:	9b01      	ldr	r3, [sp, #4]
 8003cac:	68db      	ldr	r3, [r3, #12]
 8003cae:	9903      	ldr	r1, [sp, #12]
 8003cb0:	4805      	ldr	r0, [pc, #20]	@ (8003cc8 <chThdCreateSuspendedI+0x118>)
 8003cb2:	f7ff ff3d 	bl	8003b30 <__thd_object_init>
 8003cb6:	4603      	mov	r3, r0
}
 8003cb8:	4618      	mov	r0, r3
 8003cba:	b005      	add	sp, #20
 8003cbc:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cc0:	0800554c 	.word	0x0800554c
 8003cc4:	080002b1 	.word	0x080002b1
 8003cc8:	200008d0 	.word	0x200008d0
 8003ccc:	00000000 	.word	0x00000000

08003cd0 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8003cd0:	b500      	push	{lr}
 8003cd2:	b083      	sub	sp, #12
 8003cd4:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8003cd6:	9801      	ldr	r0, [sp, #4]
 8003cd8:	f7ff ff6a 	bl	8003bb0 <chThdCreateSuspendedI>
 8003cdc:	4603      	mov	r3, r0
 8003cde:	4618      	mov	r0, r3
 8003ce0:	f7ff fc06 	bl	80034f0 <chSchReadyI>
 8003ce4:	4603      	mov	r3, r0
}
 8003ce6:	4618      	mov	r0, r3
 8003ce8:	b003      	add	sp, #12
 8003cea:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cee:	bf00      	nop

08003cf0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003cf0:	b500      	push	{lr}
 8003cf2:	b087      	sub	sp, #28
 8003cf4:	9003      	str	r0, [sp, #12]
 8003cf6:	9102      	str	r1, [sp, #8]
 8003cf8:	9201      	str	r2, [sp, #4]
 8003cfa:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 8003cfc:	9b03      	ldr	r3, [sp, #12]
 8003cfe:	2b00      	cmp	r3, #0
 8003d00:	bf0c      	ite	eq
 8003d02:	2301      	moveq	r3, #1
 8003d04:	2300      	movne	r3, #0
 8003d06:	b2db      	uxtb	r3, r3
 8003d08:	2b00      	cmp	r3, #0
 8003d0a:	d109      	bne.n	8003d20 <chThdCreateStatic+0x30>
 8003d0c:	9b03      	ldr	r3, [sp, #12]
 8003d0e:	f003 0307 	and.w	r3, r3, #7
 8003d12:	2b00      	cmp	r3, #0
 8003d14:	bf14      	ite	ne
 8003d16:	2301      	movne	r3, #1
 8003d18:	2300      	moveq	r3, #0
 8003d1a:	b2db      	uxtb	r3, r3
 8003d1c:	2b00      	cmp	r3, #0
 8003d1e:	d001      	beq.n	8003d24 <chThdCreateStatic+0x34>
 8003d20:	2301      	movs	r3, #1
 8003d22:	e000      	b.n	8003d26 <chThdCreateStatic+0x36>
 8003d24:	2300      	movs	r3, #0
 8003d26:	2b00      	cmp	r3, #0
 8003d28:	d107      	bne.n	8003d3a <chThdCreateStatic+0x4a>
 8003d2a:	9b02      	ldr	r3, [sp, #8]
 8003d2c:	2bef      	cmp	r3, #239	@ 0xef
 8003d2e:	bf94      	ite	ls
 8003d30:	2301      	movls	r3, #1
 8003d32:	2300      	movhi	r3, #0
 8003d34:	b2db      	uxtb	r3, r3
 8003d36:	2b00      	cmp	r3, #0
 8003d38:	d001      	beq.n	8003d3e <chThdCreateStatic+0x4e>
 8003d3a:	2301      	movs	r3, #1
 8003d3c:	e000      	b.n	8003d40 <chThdCreateStatic+0x50>
 8003d3e:	2300      	movs	r3, #0
 8003d40:	2b00      	cmp	r3, #0
 8003d42:	d109      	bne.n	8003d58 <chThdCreateStatic+0x68>
 8003d44:	9b02      	ldr	r3, [sp, #8]
 8003d46:	f003 0307 	and.w	r3, r3, #7
 8003d4a:	2b00      	cmp	r3, #0
 8003d4c:	bf14      	ite	ne
 8003d4e:	2301      	movne	r3, #1
 8003d50:	2300      	moveq	r3, #0
 8003d52:	b2db      	uxtb	r3, r3
 8003d54:	2b00      	cmp	r3, #0
 8003d56:	d001      	beq.n	8003d5c <chThdCreateStatic+0x6c>
 8003d58:	2301      	movs	r3, #1
 8003d5a:	e000      	b.n	8003d5e <chThdCreateStatic+0x6e>
 8003d5c:	2300      	movs	r3, #0
 8003d5e:	2b00      	cmp	r3, #0
 8003d60:	d107      	bne.n	8003d72 <chThdCreateStatic+0x82>
 8003d62:	9b01      	ldr	r3, [sp, #4]
 8003d64:	2bff      	cmp	r3, #255	@ 0xff
 8003d66:	bf8c      	ite	hi
 8003d68:	2301      	movhi	r3, #1
 8003d6a:	2300      	movls	r3, #0
 8003d6c:	b2db      	uxtb	r3, r3
 8003d6e:	2b00      	cmp	r3, #0
 8003d70:	d001      	beq.n	8003d76 <chThdCreateStatic+0x86>
 8003d72:	2301      	movs	r3, #1
 8003d74:	e000      	b.n	8003d78 <chThdCreateStatic+0x88>
 8003d76:	2300      	movs	r3, #0
 8003d78:	2b00      	cmp	r3, #0
 8003d7a:	d107      	bne.n	8003d8c <chThdCreateStatic+0x9c>
 8003d7c:	9b00      	ldr	r3, [sp, #0]
 8003d7e:	2b00      	cmp	r3, #0
 8003d80:	bf0c      	ite	eq
 8003d82:	2301      	moveq	r3, #1
 8003d84:	2300      	movne	r3, #0
 8003d86:	b2db      	uxtb	r3, r3
 8003d88:	2b00      	cmp	r3, #0
 8003d8a:	d002      	beq.n	8003d92 <chThdCreateStatic+0xa2>
 8003d8c:	481e      	ldr	r0, [pc, #120]	@ (8003e08 <chThdCreateStatic+0x118>)
 8003d8e:	f7fe fcb7 	bl	8002700 <chSysHalt>
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8003d92:	9803      	ldr	r0, [sp, #12]
 8003d94:	f000 fa9c 	bl	80042d0 <chRegFindThreadByWorkingArea>
 8003d98:	4603      	mov	r3, r0
 8003d9a:	2b00      	cmp	r3, #0
 8003d9c:	bf14      	ite	ne
 8003d9e:	2301      	movne	r3, #1
 8003da0:	2300      	moveq	r3, #0
 8003da2:	b2db      	uxtb	r3, r3
 8003da4:	2b00      	cmp	r3, #0
 8003da6:	d002      	beq.n	8003dae <chThdCreateStatic+0xbe>
 8003da8:	4817      	ldr	r0, [pc, #92]	@ (8003e08 <chThdCreateStatic+0x118>)
 8003daa:	f7fe fca9 	bl	8002700 <chSysHalt>

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wsp, (uint8_t *)wsp + size);
#endif

  chSysLock();
 8003dae:	f7ff fe57 	bl	8003a60 <chSysLock.lto_priv.6>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 8003db2:	9b02      	ldr	r3, [sp, #8]
 8003db4:	3b48      	subs	r3, #72	@ 0x48
 8003db6:	9a03      	ldr	r2, [sp, #12]
 8003db8:	4413      	add	r3, r2
 8003dba:	9305      	str	r3, [sp, #20]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8003dbc:	9b05      	ldr	r3, [sp, #20]
 8003dbe:	9a03      	ldr	r2, [sp, #12]
 8003dc0:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003dc2:	9b05      	ldr	r3, [sp, #20]
 8003dc4:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8003dc8:	9b05      	ldr	r3, [sp, #20]
 8003dca:	60da      	str	r2, [r3, #12]
 8003dcc:	9b05      	ldr	r3, [sp, #20]
 8003dce:	68db      	ldr	r3, [r3, #12]
 8003dd0:	9a00      	ldr	r2, [sp, #0]
 8003dd2:	601a      	str	r2, [r3, #0]
 8003dd4:	9b05      	ldr	r3, [sp, #20]
 8003dd6:	68db      	ldr	r3, [r3, #12]
 8003dd8:	9a08      	ldr	r2, [sp, #32]
 8003dda:	605a      	str	r2, [r3, #4]
 8003ddc:	9b05      	ldr	r3, [sp, #20]
 8003dde:	68db      	ldr	r3, [r3, #12]
 8003de0:	4a0a      	ldr	r2, [pc, #40]	@ (8003e0c <chThdCreateStatic+0x11c>)
 8003de2:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 8003de4:	9b01      	ldr	r3, [sp, #4]
 8003de6:	4a0a      	ldr	r2, [pc, #40]	@ (8003e10 <chThdCreateStatic+0x120>)
 8003de8:	9905      	ldr	r1, [sp, #20]
 8003dea:	480a      	ldr	r0, [pc, #40]	@ (8003e14 <chThdCreateStatic+0x124>)
 8003dec:	f7ff fea0 	bl	8003b30 <__thd_object_init>
 8003df0:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8003df2:	2100      	movs	r1, #0
 8003df4:	9805      	ldr	r0, [sp, #20]
 8003df6:	f7ff fc1b 	bl	8003630 <chSchWakeupS>
  chSysUnlock();
 8003dfa:	f7ff fe41 	bl	8003a80 <chSysUnlock.lto_priv.6>

  return tp;
 8003dfe:	9b05      	ldr	r3, [sp, #20]
}
 8003e00:	4618      	mov	r0, r3
 8003e02:	b007      	add	sp, #28
 8003e04:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e08:	08005570 	.word	0x08005570
 8003e0c:	080002b1 	.word	0x080002b1
 8003e10:	08005458 	.word	0x08005458
 8003e14:	200008d0 	.word	0x200008d0
	...

08003e20 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8003e20:	b510      	push	{r4, lr}
 8003e22:	b082      	sub	sp, #8
 8003e24:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003e26:	f7ff fe1b 	bl	8003a60 <chSysLock.lto_priv.6>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8003e2a:	9b01      	ldr	r3, [sp, #4]
 8003e2c:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003e30:	2b00      	cmp	r3, #0
 8003e32:	bf0c      	ite	eq
 8003e34:	2301      	moveq	r3, #1
 8003e36:	2300      	movne	r3, #0
 8003e38:	b2db      	uxtb	r3, r3
 8003e3a:	2b00      	cmp	r3, #0
 8003e3c:	d002      	beq.n	8003e44 <chThdRelease+0x24>
 8003e3e:	481f      	ldr	r0, [pc, #124]	@ (8003ebc <chThdRelease+0x9c>)
 8003e40:	f7fe fc5e 	bl	8002700 <chSysHalt>
  tp->refs--;
 8003e44:	9b01      	ldr	r3, [sp, #4]
 8003e46:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003e4a:	3b01      	subs	r3, #1
 8003e4c:	b2da      	uxtb	r2, r3
 8003e4e:	9b01      	ldr	r3, [sp, #4]
 8003e50:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8003e54:	9b01      	ldr	r3, [sp, #4]
 8003e56:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003e5a:	2b00      	cmp	r3, #0
 8003e5c:	d129      	bne.n	8003eb2 <chThdRelease+0x92>
 8003e5e:	9b01      	ldr	r3, [sp, #4]
 8003e60:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003e64:	2b0f      	cmp	r3, #15
 8003e66:	d124      	bne.n	8003eb2 <chThdRelease+0x92>
    REG_REMOVE(tp);
 8003e68:	9b01      	ldr	r3, [sp, #4]
 8003e6a:	3310      	adds	r3, #16
 8003e6c:	4618      	mov	r0, r3
 8003e6e:	f7ff fde7 	bl	8003a40 <ch_queue_dequeue.lto_priv.1>
    chSysUnlock();
 8003e72:	f7ff fe05 	bl	8003a80 <chSysUnlock.lto_priv.6>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8003e76:	9b01      	ldr	r3, [sp, #4]
 8003e78:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8003e7c:	f003 0303 	and.w	r3, r3, #3
 8003e80:	2b01      	cmp	r3, #1
 8003e82:	d002      	beq.n	8003e8a <chThdRelease+0x6a>
 8003e84:	2b02      	cmp	r3, #2
 8003e86:	d008      	beq.n	8003e9a <chThdRelease+0x7a>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
      /* Nothing else to do for static threads.*/
      break;
 8003e88:	e012      	b.n	8003eb0 <chThdRelease+0x90>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8003e8a:	9801      	ldr	r0, [sp, #4]
 8003e8c:	f7ff fe30 	bl	8003af0 <chThdGetWorkingAreaX.lto_priv.0>
 8003e90:	4603      	mov	r3, r0
 8003e92:	4618      	mov	r0, r3
 8003e94:	f000 fd1c 	bl	80048d0 <chHeapFree>
      break;
 8003e98:	e00a      	b.n	8003eb0 <chThdRelease+0x90>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8003e9a:	9b01      	ldr	r3, [sp, #4]
 8003e9c:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
 8003e9e:	9801      	ldr	r0, [sp, #4]
 8003ea0:	f7ff fe26 	bl	8003af0 <chThdGetWorkingAreaX.lto_priv.0>
 8003ea4:	4603      	mov	r3, r0
 8003ea6:	4619      	mov	r1, r3
 8003ea8:	4620      	mov	r0, r4
 8003eaa:	f000 fe89 	bl	8004bc0 <chPoolFree>
      break;
 8003eae:	bf00      	nop
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
 8003eb0:	e001      	b.n	8003eb6 <chThdRelease+0x96>
  }
  chSysUnlock();
 8003eb2:	f7ff fde5 	bl	8003a80 <chSysUnlock.lto_priv.6>
}
 8003eb6:	b002      	add	sp, #8
 8003eb8:	bd10      	pop	{r4, pc}
 8003eba:	bf00      	nop
 8003ebc:	08005584 	.word	0x08005584

08003ec0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8003ec0:	b500      	push	{lr}
 8003ec2:	b083      	sub	sp, #12
 8003ec4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003ec6:	f7ff fdcb 	bl	8003a60 <chSysLock.lto_priv.6>
  chThdExitS(msg);
 8003eca:	9801      	ldr	r0, [sp, #4]
 8003ecc:	f000 f808 	bl	8003ee0 <chThdExitS>
  /* The thread never returns here.*/
}
 8003ed0:	bf00      	nop
 8003ed2:	b003      	add	sp, #12
 8003ed4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003ee0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8003ee0:	b500      	push	{lr}
 8003ee2:	b085      	sub	sp, #20
 8003ee4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8003ee6:	f7ff fdfb 	bl	8003ae0 <chThdGetSelfX.lto_priv.0>
 8003eea:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 8003eec:	9b03      	ldr	r3, [sp, #12]
 8003eee:	9a01      	ldr	r2, [sp, #4]
 8003ef0:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003ef2:	e008      	b.n	8003f06 <chThdExitS+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8003ef4:	9b03      	ldr	r3, [sp, #12]
 8003ef6:	332c      	adds	r3, #44	@ 0x2c
 8003ef8:	4618      	mov	r0, r3
 8003efa:	f7ff fd69 	bl	80039d0 <ch_list_unlink>
 8003efe:	4603      	mov	r3, r0
 8003f00:	4618      	mov	r0, r3
 8003f02:	f7ff faf5 	bl	80034f0 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003f06:	9b03      	ldr	r3, [sp, #12]
 8003f08:	332c      	adds	r3, #44	@ 0x2c
 8003f0a:	4618      	mov	r0, r3
 8003f0c:	f7ff fd50 	bl	80039b0 <ch_list_notempty>
 8003f10:	4603      	mov	r3, r0
 8003f12:	2b00      	cmp	r3, #0
 8003f14:	d1ee      	bne.n	8003ef4 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8003f16:	9b03      	ldr	r3, [sp, #12]
 8003f18:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003f1c:	2b00      	cmp	r3, #0
 8003f1e:	bf0c      	ite	eq
 8003f20:	2301      	moveq	r3, #1
 8003f22:	2300      	movne	r3, #0
 8003f24:	b2db      	uxtb	r3, r3
 8003f26:	2b00      	cmp	r3, #0
 8003f28:	d010      	beq.n	8003f4c <chThdExitS+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8003f2a:	9b03      	ldr	r3, [sp, #12]
 8003f2c:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8003f30:	f003 0303 	and.w	r3, r3, #3
 8003f34:	2b00      	cmp	r3, #0
 8003f36:	bf0c      	ite	eq
 8003f38:	2301      	moveq	r3, #1
 8003f3a:	2300      	movne	r3, #0
 8003f3c:	b2db      	uxtb	r3, r3
 8003f3e:	2b00      	cmp	r3, #0
 8003f40:	d004      	beq.n	8003f4c <chThdExitS+0x6c>
      REG_REMOVE(currtp);
 8003f42:	9b03      	ldr	r3, [sp, #12]
 8003f44:	3310      	adds	r3, #16
 8003f46:	4618      	mov	r0, r3
 8003f48:	f7ff fd7a 	bl	8003a40 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003f4c:	200f      	movs	r0, #15
 8003f4e:	f7ff faef 	bl	8003530 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8003f52:	4803      	ldr	r0, [pc, #12]	@ (8003f60 <chThdExitS+0x80>)
 8003f54:	f7fe fbd4 	bl	8002700 <chSysHalt>
}
 8003f58:	bf00      	nop
 8003f5a:	b005      	add	sp, #20
 8003f5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f60:	08005594 	.word	0x08005594
	...

08003f70 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8003f70:	b500      	push	{lr}
 8003f72:	b083      	sub	sp, #12
 8003f74:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003f76:	f7ff fd73 	bl	8003a60 <chSysLock.lto_priv.6>
  chThdSleepS(time);
 8003f7a:	9801      	ldr	r0, [sp, #4]
 8003f7c:	f7ff fdc0 	bl	8003b00 <chThdSleepS>
  chSysUnlock();
 8003f80:	f7ff fd7e 	bl	8003a80 <chSysUnlock.lto_priv.6>
}
 8003f84:	bf00      	nop
 8003f86:	b003      	add	sp, #12
 8003f88:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f8c:	0000      	movs	r0, r0
	...

08003f90 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8003f90:	b500      	push	{lr}
 8003f92:	b085      	sub	sp, #20
 8003f94:	9001      	str	r0, [sp, #4]
 8003f96:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8003f98:	f7ff fda2 	bl	8003ae0 <chThdGetSelfX.lto_priv.0>
 8003f9c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 8003f9e:	9b01      	ldr	r3, [sp, #4]
 8003fa0:	681b      	ldr	r3, [r3, #0]
 8003fa2:	2b00      	cmp	r3, #0
 8003fa4:	bf14      	ite	ne
 8003fa6:	2301      	movne	r3, #1
 8003fa8:	2300      	moveq	r3, #0
 8003faa:	b2db      	uxtb	r3, r3
 8003fac:	2b00      	cmp	r3, #0
 8003fae:	d002      	beq.n	8003fb6 <chThdSuspendTimeoutS+0x26>
 8003fb0:	480e      	ldr	r0, [pc, #56]	@ (8003fec <chThdSuspendTimeoutS+0x5c>)
 8003fb2:	f7fe fba5 	bl	8002700 <chSysHalt>

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8003fb6:	9b00      	ldr	r3, [sp, #0]
 8003fb8:	2b00      	cmp	r3, #0
 8003fba:	bf0c      	ite	eq
 8003fbc:	2301      	moveq	r3, #1
 8003fbe:	2300      	movne	r3, #0
 8003fc0:	b2db      	uxtb	r3, r3
 8003fc2:	2b00      	cmp	r3, #0
 8003fc4:	d002      	beq.n	8003fcc <chThdSuspendTimeoutS+0x3c>
    return MSG_TIMEOUT;
 8003fc6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8003fca:	e00a      	b.n	8003fe2 <chThdSuspendTimeoutS+0x52>
  }

  *trp = tp;
 8003fcc:	9b01      	ldr	r3, [sp, #4]
 8003fce:	9a03      	ldr	r2, [sp, #12]
 8003fd0:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8003fd2:	9b03      	ldr	r3, [sp, #12]
 8003fd4:	9a01      	ldr	r2, [sp, #4]
 8003fd6:	629a      	str	r2, [r3, #40]	@ 0x28

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003fd8:	9900      	ldr	r1, [sp, #0]
 8003fda:	2003      	movs	r0, #3
 8003fdc:	f7ff faf0 	bl	80035c0 <chSchGoSleepTimeoutS>
 8003fe0:	4603      	mov	r3, r0
}
 8003fe2:	4618      	mov	r0, r3
 8003fe4:	b005      	add	sp, #20
 8003fe6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fea:	bf00      	nop
 8003fec:	080055ac 	.word	0x080055ac

08003ff0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8003ff0:	b500      	push	{lr}
 8003ff2:	b085      	sub	sp, #20
 8003ff4:	9001      	str	r0, [sp, #4]
 8003ff6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8003ff8:	9b01      	ldr	r3, [sp, #4]
 8003ffa:	681b      	ldr	r3, [r3, #0]
 8003ffc:	2b00      	cmp	r3, #0
 8003ffe:	d018      	beq.n	8004032 <chThdResumeI+0x42>
    thread_t *tp = *trp;
 8004000:	9b01      	ldr	r3, [sp, #4]
 8004002:	681b      	ldr	r3, [r3, #0]
 8004004:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004006:	9b03      	ldr	r3, [sp, #12]
 8004008:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800400c:	2b03      	cmp	r3, #3
 800400e:	bf14      	ite	ne
 8004010:	2301      	movne	r3, #1
 8004012:	2300      	moveq	r3, #0
 8004014:	b2db      	uxtb	r3, r3
 8004016:	2b00      	cmp	r3, #0
 8004018:	d002      	beq.n	8004020 <chThdResumeI+0x30>
 800401a:	4808      	ldr	r0, [pc, #32]	@ (800403c <chThdResumeI+0x4c>)
 800401c:	f7fe fb70 	bl	8002700 <chSysHalt>

    *trp = NULL;
 8004020:	9b01      	ldr	r3, [sp, #4]
 8004022:	2200      	movs	r2, #0
 8004024:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8004026:	9b03      	ldr	r3, [sp, #12]
 8004028:	9a00      	ldr	r2, [sp, #0]
 800402a:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 800402c:	9803      	ldr	r0, [sp, #12]
 800402e:	f7ff fa5f 	bl	80034f0 <chSchReadyI>
  }
}
 8004032:	bf00      	nop
 8004034:	b005      	add	sp, #20
 8004036:	f85d fb04 	ldr.w	pc, [sp], #4
 800403a:	bf00      	nop
 800403c:	080055c4 	.word	0x080055c4

08004040 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8004040:	b500      	push	{lr}
 8004042:	b085      	sub	sp, #20
 8004044:	9001      	str	r0, [sp, #4]
 8004046:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8004048:	9b01      	ldr	r3, [sp, #4]
 800404a:	681b      	ldr	r3, [r3, #0]
 800404c:	2b00      	cmp	r3, #0
 800404e:	d016      	beq.n	800407e <chThdResumeS+0x3e>
    thread_t *tp = *trp;
 8004050:	9b01      	ldr	r3, [sp, #4]
 8004052:	681b      	ldr	r3, [r3, #0]
 8004054:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004056:	9b03      	ldr	r3, [sp, #12]
 8004058:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800405c:	2b03      	cmp	r3, #3
 800405e:	bf14      	ite	ne
 8004060:	2301      	movne	r3, #1
 8004062:	2300      	moveq	r3, #0
 8004064:	b2db      	uxtb	r3, r3
 8004066:	2b00      	cmp	r3, #0
 8004068:	d002      	beq.n	8004070 <chThdResumeS+0x30>
 800406a:	4807      	ldr	r0, [pc, #28]	@ (8004088 <chThdResumeS+0x48>)
 800406c:	f7fe fb48 	bl	8002700 <chSysHalt>

    *trp = NULL;
 8004070:	9b01      	ldr	r3, [sp, #4]
 8004072:	2200      	movs	r2, #0
 8004074:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 8004076:	9900      	ldr	r1, [sp, #0]
 8004078:	9803      	ldr	r0, [sp, #12]
 800407a:	f7ff fad9 	bl	8003630 <chSchWakeupS>
  }
}
 800407e:	bf00      	nop
 8004080:	b005      	add	sp, #20
 8004082:	f85d fb04 	ldr.w	pc, [sp], #4
 8004086:	bf00      	nop
 8004088:	080055d4 	.word	0x080055d4
 800408c:	00000000 	.word	0x00000000

08004090 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8004090:	b4f0      	push	{r4, r5, r6, r7}
 8004092:	b084      	sub	sp, #16
 8004094:	9003      	str	r0, [sp, #12]
 8004096:	9102      	str	r1, [sp, #8]
 8004098:	9201      	str	r2, [sp, #4]

  tmp->n++;
 800409a:	9b03      	ldr	r3, [sp, #12]
 800409c:	68db      	ldr	r3, [r3, #12]
 800409e:	1c5a      	adds	r2, r3, #1
 80040a0:	9b03      	ldr	r3, [sp, #12]
 80040a2:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 80040a4:	9b03      	ldr	r3, [sp, #12]
 80040a6:	689b      	ldr	r3, [r3, #8]
 80040a8:	9a02      	ldr	r2, [sp, #8]
 80040aa:	1ad2      	subs	r2, r2, r3
 80040ac:	9b01      	ldr	r3, [sp, #4]
 80040ae:	1ad2      	subs	r2, r2, r3
 80040b0:	9b03      	ldr	r3, [sp, #12]
 80040b2:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80040b4:	9b03      	ldr	r3, [sp, #12]
 80040b6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80040ba:	9903      	ldr	r1, [sp, #12]
 80040bc:	6889      	ldr	r1, [r1, #8]
 80040be:	2000      	movs	r0, #0
 80040c0:	460c      	mov	r4, r1
 80040c2:	4605      	mov	r5, r0
 80040c4:	1916      	adds	r6, r2, r4
 80040c6:	eb43 0705 	adc.w	r7, r3, r5
 80040ca:	9b03      	ldr	r3, [sp, #12]
 80040cc:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
 80040d0:	9b03      	ldr	r3, [sp, #12]
 80040d2:	689a      	ldr	r2, [r3, #8]
 80040d4:	9b03      	ldr	r3, [sp, #12]
 80040d6:	685b      	ldr	r3, [r3, #4]
 80040d8:	429a      	cmp	r2, r3
 80040da:	d903      	bls.n	80040e4 <tm_stop+0x54>
    tmp->worst = tmp->last;
 80040dc:	9b03      	ldr	r3, [sp, #12]
 80040de:	689a      	ldr	r2, [r3, #8]
 80040e0:	9b03      	ldr	r3, [sp, #12]
 80040e2:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 80040e4:	9b03      	ldr	r3, [sp, #12]
 80040e6:	689a      	ldr	r2, [r3, #8]
 80040e8:	9b03      	ldr	r3, [sp, #12]
 80040ea:	681b      	ldr	r3, [r3, #0]
 80040ec:	429a      	cmp	r2, r3
 80040ee:	d203      	bcs.n	80040f8 <tm_stop+0x68>
    tmp->best = tmp->last;
 80040f0:	9b03      	ldr	r3, [sp, #12]
 80040f2:	689a      	ldr	r2, [r3, #8]
 80040f4:	9b03      	ldr	r3, [sp, #12]
 80040f6:	601a      	str	r2, [r3, #0]
  }
}
 80040f8:	bf00      	nop
 80040fa:	b004      	add	sp, #16
 80040fc:	bcf0      	pop	{r4, r5, r6, r7}
 80040fe:	4770      	bx	lr

08004100 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8004100:	b082      	sub	sp, #8
 8004102:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8004104:	9b01      	ldr	r3, [sp, #4]
 8004106:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800410a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 800410c:	9b01      	ldr	r3, [sp, #4]
 800410e:	2200      	movs	r2, #0
 8004110:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8004112:	9b01      	ldr	r3, [sp, #4]
 8004114:	2200      	movs	r2, #0
 8004116:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8004118:	9b01      	ldr	r3, [sp, #4]
 800411a:	2200      	movs	r2, #0
 800411c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 800411e:	9901      	ldr	r1, [sp, #4]
 8004120:	f04f 0200 	mov.w	r2, #0
 8004124:	f04f 0300 	mov.w	r3, #0
 8004128:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 800412c:	bf00      	nop
 800412e:	b002      	add	sp, #8
 8004130:	4770      	bx	lr
 8004132:	bf00      	nop
	...

08004140 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8004140:	b082      	sub	sp, #8
 8004142:	9001      	str	r0, [sp, #4]
  return DWT->CYCCNT;
 8004144:	4b03      	ldr	r3, [pc, #12]	@ (8004154 <chTMStartMeasurementX+0x14>)
 8004146:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8004148:	9b01      	ldr	r3, [sp, #4]
 800414a:	609a      	str	r2, [r3, #8]
}
 800414c:	bf00      	nop
 800414e:	b002      	add	sp, #8
 8004150:	4770      	bx	lr
 8004152:	bf00      	nop
 8004154:	e0001000 	.word	0xe0001000
	...

08004160 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8004160:	b500      	push	{lr}
 8004162:	b083      	sub	sp, #12
 8004164:	9001      	str	r0, [sp, #4]
 8004166:	4b06      	ldr	r3, [pc, #24]	@ (8004180 <chTMStopMeasurementX+0x20>)
 8004168:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 800416a:	4a06      	ldr	r2, [pc, #24]	@ (8004184 <chTMStopMeasurementX+0x24>)
 800416c:	6892      	ldr	r2, [r2, #8]
 800416e:	4619      	mov	r1, r3
 8004170:	9801      	ldr	r0, [sp, #4]
 8004172:	f7ff ff8d 	bl	8004090 <tm_stop>
}
 8004176:	bf00      	nop
 8004178:	b003      	add	sp, #12
 800417a:	f85d fb04 	ldr.w	pc, [sp], #4
 800417e:	bf00      	nop
 8004180:	e0001000 	.word	0xe0001000
 8004184:	200008c4 	.word	0x200008c4
	...

08004190 <chSysLock.lto_priv.7>:
static inline void chSysLock(void) {
 8004190:	b500      	push	{lr}
 8004192:	b083      	sub	sp, #12
 8004194:	2330      	movs	r3, #48	@ 0x30
 8004196:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004198:	9b01      	ldr	r3, [sp, #4]
 800419a:	f383 8811 	msr	BASEPRI, r3
}
 800419e:	bf00      	nop
}
 80041a0:	bf00      	nop
  __dbg_check_lock();
 80041a2:	f7fe fb35 	bl	8002810 <__dbg_check_lock>
}
 80041a6:	bf00      	nop
 80041a8:	b003      	add	sp, #12
 80041aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80041ae:	bf00      	nop

080041b0 <chSysUnlock.lto_priv.7>:
static inline void chSysUnlock(void) {
 80041b0:	b500      	push	{lr}
 80041b2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80041b4:	f7fe fb54 	bl	8002860 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80041b8:	4b12      	ldr	r3, [pc, #72]	@ (8004204 <chSysUnlock.lto_priv.7+0x54>)
 80041ba:	681b      	ldr	r3, [r3, #0]
 80041bc:	4a11      	ldr	r2, [pc, #68]	@ (8004204 <chSysUnlock.lto_priv.7+0x54>)
 80041be:	4293      	cmp	r3, r2
 80041c0:	bf14      	ite	ne
 80041c2:	2301      	movne	r3, #1
 80041c4:	2300      	moveq	r3, #0
 80041c6:	b2db      	uxtb	r3, r3
 80041c8:	2b00      	cmp	r3, #0
 80041ca:	d00f      	beq.n	80041ec <chSysUnlock.lto_priv.7+0x3c>
 80041cc:	4b0d      	ldr	r3, [pc, #52]	@ (8004204 <chSysUnlock.lto_priv.7+0x54>)
 80041ce:	68db      	ldr	r3, [r3, #12]
 80041d0:	689a      	ldr	r2, [r3, #8]
 80041d2:	4b0c      	ldr	r3, [pc, #48]	@ (8004204 <chSysUnlock.lto_priv.7+0x54>)
 80041d4:	681b      	ldr	r3, [r3, #0]
 80041d6:	689b      	ldr	r3, [r3, #8]
 80041d8:	429a      	cmp	r2, r3
 80041da:	bf34      	ite	cc
 80041dc:	2301      	movcc	r3, #1
 80041de:	2300      	movcs	r3, #0
 80041e0:	b2db      	uxtb	r3, r3
 80041e2:	2b00      	cmp	r3, #0
 80041e4:	d002      	beq.n	80041ec <chSysUnlock.lto_priv.7+0x3c>
 80041e6:	4808      	ldr	r0, [pc, #32]	@ (8004208 <chSysUnlock.lto_priv.7+0x58>)
 80041e8:	f7fe fa8a 	bl	8002700 <chSysHalt>
 80041ec:	2300      	movs	r3, #0
 80041ee:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80041f0:	9b01      	ldr	r3, [sp, #4]
 80041f2:	f383 8811 	msr	BASEPRI, r3
}
 80041f6:	bf00      	nop
}
 80041f8:	bf00      	nop
}
 80041fa:	bf00      	nop
 80041fc:	b003      	add	sp, #12
 80041fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004202:	bf00      	nop
 8004204:	200008d0 	.word	0x200008d0
 8004208:	08005610 	.word	0x08005610
 800420c:	00000000 	.word	0x00000000

08004210 <chThdGetWorkingAreaX.lto_priv.1>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8004210:	b082      	sub	sp, #8
 8004212:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8004214:	9b01      	ldr	r3, [sp, #4]
 8004216:	6a1b      	ldr	r3, [r3, #32]
}
 8004218:	4618      	mov	r0, r3
 800421a:	b002      	add	sp, #8
 800421c:	4770      	bx	lr
 800421e:	bf00      	nop

08004220 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8004220:	b500      	push	{lr}
 8004222:	b083      	sub	sp, #12
  thread_t *tp;
  uint8_t *p;

  chSysLock();
 8004224:	f7ff ffb4 	bl	8004190 <chSysLock.lto_priv.7>
  p = (uint8_t *)REG_HEADER(currcore)->next;
 8004228:	4b0a      	ldr	r3, [pc, #40]	@ (8004254 <chRegFirstThread+0x34>)
 800422a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800422c:	9301      	str	r3, [sp, #4]
  /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 800422e:	9b01      	ldr	r3, [sp, #4]
 8004230:	3b10      	subs	r3, #16
 8004232:	9300      	str	r3, [sp, #0]
  /*lint -restore*/
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8004234:	9b00      	ldr	r3, [sp, #0]
 8004236:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800423a:	3301      	adds	r3, #1
 800423c:	b2da      	uxtb	r2, r3
 800423e:	9b00      	ldr	r3, [sp, #0]
 8004240:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
#endif
  chSysUnlock();
 8004244:	f7ff ffb4 	bl	80041b0 <chSysUnlock.lto_priv.7>

  return tp;
 8004248:	9b00      	ldr	r3, [sp, #0]
}
 800424a:	4618      	mov	r0, r3
 800424c:	b003      	add	sp, #12
 800424e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004252:	bf00      	nop
 8004254:	200008d0 	.word	0x200008d0
	...

08004260 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8004260:	b500      	push	{lr}
 8004262:	b087      	sub	sp, #28
 8004264:	9001      	str	r0, [sp, #4]
  thread_t *ntp;
  ch_queue_t *nqp;

  chSysLock();
 8004266:	f7ff ff93 	bl	8004190 <chSysLock.lto_priv.7>

  /* Next element in the registry queue.*/
  nqp = tp->rqueue.next;
 800426a:	9b01      	ldr	r3, [sp, #4]
 800426c:	691b      	ldr	r3, [r3, #16]
 800426e:	9304      	str	r3, [sp, #16]
  if (nqp == REG_HEADER(currcore)) {
 8004270:	9b04      	ldr	r3, [sp, #16]
 8004272:	4a15      	ldr	r2, [pc, #84]	@ (80042c8 <chRegNextThread+0x68>)
 8004274:	4293      	cmp	r3, r2
 8004276:	d102      	bne.n	800427e <chRegNextThread+0x1e>
    ntp = NULL;
 8004278:	2300      	movs	r3, #0
 800427a:	9305      	str	r3, [sp, #20]
 800427c:	e019      	b.n	80042b2 <chRegNextThread+0x52>
  }
  else {
    uint8_t *p = (uint8_t *)nqp;
 800427e:	9b04      	ldr	r3, [sp, #16]
 8004280:	9303      	str	r3, [sp, #12]
    /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8004282:	9b03      	ldr	r3, [sp, #12]
 8004284:	3b10      	subs	r3, #16
 8004286:	9305      	str	r3, [sp, #20]
    /*lint -restore*/

#if CH_CFG_USE_DYNAMIC == TRUE
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8004288:	9b05      	ldr	r3, [sp, #20]
 800428a:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800428e:	2bff      	cmp	r3, #255	@ 0xff
 8004290:	bf0c      	ite	eq
 8004292:	2301      	moveq	r3, #1
 8004294:	2300      	movne	r3, #0
 8004296:	b2db      	uxtb	r3, r3
 8004298:	2b00      	cmp	r3, #0
 800429a:	d002      	beq.n	80042a2 <chRegNextThread+0x42>
 800429c:	480b      	ldr	r0, [pc, #44]	@ (80042cc <chRegNextThread+0x6c>)
 800429e:	f7fe fa2f 	bl	8002700 <chSysHalt>

    ntp->refs++;
 80042a2:	9b05      	ldr	r3, [sp, #20]
 80042a4:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 80042a8:	3301      	adds	r3, #1
 80042aa:	b2da      	uxtb	r2, r3
 80042ac:	9b05      	ldr	r3, [sp, #20]
 80042ae:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
#endif
  }
  chSysUnlock();
 80042b2:	f7ff ff7d 	bl	80041b0 <chSysUnlock.lto_priv.7>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80042b6:	9801      	ldr	r0, [sp, #4]
 80042b8:	f7ff fdb2 	bl	8003e20 <chThdRelease>
#endif

  return ntp;
 80042bc:	9b05      	ldr	r3, [sp, #20]
}
 80042be:	4618      	mov	r0, r3
 80042c0:	b007      	add	sp, #28
 80042c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80042c6:	bf00      	nop
 80042c8:	200008f8 	.word	0x200008f8
 80042cc:	0800561c 	.word	0x0800561c

080042d0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 80042d0:	b500      	push	{lr}
 80042d2:	b085      	sub	sp, #20
 80042d4:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 80042d6:	f7ff ffa3 	bl	8004220 <chRegFirstThread>
 80042da:	9003      	str	r0, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80042dc:	9803      	ldr	r0, [sp, #12]
 80042de:	f7ff ff97 	bl	8004210 <chThdGetWorkingAreaX.lto_priv.1>
 80042e2:	4602      	mov	r2, r0
 80042e4:	9b01      	ldr	r3, [sp, #4]
 80042e6:	4293      	cmp	r3, r2
 80042e8:	d101      	bne.n	80042ee <chRegFindThreadByWorkingArea+0x1e>
      return ctp;
 80042ea:	9b03      	ldr	r3, [sp, #12]
 80042ec:	e007      	b.n	80042fe <chRegFindThreadByWorkingArea+0x2e>
    }
    ctp = chRegNextThread(ctp);
 80042ee:	9803      	ldr	r0, [sp, #12]
 80042f0:	f7ff ffb6 	bl	8004260 <chRegNextThread>
 80042f4:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 80042f6:	9b03      	ldr	r3, [sp, #12]
 80042f8:	2b00      	cmp	r3, #0
 80042fa:	d1ef      	bne.n	80042dc <chRegFindThreadByWorkingArea+0xc>

  return NULL;
 80042fc:	2300      	movs	r3, #0
}
 80042fe:	4618      	mov	r0, r3
 8004300:	b005      	add	sp, #20
 8004302:	f85d fb04 	ldr.w	pc, [sp], #4
 8004306:	bf00      	nop
	...

08004310 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004310:	b082      	sub	sp, #8
 8004312:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004314:	9b01      	ldr	r3, [sp, #4]
 8004316:	9a01      	ldr	r2, [sp, #4]
 8004318:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800431a:	9b01      	ldr	r3, [sp, #4]
 800431c:	9a01      	ldr	r2, [sp, #4]
 800431e:	605a      	str	r2, [r3, #4]
}
 8004320:	bf00      	nop
 8004322:	b002      	add	sp, #8
 8004324:	4770      	bx	lr
 8004326:	bf00      	nop
	...

08004330 <ch_queue_notempty.lto_priv.2>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 8004330:	b082      	sub	sp, #8
 8004332:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 8004334:	9b01      	ldr	r3, [sp, #4]
 8004336:	681b      	ldr	r3, [r3, #0]
 8004338:	9a01      	ldr	r2, [sp, #4]
 800433a:	429a      	cmp	r2, r3
 800433c:	bf14      	ite	ne
 800433e:	2301      	movne	r3, #1
 8004340:	2300      	moveq	r3, #0
 8004342:	b2db      	uxtb	r3, r3
}
 8004344:	4618      	mov	r0, r3
 8004346:	b002      	add	sp, #8
 8004348:	4770      	bx	lr
 800434a:	bf00      	nop
 800434c:	0000      	movs	r0, r0
	...

08004350 <ch_queue_fifo_remove.lto_priv.2>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 8004350:	b084      	sub	sp, #16
 8004352:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 8004354:	9b01      	ldr	r3, [sp, #4]
 8004356:	681b      	ldr	r3, [r3, #0]
 8004358:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 800435a:	9b03      	ldr	r3, [sp, #12]
 800435c:	681a      	ldr	r2, [r3, #0]
 800435e:	9b01      	ldr	r3, [sp, #4]
 8004360:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 8004362:	9b01      	ldr	r3, [sp, #4]
 8004364:	681b      	ldr	r3, [r3, #0]
 8004366:	9a01      	ldr	r2, [sp, #4]
 8004368:	605a      	str	r2, [r3, #4]
  return p;
 800436a:	9b03      	ldr	r3, [sp, #12]
}
 800436c:	4618      	mov	r0, r3
 800436e:	b004      	add	sp, #16
 8004370:	4770      	bx	lr
 8004372:	bf00      	nop
	...

08004380 <ch_queue_dequeue.lto_priv.2>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8004380:	b082      	sub	sp, #8
 8004382:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8004384:	9b01      	ldr	r3, [sp, #4]
 8004386:	685b      	ldr	r3, [r3, #4]
 8004388:	9a01      	ldr	r2, [sp, #4]
 800438a:	6812      	ldr	r2, [r2, #0]
 800438c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800438e:	9b01      	ldr	r3, [sp, #4]
 8004390:	681b      	ldr	r3, [r3, #0]
 8004392:	9a01      	ldr	r2, [sp, #4]
 8004394:	6852      	ldr	r2, [r2, #4]
 8004396:	605a      	str	r2, [r3, #4]
  return p;
 8004398:	9b01      	ldr	r3, [sp, #4]
}
 800439a:	4618      	mov	r0, r3
 800439c:	b002      	add	sp, #8
 800439e:	4770      	bx	lr

080043a0 <chSysLock.lto_priv.9>:
static inline void chSysLock(void) {
 80043a0:	b500      	push	{lr}
 80043a2:	b083      	sub	sp, #12
 80043a4:	2330      	movs	r3, #48	@ 0x30
 80043a6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80043a8:	9b01      	ldr	r3, [sp, #4]
 80043aa:	f383 8811 	msr	BASEPRI, r3
}
 80043ae:	bf00      	nop
}
 80043b0:	bf00      	nop
  __dbg_check_lock();
 80043b2:	f7fe fa2d 	bl	8002810 <__dbg_check_lock>
}
 80043b6:	bf00      	nop
 80043b8:	b003      	add	sp, #12
 80043ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80043be:	bf00      	nop

080043c0 <chSysUnlock.lto_priv.9>:
static inline void chSysUnlock(void) {
 80043c0:	b500      	push	{lr}
 80043c2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80043c4:	f7fe fa4c 	bl	8002860 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80043c8:	4b12      	ldr	r3, [pc, #72]	@ (8004414 <chSysUnlock.lto_priv.9+0x54>)
 80043ca:	681b      	ldr	r3, [r3, #0]
 80043cc:	4a11      	ldr	r2, [pc, #68]	@ (8004414 <chSysUnlock.lto_priv.9+0x54>)
 80043ce:	4293      	cmp	r3, r2
 80043d0:	bf14      	ite	ne
 80043d2:	2301      	movne	r3, #1
 80043d4:	2300      	moveq	r3, #0
 80043d6:	b2db      	uxtb	r3, r3
 80043d8:	2b00      	cmp	r3, #0
 80043da:	d00f      	beq.n	80043fc <chSysUnlock.lto_priv.9+0x3c>
 80043dc:	4b0d      	ldr	r3, [pc, #52]	@ (8004414 <chSysUnlock.lto_priv.9+0x54>)
 80043de:	68db      	ldr	r3, [r3, #12]
 80043e0:	689a      	ldr	r2, [r3, #8]
 80043e2:	4b0c      	ldr	r3, [pc, #48]	@ (8004414 <chSysUnlock.lto_priv.9+0x54>)
 80043e4:	681b      	ldr	r3, [r3, #0]
 80043e6:	689b      	ldr	r3, [r3, #8]
 80043e8:	429a      	cmp	r2, r3
 80043ea:	bf34      	ite	cc
 80043ec:	2301      	movcc	r3, #1
 80043ee:	2300      	movcs	r3, #0
 80043f0:	b2db      	uxtb	r3, r3
 80043f2:	2b00      	cmp	r3, #0
 80043f4:	d002      	beq.n	80043fc <chSysUnlock.lto_priv.9+0x3c>
 80043f6:	4808      	ldr	r0, [pc, #32]	@ (8004418 <chSysUnlock.lto_priv.9+0x58>)
 80043f8:	f7fe f982 	bl	8002700 <chSysHalt>
 80043fc:	2300      	movs	r3, #0
 80043fe:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004400:	9b01      	ldr	r3, [sp, #4]
 8004402:	f383 8811 	msr	BASEPRI, r3
}
 8004406:	bf00      	nop
}
 8004408:	bf00      	nop
}
 800440a:	bf00      	nop
 800440c:	b003      	add	sp, #12
 800440e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004412:	bf00      	nop
 8004414:	200008d0 	.word	0x200008d0
 8004418:	0800563c 	.word	0x0800563c
 800441c:	00000000 	.word	0x00000000

08004420 <ch_sch_prio_insert.lto_priv.0>:
/*===========================================================================*/

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 8004420:	b084      	sub	sp, #16
 8004422:	9001      	str	r0, [sp, #4]
 8004424:	9100      	str	r1, [sp, #0]

  ch_queue_t *cp = qp;
 8004426:	9b01      	ldr	r3, [sp, #4]
 8004428:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->next;
 800442a:	9b03      	ldr	r3, [sp, #12]
 800442c:	681b      	ldr	r3, [r3, #0]
 800442e:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
 8004430:	9a03      	ldr	r2, [sp, #12]
 8004432:	9b01      	ldr	r3, [sp, #4]
 8004434:	429a      	cmp	r2, r3
 8004436:	d005      	beq.n	8004444 <ch_sch_prio_insert.lto_priv.0+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8004438:	9b03      	ldr	r3, [sp, #12]
 800443a:	689a      	ldr	r2, [r3, #8]
 800443c:	9b00      	ldr	r3, [sp, #0]
 800443e:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
 8004440:	429a      	cmp	r2, r3
 8004442:	d2f2      	bcs.n	800442a <ch_sch_prio_insert.lto_priv.0+0xa>
  tp->next       = cp;
 8004444:	9b00      	ldr	r3, [sp, #0]
 8004446:	9a03      	ldr	r2, [sp, #12]
 8004448:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
 800444a:	9b03      	ldr	r3, [sp, #12]
 800444c:	685a      	ldr	r2, [r3, #4]
 800444e:	9b00      	ldr	r3, [sp, #0]
 8004450:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
 8004452:	9b00      	ldr	r3, [sp, #0]
 8004454:	685b      	ldr	r3, [r3, #4]
 8004456:	9a00      	ldr	r2, [sp, #0]
 8004458:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
 800445a:	9b03      	ldr	r3, [sp, #12]
 800445c:	9a00      	ldr	r2, [sp, #0]
 800445e:	605a      	str	r2, [r3, #4]
}
 8004460:	bf00      	nop
 8004462:	b004      	add	sp, #16
 8004464:	4770      	bx	lr
 8004466:	bf00      	nop
	...

08004470 <chThdGetSelfX.lto_priv.2>:
  return __sch_get_currthread();
 8004470:	4b01      	ldr	r3, [pc, #4]	@ (8004478 <chThdGetSelfX.lto_priv.2+0x8>)
 8004472:	68db      	ldr	r3, [r3, #12]
}
 8004474:	4618      	mov	r0, r3
 8004476:	4770      	bx	lr
 8004478:	200008d0 	.word	0x200008d0
 800447c:	00000000 	.word	0x00000000

08004480 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8004480:	b500      	push	{lr}
 8004482:	b083      	sub	sp, #12
 8004484:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8004486:	f7fe fafb 	bl	8002a80 <chDbgCheckClassS>

  return ch_queue_notempty(&mp->queue);
 800448a:	9b01      	ldr	r3, [sp, #4]
 800448c:	4618      	mov	r0, r3
 800448e:	f7ff ff4f 	bl	8004330 <ch_queue_notempty.lto_priv.2>
 8004492:	4603      	mov	r3, r0
}
 8004494:	4618      	mov	r0, r3
 8004496:	b003      	add	sp, #12
 8004498:	f85d fb04 	ldr.w	pc, [sp], #4
 800449c:	0000      	movs	r0, r0
	...

080044a0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 80044a0:	b500      	push	{lr}
 80044a2:	b083      	sub	sp, #12
 80044a4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 80044a6:	9b01      	ldr	r3, [sp, #4]
 80044a8:	2b00      	cmp	r3, #0
 80044aa:	bf0c      	ite	eq
 80044ac:	2301      	moveq	r3, #1
 80044ae:	2300      	movne	r3, #0
 80044b0:	b2db      	uxtb	r3, r3
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	d002      	beq.n	80044bc <chMtxObjectInit+0x1c>
 80044b6:	4807      	ldr	r0, [pc, #28]	@ (80044d4 <chMtxObjectInit+0x34>)
 80044b8:	f7fe f922 	bl	8002700 <chSysHalt>

  ch_queue_init(&mp->queue);
 80044bc:	9b01      	ldr	r3, [sp, #4]
 80044be:	4618      	mov	r0, r3
 80044c0:	f7ff ff26 	bl	8004310 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 80044c4:	9b01      	ldr	r3, [sp, #4]
 80044c6:	2200      	movs	r2, #0
 80044c8:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 80044ca:	bf00      	nop
 80044cc:	b003      	add	sp, #12
 80044ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80044d2:	bf00      	nop
 80044d4:	0800562c 	.word	0x0800562c
	...

080044e0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80044e0:	b500      	push	{lr}
 80044e2:	b083      	sub	sp, #12
 80044e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80044e6:	f7ff ff5b 	bl	80043a0 <chSysLock.lto_priv.9>
  chMtxLockS(mp);
 80044ea:	9801      	ldr	r0, [sp, #4]
 80044ec:	f000 f808 	bl	8004500 <chMtxLockS>
  chSysUnlock();
 80044f0:	f7ff ff66 	bl	80043c0 <chSysUnlock.lto_priv.9>
}
 80044f4:	bf00      	nop
 80044f6:	b003      	add	sp, #12
 80044f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80044fc:	0000      	movs	r0, r0
	...

08004500 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8004500:	b510      	push	{r4, lr}
 8004502:	b084      	sub	sp, #16
 8004504:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004506:	f7ff ffb3 	bl	8004470 <chThdGetSelfX.lto_priv.2>
 800450a:	9002      	str	r0, [sp, #8]

  chDbgCheckClassS();
 800450c:	f7fe fab8 	bl	8002a80 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8004510:	9b01      	ldr	r3, [sp, #4]
 8004512:	2b00      	cmp	r3, #0
 8004514:	bf0c      	ite	eq
 8004516:	2301      	moveq	r3, #1
 8004518:	2300      	movne	r3, #0
 800451a:	b2db      	uxtb	r3, r3
 800451c:	2b00      	cmp	r3, #0
 800451e:	d002      	beq.n	8004526 <chMtxLockS+0x26>
 8004520:	4840      	ldr	r0, [pc, #256]	@ (8004624 <chMtxLockS+0x124>)
 8004522:	f7fe f8ed 	bl	8002700 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8004526:	9b01      	ldr	r3, [sp, #4]
 8004528:	689b      	ldr	r3, [r3, #8]
 800452a:	2b00      	cmp	r3, #0
 800452c:	d06c      	beq.n	8004608 <chMtxLockS+0x108>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 800452e:	9b01      	ldr	r3, [sp, #4]
 8004530:	689b      	ldr	r3, [r3, #8]
 8004532:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8004534:	e03b      	b.n	80045ae <chMtxLockS+0xae>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8004536:	9b02      	ldr	r3, [sp, #8]
 8004538:	689a      	ldr	r2, [r3, #8]
 800453a:	9b03      	ldr	r3, [sp, #12]
 800453c:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800453e:	9b03      	ldr	r3, [sp, #12]
 8004540:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004544:	2b07      	cmp	r3, #7
 8004546:	d016      	beq.n	8004576 <chMtxLockS+0x76>
 8004548:	2b07      	cmp	r3, #7
 800454a:	dc2e      	bgt.n	80045aa <chMtxLockS+0xaa>
 800454c:	2b00      	cmp	r3, #0
 800454e:	d01f      	beq.n	8004590 <chMtxLockS+0x90>
 8004550:	2b06      	cmp	r3, #6
 8004552:	d12a      	bne.n	80045aa <chMtxLockS+0xaa>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004554:	9b03      	ldr	r3, [sp, #12]
 8004556:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004558:	461c      	mov	r4, r3
 800455a:	9b03      	ldr	r3, [sp, #12]
 800455c:	4618      	mov	r0, r3
 800455e:	f7ff ff0f 	bl	8004380 <ch_queue_dequeue.lto_priv.2>
 8004562:	4603      	mov	r3, r0
 8004564:	4619      	mov	r1, r3
 8004566:	4620      	mov	r0, r4
 8004568:	f7ff ff5a 	bl	8004420 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          tp = tp->u.wtmtxp->owner;
 800456c:	9b03      	ldr	r3, [sp, #12]
 800456e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004570:	689b      	ldr	r3, [r3, #8]
 8004572:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8004574:	e01b      	b.n	80045ae <chMtxLockS+0xae>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004576:	9b03      	ldr	r3, [sp, #12]
 8004578:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800457a:	461c      	mov	r4, r3
 800457c:	9b03      	ldr	r3, [sp, #12]
 800457e:	4618      	mov	r0, r3
 8004580:	f7ff fefe 	bl	8004380 <ch_queue_dequeue.lto_priv.2>
 8004584:	4603      	mov	r3, r0
 8004586:	4619      	mov	r1, r3
 8004588:	4620      	mov	r0, r4
 800458a:	f7ff ff49 	bl	8004420 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          break;
 800458e:	e00d      	b.n	80045ac <chMtxLockS+0xac>
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8004590:	9b03      	ldr	r3, [sp, #12]
 8004592:	2201      	movs	r2, #1
 8004594:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 8004598:	9b03      	ldr	r3, [sp, #12]
 800459a:	4618      	mov	r0, r3
 800459c:	f7ff fef0 	bl	8004380 <ch_queue_dequeue.lto_priv.2>
 80045a0:	4603      	mov	r3, r0
 80045a2:	4618      	mov	r0, r3
 80045a4:	f7fe ffa4 	bl	80034f0 <chSchReadyI>
          break;
 80045a8:	e000      	b.n	80045ac <chMtxLockS+0xac>
        default:
          /* Nothing to do for other states.*/
          break;
 80045aa:	bf00      	nop
        }
        break;
 80045ac:	e005      	b.n	80045ba <chMtxLockS+0xba>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 80045ae:	9b03      	ldr	r3, [sp, #12]
 80045b0:	689a      	ldr	r2, [r3, #8]
 80045b2:	9b02      	ldr	r3, [sp, #8]
 80045b4:	689b      	ldr	r3, [r3, #8]
 80045b6:	429a      	cmp	r2, r3
 80045b8:	d3bd      	bcc.n	8004536 <chMtxLockS+0x36>
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
 80045ba:	9b01      	ldr	r3, [sp, #4]
 80045bc:	9a02      	ldr	r2, [sp, #8]
 80045be:	4611      	mov	r1, r2
 80045c0:	4618      	mov	r0, r3
 80045c2:	f7ff ff2d 	bl	8004420 <ch_sch_prio_insert.lto_priv.0>
      currtp->u.wtmtxp = mp;
 80045c6:	9b02      	ldr	r3, [sp, #8]
 80045c8:	9a01      	ldr	r2, [sp, #4]
 80045ca:	629a      	str	r2, [r3, #40]	@ 0x28
      chSchGoSleepS(CH_STATE_WTMTX);
 80045cc:	2006      	movs	r0, #6
 80045ce:	f7fe ffaf 	bl	8003530 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 80045d2:	9b01      	ldr	r3, [sp, #4]
 80045d4:	689b      	ldr	r3, [r3, #8]
 80045d6:	9a02      	ldr	r2, [sp, #8]
 80045d8:	429a      	cmp	r2, r3
 80045da:	bf14      	ite	ne
 80045dc:	2301      	movne	r3, #1
 80045de:	2300      	moveq	r3, #0
 80045e0:	b2db      	uxtb	r3, r3
 80045e2:	2b00      	cmp	r3, #0
 80045e4:	d002      	beq.n	80045ec <chMtxLockS+0xec>
 80045e6:	480f      	ldr	r0, [pc, #60]	@ (8004624 <chMtxLockS+0x124>)
 80045e8:	f7fe f88a 	bl	8002700 <chSysHalt>
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 80045ec:	9b02      	ldr	r3, [sp, #8]
 80045ee:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80045f0:	9a01      	ldr	r2, [sp, #4]
 80045f2:	429a      	cmp	r2, r3
 80045f4:	bf14      	ite	ne
 80045f6:	2301      	movne	r3, #1
 80045f8:	2300      	moveq	r3, #0
 80045fa:	b2db      	uxtb	r3, r3
 80045fc:	2b00      	cmp	r3, #0
 80045fe:	d00d      	beq.n	800461c <chMtxLockS+0x11c>
 8004600:	4808      	ldr	r0, [pc, #32]	@ (8004624 <chMtxLockS+0x124>)
 8004602:	f7fe f87d 	bl	8002700 <chSysHalt>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 8004606:	e009      	b.n	800461c <chMtxLockS+0x11c>
    mp->owner = currtp;
 8004608:	9b01      	ldr	r3, [sp, #4]
 800460a:	9a02      	ldr	r2, [sp, #8]
 800460c:	609a      	str	r2, [r3, #8]
    mp->next = currtp->mtxlist;
 800460e:	9b02      	ldr	r3, [sp, #8]
 8004610:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8004612:	9b01      	ldr	r3, [sp, #4]
 8004614:	60da      	str	r2, [r3, #12]
    currtp->mtxlist = mp;
 8004616:	9b02      	ldr	r3, [sp, #8]
 8004618:	9a01      	ldr	r2, [sp, #4]
 800461a:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 800461c:	bf00      	nop
 800461e:	b004      	add	sp, #16
 8004620:	bd10      	pop	{r4, pc}
 8004622:	bf00      	nop
 8004624:	08005648 	.word	0x08005648
	...

08004630 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8004630:	b500      	push	{lr}
 8004632:	b087      	sub	sp, #28
 8004634:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004636:	f7ff ff1b 	bl	8004470 <chThdGetSelfX.lto_priv.2>
 800463a:	9003      	str	r0, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800463c:	9b01      	ldr	r3, [sp, #4]
 800463e:	2b00      	cmp	r3, #0
 8004640:	bf0c      	ite	eq
 8004642:	2301      	moveq	r3, #1
 8004644:	2300      	movne	r3, #0
 8004646:	b2db      	uxtb	r3, r3
 8004648:	2b00      	cmp	r3, #0
 800464a:	d002      	beq.n	8004652 <chMtxUnlock+0x22>
 800464c:	4839      	ldr	r0, [pc, #228]	@ (8004734 <chMtxUnlock+0x104>)
 800464e:	f7fe f857 	bl	8002700 <chSysHalt>

  chSysLock();
 8004652:	f7ff fea5 	bl	80043a0 <chSysLock.lto_priv.9>

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8004656:	9b03      	ldr	r3, [sp, #12]
 8004658:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800465a:	2b00      	cmp	r3, #0
 800465c:	bf0c      	ite	eq
 800465e:	2301      	moveq	r3, #1
 8004660:	2300      	movne	r3, #0
 8004662:	b2db      	uxtb	r3, r3
 8004664:	2b00      	cmp	r3, #0
 8004666:	d002      	beq.n	800466e <chMtxUnlock+0x3e>
 8004668:	4832      	ldr	r0, [pc, #200]	@ (8004734 <chMtxUnlock+0x104>)
 800466a:	f7fe f849 	bl	8002700 <chSysHalt>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 800466e:	9b03      	ldr	r3, [sp, #12]
 8004670:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8004672:	689b      	ldr	r3, [r3, #8]
 8004674:	9a03      	ldr	r2, [sp, #12]
 8004676:	429a      	cmp	r2, r3
 8004678:	bf14      	ite	ne
 800467a:	2301      	movne	r3, #1
 800467c:	2300      	moveq	r3, #0
 800467e:	b2db      	uxtb	r3, r3
 8004680:	2b00      	cmp	r3, #0
 8004682:	d002      	beq.n	800468a <chMtxUnlock+0x5a>
 8004684:	482b      	ldr	r0, [pc, #172]	@ (8004734 <chMtxUnlock+0x104>)
 8004686:	f7fe f83b 	bl	8002700 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 800468a:	9b03      	ldr	r3, [sp, #12]
 800468c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800468e:	9a01      	ldr	r2, [sp, #4]
 8004690:	429a      	cmp	r2, r3
 8004692:	bf14      	ite	ne
 8004694:	2301      	movne	r3, #1
 8004696:	2300      	moveq	r3, #0
 8004698:	b2db      	uxtb	r3, r3
 800469a:	2b00      	cmp	r3, #0
 800469c:	d002      	beq.n	80046a4 <chMtxUnlock+0x74>
 800469e:	4825      	ldr	r0, [pc, #148]	@ (8004734 <chMtxUnlock+0x104>)
 80046a0:	f7fe f82e 	bl	8002700 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 80046a4:	9b01      	ldr	r3, [sp, #4]
 80046a6:	68da      	ldr	r2, [r3, #12]
 80046a8:	9b03      	ldr	r3, [sp, #12]
 80046aa:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80046ac:	9801      	ldr	r0, [sp, #4]
 80046ae:	f7ff fee7 	bl	8004480 <chMtxQueueNotEmptyS>
 80046b2:	4603      	mov	r3, r0
 80046b4:	2b00      	cmp	r3, #0
 80046b6:	d034      	beq.n	8004722 <chMtxUnlock+0xf2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 80046b8:	9b03      	ldr	r3, [sp, #12]
 80046ba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80046bc:	9304      	str	r3, [sp, #16]
      lmp = currtp->mtxlist;
 80046be:	9b03      	ldr	r3, [sp, #12]
 80046c0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80046c2:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80046c4:	e012      	b.n	80046ec <chMtxUnlock+0xbc>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80046c6:	9805      	ldr	r0, [sp, #20]
 80046c8:	f7ff feda 	bl	8004480 <chMtxQueueNotEmptyS>
 80046cc:	4603      	mov	r3, r0
 80046ce:	2b00      	cmp	r3, #0
 80046d0:	d009      	beq.n	80046e6 <chMtxUnlock+0xb6>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 80046d2:	9b05      	ldr	r3, [sp, #20]
 80046d4:	681b      	ldr	r3, [r3, #0]
 80046d6:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 80046d8:	9a04      	ldr	r2, [sp, #16]
 80046da:	429a      	cmp	r2, r3
 80046dc:	d203      	bcs.n	80046e6 <chMtxUnlock+0xb6>
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
 80046de:	9b05      	ldr	r3, [sp, #20]
 80046e0:	681b      	ldr	r3, [r3, #0]
 80046e2:	689b      	ldr	r3, [r3, #8]
 80046e4:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 80046e6:	9b05      	ldr	r3, [sp, #20]
 80046e8:	68db      	ldr	r3, [r3, #12]
 80046ea:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80046ec:	9b05      	ldr	r3, [sp, #20]
 80046ee:	2b00      	cmp	r3, #0
 80046f0:	d1e9      	bne.n	80046c6 <chMtxUnlock+0x96>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 80046f2:	9b03      	ldr	r3, [sp, #12]
 80046f4:	9a04      	ldr	r2, [sp, #16]
 80046f6:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
 80046f8:	9b01      	ldr	r3, [sp, #4]
 80046fa:	4618      	mov	r0, r3
 80046fc:	f7ff fe28 	bl	8004350 <ch_queue_fifo_remove.lto_priv.2>
 8004700:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 8004702:	9b01      	ldr	r3, [sp, #4]
 8004704:	9a02      	ldr	r2, [sp, #8]
 8004706:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8004708:	9b02      	ldr	r3, [sp, #8]
 800470a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800470c:	9b01      	ldr	r3, [sp, #4]
 800470e:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8004710:	9b02      	ldr	r3, [sp, #8]
 8004712:	9a01      	ldr	r2, [sp, #4]
 8004714:	63da      	str	r2, [r3, #60]	@ 0x3c

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8004716:	9802      	ldr	r0, [sp, #8]
 8004718:	f7fe feea 	bl	80034f0 <chSchReadyI>
      chSchRescheduleS();
 800471c:	f7fe ffd8 	bl	80036d0 <chSchRescheduleS>
 8004720:	e002      	b.n	8004728 <chMtxUnlock+0xf8>
    }
    else {
      mp->owner = NULL;
 8004722:	9b01      	ldr	r3, [sp, #4]
 8004724:	2200      	movs	r2, #0
 8004726:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8004728:	f7ff fe4a 	bl	80043c0 <chSysUnlock.lto_priv.9>
}
 800472c:	bf00      	nop
 800472e:	b007      	add	sp, #28
 8004730:	f85d fb04 	ldr.w	pc, [sp], #4
 8004734:	08005654 	.word	0x08005654
	...

08004740 <chSysLock.lto_priv.15>:
static inline void chSysLock(void) {
 8004740:	b500      	push	{lr}
 8004742:	b083      	sub	sp, #12
 8004744:	2330      	movs	r3, #48	@ 0x30
 8004746:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004748:	9b01      	ldr	r3, [sp, #4]
 800474a:	f383 8811 	msr	BASEPRI, r3
}
 800474e:	bf00      	nop
}
 8004750:	bf00      	nop
  __dbg_check_lock();
 8004752:	f7fe f85d 	bl	8002810 <__dbg_check_lock>
}
 8004756:	bf00      	nop
 8004758:	b003      	add	sp, #12
 800475a:	f85d fb04 	ldr.w	pc, [sp], #4
 800475e:	bf00      	nop

08004760 <chSysUnlock.lto_priv.15>:
static inline void chSysUnlock(void) {
 8004760:	b500      	push	{lr}
 8004762:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004764:	f7fe f87c 	bl	8002860 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004768:	4b12      	ldr	r3, [pc, #72]	@ (80047b4 <chSysUnlock.lto_priv.15+0x54>)
 800476a:	681b      	ldr	r3, [r3, #0]
 800476c:	4a11      	ldr	r2, [pc, #68]	@ (80047b4 <chSysUnlock.lto_priv.15+0x54>)
 800476e:	4293      	cmp	r3, r2
 8004770:	bf14      	ite	ne
 8004772:	2301      	movne	r3, #1
 8004774:	2300      	moveq	r3, #0
 8004776:	b2db      	uxtb	r3, r3
 8004778:	2b00      	cmp	r3, #0
 800477a:	d00f      	beq.n	800479c <chSysUnlock.lto_priv.15+0x3c>
 800477c:	4b0d      	ldr	r3, [pc, #52]	@ (80047b4 <chSysUnlock.lto_priv.15+0x54>)
 800477e:	68db      	ldr	r3, [r3, #12]
 8004780:	689a      	ldr	r2, [r3, #8]
 8004782:	4b0c      	ldr	r3, [pc, #48]	@ (80047b4 <chSysUnlock.lto_priv.15+0x54>)
 8004784:	681b      	ldr	r3, [r3, #0]
 8004786:	689b      	ldr	r3, [r3, #8]
 8004788:	429a      	cmp	r2, r3
 800478a:	bf34      	ite	cc
 800478c:	2301      	movcc	r3, #1
 800478e:	2300      	movcs	r3, #0
 8004790:	b2db      	uxtb	r3, r3
 8004792:	2b00      	cmp	r3, #0
 8004794:	d002      	beq.n	800479c <chSysUnlock.lto_priv.15+0x3c>
 8004796:	4808      	ldr	r0, [pc, #32]	@ (80047b8 <chSysUnlock.lto_priv.15+0x58>)
 8004798:	f7fd ffb2 	bl	8002700 <chSysHalt>
 800479c:	2300      	movs	r3, #0
 800479e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80047a0:	9b01      	ldr	r3, [sp, #4]
 80047a2:	f383 8811 	msr	BASEPRI, r3
}
 80047a6:	bf00      	nop
}
 80047a8:	bf00      	nop
}
 80047aa:	bf00      	nop
 80047ac:	b003      	add	sp, #12
 80047ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80047b2:	bf00      	nop
 80047b4:	200008d0 	.word	0x200008d0
 80047b8:	08005674 	.word	0x08005674
 80047bc:	00000000 	.word	0x00000000

080047c0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 80047c0:	4b03      	ldr	r3, [pc, #12]	@ (80047d0 <__core_init+0x10>)
 80047c2:	4a04      	ldr	r2, [pc, #16]	@ (80047d4 <__core_init+0x14>)
 80047c4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 80047c6:	4b02      	ldr	r3, [pc, #8]	@ (80047d0 <__core_init+0x10>)
 80047c8:	4a03      	ldr	r2, [pc, #12]	@ (80047d8 <__core_init+0x18>)
 80047ca:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 80047cc:	bf00      	nop
 80047ce:	4770      	bx	lr
 80047d0:	20000a90 	.word	0x20000a90
 80047d4:	20000d80 	.word	0x20000d80
 80047d8:	200a0000 	.word	0x200a0000
 80047dc:	00000000 	.word	0x00000000

080047e0 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 80047e0:	b500      	push	{lr}
 80047e2:	b087      	sub	sp, #28
 80047e4:	9003      	str	r0, [sp, #12]
 80047e6:	9102      	str	r1, [sp, #8]
 80047e8:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 80047ea:	f7fe f929 	bl	8002a40 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80047ee:	9b02      	ldr	r3, [sp, #8]
 80047f0:	2b00      	cmp	r3, #0
 80047f2:	bf0c      	ite	eq
 80047f4:	2301      	moveq	r3, #1
 80047f6:	2300      	movne	r3, #0
 80047f8:	b2db      	uxtb	r3, r3
 80047fa:	2b00      	cmp	r3, #0
 80047fc:	d10a      	bne.n	8004814 <chCoreAllocFromTopI+0x34>
 80047fe:	9b02      	ldr	r3, [sp, #8]
 8004800:	1e5a      	subs	r2, r3, #1
 8004802:	9b02      	ldr	r3, [sp, #8]
 8004804:	4013      	ands	r3, r2
 8004806:	2b00      	cmp	r3, #0
 8004808:	bf14      	ite	ne
 800480a:	2301      	movne	r3, #1
 800480c:	2300      	moveq	r3, #0
 800480e:	b2db      	uxtb	r3, r3
 8004810:	2b00      	cmp	r3, #0
 8004812:	d002      	beq.n	800481a <chCoreAllocFromTopI+0x3a>
 8004814:	4812      	ldr	r0, [pc, #72]	@ (8004860 <chCoreAllocFromTopI+0x80>)
 8004816:	f7fd ff73 	bl	8002700 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 800481a:	4b12      	ldr	r3, [pc, #72]	@ (8004864 <chCoreAllocFromTopI+0x84>)
 800481c:	685a      	ldr	r2, [r3, #4]
 800481e:	9b03      	ldr	r3, [sp, #12]
 8004820:	425b      	negs	r3, r3
 8004822:	4413      	add	r3, r2
 8004824:	461a      	mov	r2, r3
 8004826:	9b02      	ldr	r3, [sp, #8]
 8004828:	425b      	negs	r3, r3
 800482a:	4013      	ands	r3, r2
 800482c:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 800482e:	9b01      	ldr	r3, [sp, #4]
 8004830:	425b      	negs	r3, r3
 8004832:	9a05      	ldr	r2, [sp, #20]
 8004834:	4413      	add	r3, r2
 8004836:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8004838:	4b0a      	ldr	r3, [pc, #40]	@ (8004864 <chCoreAllocFromTopI+0x84>)
 800483a:	681b      	ldr	r3, [r3, #0]
 800483c:	9a04      	ldr	r2, [sp, #16]
 800483e:	429a      	cmp	r2, r3
 8004840:	d304      	bcc.n	800484c <chCoreAllocFromTopI+0x6c>
 8004842:	4b08      	ldr	r3, [pc, #32]	@ (8004864 <chCoreAllocFromTopI+0x84>)
 8004844:	685b      	ldr	r3, [r3, #4]
 8004846:	9a04      	ldr	r2, [sp, #16]
 8004848:	429a      	cmp	r2, r3
 800484a:	d901      	bls.n	8004850 <chCoreAllocFromTopI+0x70>
    return NULL;
 800484c:	2300      	movs	r3, #0
 800484e:	e003      	b.n	8004858 <chCoreAllocFromTopI+0x78>
  }

  ch_memcore.topmem = prev;
 8004850:	4a04      	ldr	r2, [pc, #16]	@ (8004864 <chCoreAllocFromTopI+0x84>)
 8004852:	9b04      	ldr	r3, [sp, #16]
 8004854:	6053      	str	r3, [r2, #4]

  return p;
 8004856:	9b05      	ldr	r3, [sp, #20]
}
 8004858:	4618      	mov	r0, r3
 800485a:	b007      	add	sp, #28
 800485c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004860:	08005660 	.word	0x08005660
 8004864:	20000a90 	.word	0x20000a90
	...

08004870 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8004870:	b500      	push	{lr}
 8004872:	b087      	sub	sp, #28
 8004874:	9003      	str	r0, [sp, #12]
 8004876:	9102      	str	r1, [sp, #8]
 8004878:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 800487a:	f7ff ff61 	bl	8004740 <chSysLock.lto_priv.15>
  p = chCoreAllocFromTopI(size, align, offset);
 800487e:	9a01      	ldr	r2, [sp, #4]
 8004880:	9902      	ldr	r1, [sp, #8]
 8004882:	9803      	ldr	r0, [sp, #12]
 8004884:	f7ff ffac 	bl	80047e0 <chCoreAllocFromTopI>
 8004888:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800488a:	f7ff ff69 	bl	8004760 <chSysUnlock.lto_priv.15>

  return p;
 800488e:	9b05      	ldr	r3, [sp, #20]
}
 8004890:	4618      	mov	r0, r3
 8004892:	b007      	add	sp, #28
 8004894:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080048a0 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 80048a0:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80048a2:	4b07      	ldr	r3, [pc, #28]	@ (80048c0 <__heap_init+0x20>)
 80048a4:	4a07      	ldr	r2, [pc, #28]	@ (80048c4 <__heap_init+0x24>)
 80048a6:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 80048a8:	4b05      	ldr	r3, [pc, #20]	@ (80048c0 <__heap_init+0x20>)
 80048aa:	2200      	movs	r2, #0
 80048ac:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 80048ae:	4b04      	ldr	r3, [pc, #16]	@ (80048c0 <__heap_init+0x20>)
 80048b0:	2200      	movs	r2, #0
 80048b2:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80048b4:	4804      	ldr	r0, [pc, #16]	@ (80048c8 <__heap_init+0x28>)
 80048b6:	f7ff fdf3 	bl	80044a0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 80048ba:	bf00      	nop
 80048bc:	bd08      	pop	{r3, pc}
 80048be:	bf00      	nop
 80048c0:	20000a98 	.word	0x20000a98
 80048c4:	08004871 	.word	0x08004871
 80048c8:	20000aa4 	.word	0x20000aa4
 80048cc:	00000000 	.word	0x00000000

080048d0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80048d0:	b500      	push	{lr}
 80048d2:	b087      	sub	sp, #28
 80048d4:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80048d6:	9b01      	ldr	r3, [sp, #4]
 80048d8:	2b00      	cmp	r3, #0
 80048da:	bf0c      	ite	eq
 80048dc:	2301      	moveq	r3, #1
 80048de:	2300      	movne	r3, #0
 80048e0:	b2db      	uxtb	r3, r3
 80048e2:	2b00      	cmp	r3, #0
 80048e4:	d109      	bne.n	80048fa <chHeapFree+0x2a>
 80048e6:	9b01      	ldr	r3, [sp, #4]
 80048e8:	f003 0307 	and.w	r3, r3, #7
 80048ec:	2b00      	cmp	r3, #0
 80048ee:	bf14      	ite	ne
 80048f0:	2301      	movne	r3, #1
 80048f2:	2300      	moveq	r3, #0
 80048f4:	b2db      	uxtb	r3, r3
 80048f6:	2b00      	cmp	r3, #0
 80048f8:	d002      	beq.n	8004900 <chHeapFree+0x30>
 80048fa:	4843      	ldr	r0, [pc, #268]	@ (8004a08 <chHeapFree+0x138>)
 80048fc:	f7fd ff00 	bl	8002700 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8004900:	9b01      	ldr	r3, [sp, #4]
 8004902:	3b08      	subs	r3, #8
 8004904:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8004906:	9b04      	ldr	r3, [sp, #16]
 8004908:	681b      	ldr	r3, [r3, #0]
 800490a:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 800490c:	9b03      	ldr	r3, [sp, #12]
 800490e:	3304      	adds	r3, #4
 8004910:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8004912:	9b04      	ldr	r3, [sp, #16]
 8004914:	685b      	ldr	r3, [r3, #4]
 8004916:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8004918:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800491a:	9b04      	ldr	r3, [sp, #16]
 800491c:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800491e:	9b03      	ldr	r3, [sp, #12]
 8004920:	330c      	adds	r3, #12
 8004922:	4618      	mov	r0, r3
 8004924:	f7ff fddc 	bl	80044e0 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8004928:	9a04      	ldr	r2, [sp, #16]
 800492a:	9b05      	ldr	r3, [sp, #20]
 800492c:	429a      	cmp	r2, r3
 800492e:	bf2c      	ite	cs
 8004930:	2301      	movcs	r3, #1
 8004932:	2300      	movcc	r3, #0
 8004934:	b2db      	uxtb	r3, r3
 8004936:	2b00      	cmp	r3, #0
 8004938:	d010      	beq.n	800495c <chHeapFree+0x8c>
 800493a:	9b05      	ldr	r3, [sp, #20]
 800493c:	685b      	ldr	r3, [r3, #4]
 800493e:	3301      	adds	r3, #1
 8004940:	00db      	lsls	r3, r3, #3
 8004942:	9a05      	ldr	r2, [sp, #20]
 8004944:	4413      	add	r3, r2
 8004946:	9a04      	ldr	r2, [sp, #16]
 8004948:	429a      	cmp	r2, r3
 800494a:	bf34      	ite	cc
 800494c:	2301      	movcc	r3, #1
 800494e:	2300      	movcs	r3, #0
 8004950:	b2db      	uxtb	r3, r3
 8004952:	2b00      	cmp	r3, #0
 8004954:	d002      	beq.n	800495c <chHeapFree+0x8c>
 8004956:	482c      	ldr	r0, [pc, #176]	@ (8004a08 <chHeapFree+0x138>)
 8004958:	f7fd fed2 	bl	8002700 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 800495c:	9b03      	ldr	r3, [sp, #12]
 800495e:	3304      	adds	r3, #4
 8004960:	9a05      	ldr	r2, [sp, #20]
 8004962:	429a      	cmp	r2, r3
 8004964:	d003      	beq.n	800496e <chHeapFree+0x9e>
 8004966:	9a04      	ldr	r2, [sp, #16]
 8004968:	9b05      	ldr	r3, [sp, #20]
 800496a:	429a      	cmp	r2, r3
 800496c:	d93d      	bls.n	80049ea <chHeapFree+0x11a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800496e:	9b05      	ldr	r3, [sp, #20]
 8004970:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8004972:	2b00      	cmp	r3, #0
 8004974:	d004      	beq.n	8004980 <chHeapFree+0xb0>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8004976:	9b05      	ldr	r3, [sp, #20]
 8004978:	681b      	ldr	r3, [r3, #0]
 800497a:	9a04      	ldr	r2, [sp, #16]
 800497c:	429a      	cmp	r2, r3
 800497e:	d234      	bcs.n	80049ea <chHeapFree+0x11a>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8004980:	9b05      	ldr	r3, [sp, #20]
 8004982:	681a      	ldr	r2, [r3, #0]
 8004984:	9b04      	ldr	r3, [sp, #16]
 8004986:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8004988:	9b05      	ldr	r3, [sp, #20]
 800498a:	9a04      	ldr	r2, [sp, #16]
 800498c:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800498e:	9b04      	ldr	r3, [sp, #16]
 8004990:	685b      	ldr	r3, [r3, #4]
 8004992:	3301      	adds	r3, #1
 8004994:	00db      	lsls	r3, r3, #3
 8004996:	9a04      	ldr	r2, [sp, #16]
 8004998:	441a      	add	r2, r3
 800499a:	9b04      	ldr	r3, [sp, #16]
 800499c:	681b      	ldr	r3, [r3, #0]
 800499e:	429a      	cmp	r2, r3
 80049a0:	d10d      	bne.n	80049be <chHeapFree+0xee>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80049a2:	9b04      	ldr	r3, [sp, #16]
 80049a4:	685a      	ldr	r2, [r3, #4]
 80049a6:	9b04      	ldr	r3, [sp, #16]
 80049a8:	681b      	ldr	r3, [r3, #0]
 80049aa:	685b      	ldr	r3, [r3, #4]
 80049ac:	4413      	add	r3, r2
 80049ae:	1c5a      	adds	r2, r3, #1
 80049b0:	9b04      	ldr	r3, [sp, #16]
 80049b2:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80049b4:	9b04      	ldr	r3, [sp, #16]
 80049b6:	681b      	ldr	r3, [r3, #0]
 80049b8:	681a      	ldr	r2, [r3, #0]
 80049ba:	9b04      	ldr	r3, [sp, #16]
 80049bc:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 80049be:	9b05      	ldr	r3, [sp, #20]
 80049c0:	685b      	ldr	r3, [r3, #4]
 80049c2:	3301      	adds	r3, #1
 80049c4:	00db      	lsls	r3, r3, #3
 80049c6:	9a05      	ldr	r2, [sp, #20]
 80049c8:	4413      	add	r3, r2
 80049ca:	9a04      	ldr	r2, [sp, #16]
 80049cc:	429a      	cmp	r2, r3
 80049ce:	d110      	bne.n	80049f2 <chHeapFree+0x122>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80049d0:	9b05      	ldr	r3, [sp, #20]
 80049d2:	685a      	ldr	r2, [r3, #4]
 80049d4:	9b04      	ldr	r3, [sp, #16]
 80049d6:	685b      	ldr	r3, [r3, #4]
 80049d8:	4413      	add	r3, r2
 80049da:	1c5a      	adds	r2, r3, #1
 80049dc:	9b05      	ldr	r3, [sp, #20]
 80049de:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 80049e0:	9b04      	ldr	r3, [sp, #16]
 80049e2:	681a      	ldr	r2, [r3, #0]
 80049e4:	9b05      	ldr	r3, [sp, #20]
 80049e6:	601a      	str	r2, [r3, #0]
      }
      break;
 80049e8:	e003      	b.n	80049f2 <chHeapFree+0x122>
    }
    qp = H_NEXT(qp);
 80049ea:	9b05      	ldr	r3, [sp, #20]
 80049ec:	681b      	ldr	r3, [r3, #0]
 80049ee:	9305      	str	r3, [sp, #20]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 80049f0:	e79a      	b.n	8004928 <chHeapFree+0x58>
      break;
 80049f2:	bf00      	nop
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80049f4:	9b03      	ldr	r3, [sp, #12]
 80049f6:	330c      	adds	r3, #12
 80049f8:	4618      	mov	r0, r3
 80049fa:	f7ff fe19 	bl	8004630 <chMtxUnlock>

  return;
 80049fe:	bf00      	nop
}
 8004a00:	b007      	add	sp, #28
 8004a02:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a06:	bf00      	nop
 8004a08:	08005680 	.word	0x08005680
 8004a0c:	00000000 	.word	0x00000000

08004a10 <chSysLock.lto_priv.16>:
static inline void chSysLock(void) {
 8004a10:	b500      	push	{lr}
 8004a12:	b083      	sub	sp, #12
 8004a14:	2330      	movs	r3, #48	@ 0x30
 8004a16:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004a18:	9b01      	ldr	r3, [sp, #4]
 8004a1a:	f383 8811 	msr	BASEPRI, r3
}
 8004a1e:	bf00      	nop
}
 8004a20:	bf00      	nop
  __dbg_check_lock();
 8004a22:	f7fd fef5 	bl	8002810 <__dbg_check_lock>
}
 8004a26:	bf00      	nop
 8004a28:	b003      	add	sp, #12
 8004a2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a2e:	bf00      	nop

08004a30 <chSysUnlock.lto_priv.16>:
static inline void chSysUnlock(void) {
 8004a30:	b500      	push	{lr}
 8004a32:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004a34:	f7fd ff14 	bl	8002860 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004a38:	4b12      	ldr	r3, [pc, #72]	@ (8004a84 <chSysUnlock.lto_priv.16+0x54>)
 8004a3a:	681b      	ldr	r3, [r3, #0]
 8004a3c:	4a11      	ldr	r2, [pc, #68]	@ (8004a84 <chSysUnlock.lto_priv.16+0x54>)
 8004a3e:	4293      	cmp	r3, r2
 8004a40:	bf14      	ite	ne
 8004a42:	2301      	movne	r3, #1
 8004a44:	2300      	moveq	r3, #0
 8004a46:	b2db      	uxtb	r3, r3
 8004a48:	2b00      	cmp	r3, #0
 8004a4a:	d00f      	beq.n	8004a6c <chSysUnlock.lto_priv.16+0x3c>
 8004a4c:	4b0d      	ldr	r3, [pc, #52]	@ (8004a84 <chSysUnlock.lto_priv.16+0x54>)
 8004a4e:	68db      	ldr	r3, [r3, #12]
 8004a50:	689a      	ldr	r2, [r3, #8]
 8004a52:	4b0c      	ldr	r3, [pc, #48]	@ (8004a84 <chSysUnlock.lto_priv.16+0x54>)
 8004a54:	681b      	ldr	r3, [r3, #0]
 8004a56:	689b      	ldr	r3, [r3, #8]
 8004a58:	429a      	cmp	r2, r3
 8004a5a:	bf34      	ite	cc
 8004a5c:	2301      	movcc	r3, #1
 8004a5e:	2300      	movcs	r3, #0
 8004a60:	b2db      	uxtb	r3, r3
 8004a62:	2b00      	cmp	r3, #0
 8004a64:	d002      	beq.n	8004a6c <chSysUnlock.lto_priv.16+0x3c>
 8004a66:	4808      	ldr	r0, [pc, #32]	@ (8004a88 <chSysUnlock.lto_priv.16+0x58>)
 8004a68:	f7fd fe4a 	bl	8002700 <chSysHalt>
 8004a6c:	2300      	movs	r3, #0
 8004a6e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004a70:	9b01      	ldr	r3, [sp, #4]
 8004a72:	f383 8811 	msr	BASEPRI, r3
}
 8004a76:	bf00      	nop
}
 8004a78:	bf00      	nop
}
 8004a7a:	bf00      	nop
 8004a7c:	b003      	add	sp, #12
 8004a7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a82:	bf00      	nop
 8004a84:	200008d0 	.word	0x200008d0
 8004a88:	080056a4 	.word	0x080056a4
 8004a8c:	00000000 	.word	0x00000000

08004a90 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8004a90:	b500      	push	{lr}
 8004a92:	b085      	sub	sp, #20
 8004a94:	9003      	str	r0, [sp, #12]
 8004a96:	9102      	str	r1, [sp, #8]
 8004a98:	9201      	str	r2, [sp, #4]
 8004a9a:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 8004a9c:	9b03      	ldr	r3, [sp, #12]
 8004a9e:	2b00      	cmp	r3, #0
 8004aa0:	bf0c      	ite	eq
 8004aa2:	2301      	moveq	r3, #1
 8004aa4:	2300      	movne	r3, #0
 8004aa6:	b2db      	uxtb	r3, r3
 8004aa8:	2b00      	cmp	r3, #0
 8004aaa:	d107      	bne.n	8004abc <chPoolObjectInitAligned+0x2c>
 8004aac:	9b02      	ldr	r3, [sp, #8]
 8004aae:	2b03      	cmp	r3, #3
 8004ab0:	bf94      	ite	ls
 8004ab2:	2301      	movls	r3, #1
 8004ab4:	2300      	movhi	r3, #0
 8004ab6:	b2db      	uxtb	r3, r3
 8004ab8:	2b00      	cmp	r3, #0
 8004aba:	d001      	beq.n	8004ac0 <chPoolObjectInitAligned+0x30>
 8004abc:	2301      	movs	r3, #1
 8004abe:	e000      	b.n	8004ac2 <chPoolObjectInitAligned+0x32>
 8004ac0:	2300      	movs	r3, #0
 8004ac2:	2b00      	cmp	r3, #0
 8004ac4:	d107      	bne.n	8004ad6 <chPoolObjectInitAligned+0x46>
 8004ac6:	9b01      	ldr	r3, [sp, #4]
 8004ac8:	2b03      	cmp	r3, #3
 8004aca:	bf94      	ite	ls
 8004acc:	2301      	movls	r3, #1
 8004ace:	2300      	movhi	r3, #0
 8004ad0:	b2db      	uxtb	r3, r3
 8004ad2:	2b00      	cmp	r3, #0
 8004ad4:	d001      	beq.n	8004ada <chPoolObjectInitAligned+0x4a>
 8004ad6:	2301      	movs	r3, #1
 8004ad8:	e000      	b.n	8004adc <chPoolObjectInitAligned+0x4c>
 8004ada:	2300      	movs	r3, #0
 8004adc:	2b00      	cmp	r3, #0
 8004ade:	d117      	bne.n	8004b10 <chPoolObjectInitAligned+0x80>
 8004ae0:	9b01      	ldr	r3, [sp, #4]
 8004ae2:	2b00      	cmp	r3, #0
 8004ae4:	bf0c      	ite	eq
 8004ae6:	2301      	moveq	r3, #1
 8004ae8:	2300      	movne	r3, #0
 8004aea:	b2db      	uxtb	r3, r3
 8004aec:	2b00      	cmp	r3, #0
 8004aee:	d10a      	bne.n	8004b06 <chPoolObjectInitAligned+0x76>
 8004af0:	9b01      	ldr	r3, [sp, #4]
 8004af2:	1e5a      	subs	r2, r3, #1
 8004af4:	9b01      	ldr	r3, [sp, #4]
 8004af6:	4013      	ands	r3, r2
 8004af8:	2b00      	cmp	r3, #0
 8004afa:	bf14      	ite	ne
 8004afc:	2301      	movne	r3, #1
 8004afe:	2300      	moveq	r3, #0
 8004b00:	b2db      	uxtb	r3, r3
 8004b02:	2b00      	cmp	r3, #0
 8004b04:	d001      	beq.n	8004b0a <chPoolObjectInitAligned+0x7a>
 8004b06:	2301      	movs	r3, #1
 8004b08:	e000      	b.n	8004b0c <chPoolObjectInitAligned+0x7c>
 8004b0a:	2300      	movs	r3, #0
 8004b0c:	2b00      	cmp	r3, #0
 8004b0e:	d002      	beq.n	8004b16 <chPoolObjectInitAligned+0x86>
 8004b10:	4809      	ldr	r0, [pc, #36]	@ (8004b38 <chPoolObjectInitAligned+0xa8>)
 8004b12:	f7fd fdf5 	bl	8002700 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8004b16:	9b03      	ldr	r3, [sp, #12]
 8004b18:	2200      	movs	r2, #0
 8004b1a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8004b1c:	9b03      	ldr	r3, [sp, #12]
 8004b1e:	9a02      	ldr	r2, [sp, #8]
 8004b20:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8004b22:	9b03      	ldr	r3, [sp, #12]
 8004b24:	9a01      	ldr	r2, [sp, #4]
 8004b26:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8004b28:	9b03      	ldr	r3, [sp, #12]
 8004b2a:	9a00      	ldr	r2, [sp, #0]
 8004b2c:	60da      	str	r2, [r3, #12]
}
 8004b2e:	bf00      	nop
 8004b30:	b005      	add	sp, #20
 8004b32:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b36:	bf00      	nop
 8004b38:	0800568c 	.word	0x0800568c
 8004b3c:	00000000 	.word	0x00000000

08004b40 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8004b40:	b500      	push	{lr}
 8004b42:	b085      	sub	sp, #20
 8004b44:	9001      	str	r0, [sp, #4]
 8004b46:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8004b48:	9b00      	ldr	r3, [sp, #0]
 8004b4a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 8004b4c:	f7fd ff78 	bl	8002a40 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8004b50:	9b01      	ldr	r3, [sp, #4]
 8004b52:	2b00      	cmp	r3, #0
 8004b54:	bf0c      	ite	eq
 8004b56:	2301      	moveq	r3, #1
 8004b58:	2300      	movne	r3, #0
 8004b5a:	b2db      	uxtb	r3, r3
 8004b5c:	2b00      	cmp	r3, #0
 8004b5e:	d107      	bne.n	8004b70 <chPoolFreeI+0x30>
 8004b60:	9b00      	ldr	r3, [sp, #0]
 8004b62:	2b00      	cmp	r3, #0
 8004b64:	bf0c      	ite	eq
 8004b66:	2301      	moveq	r3, #1
 8004b68:	2300      	movne	r3, #0
 8004b6a:	b2db      	uxtb	r3, r3
 8004b6c:	2b00      	cmp	r3, #0
 8004b6e:	d001      	beq.n	8004b74 <chPoolFreeI+0x34>
 8004b70:	2301      	movs	r3, #1
 8004b72:	e000      	b.n	8004b76 <chPoolFreeI+0x36>
 8004b74:	2300      	movs	r3, #0
 8004b76:	2b00      	cmp	r3, #0
 8004b78:	d10b      	bne.n	8004b92 <chPoolFreeI+0x52>
 8004b7a:	9b01      	ldr	r3, [sp, #4]
 8004b7c:	689b      	ldr	r3, [r3, #8]
 8004b7e:	1e5a      	subs	r2, r3, #1
 8004b80:	9b00      	ldr	r3, [sp, #0]
 8004b82:	4013      	ands	r3, r2
 8004b84:	2b00      	cmp	r3, #0
 8004b86:	bf14      	ite	ne
 8004b88:	2301      	movne	r3, #1
 8004b8a:	2300      	moveq	r3, #0
 8004b8c:	b2db      	uxtb	r3, r3
 8004b8e:	2b00      	cmp	r3, #0
 8004b90:	d002      	beq.n	8004b98 <chPoolFreeI+0x58>
 8004b92:	4807      	ldr	r0, [pc, #28]	@ (8004bb0 <chPoolFreeI+0x70>)
 8004b94:	f7fd fdb4 	bl	8002700 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8004b98:	9b01      	ldr	r3, [sp, #4]
 8004b9a:	681a      	ldr	r2, [r3, #0]
 8004b9c:	9b03      	ldr	r3, [sp, #12]
 8004b9e:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8004ba0:	9b01      	ldr	r3, [sp, #4]
 8004ba2:	9a03      	ldr	r2, [sp, #12]
 8004ba4:	601a      	str	r2, [r3, #0]
}
 8004ba6:	bf00      	nop
 8004ba8:	b005      	add	sp, #20
 8004baa:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bae:	bf00      	nop
 8004bb0:	080056b0 	.word	0x080056b0
	...

08004bc0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8004bc0:	b500      	push	{lr}
 8004bc2:	b083      	sub	sp, #12
 8004bc4:	9001      	str	r0, [sp, #4]
 8004bc6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8004bc8:	f7ff ff22 	bl	8004a10 <chSysLock.lto_priv.16>
  chPoolFreeI(mp, objp);
 8004bcc:	9900      	ldr	r1, [sp, #0]
 8004bce:	9801      	ldr	r0, [sp, #4]
 8004bd0:	f7ff ffb6 	bl	8004b40 <chPoolFreeI>
  chSysUnlock();
 8004bd4:	f7ff ff2c 	bl	8004a30 <chSysUnlock.lto_priv.16>
}
 8004bd8:	bf00      	nop
 8004bda:	b003      	add	sp, #12
 8004bdc:	f85d fb04 	ldr.w	pc, [sp], #4

08004be0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8004be0:	b500      	push	{lr}
 8004be2:	b083      	sub	sp, #12
 8004be4:	9001      	str	r0, [sp, #4]
 8004be6:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8004be8:	2200      	movs	r2, #0
 8004bea:	9900      	ldr	r1, [sp, #0]
 8004bec:	9801      	ldr	r0, [sp, #4]
 8004bee:	f7ff fdf7 	bl	80047e0 <chCoreAllocFromTopI>
 8004bf2:	4603      	mov	r3, r0
}
 8004bf4:	4618      	mov	r0, r3
 8004bf6:	b003      	add	sp, #12
 8004bf8:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bfc:	0000      	movs	r0, r0
	...

08004c00 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8004c00:	b500      	push	{lr}
 8004c02:	b085      	sub	sp, #20
 8004c04:	9003      	str	r0, [sp, #12]
 8004c06:	9102      	str	r1, [sp, #8]
 8004c08:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8004c0a:	9b01      	ldr	r3, [sp, #4]
 8004c0c:	2204      	movs	r2, #4
 8004c0e:	9902      	ldr	r1, [sp, #8]
 8004c10:	9803      	ldr	r0, [sp, #12]
 8004c12:	f7ff ff3d 	bl	8004a90 <chPoolObjectInitAligned>
}
 8004c16:	bf00      	nop
 8004c18:	b005      	add	sp, #20
 8004c1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c1e:	bf00      	nop

08004c20 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8004c20:	b082      	sub	sp, #8
 8004c22:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8004c24:	9b01      	ldr	r3, [sp, #4]
 8004c26:	9a01      	ldr	r2, [sp, #4]
 8004c28:	601a      	str	r2, [r3, #0]
}
 8004c2a:	bf00      	nop
 8004c2c:	b002      	add	sp, #8
 8004c2e:	4770      	bx	lr

08004c30 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8004c30:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8004c32:	4810      	ldr	r0, [pc, #64]	@ (8004c74 <__factory_init+0x44>)
 8004c34:	f7ff fc34 	bl	80044a0 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8004c38:	480f      	ldr	r0, [pc, #60]	@ (8004c78 <__factory_init+0x48>)
 8004c3a:	f7ff fff1 	bl	8004c20 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8004c3e:	4a0f      	ldr	r2, [pc, #60]	@ (8004c7c <__factory_init+0x4c>)
 8004c40:	2114      	movs	r1, #20
 8004c42:	480f      	ldr	r0, [pc, #60]	@ (8004c80 <__factory_init+0x50>)
 8004c44:	f7ff ffdc 	bl	8004c00 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8004c48:	480e      	ldr	r0, [pc, #56]	@ (8004c84 <__factory_init+0x54>)
 8004c4a:	f7ff ffe9 	bl	8004c20 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8004c4e:	480e      	ldr	r0, [pc, #56]	@ (8004c88 <__factory_init+0x58>)
 8004c50:	f7ff ffe6 	bl	8004c20 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8004c54:	4a09      	ldr	r2, [pc, #36]	@ (8004c7c <__factory_init+0x4c>)
 8004c56:	211c      	movs	r1, #28
 8004c58:	480c      	ldr	r0, [pc, #48]	@ (8004c8c <__factory_init+0x5c>)
 8004c5a:	f7ff ffd1 	bl	8004c00 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8004c5e:	480c      	ldr	r0, [pc, #48]	@ (8004c90 <__factory_init+0x60>)
 8004c60:	f7ff ffde 	bl	8004c20 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8004c64:	480b      	ldr	r0, [pc, #44]	@ (8004c94 <__factory_init+0x64>)
 8004c66:	f7ff ffdb 	bl	8004c20 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 8004c6a:	480b      	ldr	r0, [pc, #44]	@ (8004c98 <__factory_init+0x68>)
 8004c6c:	f7ff ffd8 	bl	8004c20 <dyn_list_init>
#endif
}
 8004c70:	bf00      	nop
 8004c72:	bd08      	pop	{r3, pc}
 8004c74:	20000ab4 	.word	0x20000ab4
 8004c78:	20000ac4 	.word	0x20000ac4
 8004c7c:	08004be1 	.word	0x08004be1
 8004c80:	20000ac8 	.word	0x20000ac8
 8004c84:	20000ad8 	.word	0x20000ad8
 8004c88:	20000adc 	.word	0x20000adc
 8004c8c:	20000ae0 	.word	0x20000ae0
 8004c90:	20000af0 	.word	0x20000af0
 8004c94:	20000af4 	.word	0x20000af4
 8004c98:	20000af8 	.word	0x20000af8
 8004c9c:	00000000 	.word	0x00000000

08004ca0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8004ca0:	b084      	sub	sp, #16
 8004ca2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8004ca4:	9b01      	ldr	r3, [sp, #4]
 8004ca6:	f003 0307 	and.w	r3, r3, #7
 8004caa:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004cac:	4b0b      	ldr	r3, [pc, #44]	@ (8004cdc <__NVIC_SetPriorityGrouping+0x3c>)
 8004cae:	68db      	ldr	r3, [r3, #12]
 8004cb0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8004cb2:	9a02      	ldr	r2, [sp, #8]
 8004cb4:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8004cb8:	4013      	ands	r3, r2
 8004cba:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8004cbc:	9b03      	ldr	r3, [sp, #12]
 8004cbe:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8004cc0:	9b02      	ldr	r3, [sp, #8]
 8004cc2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8004cc4:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8004cc8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004ccc:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 8004cce:	4a03      	ldr	r2, [pc, #12]	@ (8004cdc <__NVIC_SetPriorityGrouping+0x3c>)
 8004cd0:	9b02      	ldr	r3, [sp, #8]
 8004cd2:	60d3      	str	r3, [r2, #12]
}
 8004cd4:	bf00      	nop
 8004cd6:	b004      	add	sp, #16
 8004cd8:	4770      	bx	lr
 8004cda:	bf00      	nop
 8004cdc:	e000ed00 	.word	0xe000ed00

08004ce0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8004ce0:	b082      	sub	sp, #8
 8004ce2:	4603      	mov	r3, r0
 8004ce4:	9100      	str	r1, [sp, #0]
 8004ce6:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 8004cea:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004cee:	2b00      	cmp	r3, #0
 8004cf0:	db0a      	blt.n	8004d08 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004cf2:	9b00      	ldr	r3, [sp, #0]
 8004cf4:	b2da      	uxtb	r2, r3
 8004cf6:	490c      	ldr	r1, [pc, #48]	@ (8004d28 <__NVIC_SetPriority+0x48>)
 8004cf8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004cfc:	0112      	lsls	r2, r2, #4
 8004cfe:	b2d2      	uxtb	r2, r2
 8004d00:	440b      	add	r3, r1
 8004d02:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8004d06:	e00b      	b.n	8004d20 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004d08:	9b00      	ldr	r3, [sp, #0]
 8004d0a:	b2da      	uxtb	r2, r3
 8004d0c:	4907      	ldr	r1, [pc, #28]	@ (8004d2c <__NVIC_SetPriority+0x4c>)
 8004d0e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004d12:	f003 030f 	and.w	r3, r3, #15
 8004d16:	3b04      	subs	r3, #4
 8004d18:	0112      	lsls	r2, r2, #4
 8004d1a:	b2d2      	uxtb	r2, r2
 8004d1c:	440b      	add	r3, r1
 8004d1e:	761a      	strb	r2, [r3, #24]
}
 8004d20:	bf00      	nop
 8004d22:	b002      	add	sp, #8
 8004d24:	4770      	bx	lr
 8004d26:	bf00      	nop
 8004d28:	e000e100 	.word	0xe000e100
 8004d2c:	e000ed00 	.word	0xe000ed00

08004d30 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004d30:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004d32:	f3ef 8309 	mrs	r3, PSP
 8004d36:	9300      	str	r3, [sp, #0]
  return(result);
 8004d38:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 8004d3a:	9303      	str	r3, [sp, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8004d3c:	9b03      	ldr	r3, [sp, #12]
 8004d3e:	3320      	adds	r3, #32
 8004d40:	9303      	str	r3, [sp, #12]
 8004d42:	9b03      	ldr	r3, [sp, #12]
 8004d44:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004d46:	9b01      	ldr	r3, [sp, #4]
 8004d48:	f383 8809 	msr	PSP, r3
}
 8004d4c:	bf00      	nop
 8004d4e:	2300      	movs	r3, #0
 8004d50:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004d52:	9b02      	ldr	r3, [sp, #8]
 8004d54:	f383 8811 	msr	BASEPRI, r3
}
 8004d58:	bf00      	nop
 8004d5a:	bf00      	nop
}
 8004d5c:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8004d5e:	bf00      	nop
 8004d60:	b004      	add	sp, #16
 8004d62:	4770      	bx	lr
	...

08004d70 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004d70:	b500      	push	{lr}
 8004d72:	b085      	sub	sp, #20
 8004d74:	9001      	str	r0, [sp, #4]
 8004d76:	2330      	movs	r3, #48	@ 0x30
 8004d78:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004d7a:	9b03      	ldr	r3, [sp, #12]
 8004d7c:	f383 8811 	msr	BASEPRI, r3
}
 8004d80:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8004d82:	b662      	cpsie	i
}
 8004d84:	bf00      	nop
}
 8004d86:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8004d88:	2003      	movs	r0, #3
 8004d8a:	f7ff ff89 	bl	8004ca0 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8004d8e:	4b0d      	ldr	r3, [pc, #52]	@ (8004dc4 <port_init+0x54>)
 8004d90:	68db      	ldr	r3, [r3, #12]
 8004d92:	4a0c      	ldr	r2, [pc, #48]	@ (8004dc4 <port_init+0x54>)
 8004d94:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004d98:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8004d9a:	4b0b      	ldr	r3, [pc, #44]	@ (8004dc8 <port_init+0x58>)
 8004d9c:	681b      	ldr	r3, [r3, #0]
 8004d9e:	4a0a      	ldr	r2, [pc, #40]	@ (8004dc8 <port_init+0x58>)
 8004da0:	f043 0301 	orr.w	r3, r3, #1
 8004da4:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8004da6:	2102      	movs	r1, #2
 8004da8:	f06f 0004 	mvn.w	r0, #4
 8004dac:	f7ff ff98 	bl	8004ce0 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004db0:	2103      	movs	r1, #3
 8004db2:	f06f 0001 	mvn.w	r0, #1
 8004db6:	f7ff ff93 	bl	8004ce0 <__NVIC_SetPriority>

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 8004dba:	bf00      	nop
 8004dbc:	b005      	add	sp, #20
 8004dbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004dc2:	bf00      	nop
 8004dc4:	e000edf0 	.word	0xe000edf0
 8004dc8:	e0001000 	.word	0xe0001000
 8004dcc:	00000000 	.word	0x00000000

08004dd0 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 8004dd0:	b500      	push	{lr}
 8004dd2:	b087      	sub	sp, #28
 8004dd4:	2330      	movs	r3, #48	@ 0x30
 8004dd6:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004dd8:	9b03      	ldr	r3, [sp, #12]
 8004dda:	f383 8811 	msr	BASEPRI, r3
}
 8004dde:	bf00      	nop
}
 8004de0:	bf00      	nop
}
 8004de2:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004de4:	4b18      	ldr	r3, [pc, #96]	@ (8004e48 <__port_irq_epilogue+0x78>)
 8004de6:	685b      	ldr	r3, [r3, #4]
 8004de8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8004dec:	2b00      	cmp	r3, #0
 8004dee:	d020      	beq.n	8004e32 <__port_irq_epilogue+0x62>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004df0:	f3ef 8309 	mrs	r3, PSP
 8004df4:	9301      	str	r3, [sp, #4]
  return(result);
 8004df6:	9b01      	ldr	r3, [sp, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 8004df8:	9305      	str	r3, [sp, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 8004dfa:	9b05      	ldr	r3, [sp, #20]
 8004dfc:	3b20      	subs	r3, #32
 8004dfe:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 8004e00:	9b05      	ldr	r3, [sp, #20]
 8004e02:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8004e04:	9b04      	ldr	r3, [sp, #16]
 8004e06:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 8004e0a:	61da      	str	r2, [r3, #28]
 8004e0c:	9b05      	ldr	r3, [sp, #20]
 8004e0e:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004e10:	9b02      	ldr	r3, [sp, #8]
 8004e12:	f383 8809 	msr	PSP, r3
}
 8004e16:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004e18:	f7fe fc7a 	bl	8003710 <chSchIsPreemptionRequired>
 8004e1c:	4603      	mov	r3, r0
 8004e1e:	2b00      	cmp	r3, #0
 8004e20:	d003      	beq.n	8004e2a <__port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8004e22:	4a0a      	ldr	r2, [pc, #40]	@ (8004e4c <__port_irq_epilogue+0x7c>)
 8004e24:	9b04      	ldr	r3, [sp, #16]
 8004e26:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8004e28:	e00b      	b.n	8004e42 <__port_irq_epilogue+0x72>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8004e2a:	4a09      	ldr	r2, [pc, #36]	@ (8004e50 <__port_irq_epilogue+0x80>)
 8004e2c:	9b04      	ldr	r3, [sp, #16]
 8004e2e:	619a      	str	r2, [r3, #24]
    return;
 8004e30:	e007      	b.n	8004e42 <__port_irq_epilogue+0x72>
 8004e32:	2300      	movs	r3, #0
 8004e34:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004e36:	9b00      	ldr	r3, [sp, #0]
 8004e38:	f383 8811 	msr	BASEPRI, r3
}
 8004e3c:	bf00      	nop
}
 8004e3e:	bf00      	nop
}
 8004e40:	bf00      	nop
  }
  port_unlock_from_isr();
}
 8004e42:	b007      	add	sp, #28
 8004e44:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e48:	e000ed00 	.word	0xe000ed00
 8004e4c:	080002c7 	.word	0x080002c7
 8004e50:	080002d2 	.word	0x080002d2
	...

08004e60 <portab_setup>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

void portab_setup(void) {
 8004e60:	b508      	push	{r3, lr}

  /* ADC inputs.*/
  palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG);
 8004e62:	f640 0203 	movw	r2, #2051	@ 0x803
 8004e66:	2101      	movs	r1, #1
 8004e68:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8004e6c:	f7fd f890 	bl	8001f90 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 1, PAL_MODE_INPUT_ANALOG);
 8004e70:	f640 0203 	movw	r2, #2051	@ 0x803
 8004e74:	2102      	movs	r1, #2
 8004e76:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8004e7a:	f7fd f889 	bl	8001f90 <_pal_lld_setgroupmode>
}
 8004e7e:	bf00      	nop
 8004e80:	bd08      	pop	{r3, pc}
 8004e82:	bf00      	nop
	...

08004e90 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8004e90:	b082      	sub	sp, #8
 8004e92:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8004e94:	4b03      	ldr	r3, [pc, #12]	@ (8004ea4 <chRegSetThreadName+0x14>)
 8004e96:	68db      	ldr	r3, [r3, #12]
 8004e98:	9a01      	ldr	r2, [sp, #4]
 8004e9a:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 8004e9c:	bf00      	nop
 8004e9e:	b002      	add	sp, #8
 8004ea0:	4770      	bx	lr
 8004ea2:	bf00      	nop
 8004ea4:	200008d0 	.word	0x200008d0
	...

08004eb0 <adccallback>:

/*
 * ADC streaming callback.
 */
size_t n= 0, nx = 0, ny = 0;
void adccallback(ADCDriver *adcp) {
 8004eb0:	b082      	sub	sp, #8
 8004eb2:	9001      	str	r0, [sp, #4]

  /* Updating counters.*/
  n++;
 8004eb4:	4b14      	ldr	r3, [pc, #80]	@ (8004f08 <adccallback+0x58>)
 8004eb6:	681b      	ldr	r3, [r3, #0]
 8004eb8:	3301      	adds	r3, #1
 8004eba:	4a13      	ldr	r2, [pc, #76]	@ (8004f08 <adccallback+0x58>)
 8004ebc:	6013      	str	r3, [r2, #0]
  if (adcIsBufferComplete(adcp)) {
 8004ebe:	9b01      	ldr	r3, [sp, #4]
 8004ec0:	781b      	ldrb	r3, [r3, #0]
 8004ec2:	2b04      	cmp	r3, #4
 8004ec4:	d105      	bne.n	8004ed2 <adccallback+0x22>
    nx += 1;
 8004ec6:	4b11      	ldr	r3, [pc, #68]	@ (8004f0c <adccallback+0x5c>)
 8004ec8:	681b      	ldr	r3, [r3, #0]
 8004eca:	3301      	adds	r3, #1
 8004ecc:	4a0f      	ldr	r2, [pc, #60]	@ (8004f0c <adccallback+0x5c>)
 8004ece:	6013      	str	r3, [r2, #0]
 8004ed0:	e004      	b.n	8004edc <adccallback+0x2c>
  }
  else {
    ny += 1;
 8004ed2:	4b0f      	ldr	r3, [pc, #60]	@ (8004f10 <adccallback+0x60>)
 8004ed4:	681b      	ldr	r3, [r3, #0]
 8004ed6:	3301      	adds	r3, #1
 8004ed8:	4a0d      	ldr	r2, [pc, #52]	@ (8004f10 <adccallback+0x60>)
 8004eda:	6013      	str	r3, [r2, #0]
  }

  if ((n % 200) == 0U) {
 8004edc:	4b0a      	ldr	r3, [pc, #40]	@ (8004f08 <adccallback+0x58>)
 8004ede:	681a      	ldr	r2, [r3, #0]
 8004ee0:	4b0c      	ldr	r3, [pc, #48]	@ (8004f14 <adccallback+0x64>)
 8004ee2:	fba3 1302 	umull	r1, r3, r3, r2
 8004ee6:	099b      	lsrs	r3, r3, #6
 8004ee8:	21c8      	movs	r1, #200	@ 0xc8
 8004eea:	fb01 f303 	mul.w	r3, r1, r3
 8004eee:	1ad3      	subs	r3, r2, r3
 8004ef0:	2b00      	cmp	r3, #0
 8004ef2:	d105      	bne.n	8004f00 <adccallback+0x50>
#if defined(PORTAB_LINE_LED2)
    palToggleLine(PORTAB_LINE_LED2);
 8004ef4:	4b08      	ldr	r3, [pc, #32]	@ (8004f18 <adccallback+0x68>)
 8004ef6:	695b      	ldr	r3, [r3, #20]
 8004ef8:	4a07      	ldr	r2, [pc, #28]	@ (8004f18 <adccallback+0x68>)
 8004efa:	f083 0380 	eor.w	r3, r3, #128	@ 0x80
 8004efe:	6153      	str	r3, [r2, #20]
#endif
  }
}
 8004f00:	bf00      	nop
 8004f02:	b002      	add	sp, #8
 8004f04:	4770      	bx	lr
 8004f06:	bf00      	nop
 8004f08:	20000c04 	.word	0x20000c04
 8004f0c:	20000c08 	.word	0x20000c08
 8004f10:	20000c0c 	.word	0x20000c0c
 8004f14:	51eb851f 	.word	0x51eb851f
 8004f18:	48000400 	.word	0x48000400
 8004f1c:	00000000 	.word	0x00000000

08004f20 <adcerrorcallback>:

/*
 * ADC errors callback, should never happen.
 */
void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8004f20:	b500      	push	{lr}
 8004f22:	b083      	sub	sp, #12
 8004f24:	9001      	str	r0, [sp, #4]
 8004f26:	9100      	str	r1, [sp, #0]

  (void)adcp;
  (void)err;

  chSysHalt("it happened");
 8004f28:	4803      	ldr	r0, [pc, #12]	@ (8004f38 <adcerrorcallback+0x18>)
 8004f2a:	f7fd fbe9 	bl	8002700 <chSysHalt>
}
 8004f2e:	bf00      	nop
 8004f30:	b003      	add	sp, #12
 8004f32:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f36:	bf00      	nop
 8004f38:	08005460 	.word	0x08005460
 8004f3c:	00000000 	.word	0x00000000

08004f40 <Thread1>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED attached to TP1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8004f40:	b500      	push	{lr}
 8004f42:	b083      	sub	sp, #12
 8004f44:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 8004f46:	4809      	ldr	r0, [pc, #36]	@ (8004f6c <Thread1+0x2c>)
 8004f48:	f7ff ffa2 	bl	8004e90 <chRegSetThreadName>
  while (true) {
    palSetLine(PORTAB_LINE_LED1);
 8004f4c:	4b08      	ldr	r3, [pc, #32]	@ (8004f70 <Thread1+0x30>)
 8004f4e:	2280      	movs	r2, #128	@ 0x80
 8004f50:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8004f52:	f241 3088 	movw	r0, #5000	@ 0x1388
 8004f56:	f7ff f80b 	bl	8003f70 <chThdSleep>
    palClearLine(PORTAB_LINE_LED1);
 8004f5a:	4b05      	ldr	r3, [pc, #20]	@ (8004f70 <Thread1+0x30>)
 8004f5c:	2280      	movs	r2, #128	@ 0x80
 8004f5e:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8004f60:	f241 3088 	movw	r0, #5000	@ 0x1388
 8004f64:	f7ff f804 	bl	8003f70 <chThdSleep>
    palSetLine(PORTAB_LINE_LED1);
 8004f68:	bf00      	nop
 8004f6a:	e7ef      	b.n	8004f4c <Thread1+0xc>
 8004f6c:	0800546c 	.word	0x0800546c
 8004f70:	48000800 	.word	0x48000800
	...

08004f80 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8004f80:	b500      	push	{lr}
 8004f82:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8004f84:	f7fb fa04 	bl	8000390 <halInit>
  chSysInit();
 8004f88:	f7fd fb8a 	bl	80026a0 <chSysInit>

  /* Board-dependent GPIO setup code.*/
  portab_setup();
 8004f8c:	f7ff ff68 	bl	8004e60 <portab_setup>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8004f90:	2300      	movs	r3, #0
 8004f92:	9300      	str	r3, [sp, #0]
 8004f94:	4b1b      	ldr	r3, [pc, #108]	@ (8005004 <main+0x84>)
 8004f96:	2280      	movs	r2, #128	@ 0x80
 8004f98:	f44f 71b8 	mov.w	r1, #368	@ 0x170
 8004f9c:	481a      	ldr	r0, [pc, #104]	@ (8005008 <main+0x88>)
 8004f9e:	f7fe fea7 	bl	8003cf0 <chThdCreateStatic>

  /*
   * Starting PORTAB_ADC1 driver and the temperature sensor.
   */
  adcStart(&PORTAB_ADC1, &portab_adccfg1);
 8004fa2:	491a      	ldr	r1, [pc, #104]	@ (800500c <main+0x8c>)
 8004fa4:	481a      	ldr	r0, [pc, #104]	@ (8005010 <main+0x90>)
 8004fa6:	f7fb fb4b 	bl	8000640 <adcStart>
  adcSTM32EnableVREF(&PORTAB_ADC1);
 8004faa:	4819      	ldr	r0, [pc, #100]	@ (8005010 <main+0x90>)
 8004fac:	f7fc fd80 	bl	8001ab0 <adcSTM32EnableVREF>
  adcSTM32EnableTS(&PORTAB_ADC1);
 8004fb0:	4817      	ldr	r0, [pc, #92]	@ (8005010 <main+0x90>)
 8004fb2:	f7fc fd8d 	bl	8001ad0 <adcSTM32EnableTS>

  /* Performing a one-shot conversion on two channels.*/
  adcConvert(&PORTAB_ADC1, &portab_adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
 8004fb6:	2302      	movs	r3, #2
 8004fb8:	4a16      	ldr	r2, [pc, #88]	@ (8005014 <main+0x94>)
 8004fba:	4917      	ldr	r1, [pc, #92]	@ (8005018 <main+0x98>)
 8004fbc:	4814      	ldr	r0, [pc, #80]	@ (8005010 <main+0x90>)
 8004fbe:	f7fb fc5f 	bl	8000880 <adcConvert>
  cacheBufferInvalidate(samples1, sizeof (samples1) / sizeof (adcsample_t));

  /*
   * Starting PORTAB_GPT1 driver, it is used for triggering the ADC.
   */
  gptStart(&PORTAB_GPT1, &portab_gptcfg1);
 8004fc2:	4916      	ldr	r1, [pc, #88]	@ (800501c <main+0x9c>)
 8004fc4:	4816      	ldr	r0, [pc, #88]	@ (8005020 <main+0xa0>)
 8004fc6:	f7fb fcf3 	bl	80009b0 <gptStart>

  /*
   * Starting an ADC continuous conversion triggered with a period of
   * 1/10000 second.
   */
  adcStartConversion(&PORTAB_ADC1, &portab_adcgrpcfg2,
 8004fca:	2340      	movs	r3, #64	@ 0x40
 8004fcc:	4a15      	ldr	r2, [pc, #84]	@ (8005024 <main+0xa4>)
 8004fce:	4916      	ldr	r1, [pc, #88]	@ (8005028 <main+0xa8>)
 8004fd0:	480f      	ldr	r0, [pc, #60]	@ (8005010 <main+0x90>)
 8004fd2:	f7fb fb7d 	bl	80006d0 <adcStartConversion>
                     samples2, ADC_GRP2_BUF_DEPTH);
  gptStartContinuous(&PORTAB_GPT1, 100U);
 8004fd6:	2164      	movs	r1, #100	@ 0x64
 8004fd8:	4811      	ldr	r0, [pc, #68]	@ (8005020 <main+0xa0>)
 8004fda:	f7fb fd39 	bl	8000a50 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the
   * conversion is stopped.
   */
  while (true) {
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8004fde:	4b13      	ldr	r3, [pc, #76]	@ (800502c <main+0xac>)
 8004fe0:	691b      	ldr	r3, [r3, #16]
 8004fe2:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8004fe6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8004fea:	d105      	bne.n	8004ff8 <main+0x78>
      gptStopTimer(&PORTAB_GPT1);
 8004fec:	480c      	ldr	r0, [pc, #48]	@ (8005020 <main+0xa0>)
 8004fee:	f7fb fd6f 	bl	8000ad0 <gptStopTimer>
      adcStopConversion(&PORTAB_ADC1);
 8004ff2:	4807      	ldr	r0, [pc, #28]	@ (8005010 <main+0x90>)
 8004ff4:	f7fb fbfc 	bl	80007f0 <adcStopConversion>
    }
    chThdSleepMilliseconds(500);
 8004ff8:	f241 3088 	movw	r0, #5000	@ 0x1388
 8004ffc:	f7fe ffb8 	bl	8003f70 <chThdSleep>
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8005000:	e7ed      	b.n	8004fde <main+0x5e>
 8005002:	bf00      	nop
 8005004:	08004f41 	.word	0x08004f41
 8005008:	20000c10 	.word	0x20000c10
 800500c:	080056cc 	.word	0x080056cc
 8005010:	20000800 	.word	0x20000800
 8005014:	20000afc 	.word	0x20000afc
 8005018:	080056d0 	.word	0x080056d0
 800501c:	080056bc 	.word	0x080056bc
 8005020:	200008b4 	.word	0x200008b4
 8005024:	20000b04 	.word	0x20000b04
 8005028:	08005710 	.word	0x08005710
 800502c:	48000800 	.word	0x48000800
