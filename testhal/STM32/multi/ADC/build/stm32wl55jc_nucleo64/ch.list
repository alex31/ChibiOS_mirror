
build/stm32wl55jc_nucleo64/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000239 	.word	0x08000239
 8000008:	0800023b 	.word	0x0800023b
 800000c:	0800023b 	.word	0x0800023b
 8000010:	0800023b 	.word	0x0800023b
 8000014:	0800023b 	.word	0x0800023b
 8000018:	0800023b 	.word	0x0800023b
 800001c:	0800023b 	.word	0x0800023b
 8000020:	0800023b 	.word	0x0800023b
 8000024:	0800023b 	.word	0x0800023b
 8000028:	0800023b 	.word	0x0800023b
 800002c:	080045f1 	.word	0x080045f1
 8000030:	0800023b 	.word	0x0800023b
 8000034:	0800023b 	.word	0x0800023b
 8000038:	0800023b 	.word	0x0800023b
 800003c:	0800023b 	.word	0x0800023b
 8000040:	0800023b 	.word	0x0800023b
 8000044:	0800023b 	.word	0x0800023b
 8000048:	0800023b 	.word	0x0800023b
 800004c:	0800023b 	.word	0x0800023b
 8000050:	0800023b 	.word	0x0800023b
 8000054:	0800023b 	.word	0x0800023b
 8000058:	0800023b 	.word	0x0800023b
 800005c:	0800023b 	.word	0x0800023b
 8000060:	0800023b 	.word	0x0800023b
 8000064:	0800023b 	.word	0x0800023b
 8000068:	0800023b 	.word	0x0800023b
 800006c:	08001cd1 	.word	0x08001cd1
 8000070:	08001cf1 	.word	0x08001cf1
 8000074:	08001d11 	.word	0x08001d11
 8000078:	08001d31 	.word	0x08001d31
 800007c:	08001d51 	.word	0x08001d51
 8000080:	08001d71 	.word	0x08001d71
 8000084:	08001d91 	.word	0x08001d91
 8000088:	08001901 	.word	0x08001901
 800008c:	0800023b 	.word	0x0800023b
 8000090:	0800023b 	.word	0x0800023b
 8000094:	0800023b 	.word	0x0800023b
 8000098:	0800023b 	.word	0x0800023b
 800009c:	0800023b 	.word	0x0800023b
 80000a0:	08000b71 	.word	0x08000b71
 80000a4:	0800023b 	.word	0x0800023b
 80000a8:	08000b91 	.word	0x08000b91
 80000ac:	08000bf1 	.word	0x08000bf1
 80000b0:	0800023b 	.word	0x0800023b
 80000b4:	0800023b 	.word	0x0800023b
 80000b8:	0800023b 	.word	0x0800023b
 80000bc:	0800023b 	.word	0x0800023b
 80000c0:	0800023b 	.word	0x0800023b
 80000c4:	0800023b 	.word	0x0800023b
 80000c8:	0800023b 	.word	0x0800023b
 80000cc:	0800023b 	.word	0x0800023b
 80000d0:	0800023b 	.word	0x0800023b
 80000d4:	0800023b 	.word	0x0800023b
 80000d8:	0800023b 	.word	0x0800023b
 80000dc:	0800023b 	.word	0x0800023b
 80000e0:	0800023b 	.word	0x0800023b
 80000e4:	0800023b 	.word	0x0800023b
 80000e8:	0800023b 	.word	0x0800023b
 80000ec:	0800023b 	.word	0x0800023b
 80000f0:	0800023b 	.word	0x0800023b
 80000f4:	0800023b 	.word	0x0800023b
 80000f8:	0800023b 	.word	0x0800023b
 80000fc:	0800023b 	.word	0x0800023b
 8000100:	0800023b 	.word	0x0800023b
 8000104:	0800023b 	.word	0x0800023b
 8000108:	0800023b 	.word	0x0800023b
 800010c:	0800023b 	.word	0x0800023b
 8000110:	0800023b 	.word	0x0800023b
 8000114:	0800023b 	.word	0x0800023b
 8000118:	08001db1 	.word	0x08001db1
 800011c:	08001dd1 	.word	0x08001dd1
 8000120:	08001df1 	.word	0x08001df1
 8000124:	08001e11 	.word	0x08001e11
 8000128:	08001e31 	.word	0x08001e31
 800012c:	08001e51 	.word	0x08001e51
 8000130:	08001e71 	.word	0x08001e71
 8000134:	0800023b 	.word	0x0800023b
 8000138:	0800023b 	.word	0x0800023b
 800013c:	0800023b 	.word	0x0800023b
 8000140:	0800023b 	.word	0x0800023b
 8000144:	0800023b 	.word	0x0800023b
 8000148:	0800023b 	.word	0x0800023b
 800014c:	0800023b 	.word	0x0800023b
 8000150:	0800023b 	.word	0x0800023b
 8000154:	0800023b 	.word	0x0800023b
 8000158:	0800023b 	.word	0x0800023b
 800015c:	0800023b 	.word	0x0800023b

Disassembly of section .text:

08000160 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000160:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000162:	4826      	ldr	r0, [pc, #152]	@ (80001fc <endfiniloop+0x6>)
                msr     MSP, r0
 8000164:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000168:	4825      	ldr	r0, [pc, #148]	@ (8000200 <endfiniloop+0xa>)
                msr     PSP, r0
 800016a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 800016e:	4825      	ldr	r0, [pc, #148]	@ (8000204 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 8000170:	4925      	ldr	r1, [pc, #148]	@ (8000208 <endfiniloop+0x12>)
                str     r0, [r1]
 8000172:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 8000174:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000176:	f380 8814 	msr	CONTROL, r0
                isb
 800017a:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 800017e:	f000 f88f 	bl	80002a0 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000182:	f002 fad5 	bl	8002730 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000186:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800018a:	4920      	ldr	r1, [pc, #128]	@ (800020c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800018c:	4a1b      	ldr	r2, [pc, #108]	@ (80001fc <endfiniloop+0x6>)

0800018e <msloop>:
msloop:
                cmp     r1, r2
 800018e:	4291      	cmp	r1, r2
                itt     lo
 8000190:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000192:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000196:	e7fa      	bcc.n	800018e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000198:	491d      	ldr	r1, [pc, #116]	@ (8000210 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800019a:	4a19      	ldr	r2, [pc, #100]	@ (8000200 <endfiniloop+0xa>)

0800019c <psloop>:
psloop:
                cmp     r1, r2
 800019c:	4291      	cmp	r1, r2
                itt     lo
 800019e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001a0:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 80001a4:	e7fa      	bcc.n	800019c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 80001a6:	491b      	ldr	r1, [pc, #108]	@ (8000214 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 80001a8:	4a1b      	ldr	r2, [pc, #108]	@ (8000218 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 80001aa:	4b1c      	ldr	r3, [pc, #112]	@ (800021c <endfiniloop+0x26>)

080001ac <dloop>:
dloop:
                cmp     r2, r3
 80001ac:	429a      	cmp	r2, r3
                ittt    lo
 80001ae:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 80001b0:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 80001b4:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 80001b8:	e7f8      	bcc.n	80001ac <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 80001ba:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 80001bc:	4918      	ldr	r1, [pc, #96]	@ (8000220 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 80001be:	4a19      	ldr	r2, [pc, #100]	@ (8000224 <endfiniloop+0x2e>)

080001c0 <bloop>:
bloop:
                cmp     r1, r2
 80001c0:	4291      	cmp	r1, r2
                itt     lo
 80001c2:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001c4:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 80001c8:	e7fa      	bcc.n	80001c0 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 80001ca:	f000 f881 	bl	80002d0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 80001ce:	f000 f86f 	bl	80002b0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 80001d2:	4c15      	ldr	r4, [pc, #84]	@ (8000228 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 80001d4:	4d15      	ldr	r5, [pc, #84]	@ (800022c <endfiniloop+0x36>)

080001d6 <initloop>:
initloop:
                cmp     r4, r5
 80001d6:	42ac      	cmp	r4, r5
                bge     endinitloop
 80001d8:	da03      	bge.n	80001e2 <endinitloop>
                ldr     r1, [r4], #4
 80001da:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80001de:	4788      	blx	r1
                b       initloop
 80001e0:	e7f9      	b.n	80001d6 <initloop>

080001e2 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80001e2:	f004 fb0d 	bl	8004800 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80001e6:	4c12      	ldr	r4, [pc, #72]	@ (8000230 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 80001e8:	4d12      	ldr	r5, [pc, #72]	@ (8000234 <endfiniloop+0x3e>)

080001ea <finiloop>:
finiloop:
                cmp     r4, r5
 80001ea:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80001ec:	da03      	bge.n	80001f6 <endfiniloop>
                ldr     r1, [r4], #4
 80001ee:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80001f2:	4788      	blx	r1
                b       finiloop
 80001f4:	e7f9      	b.n	80001ea <finiloop>

080001f6 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80001f6:	f000 b863 	b.w	80002c0 <__default_exit>
 80001fa:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 80001fc:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000200:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000204:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000208:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800020c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000210:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000214:	08004db0 	.word	0x08004db0
                ldr     r2, =__data_base__
 8000218:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800021c:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 8000220:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 8000224:	20000e98 	.word	0x20000e98
                ldr     r4, =__init_array_base__
 8000228:	08000160 	.word	0x08000160
                ldr     r5, =__init_array_end__
 800022c:	08000160 	.word	0x08000160
                ldr     r4, =__fini_array_base__
 8000230:	08000160 	.word	0x08000160
                ldr     r5, =__fini_array_end__
 8000234:	08000160 	.word	0x08000160

08000238 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000238:	e792      	b.n	8000160 <_crt0_entry>

0800023a <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 800023a:	f000 f800 	bl	800023e <_unhandled_exception>

0800023e <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 800023e:	e7fe      	b.n	800023e <_unhandled_exception>

08000240 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000244:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000248:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 800024a:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800024c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000250 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 8000250:	f002 fb4e 	bl	80028f0 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000254:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000256:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 800025a:	4628      	mov	r0, r5
                blx     r4
 800025c:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800025e:	2000      	movs	r0, #0
                bl      chThdExit
 8000260:	f003 fd5e 	bl	8003d20 <chThdExit>

08000264 <.zombies>:
.zombies:       b       .zombies
 8000264:	e7fe      	b.n	8000264 <.zombies>

08000266 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 8000266:	f002 fb1b 	bl	80028a0 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 800026a:	f003 fa41 	bl	80036f0 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 800026e:	f002 fb3f 	bl	80028f0 <__dbg_check_unlock>

08000272 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000272:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000274:	e7fe      	b.n	8000274 <__port_exit_from_isr+0x2>

08000276 <memcpy>:
 8000276:	440a      	add	r2, r1
 8000278:	4291      	cmp	r1, r2
 800027a:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
 800027e:	d100      	bne.n	8000282 <memcpy+0xc>
 8000280:	4770      	bx	lr
 8000282:	b510      	push	{r4, lr}
 8000284:	f811 4b01 	ldrb.w	r4, [r1], #1
 8000288:	f803 4f01 	strb.w	r4, [r3, #1]!
 800028c:	4291      	cmp	r1, r2
 800028e:	d1f9      	bne.n	8000284 <memcpy+0xe>
 8000290:	bd10      	pop	{r4, pc}
	...

080002a0 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80002a0:	bf00      	nop
 80002a2:	4770      	bx	lr
	...

080002b0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80002b0:	bf00      	nop
 80002b2:	4770      	bx	lr
	...

080002c0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
     asm volatile ("nop");
 80002c0:	bf00      	nop
 80002c2:	e7fd      	b.n	80002c0 <__default_exit>
	...

080002d0 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80002d0:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80002d2:	4b17      	ldr	r3, [pc, #92]	@ (8000330 <__init_ram_areas+0x60>)
 80002d4:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 80002d6:	9b03      	ldr	r3, [sp, #12]
 80002d8:	681b      	ldr	r3, [r3, #0]
 80002da:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 80002dc:	9b03      	ldr	r3, [sp, #12]
 80002de:	685b      	ldr	r3, [r3, #4]
 80002e0:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80002e2:	e009      	b.n	80002f8 <__init_ram_areas+0x28>
      *p = *tp;
 80002e4:	9b02      	ldr	r3, [sp, #8]
 80002e6:	681a      	ldr	r2, [r3, #0]
 80002e8:	9b01      	ldr	r3, [sp, #4]
 80002ea:	601a      	str	r2, [r3, #0]
      p++;
 80002ec:	9b01      	ldr	r3, [sp, #4]
 80002ee:	3304      	adds	r3, #4
 80002f0:	9301      	str	r3, [sp, #4]
      tp++;
 80002f2:	9b02      	ldr	r3, [sp, #8]
 80002f4:	3304      	adds	r3, #4
 80002f6:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 80002f8:	9b03      	ldr	r3, [sp, #12]
 80002fa:	689b      	ldr	r3, [r3, #8]
 80002fc:	9a01      	ldr	r2, [sp, #4]
 80002fe:	429a      	cmp	r2, r3
 8000300:	d3f0      	bcc.n	80002e4 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000302:	e005      	b.n	8000310 <__init_ram_areas+0x40>
      *p = 0;
 8000304:	9b01      	ldr	r3, [sp, #4]
 8000306:	2200      	movs	r2, #0
 8000308:	601a      	str	r2, [r3, #0]
      p++;
 800030a:	9b01      	ldr	r3, [sp, #4]
 800030c:	3304      	adds	r3, #4
 800030e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8000310:	9b03      	ldr	r3, [sp, #12]
 8000312:	68db      	ldr	r3, [r3, #12]
 8000314:	9a01      	ldr	r2, [sp, #4]
 8000316:	429a      	cmp	r2, r3
 8000318:	d3f4      	bcc.n	8000304 <__init_ram_areas+0x34>
    }
    rap++;
 800031a:	9b03      	ldr	r3, [sp, #12]
 800031c:	3310      	adds	r3, #16
 800031e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000320:	9b03      	ldr	r3, [sp, #12]
 8000322:	4a04      	ldr	r2, [pc, #16]	@ (8000334 <__init_ram_areas+0x64>)
 8000324:	4293      	cmp	r3, r2
 8000326:	d3d6      	bcc.n	80002d6 <__init_ram_areas+0x6>
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8000328:	bf00      	nop
 800032a:	bf00      	nop
 800032c:	b004      	add	sp, #16
 800032e:	4770      	bx	lr
 8000330:	080048ac 	.word	0x080048ac
 8000334:	0800492c 	.word	0x0800492c
	...

08000340 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000340:	bf00      	nop
 8000342:	4770      	bx	lr
	...

08000350 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000350:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000352:	f7ff fff5 	bl	8000340 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000356:	f000 fe33 	bl	8000fc0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 800035a:	f001 ff11 	bl	8002180 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800035e:	f000 f907 	bl	8000570 <adcInit>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
 8000362:	f000 fa7d 	bl	8000860 <eflInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 8000366:	f000 facb 	bl	8000900 <gptInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 800036a:	f002 f9e9 	bl	8002740 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800036e:	f000 f83f 	bl	80003f0 <stInit>
#endif
}
 8000372:	bf00      	nop
 8000374:	bd08      	pop	{r3, pc}
 8000376:	bf00      	nop
	...

08000380 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000380:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000384:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
}
 8000386:	4618      	mov	r0, r3
 8000388:	4770      	bx	lr
 800038a:	bf00      	nop
 800038c:	0000      	movs	r0, r0
	...

08000390 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 8000390:	b082      	sub	sp, #8
 8000392:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000394:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000398:	9b01      	ldr	r3, [sp, #4]
 800039a:	6353      	str	r3, [r2, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 800039c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003a0:	2200      	movs	r2, #0
 80003a2:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80003a4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003a8:	2202      	movs	r2, #2
 80003aa:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 80003ac:	bf00      	nop
 80003ae:	b002      	add	sp, #8
 80003b0:	4770      	bx	lr
 80003b2:	bf00      	nop
	...

080003c0 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 80003c0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003c4:	2200      	movs	r2, #0
 80003c6:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 80003c8:	bf00      	nop
 80003ca:	4770      	bx	lr
 80003cc:	0000      	movs	r0, r0
	...

080003d0 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 80003d0:	b082      	sub	sp, #8
 80003d2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003d4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80003d8:	9b01      	ldr	r3, [sp, #4]
 80003da:	6353      	str	r3, [r2, #52]	@ 0x34
}
 80003dc:	bf00      	nop
 80003de:	b002      	add	sp, #8
 80003e0:	4770      	bx	lr
 80003e2:	bf00      	nop
	...

080003f0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80003f0:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 80003f2:	f001 ffdd 	bl	80023b0 <st_lld_init>
}
 80003f6:	bf00      	nop
 80003f8:	bd08      	pop	{r3, pc}
 80003fa:	bf00      	nop
 80003fc:	0000      	movs	r0, r0
	...

08000400 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 8000400:	b508      	push	{r3, lr}

  return st_lld_get_counter();
 8000402:	f7ff ffbd 	bl	8000380 <st_lld_get_counter>
 8000406:	4603      	mov	r3, r0
}
 8000408:	4618      	mov	r0, r3
 800040a:	bd08      	pop	{r3, pc}
 800040c:	0000      	movs	r0, r0
	...

08000410 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000410:	b500      	push	{lr}
 8000412:	b083      	sub	sp, #12
 8000414:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8000416:	9801      	ldr	r0, [sp, #4]
 8000418:	f7ff ffba 	bl	8000390 <st_lld_start_alarm>
}
 800041c:	bf00      	nop
 800041e:	b003      	add	sp, #12
 8000420:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000430 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000430:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8000432:	f7ff ffc5 	bl	80003c0 <st_lld_stop_alarm>
}
 8000436:	bf00      	nop
 8000438:	bd08      	pop	{r3, pc}
 800043a:	bf00      	nop
 800043c:	0000      	movs	r0, r0
	...

08000440 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000440:	b500      	push	{lr}
 8000442:	b083      	sub	sp, #12
 8000444:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8000446:	9801      	ldr	r0, [sp, #4]
 8000448:	f7ff ffc2 	bl	80003d0 <st_lld_set_alarm>
}
 800044c:	bf00      	nop
 800044e:	b003      	add	sp, #12
 8000450:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000460 <flashGetSectorOffset>:
 * @return              Sector offset.
 *
 * @api
 */
flash_offset_t flashGetSectorOffset(BaseFlash *devp,
                                    flash_sector_t sector) {
 8000460:	b500      	push	{lr}
 8000462:	b085      	sub	sp, #20
 8000464:	9001      	str	r0, [sp, #4]
 8000466:	9100      	str	r1, [sp, #0]
  flash_offset_t offset;
  const flash_descriptor_t *descriptor = flashGetDescriptor(devp);
 8000468:	9b01      	ldr	r3, [sp, #4]
 800046a:	681b      	ldr	r3, [r3, #0]
 800046c:	685b      	ldr	r3, [r3, #4]
 800046e:	9801      	ldr	r0, [sp, #4]
 8000470:	4798      	blx	r3
 8000472:	9002      	str	r0, [sp, #8]

  osalDbgAssert(sector < descriptor->sectors_count, "invalid sector");

  if (descriptor->sectors != NULL) {
 8000474:	9b02      	ldr	r3, [sp, #8]
 8000476:	68db      	ldr	r3, [r3, #12]
 8000478:	2b00      	cmp	r3, #0
 800047a:	d007      	beq.n	800048c <flashGetSectorOffset+0x2c>
    offset = descriptor->sectors[sector].offset;
 800047c:	9b02      	ldr	r3, [sp, #8]
 800047e:	68da      	ldr	r2, [r3, #12]
 8000480:	9b00      	ldr	r3, [sp, #0]
 8000482:	00db      	lsls	r3, r3, #3
 8000484:	4413      	add	r3, r2
 8000486:	681b      	ldr	r3, [r3, #0]
 8000488:	9303      	str	r3, [sp, #12]
 800048a:	e005      	b.n	8000498 <flashGetSectorOffset+0x38>
  }
  else {
    offset = (flash_offset_t)sector * (flash_offset_t)descriptor->sectors_size;
 800048c:	9b02      	ldr	r3, [sp, #8]
 800048e:	691a      	ldr	r2, [r3, #16]
 8000490:	9b00      	ldr	r3, [sp, #0]
 8000492:	fb02 f303 	mul.w	r3, r2, r3
 8000496:	9303      	str	r3, [sp, #12]
  }

  return offset;
 8000498:	9b03      	ldr	r3, [sp, #12]
}
 800049a:	4618      	mov	r0, r3
 800049c:	b005      	add	sp, #20
 800049e:	f85d fb04 	ldr.w	pc, [sp], #4
 80004a2:	bf00      	nop
	...

080004b0 <chSysLock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 80004b0:	b500      	push	{lr}
 80004b2:	b083      	sub	sp, #12
 80004b4:	2330      	movs	r3, #48	@ 0x30
 80004b6:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80004b8:	9b01      	ldr	r3, [sp, #4]
 80004ba:	f383 8811 	msr	BASEPRI, r3
}
 80004be:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004c0:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 80004c2:	f002 f9ed 	bl	80028a0 <__dbg_check_lock>
}
 80004c6:	bf00      	nop
 80004c8:	b003      	add	sp, #12
 80004ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80004ce:	bf00      	nop

080004d0 <chSysUnlock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80004d0:	b500      	push	{lr}
 80004d2:	b083      	sub	sp, #12

  __dbg_check_unlock();
 80004d4:	f002 fa0c 	bl	80028f0 <__dbg_check_unlock>
 80004d8:	2300      	movs	r3, #0
 80004da:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80004dc:	9b01      	ldr	r3, [sp, #4]
 80004de:	f383 8811 	msr	BASEPRI, r3
}
 80004e2:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004e4:	bf00      	nop
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 80004e6:	bf00      	nop
 80004e8:	b003      	add	sp, #12
 80004ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80004ee:	bf00      	nop

080004f0 <osalSysLock.lto_priv.2>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80004f0:	b508      	push	{r3, lr}

  chSysLock();
 80004f2:	f7ff ffdd 	bl	80004b0 <chSysLock.lto_priv.2>
}
 80004f6:	bf00      	nop
 80004f8:	bd08      	pop	{r3, pc}
 80004fa:	bf00      	nop
 80004fc:	0000      	movs	r0, r0
	...

08000500 <osalSysUnlock.lto_priv.2>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8000500:	b508      	push	{r3, lr}

  chSysUnlock();
 8000502:	f7ff ffe5 	bl	80004d0 <chSysUnlock.lto_priv.2>
}
 8000506:	bf00      	nop
 8000508:	bd08      	pop	{r3, pc}
 800050a:	bf00      	nop
 800050c:	0000      	movs	r0, r0
	...

08000510 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8000510:	b500      	push	{lr}
 8000512:	b083      	sub	sp, #12
 8000514:	9001      	str	r0, [sp, #4]

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8000516:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 800051a:	9801      	ldr	r0, [sp, #4]
 800051c:	f003 fc60 	bl	8003de0 <chThdSuspendTimeoutS>
 8000520:	4603      	mov	r3, r0
}
 8000522:	4618      	mov	r0, r3
 8000524:	b003      	add	sp, #12
 8000526:	f85d fb04 	ldr.w	pc, [sp], #4
 800052a:	bf00      	nop
 800052c:	0000      	movs	r0, r0
	...

08000530 <osalThreadResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 8000530:	b500      	push	{lr}
 8000532:	b083      	sub	sp, #12
 8000534:	9001      	str	r0, [sp, #4]
 8000536:	9100      	str	r1, [sp, #0]

  chThdResumeS(trp, msg);
 8000538:	9900      	ldr	r1, [sp, #0]
 800053a:	9801      	ldr	r0, [sp, #4]
 800053c:	f003 fc90 	bl	8003e60 <chThdResumeS>
}
 8000540:	bf00      	nop
 8000542:	b003      	add	sp, #12
 8000544:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000550 <osalMutexObjectInit.lto_priv.0>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8000550:	b500      	push	{lr}
 8000552:	b083      	sub	sp, #12
 8000554:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8000556:	9801      	ldr	r0, [sp, #4]
 8000558:	f003 fd9a 	bl	8004090 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800055c:	bf00      	nop
 800055e:	b003      	add	sp, #12
 8000560:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000570 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 8000570:	b508      	push	{r3, lr}

  adc_lld_init();
 8000572:	f001 f9d5 	bl	8001920 <adc_lld_init>
}
 8000576:	bf00      	nop
 8000578:	bd08      	pop	{r3, pc}
 800057a:	bf00      	nop
 800057c:	0000      	movs	r0, r0
	...

08000580 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 8000580:	b500      	push	{lr}
 8000582:	b083      	sub	sp, #12
 8000584:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 8000586:	9b01      	ldr	r3, [sp, #4]
 8000588:	2201      	movs	r2, #1
 800058a:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 800058c:	9b01      	ldr	r3, [sp, #4]
 800058e:	2200      	movs	r2, #0
 8000590:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 8000592:	9b01      	ldr	r3, [sp, #4]
 8000594:	2200      	movs	r2, #0
 8000596:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 8000598:	9b01      	ldr	r3, [sp, #4]
 800059a:	2200      	movs	r2, #0
 800059c:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 800059e:	9b01      	ldr	r3, [sp, #4]
 80005a0:	2200      	movs	r2, #0
 80005a2:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 80005a4:	9b01      	ldr	r3, [sp, #4]
 80005a6:	2200      	movs	r2, #0
 80005a8:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 80005aa:	9b01      	ldr	r3, [sp, #4]
 80005ac:	3318      	adds	r3, #24
 80005ae:	4618      	mov	r0, r3
 80005b0:	f7ff ffce 	bl	8000550 <osalMutexObjectInit.lto_priv.0>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 80005b4:	bf00      	nop
 80005b6:	b003      	add	sp, #12
 80005b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80005bc:	0000      	movs	r0, r0
	...

080005c0 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 80005c0:	b500      	push	{lr}
 80005c2:	b085      	sub	sp, #20
 80005c4:	9001      	str	r0, [sp, #4]
 80005c6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(adcp != NULL);
 80005c8:	9b01      	ldr	r3, [sp, #4]
 80005ca:	2b00      	cmp	r3, #0
 80005cc:	bf0c      	ite	eq
 80005ce:	2301      	moveq	r3, #1
 80005d0:	2300      	movne	r3, #0
 80005d2:	b2db      	uxtb	r3, r3
 80005d4:	2b00      	cmp	r3, #0
 80005d6:	d002      	beq.n	80005de <adcStart+0x1e>
 80005d8:	480e      	ldr	r0, [pc, #56]	@ (8000614 <adcStart+0x54>)
 80005da:	f002 f931 	bl	8002840 <chSysHalt>

  osalSysLock();
 80005de:	f7ff ff87 	bl	80004f0 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 80005e2:	9b01      	ldr	r3, [sp, #4]
 80005e4:	9a00      	ldr	r2, [sp, #0]
 80005e6:	605a      	str	r2, [r3, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
#else
  adc_lld_start(adcp);
 80005e8:	9801      	ldr	r0, [sp, #4]
 80005ea:	f001 f9b1 	bl	8001950 <adc_lld_start>
  msg = HAL_RET_SUCCESS;
 80005ee:	2300      	movs	r3, #0
 80005f0:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 80005f2:	9b03      	ldr	r3, [sp, #12]
 80005f4:	2b00      	cmp	r3, #0
 80005f6:	d103      	bne.n	8000600 <adcStart+0x40>
    adcp->state = ADC_READY;
 80005f8:	9b01      	ldr	r3, [sp, #4]
 80005fa:	2202      	movs	r2, #2
 80005fc:	701a      	strb	r2, [r3, #0]
 80005fe:	e002      	b.n	8000606 <adcStart+0x46>
  }
  else {
    adcp->state = ADC_STOP;
 8000600:	9b01      	ldr	r3, [sp, #4]
 8000602:	2201      	movs	r2, #1
 8000604:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000606:	f7ff ff7b 	bl	8000500 <osalSysUnlock.lto_priv.2>

  return msg;
 800060a:	9b03      	ldr	r3, [sp, #12]
}
 800060c:	4618      	mov	r0, r3
 800060e:	b005      	add	sp, #20
 8000610:	f85d fb04 	ldr.w	pc, [sp], #4
 8000614:	0800492c 	.word	0x0800492c
	...

08000620 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 8000620:	b500      	push	{lr}
 8000622:	b085      	sub	sp, #20
 8000624:	9003      	str	r0, [sp, #12]
 8000626:	9102      	str	r1, [sp, #8]
 8000628:	9201      	str	r2, [sp, #4]
 800062a:	9300      	str	r3, [sp, #0]

  osalSysLock();
 800062c:	f7ff ff60 	bl	80004f0 <osalSysLock.lto_priv.2>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000630:	9b00      	ldr	r3, [sp, #0]
 8000632:	9a01      	ldr	r2, [sp, #4]
 8000634:	9902      	ldr	r1, [sp, #8]
 8000636:	9803      	ldr	r0, [sp, #12]
 8000638:	f000 f80a 	bl	8000650 <adcStartConversionI>
  osalSysUnlock();
 800063c:	f7ff ff60 	bl	8000500 <osalSysUnlock.lto_priv.2>
}
 8000640:	bf00      	nop
 8000642:	b005      	add	sp, #20
 8000644:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000650 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
 8000650:	b500      	push	{lr}
 8000652:	b085      	sub	sp, #20
 8000654:	9003      	str	r0, [sp, #12]
 8000656:	9102      	str	r1, [sp, #8]
 8000658:	9201      	str	r2, [sp, #4]
 800065a:	9300      	str	r3, [sp, #0]

  osalDbgCheckClassI();
 800065c:	f002 fa38 	bl	8002ad0 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
 8000660:	9b03      	ldr	r3, [sp, #12]
 8000662:	2b00      	cmp	r3, #0
 8000664:	bf0c      	ite	eq
 8000666:	2301      	moveq	r3, #1
 8000668:	2300      	movne	r3, #0
 800066a:	b2db      	uxtb	r3, r3
 800066c:	2b00      	cmp	r3, #0
 800066e:	d107      	bne.n	8000680 <adcStartConversionI+0x30>
 8000670:	9b02      	ldr	r3, [sp, #8]
 8000672:	2b00      	cmp	r3, #0
 8000674:	bf0c      	ite	eq
 8000676:	2301      	moveq	r3, #1
 8000678:	2300      	movne	r3, #0
 800067a:	b2db      	uxtb	r3, r3
 800067c:	2b00      	cmp	r3, #0
 800067e:	d001      	beq.n	8000684 <adcStartConversionI+0x34>
 8000680:	2301      	movs	r3, #1
 8000682:	e000      	b.n	8000686 <adcStartConversionI+0x36>
 8000684:	2300      	movs	r3, #0
 8000686:	2b00      	cmp	r3, #0
 8000688:	d107      	bne.n	800069a <adcStartConversionI+0x4a>
 800068a:	9b01      	ldr	r3, [sp, #4]
 800068c:	2b00      	cmp	r3, #0
 800068e:	bf0c      	ite	eq
 8000690:	2301      	moveq	r3, #1
 8000692:	2300      	movne	r3, #0
 8000694:	b2db      	uxtb	r3, r3
 8000696:	2b00      	cmp	r3, #0
 8000698:	d001      	beq.n	800069e <adcStartConversionI+0x4e>
 800069a:	2301      	movs	r3, #1
 800069c:	e000      	b.n	80006a0 <adcStartConversionI+0x50>
 800069e:	2300      	movs	r3, #0
 80006a0:	2b00      	cmp	r3, #0
 80006a2:	d107      	bne.n	80006b4 <adcStartConversionI+0x64>
 80006a4:	9b00      	ldr	r3, [sp, #0]
 80006a6:	2b00      	cmp	r3, #0
 80006a8:	bf0c      	ite	eq
 80006aa:	2301      	moveq	r3, #1
 80006ac:	2300      	movne	r3, #0
 80006ae:	b2db      	uxtb	r3, r3
 80006b0:	2b00      	cmp	r3, #0
 80006b2:	d001      	beq.n	80006b8 <adcStartConversionI+0x68>
 80006b4:	2301      	movs	r3, #1
 80006b6:	e000      	b.n	80006ba <adcStartConversionI+0x6a>
 80006b8:	2300      	movs	r3, #0
 80006ba:	2b00      	cmp	r3, #0
 80006bc:	d111      	bne.n	80006e2 <adcStartConversionI+0x92>
 80006be:	9b00      	ldr	r3, [sp, #0]
 80006c0:	2b01      	cmp	r3, #1
 80006c2:	bf14      	ite	ne
 80006c4:	2301      	movne	r3, #1
 80006c6:	2300      	moveq	r3, #0
 80006c8:	b2db      	uxtb	r3, r3
 80006ca:	2b00      	cmp	r3, #0
 80006cc:	d006      	beq.n	80006dc <adcStartConversionI+0x8c>
 80006ce:	9b00      	ldr	r3, [sp, #0]
 80006d0:	f003 0301 	and.w	r3, r3, #1
 80006d4:	2b00      	cmp	r3, #0
 80006d6:	d001      	beq.n	80006dc <adcStartConversionI+0x8c>
 80006d8:	2301      	movs	r3, #1
 80006da:	e000      	b.n	80006de <adcStartConversionI+0x8e>
 80006dc:	2300      	movs	r3, #0
 80006de:	2b00      	cmp	r3, #0
 80006e0:	d002      	beq.n	80006e8 <adcStartConversionI+0x98>
 80006e2:	480b      	ldr	r0, [pc, #44]	@ (8000710 <adcStartConversionI+0xc0>)
 80006e4:	f002 f8ac 	bl	8002840 <chSysHalt>
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 80006e8:	9b03      	ldr	r3, [sp, #12]
 80006ea:	9a01      	ldr	r2, [sp, #4]
 80006ec:	609a      	str	r2, [r3, #8]
  adcp->depth    = depth;
 80006ee:	9b03      	ldr	r3, [sp, #12]
 80006f0:	9a00      	ldr	r2, [sp, #0]
 80006f2:	60da      	str	r2, [r3, #12]
  adcp->grpp     = grpp;
 80006f4:	9b03      	ldr	r3, [sp, #12]
 80006f6:	9a02      	ldr	r2, [sp, #8]
 80006f8:	611a      	str	r2, [r3, #16]
  adcp->state    = ADC_ACTIVE;
 80006fa:	9b03      	ldr	r3, [sp, #12]
 80006fc:	2203      	movs	r2, #3
 80006fe:	701a      	strb	r2, [r3, #0]
  adc_lld_start_conversion(adcp);
 8000700:	9803      	ldr	r0, [sp, #12]
 8000702:	f001 f98d 	bl	8001a20 <adc_lld_start_conversion>
}
 8000706:	bf00      	nop
 8000708:	b005      	add	sp, #20
 800070a:	f85d fb04 	ldr.w	pc, [sp], #4
 800070e:	bf00      	nop
 8000710:	08004938 	.word	0x08004938
	...

08000720 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
 8000720:	b500      	push	{lr}
 8000722:	b083      	sub	sp, #12
 8000724:	9001      	str	r0, [sp, #4]

  osalDbgCheck(adcp != NULL);
 8000726:	9b01      	ldr	r3, [sp, #4]
 8000728:	2b00      	cmp	r3, #0
 800072a:	bf0c      	ite	eq
 800072c:	2301      	moveq	r3, #1
 800072e:	2300      	movne	r3, #0
 8000730:	b2db      	uxtb	r3, r3
 8000732:	2b00      	cmp	r3, #0
 8000734:	d002      	beq.n	800073c <adcStopConversion+0x1c>
 8000736:	480f      	ldr	r0, [pc, #60]	@ (8000774 <adcStopConversion+0x54>)
 8000738:	f002 f882 	bl	8002840 <chSysHalt>

  osalSysLock();
 800073c:	f7ff fed8 	bl	80004f0 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_READY) || (adcp->state == ADC_ACTIVE),
                "invalid state");
  if (adcp->state != ADC_READY) {
 8000740:	9b01      	ldr	r3, [sp, #4]
 8000742:	781b      	ldrb	r3, [r3, #0]
 8000744:	2b02      	cmp	r3, #2
 8000746:	d00f      	beq.n	8000768 <adcStopConversion+0x48>
    adc_lld_stop_conversion(adcp);
 8000748:	9801      	ldr	r0, [sp, #4]
 800074a:	f001 fa09 	bl	8001b60 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
 800074e:	9b01      	ldr	r3, [sp, #4]
 8000750:	2200      	movs	r2, #0
 8000752:	611a      	str	r2, [r3, #16]
    adcp->state = ADC_READY;
 8000754:	9b01      	ldr	r3, [sp, #4]
 8000756:	2202      	movs	r2, #2
 8000758:	701a      	strb	r2, [r3, #0]
    _adc_reset_s(adcp);
 800075a:	9b01      	ldr	r3, [sp, #4]
 800075c:	3314      	adds	r3, #20
 800075e:	f06f 0101 	mvn.w	r1, #1
 8000762:	4618      	mov	r0, r3
 8000764:	f7ff fee4 	bl	8000530 <osalThreadResumeS>
  }
  osalSysUnlock();
 8000768:	f7ff feca 	bl	8000500 <osalSysUnlock.lto_priv.2>
}
 800076c:	bf00      	nop
 800076e:	b003      	add	sp, #12
 8000770:	f85d fb04 	ldr.w	pc, [sp], #4
 8000774:	0800494c 	.word	0x0800494c
	...

08000780 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8000780:	b500      	push	{lr}
 8000782:	b087      	sub	sp, #28
 8000784:	9003      	str	r0, [sp, #12]
 8000786:	9102      	str	r1, [sp, #8]
 8000788:	9201      	str	r2, [sp, #4]
 800078a:	9300      	str	r3, [sp, #0]
  msg_t msg;

  osalSysLock();
 800078c:	f7ff feb0 	bl	80004f0 <osalSysLock.lto_priv.2>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
  adcStartConversionI(adcp, grpp, samples, depth);
 8000790:	9b00      	ldr	r3, [sp, #0]
 8000792:	9a01      	ldr	r2, [sp, #4]
 8000794:	9902      	ldr	r1, [sp, #8]
 8000796:	9803      	ldr	r0, [sp, #12]
 8000798:	f7ff ff5a 	bl	8000650 <adcStartConversionI>
  msg = osalThreadSuspendS(&adcp->thread);
 800079c:	9b03      	ldr	r3, [sp, #12]
 800079e:	3314      	adds	r3, #20
 80007a0:	4618      	mov	r0, r3
 80007a2:	f7ff feb5 	bl	8000510 <osalThreadSuspendS>
 80007a6:	9005      	str	r0, [sp, #20]
  osalSysUnlock();
 80007a8:	f7ff feaa 	bl	8000500 <osalSysUnlock.lto_priv.2>
  return msg;
 80007ac:	9b05      	ldr	r3, [sp, #20]
}
 80007ae:	4618      	mov	r0, r3
 80007b0:	b007      	add	sp, #28
 80007b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80007b6:	bf00      	nop
	...

080007c0 <osalMutexObjectInit.lto_priv.1>:
static inline void osalMutexObjectInit(mutex_t *mp) {
 80007c0:	b500      	push	{lr}
 80007c2:	b083      	sub	sp, #12
 80007c4:	9001      	str	r0, [sp, #4]
  chMtxObjectInit(mp);
 80007c6:	9801      	ldr	r0, [sp, #4]
 80007c8:	f003 fc62 	bl	8004090 <chMtxObjectInit>
}
 80007cc:	bf00      	nop
 80007ce:	b003      	add	sp, #12
 80007d0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080007e0 <osalMutexLock.lto_priv.1>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 80007e0:	b500      	push	{lr}
 80007e2:	b083      	sub	sp, #12
 80007e4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80007e6:	9801      	ldr	r0, [sp, #4]
 80007e8:	f003 fc72 	bl	80040d0 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 80007ec:	bf00      	nop
 80007ee:	b003      	add	sp, #12
 80007f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000800 <osalMutexUnlock.lto_priv.1>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 8000800:	b500      	push	{lr}
 8000802:	b083      	sub	sp, #12
 8000804:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8000806:	9801      	ldr	r0, [sp, #4]
 8000808:	f003 fcea 	bl	80041e0 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 800080c:	bf00      	nop
 800080e:	b003      	add	sp, #12
 8000810:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000820 <efl_acquire_exclusive>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static flash_error_t efl_acquire_exclusive(void *instance) {
 8000820:	b500      	push	{lr}
 8000822:	b085      	sub	sp, #20
 8000824:	9001      	str	r0, [sp, #4]
#if (EFL_USE_MUTUAL_EXCLUSION == TRUE)
  EFlashDriver *devp = (EFlashDriver *)instance;
 8000826:	9b01      	ldr	r3, [sp, #4]
 8000828:	9303      	str	r3, [sp, #12]

  osalMutexLock(&devp->mutex);
 800082a:	9b03      	ldr	r3, [sp, #12]
 800082c:	330c      	adds	r3, #12
 800082e:	4618      	mov	r0, r3
 8000830:	f7ff ffd6 	bl	80007e0 <osalMutexLock.lto_priv.1>
  return FLASH_NO_ERROR;
 8000834:	2300      	movs	r3, #0
#else
  (void)instance;
  osalDbgAssert(false, "mutual exclusion not enabled");
  return FLASH_ERROR_UNIMPLEMENTED;
#endif
}
 8000836:	4618      	mov	r0, r3
 8000838:	b005      	add	sp, #20
 800083a:	f85d fb04 	ldr.w	pc, [sp], #4
 800083e:	bf00      	nop

08000840 <efl_release_exclusive>:

static flash_error_t efl_release_exclusive(void *instance) {
 8000840:	b500      	push	{lr}
 8000842:	b085      	sub	sp, #20
 8000844:	9001      	str	r0, [sp, #4]
#if (EFL_USE_MUTUAL_EXCLUSION == TRUE)
  EFlashDriver *devp = (EFlashDriver *)instance;
 8000846:	9b01      	ldr	r3, [sp, #4]
 8000848:	9303      	str	r3, [sp, #12]

  osalMutexUnlock(&devp->mutex);
 800084a:	9b03      	ldr	r3, [sp, #12]
 800084c:	330c      	adds	r3, #12
 800084e:	4618      	mov	r0, r3
 8000850:	f7ff ffd6 	bl	8000800 <osalMutexUnlock.lto_priv.1>
  return FLASH_NO_ERROR;
 8000854:	2300      	movs	r3, #0
#else
  (void)instance;
  osalDbgAssert(false, "mutual exclusion not enabled");
  return FLASH_ERROR_UNIMPLEMENTED;
#endif
}
 8000856:	4618      	mov	r0, r3
 8000858:	b005      	add	sp, #20
 800085a:	f85d fb04 	ldr.w	pc, [sp], #4
 800085e:	bf00      	nop

08000860 <eflInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void eflInit(void) {
 8000860:	b508      	push	{r3, lr}

  efl_lld_init();
 8000862:	f000 fcd5 	bl	8001210 <efl_lld_init>
}
 8000866:	bf00      	nop
 8000868:	bd08      	pop	{r3, pc}
 800086a:	bf00      	nop
 800086c:	0000      	movs	r0, r0
	...

08000870 <eflObjectInit>:
 *
 * @param[out] eflp     pointer to a @p EFlashDriver structure
 *
 * @init
 */
void eflObjectInit(EFlashDriver *eflp) {
 8000870:	b500      	push	{lr}
 8000872:	b083      	sub	sp, #12
 8000874:	9001      	str	r0, [sp, #4]

  eflp->vmt = &vmt;
 8000876:	9b01      	ldr	r3, [sp, #4]
 8000878:	4a06      	ldr	r2, [pc, #24]	@ (8000894 <eflObjectInit+0x24>)
 800087a:	601a      	str	r2, [r3, #0]
  eflp->state = FLASH_STOP;
 800087c:	9b01      	ldr	r3, [sp, #4]
 800087e:	2201      	movs	r2, #1
 8000880:	711a      	strb	r2, [r3, #4]
#if EFL_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&eflp->mutex);
 8000882:	9b01      	ldr	r3, [sp, #4]
 8000884:	330c      	adds	r3, #12
 8000886:	4618      	mov	r0, r3
 8000888:	f7ff ff9a 	bl	80007c0 <osalMutexObjectInit.lto_priv.1>
#endif
}
 800088c:	bf00      	nop
 800088e:	b003      	add	sp, #12
 8000890:	f85d fb04 	ldr.w	pc, [sp], #4
 8000894:	08004960 	.word	0x08004960
	...

080008a0 <chSysLock.lto_priv.4>:
static inline void chSysLock(void) {
 80008a0:	b500      	push	{lr}
 80008a2:	b083      	sub	sp, #12
 80008a4:	2330      	movs	r3, #48	@ 0x30
 80008a6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80008a8:	9b01      	ldr	r3, [sp, #4]
 80008aa:	f383 8811 	msr	BASEPRI, r3
}
 80008ae:	bf00      	nop
}
 80008b0:	bf00      	nop
  __dbg_check_lock();
 80008b2:	f001 fff5 	bl	80028a0 <__dbg_check_lock>
}
 80008b6:	bf00      	nop
 80008b8:	b003      	add	sp, #12
 80008ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80008be:	bf00      	nop

080008c0 <chSysUnlock.lto_priv.4>:
static inline void chSysUnlock(void) {
 80008c0:	b500      	push	{lr}
 80008c2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80008c4:	f002 f814 	bl	80028f0 <__dbg_check_unlock>
 80008c8:	2300      	movs	r3, #0
 80008ca:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80008cc:	9b01      	ldr	r3, [sp, #4]
 80008ce:	f383 8811 	msr	BASEPRI, r3
}
 80008d2:	bf00      	nop
}
 80008d4:	bf00      	nop
}
 80008d6:	bf00      	nop
 80008d8:	b003      	add	sp, #12
 80008da:	f85d fb04 	ldr.w	pc, [sp], #4
 80008de:	bf00      	nop

080008e0 <osalSysLock.lto_priv.4>:
static inline void osalSysLock(void) {
 80008e0:	b508      	push	{r3, lr}
  chSysLock();
 80008e2:	f7ff ffdd 	bl	80008a0 <chSysLock.lto_priv.4>
}
 80008e6:	bf00      	nop
 80008e8:	bd08      	pop	{r3, pc}
 80008ea:	bf00      	nop
 80008ec:	0000      	movs	r0, r0
	...

080008f0 <osalSysUnlock.lto_priv.4>:
static inline void osalSysUnlock(void) {
 80008f0:	b508      	push	{r3, lr}
  chSysUnlock();
 80008f2:	f7ff ffe5 	bl	80008c0 <chSysUnlock.lto_priv.4>
}
 80008f6:	bf00      	nop
 80008f8:	bd08      	pop	{r3, pc}
 80008fa:	bf00      	nop
 80008fc:	0000      	movs	r0, r0
	...

08000900 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8000900:	b508      	push	{r3, lr}

  gpt_lld_init();
 8000902:	f001 fdbd 	bl	8002480 <gpt_lld_init>
}
 8000906:	bf00      	nop
 8000908:	bd08      	pop	{r3, pc}
 800090a:	bf00      	nop
 800090c:	0000      	movs	r0, r0
	...

08000910 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8000910:	b082      	sub	sp, #8
 8000912:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 8000914:	9b01      	ldr	r3, [sp, #4]
 8000916:	2201      	movs	r2, #1
 8000918:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 800091a:	9b01      	ldr	r3, [sp, #4]
 800091c:	2200      	movs	r2, #0
 800091e:	605a      	str	r2, [r3, #4]
}
 8000920:	bf00      	nop
 8000922:	b002      	add	sp, #8
 8000924:	4770      	bx	lr
 8000926:	bf00      	nop
	...

08000930 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8000930:	b500      	push	{lr}
 8000932:	b085      	sub	sp, #20
 8000934:	9001      	str	r0, [sp, #4]
 8000936:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 8000938:	9b01      	ldr	r3, [sp, #4]
 800093a:	2b00      	cmp	r3, #0
 800093c:	bf0c      	ite	eq
 800093e:	2301      	moveq	r3, #1
 8000940:	2300      	movne	r3, #0
 8000942:	b2db      	uxtb	r3, r3
 8000944:	2b00      	cmp	r3, #0
 8000946:	d107      	bne.n	8000958 <gptStart+0x28>
 8000948:	9b00      	ldr	r3, [sp, #0]
 800094a:	2b00      	cmp	r3, #0
 800094c:	bf0c      	ite	eq
 800094e:	2301      	moveq	r3, #1
 8000950:	2300      	movne	r3, #0
 8000952:	b2db      	uxtb	r3, r3
 8000954:	2b00      	cmp	r3, #0
 8000956:	d002      	beq.n	800095e <gptStart+0x2e>
 8000958:	480e      	ldr	r0, [pc, #56]	@ (8000994 <gptStart+0x64>)
 800095a:	f001 ff71 	bl	8002840 <chSysHalt>

  osalSysLock();
 800095e:	f7ff ffbf 	bl	80008e0 <osalSysLock.lto_priv.4>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");

  gptp->config = config;
 8000962:	9b01      	ldr	r3, [sp, #4]
 8000964:	9a00      	ldr	r2, [sp, #0]
 8000966:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 8000968:	9801      	ldr	r0, [sp, #4]
 800096a:	f001 fd99 	bl	80024a0 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 800096e:	2300      	movs	r3, #0
 8000970:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 8000972:	9b03      	ldr	r3, [sp, #12]
 8000974:	2b00      	cmp	r3, #0
 8000976:	d103      	bne.n	8000980 <gptStart+0x50>
    gptp->state = GPT_READY;
 8000978:	9b01      	ldr	r3, [sp, #4]
 800097a:	2202      	movs	r2, #2
 800097c:	701a      	strb	r2, [r3, #0]
 800097e:	e002      	b.n	8000986 <gptStart+0x56>
  }
  else {
    gptp->state = GPT_STOP;
 8000980:	9b01      	ldr	r3, [sp, #4]
 8000982:	2201      	movs	r2, #1
 8000984:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000986:	f7ff ffb3 	bl	80008f0 <osalSysUnlock.lto_priv.4>

  return msg;
 800098a:	9b03      	ldr	r3, [sp, #12]
}
 800098c:	4618      	mov	r0, r3
 800098e:	b005      	add	sp, #20
 8000990:	f85d fb04 	ldr.w	pc, [sp], #4
 8000994:	08004988 	.word	0x08004988
	...

080009a0 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 80009a0:	b500      	push	{lr}
 80009a2:	b083      	sub	sp, #12
 80009a4:	9001      	str	r0, [sp, #4]
 80009a6:	9100      	str	r1, [sp, #0]

  osalSysLock();
 80009a8:	f7ff ff9a 	bl	80008e0 <osalSysLock.lto_priv.4>
  gptStartContinuousI(gptp, interval);
 80009ac:	9900      	ldr	r1, [sp, #0]
 80009ae:	9801      	ldr	r0, [sp, #4]
 80009b0:	f000 f806 	bl	80009c0 <gptStartContinuousI>
  osalSysUnlock();
 80009b4:	f7ff ff9c 	bl	80008f0 <osalSysUnlock.lto_priv.4>
}
 80009b8:	bf00      	nop
 80009ba:	b003      	add	sp, #12
 80009bc:	f85d fb04 	ldr.w	pc, [sp], #4

080009c0 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 80009c0:	b500      	push	{lr}
 80009c2:	b083      	sub	sp, #12
 80009c4:	9001      	str	r0, [sp, #4]
 80009c6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 80009c8:	f002 f882 	bl	8002ad0 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 80009cc:	9b01      	ldr	r3, [sp, #4]
 80009ce:	2b00      	cmp	r3, #0
 80009d0:	bf0c      	ite	eq
 80009d2:	2301      	moveq	r3, #1
 80009d4:	2300      	movne	r3, #0
 80009d6:	b2db      	uxtb	r3, r3
 80009d8:	2b00      	cmp	r3, #0
 80009da:	d002      	beq.n	80009e2 <gptStartContinuousI+0x22>
 80009dc:	4806      	ldr	r0, [pc, #24]	@ (80009f8 <gptStartContinuousI+0x38>)
 80009de:	f001 ff2f 	bl	8002840 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 80009e2:	9b01      	ldr	r3, [sp, #4]
 80009e4:	2203      	movs	r2, #3
 80009e6:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 80009e8:	9900      	ldr	r1, [sp, #0]
 80009ea:	9801      	ldr	r0, [sp, #4]
 80009ec:	f001 fdc0 	bl	8002570 <gpt_lld_start_timer>
}
 80009f0:	bf00      	nop
 80009f2:	b003      	add	sp, #12
 80009f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80009f8:	08004994 	.word	0x08004994
 80009fc:	00000000 	.word	0x00000000

08000a00 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000a00:	b500      	push	{lr}
 8000a02:	b083      	sub	sp, #12
 8000a04:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8000a06:	f7ff ff6b 	bl	80008e0 <osalSysLock.lto_priv.4>
  gptStopTimerI(gptp);
 8000a0a:	9801      	ldr	r0, [sp, #4]
 8000a0c:	f000 f808 	bl	8000a20 <gptStopTimerI>
  osalSysUnlock();
 8000a10:	f7ff ff6e 	bl	80008f0 <osalSysUnlock.lto_priv.4>
}
 8000a14:	bf00      	nop
 8000a16:	b003      	add	sp, #12
 8000a18:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a1c:	0000      	movs	r0, r0
	...

08000a20 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000a20:	b500      	push	{lr}
 8000a22:	b083      	sub	sp, #12
 8000a24:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8000a26:	f002 f853 	bl	8002ad0 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000a2a:	9b01      	ldr	r3, [sp, #4]
 8000a2c:	2b00      	cmp	r3, #0
 8000a2e:	bf0c      	ite	eq
 8000a30:	2301      	moveq	r3, #1
 8000a32:	2300      	movne	r3, #0
 8000a34:	b2db      	uxtb	r3, r3
 8000a36:	2b00      	cmp	r3, #0
 8000a38:	d002      	beq.n	8000a40 <gptStopTimerI+0x20>
 8000a3a:	4806      	ldr	r0, [pc, #24]	@ (8000a54 <gptStopTimerI+0x34>)
 8000a3c:	f001 ff00 	bl	8002840 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000a40:	9b01      	ldr	r3, [sp, #4]
 8000a42:	2202      	movs	r2, #2
 8000a44:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000a46:	9801      	ldr	r0, [sp, #4]
 8000a48:	f001 fdba 	bl	80025c0 <gpt_lld_stop_timer>
}
 8000a4c:	bf00      	nop
 8000a4e:	b003      	add	sp, #12
 8000a50:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a54:	080049a8 	.word	0x080049a8
	...

08000a60 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000a60:	b082      	sub	sp, #8
 8000a62:	9001      	str	r0, [sp, #4]
 8000a64:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8000a66:	9b00      	ldr	r3, [sp, #0]
 8000a68:	b2db      	uxtb	r3, r3
 8000a6a:	4a11      	ldr	r2, [pc, #68]	@ (8000ab0 <nvicEnableVector+0x50>)
 8000a6c:	011b      	lsls	r3, r3, #4
 8000a6e:	b2d9      	uxtb	r1, r3
 8000a70:	9b01      	ldr	r3, [sp, #4]
 8000a72:	4413      	add	r3, r2
 8000a74:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8000a78:	460a      	mov	r2, r1
 8000a7a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000a7c:	9b01      	ldr	r3, [sp, #4]
 8000a7e:	f003 021f 	and.w	r2, r3, #31
 8000a82:	490b      	ldr	r1, [pc, #44]	@ (8000ab0 <nvicEnableVector+0x50>)
 8000a84:	9b01      	ldr	r3, [sp, #4]
 8000a86:	095b      	lsrs	r3, r3, #5
 8000a88:	2001      	movs	r0, #1
 8000a8a:	fa00 f202 	lsl.w	r2, r0, r2
 8000a8e:	3360      	adds	r3, #96	@ 0x60
 8000a90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000a94:	9b01      	ldr	r3, [sp, #4]
 8000a96:	f003 021f 	and.w	r2, r3, #31
 8000a9a:	4905      	ldr	r1, [pc, #20]	@ (8000ab0 <nvicEnableVector+0x50>)
 8000a9c:	9b01      	ldr	r3, [sp, #4]
 8000a9e:	095b      	lsrs	r3, r3, #5
 8000aa0:	2001      	movs	r0, #1
 8000aa2:	fa00 f202 	lsl.w	r2, r0, r2
 8000aa6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000aaa:	bf00      	nop
 8000aac:	b002      	add	sp, #8
 8000aae:	4770      	bx	lr
 8000ab0:	e000e100 	.word	0xe000e100
	...

08000ac0 <exti0_irq_init>:

static inline void exti0_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
 8000ac0:	bf00      	nop
 8000ac2:	4770      	bx	lr
	...

08000ad0 <exti1_irq_init>:

static inline void exti1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
 8000ad0:	bf00      	nop
 8000ad2:	4770      	bx	lr
	...

08000ae0 <exti2_irq_init>:

static inline void exti2_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
 8000ae0:	bf00      	nop
 8000ae2:	4770      	bx	lr
	...

08000af0 <exti3_irq_init>:

static inline void exti3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
 8000af0:	bf00      	nop
 8000af2:	4770      	bx	lr
	...

08000b00 <exti4_irq_init>:

static inline void exti4_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
 8000b00:	bf00      	nop
 8000b02:	4770      	bx	lr
	...

08000b10 <exti5_9_irq_init>:

static inline void exti5_9_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
 8000b10:	bf00      	nop
 8000b12:	4770      	bx	lr
	...

08000b20 <exti10_15_irq_init>:

static inline void exti10_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
 8000b20:	bf00      	nop
 8000b22:	4770      	bx	lr
	...

08000b30 <exti16_exti34_irq_init>:

static inline void exti16_exti34_irq_init(void) {
#if defined(STM32_EXTI16_IS_USED) || defined(STM32_EXTI34_IS_USED)
  nvicEnableVector(STM32_EXTI16_34_NUMBER, STM32_IRQ_EXTI16_34_PRIORITY);
#endif
}
 8000b30:	bf00      	nop
 8000b32:	4770      	bx	lr
	...

08000b40 <exti45_irq_init>:

static inline void exti45_irq_init(void) {
#if defined(STM32_EXTI45_IS_USED)
  nvicEnableVector(STM32_EXTI45_NUMBER, STM32_IRQ_EXTI45_PRIORITY);
#endif
}
 8000b40:	bf00      	nop
 8000b42:	4770      	bx	lr
	...

08000b50 <tim1_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim1_irq_init(void) {
 8000b50:	b508      	push	{r3, lr}
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_IRQ_TIM1_UP_PRIORITY);
 8000b52:	2107      	movs	r1, #7
 8000b54:	2018      	movs	r0, #24
 8000b56:	f7ff ff83 	bl	8000a60 <nvicEnableVector>
  nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_IRQ_TIM1_CC_PRIORITY);
 8000b5a:	2107      	movs	r1, #7
 8000b5c:	201a      	movs	r0, #26
 8000b5e:	f7ff ff7f 	bl	8000a60 <nvicEnableVector>
#endif
}
 8000b62:	bf00      	nop
 8000b64:	bd08      	pop	{r3, pc}
 8000b66:	bf00      	nop
	...

08000b70 <VectorA0>:
/**
 * @brief   TIM1-UP interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8000b70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000b72:	f001 ff35 	bl	80029e0 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM1
  gpt_lld_serve_interrupt(&GPTD1);
 8000b76:	4804      	ldr	r0, [pc, #16]	@ (8000b88 <VectorA0+0x18>)
 8000b78:	f001 fd3a 	bl	80025f0 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM1
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000b7c:	f001 ff68 	bl	8002a50 <__dbg_check_leave_isr>
 8000b80:	f003 fd86 	bl	8004690 <__port_irq_epilogue>
}
 8000b84:	bf00      	nop
 8000b86:	bd08      	pop	{r3, pc}
 8000b88:	200008cc 	.word	0x200008cc
 8000b8c:	00000000 	.word	0x00000000

08000b90 <VectorA8>:
/**
 * @brief   TIM1-CC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 8000b90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000b92:	f001 ff25 	bl	80029e0 <__dbg_check_enter_isr>
#endif
#if 1
  /* Not used by ST.*/
#endif

  OSAL_IRQ_EPILOGUE();
 8000b96:	f001 ff5b 	bl	8002a50 <__dbg_check_leave_isr>
 8000b9a:	f003 fd79 	bl	8004690 <__port_irq_epilogue>
}
 8000b9e:	bf00      	nop
 8000ba0:	bd08      	pop	{r3, pc}
 8000ba2:	bf00      	nop
	...

08000bb0 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000bb0:	bf00      	nop
 8000bb2:	4770      	bx	lr
	...

08000bc0 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000bc0:	bf00      	nop
 8000bc2:	4770      	bx	lr
	...

08000bd0 <lpuart1_irq_init>:

static inline void lpuart1_irq_init(void) {
#if defined(STM32_LPUART1_IS_USED)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_IRQ_LPUART1_PRIORITY);
#endif
}
 8000bd0:	bf00      	nop
 8000bd2:	4770      	bx	lr
	...

08000be0 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8000be0:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8000be2:	2107      	movs	r1, #7
 8000be4:	201b      	movs	r0, #27
 8000be6:	f7ff ff3b 	bl	8000a60 <nvicEnableVector>
#endif
}
 8000bea:	bf00      	nop
 8000bec:	bd08      	pop	{r3, pc}
 8000bee:	bf00      	nop

08000bf0 <VectorAC>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000bf0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000bf2:	f001 fef5 	bl	80029e0 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000bf6:	f001 fc1b 	bl	8002430 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000bfa:	f001 ff29 	bl	8002a50 <__dbg_check_leave_isr>
 8000bfe:	f003 fd47 	bl	8004690 <__port_irq_epilogue>
}
 8000c02:	bf00      	nop
 8000c04:	bd08      	pop	{r3, pc}
 8000c06:	bf00      	nop
	...

08000c10 <tim16_irq_init>:

static inline void tim16_irq_init(void) {
#if defined(STM32_TIM16_IS_USED)
  nvicEnableVector(STM32_TIM16_NUMBER, STM32_IRQ_TIM16_PRIORITY);
#endif
}
 8000c10:	bf00      	nop
 8000c12:	4770      	bx	lr
	...

08000c20 <tim17_irq_init>:

static inline void tim17_irq_init(void) {
#if defined(STM32_TIM17_IS_USED)
  nvicEnableVector(STM32_TIM17_NUMBER, STM32_IRQ_TIM17_PRIORITY);
#endif
}
 8000c20:	bf00      	nop
 8000c22:	4770      	bx	lr
	...

08000c30 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000c30:	b508      	push	{r3, lr}

#if STM32_TARGET_CORE == 1
  exti0_irq_init();
 8000c32:	f7ff ff45 	bl	8000ac0 <exti0_irq_init>
  exti1_irq_init();
 8000c36:	f7ff ff4b 	bl	8000ad0 <exti1_irq_init>
  exti2_irq_init();
 8000c3a:	f7ff ff51 	bl	8000ae0 <exti2_irq_init>
  exti3_irq_init();
 8000c3e:	f7ff ff57 	bl	8000af0 <exti3_irq_init>
  exti4_irq_init();
 8000c42:	f7ff ff5d 	bl	8000b00 <exti4_irq_init>
  exti5_9_irq_init();
 8000c46:	f7ff ff63 	bl	8000b10 <exti5_9_irq_init>
  exti10_15_irq_init();
 8000c4a:	f7ff ff69 	bl	8000b20 <exti10_15_irq_init>
  exti16_exti34_irq_init();
 8000c4e:	f7ff ff6f 	bl	8000b30 <exti16_exti34_irq_init>
  exti45_irq_init();
 8000c52:	f7ff ff75 	bl	8000b40 <exti45_irq_init>
  exti4_15_irq_init();
  exti16_exti34_irq_init();
  exti45_irq_init();
#endif /* STM32_TARGET_CORE == 1 */

  tim1_irq_init();
 8000c56:	f7ff ff7b 	bl	8000b50 <tim1_irq_init>
  tim2_irq_init();
 8000c5a:	f7ff ffc1 	bl	8000be0 <tim2_irq_init>
  tim16_irq_init();
 8000c5e:	f7ff ffd7 	bl	8000c10 <tim16_irq_init>
  tim17_irq_init();
 8000c62:	f7ff ffdd 	bl	8000c20 <tim17_irq_init>

  usart1_irq_init();
 8000c66:	f7ff ffa3 	bl	8000bb0 <usart1_irq_init>
  usart2_irq_init();
 8000c6a:	f7ff ffa9 	bl	8000bc0 <usart2_irq_init>
  lpuart1_irq_init();
 8000c6e:	f7ff ffaf 	bl	8000bd0 <lpuart1_irq_init>
}
 8000c72:	bf00      	nop
 8000c74:	bd08      	pop	{r3, pc}
 8000c76:	bf00      	nop
	...

08000c80 <bd_init>:
/*===========================================================================*/

/**
 * @brief   Initializes the backup domain.
 */
__STATIC_INLINE void bd_init(void) {
 8000c80:	b082      	sub	sp, #8
  uint32_t bdcr;

  /* Current settings.*/
  bdcr = RCC->BDCR;
 8000c82:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000c86:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000c8a:	9301      	str	r3, [sp, #4]
    bdcr |= RCC_BDCR_RTCEN;
  }
#endif

  /* Selectors.*/
  bdcr &= ~(STM32_RTCSEL_MASK | STM32_LSCOSEL_MASK);
 8000c8c:	9b01      	ldr	r3, [sp, #4]
 8000c8e:	f023 2303 	bic.w	r3, r3, #50332416	@ 0x3000300
 8000c92:	9301      	str	r3, [sp, #4]
  bdcr |= STM32_RTCSEL | STM32_LSCOSEL;
 8000c94:	9b01      	ldr	r3, [sp, #4]
 8000c96:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000c9a:	9301      	str	r3, [sp, #4]

  /* Final settings.*/
  RCC->BDCR = bdcr;
 8000c9c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000ca0:	9b01      	ldr	r3, [sp, #4]
 8000ca2:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
}
 8000ca6:	bf00      	nop
 8000ca8:	b002      	add	sp, #8
 8000caa:	4770      	bx	lr
 8000cac:	0000      	movs	r0, r0
	...

08000cb0 <bd_reset>:
 *          of the whole BKP domain.
 */
__STATIC_INLINE void bd_reset(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8000cb0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000cb4:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000cb8:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8000cbc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8000cc0:	d00a      	beq.n	8000cd8 <bd_reset+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000cc2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000cc6:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8000cca:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    RCC->BDCR = 0U;
 8000cce:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000cd2:	2200      	movs	r2, #0
 8000cd4:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  }
}
 8000cd8:	bf00      	nop
 8000cda:	4770      	bx	lr
 8000cdc:	0000      	movs	r0, r0
	...

08000ce0 <lse_init>:
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN;
 8000ce0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000ce4:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8000ce8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000cec:	f043 0391 	orr.w	r3, r3, #145	@ 0x91
 8000cf0:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  while ((RCC->BDCR & (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) !=
 8000cf4:	bf00      	nop
 8000cf6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000cfa:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8000cfe:	f640 0302 	movw	r3, #2050	@ 0x802
 8000d02:	4013      	ands	r3, r2
 8000d04:	f640 0202 	movw	r2, #2050	@ 0x802
 8000d08:	4293      	cmp	r3, r2
 8000d0a:	d1f4      	bne.n	8000cf6 <lse_init+0x16>
         (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) {
  }
#endif
#endif
}
 8000d0c:	bf00      	nop
 8000d0e:	bf00      	nop
 8000d10:	4770      	bx	lr
 8000d12:	bf00      	nop
	...

08000d20 <lsi_init>:
  /* LSI activation.*/
  RCC->CSR |= STM32_LSIPRE | RCC_CSR_LSION;
  while ((RCC->BDCR & RCC_CSR_LSIRDY) == 0U) {
  }
#endif
}
 8000d20:	bf00      	nop
 8000d22:	4770      	bx	lr
	...

08000d30 <msi_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void msi_enable(void) {

  RCC->CR |= RCC_CR_MSION;
 8000d30:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000d34:	681b      	ldr	r3, [r3, #0]
 8000d36:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000d3a:	f043 0301 	orr.w	r3, r3, #1
 8000d3e:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000d40:	bf00      	nop
 8000d42:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000d46:	681b      	ldr	r3, [r3, #0]
 8000d48:	f003 0302 	and.w	r3, r3, #2
 8000d4c:	2b00      	cmp	r3, #0
 8000d4e:	d0f8      	beq.n	8000d42 <msi_enable+0x12>
    /* Wait until MSI is stable.*/
  }
}
 8000d50:	bf00      	nop
 8000d52:	bf00      	nop
 8000d54:	4770      	bx	lr
 8000d56:	bf00      	nop
	...

08000d60 <msi_reset>:
__STATIC_INLINE void msi_disable(void) {

  RCC->CR &= ~RCC_CR_MSION;
}

__STATIC_INLINE void msi_reset(void) {
 8000d60:	b508      	push	{r3, lr}

  /* Resetting MSI defaults.
     Note from RM0432: MSIRANGE can be modified when MSI is OFF (MSION=0)
     or when MSI is ready (MSIRDY=1). MSIRANGE must NOT be modified when
     MSI is ON and NOT ready (MSION=1 and MSIRDY=0).*/
  RCC->CR = (RCC->CR & ~RCC_CR_MSIRANGE_Msk) | RCC_CR_MSIRANGE_6;
 8000d62:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000d66:	681b      	ldr	r3, [r3, #0]
 8000d68:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8000d6c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000d70:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 8000d74:	6013      	str	r3, [r2, #0]

  /* Making sure MSI is active and ready.*/
  msi_enable();
 8000d76:	f7ff ffdb 	bl	8000d30 <msi_enable>

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = RCC_CFGR_SW_MSI;
 8000d7a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000d7e:	2200      	movs	r2, #0
 8000d80:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI) {
 8000d82:	bf00      	nop
 8000d84:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000d88:	689b      	ldr	r3, [r3, #8]
 8000d8a:	f003 030c 	and.w	r3, r3, #12
 8000d8e:	2b00      	cmp	r3, #0
 8000d90:	d1f8      	bne.n	8000d84 <msi_reset+0x24>
    /* Wait until MSI is selected.*/
  }
}
 8000d92:	bf00      	nop
 8000d94:	bf00      	nop
 8000d96:	bd08      	pop	{r3, pc}
	...

08000da0 <msi_init>:

__STATIC_INLINE void msi_init(void) {
 8000da0:	b082      	sub	sp, #8
     Trim fields are not altered from reset values.*/

  /* MSIRANGE can be set only when MSI is OFF or READY, it is ready after
     reset.*/
#if STM32_MSIPLL_ENABLED
  cr = STM32_MSIRANGE | RCC_CR_MSIPLLEN | RCC_CR_MSION;
 8000da2:	2365      	movs	r3, #101	@ 0x65
 8000da4:	9301      	str	r3, [sp, #4]
#else
  cr = STM32_MSIRANGE | RCC_CR_MSION;
#endif
  RCC->CR = cr;
 8000da6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000daa:	9b01      	ldr	r3, [sp, #4]
 8000dac:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000dae:	bf00      	nop
 8000db0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000db4:	681b      	ldr	r3, [r3, #0]
 8000db6:	f003 0302 	and.w	r3, r3, #2
 8000dba:	2b00      	cmp	r3, #0
 8000dbc:	d0f8      	beq.n	8000db0 <msi_init+0x10>
    /* Wait until MSI is stable.*/
  }

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0U;
 8000dbe:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000dc2:	2200      	movs	r2, #0
 8000dc4:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8000dc6:	bf00      	nop
 8000dc8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000dcc:	689b      	ldr	r3, [r3, #8]
 8000dce:	f003 030c 	and.w	r3, r3, #12
 8000dd2:	2b00      	cmp	r3, #0
 8000dd4:	d1f8      	bne.n	8000dc8 <msi_init+0x28>
    ;                                       /* Wait until MSI is selected.  */

  /* Updating MSISRANGE value. MSISRANGE can be set only when MSIRGSEL is high.
     This range is used exiting the Standby mode until MSIRGSEL is set.*/
  cr      |= RCC_CR_MSIRGSEL;
 8000dd6:	9b01      	ldr	r3, [sp, #4]
 8000dd8:	f043 0308 	orr.w	r3, r3, #8
 8000ddc:	9301      	str	r3, [sp, #4]
  RCC->CR  = cr;
 8000dde:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000de2:	9b01      	ldr	r3, [sp, #4]
 8000de4:	6013      	str	r3, [r2, #0]

  csr      = RCC->CSR;
 8000de6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000dea:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8000dee:	9300      	str	r3, [sp, #0]
  csr     &= ~STM32_MSISRANGE_MASK;
 8000df0:	9b00      	ldr	r3, [sp, #0]
 8000df2:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8000df6:	9300      	str	r3, [sp, #0]
  csr     |= STM32_MSISRANGE;
 8000df8:	9b00      	ldr	r3, [sp, #0]
 8000dfa:	f443 63c0 	orr.w	r3, r3, #1536	@ 0x600
 8000dfe:	9300      	str	r3, [sp, #0]
  RCC->CSR = csr;
 8000e00:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000e04:	9b00      	ldr	r3, [sp, #0]
 8000e06:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
}
 8000e0a:	bf00      	nop
 8000e0c:	b002      	add	sp, #8
 8000e0e:	4770      	bx	lr

08000e10 <hsi16_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void hsi16_enable(void) {

  RCC->CR |= RCC_CR_HSION;
 8000e10:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000e14:	681b      	ldr	r3, [r3, #0]
 8000e16:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000e1a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000e1e:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0U) {
 8000e20:	bf00      	nop
 8000e22:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000e26:	681b      	ldr	r3, [r3, #0]
 8000e28:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8000e2c:	2b00      	cmp	r3, #0
 8000e2e:	d0f8      	beq.n	8000e22 <hsi16_enable+0x12>
    /* Waiting for HSI16 activation.*/
  }
}
 8000e30:	bf00      	nop
 8000e32:	bf00      	nop
 8000e34:	4770      	bx	lr
 8000e36:	bf00      	nop
	...

08000e40 <hsi16_init>:
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI) {
    /* Wait until HSI is selected.*/
  }
}

__STATIC_INLINE void hsi16_init(void) {
 8000e40:	b508      	push	{r3, lr}

#if STM32_HSI16_ENABLED
  /* HSI activation.*/
  hsi16_enable();
 8000e42:	f7ff ffe5 	bl	8000e10 <hsi16_enable>
#endif
}
 8000e46:	bf00      	nop
 8000e48:	bd08      	pop	{r3, pc}
 8000e4a:	bf00      	nop
 8000e4c:	0000      	movs	r0, r0
	...

08000e50 <hse32_enable>:
/*===========================================================================*/

__STATIC_INLINE void hse32_enable(void) {

  /* Set HSE32 SYSCLK prescaler.*/
  RCC->CR |= STM32_HSE32PRE;
 8000e50:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000e54:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000e58:	681b      	ldr	r3, [r3, #0]
 8000e5a:	6013      	str	r3, [r2, #0]

  /* HSE32 activation.*/
  RCC->CR |= RCC_CR_HSEON;
 8000e5c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000e60:	681b      	ldr	r3, [r3, #0]
 8000e62:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000e66:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8000e6a:	6013      	str	r3, [r2, #0]

  while ((RCC->CR & RCC_CR_HSERDY) == 0U) {
 8000e6c:	bf00      	nop
 8000e6e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000e72:	681b      	ldr	r3, [r3, #0]
 8000e74:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8000e78:	2b00      	cmp	r3, #0
 8000e7a:	d0f8      	beq.n	8000e6e <hse32_enable+0x1e>
    /* Wait until HSE32 is stable.    */
  }
}
 8000e7c:	bf00      	nop
 8000e7e:	bf00      	nop
 8000e80:	4770      	bx	lr
 8000e82:	bf00      	nop
	...

08000e90 <hse32_init>:

__STATIC_INLINE void hse32_init(void) {
 8000e90:	b508      	push	{r3, lr}

#if STM32_HSE32_ENABLED
  hse32_enable();
 8000e92:	f7ff ffdd 	bl	8000e50 <hse32_enable>
#endif
}
 8000e96:	bf00      	nop
 8000e98:	bd08      	pop	{r3, pc}
 8000e9a:	bf00      	nop
 8000e9c:	0000      	movs	r0, r0
	...

08000ea0 <pll_not_locked>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE bool pll_not_locked(void) {

  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8000ea0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000ea4:	681b      	ldr	r3, [r3, #0]
 8000ea6:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8000eaa:	2b00      	cmp	r3, #0
 8000eac:	bf0c      	ite	eq
 8000eae:	2301      	moveq	r3, #1
 8000eb0:	2300      	movne	r3, #0
 8000eb2:	b2db      	uxtb	r3, r3
}
 8000eb4:	4618      	mov	r0, r3
 8000eb6:	4770      	bx	lr
	...

08000ec0 <pll_wait_lock>:

__STATIC_INLINE void pll_wait_lock(void) {
 8000ec0:	b508      	push	{r3, lr}

  while (pll_not_locked()) {
 8000ec2:	bf00      	nop
 8000ec4:	f7ff ffec 	bl	8000ea0 <pll_not_locked>
 8000ec8:	4603      	mov	r3, r0
 8000eca:	2b00      	cmp	r3, #0
 8000ecc:	d1fa      	bne.n	8000ec4 <pll_wait_lock+0x4>
    /* Waiting for PLL lock.*/
  }
}
 8000ece:	bf00      	nop
 8000ed0:	bf00      	nop
 8000ed2:	bd08      	pop	{r3, pc}
	...

08000ee0 <pll_init>:

#endif /* STM32_RCC_HAS_PLL */

__STATIC_INLINE void pll_init(void) {
 8000ee0:	b508      	push	{r3, lr}

#if STM32_RCC_HAS_PLL
#if STM32_ACTIVATE_PLL
  /* PLLM and PLLSRC are common to all PLLs.*/
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 8000ee2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000ee6:	4a07      	ldr	r2, [pc, #28]	@ (8000f04 <pll_init+0x24>)
 8000ee8:	60da      	str	r2, [r3, #12]
                 STM32_PLLP   | STM32_PLLPEN |
                 STM32_PLLN   | STM32_PLLM   |
                 STM32_PLLSRC;

  /* PLL activation.*/
  RCC->CR |= RCC_CR_PLLON;
 8000eea:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000eee:	681b      	ldr	r3, [r3, #0]
 8000ef0:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000ef4:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8000ef8:	6013      	str	r3, [r2, #0]

  pll_wait_lock();
 8000efa:	f7ff ffe1 	bl	8000ec0 <pll_wait_lock>
#endif
#endif
}
 8000efe:	bf00      	nop
 8000f00:	bd08      	pop	{r3, pc}
 8000f02:	bf00      	nop
 8000f04:	33021801 	.word	0x33021801
	...

08000f10 <flash_set_acr>:
/**
 * @brief   Safe setting of flash ACR register.
 *
 * @param[in] acr       value for the ACR register
 */
__STATIC_INLINE void flash_set_acr(uint32_t acr) {
 8000f10:	b082      	sub	sp, #8
 8000f12:	9001      	str	r0, [sp, #4]

  FLASH->ACR = acr;
 8000f14:	4a07      	ldr	r2, [pc, #28]	@ (8000f34 <flash_set_acr+0x24>)
 8000f16:	9b01      	ldr	r3, [sp, #4]
 8000f18:	6013      	str	r3, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) != (acr & FLASH_ACR_LATENCY_Msk)) {
 8000f1a:	bf00      	nop
 8000f1c:	4b05      	ldr	r3, [pc, #20]	@ (8000f34 <flash_set_acr+0x24>)
 8000f1e:	681a      	ldr	r2, [r3, #0]
 8000f20:	9b01      	ldr	r3, [sp, #4]
 8000f22:	4053      	eors	r3, r2
 8000f24:	f003 0307 	and.w	r3, r3, #7
 8000f28:	2b00      	cmp	r3, #0
 8000f2a:	d1f7      	bne.n	8000f1c <flash_set_acr+0xc>
    /* Waiting for flash wait states setup.*/
  }
}
 8000f2c:	bf00      	nop
 8000f2e:	bf00      	nop
 8000f30:	b002      	add	sp, #8
 8000f32:	4770      	bx	lr
 8000f34:	58004000 	.word	0x58004000
	...

08000f40 <hal_lld_set_static_pwr>:
 * @note    CR1, CR2 and CR5 are not initialized inside this function.
 */
__STATIC_INLINE void hal_lld_set_static_pwr(void) {

  /* Static PWR configurations.*/
  PWR->CR3 = STM32_PWR_CR3;
 8000f40:	4b10      	ldr	r3, [pc, #64]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f42:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8000f46:	609a      	str	r2, [r3, #8]
  PWR->CR4 = STM32_PWR_CR4;
 8000f48:	4b0e      	ldr	r3, [pc, #56]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f4a:	2200      	movs	r2, #0
 8000f4c:	60da      	str	r2, [r3, #12]
  PWR->PUCRA = STM32_PWR_PUCRA;
 8000f4e:	4b0d      	ldr	r3, [pc, #52]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f50:	2200      	movs	r2, #0
 8000f52:	621a      	str	r2, [r3, #32]
  PWR->PDCRA = STM32_PWR_PDCRA;
 8000f54:	4b0b      	ldr	r3, [pc, #44]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f56:	2200      	movs	r2, #0
 8000f58:	625a      	str	r2, [r3, #36]	@ 0x24
  PWR->PUCRB = STM32_PWR_PUCRB;
 8000f5a:	4b0a      	ldr	r3, [pc, #40]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f5c:	2200      	movs	r2, #0
 8000f5e:	629a      	str	r2, [r3, #40]	@ 0x28
  PWR->PDCRB = STM32_PWR_PDCRB;
 8000f60:	4b08      	ldr	r3, [pc, #32]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f62:	2200      	movs	r2, #0
 8000f64:	62da      	str	r2, [r3, #44]	@ 0x2c
  PWR->PUCRC = STM32_PWR_PUCRC;
 8000f66:	4b07      	ldr	r3, [pc, #28]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f68:	2200      	movs	r2, #0
 8000f6a:	631a      	str	r2, [r3, #48]	@ 0x30
  PWR->PDCRC = STM32_PWR_PDCRC;
 8000f6c:	4b05      	ldr	r3, [pc, #20]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f6e:	2200      	movs	r2, #0
 8000f70:	635a      	str	r2, [r3, #52]	@ 0x34
  PWR->PUCRH = STM32_PWR_PUCRH;
 8000f72:	4b04      	ldr	r3, [pc, #16]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f74:	2200      	movs	r2, #0
 8000f76:	659a      	str	r2, [r3, #88]	@ 0x58
  PWR->PDCRH = STM32_PWR_PDCRH;
 8000f78:	4b02      	ldr	r3, [pc, #8]	@ (8000f84 <hal_lld_set_static_pwr+0x44>)
 8000f7a:	2200      	movs	r2, #0
 8000f7c:	65da      	str	r2, [r3, #92]	@ 0x5c
}
 8000f7e:	bf00      	nop
 8000f80:	4770      	bx	lr
 8000f82:	bf00      	nop
 8000f84:	58000400 	.word	0x58000400
	...

08000f90 <hal_lld_set_static_clocks>:

/**
 * @brief   Initializes static muxes and dividers.
 */
__STATIC_INLINE void hal_lld_set_static_clocks(void) {
 8000f90:	b082      	sub	sp, #8

  uint32_t ccipr;

  /* Clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 8000f92:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000f96:	2200      	movs	r2, #0
 8000f98:	609a      	str	r2, [r3, #8]
              STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;
  RCC->EXTCFGR = STM32_SHDHPRE | STM32_C2HPRE;
 8000f9a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000f9e:	2200      	movs	r2, #0
 8000fa0:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

  /* CCIPR register initialization, note, must take care of the _OFF
     pseudo settings.*/
  ccipr = STM32_RNGSEL    | STM32_ADCSEL    | STM32_LPTIM3SEL  |
 8000fa4:	4b04      	ldr	r3, [pc, #16]	@ (8000fb8 <hal_lld_set_static_clocks+0x28>)
 8000fa6:	9301      	str	r3, [sp, #4]
          STM32_LPTIM2SEL | STM32_LPTIM1SEL | STM32_I2C3SEL    |
          STM32_I2C2SEL   | STM32_I2C1SEL   | STM32_LPUART1SEL |
          STM32_SPI2S2SEL | STM32_USART2SEL | STM32_USART1SEL;

  RCC->CCIPR = ccipr;
 8000fa8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8000fac:	9b01      	ldr	r3, [sp, #4]
 8000fae:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
}
 8000fb2:	bf00      	nop
 8000fb4:	b002      	add	sp, #8
 8000fb6:	4770      	bx	lr
 8000fb8:	80015505 	.word	0x80015505
 8000fbc:	00000000 	.word	0x00000000

08000fc0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8000fc0:	b508      	push	{r3, lr}

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8000fc2:	f000 ff65 	bl	8001e90 <dmaInit>
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 8000fc6:	f7ff fe33 	bl	8000c30 <irqInit>
}
 8000fca:	bf00      	nop
 8000fcc:	bd08      	pop	{r3, pc}
 8000fce:	bf00      	nop

08000fd0 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8000fd0:	b508      	push	{r3, lr}
#if !STM32_NO_INIT

  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~0UL);
 8000fd2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000fd6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000fd8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000fdc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8000fe0:	629a      	str	r2, [r3, #40]	@ 0x28
 8000fe2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000fe6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000fe8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000fec:	2200      	movs	r2, #0
 8000fee:	629a      	str	r2, [r3, #40]	@ 0x28
 8000ff0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000ff4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 8000ff6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8000ffa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000ffc:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001000:	f063 0307 	orn	r3, r3, #7
 8001004:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001006:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800100a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800100c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001010:	f003 0307 	and.w	r3, r3, #7
 8001014:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001016:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800101a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  /* Reset all except FLASH.*/
  rccResetAHB3(RCC_AHB3RSTR_PKARST | RCC_AHB3RSTR_AESRST |
 800101c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001020:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001022:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001026:	f443 2370 	orr.w	r3, r3, #983040	@ 0xf0000
 800102a:	6313      	str	r3, [r2, #48]	@ 0x30
 800102c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001030:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001032:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001036:	f423 2370 	bic.w	r3, r3, #983040	@ 0xf0000
 800103a:	6313      	str	r3, [r2, #48]	@ 0x30
 800103c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001040:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
               RCC_AHB3RSTR_RNGRST | RCC_AHB3RSTR_HSEMRST);
  rccResetAPB1R1(~0UL);
 8001042:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001046:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001048:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800104c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001050:	639a      	str	r2, [r3, #56]	@ 0x38
 8001052:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001056:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001058:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800105c:	2200      	movs	r2, #0
 800105e:	639a      	str	r2, [r3, #56]	@ 0x38
 8001060:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001064:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
  rccResetAPB1R2(~0UL);
 8001066:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800106a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800106c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001070:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001074:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001076:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800107a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800107c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001080:	2200      	movs	r2, #0
 8001082:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001084:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001088:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  rccResetAPB2(~0UL);
 800108a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800108e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001090:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001094:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001098:	641a      	str	r2, [r3, #64]	@ 0x40
 800109a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800109e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80010a0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80010a4:	2200      	movs	r2, #0
 80010a6:	641a      	str	r2, [r3, #64]	@ 0x40
 80010a8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80010ac:	6c1b      	ldr	r3, [r3, #64]	@ 0x40

  /* Backup domain initializations.*/
  bd_init();
#else /* !defined(HAL_LLD_USE_CLOCK_MANAGEMENT) */
  /* Flash setup for selected MSI speed setting.*/
  flash_set_acr(FLASH_ACR_DCEN   | FLASH_ACR_ICEN |
 80010ae:	f240 7002 	movw	r0, #1794	@ 0x702
 80010b2:	f7ff ff2d 	bl	8000f10 <flash_set_acr>
                FLASH_ACR_PRFTEN |STM32_FLASHBITS);

  /* Static PWR initializations.*/
  hal_lld_set_static_pwr();
 80010b6:	f7ff ff43 	bl	8000f40 <hal_lld_set_static_pwr>

  /* Core voltage setup, backup domain access enabled and left open.*/
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 80010ba:	4b1d      	ldr	r3, [pc, #116]	@ (8001130 <stm32_clock_init+0x160>)
 80010bc:	f44f 7240 	mov.w	r2, #768	@ 0x300
 80010c0:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0) {
 80010c2:	bf00      	nop
 80010c4:	4b1a      	ldr	r3, [pc, #104]	@ (8001130 <stm32_clock_init+0x160>)
 80010c6:	695b      	ldr	r3, [r3, #20]
 80010c8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80010cc:	2b00      	cmp	r3, #0
 80010ce:	d1f9      	bne.n	80010c4 <stm32_clock_init+0xf4>
    /* Wait until regulator is stable.*/
  }

  /* MSI clock reset.*/
  msi_reset();
 80010d0:	f7ff fe46 	bl	8000d60 <msi_reset>

  /* Backup domain reset.*/
  bd_reset();
 80010d4:	f7ff fdec 	bl	8000cb0 <bd_reset>

  /* Clocks setup.*/
  lse_init();
 80010d8:	f7ff fe02 	bl	8000ce0 <lse_init>
  lsi_init();
 80010dc:	f7ff fe20 	bl	8000d20 <lsi_init>
  msi_init();
 80010e0:	f7ff fe5e 	bl	8000da0 <msi_init>
  hsi16_init();
 80010e4:	f7ff feac 	bl	8000e40 <hsi16_init>
  hse32_init();
 80010e8:	f7ff fed2 	bl	8000e90 <hse32_init>

  /* Backup domain initializations.*/
  bd_init();
 80010ec:	f7ff fdc8 	bl	8000c80 <bd_init>

  /* PLLs activation, if required.*/
  pll_init();
 80010f0:	f7ff fef6 	bl	8000ee0 <pll_init>

  /* Static clocks setup.*/
  hal_lld_set_static_clocks();
 80010f4:	f7ff ff4c 	bl	8000f90 <hal_lld_set_static_clocks>

  /* Set flash WS's according HCLK3.*/
  flash_set_acr((FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS);
 80010f8:	4b0e      	ldr	r3, [pc, #56]	@ (8001134 <stm32_clock_init+0x164>)
 80010fa:	681b      	ldr	r3, [r3, #0]
 80010fc:	f023 0307 	bic.w	r3, r3, #7
 8001100:	f043 0302 	orr.w	r3, r3, #2
 8001104:	4618      	mov	r0, r3
 8001106:	f7ff ff03 	bl	8000f10 <flash_set_acr>

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800110a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800110e:	689b      	ldr	r3, [r3, #8]
 8001110:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001114:	f043 0303 	orr.w	r3, r3, #3
 8001118:	6093      	str	r3, [r2, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800111a:	bf00      	nop
 800111c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001120:	689b      	ldr	r3, [r3, #8]
 8001122:	f003 030c 	and.w	r3, r3, #12
 8001126:	2b0c      	cmp	r3, #12
 8001128:	d1f8      	bne.n	800111c <stm32_clock_init+0x14c>
    ;
#endif
#endif /* defined(HAL_LLD_USE_CLOCK_MANAGEMENT) */

#endif /* STM32_NO_INIT */
}
 800112a:	bf00      	nop
 800112c:	bf00      	nop
 800112e:	bd08      	pop	{r3, pc}
 8001130:	58000400 	.word	0x58000400
 8001134:	58004000 	.word	0x58004000
	...

08001140 <stm32_flash_enable_pgm>:

  eflp->flash->KEYR |= FLASH_KEY1;
  eflp->flash->KEYR |= FLASH_KEY2;
}

static inline void stm32_flash_enable_pgm(EFlashDriver *eflp) {
 8001140:	b082      	sub	sp, #8
 8001142:	9001      	str	r0, [sp, #4]

  eflp->flash->CR |= FLASH_CR_PG;
 8001144:	9b01      	ldr	r3, [sp, #4]
 8001146:	69db      	ldr	r3, [r3, #28]
 8001148:	695a      	ldr	r2, [r3, #20]
 800114a:	9b01      	ldr	r3, [sp, #4]
 800114c:	69db      	ldr	r3, [r3, #28]
 800114e:	f042 0201 	orr.w	r2, r2, #1
 8001152:	615a      	str	r2, [r3, #20]
}
 8001154:	bf00      	nop
 8001156:	b002      	add	sp, #8
 8001158:	4770      	bx	lr
 800115a:	bf00      	nop
 800115c:	0000      	movs	r0, r0
	...

08001160 <stm32_flash_disable_pgm>:

static inline void stm32_flash_disable_pgm(EFlashDriver *eflp) {
 8001160:	b082      	sub	sp, #8
 8001162:	9001      	str	r0, [sp, #4]

  eflp->flash->CR &= ~FLASH_CR_PG;
 8001164:	9b01      	ldr	r3, [sp, #4]
 8001166:	69db      	ldr	r3, [r3, #28]
 8001168:	695a      	ldr	r2, [r3, #20]
 800116a:	9b01      	ldr	r3, [sp, #4]
 800116c:	69db      	ldr	r3, [r3, #28]
 800116e:	f022 0201 	bic.w	r2, r2, #1
 8001172:	615a      	str	r2, [r3, #20]
}
 8001174:	bf00      	nop
 8001176:	b002      	add	sp, #8
 8001178:	4770      	bx	lr
 800117a:	bf00      	nop
 800117c:	0000      	movs	r0, r0
	...

08001180 <stm32_flash_clear_status>:

static inline void stm32_flash_clear_status(EFlashDriver *eflp) {
 8001180:	b082      	sub	sp, #8
 8001182:	9001      	str	r0, [sp, #4]

  eflp->flash->SR = 0x0000FFFFU;
 8001184:	9b01      	ldr	r3, [sp, #4]
 8001186:	69db      	ldr	r3, [r3, #28]
 8001188:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800118c:	611a      	str	r2, [r3, #16]
}
 800118e:	bf00      	nop
 8001190:	b002      	add	sp, #8
 8001192:	4770      	bx	lr
	...

080011a0 <stm32_flash_wait_busy>:

static inline void stm32_flash_wait_busy(EFlashDriver *eflp) {
 80011a0:	b082      	sub	sp, #8
 80011a2:	9001      	str	r0, [sp, #4]

  /* Wait for busy bit clear.*/
  while ((eflp->flash->SR & FLASH_SR_BSY) != 0U) {
 80011a4:	bf00      	nop
 80011a6:	9b01      	ldr	r3, [sp, #4]
 80011a8:	69db      	ldr	r3, [r3, #28]
 80011aa:	691b      	ldr	r3, [r3, #16]
 80011ac:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80011b0:	2b00      	cmp	r3, #0
 80011b2:	d1f8      	bne.n	80011a6 <stm32_flash_wait_busy+0x6>
  }
}
 80011b4:	bf00      	nop
 80011b6:	bf00      	nop
 80011b8:	b002      	add	sp, #8
 80011ba:	4770      	bx	lr
 80011bc:	0000      	movs	r0, r0
	...

080011c0 <stm32_flash_check_errors>:

static inline flash_error_t stm32_flash_check_errors(EFlashDriver *eflp) {
 80011c0:	b084      	sub	sp, #16
 80011c2:	9001      	str	r0, [sp, #4]
  uint32_t sr = eflp->flash->SR;
 80011c4:	9b01      	ldr	r3, [sp, #4]
 80011c6:	69db      	ldr	r3, [r3, #28]
 80011c8:	691b      	ldr	r3, [r3, #16]
 80011ca:	9303      	str	r3, [sp, #12]

  /* Clearing error conditions.*/
  eflp->flash->SR = sr & 0x0000FFFFU;
 80011cc:	9b01      	ldr	r3, [sp, #4]
 80011ce:	69db      	ldr	r3, [r3, #28]
 80011d0:	9a03      	ldr	r2, [sp, #12]
 80011d2:	b292      	uxth	r2, r2
 80011d4:	611a      	str	r2, [r3, #16]
  osalDbgAssert((sr & (FLASH_SR_FASTERR |
                       FLASH_SR_MISERR |
                       FLASH_SR_SIZERR)) == 0U, "unexpected flash error");

  /* Decoding relevant errors.*/
  if ((sr & FLASH_SR_WRPERR) != 0U) {
 80011d6:	9b03      	ldr	r3, [sp, #12]
 80011d8:	f003 0310 	and.w	r3, r3, #16
 80011dc:	2b00      	cmp	r3, #0
 80011de:	d001      	beq.n	80011e4 <stm32_flash_check_errors+0x24>
    return FLASH_ERROR_HW_FAILURE;
 80011e0:	2306      	movs	r3, #6
 80011e2:	e00d      	b.n	8001200 <stm32_flash_check_errors+0x40>
  }

  if ((sr & (FLASH_SR_PGAERR | FLASH_SR_PROGERR | FLASH_SR_OPERR)) != 0U) {
 80011e4:	9b03      	ldr	r3, [sp, #12]
 80011e6:	f003 032a 	and.w	r3, r3, #42	@ 0x2a
 80011ea:	2b00      	cmp	r3, #0
 80011ec:	d007      	beq.n	80011fe <stm32_flash_check_errors+0x3e>
    return eflp->state == FLASH_PGM ? FLASH_ERROR_PROGRAM : FLASH_ERROR_ERASE;
 80011ee:	9b01      	ldr	r3, [sp, #4]
 80011f0:	791b      	ldrb	r3, [r3, #4]
 80011f2:	2b04      	cmp	r3, #4
 80011f4:	d101      	bne.n	80011fa <stm32_flash_check_errors+0x3a>
 80011f6:	2303      	movs	r3, #3
 80011f8:	e002      	b.n	8001200 <stm32_flash_check_errors+0x40>
 80011fa:	2304      	movs	r3, #4
 80011fc:	e000      	b.n	8001200 <stm32_flash_check_errors+0x40>
  }

  return FLASH_NO_ERROR;
 80011fe:	2300      	movs	r3, #0
}
 8001200:	4618      	mov	r0, r3
 8001202:	b004      	add	sp, #16
 8001204:	4770      	bx	lr
 8001206:	bf00      	nop
	...

08001210 <efl_lld_init>:
/**
 * @brief   Low level Embedded Flash driver initialization.
 *
 * @notapi
 */
void efl_lld_init(void) {
 8001210:	b508      	push	{r3, lr}

  /* Driver initialization.*/
  eflObjectInit(&EFLD1);
 8001212:	4804      	ldr	r0, [pc, #16]	@ (8001224 <efl_lld_init+0x14>)
 8001214:	f7ff fb2c 	bl	8000870 <eflObjectInit>
  EFLD1.flash = FLASH;
 8001218:	4b02      	ldr	r3, [pc, #8]	@ (8001224 <efl_lld_init+0x14>)
 800121a:	4a03      	ldr	r2, [pc, #12]	@ (8001228 <efl_lld_init+0x18>)
 800121c:	61da      	str	r2, [r3, #28]
}
 800121e:	bf00      	nop
 8001220:	bd08      	pop	{r3, pc}
 8001222:	bf00      	nop
 8001224:	20000800 	.word	0x20000800
 8001228:	58004000 	.word	0x58004000
 800122c:	00000000 	.word	0x00000000

08001230 <efl_lld_get_descriptor>:
 * @param[in] ip                    pointer to a @p EFlashDriver instance
 * @return                          A flash device descriptor.
 *
 * @notapi
 */
const flash_descriptor_t *efl_lld_get_descriptor(void *instance) {
 8001230:	b082      	sub	sp, #8
 8001232:	9001      	str	r0, [sp, #4]

  (void)instance;

  return &efl_lld_descriptor;
 8001234:	4b01      	ldr	r3, [pc, #4]	@ (800123c <efl_lld_get_descriptor+0xc>)
}
 8001236:	4618      	mov	r0, r3
 8001238:	b002      	add	sp, #8
 800123a:	4770      	bx	lr
 800123c:	080049b8 	.word	0x080049b8

08001240 <efl_lld_read>:
 * @retval FLASH_ERROR_HW_FAILURE   if access to the memory failed.
 *
 * @notapi
 */
flash_error_t efl_lld_read(void *instance, flash_offset_t offset,
                           size_t n, uint8_t *rp) {
 8001240:	b500      	push	{lr}
 8001242:	b087      	sub	sp, #28
 8001244:	9003      	str	r0, [sp, #12]
 8001246:	9102      	str	r1, [sp, #8]
 8001248:	9201      	str	r2, [sp, #4]
 800124a:	9300      	str	r3, [sp, #0]
  EFlashDriver *devp = (EFlashDriver *)instance;
 800124c:	9b03      	ldr	r3, [sp, #12]
 800124e:	9305      	str	r3, [sp, #20]
  flash_error_t err = FLASH_NO_ERROR;
 8001250:	2300      	movs	r3, #0
 8001252:	f88d 3013 	strb.w	r3, [sp, #19]

  osalDbgCheck((instance != NULL) && (rp != NULL) && (n > 0U));
 8001256:	9b03      	ldr	r3, [sp, #12]
 8001258:	2b00      	cmp	r3, #0
 800125a:	bf0c      	ite	eq
 800125c:	2301      	moveq	r3, #1
 800125e:	2300      	movne	r3, #0
 8001260:	b2db      	uxtb	r3, r3
 8001262:	2b00      	cmp	r3, #0
 8001264:	d107      	bne.n	8001276 <efl_lld_read+0x36>
 8001266:	9b00      	ldr	r3, [sp, #0]
 8001268:	2b00      	cmp	r3, #0
 800126a:	bf0c      	ite	eq
 800126c:	2301      	moveq	r3, #1
 800126e:	2300      	movne	r3, #0
 8001270:	b2db      	uxtb	r3, r3
 8001272:	2b00      	cmp	r3, #0
 8001274:	d001      	beq.n	800127a <efl_lld_read+0x3a>
 8001276:	2301      	movs	r3, #1
 8001278:	e000      	b.n	800127c <efl_lld_read+0x3c>
 800127a:	2300      	movs	r3, #0
 800127c:	2b00      	cmp	r3, #0
 800127e:	d107      	bne.n	8001290 <efl_lld_read+0x50>
 8001280:	9b01      	ldr	r3, [sp, #4]
 8001282:	2b00      	cmp	r3, #0
 8001284:	bf0c      	ite	eq
 8001286:	2301      	moveq	r3, #1
 8001288:	2300      	movne	r3, #0
 800128a:	b2db      	uxtb	r3, r3
 800128c:	2b00      	cmp	r3, #0
 800128e:	d002      	beq.n	8001296 <efl_lld_read+0x56>
 8001290:	481c      	ldr	r0, [pc, #112]	@ (8001304 <efl_lld_read+0xc4>)
 8001292:	f001 fad5 	bl	8002840 <chSysHalt>
  osalDbgCheck((size_t)offset + n <= (size_t)efl_lld_descriptor.size);
 8001296:	9a02      	ldr	r2, [sp, #8]
 8001298:	9b01      	ldr	r3, [sp, #4]
 800129a:	4413      	add	r3, r2
 800129c:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
 80012a0:	4293      	cmp	r3, r2
 80012a2:	bf8c      	ite	hi
 80012a4:	2301      	movhi	r3, #1
 80012a6:	2300      	movls	r3, #0
 80012a8:	b2db      	uxtb	r3, r3
 80012aa:	2b00      	cmp	r3, #0
 80012ac:	d002      	beq.n	80012b4 <efl_lld_read+0x74>
 80012ae:	4815      	ldr	r0, [pc, #84]	@ (8001304 <efl_lld_read+0xc4>)
 80012b0:	f001 fac6 	bl	8002840 <chSysHalt>
  osalDbgAssert((devp->state == FLASH_READY) || (devp->state == FLASH_ERASE),
                "invalid state");

  /* No reading while erasing.*/
  if (devp->state == FLASH_ERASE) {
 80012b4:	9b05      	ldr	r3, [sp, #20]
 80012b6:	791b      	ldrb	r3, [r3, #4]
 80012b8:	2b05      	cmp	r3, #5
 80012ba:	d101      	bne.n	80012c0 <efl_lld_read+0x80>
    return FLASH_BUSY_ERASING;
 80012bc:	2301      	movs	r3, #1
 80012be:	e01d      	b.n	80012fc <efl_lld_read+0xbc>
  }

  /* FLASH_READY state while the operation is performed.*/
  devp->state = FLASH_READ;
 80012c0:	9b05      	ldr	r3, [sp, #20]
 80012c2:	2203      	movs	r2, #3
 80012c4:	711a      	strb	r2, [r3, #4]

  /* Clearing error status bits.*/
  stm32_flash_clear_status(devp);
 80012c6:	9805      	ldr	r0, [sp, #20]
 80012c8:	f7ff ff5a 	bl	8001180 <stm32_flash_clear_status>

  /* Actual read implementation.*/
  memcpy((void *)rp, (const void *)efl_lld_descriptor.address + offset, n);
 80012cc:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 80012d0:	9b02      	ldr	r3, [sp, #8]
 80012d2:	4413      	add	r3, r2
 80012d4:	9a01      	ldr	r2, [sp, #4]
 80012d6:	4619      	mov	r1, r3
 80012d8:	9800      	ldr	r0, [sp, #0]
 80012da:	f7fe ffcc 	bl	8000276 <memcpy>

  /* Checking for errors after reading.*/
  if ((devp->flash->SR & FLASH_SR_RDERR) != 0U) {
 80012de:	9b05      	ldr	r3, [sp, #20]
 80012e0:	69db      	ldr	r3, [r3, #28]
 80012e2:	691b      	ldr	r3, [r3, #16]
 80012e4:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80012e8:	2b00      	cmp	r3, #0
 80012ea:	d002      	beq.n	80012f2 <efl_lld_read+0xb2>
    err = FLASH_ERROR_READ;
 80012ec:	2302      	movs	r3, #2
 80012ee:	f88d 3013 	strb.w	r3, [sp, #19]
  }

  /* Ready state again.*/
  devp->state = FLASH_READY;
 80012f2:	9b05      	ldr	r3, [sp, #20]
 80012f4:	2202      	movs	r2, #2
 80012f6:	711a      	strb	r2, [r3, #4]

  return err;
 80012f8:	f89d 3013 	ldrb.w	r3, [sp, #19]

}
 80012fc:	4618      	mov	r0, r3
 80012fe:	b007      	add	sp, #28
 8001300:	f85d fb04 	ldr.w	pc, [sp], #4
 8001304:	080049d4 	.word	0x080049d4
	...

08001310 <efl_lld_program>:
 * @retval FLASH_ERROR_HW_FAILURE   if access to the memory failed.
 *
 * @notapi
 */
flash_error_t efl_lld_program(void *instance, flash_offset_t offset,
                              size_t n, const uint8_t *pp) {
 8001310:	b500      	push	{lr}
 8001312:	b08b      	sub	sp, #44	@ 0x2c
 8001314:	9003      	str	r0, [sp, #12]
 8001316:	9102      	str	r1, [sp, #8]
 8001318:	9201      	str	r2, [sp, #4]
 800131a:	9300      	str	r3, [sp, #0]
  EFlashDriver *devp = (EFlashDriver *)instance;
 800131c:	9b03      	ldr	r3, [sp, #12]
 800131e:	9308      	str	r3, [sp, #32]
  flash_error_t err = FLASH_NO_ERROR;
 8001320:	2300      	movs	r3, #0
 8001322:	f88d 3027 	strb.w	r3, [sp, #39]	@ 0x27

  osalDbgCheck((instance != NULL) && (pp != NULL) && (n > 0U));
 8001326:	9b03      	ldr	r3, [sp, #12]
 8001328:	2b00      	cmp	r3, #0
 800132a:	bf0c      	ite	eq
 800132c:	2301      	moveq	r3, #1
 800132e:	2300      	movne	r3, #0
 8001330:	b2db      	uxtb	r3, r3
 8001332:	2b00      	cmp	r3, #0
 8001334:	d107      	bne.n	8001346 <efl_lld_program+0x36>
 8001336:	9b00      	ldr	r3, [sp, #0]
 8001338:	2b00      	cmp	r3, #0
 800133a:	bf0c      	ite	eq
 800133c:	2301      	moveq	r3, #1
 800133e:	2300      	movne	r3, #0
 8001340:	b2db      	uxtb	r3, r3
 8001342:	2b00      	cmp	r3, #0
 8001344:	d001      	beq.n	800134a <efl_lld_program+0x3a>
 8001346:	2301      	movs	r3, #1
 8001348:	e000      	b.n	800134c <efl_lld_program+0x3c>
 800134a:	2300      	movs	r3, #0
 800134c:	2b00      	cmp	r3, #0
 800134e:	d107      	bne.n	8001360 <efl_lld_program+0x50>
 8001350:	9b01      	ldr	r3, [sp, #4]
 8001352:	2b00      	cmp	r3, #0
 8001354:	bf0c      	ite	eq
 8001356:	2301      	moveq	r3, #1
 8001358:	2300      	movne	r3, #0
 800135a:	b2db      	uxtb	r3, r3
 800135c:	2b00      	cmp	r3, #0
 800135e:	d002      	beq.n	8001366 <efl_lld_program+0x56>
 8001360:	483b      	ldr	r0, [pc, #236]	@ (8001450 <efl_lld_program+0x140>)
 8001362:	f001 fa6d 	bl	8002840 <chSysHalt>
  osalDbgCheck((size_t)offset + n <= (size_t)efl_lld_descriptor.size);
 8001366:	9a02      	ldr	r2, [sp, #8]
 8001368:	9b01      	ldr	r3, [sp, #4]
 800136a:	4413      	add	r3, r2
 800136c:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
 8001370:	4293      	cmp	r3, r2
 8001372:	bf8c      	ite	hi
 8001374:	2301      	movhi	r3, #1
 8001376:	2300      	movls	r3, #0
 8001378:	b2db      	uxtb	r3, r3
 800137a:	2b00      	cmp	r3, #0
 800137c:	d002      	beq.n	8001384 <efl_lld_program+0x74>
 800137e:	4834      	ldr	r0, [pc, #208]	@ (8001450 <efl_lld_program+0x140>)
 8001380:	f001 fa5e 	bl	8002840 <chSysHalt>

  osalDbgAssert((devp->state == FLASH_READY) || (devp->state == FLASH_ERASE),
                "invalid state");

  /* No programming while erasing.*/
  if (devp->state == FLASH_ERASE) {
 8001384:	9b08      	ldr	r3, [sp, #32]
 8001386:	791b      	ldrb	r3, [r3, #4]
 8001388:	2b05      	cmp	r3, #5
 800138a:	d101      	bne.n	8001390 <efl_lld_program+0x80>
    return FLASH_BUSY_ERASING;
 800138c:	2301      	movs	r3, #1
 800138e:	e05b      	b.n	8001448 <efl_lld_program+0x138>
  }

  /* FLASH_PGM state while the operation is performed.*/
  devp->state = FLASH_PGM;
 8001390:	9b08      	ldr	r3, [sp, #32]
 8001392:	2204      	movs	r2, #4
 8001394:	711a      	strb	r2, [r3, #4]

  /* Clearing error status bits.*/
  stm32_flash_clear_status(devp);
 8001396:	9808      	ldr	r0, [sp, #32]
 8001398:	f7ff fef2 	bl	8001180 <stm32_flash_clear_status>

  /* Enabling PGM mode in the controller.*/
  stm32_flash_enable_pgm(devp);
 800139c:	9808      	ldr	r0, [sp, #32]
 800139e:	f7ff fecf 	bl	8001140 <stm32_flash_enable_pgm>

  /* Actual program implementation.*/
  while (n > 0U) {
 80013a2:	e044      	b.n	800142e <efl_lld_program+0x11e>
      uint32_t  w[STM32_FLASH_LINE_SIZE / sizeof (uint32_t)];
      uint8_t   b[STM32_FLASH_LINE_SIZE / sizeof (uint8_t)];
    } line;

    /* Unwritten bytes are initialized to all ones.*/
    line.w[0] = 0xFFFFFFFFU;
 80013a4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80013a8:	9305      	str	r3, [sp, #20]
    line.w[1] = 0xFFFFFFFFU;
 80013aa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80013ae:	9306      	str	r3, [sp, #24]

    /* Programming address aligned to flash lines.*/
    address = (volatile uint32_t *)(efl_lld_descriptor.address +
 80013b0:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
                                    (offset & ~STM32_FLASH_LINE_MASK));
 80013b4:	9b02      	ldr	r3, [sp, #8]
 80013b6:	f023 0307 	bic.w	r3, r3, #7
    address = (volatile uint32_t *)(efl_lld_descriptor.address +
 80013ba:	4413      	add	r3, r2
 80013bc:	9307      	str	r3, [sp, #28]

    /* Copying data inside the prepared line.*/
    do {
      line.b[offset & STM32_FLASH_LINE_MASK] = *pp;
 80013be:	9b02      	ldr	r3, [sp, #8]
 80013c0:	f003 0307 	and.w	r3, r3, #7
 80013c4:	9a00      	ldr	r2, [sp, #0]
 80013c6:	7812      	ldrb	r2, [r2, #0]
 80013c8:	3328      	adds	r3, #40	@ 0x28
 80013ca:	446b      	add	r3, sp
 80013cc:	f803 2c14 	strb.w	r2, [r3, #-20]
      offset++;
 80013d0:	9b02      	ldr	r3, [sp, #8]
 80013d2:	3301      	adds	r3, #1
 80013d4:	9302      	str	r3, [sp, #8]
      n--;
 80013d6:	9b01      	ldr	r3, [sp, #4]
 80013d8:	3b01      	subs	r3, #1
 80013da:	9301      	str	r3, [sp, #4]
      pp++;
 80013dc:	9b00      	ldr	r3, [sp, #0]
 80013de:	3301      	adds	r3, #1
 80013e0:	9300      	str	r3, [sp, #0]
    }
    while ((n > 0U) & ((offset & STM32_FLASH_LINE_MASK) != 0U));
 80013e2:	9b01      	ldr	r3, [sp, #4]
 80013e4:	2b00      	cmp	r3, #0
 80013e6:	bf14      	ite	ne
 80013e8:	2301      	movne	r3, #1
 80013ea:	2300      	moveq	r3, #0
 80013ec:	b2da      	uxtb	r2, r3
 80013ee:	9b02      	ldr	r3, [sp, #8]
 80013f0:	f003 0307 	and.w	r3, r3, #7
 80013f4:	2b00      	cmp	r3, #0
 80013f6:	bf14      	ite	ne
 80013f8:	2301      	movne	r3, #1
 80013fa:	2300      	moveq	r3, #0
 80013fc:	b2db      	uxtb	r3, r3
 80013fe:	4013      	ands	r3, r2
 8001400:	b2db      	uxtb	r3, r3
 8001402:	2b00      	cmp	r3, #0
 8001404:	d1db      	bne.n	80013be <efl_lld_program+0xae>

    /* Programming line.*/
    address[0] = line.w[0];
 8001406:	9a05      	ldr	r2, [sp, #20]
 8001408:	9b07      	ldr	r3, [sp, #28]
 800140a:	601a      	str	r2, [r3, #0]
    address[1] = line.w[1];
 800140c:	9b07      	ldr	r3, [sp, #28]
 800140e:	3304      	adds	r3, #4
 8001410:	9a06      	ldr	r2, [sp, #24]
 8001412:	601a      	str	r2, [r3, #0]
    stm32_flash_wait_busy(devp);
 8001414:	9808      	ldr	r0, [sp, #32]
 8001416:	f7ff fec3 	bl	80011a0 <stm32_flash_wait_busy>
    err = stm32_flash_check_errors(devp);
 800141a:	9808      	ldr	r0, [sp, #32]
 800141c:	f7ff fed0 	bl	80011c0 <stm32_flash_check_errors>
 8001420:	4603      	mov	r3, r0
 8001422:	f88d 3027 	strb.w	r3, [sp, #39]	@ 0x27
    if (err != FLASH_NO_ERROR) {
 8001426:	f89d 3027 	ldrb.w	r3, [sp, #39]	@ 0x27
 800142a:	2b00      	cmp	r3, #0
 800142c:	d103      	bne.n	8001436 <efl_lld_program+0x126>
  while (n > 0U) {
 800142e:	9b01      	ldr	r3, [sp, #4]
 8001430:	2b00      	cmp	r3, #0
 8001432:	d1b7      	bne.n	80013a4 <efl_lld_program+0x94>
 8001434:	e000      	b.n	8001438 <efl_lld_program+0x128>
      break;
 8001436:	bf00      	nop
    }
  }

  /* Disabling PGM mode in the controller.*/
  stm32_flash_disable_pgm(devp);
 8001438:	9808      	ldr	r0, [sp, #32]
 800143a:	f7ff fe91 	bl	8001160 <stm32_flash_disable_pgm>

  /* Ready state again.*/
  devp->state = FLASH_READY;
 800143e:	9b08      	ldr	r3, [sp, #32]
 8001440:	2202      	movs	r2, #2
 8001442:	711a      	strb	r2, [r3, #4]

  return err;
 8001444:	f89d 3027 	ldrb.w	r3, [sp, #39]	@ 0x27
}
 8001448:	4618      	mov	r0, r3
 800144a:	b00b      	add	sp, #44	@ 0x2c
 800144c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001450:	080049e4 	.word	0x080049e4
	...

08001460 <efl_lld_start_erase_all>:
 * @retval FLASH_BUSY_ERASING       if there is an erase operation in progress.
 * @retval FLASH_ERROR_HW_FAILURE   if access to the memory failed.
 *
 * @notapi
 */
flash_error_t efl_lld_start_erase_all(void *instance) {
 8001460:	b500      	push	{lr}
 8001462:	b085      	sub	sp, #20
 8001464:	9001      	str	r0, [sp, #4]
  EFlashDriver *devp = (EFlashDriver *)instance;
 8001466:	9b01      	ldr	r3, [sp, #4]
 8001468:	9303      	str	r3, [sp, #12]

  osalDbgCheck(instance != NULL);
 800146a:	9b01      	ldr	r3, [sp, #4]
 800146c:	2b00      	cmp	r3, #0
 800146e:	bf0c      	ite	eq
 8001470:	2301      	moveq	r3, #1
 8001472:	2300      	movne	r3, #0
 8001474:	b2db      	uxtb	r3, r3
 8001476:	2b00      	cmp	r3, #0
 8001478:	d002      	beq.n	8001480 <efl_lld_start_erase_all+0x20>
 800147a:	480a      	ldr	r0, [pc, #40]	@ (80014a4 <efl_lld_start_erase_all+0x44>)
 800147c:	f001 f9e0 	bl	8002840 <chSysHalt>
  osalDbgAssert((devp->state == FLASH_READY) || (devp->state == FLASH_ERASE),
                "invalid state");

  /* No erasing while erasing.*/
  if (devp->state == FLASH_ERASE) {
 8001480:	9b03      	ldr	r3, [sp, #12]
 8001482:	791b      	ldrb	r3, [r3, #4]
 8001484:	2b05      	cmp	r3, #5
 8001486:	d101      	bne.n	800148c <efl_lld_start_erase_all+0x2c>
    return FLASH_BUSY_ERASING;
 8001488:	2301      	movs	r3, #1
 800148a:	e006      	b.n	800149a <efl_lld_start_erase_all+0x3a>
  }

  /* FLASH_PGM state while the operation is performed.*/
  devp->state = FLASH_ERASE;
 800148c:	9b03      	ldr	r3, [sp, #12]
 800148e:	2205      	movs	r2, #5
 8001490:	711a      	strb	r2, [r3, #4]

  /* Clearing error status bits.*/
  stm32_flash_clear_status(devp);
 8001492:	9803      	ldr	r0, [sp, #12]
 8001494:	f7ff fe74 	bl	8001180 <stm32_flash_clear_status>
#if defined(FLASH_CR_MER2)
  devp->flash->CR |= FLASH_CR_MER2;
  devp->flash->CR |= FLASH_CR_STRT;
#endif

  return FLASH_NO_ERROR;
 8001498:	2300      	movs	r3, #0
}
 800149a:	4618      	mov	r0, r3
 800149c:	b005      	add	sp, #20
 800149e:	f85d fb04 	ldr.w	pc, [sp], #4
 80014a2:	bf00      	nop
 80014a4:	080049f4 	.word	0x080049f4
	...

080014b0 <efl_lld_start_erase_sector>:
 * @retval FLASH_ERROR_HW_FAILURE   if access to the memory failed.
 *
 * @notapi
 */
flash_error_t efl_lld_start_erase_sector(void *instance,
                                         flash_sector_t sector) {
 80014b0:	b500      	push	{lr}
 80014b2:	b085      	sub	sp, #20
 80014b4:	9001      	str	r0, [sp, #4]
 80014b6:	9100      	str	r1, [sp, #0]
  EFlashDriver *devp = (EFlashDriver *)instance;
 80014b8:	9b01      	ldr	r3, [sp, #4]
 80014ba:	9303      	str	r3, [sp, #12]

  osalDbgCheck(instance != NULL);
 80014bc:	9b01      	ldr	r3, [sp, #4]
 80014be:	2b00      	cmp	r3, #0
 80014c0:	bf0c      	ite	eq
 80014c2:	2301      	moveq	r3, #1
 80014c4:	2300      	movne	r3, #0
 80014c6:	b2db      	uxtb	r3, r3
 80014c8:	2b00      	cmp	r3, #0
 80014ca:	d002      	beq.n	80014d2 <efl_lld_start_erase_sector+0x22>
 80014cc:	4820      	ldr	r0, [pc, #128]	@ (8001550 <efl_lld_start_erase_sector+0xa0>)
 80014ce:	f001 f9b7 	bl	8002840 <chSysHalt>
  osalDbgCheck(sector < efl_lld_descriptor.sectors_count);
 80014d2:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80014d6:	9b00      	ldr	r3, [sp, #0]
 80014d8:	4293      	cmp	r3, r2
 80014da:	bf2c      	ite	cs
 80014dc:	2301      	movcs	r3, #1
 80014de:	2300      	movcc	r3, #0
 80014e0:	b2db      	uxtb	r3, r3
 80014e2:	2b00      	cmp	r3, #0
 80014e4:	d002      	beq.n	80014ec <efl_lld_start_erase_sector+0x3c>
 80014e6:	481a      	ldr	r0, [pc, #104]	@ (8001550 <efl_lld_start_erase_sector+0xa0>)
 80014e8:	f001 f9aa 	bl	8002840 <chSysHalt>
  osalDbgAssert((devp->state == FLASH_READY) || (devp->state == FLASH_ERASE),
                "invalid state");

  /* No erasing while erasing.*/
  if (devp->state == FLASH_ERASE) {
 80014ec:	9b03      	ldr	r3, [sp, #12]
 80014ee:	791b      	ldrb	r3, [r3, #4]
 80014f0:	2b05      	cmp	r3, #5
 80014f2:	d101      	bne.n	80014f8 <efl_lld_start_erase_sector+0x48>
    return FLASH_BUSY_ERASING;
 80014f4:	2301      	movs	r3, #1
 80014f6:	e027      	b.n	8001548 <efl_lld_start_erase_sector+0x98>
  }

  /* FLASH_PGM state while the operation is performed.*/
  devp->state = FLASH_ERASE;
 80014f8:	9b03      	ldr	r3, [sp, #12]
 80014fa:	2205      	movs	r2, #5
 80014fc:	711a      	strb	r2, [r3, #4]

  /* Clearing error status bits.*/
  stm32_flash_clear_status(devp);
 80014fe:	9803      	ldr	r0, [sp, #12]
 8001500:	f7ff fe3e 	bl	8001180 <stm32_flash_clear_status>

  /* Enable page erase.*/
  devp->flash->CR |= FLASH_CR_PER;
 8001504:	9b03      	ldr	r3, [sp, #12]
 8001506:	69db      	ldr	r3, [r3, #28]
 8001508:	695a      	ldr	r2, [r3, #20]
 800150a:	9b03      	ldr	r3, [sp, #12]
 800150c:	69db      	ldr	r3, [r3, #28]
 800150e:	f042 0202 	orr.w	r2, r2, #2
 8001512:	615a      	str	r2, [r3, #20]
    devp->flash->CR |= FLASH_CR_BKER;
  }
#endif

  /* Mask off the page selection bits.*/
  devp->flash->CR &= ~FLASH_CR_PNB;
 8001514:	9b03      	ldr	r3, [sp, #12]
 8001516:	69db      	ldr	r3, [r3, #28]
 8001518:	695a      	ldr	r2, [r3, #20]
 800151a:	9b03      	ldr	r3, [sp, #12]
 800151c:	69db      	ldr	r3, [r3, #28]
 800151e:	f422 727e 	bic.w	r2, r2, #1016	@ 0x3f8
 8001522:	615a      	str	r2, [r3, #20]

  /* Set the page selection bits.*/
  devp->flash->CR |= sector << FLASH_CR_PNB_Pos;
 8001524:	9b03      	ldr	r3, [sp, #12]
 8001526:	69db      	ldr	r3, [r3, #28]
 8001528:	6959      	ldr	r1, [r3, #20]
 800152a:	9b00      	ldr	r3, [sp, #0]
 800152c:	00da      	lsls	r2, r3, #3
 800152e:	9b03      	ldr	r3, [sp, #12]
 8001530:	69db      	ldr	r3, [r3, #28]
 8001532:	430a      	orrs	r2, r1
 8001534:	615a      	str	r2, [r3, #20]

  /* Start the erase.*/
  devp->flash->CR |= FLASH_CR_STRT;
 8001536:	9b03      	ldr	r3, [sp, #12]
 8001538:	69db      	ldr	r3, [r3, #28]
 800153a:	695a      	ldr	r2, [r3, #20]
 800153c:	9b03      	ldr	r3, [sp, #12]
 800153e:	69db      	ldr	r3, [r3, #28]
 8001540:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8001544:	615a      	str	r2, [r3, #20]

  return FLASH_NO_ERROR;
 8001546:	2300      	movs	r3, #0
}
 8001548:	4618      	mov	r0, r3
 800154a:	b005      	add	sp, #20
 800154c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001550:	08004a0c 	.word	0x08004a0c
	...

08001560 <efl_lld_query_erase>:
 * @retval FLASH_ERROR_ERASE        if the erase operation failed.
 * @retval FLASH_ERROR_HW_FAILURE   if access to the memory failed.
 *
 * @api
 */
flash_error_t efl_lld_query_erase(void *instance, uint32_t *msec) {
 8001560:	b500      	push	{lr}
 8001562:	b085      	sub	sp, #20
 8001564:	9001      	str	r0, [sp, #4]
 8001566:	9100      	str	r1, [sp, #0]
  EFlashDriver *devp = (EFlashDriver *)instance;
 8001568:	9b01      	ldr	r3, [sp, #4]
 800156a:	9302      	str	r3, [sp, #8]
  flash_error_t err;

  /* If there is an erase in progress then the device must be checked.*/
  if (devp->state == FLASH_ERASE) {
 800156c:	9b02      	ldr	r3, [sp, #8]
 800156e:	791b      	ldrb	r3, [r3, #4]
 8001570:	2b05      	cmp	r3, #5
 8001572:	d122      	bne.n	80015ba <efl_lld_query_erase+0x5a>

    /* Checking for operation in progress.*/
    if ((devp->flash->SR & FLASH_SR_BSY) == 0U) {
 8001574:	9b02      	ldr	r3, [sp, #8]
 8001576:	69db      	ldr	r3, [r3, #28]
 8001578:	691b      	ldr	r3, [r3, #16]
 800157a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800157e:	2b00      	cmp	r3, #0
 8001580:	d111      	bne.n	80015a6 <efl_lld_query_erase+0x46>

      /* Disabling the various erase control bits.*/
      devp->flash->CR &= ~(FLASH_CR_MER |
 8001582:	9b02      	ldr	r3, [sp, #8]
 8001584:	69db      	ldr	r3, [r3, #28]
 8001586:	695a      	ldr	r2, [r3, #20]
 8001588:	9b02      	ldr	r3, [sp, #8]
 800158a:	69db      	ldr	r3, [r3, #28]
 800158c:	f022 0206 	bic.w	r2, r2, #6
 8001590:	615a      	str	r2, [r3, #20]
                           FLASH_CR_PER);

      /* No operation in progress, checking for errors.*/
      err = stm32_flash_check_errors(devp);
 8001592:	9802      	ldr	r0, [sp, #8]
 8001594:	f7ff fe14 	bl	80011c0 <stm32_flash_check_errors>
 8001598:	4603      	mov	r3, r0
 800159a:	f88d 300f 	strb.w	r3, [sp, #15]

      /* Back to ready state.*/
      devp->state = FLASH_READY;
 800159e:	9b02      	ldr	r3, [sp, #8]
 80015a0:	2202      	movs	r2, #2
 80015a2:	711a      	strb	r2, [r3, #4]
 80015a4:	e00c      	b.n	80015c0 <efl_lld_query_erase+0x60>
    }
    else {
      /* Recommended time before polling again, this is a simplified
         implementation.*/
      if (msec != NULL) {
 80015a6:	9b00      	ldr	r3, [sp, #0]
 80015a8:	2b00      	cmp	r3, #0
 80015aa:	d002      	beq.n	80015b2 <efl_lld_query_erase+0x52>
        *msec = (uint32_t)STM32_FLASH_WAIT_TIME_MS;
 80015ac:	9b00      	ldr	r3, [sp, #0]
 80015ae:	2205      	movs	r2, #5
 80015b0:	601a      	str	r2, [r3, #0]
      }

      err = FLASH_BUSY_ERASING;
 80015b2:	2301      	movs	r3, #1
 80015b4:	f88d 300f 	strb.w	r3, [sp, #15]
 80015b8:	e002      	b.n	80015c0 <efl_lld_query_erase+0x60>
    }
  }
  else {
    err = FLASH_NO_ERROR;
 80015ba:	2300      	movs	r3, #0
 80015bc:	f88d 300f 	strb.w	r3, [sp, #15]
  }

  return err;
 80015c0:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 80015c4:	4618      	mov	r0, r3
 80015c6:	b005      	add	sp, #20
 80015c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80015cc:	0000      	movs	r0, r0
	...

080015d0 <efl_lld_verify_erase>:
 * @retval FLASH_ERROR_VERIFY       if the verify operation failed.
 * @retval FLASH_ERROR_HW_FAILURE   if access to the memory failed.
 *
 * @notapi
 */
flash_error_t efl_lld_verify_erase(void *instance, flash_sector_t sector) {
 80015d0:	b510      	push	{r4, lr}
 80015d2:	b086      	sub	sp, #24
 80015d4:	9001      	str	r0, [sp, #4]
 80015d6:	9100      	str	r1, [sp, #0]
  EFlashDriver *devp = (EFlashDriver *)instance;
 80015d8:	9b01      	ldr	r3, [sp, #4]
 80015da:	9302      	str	r3, [sp, #8]
  uint32_t *address;
  flash_error_t err = FLASH_NO_ERROR;
 80015dc:	2300      	movs	r3, #0
 80015de:	f88d 3013 	strb.w	r3, [sp, #19]
  unsigned i;

  osalDbgCheck(instance != NULL);
 80015e2:	9b01      	ldr	r3, [sp, #4]
 80015e4:	2b00      	cmp	r3, #0
 80015e6:	bf0c      	ite	eq
 80015e8:	2301      	moveq	r3, #1
 80015ea:	2300      	movne	r3, #0
 80015ec:	b2db      	uxtb	r3, r3
 80015ee:	2b00      	cmp	r3, #0
 80015f0:	d002      	beq.n	80015f8 <efl_lld_verify_erase+0x28>
 80015f2:	4820      	ldr	r0, [pc, #128]	@ (8001674 <efl_lld_verify_erase+0xa4>)
 80015f4:	f001 f924 	bl	8002840 <chSysHalt>
  osalDbgCheck(sector < efl_lld_descriptor.sectors_count);
 80015f8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80015fc:	9b00      	ldr	r3, [sp, #0]
 80015fe:	4293      	cmp	r3, r2
 8001600:	bf2c      	ite	cs
 8001602:	2301      	movcs	r3, #1
 8001604:	2300      	movcc	r3, #0
 8001606:	b2db      	uxtb	r3, r3
 8001608:	2b00      	cmp	r3, #0
 800160a:	d002      	beq.n	8001612 <efl_lld_verify_erase+0x42>
 800160c:	4819      	ldr	r0, [pc, #100]	@ (8001674 <efl_lld_verify_erase+0xa4>)
 800160e:	f001 f917 	bl	8002840 <chSysHalt>
  osalDbgAssert((devp->state == FLASH_READY) || (devp->state == FLASH_ERASE),
                "invalid state");

  /* No verifying while erasing.*/
  if (devp->state == FLASH_ERASE) {
 8001612:	9b02      	ldr	r3, [sp, #8]
 8001614:	791b      	ldrb	r3, [r3, #4]
 8001616:	2b05      	cmp	r3, #5
 8001618:	d101      	bne.n	800161e <efl_lld_verify_erase+0x4e>
    return FLASH_BUSY_ERASING;
 800161a:	2301      	movs	r3, #1
 800161c:	e027      	b.n	800166e <efl_lld_verify_erase+0x9e>
  }

  /* Address of the sector.*/
  address = (uint32_t *)(efl_lld_descriptor.address +
 800161e:	f04f 6400 	mov.w	r4, #134217728	@ 0x8000000
                         flashGetSectorOffset(getBaseFlash(devp), sector));
 8001622:	9b02      	ldr	r3, [sp, #8]
 8001624:	9900      	ldr	r1, [sp, #0]
 8001626:	4618      	mov	r0, r3
 8001628:	f7fe ff1a 	bl	8000460 <flashGetSectorOffset>
 800162c:	4603      	mov	r3, r0
  address = (uint32_t *)(efl_lld_descriptor.address +
 800162e:	4423      	add	r3, r4
 8001630:	9305      	str	r3, [sp, #20]

  /* FLASH_READY state while the operation is performed.*/
  devp->state = FLASH_READ;
 8001632:	9b02      	ldr	r3, [sp, #8]
 8001634:	2203      	movs	r2, #3
 8001636:	711a      	strb	r2, [r3, #4]

  /* Scanning the sector space.*/
  for (i = 0U; i < STM32_FLASH_SECTOR_SIZE / sizeof(uint32_t); i++) {
 8001638:	2300      	movs	r3, #0
 800163a:	9303      	str	r3, [sp, #12]
 800163c:	e00e      	b.n	800165c <efl_lld_verify_erase+0x8c>
    if (*address != 0xFFFFFFFFU) {
 800163e:	9b05      	ldr	r3, [sp, #20]
 8001640:	681b      	ldr	r3, [r3, #0]
 8001642:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8001646:	d003      	beq.n	8001650 <efl_lld_verify_erase+0x80>
      err = FLASH_ERROR_VERIFY;
 8001648:	2305      	movs	r3, #5
 800164a:	f88d 3013 	strb.w	r3, [sp, #19]
      break;
 800164e:	e009      	b.n	8001664 <efl_lld_verify_erase+0x94>
    }
    address++;
 8001650:	9b05      	ldr	r3, [sp, #20]
 8001652:	3304      	adds	r3, #4
 8001654:	9305      	str	r3, [sp, #20]
  for (i = 0U; i < STM32_FLASH_SECTOR_SIZE / sizeof(uint32_t); i++) {
 8001656:	9b03      	ldr	r3, [sp, #12]
 8001658:	3301      	adds	r3, #1
 800165a:	9303      	str	r3, [sp, #12]
 800165c:	9b03      	ldr	r3, [sp, #12]
 800165e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8001662:	d3ec      	bcc.n	800163e <efl_lld_verify_erase+0x6e>
  }

  /* Ready state again.*/
  devp->state = FLASH_READY;
 8001664:	9b02      	ldr	r3, [sp, #8]
 8001666:	2202      	movs	r2, #2
 8001668:	711a      	strb	r2, [r3, #4]

  return err;
 800166a:	f89d 3013 	ldrb.w	r3, [sp, #19]
}
 800166e:	4618      	mov	r0, r3
 8001670:	b006      	add	sp, #24
 8001672:	bd10      	pop	{r4, pc}
 8001674:	08004a28 	.word	0x08004a28
	...

08001680 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001680:	b500      	push	{lr}
 8001682:	b083      	sub	sp, #12
 8001684:	2330      	movs	r3, #48	@ 0x30
 8001686:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001688:	9b01      	ldr	r3, [sp, #4]
 800168a:	f383 8811 	msr	BASEPRI, r3
}
 800168e:	bf00      	nop
}
 8001690:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 8001692:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 8001694:	f001 f954 	bl	8002940 <__dbg_check_lock_from_isr>
}
 8001698:	bf00      	nop
 800169a:	b003      	add	sp, #12
 800169c:	f85d fb04 	ldr.w	pc, [sp], #4

080016a0 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80016a0:	b500      	push	{lr}
 80016a2:	b083      	sub	sp, #12

  __dbg_check_unlock_from_isr();
 80016a4:	f001 f974 	bl	8002990 <__dbg_check_unlock_from_isr>
 80016a8:	2300      	movs	r3, #0
 80016aa:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80016ac:	9b01      	ldr	r3, [sp, #4]
 80016ae:	f383 8811 	msr	BASEPRI, r3
}
 80016b2:	bf00      	nop
}
 80016b4:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 80016b6:	bf00      	nop
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 80016b8:	bf00      	nop
 80016ba:	b003      	add	sp, #12
 80016bc:	f85d fb04 	ldr.w	pc, [sp], #4

080016c0 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 80016c0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80016c2:	f7ff ffdd 	bl	8001680 <chSysLockFromISR.lto_priv.0>
}
 80016c6:	bf00      	nop
 80016c8:	bd08      	pop	{r3, pc}
 80016ca:	bf00      	nop
 80016cc:	0000      	movs	r0, r0
	...

080016d0 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 80016d0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80016d2:	f7ff ffe5 	bl	80016a0 <chSysUnlockFromISR.lto_priv.0>
}
 80016d6:	bf00      	nop
 80016d8:	bd08      	pop	{r3, pc}
 80016da:	bf00      	nop
 80016dc:	0000      	movs	r0, r0
	...

080016e0 <osalThreadResumeI.lto_priv.1>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80016e0:	b500      	push	{lr}
 80016e2:	b083      	sub	sp, #12
 80016e4:	9001      	str	r0, [sp, #4]
 80016e6:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 80016e8:	9900      	ldr	r1, [sp, #0]
 80016ea:	9801      	ldr	r0, [sp, #4]
 80016ec:	f002 fba0 	bl	8003e30 <chThdResumeI>
}
 80016f0:	bf00      	nop
 80016f2:	b003      	add	sp, #12
 80016f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001700 <adc_lld_vreg_on>:
/**
 * @brief   ADC voltage regulator enable.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
NOINLINE static void adc_lld_vreg_on(ADC_TypeDef *adc) {
 8001700:	b084      	sub	sp, #16
 8001702:	9001      	str	r0, [sp, #4]

  osalDbgAssert(adc->CR == 0, "invalid register state");

#if defined(ADC_CR_ADVREGEN)
  adc->CR = ADC_CR_ADVREGEN;
 8001704:	9b01      	ldr	r3, [sp, #4]
 8001706:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800170a:	609a      	str	r2, [r3, #8]
  volatile uint32_t loop = STM32_HCLK >> 16;
 800170c:	f44f 7337 	mov.w	r3, #732	@ 0x2dc
 8001710:	9303      	str	r3, [sp, #12]
  do {
    loop--;
 8001712:	9b03      	ldr	r3, [sp, #12]
 8001714:	3b01      	subs	r3, #1
 8001716:	9303      	str	r3, [sp, #12]
  } while (loop > 0);
 8001718:	9b03      	ldr	r3, [sp, #12]
 800171a:	2b00      	cmp	r3, #0
 800171c:	d1f9      	bne.n	8001712 <adc_lld_vreg_on+0x12>
#else
#endif
}
 800171e:	bf00      	nop
 8001720:	bf00      	nop
 8001722:	b004      	add	sp, #16
 8001724:	4770      	bx	lr
 8001726:	bf00      	nop
	...

08001730 <adc_lld_calibrate>:
/**
 * @brief   Calibrates an ADC unit.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_calibrate(ADC_TypeDef *adc) {
 8001730:	b082      	sub	sp, #8
 8001732:	9001      	str	r0, [sp, #4]

  adc->CR |= ADC_CR_ADCAL;
 8001734:	9b01      	ldr	r3, [sp, #4]
 8001736:	689b      	ldr	r3, [r3, #8]
 8001738:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
 800173c:	9b01      	ldr	r3, [sp, #4]
 800173e:	609a      	str	r2, [r3, #8]
  while (adc->CR & ADC_CR_ADCAL) {
 8001740:	bf00      	nop
 8001742:	9b01      	ldr	r3, [sp, #4]
 8001744:	689b      	ldr	r3, [r3, #8]
 8001746:	2b00      	cmp	r3, #0
 8001748:	dbfb      	blt.n	8001742 <adc_lld_calibrate+0x12>
    /* Waiting for calibration end.*/
  }
}
 800174a:	bf00      	nop
 800174c:	bf00      	nop
 800174e:	b002      	add	sp, #8
 8001750:	4770      	bx	lr
 8001752:	bf00      	nop
	...

08001760 <adc_lld_stop_adc>:
/**
 * @brief   Stops an ongoing conversion, if any.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {
 8001760:	b082      	sub	sp, #8
 8001762:	9001      	str	r0, [sp, #4]

  if (adc->CR & ADC_CR_ADSTART) {
 8001764:	9b01      	ldr	r3, [sp, #4]
 8001766:	689b      	ldr	r3, [r3, #8]
 8001768:	f003 0304 	and.w	r3, r3, #4
 800176c:	2b00      	cmp	r3, #0
 800176e:	d00f      	beq.n	8001790 <adc_lld_stop_adc+0x30>
    adc->CR |= ADC_CR_ADSTP;
 8001770:	9b01      	ldr	r3, [sp, #4]
 8001772:	689b      	ldr	r3, [r3, #8]
 8001774:	f043 0210 	orr.w	r2, r3, #16
 8001778:	9b01      	ldr	r3, [sp, #4]
 800177a:	609a      	str	r2, [r3, #8]
    while (adc->CR & ADC_CR_ADSTP)
 800177c:	bf00      	nop
 800177e:	9b01      	ldr	r3, [sp, #4]
 8001780:	689b      	ldr	r3, [r3, #8]
 8001782:	f003 0310 	and.w	r3, r3, #16
 8001786:	2b00      	cmp	r3, #0
 8001788:	d1f9      	bne.n	800177e <adc_lld_stop_adc+0x1e>
      ;
    adc->IER = 0;
 800178a:	9b01      	ldr	r3, [sp, #4]
 800178c:	2200      	movs	r2, #0
 800178e:	605a      	str	r2, [r3, #4]
  }

  /* Disabling the ADC.*/
  adc->CR |= ADC_CR_ADDIS;
 8001790:	9b01      	ldr	r3, [sp, #4]
 8001792:	689b      	ldr	r3, [r3, #8]
 8001794:	f043 0202 	orr.w	r2, r3, #2
 8001798:	9b01      	ldr	r3, [sp, #4]
 800179a:	609a      	str	r2, [r3, #8]
  while ((adc->CR & ADC_CR_ADEN) != 0U) {
 800179c:	bf00      	nop
 800179e:	9b01      	ldr	r3, [sp, #4]
 80017a0:	689b      	ldr	r3, [r3, #8]
 80017a2:	f003 0301 	and.w	r3, r3, #1
 80017a6:	2b00      	cmp	r3, #0
 80017a8:	d1f9      	bne.n	800179e <adc_lld_stop_adc+0x3e>
    /* Waiting for ADC to be disabled.*/
  }
}
 80017aa:	bf00      	nop
 80017ac:	bf00      	nop
 80017ae:	b002      	add	sp, #8
 80017b0:	4770      	bx	lr
 80017b2:	bf00      	nop
	...

080017c0 <adc_lld_serve_rx_interrupt>:
 * @brief   ADC DMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 80017c0:	b500      	push	{lr}
 80017c2:	b083      	sub	sp, #12
 80017c4:	9001      	str	r0, [sp, #4]
 80017c6:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80017c8:	9b00      	ldr	r3, [sp, #0]
 80017ca:	f003 0308 	and.w	r3, r3, #8
 80017ce:	2b00      	cmp	r3, #0
 80017d0:	d02d      	beq.n	800182e <adc_lld_serve_rx_interrupt+0x6e>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80017d2:	9801      	ldr	r0, [sp, #4]
 80017d4:	f000 f9c4 	bl	8001b60 <adc_lld_stop_conversion>
 80017d8:	9b01      	ldr	r3, [sp, #4]
 80017da:	691b      	ldr	r3, [r3, #16]
 80017dc:	689b      	ldr	r3, [r3, #8]
 80017de:	2b00      	cmp	r3, #0
 80017e0:	d013      	beq.n	800180a <adc_lld_serve_rx_interrupt+0x4a>
 80017e2:	9b01      	ldr	r3, [sp, #4]
 80017e4:	2205      	movs	r2, #5
 80017e6:	701a      	strb	r2, [r3, #0]
 80017e8:	9b01      	ldr	r3, [sp, #4]
 80017ea:	691b      	ldr	r3, [r3, #16]
 80017ec:	689b      	ldr	r3, [r3, #8]
 80017ee:	2101      	movs	r1, #1
 80017f0:	9801      	ldr	r0, [sp, #4]
 80017f2:	4798      	blx	r3
 80017f4:	9b01      	ldr	r3, [sp, #4]
 80017f6:	781b      	ldrb	r3, [r3, #0]
 80017f8:	2b05      	cmp	r3, #5
 80017fa:	d10c      	bne.n	8001816 <adc_lld_serve_rx_interrupt+0x56>
 80017fc:	9b01      	ldr	r3, [sp, #4]
 80017fe:	2202      	movs	r2, #2
 8001800:	701a      	strb	r2, [r3, #0]
 8001802:	9b01      	ldr	r3, [sp, #4]
 8001804:	2200      	movs	r2, #0
 8001806:	611a      	str	r2, [r3, #16]
 8001808:	e005      	b.n	8001816 <adc_lld_serve_rx_interrupt+0x56>
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	2202      	movs	r2, #2
 800180e:	701a      	strb	r2, [r3, #0]
 8001810:	9b01      	ldr	r3, [sp, #4]
 8001812:	2200      	movs	r2, #0
 8001814:	611a      	str	r2, [r3, #16]
 8001816:	f7ff ff53 	bl	80016c0 <osalSysLockFromISR.lto_priv.0>
 800181a:	9b01      	ldr	r3, [sp, #4]
 800181c:	3314      	adds	r3, #20
 800181e:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8001822:	4618      	mov	r0, r3
 8001824:	f7ff ff5c 	bl	80016e0 <osalThreadResumeI.lto_priv.1>
 8001828:	f7ff ff52 	bl	80016d0 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800182c:	e05d      	b.n	80018ea <adc_lld_serve_rx_interrupt+0x12a>
    if (adcp->grpp != NULL) {
 800182e:	9b01      	ldr	r3, [sp, #4]
 8001830:	691b      	ldr	r3, [r3, #16]
 8001832:	2b00      	cmp	r3, #0
 8001834:	d059      	beq.n	80018ea <adc_lld_serve_rx_interrupt+0x12a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8001836:	9b00      	ldr	r3, [sp, #0]
 8001838:	f003 0302 	and.w	r3, r3, #2
 800183c:	2b00      	cmp	r3, #0
 800183e:	d045      	beq.n	80018cc <adc_lld_serve_rx_interrupt+0x10c>
        _adc_isr_full_code(adcp);
 8001840:	9b01      	ldr	r3, [sp, #4]
 8001842:	691b      	ldr	r3, [r3, #16]
 8001844:	781b      	ldrb	r3, [r3, #0]
 8001846:	2b00      	cmp	r3, #0
 8001848:	d014      	beq.n	8001874 <adc_lld_serve_rx_interrupt+0xb4>
 800184a:	9b01      	ldr	r3, [sp, #4]
 800184c:	691b      	ldr	r3, [r3, #16]
 800184e:	685b      	ldr	r3, [r3, #4]
 8001850:	2b00      	cmp	r3, #0
 8001852:	d04a      	beq.n	80018ea <adc_lld_serve_rx_interrupt+0x12a>
 8001854:	9b01      	ldr	r3, [sp, #4]
 8001856:	2204      	movs	r2, #4
 8001858:	701a      	strb	r2, [r3, #0]
 800185a:	9b01      	ldr	r3, [sp, #4]
 800185c:	691b      	ldr	r3, [r3, #16]
 800185e:	685b      	ldr	r3, [r3, #4]
 8001860:	9801      	ldr	r0, [sp, #4]
 8001862:	4798      	blx	r3
 8001864:	9b01      	ldr	r3, [sp, #4]
 8001866:	781b      	ldrb	r3, [r3, #0]
 8001868:	2b04      	cmp	r3, #4
 800186a:	d13e      	bne.n	80018ea <adc_lld_serve_rx_interrupt+0x12a>
 800186c:	9b01      	ldr	r3, [sp, #4]
 800186e:	2203      	movs	r2, #3
 8001870:	701a      	strb	r2, [r3, #0]
}
 8001872:	e03a      	b.n	80018ea <adc_lld_serve_rx_interrupt+0x12a>
        _adc_isr_full_code(adcp);
 8001874:	9801      	ldr	r0, [sp, #4]
 8001876:	f000 f973 	bl	8001b60 <adc_lld_stop_conversion>
 800187a:	9b01      	ldr	r3, [sp, #4]
 800187c:	691b      	ldr	r3, [r3, #16]
 800187e:	685b      	ldr	r3, [r3, #4]
 8001880:	2b00      	cmp	r3, #0
 8001882:	d012      	beq.n	80018aa <adc_lld_serve_rx_interrupt+0xea>
 8001884:	9b01      	ldr	r3, [sp, #4]
 8001886:	2204      	movs	r2, #4
 8001888:	701a      	strb	r2, [r3, #0]
 800188a:	9b01      	ldr	r3, [sp, #4]
 800188c:	691b      	ldr	r3, [r3, #16]
 800188e:	685b      	ldr	r3, [r3, #4]
 8001890:	9801      	ldr	r0, [sp, #4]
 8001892:	4798      	blx	r3
 8001894:	9b01      	ldr	r3, [sp, #4]
 8001896:	781b      	ldrb	r3, [r3, #0]
 8001898:	2b04      	cmp	r3, #4
 800189a:	d10c      	bne.n	80018b6 <adc_lld_serve_rx_interrupt+0xf6>
 800189c:	9b01      	ldr	r3, [sp, #4]
 800189e:	2202      	movs	r2, #2
 80018a0:	701a      	strb	r2, [r3, #0]
 80018a2:	9b01      	ldr	r3, [sp, #4]
 80018a4:	2200      	movs	r2, #0
 80018a6:	611a      	str	r2, [r3, #16]
 80018a8:	e005      	b.n	80018b6 <adc_lld_serve_rx_interrupt+0xf6>
 80018aa:	9b01      	ldr	r3, [sp, #4]
 80018ac:	2202      	movs	r2, #2
 80018ae:	701a      	strb	r2, [r3, #0]
 80018b0:	9b01      	ldr	r3, [sp, #4]
 80018b2:	2200      	movs	r2, #0
 80018b4:	611a      	str	r2, [r3, #16]
 80018b6:	f7ff ff03 	bl	80016c0 <osalSysLockFromISR.lto_priv.0>
 80018ba:	9b01      	ldr	r3, [sp, #4]
 80018bc:	3314      	adds	r3, #20
 80018be:	2100      	movs	r1, #0
 80018c0:	4618      	mov	r0, r3
 80018c2:	f7ff ff0d 	bl	80016e0 <osalThreadResumeI.lto_priv.1>
 80018c6:	f7ff ff03 	bl	80016d0 <osalSysUnlockFromISR.lto_priv.0>
}
 80018ca:	e00e      	b.n	80018ea <adc_lld_serve_rx_interrupt+0x12a>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 80018cc:	9b00      	ldr	r3, [sp, #0]
 80018ce:	f003 0304 	and.w	r3, r3, #4
 80018d2:	2b00      	cmp	r3, #0
 80018d4:	d009      	beq.n	80018ea <adc_lld_serve_rx_interrupt+0x12a>
        _adc_isr_half_code(adcp);
 80018d6:	9b01      	ldr	r3, [sp, #4]
 80018d8:	691b      	ldr	r3, [r3, #16]
 80018da:	685b      	ldr	r3, [r3, #4]
 80018dc:	2b00      	cmp	r3, #0
 80018de:	d004      	beq.n	80018ea <adc_lld_serve_rx_interrupt+0x12a>
 80018e0:	9b01      	ldr	r3, [sp, #4]
 80018e2:	691b      	ldr	r3, [r3, #16]
 80018e4:	685b      	ldr	r3, [r3, #4]
 80018e6:	9801      	ldr	r0, [sp, #4]
 80018e8:	4798      	blx	r3
}
 80018ea:	bf00      	nop
 80018ec:	b003      	add	sp, #12
 80018ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80018f2:	bf00      	nop
	...

08001900 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8001900:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001902:	f001 f86d 	bl	80029e0 <__dbg_check_enter_isr>

  adc_lld_serve_interrupt(&ADCD1);
 8001906:	4804      	ldr	r0, [pc, #16]	@ (8001918 <Vector88+0x18>)
 8001908:	f000 f952 	bl	8001bb0 <adc_lld_serve_interrupt>

#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif

  OSAL_IRQ_EPILOGUE();
 800190c:	f001 f8a0 	bl	8002a50 <__dbg_check_leave_isr>
 8001910:	f002 febe 	bl	8004690 <__port_irq_epilogue>
}
 8001914:	bf00      	nop
 8001916:	bd08      	pop	{r3, pc}
 8001918:	20000820 	.word	0x20000820
 800191c:	00000000 	.word	0x00000000

08001920 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8001920:	b508      	push	{r3, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8001922:	4809      	ldr	r0, [pc, #36]	@ (8001948 <adc_lld_init+0x28>)
 8001924:	f7fe fe2c 	bl	8000580 <adcObjectInit>
  ADCD1.adc     = ADC1;
 8001928:	4b07      	ldr	r3, [pc, #28]	@ (8001948 <adc_lld_init+0x28>)
 800192a:	4a08      	ldr	r2, [pc, #32]	@ (800194c <adc_lld_init+0x2c>)
 800192c:	629a      	str	r2, [r3, #40]	@ 0x28
  ADCD1.dmastp  = NULL;
 800192e:	4b06      	ldr	r3, [pc, #24]	@ (8001948 <adc_lld_init+0x28>)
 8001930:	2200      	movs	r2, #0
 8001932:	62da      	str	r2, [r3, #44]	@ 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8001934:	4b04      	ldr	r3, [pc, #16]	@ (8001948 <adc_lld_init+0x28>)
 8001936:	f242 528a 	movw	r2, #9610	@ 0x258a
 800193a:	631a      	str	r2, [r3, #48]	@ 0x30
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;

  /* The vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC1_IRQ_PRIORITY);
 800193c:	2105      	movs	r1, #5
 800193e:	2012      	movs	r0, #18
 8001940:	f7ff f88e 	bl	8000a60 <nvicEnableVector>
#endif
}
 8001944:	bf00      	nop
 8001946:	bd08      	pop	{r3, pc}
 8001948:	20000820 	.word	0x20000820
 800194c:	40012400 	.word	0x40012400

08001950 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8001950:	b500      	push	{lr}
 8001952:	b083      	sub	sp, #12
 8001954:	9001      	str	r0, [sp, #4]

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8001956:	9b01      	ldr	r3, [sp, #4]
 8001958:	781b      	ldrb	r3, [r3, #0]
 800195a:	2b01      	cmp	r3, #1
 800195c:	d152      	bne.n	8001a04 <adc_lld_start+0xb4>

#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800195e:	9b01      	ldr	r3, [sp, #4]
 8001960:	4a2a      	ldr	r2, [pc, #168]	@ (8001a0c <adc_lld_start+0xbc>)
 8001962:	4293      	cmp	r3, r2
 8001964:	d144      	bne.n	80019f0 <adc_lld_start+0xa0>
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 8001966:	9b01      	ldr	r3, [sp, #4]
 8001968:	4a29      	ldr	r2, [pc, #164]	@ (8001a10 <adc_lld_start+0xc0>)
 800196a:	2105      	movs	r1, #5
 800196c:	200e      	movs	r0, #14
 800196e:	f000 fac7 	bl	8001f00 <dmaStreamAllocI>
 8001972:	4602      	mov	r2, r0
 8001974:	9b01      	ldr	r3, [sp, #4]
 8001976:	62da      	str	r2, [r3, #44]	@ 0x2c
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
      rccResetADC1();
 8001978:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800197c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800197e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001982:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001986:	6413      	str	r3, [r2, #64]	@ 0x40
 8001988:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800198c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800198e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001992:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8001996:	6413      	str	r3, [r2, #64]	@ 0x40
 8001998:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800199c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
      rccEnableADC1(true);
 800199e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80019a2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80019a4:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80019a8:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 80019ac:	6613      	str	r3, [r2, #96]	@ 0x60
 80019ae:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80019b2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 80019b6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80019ba:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 80019be:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 80019c2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80019c6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80

      /* DMA setup.*/
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80019ca:	9b01      	ldr	r3, [sp, #4]
 80019cc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80019ce:	685b      	ldr	r3, [r3, #4]
 80019d0:	4a10      	ldr	r2, [pc, #64]	@ (8001a14 <adc_lld_start+0xc4>)
 80019d2:	609a      	str	r2, [r3, #8]
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC1);
 80019d4:	9b01      	ldr	r3, [sp, #4]
 80019d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80019d8:	2105      	movs	r1, #5
 80019da:	4618      	mov	r0, r3
 80019dc:	f000 fbb0 	bl	8002140 <dmaSetRequestSource>

      /* Clock settings.*/
      ADC1_COMMON->CCR = STM32_ADC_PRESC << ADC_CCR_PRESC_Pos;
 80019e0:	4b0d      	ldr	r3, [pc, #52]	@ (8001a18 <adc_lld_start+0xc8>)
 80019e2:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 80019e6:	601a      	str	r2, [r3, #0]
      adcp->adc->CFGR2 = STM32_ADC_ADC1_CFGR2;
 80019e8:	9b01      	ldr	r3, [sp, #4]
 80019ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019ec:	2200      	movs	r2, #0
 80019ee:	611a      	str	r2, [r3, #16]
    }
#endif /* STM32_ADC_USE_ADC1 */

    /* Regulator enabled and stabilized.*/
    adc_lld_vreg_on(adcp->adc);
 80019f0:	9b01      	ldr	r3, [sp, #4]
 80019f2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019f4:	4618      	mov	r0, r3
 80019f6:	f7ff fe83 	bl	8001700 <adc_lld_vreg_on>

    /* Calibrating ADC.*/
    adc_lld_calibrate(adcp->adc);
 80019fa:	9b01      	ldr	r3, [sp, #4]
 80019fc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80019fe:	4618      	mov	r0, r3
 8001a00:	f7ff fe96 	bl	8001730 <adc_lld_calibrate>
  }
}
 8001a04:	bf00      	nop
 8001a06:	b003      	add	sp, #12
 8001a08:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a0c:	20000820 	.word	0x20000820
 8001a10:	080017c1 	.word	0x080017c1
 8001a14:	40012440 	.word	0x40012440
 8001a18:	40012708 	.word	0x40012708
 8001a1c:	00000000 	.word	0x00000000

08001a20 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 8001a20:	b086      	sub	sp, #24
 8001a22:	9001      	str	r0, [sp, #4]
  uint32_t mode, cfgr1;
  const ADCConversionGroup *grpp = adcp->grpp;
 8001a24:	9b01      	ldr	r3, [sp, #4]
 8001a26:	691b      	ldr	r3, [r3, #16]
 8001a28:	9303      	str	r3, [sp, #12]

  /* Write back ISR bits to clear register.*/
  adcp->adc->ISR = adcp->adc->ISR;
 8001a2a:	9b01      	ldr	r3, [sp, #4]
 8001a2c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001a2e:	9b01      	ldr	r3, [sp, #4]
 8001a30:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a32:	6812      	ldr	r2, [r2, #0]
 8001a34:	601a      	str	r2, [r3, #0]

  /* Get group1 configuration. Transfer the clock mode for group2.*/
  cfgr1  = grpp->cfgr1 | ADC_CFGR1_DMAEN;
 8001a36:	9b03      	ldr	r3, [sp, #12]
 8001a38:	68db      	ldr	r3, [r3, #12]
 8001a3a:	f043 0301 	orr.w	r3, r3, #1
 8001a3e:	9304      	str	r3, [sp, #16]

  /* DMA setup.*/
  mode  = adcp->dmamode;
 8001a40:	9b01      	ldr	r3, [sp, #4]
 8001a42:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a44:	9305      	str	r3, [sp, #20]
  if (grpp->circular) {
 8001a46:	9b03      	ldr	r3, [sp, #12]
 8001a48:	781b      	ldrb	r3, [r3, #0]
 8001a4a:	2b00      	cmp	r3, #0
 8001a4c:	d00f      	beq.n	8001a6e <adc_lld_start_conversion+0x4e>
    mode  |= STM32_DMA_CR_CIRC;
 8001a4e:	9b05      	ldr	r3, [sp, #20]
 8001a50:	f043 0320 	orr.w	r3, r3, #32
 8001a54:	9305      	str	r3, [sp, #20]
    cfgr1 |= ADC_CFGR1_DMACFG;
 8001a56:	9b04      	ldr	r3, [sp, #16]
 8001a58:	f043 0302 	orr.w	r3, r3, #2
 8001a5c:	9304      	str	r3, [sp, #16]
    if (adcp->depth > 1) {
 8001a5e:	9b01      	ldr	r3, [sp, #4]
 8001a60:	68db      	ldr	r3, [r3, #12]
 8001a62:	2b01      	cmp	r3, #1
 8001a64:	d903      	bls.n	8001a6e <adc_lld_start_conversion+0x4e>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
 8001a66:	9b05      	ldr	r3, [sp, #20]
 8001a68:	f043 0304 	orr.w	r3, r3, #4
 8001a6c:	9305      	str	r3, [sp, #20]
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8001a6e:	9b01      	ldr	r3, [sp, #4]
 8001a70:	689a      	ldr	r2, [r3, #8]
 8001a72:	9b01      	ldr	r3, [sp, #4]
 8001a74:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001a76:	685b      	ldr	r3, [r3, #4]
 8001a78:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels *
 8001a7a:	9b03      	ldr	r3, [sp, #12]
 8001a7c:	885b      	ldrh	r3, [r3, #2]
 8001a7e:	4619      	mov	r1, r3
 8001a80:	9b01      	ldr	r3, [sp, #4]
 8001a82:	68da      	ldr	r2, [r3, #12]
 8001a84:	9b01      	ldr	r3, [sp, #4]
 8001a86:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001a88:	685b      	ldr	r3, [r3, #4]
 8001a8a:	fb01 f202 	mul.w	r2, r1, r2
 8001a8e:	605a      	str	r2, [r3, #4]
                                            (uint32_t)adcp->depth));
  dmaStreamSetMode(adcp->dmastp, mode);
 8001a90:	9b01      	ldr	r3, [sp, #4]
 8001a92:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001a94:	685b      	ldr	r3, [r3, #4]
 8001a96:	9a05      	ldr	r2, [sp, #20]
 8001a98:	601a      	str	r2, [r3, #0]

  /* Apply ADC configuration.*/
  adcp->adc->CFGR1  = cfgr1;
 8001a9a:	9b01      	ldr	r3, [sp, #4]
 8001a9c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001a9e:	9a04      	ldr	r2, [sp, #16]
 8001aa0:	60da      	str	r2, [r3, #12]
  adcp->adc->CHSELR = grpp->chselr;
 8001aa2:	9b01      	ldr	r3, [sp, #4]
 8001aa4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001aa6:	9a03      	ldr	r2, [sp, #12]
 8001aa8:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8001aaa:	629a      	str	r2, [r3, #40]	@ 0x28

  while ((adcp->adc->ISR & ADC_ISR_CCRDY) == 0U) {
 8001aac:	bf00      	nop
 8001aae:	9b01      	ldr	r3, [sp, #4]
 8001ab0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ab2:	681b      	ldr	r3, [r3, #0]
 8001ab4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8001ab8:	2b00      	cmp	r3, #0
 8001aba:	d0f8      	beq.n	8001aae <adc_lld_start_conversion+0x8e>
    /* Wait for the channel bits (or sequence), CHSEL mode and scan direction
       to be applied.*/
  }

  /* Set the sample rate(s).*/
  adcp->adc->SMPR = grpp->smpr;
 8001abc:	9b01      	ldr	r3, [sp, #4]
 8001abe:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ac0:	9a03      	ldr	r2, [sp, #12]
 8001ac2:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8001ac4:	615a      	str	r2, [r3, #20]

  /* Enable ADC interrupts if callback specified.*/
   if (grpp->error_cb != NULL) {
 8001ac6:	9b03      	ldr	r3, [sp, #12]
 8001ac8:	689b      	ldr	r3, [r3, #8]
 8001aca:	2b00      	cmp	r3, #0
 8001acc:	d01f      	beq.n	8001b0e <adc_lld_start_conversion+0xee>
    adcp->adc->IER    = ADC_IER_OVRIE | ADC_IER_AWD1IE
 8001ace:	9b01      	ldr	r3, [sp, #4]
 8001ad0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ad2:	f44f 7264 	mov.w	r2, #912	@ 0x390
 8001ad6:	605a      	str	r2, [r3, #4]
                                      | ADC_IER_AWD2IE
                                      | ADC_IER_AWD3IE;
    adcp->adc->TR1    = grpp->tr1;
 8001ad8:	9b01      	ldr	r3, [sp, #4]
 8001ada:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001adc:	9a03      	ldr	r2, [sp, #12]
 8001ade:	6912      	ldr	r2, [r2, #16]
 8001ae0:	621a      	str	r2, [r3, #32]
    adcp->adc->TR2    = grpp->tr2;
 8001ae2:	9b01      	ldr	r3, [sp, #4]
 8001ae4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ae6:	9a03      	ldr	r2, [sp, #12]
 8001ae8:	6952      	ldr	r2, [r2, #20]
 8001aea:	625a      	str	r2, [r3, #36]	@ 0x24
    adcp->adc->TR3    = grpp->tr3;
 8001aec:	9b01      	ldr	r3, [sp, #4]
 8001aee:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001af0:	9a03      	ldr	r2, [sp, #12]
 8001af2:	6992      	ldr	r2, [r2, #24]
 8001af4:	62da      	str	r2, [r3, #44]	@ 0x2c
    adcp->adc->AWD2CR = grpp->awd2cr;
 8001af6:	9b01      	ldr	r3, [sp, #4]
 8001af8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001afa:	9a03      	ldr	r2, [sp, #12]
 8001afc:	69d2      	ldr	r2, [r2, #28]
 8001afe:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    adcp->adc->AWD3CR = grpp->awd3cr;
 8001b02:	9b01      	ldr	r3, [sp, #4]
 8001b04:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b06:	9a03      	ldr	r2, [sp, #12]
 8001b08:	6a12      	ldr	r2, [r2, #32]
 8001b0a:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
  }

  /* Enable the ADC. Note: Setting ADEN must be deferred as a STM32G071 will
     reset RES[1:0] resolution bits if CFGR1 is modified with ADEN set
     (see STM32G071xx errata ES0418 Rev 3 2.6.2). Same applies to STM32WL.*/
  adcp->adc->CR  |= ADC_CR_ADEN;
 8001b0e:	9b01      	ldr	r3, [sp, #4]
 8001b10:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b12:	689a      	ldr	r2, [r3, #8]
 8001b14:	9b01      	ldr	r3, [sp, #4]
 8001b16:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b18:	f042 0201 	orr.w	r2, r2, #1
 8001b1c:	609a      	str	r2, [r3, #8]
  while ((adcp->adc->ISR & ADC_ISR_ADRDY) == 0U) {
 8001b1e:	bf00      	nop
 8001b20:	9b01      	ldr	r3, [sp, #4]
 8001b22:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b24:	681b      	ldr	r3, [r3, #0]
 8001b26:	f003 0301 	and.w	r3, r3, #1
 8001b2a:	2b00      	cmp	r3, #0
 8001b2c:	d0f8      	beq.n	8001b20 <adc_lld_start_conversion+0x100>
    /* Wait for the ADC to become ready.*/
  }

  /* Enable DMA controller stream.*/
  dmaStreamEnable(adcp->dmastp);
 8001b2e:	9b01      	ldr	r3, [sp, #4]
 8001b30:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b32:	685b      	ldr	r3, [r3, #4]
 8001b34:	681a      	ldr	r2, [r3, #0]
 8001b36:	9b01      	ldr	r3, [sp, #4]
 8001b38:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b3a:	685b      	ldr	r3, [r3, #4]
 8001b3c:	f042 0201 	orr.w	r2, r2, #1
 8001b40:	601a      	str	r2, [r3, #0]

  /* ADC conversion start.*/
  adcp->adc->CR |= ADC_CR_ADSTART;
 8001b42:	9b01      	ldr	r3, [sp, #4]
 8001b44:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b46:	689a      	ldr	r2, [r3, #8]
 8001b48:	9b01      	ldr	r3, [sp, #4]
 8001b4a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b4c:	f042 0204 	orr.w	r2, r2, #4
 8001b50:	609a      	str	r2, [r3, #8]
}
 8001b52:	bf00      	nop
 8001b54:	b006      	add	sp, #24
 8001b56:	4770      	bx	lr
	...

08001b60 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8001b60:	b500      	push	{lr}
 8001b62:	b083      	sub	sp, #12
 8001b64:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
 8001b66:	9b01      	ldr	r3, [sp, #4]
 8001b68:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b6a:	685b      	ldr	r3, [r3, #4]
 8001b6c:	681a      	ldr	r2, [r3, #0]
 8001b6e:	9b01      	ldr	r3, [sp, #4]
 8001b70:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b72:	685b      	ldr	r3, [r3, #4]
 8001b74:	f022 020f 	bic.w	r2, r2, #15
 8001b78:	601a      	str	r2, [r3, #0]
 8001b7a:	9b01      	ldr	r3, [sp, #4]
 8001b7c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b7e:	7c1b      	ldrb	r3, [r3, #16]
 8001b80:	461a      	mov	r2, r3
 8001b82:	230e      	movs	r3, #14
 8001b84:	fa03 f202 	lsl.w	r2, r3, r2
 8001b88:	9b01      	ldr	r3, [sp, #4]
 8001b8a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001b8c:	681b      	ldr	r3, [r3, #0]
 8001b8e:	605a      	str	r2, [r3, #4]
  adc_lld_stop_adc(adcp->adc);
 8001b90:	9b01      	ldr	r3, [sp, #4]
 8001b92:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b94:	4618      	mov	r0, r3
 8001b96:	f7ff fde3 	bl	8001760 <adc_lld_stop_adc>
}
 8001b9a:	bf00      	nop
 8001b9c:	b003      	add	sp, #12
 8001b9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ba2:	bf00      	nop
	...

08001bb0 <adc_lld_serve_interrupt>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_serve_interrupt(ADCDriver *adcp) {
 8001bb0:	b500      	push	{lr}
 8001bb2:	b085      	sub	sp, #20
 8001bb4:	9001      	str	r0, [sp, #4]
  uint32_t isr;

  isr = adcp->adc->ISR;
 8001bb6:	9b01      	ldr	r3, [sp, #4]
 8001bb8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001bba:	681b      	ldr	r3, [r3, #0]
 8001bbc:	9302      	str	r3, [sp, #8]
  adcp->adc->ISR = isr;
 8001bbe:	9b01      	ldr	r3, [sp, #4]
 8001bc0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001bc2:	9a02      	ldr	r2, [sp, #8]
 8001bc4:	601a      	str	r2, [r3, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8001bc6:	9b01      	ldr	r3, [sp, #4]
 8001bc8:	691b      	ldr	r3, [r3, #16]
 8001bca:	2b00      	cmp	r3, #0
 8001bcc:	d059      	beq.n	8001c82 <adc_lld_serve_interrupt+0xd2>
    adcerror_t emask = 0U;
 8001bce:	2300      	movs	r3, #0
 8001bd0:	9303      	str	r3, [sp, #12]

    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the state is checked too.*/
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8001bd2:	9b02      	ldr	r3, [sp, #8]
 8001bd4:	f003 0310 	and.w	r3, r3, #16
 8001bd8:	2b00      	cmp	r3, #0
 8001bda:	d007      	beq.n	8001bec <adc_lld_serve_interrupt+0x3c>
 8001bdc:	9b01      	ldr	r3, [sp, #4]
 8001bde:	781b      	ldrb	r3, [r3, #0]
 8001be0:	2b03      	cmp	r3, #3
 8001be2:	d103      	bne.n	8001bec <adc_lld_serve_interrupt+0x3c>
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
 8001be4:	9b03      	ldr	r3, [sp, #12]
 8001be6:	f043 0302 	orr.w	r3, r3, #2
 8001bea:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD1) {
 8001bec:	9b02      	ldr	r3, [sp, #8]
 8001bee:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8001bf2:	2b00      	cmp	r3, #0
 8001bf4:	d003      	beq.n	8001bfe <adc_lld_serve_interrupt+0x4e>
      /* Analog watchdog 1 error.*/
      emask |= ADC_ERR_AWD1;
 8001bf6:	9b03      	ldr	r3, [sp, #12]
 8001bf8:	f043 0304 	orr.w	r3, r3, #4
 8001bfc:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD2) {
 8001bfe:	9b02      	ldr	r3, [sp, #8]
 8001c00:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8001c04:	2b00      	cmp	r3, #0
 8001c06:	d003      	beq.n	8001c10 <adc_lld_serve_interrupt+0x60>
      /* Analog watchdog 2 error.*/
      emask |= ADC_ERR_AWD2;
 8001c08:	9b03      	ldr	r3, [sp, #12]
 8001c0a:	f043 0308 	orr.w	r3, r3, #8
 8001c0e:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD3) {
 8001c10:	9b02      	ldr	r3, [sp, #8]
 8001c12:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8001c16:	2b00      	cmp	r3, #0
 8001c18:	d003      	beq.n	8001c22 <adc_lld_serve_interrupt+0x72>
      /* Analog watchdog 3 error.*/
      emask |= ADC_ERR_AWD3;
 8001c1a:	9b03      	ldr	r3, [sp, #12]
 8001c1c:	f043 0310 	orr.w	r3, r3, #16
 8001c20:	9303      	str	r3, [sp, #12]
    }
    if (emask != 0U) {
 8001c22:	9b03      	ldr	r3, [sp, #12]
 8001c24:	2b00      	cmp	r3, #0
 8001c26:	d02c      	beq.n	8001c82 <adc_lld_serve_interrupt+0xd2>
      _adc_isr_error_code(adcp, emask);
 8001c28:	9801      	ldr	r0, [sp, #4]
 8001c2a:	f7ff ff99 	bl	8001b60 <adc_lld_stop_conversion>
 8001c2e:	9b01      	ldr	r3, [sp, #4]
 8001c30:	691b      	ldr	r3, [r3, #16]
 8001c32:	689b      	ldr	r3, [r3, #8]
 8001c34:	2b00      	cmp	r3, #0
 8001c36:	d013      	beq.n	8001c60 <adc_lld_serve_interrupt+0xb0>
 8001c38:	9b01      	ldr	r3, [sp, #4]
 8001c3a:	2205      	movs	r2, #5
 8001c3c:	701a      	strb	r2, [r3, #0]
 8001c3e:	9b01      	ldr	r3, [sp, #4]
 8001c40:	691b      	ldr	r3, [r3, #16]
 8001c42:	689b      	ldr	r3, [r3, #8]
 8001c44:	9903      	ldr	r1, [sp, #12]
 8001c46:	9801      	ldr	r0, [sp, #4]
 8001c48:	4798      	blx	r3
 8001c4a:	9b01      	ldr	r3, [sp, #4]
 8001c4c:	781b      	ldrb	r3, [r3, #0]
 8001c4e:	2b05      	cmp	r3, #5
 8001c50:	d10c      	bne.n	8001c6c <adc_lld_serve_interrupt+0xbc>
 8001c52:	9b01      	ldr	r3, [sp, #4]
 8001c54:	2202      	movs	r2, #2
 8001c56:	701a      	strb	r2, [r3, #0]
 8001c58:	9b01      	ldr	r3, [sp, #4]
 8001c5a:	2200      	movs	r2, #0
 8001c5c:	611a      	str	r2, [r3, #16]
 8001c5e:	e005      	b.n	8001c6c <adc_lld_serve_interrupt+0xbc>
 8001c60:	9b01      	ldr	r3, [sp, #4]
 8001c62:	2202      	movs	r2, #2
 8001c64:	701a      	strb	r2, [r3, #0]
 8001c66:	9b01      	ldr	r3, [sp, #4]
 8001c68:	2200      	movs	r2, #0
 8001c6a:	611a      	str	r2, [r3, #16]
 8001c6c:	f7ff fd28 	bl	80016c0 <osalSysLockFromISR.lto_priv.0>
 8001c70:	9b01      	ldr	r3, [sp, #4]
 8001c72:	3314      	adds	r3, #20
 8001c74:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8001c78:	4618      	mov	r0, r3
 8001c7a:	f7ff fd31 	bl	80016e0 <osalThreadResumeI.lto_priv.1>
 8001c7e:	f7ff fd27 	bl	80016d0 <osalSysUnlockFromISR.lto_priv.0>
    }
  }
}
 8001c82:	bf00      	nop
 8001c84:	b005      	add	sp, #20
 8001c86:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c8a:	bf00      	nop
 8001c8c:	0000      	movs	r0, r0
	...

08001c90 <adcSTM32EnableVREF>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableVREF(ADCDriver *adcp) {
 8001c90:	b082      	sub	sp, #8
 8001c92:	9001      	str	r0, [sp, #4]

  (void)adcp;

  ADC1_COMMON->CCR |= ADC_CCR_VREFEN;
 8001c94:	4b04      	ldr	r3, [pc, #16]	@ (8001ca8 <adcSTM32EnableVREF+0x18>)
 8001c96:	681b      	ldr	r3, [r3, #0]
 8001c98:	4a03      	ldr	r2, [pc, #12]	@ (8001ca8 <adcSTM32EnableVREF+0x18>)
 8001c9a:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8001c9e:	6013      	str	r3, [r2, #0]
}
 8001ca0:	bf00      	nop
 8001ca2:	b002      	add	sp, #8
 8001ca4:	4770      	bx	lr
 8001ca6:	bf00      	nop
 8001ca8:	40012708 	.word	0x40012708
 8001cac:	00000000 	.word	0x00000000

08001cb0 <adcSTM32EnableTS>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {
 8001cb0:	b082      	sub	sp, #8
 8001cb2:	9001      	str	r0, [sp, #4]

  (void)adcp;

  ADC1_COMMON->CCR |= ADC_CCR_TSEN;
 8001cb4:	4b04      	ldr	r3, [pc, #16]	@ (8001cc8 <adcSTM32EnableTS+0x18>)
 8001cb6:	681b      	ldr	r3, [r3, #0]
 8001cb8:	4a03      	ldr	r2, [pc, #12]	@ (8001cc8 <adcSTM32EnableTS+0x18>)
 8001cba:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8001cbe:	6013      	str	r3, [r2, #0]
}
 8001cc0:	bf00      	nop
 8001cc2:	b002      	add	sp, #8
 8001cc4:	4770      	bx	lr
 8001cc6:	bf00      	nop
 8001cc8:	40012708 	.word	0x40012708
 8001ccc:	00000000 	.word	0x00000000

08001cd0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001cd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001cd2:	f000 fe85 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8001cd6:	4804      	ldr	r0, [pc, #16]	@ (8001ce8 <Vector6C+0x18>)
 8001cd8:	f000 f9f2 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001cdc:	f000 feb8 	bl	8002a50 <__dbg_check_leave_isr>
 8001ce0:	f002 fcd6 	bl	8004690 <__port_irq_epilogue>
}
 8001ce4:	bf00      	nop
 8001ce6:	bd08      	pop	{r3, pc}
 8001ce8:	08004a40 	.word	0x08004a40
 8001cec:	00000000 	.word	0x00000000

08001cf0 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8001cf0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001cf2:	f000 fe75 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8001cf6:	4804      	ldr	r0, [pc, #16]	@ (8001d08 <Vector70+0x18>)
 8001cf8:	f000 f9e2 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001cfc:	f000 fea8 	bl	8002a50 <__dbg_check_leave_isr>
 8001d00:	f002 fcc6 	bl	8004690 <__port_irq_epilogue>
}
 8001d04:	bf00      	nop
 8001d06:	bd08      	pop	{r3, pc}
 8001d08:	08004a54 	.word	0x08004a54
 8001d0c:	00000000 	.word	0x00000000

08001d10 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8001d10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d12:	f000 fe65 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8001d16:	4804      	ldr	r0, [pc, #16]	@ (8001d28 <Vector74+0x18>)
 8001d18:	f000 f9d2 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d1c:	f000 fe98 	bl	8002a50 <__dbg_check_leave_isr>
 8001d20:	f002 fcb6 	bl	8004690 <__port_irq_epilogue>
}
 8001d24:	bf00      	nop
 8001d26:	bd08      	pop	{r3, pc}
 8001d28:	08004a68 	.word	0x08004a68
 8001d2c:	00000000 	.word	0x00000000

08001d30 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001d30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d32:	f000 fe55 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8001d36:	4804      	ldr	r0, [pc, #16]	@ (8001d48 <Vector78+0x18>)
 8001d38:	f000 f9c2 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d3c:	f000 fe88 	bl	8002a50 <__dbg_check_leave_isr>
 8001d40:	f002 fca6 	bl	8004690 <__port_irq_epilogue>
}
 8001d44:	bf00      	nop
 8001d46:	bd08      	pop	{r3, pc}
 8001d48:	08004a7c 	.word	0x08004a7c
 8001d4c:	00000000 	.word	0x00000000

08001d50 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8001d50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d52:	f000 fe45 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8001d56:	4804      	ldr	r0, [pc, #16]	@ (8001d68 <Vector7C+0x18>)
 8001d58:	f000 f9b2 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d5c:	f000 fe78 	bl	8002a50 <__dbg_check_leave_isr>
 8001d60:	f002 fc96 	bl	8004690 <__port_irq_epilogue>
}
 8001d64:	bf00      	nop
 8001d66:	bd08      	pop	{r3, pc}
 8001d68:	08004a90 	.word	0x08004a90
 8001d6c:	00000000 	.word	0x00000000

08001d70 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8001d70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d72:	f000 fe35 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8001d76:	4804      	ldr	r0, [pc, #16]	@ (8001d88 <Vector80+0x18>)
 8001d78:	f000 f9a2 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d7c:	f000 fe68 	bl	8002a50 <__dbg_check_leave_isr>
 8001d80:	f002 fc86 	bl	8004690 <__port_irq_epilogue>
}
 8001d84:	bf00      	nop
 8001d86:	bd08      	pop	{r3, pc}
 8001d88:	08004aa4 	.word	0x08004aa4
 8001d8c:	00000000 	.word	0x00000000

08001d90 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8001d90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001d92:	f000 fe25 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8001d96:	4804      	ldr	r0, [pc, #16]	@ (8001da8 <Vector84+0x18>)
 8001d98:	f000 f992 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001d9c:	f000 fe58 	bl	8002a50 <__dbg_check_leave_isr>
 8001da0:	f002 fc76 	bl	8004690 <__port_irq_epilogue>
}
 8001da4:	bf00      	nop
 8001da6:	bd08      	pop	{r3, pc}
 8001da8:	08004ab8 	.word	0x08004ab8
 8001dac:	00000000 	.word	0x00000000

08001db0 <Vector118>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8001db0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001db2:	f000 fe15 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8001db6:	4804      	ldr	r0, [pc, #16]	@ (8001dc8 <Vector118+0x18>)
 8001db8:	f000 f982 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001dbc:	f000 fe48 	bl	8002a50 <__dbg_check_leave_isr>
 8001dc0:	f002 fc66 	bl	8004690 <__port_irq_epilogue>
}
 8001dc4:	bf00      	nop
 8001dc6:	bd08      	pop	{r3, pc}
 8001dc8:	08004acc 	.word	0x08004acc
 8001dcc:	00000000 	.word	0x00000000

08001dd0 <Vector11C>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8001dd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001dd2:	f000 fe05 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8001dd6:	4804      	ldr	r0, [pc, #16]	@ (8001de8 <Vector11C+0x18>)
 8001dd8:	f000 f972 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001ddc:	f000 fe38 	bl	8002a50 <__dbg_check_leave_isr>
 8001de0:	f002 fc56 	bl	8004690 <__port_irq_epilogue>
}
 8001de4:	bf00      	nop
 8001de6:	bd08      	pop	{r3, pc}
 8001de8:	08004ae0 	.word	0x08004ae0
 8001dec:	00000000 	.word	0x00000000

08001df0 <Vector120>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8001df0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001df2:	f000 fdf5 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8001df6:	4804      	ldr	r0, [pc, #16]	@ (8001e08 <Vector120+0x18>)
 8001df8:	f000 f962 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001dfc:	f000 fe28 	bl	8002a50 <__dbg_check_leave_isr>
 8001e00:	f002 fc46 	bl	8004690 <__port_irq_epilogue>
}
 8001e04:	bf00      	nop
 8001e06:	bd08      	pop	{r3, pc}
 8001e08:	08004af4 	.word	0x08004af4
 8001e0c:	00000000 	.word	0x00000000

08001e10 <Vector124>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001e10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e12:	f000 fde5 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8001e16:	4804      	ldr	r0, [pc, #16]	@ (8001e28 <Vector124+0x18>)
 8001e18:	f000 f952 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e1c:	f000 fe18 	bl	8002a50 <__dbg_check_leave_isr>
 8001e20:	f002 fc36 	bl	8004690 <__port_irq_epilogue>
}
 8001e24:	bf00      	nop
 8001e26:	bd08      	pop	{r3, pc}
 8001e28:	08004b08 	.word	0x08004b08
 8001e2c:	00000000 	.word	0x00000000

08001e30 <Vector128>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001e30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e32:	f000 fdd5 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8001e36:	4804      	ldr	r0, [pc, #16]	@ (8001e48 <Vector128+0x18>)
 8001e38:	f000 f942 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e3c:	f000 fe08 	bl	8002a50 <__dbg_check_leave_isr>
 8001e40:	f002 fc26 	bl	8004690 <__port_irq_epilogue>
}
 8001e44:	bf00      	nop
 8001e46:	bd08      	pop	{r3, pc}
 8001e48:	08004b1c 	.word	0x08004b1c
 8001e4c:	00000000 	.word	0x00000000

08001e50 <Vector12C>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8001e50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e52:	f000 fdc5 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8001e56:	4804      	ldr	r0, [pc, #16]	@ (8001e68 <Vector12C+0x18>)
 8001e58:	f000 f932 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e5c:	f000 fdf8 	bl	8002a50 <__dbg_check_leave_isr>
 8001e60:	f002 fc16 	bl	8004690 <__port_irq_epilogue>
}
 8001e64:	bf00      	nop
 8001e66:	bd08      	pop	{r3, pc}
 8001e68:	08004b30 	.word	0x08004b30
 8001e6c:	00000000 	.word	0x00000000

08001e70 <Vector130>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8001e70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e72:	f000 fdb5 	bl	80029e0 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 8001e76:	4804      	ldr	r0, [pc, #16]	@ (8001e88 <Vector130+0x18>)
 8001e78:	f000 f922 	bl	80020c0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8001e7c:	f000 fde8 	bl	8002a50 <__dbg_check_leave_isr>
 8001e80:	f002 fc06 	bl	8004690 <__port_irq_epilogue>
}
 8001e84:	bf00      	nop
 8001e86:	bd08      	pop	{r3, pc}
 8001e88:	08004b44 	.word	0x08004b44
 8001e8c:	00000000 	.word	0x00000000

08001e90 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8001e90:	b082      	sub	sp, #8
  int i;

  dma.allocated_mask = 0U;
 8001e92:	4b15      	ldr	r3, [pc, #84]	@ (8001ee8 <dmaInit+0x58>)
 8001e94:	2200      	movs	r2, #0
 8001e96:	601a      	str	r2, [r3, #0]
  dma.isr_mask       = 0U;
 8001e98:	4b13      	ldr	r3, [pc, #76]	@ (8001ee8 <dmaInit+0x58>)
 8001e9a:	2200      	movs	r2, #0
 8001e9c:	605a      	str	r2, [r3, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001e9e:	2300      	movs	r3, #0
 8001ea0:	9301      	str	r3, [sp, #4]
 8001ea2:	e013      	b.n	8001ecc <dmaInit+0x3c>
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001ea4:	4911      	ldr	r1, [pc, #68]	@ (8001eec <dmaInit+0x5c>)
 8001ea6:	9a01      	ldr	r2, [sp, #4]
 8001ea8:	4613      	mov	r3, r2
 8001eaa:	009b      	lsls	r3, r3, #2
 8001eac:	4413      	add	r3, r2
 8001eae:	009b      	lsls	r3, r3, #2
 8001eb0:	440b      	add	r3, r1
 8001eb2:	3304      	adds	r3, #4
 8001eb4:	681b      	ldr	r3, [r3, #0]
 8001eb6:	2200      	movs	r2, #0
 8001eb8:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 8001eba:	4a0b      	ldr	r2, [pc, #44]	@ (8001ee8 <dmaInit+0x58>)
 8001ebc:	9b01      	ldr	r3, [sp, #4]
 8001ebe:	3301      	adds	r3, #1
 8001ec0:	2100      	movs	r1, #0
 8001ec2:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001ec6:	9b01      	ldr	r3, [sp, #4]
 8001ec8:	3301      	adds	r3, #1
 8001eca:	9301      	str	r3, [sp, #4]
 8001ecc:	9b01      	ldr	r3, [sp, #4]
 8001ece:	2b0d      	cmp	r3, #13
 8001ed0:	dde8      	ble.n	8001ea4 <dmaInit+0x14>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8001ed2:	4b07      	ldr	r3, [pc, #28]	@ (8001ef0 <dmaInit+0x60>)
 8001ed4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001ed8:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8001eda:	4b06      	ldr	r3, [pc, #24]	@ (8001ef4 <dmaInit+0x64>)
 8001edc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001ee0:	605a      	str	r2, [r3, #4]
#endif
}
 8001ee2:	bf00      	nop
 8001ee4:	b002      	add	sp, #8
 8001ee6:	4770      	bx	lr
 8001ee8:	20000854 	.word	0x20000854
 8001eec:	08004a40 	.word	0x08004a40
 8001ef0:	40020000 	.word	0x40020000
 8001ef4:	40020400 	.word	0x40020400
	...

08001f00 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8001f00:	b500      	push	{lr}
 8001f02:	b08b      	sub	sp, #44	@ 0x2c
 8001f04:	9003      	str	r0, [sp, #12]
 8001f06:	9102      	str	r1, [sp, #8]
 8001f08:	9201      	str	r2, [sp, #4]
 8001f0a:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 8001f0c:	f000 fde0 	bl	8002ad0 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 8001f10:	9b03      	ldr	r3, [sp, #12]
 8001f12:	2b0d      	cmp	r3, #13
 8001f14:	d804      	bhi.n	8001f20 <dmaStreamAllocI+0x20>
    startid = id;
 8001f16:	9b03      	ldr	r3, [sp, #12]
 8001f18:	9308      	str	r3, [sp, #32]
    endid   = id;
 8001f1a:	9b03      	ldr	r3, [sp, #12]
 8001f1c:	9307      	str	r3, [sp, #28]
 8001f1e:	e01c      	b.n	8001f5a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA_SUPPORTS_DMAMUX == TRUE
  else if (id == STM32_DMA_STREAM_ID_ANY) {
 8001f20:	9b03      	ldr	r3, [sp, #12]
 8001f22:	2b0e      	cmp	r3, #14
 8001f24:	d104      	bne.n	8001f30 <dmaStreamAllocI+0x30>
    startid = 0U;
 8001f26:	2300      	movs	r3, #0
 8001f28:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 8001f2a:	230d      	movs	r3, #13
 8001f2c:	9307      	str	r3, [sp, #28]
 8001f2e:	e014      	b.n	8001f5a <dmaStreamAllocI+0x5a>
  }
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA1) {
 8001f30:	9b03      	ldr	r3, [sp, #12]
 8001f32:	2b0f      	cmp	r3, #15
 8001f34:	d104      	bne.n	8001f40 <dmaStreamAllocI+0x40>
    startid = 0U;
 8001f36:	2300      	movs	r3, #0
 8001f38:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA1_NUM_CHANNELS - 1U;
 8001f3a:	2306      	movs	r3, #6
 8001f3c:	9307      	str	r3, [sp, #28]
 8001f3e:	e00c      	b.n	8001f5a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA2) {
 8001f40:	9b03      	ldr	r3, [sp, #12]
 8001f42:	2b10      	cmp	r3, #16
 8001f44:	d104      	bne.n	8001f50 <dmaStreamAllocI+0x50>
    startid = STM32_DMA1_NUM_CHANNELS;
 8001f46:	2307      	movs	r3, #7
 8001f48:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 8001f4a:	230d      	movs	r3, #13
 8001f4c:	9307      	str	r3, [sp, #28]
 8001f4e:	e004      	b.n	8001f5a <dmaStreamAllocI+0x5a>
  }
#endif
#endif
  else {
    osalDbgCheck(false);
 8001f50:	4857      	ldr	r0, [pc, #348]	@ (80020b0 <dmaStreamAllocI+0x1b0>)
 8001f52:	f000 fc75 	bl	8002840 <chSysHalt>
    return NULL;
 8001f56:	2300      	movs	r3, #0
 8001f58:	e0a6      	b.n	80020a8 <dmaStreamAllocI+0x1a8>
  }

  for (i = startid; i <= endid; i++) {
 8001f5a:	9b08      	ldr	r3, [sp, #32]
 8001f5c:	9309      	str	r3, [sp, #36]	@ 0x24
 8001f5e:	e09d      	b.n	800209c <dmaStreamAllocI+0x19c>
    uint32_t mask = (1U << i);
 8001f60:	2201      	movs	r2, #1
 8001f62:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001f64:	fa02 f303 	lsl.w	r3, r2, r3
 8001f68:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 8001f6a:	4b52      	ldr	r3, [pc, #328]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 8001f6c:	681a      	ldr	r2, [r3, #0]
 8001f6e:	9b06      	ldr	r3, [sp, #24]
 8001f70:	4013      	ands	r3, r2
 8001f72:	2b00      	cmp	r3, #0
 8001f74:	f040 808f 	bne.w	8002096 <dmaStreamAllocI+0x196>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8001f78:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001f7a:	4613      	mov	r3, r2
 8001f7c:	009b      	lsls	r3, r3, #2
 8001f7e:	4413      	add	r3, r2
 8001f80:	009b      	lsls	r3, r3, #2
 8001f82:	4a4d      	ldr	r2, [pc, #308]	@ (80020b8 <dmaStreamAllocI+0x1b8>)
 8001f84:	4413      	add	r3, r2
 8001f86:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8001f88:	494a      	ldr	r1, [pc, #296]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 8001f8a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001f8c:	3301      	adds	r3, #1
 8001f8e:	9a01      	ldr	r2, [sp, #4]
 8001f90:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
      dma.streams[i].param = param;
 8001f94:	4a47      	ldr	r2, [pc, #284]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 8001f96:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001f98:	3301      	adds	r3, #1
 8001f9a:	00db      	lsls	r3, r3, #3
 8001f9c:	4413      	add	r3, r2
 8001f9e:	9a00      	ldr	r2, [sp, #0]
 8001fa0:	605a      	str	r2, [r3, #4]
      dma.allocated_mask  |= mask;
 8001fa2:	4b44      	ldr	r3, [pc, #272]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 8001fa4:	681a      	ldr	r2, [r3, #0]
 8001fa6:	9b06      	ldr	r3, [sp, #24]
 8001fa8:	4313      	orrs	r3, r2
 8001faa:	4a42      	ldr	r2, [pc, #264]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 8001fac:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8001fae:	9b06      	ldr	r3, [sp, #24]
 8001fb0:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8001fb4:	2b00      	cmp	r3, #0
 8001fb6:	d012      	beq.n	8001fde <dmaStreamAllocI+0xde>
        rccEnableDMA1(true);
 8001fb8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001fbc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8001fbe:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001fc2:	f043 0301 	orr.w	r3, r3, #1
 8001fc6:	6493      	str	r3, [r2, #72]	@ 0x48
 8001fc8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001fcc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8001fce:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001fd2:	f043 0301 	orr.w	r3, r3, #1
 8001fd6:	6693      	str	r3, [r2, #104]	@ 0x68
 8001fd8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001fdc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#if STM32_DMA2_NUM_CHANNELS > 0
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 8001fde:	9b06      	ldr	r3, [sp, #24]
 8001fe0:	f403 537e 	and.w	r3, r3, #16256	@ 0x3f80
 8001fe4:	2b00      	cmp	r3, #0
 8001fe6:	d012      	beq.n	800200e <dmaStreamAllocI+0x10e>
        rccEnableDMA2(true);
 8001fe8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001fec:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8001fee:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001ff2:	f043 0302 	orr.w	r3, r3, #2
 8001ff6:	6493      	str	r3, [r2, #72]	@ 0x48
 8001ff8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001ffc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8001ffe:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002002:	f043 0302 	orr.w	r3, r3, #2
 8002006:	6693      	str	r3, [r2, #104]	@ 0x68
 8002008:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800200c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

#if (STM32_DMA_SUPPORTS_DMAMUX == TRUE) && defined(rccEnableDMAMUX)
      /* Enabling DMAMUX if present.*/
      if (dma.allocated_mask != 0U) {
 800200e:	4b29      	ldr	r3, [pc, #164]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 8002010:	681b      	ldr	r3, [r3, #0]
 8002012:	2b00      	cmp	r3, #0
 8002014:	d012      	beq.n	800203c <dmaStreamAllocI+0x13c>
        rccEnableDMAMUX(true);
 8002016:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800201a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800201c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002020:	f043 0304 	orr.w	r3, r3, #4
 8002024:	6493      	str	r3, [r2, #72]	@ 0x48
 8002026:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800202a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800202c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002030:	f043 0304 	orr.w	r3, r3, #4
 8002034:	6693      	str	r3, [r2, #104]	@ 0x68
 8002036:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800203a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 800203c:	9b01      	ldr	r3, [sp, #4]
 800203e:	2b00      	cmp	r3, #0
 8002040:	d012      	beq.n	8002068 <dmaStreamAllocI+0x168>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8002042:	4b1c      	ldr	r3, [pc, #112]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 8002044:	685a      	ldr	r2, [r3, #4]
 8002046:	9b05      	ldr	r3, [sp, #20]
 8002048:	689b      	ldr	r3, [r3, #8]
 800204a:	4013      	ands	r3, r2
 800204c:	2b00      	cmp	r3, #0
 800204e:	d105      	bne.n	800205c <dmaStreamAllocI+0x15c>
          nvicEnableVector(dmastp->vector, priority);
 8002050:	9b05      	ldr	r3, [sp, #20]
 8002052:	7c9b      	ldrb	r3, [r3, #18]
 8002054:	9902      	ldr	r1, [sp, #8]
 8002056:	4618      	mov	r0, r3
 8002058:	f7fe fd02 	bl	8000a60 <nvicEnableVector>
        }
        dma.isr_mask |= mask;
 800205c:	4b15      	ldr	r3, [pc, #84]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 800205e:	685a      	ldr	r2, [r3, #4]
 8002060:	9b06      	ldr	r3, [sp, #24]
 8002062:	4313      	orrs	r3, r2
 8002064:	4a13      	ldr	r2, [pc, #76]	@ (80020b4 <dmaStreamAllocI+0x1b4>)
 8002066:	6053      	str	r3, [r2, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 8002068:	9b05      	ldr	r3, [sp, #20]
 800206a:	685b      	ldr	r3, [r3, #4]
 800206c:	681a      	ldr	r2, [r3, #0]
 800206e:	9b05      	ldr	r3, [sp, #20]
 8002070:	685b      	ldr	r3, [r3, #4]
 8002072:	f022 020f 	bic.w	r2, r2, #15
 8002076:	601a      	str	r2, [r3, #0]
 8002078:	9b05      	ldr	r3, [sp, #20]
 800207a:	7c1b      	ldrb	r3, [r3, #16]
 800207c:	461a      	mov	r2, r3
 800207e:	230e      	movs	r3, #14
 8002080:	fa03 f202 	lsl.w	r2, r3, r2
 8002084:	9b05      	ldr	r3, [sp, #20]
 8002086:	681b      	ldr	r3, [r3, #0]
 8002088:	605a      	str	r2, [r3, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 800208a:	9b05      	ldr	r3, [sp, #20]
 800208c:	685b      	ldr	r3, [r3, #4]
 800208e:	2200      	movs	r2, #0
 8002090:	601a      	str	r2, [r3, #0]

      return dmastp;
 8002092:	9b05      	ldr	r3, [sp, #20]
 8002094:	e008      	b.n	80020a8 <dmaStreamAllocI+0x1a8>
  for (i = startid; i <= endid; i++) {
 8002096:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002098:	3301      	adds	r3, #1
 800209a:	9309      	str	r3, [sp, #36]	@ 0x24
 800209c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800209e:	9b07      	ldr	r3, [sp, #28]
 80020a0:	429a      	cmp	r2, r3
 80020a2:	f67f af5d 	bls.w	8001f60 <dmaStreamAllocI+0x60>
    }
  }

  return NULL;
 80020a6:	2300      	movs	r3, #0
}
 80020a8:	4618      	mov	r0, r3
 80020aa:	b00b      	add	sp, #44	@ 0x2c
 80020ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80020b0:	08004b58 	.word	0x08004b58
 80020b4:	20000854 	.word	0x20000854
 80020b8:	08004a40 	.word	0x08004a40
 80020bc:	00000000 	.word	0x00000000

080020c0 <dmaServeInterrupt>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
 80020c0:	b500      	push	{lr}
 80020c2:	b085      	sub	sp, #20
 80020c4:	9001      	str	r0, [sp, #4]
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;
 80020c6:	9b01      	ldr	r3, [sp, #4]
 80020c8:	7c5b      	ldrb	r3, [r3, #17]
 80020ca:	9303      	str	r3, [sp, #12]

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 80020cc:	9b01      	ldr	r3, [sp, #4]
 80020ce:	681b      	ldr	r3, [r3, #0]
 80020d0:	681b      	ldr	r3, [r3, #0]
 80020d2:	9a01      	ldr	r2, [sp, #4]
 80020d4:	7c12      	ldrb	r2, [r2, #16]
 80020d6:	40d3      	lsrs	r3, r2
 80020d8:	f003 030e 	and.w	r3, r3, #14
 80020dc:	9302      	str	r3, [sp, #8]
  if (flags & dmastp->channel->CCR) {
 80020de:	9b01      	ldr	r3, [sp, #4]
 80020e0:	685b      	ldr	r3, [r3, #4]
 80020e2:	681a      	ldr	r2, [r3, #0]
 80020e4:	9b02      	ldr	r3, [sp, #8]
 80020e6:	4013      	ands	r3, r2
 80020e8:	2b00      	cmp	r3, #0
 80020ea:	d01c      	beq.n	8002126 <dmaServeInterrupt+0x66>
    dmastp->dma->IFCR = flags << dmastp->shift;
 80020ec:	9b01      	ldr	r3, [sp, #4]
 80020ee:	7c1b      	ldrb	r3, [r3, #16]
 80020f0:	4619      	mov	r1, r3
 80020f2:	9b01      	ldr	r3, [sp, #4]
 80020f4:	681b      	ldr	r3, [r3, #0]
 80020f6:	9a02      	ldr	r2, [sp, #8]
 80020f8:	408a      	lsls	r2, r1
 80020fa:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 80020fc:	4a0c      	ldr	r2, [pc, #48]	@ (8002130 <dmaServeInterrupt+0x70>)
 80020fe:	9b03      	ldr	r3, [sp, #12]
 8002100:	3301      	adds	r3, #1
 8002102:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8002106:	2b00      	cmp	r3, #0
 8002108:	d00d      	beq.n	8002126 <dmaServeInterrupt+0x66>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 800210a:	4a09      	ldr	r2, [pc, #36]	@ (8002130 <dmaServeInterrupt+0x70>)
 800210c:	9b03      	ldr	r3, [sp, #12]
 800210e:	3301      	adds	r3, #1
 8002110:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8002114:	4906      	ldr	r1, [pc, #24]	@ (8002130 <dmaServeInterrupt+0x70>)
 8002116:	9b03      	ldr	r3, [sp, #12]
 8002118:	3301      	adds	r3, #1
 800211a:	00db      	lsls	r3, r3, #3
 800211c:	440b      	add	r3, r1
 800211e:	685b      	ldr	r3, [r3, #4]
 8002120:	9902      	ldr	r1, [sp, #8]
 8002122:	4618      	mov	r0, r3
 8002124:	4790      	blx	r2
    }
  }
}
 8002126:	bf00      	nop
 8002128:	b005      	add	sp, #20
 800212a:	f85d fb04 	ldr.w	pc, [sp], #4
 800212e:	bf00      	nop
 8002130:	20000854 	.word	0x20000854
	...

08002140 <dmaSetRequestSource>:
 * @param[in] dmastp    pointer to a @p stm32_dma_stream_t structure
 * @param[in] per       peripheral identifier
 *
 * @special
 */
void dmaSetRequestSource(const stm32_dma_stream_t *dmastp, uint32_t per) {
 8002140:	b500      	push	{lr}
 8002142:	b083      	sub	sp, #12
 8002144:	9001      	str	r0, [sp, #4]
 8002146:	9100      	str	r1, [sp, #0]

  osalDbgCheck(per < 256U);
 8002148:	9b00      	ldr	r3, [sp, #0]
 800214a:	2bff      	cmp	r3, #255	@ 0xff
 800214c:	bf8c      	ite	hi
 800214e:	2301      	movhi	r3, #1
 8002150:	2300      	movls	r3, #0
 8002152:	b2db      	uxtb	r3, r3
 8002154:	2b00      	cmp	r3, #0
 8002156:	d002      	beq.n	800215e <dmaSetRequestSource+0x1e>
 8002158:	4805      	ldr	r0, [pc, #20]	@ (8002170 <dmaSetRequestSource+0x30>)
 800215a:	f000 fb71 	bl	8002840 <chSysHalt>

  dmastp->mux->CCR = per;
 800215e:	9b01      	ldr	r3, [sp, #4]
 8002160:	68db      	ldr	r3, [r3, #12]
 8002162:	9a00      	ldr	r2, [sp, #0]
 8002164:	601a      	str	r2, [r3, #0]
}
 8002166:	bf00      	nop
 8002168:	b003      	add	sp, #12
 800216a:	f85d fb04 	ldr.w	pc, [sp], #4
 800216e:	bf00      	nop
 8002170:	08004b68 	.word	0x08004b68
	...

08002180 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8002180:	bf00      	nop
 8002182:	4770      	bx	lr
	...

08002190 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8002190:	b090      	sub	sp, #64	@ 0x40
 8002192:	9003      	str	r0, [sp, #12]
 8002194:	9102      	str	r1, [sp, #8]
 8002196:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8002198:	9b01      	ldr	r3, [sp, #4]
 800219a:	f003 0303 	and.w	r3, r3, #3
 800219e:	930f      	str	r3, [sp, #60]	@ 0x3c
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80021a0:	9b01      	ldr	r3, [sp, #4]
 80021a2:	089b      	lsrs	r3, r3, #2
 80021a4:	f003 0301 	and.w	r3, r3, #1
 80021a8:	930e      	str	r3, [sp, #56]	@ 0x38
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80021aa:	9b01      	ldr	r3, [sp, #4]
 80021ac:	08db      	lsrs	r3, r3, #3
 80021ae:	f003 0303 	and.w	r3, r3, #3
 80021b2:	930d      	str	r3, [sp, #52]	@ 0x34
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80021b4:	9b01      	ldr	r3, [sp, #4]
 80021b6:	095b      	lsrs	r3, r3, #5
 80021b8:	f003 0303 	and.w	r3, r3, #3
 80021bc:	930c      	str	r3, [sp, #48]	@ 0x30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80021be:	9b01      	ldr	r3, [sp, #4]
 80021c0:	09db      	lsrs	r3, r3, #7
 80021c2:	f003 030f 	and.w	r3, r3, #15
 80021c6:	9309      	str	r3, [sp, #36]	@ 0x24
  uint32_t ascr    = (mode & PAL_STM32_ASCR_MASK) >> 11;
 80021c8:	9b01      	ldr	r3, [sp, #4]
 80021ca:	0adb      	lsrs	r3, r3, #11
 80021cc:	f003 0301 	and.w	r3, r3, #1
 80021d0:	930b      	str	r3, [sp, #44]	@ 0x2c
  uint32_t lockr   = (mode & PAL_STM32_LOCKR_MASK) >> 12;
 80021d2:	9b01      	ldr	r3, [sp, #4]
 80021d4:	0b1b      	lsrs	r3, r3, #12
 80021d6:	f003 0301 	and.w	r3, r3, #1
 80021da:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 80021dc:	2300      	movs	r3, #0
 80021de:	930a      	str	r3, [sp, #40]	@ 0x28
  while (true) {
    if ((mask & 1) != 0) {
 80021e0:	9b02      	ldr	r3, [sp, #8]
 80021e2:	f003 0301 	and.w	r3, r3, #1
 80021e6:	2b00      	cmp	r3, #0
 80021e8:	f000 808c 	beq.w	8002304 <_pal_lld_setgroupmode+0x174>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80021ec:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80021ee:	f003 0307 	and.w	r3, r3, #7
 80021f2:	009b      	lsls	r3, r3, #2
 80021f4:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80021f6:	fa02 f303 	lsl.w	r3, r2, r3
 80021fa:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 80021fc:	2201      	movs	r2, #1
 80021fe:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002200:	fa02 f303 	lsl.w	r3, r2, r3
 8002204:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8002206:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002208:	005b      	lsls	r3, r3, #1
 800220a:	2203      	movs	r2, #3
 800220c:	fa02 f303 	lsl.w	r3, r2, r3
 8002210:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8002212:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002214:	f003 0307 	and.w	r3, r3, #7
 8002218:	009b      	lsls	r3, r3, #2
 800221a:	220f      	movs	r2, #15
 800221c:	fa02 f303 	lsl.w	r3, r2, r3
 8002220:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8002222:	9b03      	ldr	r3, [sp, #12]
 8002224:	685a      	ldr	r2, [r3, #4]
 8002226:	9b06      	ldr	r3, [sp, #24]
 8002228:	43db      	mvns	r3, r3
 800222a:	401a      	ands	r2, r3
 800222c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 800222e:	431a      	orrs	r2, r3
 8002230:	9b03      	ldr	r3, [sp, #12]
 8002232:	605a      	str	r2, [r3, #4]
      port->ASCR    = (port->ASCR & ~m1) | ascr;
 8002234:	9b03      	ldr	r3, [sp, #12]
 8002236:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8002238:	9b06      	ldr	r3, [sp, #24]
 800223a:	43db      	mvns	r3, r3
 800223c:	401a      	ands	r2, r3
 800223e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8002240:	431a      	orrs	r2, r3
 8002242:	9b03      	ldr	r3, [sp, #12]
 8002244:	62da      	str	r2, [r3, #44]	@ 0x2c
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8002246:	9b03      	ldr	r3, [sp, #12]
 8002248:	689a      	ldr	r2, [r3, #8]
 800224a:	9b05      	ldr	r3, [sp, #20]
 800224c:	43db      	mvns	r3, r3
 800224e:	401a      	ands	r2, r3
 8002250:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8002252:	431a      	orrs	r2, r3
 8002254:	9b03      	ldr	r3, [sp, #12]
 8002256:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8002258:	9b03      	ldr	r3, [sp, #12]
 800225a:	68da      	ldr	r2, [r3, #12]
 800225c:	9b05      	ldr	r3, [sp, #20]
 800225e:	43db      	mvns	r3, r3
 8002260:	401a      	ands	r2, r3
 8002262:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8002264:	431a      	orrs	r2, r3
 8002266:	9b03      	ldr	r3, [sp, #12]
 8002268:	60da      	str	r2, [r3, #12]
       if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800226a:	9b01      	ldr	r3, [sp, #4]
 800226c:	f003 0303 	and.w	r3, r3, #3
 8002270:	2b02      	cmp	r3, #2
 8002272:	d11f      	bne.n	80022b4 <_pal_lld_setgroupmode+0x124>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8002274:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002276:	2b07      	cmp	r3, #7
 8002278:	d809      	bhi.n	800228e <_pal_lld_setgroupmode+0xfe>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800227a:	9b03      	ldr	r3, [sp, #12]
 800227c:	6a1a      	ldr	r2, [r3, #32]
 800227e:	9b04      	ldr	r3, [sp, #16]
 8002280:	43db      	mvns	r3, r3
 8002282:	401a      	ands	r2, r3
 8002284:	9b07      	ldr	r3, [sp, #28]
 8002286:	431a      	orrs	r2, r3
 8002288:	9b03      	ldr	r3, [sp, #12]
 800228a:	621a      	str	r2, [r3, #32]
 800228c:	e008      	b.n	80022a0 <_pal_lld_setgroupmode+0x110>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800228e:	9b03      	ldr	r3, [sp, #12]
 8002290:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8002292:	9b04      	ldr	r3, [sp, #16]
 8002294:	43db      	mvns	r3, r3
 8002296:	401a      	ands	r2, r3
 8002298:	9b07      	ldr	r3, [sp, #28]
 800229a:	431a      	orrs	r2, r3
 800229c:	9b03      	ldr	r3, [sp, #12]
 800229e:	625a      	str	r2, [r3, #36]	@ 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 80022a0:	9b03      	ldr	r3, [sp, #12]
 80022a2:	681a      	ldr	r2, [r3, #0]
 80022a4:	9b05      	ldr	r3, [sp, #20]
 80022a6:	43db      	mvns	r3, r3
 80022a8:	401a      	ands	r2, r3
 80022aa:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80022ac:	431a      	orrs	r2, r3
 80022ae:	9b03      	ldr	r3, [sp, #12]
 80022b0:	601a      	str	r2, [r3, #0]
 80022b2:	e01e      	b.n	80022f2 <_pal_lld_setgroupmode+0x162>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80022b4:	9b03      	ldr	r3, [sp, #12]
 80022b6:	681a      	ldr	r2, [r3, #0]
 80022b8:	9b05      	ldr	r3, [sp, #20]
 80022ba:	43db      	mvns	r3, r3
 80022bc:	401a      	ands	r2, r3
 80022be:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80022c0:	431a      	orrs	r2, r3
 80022c2:	9b03      	ldr	r3, [sp, #12]
 80022c4:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 80022c6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80022c8:	2b07      	cmp	r3, #7
 80022ca:	d809      	bhi.n	80022e0 <_pal_lld_setgroupmode+0x150>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80022cc:	9b03      	ldr	r3, [sp, #12]
 80022ce:	6a1a      	ldr	r2, [r3, #32]
 80022d0:	9b04      	ldr	r3, [sp, #16]
 80022d2:	43db      	mvns	r3, r3
 80022d4:	401a      	ands	r2, r3
 80022d6:	9b07      	ldr	r3, [sp, #28]
 80022d8:	431a      	orrs	r2, r3
 80022da:	9b03      	ldr	r3, [sp, #12]
 80022dc:	621a      	str	r2, [r3, #32]
 80022de:	e008      	b.n	80022f2 <_pal_lld_setgroupmode+0x162>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80022e0:	9b03      	ldr	r3, [sp, #12]
 80022e2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80022e4:	9b04      	ldr	r3, [sp, #16]
 80022e6:	43db      	mvns	r3, r3
 80022e8:	401a      	ands	r2, r3
 80022ea:	9b07      	ldr	r3, [sp, #28]
 80022ec:	431a      	orrs	r2, r3
 80022ee:	9b03      	ldr	r3, [sp, #12]
 80022f0:	625a      	str	r2, [r3, #36]	@ 0x24
      }
      port->LOCKR   = (port->LOCKR & ~m1) | lockr;
 80022f2:	9b03      	ldr	r3, [sp, #12]
 80022f4:	69da      	ldr	r2, [r3, #28]
 80022f6:	9b06      	ldr	r3, [sp, #24]
 80022f8:	43db      	mvns	r3, r3
 80022fa:	401a      	ands	r2, r3
 80022fc:	9b08      	ldr	r3, [sp, #32]
 80022fe:	431a      	orrs	r2, r3
 8002300:	9b03      	ldr	r3, [sp, #12]
 8002302:	61da      	str	r2, [r3, #28]
    }
    mask >>= 1;
 8002304:	9b02      	ldr	r3, [sp, #8]
 8002306:	085b      	lsrs	r3, r3, #1
 8002308:	9302      	str	r3, [sp, #8]
    if (!mask)
 800230a:	9b02      	ldr	r3, [sp, #8]
 800230c:	2b00      	cmp	r3, #0
 800230e:	d012      	beq.n	8002336 <_pal_lld_setgroupmode+0x1a6>
      return;
    otyper <<= 1;
 8002310:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8002312:	005b      	lsls	r3, r3, #1
 8002314:	930e      	str	r3, [sp, #56]	@ 0x38
    ascr <<= 1;
 8002316:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8002318:	005b      	lsls	r3, r3, #1
 800231a:	930b      	str	r3, [sp, #44]	@ 0x2c
    ospeedr <<= 2;
 800231c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800231e:	009b      	lsls	r3, r3, #2
 8002320:	930d      	str	r3, [sp, #52]	@ 0x34
    pupdr <<= 2;
 8002322:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8002324:	009b      	lsls	r3, r3, #2
 8002326:	930c      	str	r3, [sp, #48]	@ 0x30
    moder <<= 2;
 8002328:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800232a:	009b      	lsls	r3, r3, #2
 800232c:	930f      	str	r3, [sp, #60]	@ 0x3c
    bit++;
 800232e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002330:	3301      	adds	r3, #1
 8002332:	930a      	str	r3, [sp, #40]	@ 0x28
    if ((mask & 1) != 0) {
 8002334:	e754      	b.n	80021e0 <_pal_lld_setgroupmode+0x50>
      return;
 8002336:	bf00      	nop
  }
}
 8002338:	b010      	add	sp, #64	@ 0x40
 800233a:	4770      	bx	lr
 800233c:	0000      	movs	r0, r0
	...

08002340 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 8002340:	b500      	push	{lr}
 8002342:	b083      	sub	sp, #12
 8002344:	2330      	movs	r3, #48	@ 0x30
 8002346:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002348:	9b01      	ldr	r3, [sp, #4]
 800234a:	f383 8811 	msr	BASEPRI, r3
}
 800234e:	bf00      	nop
}
 8002350:	bf00      	nop
}
 8002352:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002354:	f000 faf4 	bl	8002940 <__dbg_check_lock_from_isr>
}
 8002358:	bf00      	nop
 800235a:	b003      	add	sp, #12
 800235c:	f85d fb04 	ldr.w	pc, [sp], #4

08002360 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8002360:	b500      	push	{lr}
 8002362:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002364:	f000 fb14 	bl	8002990 <__dbg_check_unlock_from_isr>
 8002368:	2300      	movs	r3, #0
 800236a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800236c:	9b01      	ldr	r3, [sp, #4]
 800236e:	f383 8811 	msr	BASEPRI, r3
}
 8002372:	bf00      	nop
}
 8002374:	bf00      	nop
}
 8002376:	bf00      	nop
}
 8002378:	bf00      	nop
 800237a:	b003      	add	sp, #12
 800237c:	f85d fb04 	ldr.w	pc, [sp], #4

08002380 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 8002380:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002382:	f7ff ffdd 	bl	8002340 <chSysLockFromISR.lto_priv.1>
}
 8002386:	bf00      	nop
 8002388:	bd08      	pop	{r3, pc}
 800238a:	bf00      	nop
 800238c:	0000      	movs	r0, r0
	...

08002390 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 8002390:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002392:	f7ff ffe5 	bl	8002360 <chSysUnlockFromISR.lto_priv.1>
}
 8002396:	bf00      	nop
 8002398:	bd08      	pop	{r3, pc}
 800239a:	bf00      	nop
 800239c:	0000      	movs	r0, r0
	...

080023a0 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 80023a0:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 80023a2:	f000 fa65 	bl	8002870 <chSysTimerHandlerI>
}
 80023a6:	bf00      	nop
 80023a8:	bd08      	pop	{r3, pc}
 80023aa:	bf00      	nop
 80023ac:	0000      	movs	r0, r0
	...

080023b0 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80023b0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80023b4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80023b6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80023ba:	f043 0301 	orr.w	r3, r3, #1
 80023be:	6593      	str	r3, [r2, #88]	@ 0x58
 80023c0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80023c4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80023c6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80023ca:	f043 0301 	orr.w	r3, r3, #1
 80023ce:	6793      	str	r3, [r2, #120]	@ 0x78
 80023d0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80023d4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80023d6:	4b15      	ldr	r3, [pc, #84]	@ (800242c <st_lld_init+0x7c>)
 80023d8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80023da:	4a14      	ldr	r2, [pc, #80]	@ (800242c <st_lld_init+0x7c>)
 80023dc:	f043 0301 	orr.w	r3, r3, #1
 80023e0:	63d3      	str	r3, [r2, #60]	@ 0x3c

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80023e2:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80023e6:	f241 22bf 	movw	r2, #4799	@ 0x12bf
 80023ea:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80023ec:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80023f0:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80023f4:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80023f6:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80023fa:	2200      	movs	r2, #0
 80023fc:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80023fe:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002402:	2200      	movs	r2, #0
 8002404:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 8002406:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800240a:	2200      	movs	r2, #0
 800240c:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 800240e:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002412:	2200      	movs	r2, #0
 8002414:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002416:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800241a:	2201      	movs	r2, #1
 800241c:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800241e:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002422:	2201      	movs	r2, #1
 8002424:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8002426:	bf00      	nop
 8002428:	4770      	bx	lr
 800242a:	bf00      	nop
 800242c:	e0042000 	.word	0xe0042000

08002430 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8002430:	b500      	push	{lr}
 8002432:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8002434:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002438:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 800243a:	9b01      	ldr	r3, [sp, #4]
 800243c:	691b      	ldr	r3, [r3, #16]
 800243e:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002440:	9b01      	ldr	r3, [sp, #4]
 8002442:	68db      	ldr	r3, [r3, #12]
 8002444:	b2db      	uxtb	r3, r3
 8002446:	9a00      	ldr	r2, [sp, #0]
 8002448:	4013      	ands	r3, r2
 800244a:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 800244c:	9b00      	ldr	r3, [sp, #0]
 800244e:	43da      	mvns	r2, r3
 8002450:	9b01      	ldr	r3, [sp, #4]
 8002452:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8002454:	9b00      	ldr	r3, [sp, #0]
 8002456:	f003 0302 	and.w	r3, r3, #2
 800245a:	2b00      	cmp	r3, #0
 800245c:	d005      	beq.n	800246a <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 800245e:	f7ff ff8f 	bl	8002380 <osalSysLockFromISR.lto_priv.1>
    osalOsTimerHandlerI();
 8002462:	f7ff ff9d 	bl	80023a0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8002466:	f7ff ff93 	bl	8002390 <osalSysUnlockFromISR.lto_priv.1>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 800246a:	bf00      	nop
 800246c:	b003      	add	sp, #12
 800246e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002472:	bf00      	nop
	...

08002480 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8002480:	b508      	push	{r3, lr}

#if STM32_GPT_USE_TIM1
  /* Driver initialization.*/
  GPTD1.tim = STM32_TIM1;
 8002482:	4b04      	ldr	r3, [pc, #16]	@ (8002494 <gpt_lld_init+0x14>)
 8002484:	4a04      	ldr	r2, [pc, #16]	@ (8002498 <gpt_lld_init+0x18>)
 8002486:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD1);
 8002488:	4802      	ldr	r0, [pc, #8]	@ (8002494 <gpt_lld_init+0x14>)
 800248a:	f7fe fa41 	bl	8000910 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 800248e:	bf00      	nop
 8002490:	bd08      	pop	{r3, pc}
 8002492:	bf00      	nop
 8002494:	200008cc 	.word	0x200008cc
 8002498:	40012c00 	.word	0x40012c00
 800249c:	00000000 	.word	0x00000000

080024a0 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 80024a0:	b084      	sub	sp, #16
 80024a2:	9001      	str	r0, [sp, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 80024a4:	9b01      	ldr	r3, [sp, #4]
 80024a6:	781b      	ldrb	r3, [r3, #0]
 80024a8:	2b01      	cmp	r3, #1
 80024aa:	d12f      	bne.n	800250c <gpt_lld_start+0x6c>
    /* Clock activation.*/
#if STM32_GPT_USE_TIM1
    if (&GPTD1 == gptp) {
 80024ac:	9b01      	ldr	r3, [sp, #4]
 80024ae:	4a2c      	ldr	r2, [pc, #176]	@ (8002560 <gpt_lld_start+0xc0>)
 80024b0:	4293      	cmp	r3, r2
 80024b2:	d12b      	bne.n	800250c <gpt_lld_start+0x6c>
      rccEnableTIM1(true);
 80024b4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80024b8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80024ba:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80024be:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80024c2:	6613      	str	r3, [r2, #96]	@ 0x60
 80024c4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80024c8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 80024cc:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80024d0:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80024d4:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 80024d8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80024dc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
      rccResetTIM1();
 80024e0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80024e4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80024e6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80024ea:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80024ee:	6413      	str	r3, [r2, #64]	@ 0x40
 80024f0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80024f4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80024f6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80024fa:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 80024fe:	6413      	str	r3, [r2, #64]	@ 0x40
 8002500:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002504:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_GPT_TIM1_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM1CLK)
      gptp->clock = STM32_TIM1CLK;
#else
      gptp->clock = STM32_TIMCLK2;
 8002506:	9b01      	ldr	r3, [sp, #4]
 8002508:	4a16      	ldr	r2, [pc, #88]	@ (8002564 <gpt_lld_start+0xc4>)
 800250a:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 800250c:	9b01      	ldr	r3, [sp, #4]
 800250e:	689a      	ldr	r2, [r3, #8]
 8002510:	9b01      	ldr	r3, [sp, #4]
 8002512:	685b      	ldr	r3, [r3, #4]
 8002514:	681b      	ldr	r3, [r3, #0]
 8002516:	fbb2 f3f3 	udiv	r3, r2, r3
 800251a:	b29b      	uxth	r3, r3
 800251c:	3b01      	subs	r3, #1
 800251e:	f8ad 300e 	strh.w	r3, [sp, #14]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0U;                         /* Initially stopped.       */
 8002522:	9b01      	ldr	r3, [sp, #4]
 8002524:	68db      	ldr	r3, [r3, #12]
 8002526:	2200      	movs	r2, #0
 8002528:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 800252a:	9b01      	ldr	r3, [sp, #4]
 800252c:	685a      	ldr	r2, [r3, #4]
 800252e:	9b01      	ldr	r3, [sp, #4]
 8002530:	68db      	ldr	r3, [r3, #12]
 8002532:	6892      	ldr	r2, [r2, #8]
 8002534:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8002536:	9b01      	ldr	r3, [sp, #4]
 8002538:	68db      	ldr	r3, [r3, #12]
 800253a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 800253e:	629a      	str	r2, [r3, #40]	@ 0x28
  gptp->tim->SR   = 0U;                         /* Clear pending IRQs.      */
 8002540:	9b01      	ldr	r3, [sp, #4]
 8002542:	68db      	ldr	r3, [r3, #12]
 8002544:	2200      	movs	r2, #0
 8002546:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 8002548:	9b01      	ldr	r3, [sp, #4]
 800254a:	685b      	ldr	r3, [r3, #4]
 800254c:	68da      	ldr	r2, [r3, #12]
 800254e:	9b01      	ldr	r3, [sp, #4]
 8002550:	68db      	ldr	r3, [r3, #12]
 8002552:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002556:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 8002558:	bf00      	nop
 800255a:	b004      	add	sp, #16
 800255c:	4770      	bx	lr
 800255e:	bf00      	nop
 8002560:	200008cc 	.word	0x200008cc
 8002564:	02dc6c00 	.word	0x02dc6c00
	...

08002570 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 8002570:	b082      	sub	sp, #8
 8002572:	9001      	str	r0, [sp, #4]
 8002574:	9100      	str	r1, [sp, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8002576:	9b01      	ldr	r3, [sp, #4]
 8002578:	68db      	ldr	r3, [r3, #12]
 800257a:	9a00      	ldr	r2, [sp, #0]
 800257c:	3a01      	subs	r2, #1
 800257e:	62da      	str	r2, [r3, #44]	@ 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 8002580:	9b01      	ldr	r3, [sp, #4]
 8002582:	68db      	ldr	r3, [r3, #12]
 8002584:	2201      	movs	r2, #1
 8002586:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0U;                          /* Reset counter.           */
 8002588:	9b01      	ldr	r3, [sp, #4]
 800258a:	68db      	ldr	r3, [r3, #12]
 800258c:	2200      	movs	r2, #0
 800258e:	625a      	str	r2, [r3, #36]	@ 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8002590:	9b01      	ldr	r3, [sp, #4]
 8002592:	68db      	ldr	r3, [r3, #12]
 8002594:	2200      	movs	r2, #0
 8002596:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8002598:	9b01      	ldr	r3, [sp, #4]
 800259a:	685b      	ldr	r3, [r3, #4]
 800259c:	685b      	ldr	r3, [r3, #4]
 800259e:	2b00      	cmp	r3, #0
 80025a0:	d007      	beq.n	80025b2 <gpt_lld_start_timer+0x42>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 80025a2:	9b01      	ldr	r3, [sp, #4]
 80025a4:	68db      	ldr	r3, [r3, #12]
 80025a6:	68da      	ldr	r2, [r3, #12]
 80025a8:	9b01      	ldr	r3, [sp, #4]
 80025aa:	68db      	ldr	r3, [r3, #12]
 80025ac:	f042 0201 	orr.w	r2, r2, #1
 80025b0:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 80025b2:	9b01      	ldr	r3, [sp, #4]
 80025b4:	68db      	ldr	r3, [r3, #12]
 80025b6:	2285      	movs	r2, #133	@ 0x85
 80025b8:	601a      	str	r2, [r3, #0]
}
 80025ba:	bf00      	nop
 80025bc:	b002      	add	sp, #8
 80025be:	4770      	bx	lr

080025c0 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 80025c0:	b082      	sub	sp, #8
 80025c2:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1 = 0U;                          /* Initially stopped.       */
 80025c4:	9b01      	ldr	r3, [sp, #4]
 80025c6:	68db      	ldr	r3, [r3, #12]
 80025c8:	2200      	movs	r2, #0
 80025ca:	601a      	str	r2, [r3, #0]
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 80025cc:	9b01      	ldr	r3, [sp, #4]
 80025ce:	68db      	ldr	r3, [r3, #12]
 80025d0:	2200      	movs	r2, #0
 80025d2:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 80025d4:	9b01      	ldr	r3, [sp, #4]
 80025d6:	68db      	ldr	r3, [r3, #12]
 80025d8:	68da      	ldr	r2, [r3, #12]
 80025da:	9b01      	ldr	r3, [sp, #4]
 80025dc:	68db      	ldr	r3, [r3, #12]
 80025de:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 80025e2:	60da      	str	r2, [r3, #12]
}
 80025e4:	bf00      	nop
 80025e6:	b002      	add	sp, #8
 80025e8:	4770      	bx	lr
 80025ea:	bf00      	nop
 80025ec:	0000      	movs	r0, r0
	...

080025f0 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 80025f0:	b500      	push	{lr}
 80025f2:	b085      	sub	sp, #20
 80025f4:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 80025f6:	9b01      	ldr	r3, [sp, #4]
 80025f8:	68db      	ldr	r3, [r3, #12]
 80025fa:	691b      	ldr	r3, [r3, #16]
 80025fc:	9303      	str	r3, [sp, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 80025fe:	9b01      	ldr	r3, [sp, #4]
 8002600:	68db      	ldr	r3, [r3, #12]
 8002602:	68db      	ldr	r3, [r3, #12]
 8002604:	b2db      	uxtb	r3, r3
 8002606:	9a03      	ldr	r2, [sp, #12]
 8002608:	4013      	ands	r3, r2
 800260a:	9303      	str	r3, [sp, #12]
  gptp->tim->SR = ~sr;
 800260c:	9b01      	ldr	r3, [sp, #4]
 800260e:	68db      	ldr	r3, [r3, #12]
 8002610:	9a03      	ldr	r2, [sp, #12]
 8002612:	43d2      	mvns	r2, r2
 8002614:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8002616:	9b03      	ldr	r3, [sp, #12]
 8002618:	f003 0301 	and.w	r3, r3, #1
 800261c:	2b00      	cmp	r3, #0
 800261e:	d013      	beq.n	8002648 <gpt_lld_serve_interrupt+0x58>
    _gpt_isr_invoke_cb(gptp);
 8002620:	9b01      	ldr	r3, [sp, #4]
 8002622:	781b      	ldrb	r3, [r3, #0]
 8002624:	2b04      	cmp	r3, #4
 8002626:	d105      	bne.n	8002634 <gpt_lld_serve_interrupt+0x44>
 8002628:	9b01      	ldr	r3, [sp, #4]
 800262a:	2202      	movs	r2, #2
 800262c:	701a      	strb	r2, [r3, #0]
 800262e:	9801      	ldr	r0, [sp, #4]
 8002630:	f7ff ffc6 	bl	80025c0 <gpt_lld_stop_timer>
 8002634:	9b01      	ldr	r3, [sp, #4]
 8002636:	685b      	ldr	r3, [r3, #4]
 8002638:	685b      	ldr	r3, [r3, #4]
 800263a:	2b00      	cmp	r3, #0
 800263c:	d004      	beq.n	8002648 <gpt_lld_serve_interrupt+0x58>
 800263e:	9b01      	ldr	r3, [sp, #4]
 8002640:	685b      	ldr	r3, [r3, #4]
 8002642:	685b      	ldr	r3, [r3, #4]
 8002644:	9801      	ldr	r0, [sp, #4]
 8002646:	4798      	blx	r3
  }
}
 8002648:	bf00      	nop
 800264a:	b005      	add	sp, #20
 800264c:	f85d fb04 	ldr.w	pc, [sp], #4

08002650 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8002650:	b082      	sub	sp, #8
 8002652:	9001      	str	r0, [sp, #4]
 8002654:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8002656:	9b00      	ldr	r3, [sp, #0]
 8002658:	685a      	ldr	r2, [r3, #4]
 800265a:	9b01      	ldr	r3, [sp, #4]
 800265c:	605a      	str	r2, [r3, #4]
  gpiop->ASCR    = config->ascr;
 800265e:	9b00      	ldr	r3, [sp, #0]
 8002660:	69da      	ldr	r2, [r3, #28]
 8002662:	9b01      	ldr	r3, [sp, #4]
 8002664:	62da      	str	r2, [r3, #44]	@ 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8002666:	9b00      	ldr	r3, [sp, #0]
 8002668:	689a      	ldr	r2, [r3, #8]
 800266a:	9b01      	ldr	r3, [sp, #4]
 800266c:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800266e:	9b00      	ldr	r3, [sp, #0]
 8002670:	68da      	ldr	r2, [r3, #12]
 8002672:	9b01      	ldr	r3, [sp, #4]
 8002674:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8002676:	9b00      	ldr	r3, [sp, #0]
 8002678:	691a      	ldr	r2, [r3, #16]
 800267a:	9b01      	ldr	r3, [sp, #4]
 800267c:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800267e:	9b00      	ldr	r3, [sp, #0]
 8002680:	695a      	ldr	r2, [r3, #20]
 8002682:	9b01      	ldr	r3, [sp, #4]
 8002684:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8002686:	9b00      	ldr	r3, [sp, #0]
 8002688:	699a      	ldr	r2, [r3, #24]
 800268a:	9b01      	ldr	r3, [sp, #4]
 800268c:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 800268e:	9b00      	ldr	r3, [sp, #0]
 8002690:	681a      	ldr	r2, [r3, #0]
 8002692:	9b01      	ldr	r3, [sp, #4]
 8002694:	601a      	str	r2, [r3, #0]
  gpiop->LOCKR   = config->lockr;
 8002696:	9b00      	ldr	r3, [sp, #0]
 8002698:	6a1a      	ldr	r2, [r3, #32]
 800269a:	9b01      	ldr	r3, [sp, #4]
 800269c:	61da      	str	r2, [r3, #28]
}
 800269e:	bf00      	nop
 80026a0:	b002      	add	sp, #8
 80026a2:	4770      	bx	lr
	...

080026b0 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 80026b0:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB2(STM32_GPIO_EN_MASK);
 80026b2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80026b6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80026b8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80026bc:	f043 0307 	orr.w	r3, r3, #7
 80026c0:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80026c2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80026c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80026c8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80026cc:	f023 0307 	bic.w	r3, r3, #7
 80026d0:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80026d2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80026d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 80026d8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80026dc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80026de:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80026e2:	f043 0307 	orr.w	r3, r3, #7
 80026e6:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80026e8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80026ec:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80026ee:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80026f2:	f043 0307 	orr.w	r3, r3, #7
 80026f6:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80026f8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80026fc:	6edb      	ldr	r3, [r3, #108]	@ 0x6c

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 80026fe:	4907      	ldr	r1, [pc, #28]	@ (800271c <stm32_gpio_init+0x6c>)
 8002700:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8002704:	f7ff ffa4 	bl	8002650 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8002708:	4905      	ldr	r1, [pc, #20]	@ (8002720 <stm32_gpio_init+0x70>)
 800270a:	4806      	ldr	r0, [pc, #24]	@ (8002724 <stm32_gpio_init+0x74>)
 800270c:	f7ff ffa0 	bl	8002650 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 8002710:	4905      	ldr	r1, [pc, #20]	@ (8002728 <stm32_gpio_init+0x78>)
 8002712:	4806      	ldr	r0, [pc, #24]	@ (800272c <stm32_gpio_init+0x7c>)
 8002714:	f7ff ff9c 	bl	8002650 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8002718:	bf00      	nop
 800271a:	bd08      	pop	{r3, pc}
 800271c:	08004b7c 	.word	0x08004b7c
 8002720:	08004ba0 	.word	0x08004ba0
 8002724:	48000400 	.word	0x48000400
 8002728:	08004bc4 	.word	0x08004bc4
 800272c:	48000800 	.word	0x48000800

08002730 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8002730:	b508      	push	{r3, lr}

  stm32_gpio_init();
 8002732:	f7ff ffbd 	bl	80026b0 <stm32_gpio_init>
  stm32_clock_init();
 8002736:	f7fe fc4b 	bl	8000fd0 <stm32_clock_init>
}
 800273a:	bf00      	nop
 800273c:	bd08      	pop	{r3, pc}
 800273e:	bf00      	nop

08002740 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 8002740:	bf00      	nop
 8002742:	4770      	bx	lr
	...

08002750 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 8002750:	b500      	push	{lr}
 8002752:	b08b      	sub	sp, #44	@ 0x2c
 8002754:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8002756:	9b01      	ldr	r3, [sp, #4]
 8002758:	2200      	movs	r2, #0
 800275a:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 800275c:	ab02      	add	r3, sp, #8
 800275e:	4618      	mov	r0, r3
 8002760:	f001 fbce 	bl	8003f00 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 8002764:	2304      	movs	r3, #4
 8002766:	9309      	str	r3, [sp, #36]	@ 0x24
  do {
    chTMStartMeasurementX(&tm);
 8002768:	ab02      	add	r3, sp, #8
 800276a:	4618      	mov	r0, r3
 800276c:	f001 fbe8 	bl	8003f40 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8002770:	ab02      	add	r3, sp, #8
 8002772:	4618      	mov	r0, r3
 8002774:	f001 fbf4 	bl	8003f60 <chTMStopMeasurementX>
    i--;
 8002778:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800277a:	3b01      	subs	r3, #1
 800277c:	9309      	str	r3, [sp, #36]	@ 0x24
  } while (i > 0U);
 800277e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002780:	2b00      	cmp	r3, #0
 8002782:	d1f1      	bne.n	8002768 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
 8002784:	9a02      	ldr	r2, [sp, #8]
 8002786:	9b01      	ldr	r3, [sp, #4]
 8002788:	601a      	str	r2, [r3, #0]
}
 800278a:	bf00      	nop
 800278c:	b00b      	add	sp, #44	@ 0x2c
 800278e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002792:	bf00      	nop
	...

080027a0 <chSysUnlock.lto_priv.6>:
static inline void chSysUnlock(void) {
 80027a0:	b500      	push	{lr}
 80027a2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80027a4:	f000 f8a4 	bl	80028f0 <__dbg_check_unlock>
 80027a8:	2300      	movs	r3, #0
 80027aa:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80027ac:	9b01      	ldr	r3, [sp, #4]
 80027ae:	f383 8811 	msr	BASEPRI, r3
}
 80027b2:	bf00      	nop
}
 80027b4:	bf00      	nop
}
 80027b6:	bf00      	nop
 80027b8:	b003      	add	sp, #12
 80027ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80027be:	bf00      	nop

080027c0 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 80027c0:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 80027c2:	f001 fd8d 	bl	80042e0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 80027c6:	f001 fdfb 	bl	80043c0 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 80027ca:	f001 fe91 	bl	80044f0 <__factory_init>
#endif
}
 80027ce:	bf00      	nop
 80027d0:	bd08      	pop	{r3, pc}
 80027d2:	bf00      	nop
	...

080027e0 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 80027e0:	b500      	push	{lr}
 80027e2:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 80027e4:	4b11      	ldr	r3, [pc, #68]	@ (800282c <chSysInit+0x4c>)
 80027e6:	2201      	movs	r2, #1
 80027e8:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80027ea:	2300      	movs	r3, #0
 80027ec:	9301      	str	r3, [sp, #4]
 80027ee:	e008      	b.n	8002802 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
 80027f0:	4a0e      	ldr	r2, [pc, #56]	@ (800282c <chSysInit+0x4c>)
 80027f2:	9b01      	ldr	r3, [sp, #4]
 80027f4:	009b      	lsls	r3, r3, #2
 80027f6:	4413      	add	r3, r2
 80027f8:	2200      	movs	r2, #0
 80027fa:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80027fc:	9b01      	ldr	r3, [sp, #4]
 80027fe:	3301      	adds	r3, #1
 8002800:	9301      	str	r3, [sp, #4]
 8002802:	9b01      	ldr	r3, [sp, #4]
 8002804:	2b00      	cmp	r3, #0
 8002806:	d0f3      	beq.n	80027f0 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 8002808:	4809      	ldr	r0, [pc, #36]	@ (8002830 <chSysInit+0x50>)
 800280a:	f7ff ffa1 	bl	8002750 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 800280e:	f7ff ffd7 	bl	80027c0 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 8002812:	4908      	ldr	r1, [pc, #32]	@ (8002834 <chSysInit+0x54>)
 8002814:	4808      	ldr	r0, [pc, #32]	@ (8002838 <chSysInit+0x58>)
 8002816:	f001 f81b 	bl	8003850 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 800281a:	4b04      	ldr	r3, [pc, #16]	@ (800282c <chSysInit+0x4c>)
 800281c:	2202      	movs	r2, #2
 800281e:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 8002820:	f7ff ffbe 	bl	80027a0 <chSysUnlock.lto_priv.6>
}
 8002824:	bf00      	nop
 8002826:	b003      	add	sp, #12
 8002828:	f85d fb04 	ldr.w	pc, [sp], #4
 800282c:	200008dc 	.word	0x200008dc
 8002830:	200008e4 	.word	0x200008e4
 8002834:	08004c50 	.word	0x08004c50
 8002838:	200008e8 	.word	0x200008e8
 800283c:	00000000 	.word	0x00000000

08002840 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002840:	b082      	sub	sp, #8
 8002842:	9001      	str	r0, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8002844:	b672      	cpsid	i
}
 8002846:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 8002848:	bf00      	nop

  /* Logging the event.*/
  __trace_halt(reason);

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 800284a:	4a04      	ldr	r2, [pc, #16]	@ (800285c <chSysHalt+0x1c>)
 800284c:	9b01      	ldr	r3, [sp, #4]
 800284e:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8002852:	4b03      	ldr	r3, [pc, #12]	@ (8002860 <chSysHalt+0x20>)
 8002854:	2203      	movs	r2, #3
 8002856:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
     asm volatile ("nop");
 8002858:	bf00      	nop
 800285a:	e7fd      	b.n	8002858 <chSysHalt+0x18>
 800285c:	200008e8 	.word	0x200008e8
 8002860:	200008dc 	.word	0x200008dc
	...

08002870 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002870:	b508      	push	{r3, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 8002872:	f000 f92d 	bl	8002ad0 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8002876:	f000 fc1b 	bl	80030b0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800287a:	bf00      	nop
 800287c:	bd08      	pop	{r3, pc}
 800287e:	bf00      	nop

08002880 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 8002880:	b082      	sub	sp, #8
 8002882:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8002884:	4b04      	ldr	r3, [pc, #16]	@ (8002898 <chRFCUCollectFaultsI+0x18>)
 8002886:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8002888:	9b01      	ldr	r3, [sp, #4]
 800288a:	4313      	orrs	r3, r2
 800288c:	4a02      	ldr	r2, [pc, #8]	@ (8002898 <chRFCUCollectFaultsI+0x18>)
 800288e:	6353      	str	r3, [r2, #52]	@ 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8002890:	bf00      	nop
 8002892:	b002      	add	sp, #8
 8002894:	4770      	bx	lr
 8002896:	bf00      	nop
 8002898:	200008e8 	.word	0x200008e8
 800289c:	00000000 	.word	0x00000000

080028a0 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 80028a0:	b500      	push	{lr}
 80028a2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80028a4:	4b10      	ldr	r3, [pc, #64]	@ (80028e8 <__dbg_check_lock+0x48>)
 80028a6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80028a8:	9b01      	ldr	r3, [sp, #4]
 80028aa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80028ae:	2b00      	cmp	r3, #0
 80028b0:	bf14      	ite	ne
 80028b2:	2301      	movne	r3, #1
 80028b4:	2300      	moveq	r3, #0
 80028b6:	b2db      	uxtb	r3, r3
 80028b8:	2b00      	cmp	r3, #0
 80028ba:	d109      	bne.n	80028d0 <__dbg_check_lock+0x30>
 80028bc:	9b01      	ldr	r3, [sp, #4]
 80028be:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80028c2:	2b00      	cmp	r3, #0
 80028c4:	bf14      	ite	ne
 80028c6:	2301      	movne	r3, #1
 80028c8:	2300      	moveq	r3, #0
 80028ca:	b2db      	uxtb	r3, r3
 80028cc:	2b00      	cmp	r3, #0
 80028ce:	d002      	beq.n	80028d6 <__dbg_check_lock+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 80028d0:	4806      	ldr	r0, [pc, #24]	@ (80028ec <__dbg_check_lock+0x4c>)
 80028d2:	f7ff ffb5 	bl	8002840 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 80028d6:	9b01      	ldr	r3, [sp, #4]
 80028d8:	2201      	movs	r2, #1
 80028da:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 80028de:	bf00      	nop
 80028e0:	b003      	add	sp, #12
 80028e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80028e6:	bf00      	nop
 80028e8:	200008e8 	.word	0x200008e8
 80028ec:	08004bec 	.word	0x08004bec

080028f0 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 80028f0:	b500      	push	{lr}
 80028f2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80028f4:	4b10      	ldr	r3, [pc, #64]	@ (8002938 <__dbg_check_unlock+0x48>)
 80028f6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80028f8:	9b01      	ldr	r3, [sp, #4]
 80028fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80028fe:	2b00      	cmp	r3, #0
 8002900:	bf14      	ite	ne
 8002902:	2301      	movne	r3, #1
 8002904:	2300      	moveq	r3, #0
 8002906:	b2db      	uxtb	r3, r3
 8002908:	2b00      	cmp	r3, #0
 800290a:	d109      	bne.n	8002920 <__dbg_check_unlock+0x30>
 800290c:	9b01      	ldr	r3, [sp, #4]
 800290e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002912:	2b00      	cmp	r3, #0
 8002914:	bfd4      	ite	le
 8002916:	2301      	movle	r3, #1
 8002918:	2300      	movgt	r3, #0
 800291a:	b2db      	uxtb	r3, r3
 800291c:	2b00      	cmp	r3, #0
 800291e:	d002      	beq.n	8002926 <__dbg_check_unlock+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 8002920:	4806      	ldr	r0, [pc, #24]	@ (800293c <__dbg_check_unlock+0x4c>)
 8002922:	f7ff ff8d 	bl	8002840 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002926:	9b01      	ldr	r3, [sp, #4]
 8002928:	2200      	movs	r2, #0
 800292a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800292e:	bf00      	nop
 8002930:	b003      	add	sp, #12
 8002932:	f85d fb04 	ldr.w	pc, [sp], #4
 8002936:	bf00      	nop
 8002938:	200008e8 	.word	0x200008e8
 800293c:	08004bf4 	.word	0x08004bf4

08002940 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 8002940:	b500      	push	{lr}
 8002942:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002944:	4b10      	ldr	r3, [pc, #64]	@ (8002988 <__dbg_check_lock_from_isr+0x48>)
 8002946:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002948:	9b01      	ldr	r3, [sp, #4]
 800294a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800294e:	2b00      	cmp	r3, #0
 8002950:	bfd4      	ite	le
 8002952:	2301      	movle	r3, #1
 8002954:	2300      	movgt	r3, #0
 8002956:	b2db      	uxtb	r3, r3
 8002958:	2b00      	cmp	r3, #0
 800295a:	d109      	bne.n	8002970 <__dbg_check_lock_from_isr+0x30>
 800295c:	9b01      	ldr	r3, [sp, #4]
 800295e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002962:	2b00      	cmp	r3, #0
 8002964:	bf14      	ite	ne
 8002966:	2301      	movne	r3, #1
 8002968:	2300      	moveq	r3, #0
 800296a:	b2db      	uxtb	r3, r3
 800296c:	2b00      	cmp	r3, #0
 800296e:	d002      	beq.n	8002976 <__dbg_check_lock_from_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 8002970:	4806      	ldr	r0, [pc, #24]	@ (800298c <__dbg_check_lock_from_isr+0x4c>)
 8002972:	f7ff ff65 	bl	8002840 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002976:	9b01      	ldr	r3, [sp, #4]
 8002978:	2201      	movs	r2, #1
 800297a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800297e:	bf00      	nop
 8002980:	b003      	add	sp, #12
 8002982:	f85d fb04 	ldr.w	pc, [sp], #4
 8002986:	bf00      	nop
 8002988:	200008e8 	.word	0x200008e8
 800298c:	08004bfc 	.word	0x08004bfc

08002990 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 8002990:	b500      	push	{lr}
 8002992:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002994:	4b10      	ldr	r3, [pc, #64]	@ (80029d8 <__dbg_check_unlock_from_isr+0x48>)
 8002996:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002998:	9b01      	ldr	r3, [sp, #4]
 800299a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800299e:	2b00      	cmp	r3, #0
 80029a0:	bfd4      	ite	le
 80029a2:	2301      	movle	r3, #1
 80029a4:	2300      	movgt	r3, #0
 80029a6:	b2db      	uxtb	r3, r3
 80029a8:	2b00      	cmp	r3, #0
 80029aa:	d109      	bne.n	80029c0 <__dbg_check_unlock_from_isr+0x30>
 80029ac:	9b01      	ldr	r3, [sp, #4]
 80029ae:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80029b2:	2b00      	cmp	r3, #0
 80029b4:	bfd4      	ite	le
 80029b6:	2301      	movle	r3, #1
 80029b8:	2300      	movgt	r3, #0
 80029ba:	b2db      	uxtb	r3, r3
 80029bc:	2b00      	cmp	r3, #0
 80029be:	d002      	beq.n	80029c6 <__dbg_check_unlock_from_isr+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 80029c0:	4806      	ldr	r0, [pc, #24]	@ (80029dc <__dbg_check_unlock_from_isr+0x4c>)
 80029c2:	f7ff ff3d 	bl	8002840 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 80029c6:	9b01      	ldr	r3, [sp, #4]
 80029c8:	2200      	movs	r2, #0
 80029ca:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 80029ce:	bf00      	nop
 80029d0:	b003      	add	sp, #12
 80029d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80029d6:	bf00      	nop
 80029d8:	200008e8 	.word	0x200008e8
 80029dc:	08004c04 	.word	0x08004c04

080029e0 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 80029e0:	b500      	push	{lr}
 80029e2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80029e4:	4b18      	ldr	r3, [pc, #96]	@ (8002a48 <__dbg_check_enter_isr+0x68>)
 80029e6:	9303      	str	r3, [sp, #12]
 80029e8:	2330      	movs	r3, #48	@ 0x30
 80029ea:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80029ec:	9b02      	ldr	r3, [sp, #8]
 80029ee:	f383 8811 	msr	BASEPRI, r3
}
 80029f2:	bf00      	nop
}
 80029f4:	bf00      	nop
}
 80029f6:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80029f8:	9b03      	ldr	r3, [sp, #12]
 80029fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80029fe:	0fdb      	lsrs	r3, r3, #31
 8002a00:	b2db      	uxtb	r3, r3
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	d109      	bne.n	8002a1a <__dbg_check_enter_isr+0x3a>
 8002a06:	9b03      	ldr	r3, [sp, #12]
 8002a08:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002a0c:	2b00      	cmp	r3, #0
 8002a0e:	bf14      	ite	ne
 8002a10:	2301      	movne	r3, #1
 8002a12:	2300      	moveq	r3, #0
 8002a14:	b2db      	uxtb	r3, r3
 8002a16:	2b00      	cmp	r3, #0
 8002a18:	d002      	beq.n	8002a20 <__dbg_check_enter_isr+0x40>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 8002a1a:	480c      	ldr	r0, [pc, #48]	@ (8002a4c <__dbg_check_enter_isr+0x6c>)
 8002a1c:	f7ff ff10 	bl	8002840 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 8002a20:	9b03      	ldr	r3, [sp, #12]
 8002a22:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a26:	1c5a      	adds	r2, r3, #1
 8002a28:	9b03      	ldr	r3, [sp, #12]
 8002a2a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8002a2e:	2300      	movs	r3, #0
 8002a30:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002a32:	9b01      	ldr	r3, [sp, #4]
 8002a34:	f383 8811 	msr	BASEPRI, r3
}
 8002a38:	bf00      	nop
}
 8002a3a:	bf00      	nop
}
 8002a3c:	bf00      	nop
  port_unlock_from_isr();
}
 8002a3e:	bf00      	nop
 8002a40:	b005      	add	sp, #20
 8002a42:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a46:	bf00      	nop
 8002a48:	200008e8 	.word	0x200008e8
 8002a4c:	08004c0c 	.word	0x08004c0c

08002a50 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 8002a50:	b500      	push	{lr}
 8002a52:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8002a54:	4b19      	ldr	r3, [pc, #100]	@ (8002abc <__dbg_check_leave_isr+0x6c>)
 8002a56:	9303      	str	r3, [sp, #12]
 8002a58:	2330      	movs	r3, #48	@ 0x30
 8002a5a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002a5c:	9b02      	ldr	r3, [sp, #8]
 8002a5e:	f383 8811 	msr	BASEPRI, r3
}
 8002a62:	bf00      	nop
}
 8002a64:	bf00      	nop
}
 8002a66:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002a68:	9b03      	ldr	r3, [sp, #12]
 8002a6a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a6e:	2b00      	cmp	r3, #0
 8002a70:	bfd4      	ite	le
 8002a72:	2301      	movle	r3, #1
 8002a74:	2300      	movgt	r3, #0
 8002a76:	b2db      	uxtb	r3, r3
 8002a78:	2b00      	cmp	r3, #0
 8002a7a:	d109      	bne.n	8002a90 <__dbg_check_leave_isr+0x40>
 8002a7c:	9b03      	ldr	r3, [sp, #12]
 8002a7e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002a82:	2b00      	cmp	r3, #0
 8002a84:	bf14      	ite	ne
 8002a86:	2301      	movne	r3, #1
 8002a88:	2300      	moveq	r3, #0
 8002a8a:	b2db      	uxtb	r3, r3
 8002a8c:	2b00      	cmp	r3, #0
 8002a8e:	d002      	beq.n	8002a96 <__dbg_check_leave_isr+0x46>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 8002a90:	480b      	ldr	r0, [pc, #44]	@ (8002ac0 <__dbg_check_leave_isr+0x70>)
 8002a92:	f7ff fed5 	bl	8002840 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 8002a96:	9b03      	ldr	r3, [sp, #12]
 8002a98:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002a9c:	1e5a      	subs	r2, r3, #1
 8002a9e:	9b03      	ldr	r3, [sp, #12]
 8002aa0:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8002aa4:	2300      	movs	r3, #0
 8002aa6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002aa8:	9b01      	ldr	r3, [sp, #4]
 8002aaa:	f383 8811 	msr	BASEPRI, r3
}
 8002aae:	bf00      	nop
}
 8002ab0:	bf00      	nop
}
 8002ab2:	bf00      	nop
  port_unlock_from_isr();
}
 8002ab4:	bf00      	nop
 8002ab6:	b005      	add	sp, #20
 8002ab8:	f85d fb04 	ldr.w	pc, [sp], #4
 8002abc:	200008e8 	.word	0x200008e8
 8002ac0:	08004c14 	.word	0x08004c14
	...

08002ad0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002ad0:	b500      	push	{lr}
 8002ad2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002ad4:	4b0c      	ldr	r3, [pc, #48]	@ (8002b08 <chDbgCheckClassI+0x38>)
 8002ad6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002ad8:	9b01      	ldr	r3, [sp, #4]
 8002ada:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002ade:	0fdb      	lsrs	r3, r3, #31
 8002ae0:	b2db      	uxtb	r3, r3
 8002ae2:	2b00      	cmp	r3, #0
 8002ae4:	d109      	bne.n	8002afa <chDbgCheckClassI+0x2a>
 8002ae6:	9b01      	ldr	r3, [sp, #4]
 8002ae8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002aec:	2b00      	cmp	r3, #0
 8002aee:	bfd4      	ite	le
 8002af0:	2301      	movle	r3, #1
 8002af2:	2300      	movgt	r3, #0
 8002af4:	b2db      	uxtb	r3, r3
 8002af6:	2b00      	cmp	r3, #0
 8002af8:	d002      	beq.n	8002b00 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 8002afa:	4804      	ldr	r0, [pc, #16]	@ (8002b0c <chDbgCheckClassI+0x3c>)
 8002afc:	f7ff fea0 	bl	8002840 <chSysHalt>
  }
}
 8002b00:	bf00      	nop
 8002b02:	b003      	add	sp, #12
 8002b04:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b08:	200008e8 	.word	0x200008e8
 8002b0c:	08004c1c 	.word	0x08004c1c

08002b10 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002b10:	b500      	push	{lr}
 8002b12:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002b14:	4b0e      	ldr	r3, [pc, #56]	@ (8002b50 <chDbgCheckClassS+0x40>)
 8002b16:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002b18:	9b01      	ldr	r3, [sp, #4]
 8002b1a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8002b1e:	2b00      	cmp	r3, #0
 8002b20:	bf14      	ite	ne
 8002b22:	2301      	movne	r3, #1
 8002b24:	2300      	moveq	r3, #0
 8002b26:	b2db      	uxtb	r3, r3
 8002b28:	2b00      	cmp	r3, #0
 8002b2a:	d109      	bne.n	8002b40 <chDbgCheckClassS+0x30>
 8002b2c:	9b01      	ldr	r3, [sp, #4]
 8002b2e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8002b32:	2b00      	cmp	r3, #0
 8002b34:	bfd4      	ite	le
 8002b36:	2301      	movle	r3, #1
 8002b38:	2300      	movgt	r3, #0
 8002b3a:	b2db      	uxtb	r3, r3
 8002b3c:	2b00      	cmp	r3, #0
 8002b3e:	d002      	beq.n	8002b46 <chDbgCheckClassS+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 8002b40:	4804      	ldr	r0, [pc, #16]	@ (8002b54 <chDbgCheckClassS+0x44>)
 8002b42:	f7ff fe7d 	bl	8002840 <chSysHalt>
  }
}
 8002b46:	bf00      	nop
 8002b48:	b003      	add	sp, #12
 8002b4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b4e:	bf00      	nop
 8002b50:	200008e8 	.word	0x200008e8
 8002b54:	08004c24 	.word	0x08004c24
	...

08002b60 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8002b60:	b082      	sub	sp, #8
 8002b62:	9001      	str	r0, [sp, #4]
 8002b64:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002b66:	9a01      	ldr	r2, [sp, #4]
 8002b68:	9b00      	ldr	r3, [sp, #0]
 8002b6a:	4413      	add	r3, r2
}
 8002b6c:	4618      	mov	r0, r3
 8002b6e:	b002      	add	sp, #8
 8002b70:	4770      	bx	lr
 8002b72:	bf00      	nop
	...

08002b80 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8002b80:	b082      	sub	sp, #8
 8002b82:	9001      	str	r0, [sp, #4]
 8002b84:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002b86:	9a00      	ldr	r2, [sp, #0]
 8002b88:	9b01      	ldr	r3, [sp, #4]
 8002b8a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8002b8c:	4618      	mov	r0, r3
 8002b8e:	b002      	add	sp, #8
 8002b90:	4770      	bx	lr
 8002b92:	bf00      	nop
	...

08002ba0 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8002ba0:	b082      	sub	sp, #8
 8002ba2:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8002ba4:	9b01      	ldr	r3, [sp, #4]
 8002ba6:	681b      	ldr	r3, [r3, #0]
 8002ba8:	9a01      	ldr	r2, [sp, #4]
 8002baa:	429a      	cmp	r2, r3
 8002bac:	bf0c      	ite	eq
 8002bae:	2301      	moveq	r3, #1
 8002bb0:	2300      	movne	r3, #0
 8002bb2:	b2db      	uxtb	r3, r3
}
 8002bb4:	4618      	mov	r0, r3
 8002bb6:	b002      	add	sp, #8
 8002bb8:	4770      	bx	lr
 8002bba:	bf00      	nop
 8002bbc:	0000      	movs	r0, r0
	...

08002bc0 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8002bc0:	b082      	sub	sp, #8
 8002bc2:	9001      	str	r0, [sp, #4]
 8002bc4:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8002bc6:	9b01      	ldr	r3, [sp, #4]
 8002bc8:	681b      	ldr	r3, [r3, #0]
 8002bca:	9a00      	ldr	r2, [sp, #0]
 8002bcc:	429a      	cmp	r2, r3
 8002bce:	bf0c      	ite	eq
 8002bd0:	2301      	moveq	r3, #1
 8002bd2:	2300      	movne	r3, #0
 8002bd4:	b2db      	uxtb	r3, r3
}
 8002bd6:	4618      	mov	r0, r3
 8002bd8:	b002      	add	sp, #8
 8002bda:	4770      	bx	lr
 8002bdc:	0000      	movs	r0, r0
	...

08002be0 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 8002be0:	b084      	sub	sp, #16
 8002be2:	9003      	str	r0, [sp, #12]
 8002be4:	9102      	str	r1, [sp, #8]
 8002be6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002be8:	9b02      	ldr	r3, [sp, #8]
 8002bea:	9a01      	ldr	r2, [sp, #4]
 8002bec:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 8002bee:	9b02      	ldr	r3, [sp, #8]
 8002bf0:	9a03      	ldr	r2, [sp, #12]
 8002bf2:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8002bf4:	9b02      	ldr	r3, [sp, #8]
 8002bf6:	685b      	ldr	r3, [r3, #4]
 8002bf8:	681a      	ldr	r2, [r3, #0]
 8002bfa:	9b02      	ldr	r3, [sp, #8]
 8002bfc:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 8002bfe:	9b02      	ldr	r3, [sp, #8]
 8002c00:	681b      	ldr	r3, [r3, #0]
 8002c02:	9a02      	ldr	r2, [sp, #8]
 8002c04:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 8002c06:	9b03      	ldr	r3, [sp, #12]
 8002c08:	9a02      	ldr	r2, [sp, #8]
 8002c0a:	601a      	str	r2, [r3, #0]
}
 8002c0c:	bf00      	nop
 8002c0e:	b004      	add	sp, #16
 8002c10:	4770      	bx	lr
 8002c12:	bf00      	nop
	...

08002c20 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 8002c20:	b084      	sub	sp, #16
 8002c22:	9003      	str	r0, [sp, #12]
 8002c24:	9102      	str	r1, [sp, #8]
 8002c26:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002c28:	9b02      	ldr	r3, [sp, #8]
 8002c2a:	9a01      	ldr	r2, [sp, #4]
 8002c2c:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 8002c2e:	9b02      	ldr	r3, [sp, #8]
 8002c30:	9a03      	ldr	r2, [sp, #12]
 8002c32:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8002c34:	9b02      	ldr	r3, [sp, #8]
 8002c36:	681b      	ldr	r3, [r3, #0]
 8002c38:	685a      	ldr	r2, [r3, #4]
 8002c3a:	9b02      	ldr	r3, [sp, #8]
 8002c3c:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 8002c3e:	9b02      	ldr	r3, [sp, #8]
 8002c40:	685b      	ldr	r3, [r3, #4]
 8002c42:	9a02      	ldr	r2, [sp, #8]
 8002c44:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 8002c46:	9b03      	ldr	r3, [sp, #12]
 8002c48:	9a02      	ldr	r2, [sp, #8]
 8002c4a:	605a      	str	r2, [r3, #4]
}
 8002c4c:	bf00      	nop
 8002c4e:	b004      	add	sp, #16
 8002c50:	4770      	bx	lr
 8002c52:	bf00      	nop
	...

08002c60 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8002c60:	b500      	push	{lr}
 8002c62:	b087      	sub	sp, #28
 8002c64:	9003      	str	r0, [sp, #12]
 8002c66:	9102      	str	r1, [sp, #8]
 8002c68:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 8002c6a:	9b03      	ldr	r3, [sp, #12]
 8002c6c:	681b      	ldr	r3, [r3, #0]
 8002c6e:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002c70:	e007      	b.n	8002c82 <ch_dlist_insert+0x22>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
 8002c72:	9b05      	ldr	r3, [sp, #20]
 8002c74:	689b      	ldr	r3, [r3, #8]
 8002c76:	9a01      	ldr	r2, [sp, #4]
 8002c78:	1ad3      	subs	r3, r2, r3
 8002c7a:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 8002c7c:	9b05      	ldr	r3, [sp, #20]
 8002c7e:	681b      	ldr	r3, [r3, #0]
 8002c80:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002c82:	9b05      	ldr	r3, [sp, #20]
 8002c84:	689b      	ldr	r3, [r3, #8]
 8002c86:	9a01      	ldr	r2, [sp, #4]
 8002c88:	429a      	cmp	r2, r3
 8002c8a:	bf8c      	ite	hi
 8002c8c:	2301      	movhi	r3, #1
 8002c8e:	2300      	movls	r3, #0
 8002c90:	b2db      	uxtb	r3, r3
 8002c92:	2b00      	cmp	r3, #0
 8002c94:	d1ed      	bne.n	8002c72 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 8002c96:	9a01      	ldr	r2, [sp, #4]
 8002c98:	9902      	ldr	r1, [sp, #8]
 8002c9a:	9805      	ldr	r0, [sp, #20]
 8002c9c:	f7ff ffc0 	bl	8002c20 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8002ca0:	9b05      	ldr	r3, [sp, #20]
 8002ca2:	689a      	ldr	r2, [r3, #8]
 8002ca4:	9b01      	ldr	r3, [sp, #4]
 8002ca6:	1ad2      	subs	r2, r2, r3
 8002ca8:	9b05      	ldr	r3, [sp, #20]
 8002caa:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8002cac:	9b03      	ldr	r3, [sp, #12]
 8002cae:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8002cb2:	609a      	str	r2, [r3, #8]
}
 8002cb4:	bf00      	nop
 8002cb6:	b007      	add	sp, #28
 8002cb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cbc:	0000      	movs	r0, r0
	...

08002cc0 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8002cc0:	b084      	sub	sp, #16
 8002cc2:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8002cc4:	9b01      	ldr	r3, [sp, #4]
 8002cc6:	681b      	ldr	r3, [r3, #0]
 8002cc8:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 8002cca:	9b03      	ldr	r3, [sp, #12]
 8002ccc:	681a      	ldr	r2, [r3, #0]
 8002cce:	9b01      	ldr	r3, [sp, #4]
 8002cd0:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8002cd2:	9b01      	ldr	r3, [sp, #4]
 8002cd4:	681b      	ldr	r3, [r3, #0]
 8002cd6:	9a01      	ldr	r2, [sp, #4]
 8002cd8:	605a      	str	r2, [r3, #4]

  return dlp;
 8002cda:	9b03      	ldr	r3, [sp, #12]
}
 8002cdc:	4618      	mov	r0, r3
 8002cde:	b004      	add	sp, #16
 8002ce0:	4770      	bx	lr
 8002ce2:	bf00      	nop
	...

08002cf0 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 8002cf0:	b082      	sub	sp, #8
 8002cf2:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 8002cf4:	9b01      	ldr	r3, [sp, #4]
 8002cf6:	685b      	ldr	r3, [r3, #4]
 8002cf8:	9a01      	ldr	r2, [sp, #4]
 8002cfa:	6812      	ldr	r2, [r2, #0]
 8002cfc:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 8002cfe:	9b01      	ldr	r3, [sp, #4]
 8002d00:	681b      	ldr	r3, [r3, #0]
 8002d02:	9a01      	ldr	r2, [sp, #4]
 8002d04:	6852      	ldr	r2, [r2, #4]
 8002d06:	605a      	str	r2, [r3, #4]

  return dlp;
 8002d08:	9b01      	ldr	r3, [sp, #4]
}
 8002d0a:	4618      	mov	r0, r3
 8002d0c:	b002      	add	sp, #8
 8002d0e:	4770      	bx	lr

08002d10 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8002d10:	b500      	push	{lr}
 8002d12:	b083      	sub	sp, #12
 8002d14:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8002d16:	9801      	ldr	r0, [sp, #4]
 8002d18:	f7fd fb7a 	bl	8000410 <stStartAlarm>
}
 8002d1c:	bf00      	nop
 8002d1e:	b003      	add	sp, #12
 8002d20:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002d30 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8002d30:	b508      	push	{r3, lr}

  stStopAlarm();
 8002d32:	f7fd fb7d 	bl	8000430 <stStopAlarm>
}
 8002d36:	bf00      	nop
 8002d38:	bd08      	pop	{r3, pc}
 8002d3a:	bf00      	nop
 8002d3c:	0000      	movs	r0, r0
	...

08002d40 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8002d40:	b500      	push	{lr}
 8002d42:	b083      	sub	sp, #12
 8002d44:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8002d46:	9801      	ldr	r0, [sp, #4]
 8002d48:	f7fd fb7a 	bl	8000440 <stSetAlarm>
}
 8002d4c:	bf00      	nop
 8002d4e:	b003      	add	sp, #12
 8002d50:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002d60 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002d60:	b508      	push	{r3, lr}

  return stGetCounter();
 8002d62:	f7fd fb4d 	bl	8000400 <stGetCounter>
 8002d66:	4603      	mov	r3, r0
}
 8002d68:	4618      	mov	r0, r3
 8002d6a:	bd08      	pop	{r3, pc}
 8002d6c:	0000      	movs	r0, r0
	...

08002d70 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 8002d70:	b500      	push	{lr}
 8002d72:	b083      	sub	sp, #12
 8002d74:	2330      	movs	r3, #48	@ 0x30
 8002d76:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002d78:	9b01      	ldr	r3, [sp, #4]
 8002d7a:	f383 8811 	msr	BASEPRI, r3
}
 8002d7e:	bf00      	nop
}
 8002d80:	bf00      	nop
}
 8002d82:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002d84:	f7ff fddc 	bl	8002940 <__dbg_check_lock_from_isr>
}
 8002d88:	bf00      	nop
 8002d8a:	b003      	add	sp, #12
 8002d8c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d90 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
 8002d90:	b500      	push	{lr}
 8002d92:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002d94:	f7ff fdfc 	bl	8002990 <__dbg_check_unlock_from_isr>
 8002d98:	2300      	movs	r3, #0
 8002d9a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002d9c:	9b01      	ldr	r3, [sp, #4]
 8002d9e:	f383 8811 	msr	BASEPRI, r3
}
 8002da2:	bf00      	nop
}
 8002da4:	bf00      	nop
}
 8002da6:	bf00      	nop
}
 8002da8:	bf00      	nop
 8002daa:	b003      	add	sp, #12
 8002dac:	f85d fb04 	ldr.w	pc, [sp], #4

08002db0 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002db0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002db2:	f7ff ffd5 	bl	8002d60 <port_timer_get_time.lto_priv.0>
 8002db6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002db8:	4618      	mov	r0, r3
 8002dba:	bd08      	pop	{r3, pc}
 8002dbc:	0000      	movs	r0, r0
	...

08002dc0 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 8002dc0:	b500      	push	{lr}
 8002dc2:	b087      	sub	sp, #28
 8002dc4:	9001      	str	r0, [sp, #4]
 8002dc6:	9100      	str	r1, [sp, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002dc8:	2302      	movs	r3, #2
 8002dca:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 8002dcc:	9a00      	ldr	r2, [sp, #0]
 8002dce:	9b05      	ldr	r3, [sp, #20]
 8002dd0:	429a      	cmp	r2, r3
 8002dd2:	d201      	bcs.n	8002dd8 <vt_set_alarm+0x18>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002dd4:	9b05      	ldr	r3, [sp, #20]
 8002dd6:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 8002dd8:	9900      	ldr	r1, [sp, #0]
 8002dda:	9801      	ldr	r0, [sp, #4]
 8002ddc:	f7ff fec0 	bl	8002b60 <chTimeAddX>
 8002de0:	4603      	mov	r3, r0
 8002de2:	4618      	mov	r0, r3
 8002de4:	f7ff ffac 	bl	8002d40 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002de8:	f7ff ffe2 	bl	8002db0 <chVTGetSystemTimeX.lto_priv.0>
 8002dec:	9004      	str	r0, [sp, #16]
    nowdelta = chTimeDiffX(now, newnow);
 8002dee:	9904      	ldr	r1, [sp, #16]
 8002df0:	9801      	ldr	r0, [sp, #4]
 8002df2:	f7ff fec5 	bl	8002b80 <chTimeDiffX.lto_priv.0>
 8002df6:	9003      	str	r0, [sp, #12]
    if (likely(nowdelta < delay)) {
 8002df8:	9a03      	ldr	r2, [sp, #12]
 8002dfa:	9b00      	ldr	r3, [sp, #0]
 8002dfc:	429a      	cmp	r2, r3
 8002dfe:	bf34      	ite	cc
 8002e00:	2301      	movcc	r3, #1
 8002e02:	2300      	movcs	r3, #0
 8002e04:	b2db      	uxtb	r3, r3
 8002e06:	2b00      	cmp	r3, #0
 8002e08:	d107      	bne.n	8002e1a <vt_set_alarm+0x5a>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002e0a:	9b05      	ldr	r3, [sp, #20]
 8002e0c:	3301      	adds	r3, #1
 8002e0e:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002e10:	9b04      	ldr	r3, [sp, #16]
 8002e12:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 8002e14:	9b05      	ldr	r3, [sp, #20]
 8002e16:	9300      	str	r3, [sp, #0]
  while (true) {
 8002e18:	e7de      	b.n	8002dd8 <vt_set_alarm+0x18>
      break;
 8002e1a:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002e1c:	9b05      	ldr	r3, [sp, #20]
 8002e1e:	2b02      	cmp	r3, #2
 8002e20:	d902      	bls.n	8002e28 <vt_set_alarm+0x68>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002e22:	2001      	movs	r0, #1
 8002e24:	f7ff fd2c 	bl	8002880 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002e28:	bf00      	nop
 8002e2a:	b007      	add	sp, #28
 8002e2c:	f85d fb04 	ldr.w	pc, [sp], #4

08002e30 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8002e30:	b500      	push	{lr}
 8002e32:	b087      	sub	sp, #28
 8002e34:	9003      	str	r0, [sp, #12]
 8002e36:	9102      	str	r1, [sp, #8]
 8002e38:	9201      	str	r2, [sp, #4]
 8002e3a:	9300      	str	r3, [sp, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8002e3c:	9b03      	ldr	r3, [sp, #12]
 8002e3e:	9a01      	ldr	r2, [sp, #4]
 8002e40:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8002e42:	9b03      	ldr	r3, [sp, #12]
 8002e44:	9902      	ldr	r1, [sp, #8]
 8002e46:	9a00      	ldr	r2, [sp, #0]
 8002e48:	4618      	mov	r0, r3
 8002e4a:	f7ff fec9 	bl	8002be0 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002e4e:	2302      	movs	r3, #2
 8002e50:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8002e52:	9a00      	ldr	r2, [sp, #0]
 8002e54:	9b05      	ldr	r3, [sp, #20]
 8002e56:	429a      	cmp	r2, r3
 8002e58:	d201      	bcs.n	8002e5e <vt_insert_first+0x2e>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002e5a:	9b05      	ldr	r3, [sp, #20]
 8002e5c:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 8002e5e:	9b03      	ldr	r3, [sp, #12]
 8002e60:	68db      	ldr	r3, [r3, #12]
 8002e62:	9900      	ldr	r1, [sp, #0]
 8002e64:	4618      	mov	r0, r3
 8002e66:	f7ff fe7b 	bl	8002b60 <chTimeAddX>
 8002e6a:	4603      	mov	r3, r0
 8002e6c:	4618      	mov	r0, r3
 8002e6e:	f7ff ff4f 	bl	8002d10 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002e72:	f7ff ff9d 	bl	8002db0 <chVTGetSystemTimeX.lto_priv.0>
 8002e76:	9004      	str	r0, [sp, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8002e78:	9904      	ldr	r1, [sp, #16]
 8002e7a:	9801      	ldr	r0, [sp, #4]
 8002e7c:	f7ff fe80 	bl	8002b80 <chTimeDiffX.lto_priv.0>
 8002e80:	4602      	mov	r2, r0
 8002e82:	9b00      	ldr	r3, [sp, #0]
 8002e84:	4293      	cmp	r3, r2
 8002e86:	bf8c      	ite	hi
 8002e88:	2301      	movhi	r3, #1
 8002e8a:	2300      	movls	r3, #0
 8002e8c:	b2db      	uxtb	r3, r3
 8002e8e:	2b00      	cmp	r3, #0
 8002e90:	d10f      	bne.n	8002eb2 <vt_insert_first+0x82>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002e92:	9b05      	ldr	r3, [sp, #20]
 8002e94:	3301      	adds	r3, #1
 8002e96:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8002e98:	9905      	ldr	r1, [sp, #20]
 8002e9a:	9801      	ldr	r0, [sp, #4]
 8002e9c:	f7ff fe60 	bl	8002b60 <chTimeAddX>
 8002ea0:	4603      	mov	r3, r0
 8002ea2:	4618      	mov	r0, r3
 8002ea4:	f7ff ff4c 	bl	8002d40 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002ea8:	9b04      	ldr	r3, [sp, #16]
 8002eaa:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 8002eac:	9b05      	ldr	r3, [sp, #20]
 8002eae:	9300      	str	r3, [sp, #0]
  while (true) {
 8002eb0:	e7df      	b.n	8002e72 <vt_insert_first+0x42>
      break;
 8002eb2:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002eb4:	9b05      	ldr	r3, [sp, #20]
 8002eb6:	2b02      	cmp	r3, #2
 8002eb8:	d902      	bls.n	8002ec0 <vt_insert_first+0x90>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002eba:	2001      	movs	r0, #1
 8002ebc:	f7ff fce0 	bl	8002880 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002ec0:	bf00      	nop
 8002ec2:	b007      	add	sp, #28
 8002ec4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002ed0 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 8002ed0:	b500      	push	{lr}
 8002ed2:	b089      	sub	sp, #36	@ 0x24
 8002ed4:	9003      	str	r0, [sp, #12]
 8002ed6:	9102      	str	r1, [sp, #8]
 8002ed8:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 8002eda:	f7ff ff69 	bl	8002db0 <chVTGetSystemTimeX.lto_priv.0>
 8002ede:	9006      	str	r0, [sp, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002ee0:	9b03      	ldr	r3, [sp, #12]
 8002ee2:	4618      	mov	r0, r3
 8002ee4:	f7ff fe5c 	bl	8002ba0 <ch_dlist_isempty>
 8002ee8:	4603      	mov	r3, r0
 8002eea:	2b00      	cmp	r3, #0
 8002eec:	d006      	beq.n	8002efc <vt_enqueue+0x2c>

      vt_insert_first(vtlp, vtp, now, delay);
 8002eee:	9b01      	ldr	r3, [sp, #4]
 8002ef0:	9a06      	ldr	r2, [sp, #24]
 8002ef2:	9902      	ldr	r1, [sp, #8]
 8002ef4:	9803      	ldr	r0, [sp, #12]
 8002ef6:	f7ff ff9b 	bl	8002e30 <vt_insert_first>

      return;
 8002efa:	e020      	b.n	8002f3e <vt_enqueue+0x6e>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002efc:	9b03      	ldr	r3, [sp, #12]
 8002efe:	68db      	ldr	r3, [r3, #12]
 8002f00:	9906      	ldr	r1, [sp, #24]
 8002f02:	4618      	mov	r0, r3
 8002f04:	f7ff fe3c 	bl	8002b80 <chTimeDiffX.lto_priv.0>
 8002f08:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
 8002f0a:	9a05      	ldr	r2, [sp, #20]
 8002f0c:	9b01      	ldr	r3, [sp, #4]
 8002f0e:	4413      	add	r3, r2
 8002f10:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 8002f12:	9a07      	ldr	r2, [sp, #28]
 8002f14:	9b05      	ldr	r3, [sp, #20]
 8002f16:	429a      	cmp	r2, r3
 8002f18:	d201      	bcs.n	8002f1e <vt_enqueue+0x4e>
      delta = delay;
 8002f1a:	9b01      	ldr	r3, [sp, #4]
 8002f1c:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8002f1e:	9b03      	ldr	r3, [sp, #12]
 8002f20:	681b      	ldr	r3, [r3, #0]
 8002f22:	689b      	ldr	r3, [r3, #8]
 8002f24:	9a07      	ldr	r2, [sp, #28]
 8002f26:	429a      	cmp	r2, r3
 8002f28:	d203      	bcs.n	8002f32 <vt_enqueue+0x62>

      vt_set_alarm(now, delay);
 8002f2a:	9901      	ldr	r1, [sp, #4]
 8002f2c:	9806      	ldr	r0, [sp, #24]
 8002f2e:	f7ff ff47 	bl	8002dc0 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8002f32:	9b03      	ldr	r3, [sp, #12]
 8002f34:	9902      	ldr	r1, [sp, #8]
 8002f36:	9a07      	ldr	r2, [sp, #28]
 8002f38:	4618      	mov	r0, r3
 8002f3a:	f7ff fe91 	bl	8002c60 <ch_dlist_insert>
}
 8002f3e:	b009      	add	sp, #36	@ 0x24
 8002f40:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002f50 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8002f50:	b500      	push	{lr}
 8002f52:	b087      	sub	sp, #28
 8002f54:	9003      	str	r0, [sp, #12]
 8002f56:	9102      	str	r1, [sp, #8]
 8002f58:	9201      	str	r2, [sp, #4]
 8002f5a:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002f5c:	4b1a      	ldr	r3, [pc, #104]	@ (8002fc8 <chVTDoSetI+0x78>)
 8002f5e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002f60:	f7ff fdb6 	bl	8002ad0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002f64:	9b03      	ldr	r3, [sp, #12]
 8002f66:	2b00      	cmp	r3, #0
 8002f68:	bf0c      	ite	eq
 8002f6a:	2301      	moveq	r3, #1
 8002f6c:	2300      	movne	r3, #0
 8002f6e:	b2db      	uxtb	r3, r3
 8002f70:	2b00      	cmp	r3, #0
 8002f72:	d107      	bne.n	8002f84 <chVTDoSetI+0x34>
 8002f74:	9b01      	ldr	r3, [sp, #4]
 8002f76:	2b00      	cmp	r3, #0
 8002f78:	bf0c      	ite	eq
 8002f7a:	2301      	moveq	r3, #1
 8002f7c:	2300      	movne	r3, #0
 8002f7e:	b2db      	uxtb	r3, r3
 8002f80:	2b00      	cmp	r3, #0
 8002f82:	d001      	beq.n	8002f88 <chVTDoSetI+0x38>
 8002f84:	2301      	movs	r3, #1
 8002f86:	e000      	b.n	8002f8a <chVTDoSetI+0x3a>
 8002f88:	2300      	movs	r3, #0
 8002f8a:	2b00      	cmp	r3, #0
 8002f8c:	d107      	bne.n	8002f9e <chVTDoSetI+0x4e>
 8002f8e:	9b02      	ldr	r3, [sp, #8]
 8002f90:	2b00      	cmp	r3, #0
 8002f92:	bf0c      	ite	eq
 8002f94:	2301      	moveq	r3, #1
 8002f96:	2300      	movne	r3, #0
 8002f98:	b2db      	uxtb	r3, r3
 8002f9a:	2b00      	cmp	r3, #0
 8002f9c:	d002      	beq.n	8002fa4 <chVTDoSetI+0x54>
 8002f9e:	480b      	ldr	r0, [pc, #44]	@ (8002fcc <chVTDoSetI+0x7c>)
 8002fa0:	f7ff fc4e 	bl	8002840 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8002fa4:	9b03      	ldr	r3, [sp, #12]
 8002fa6:	9a00      	ldr	r2, [sp, #0]
 8002fa8:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 8002faa:	9b03      	ldr	r3, [sp, #12]
 8002fac:	9a01      	ldr	r2, [sp, #4]
 8002fae:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8002fb0:	9b03      	ldr	r3, [sp, #12]
 8002fb2:	2200      	movs	r2, #0
 8002fb4:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8002fb6:	9a02      	ldr	r2, [sp, #8]
 8002fb8:	9903      	ldr	r1, [sp, #12]
 8002fba:	9805      	ldr	r0, [sp, #20]
 8002fbc:	f7ff ff88 	bl	8002ed0 <vt_enqueue>
}
 8002fc0:	bf00      	nop
 8002fc2:	b007      	add	sp, #28
 8002fc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fc8:	200008f8 	.word	0x200008f8
 8002fcc:	08004c64 	.word	0x08004c64

08002fd0 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8002fd0:	b500      	push	{lr}
 8002fd2:	b087      	sub	sp, #28
 8002fd4:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002fd6:	4b34      	ldr	r3, [pc, #208]	@ (80030a8 <chVTDoResetI+0xd8>)
 8002fd8:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002fda:	f7ff fd79 	bl	8002ad0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8002fde:	9b01      	ldr	r3, [sp, #4]
 8002fe0:	2b00      	cmp	r3, #0
 8002fe2:	bf0c      	ite	eq
 8002fe4:	2301      	moveq	r3, #1
 8002fe6:	2300      	movne	r3, #0
 8002fe8:	b2db      	uxtb	r3, r3
 8002fea:	2b00      	cmp	r3, #0
 8002fec:	d002      	beq.n	8002ff4 <chVTDoResetI+0x24>
 8002fee:	482f      	ldr	r0, [pc, #188]	@ (80030ac <chVTDoResetI+0xdc>)
 8002ff0:	f7ff fc26 	bl	8002840 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8002ff4:	9b05      	ldr	r3, [sp, #20]
 8002ff6:	9a01      	ldr	r2, [sp, #4]
 8002ff8:	4611      	mov	r1, r2
 8002ffa:	4618      	mov	r0, r3
 8002ffc:	f7ff fde0 	bl	8002bc0 <ch_dlist_isfirst>
 8003000:	4603      	mov	r3, r0
 8003002:	f083 0301 	eor.w	r3, r3, #1
 8003006:	b2db      	uxtb	r3, r3
 8003008:	2b00      	cmp	r3, #0
 800300a:	d014      	beq.n	8003036 <chVTDoResetI+0x66>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 800300c:	9b01      	ldr	r3, [sp, #4]
 800300e:	4618      	mov	r0, r3
 8003010:	f7ff fe6e 	bl	8002cf0 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8003014:	9b01      	ldr	r3, [sp, #4]
 8003016:	681b      	ldr	r3, [r3, #0]
 8003018:	6899      	ldr	r1, [r3, #8]
 800301a:	9b01      	ldr	r3, [sp, #4]
 800301c:	689a      	ldr	r2, [r3, #8]
 800301e:	9b01      	ldr	r3, [sp, #4]
 8003020:	681b      	ldr	r3, [r3, #0]
 8003022:	440a      	add	r2, r1
 8003024:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8003026:	9b01      	ldr	r3, [sp, #4]
 8003028:	2200      	movs	r2, #0
 800302a:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 800302c:	9b05      	ldr	r3, [sp, #20]
 800302e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003032:	609a      	str	r2, [r3, #8]

    return;
 8003034:	e035      	b.n	80030a2 <chVTDoResetI+0xd2>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8003036:	9b05      	ldr	r3, [sp, #20]
 8003038:	4618      	mov	r0, r3
 800303a:	f7ff fe41 	bl	8002cc0 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 800303e:	9b01      	ldr	r3, [sp, #4]
 8003040:	2200      	movs	r2, #0
 8003042:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003044:	9b05      	ldr	r3, [sp, #20]
 8003046:	4618      	mov	r0, r3
 8003048:	f7ff fdaa 	bl	8002ba0 <ch_dlist_isempty>
 800304c:	4603      	mov	r3, r0
 800304e:	2b00      	cmp	r3, #0
 8003050:	d002      	beq.n	8003058 <chVTDoResetI+0x88>

    port_timer_stop_alarm();
 8003052:	f7ff fe6d 	bl	8002d30 <port_timer_stop_alarm>

    return;
 8003056:	e024      	b.n	80030a2 <chVTDoResetI+0xd2>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8003058:	9b05      	ldr	r3, [sp, #20]
 800305a:	681b      	ldr	r3, [r3, #0]
 800305c:	6899      	ldr	r1, [r3, #8]
 800305e:	9b01      	ldr	r3, [sp, #4]
 8003060:	689a      	ldr	r2, [r3, #8]
 8003062:	9b05      	ldr	r3, [sp, #20]
 8003064:	681b      	ldr	r3, [r3, #0]
 8003066:	440a      	add	r2, r1
 8003068:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 800306a:	f7ff fea1 	bl	8002db0 <chVTGetSystemTimeX.lto_priv.0>
 800306e:	9004      	str	r0, [sp, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003070:	9b05      	ldr	r3, [sp, #20]
 8003072:	68db      	ldr	r3, [r3, #12]
 8003074:	9904      	ldr	r1, [sp, #16]
 8003076:	4618      	mov	r0, r3
 8003078:	f7ff fd82 	bl	8002b80 <chTimeDiffX.lto_priv.0>
 800307c:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 800307e:	9b05      	ldr	r3, [sp, #20]
 8003080:	681b      	ldr	r3, [r3, #0]
 8003082:	689b      	ldr	r3, [r3, #8]
 8003084:	9a03      	ldr	r2, [sp, #12]
 8003086:	429a      	cmp	r2, r3
 8003088:	d20a      	bcs.n	80030a0 <chVTDoResetI+0xd0>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 800308a:	9b05      	ldr	r3, [sp, #20]
 800308c:	681b      	ldr	r3, [r3, #0]
 800308e:	689a      	ldr	r2, [r3, #8]
 8003090:	9b03      	ldr	r3, [sp, #12]
 8003092:	1ad3      	subs	r3, r2, r3
 8003094:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 8003096:	9902      	ldr	r1, [sp, #8]
 8003098:	9804      	ldr	r0, [sp, #16]
 800309a:	f7ff fe91 	bl	8002dc0 <vt_set_alarm>
 800309e:	e000      	b.n	80030a2 <chVTDoResetI+0xd2>
    return;
 80030a0:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80030a2:	b007      	add	sp, #28
 80030a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80030a8:	200008f8 	.word	0x200008f8
 80030ac:	08004c70 	.word	0x08004c70

080030b0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 80030b0:	b500      	push	{lr}
 80030b2:	b089      	sub	sp, #36	@ 0x24
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 80030b4:	4b4d      	ldr	r3, [pc, #308]	@ (80031ec <chVTDoTickI+0x13c>)
 80030b6:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 80030b8:	f7ff fd0a 	bl	8002ad0 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 80030bc:	9b05      	ldr	r3, [sp, #20]
 80030be:	681b      	ldr	r3, [r3, #0]
 80030c0:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 80030c2:	f7ff fe75 	bl	8002db0 <chVTGetSystemTimeX.lto_priv.0>
 80030c6:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80030c8:	9b05      	ldr	r3, [sp, #20]
 80030ca:	68db      	ldr	r3, [r3, #12]
 80030cc:	9903      	ldr	r1, [sp, #12]
 80030ce:	4618      	mov	r0, r3
 80030d0:	f7ff fd56 	bl	8002b80 <chTimeDiffX.lto_priv.0>
 80030d4:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 80030d6:	9b04      	ldr	r3, [sp, #16]
 80030d8:	689b      	ldr	r3, [r3, #8]
 80030da:	9a02      	ldr	r2, [sp, #8]
 80030dc:	429a      	cmp	r2, r3
 80030de:	d366      	bcc.n	80031ae <chVTDoTickI+0xfe>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 80030e0:	9b05      	ldr	r3, [sp, #20]
 80030e2:	68da      	ldr	r2, [r3, #12]
 80030e4:	9b04      	ldr	r3, [sp, #16]
 80030e6:	689b      	ldr	r3, [r3, #8]
 80030e8:	4619      	mov	r1, r3
 80030ea:	4610      	mov	r0, r2
 80030ec:	f7ff fd38 	bl	8002b60 <chTimeAddX>
 80030f0:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
 80030f2:	9b05      	ldr	r3, [sp, #20]
 80030f4:	9a01      	ldr	r2, [sp, #4]
 80030f6:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 80030f8:	9b04      	ldr	r3, [sp, #16]
 80030fa:	4618      	mov	r0, r3
 80030fc:	f7ff fdf8 	bl	8002cf0 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8003100:	9b04      	ldr	r3, [sp, #16]
 8003102:	2200      	movs	r2, #0
 8003104:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003106:	9b05      	ldr	r3, [sp, #20]
 8003108:	4618      	mov	r0, r3
 800310a:	f7ff fd49 	bl	8002ba0 <ch_dlist_isempty>
 800310e:	4603      	mov	r3, r0
 8003110:	2b00      	cmp	r3, #0
 8003112:	d001      	beq.n	8003118 <chVTDoTickI+0x68>
      port_timer_stop_alarm();
 8003114:	f7ff fe0c 	bl	8002d30 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 8003118:	f7ff fe3a 	bl	8002d90 <chSysUnlockFromISR.lto_priv.3>

    vtp->func(vtp, vtp->par);
 800311c:	9b04      	ldr	r3, [sp, #16]
 800311e:	68db      	ldr	r3, [r3, #12]
 8003120:	9a04      	ldr	r2, [sp, #16]
 8003122:	6912      	ldr	r2, [r2, #16]
 8003124:	4611      	mov	r1, r2
 8003126:	9804      	ldr	r0, [sp, #16]
 8003128:	4798      	blx	r3

    chSysLockFromISR();
 800312a:	f7ff fe21 	bl	8002d70 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 800312e:	9b04      	ldr	r3, [sp, #16]
 8003130:	695b      	ldr	r3, [r3, #20]
 8003132:	2b00      	cmp	r3, #0
 8003134:	bf14      	ite	ne
 8003136:	2301      	movne	r3, #1
 8003138:	2300      	moveq	r3, #0
 800313a:	b2db      	uxtb	r3, r3
 800313c:	2b00      	cmp	r3, #0
 800313e:	d0bd      	beq.n	80030bc <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8003140:	f7ff fe36 	bl	8002db0 <chVTGetSystemTimeX.lto_priv.0>
 8003144:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 8003146:	9903      	ldr	r1, [sp, #12]
 8003148:	9801      	ldr	r0, [sp, #4]
 800314a:	f7ff fd19 	bl	8002b80 <chTimeDiffX.lto_priv.0>
 800314e:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8003150:	9b04      	ldr	r3, [sp, #16]
 8003152:	695b      	ldr	r3, [r3, #20]
 8003154:	9a02      	ldr	r2, [sp, #8]
 8003156:	429a      	cmp	r2, r3
 8003158:	d905      	bls.n	8003166 <chVTDoTickI+0xb6>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 800315a:	2002      	movs	r0, #2
 800315c:	f7ff fb90 	bl	8002880 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8003160:	2300      	movs	r3, #0
 8003162:	9306      	str	r3, [sp, #24]
 8003164:	e004      	b.n	8003170 <chVTDoTickI+0xc0>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 8003166:	9b04      	ldr	r3, [sp, #16]
 8003168:	695a      	ldr	r2, [r3, #20]
 800316a:	9b02      	ldr	r3, [sp, #8]
 800316c:	1ad3      	subs	r3, r2, r3
 800316e:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8003170:	9b05      	ldr	r3, [sp, #20]
 8003172:	4618      	mov	r0, r3
 8003174:	f7ff fd14 	bl	8002ba0 <ch_dlist_isempty>
 8003178:	4603      	mov	r3, r0
 800317a:	2b00      	cmp	r3, #0
 800317c:	d006      	beq.n	800318c <chVTDoTickI+0xdc>

        vt_insert_first(vtlp, vtp, now, delay);
 800317e:	9b06      	ldr	r3, [sp, #24]
 8003180:	9a03      	ldr	r2, [sp, #12]
 8003182:	9904      	ldr	r1, [sp, #16]
 8003184:	9805      	ldr	r0, [sp, #20]
 8003186:	f7ff fe53 	bl	8002e30 <vt_insert_first>

        return;
 800318a:	e02c      	b.n	80031e6 <chVTDoTickI+0x136>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 800318c:	9a02      	ldr	r2, [sp, #8]
 800318e:	9b06      	ldr	r3, [sp, #24]
 8003190:	4413      	add	r3, r2
 8003192:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 8003194:	9a07      	ldr	r2, [sp, #28]
 8003196:	9b02      	ldr	r3, [sp, #8]
 8003198:	429a      	cmp	r2, r3
 800319a:	d201      	bcs.n	80031a0 <chVTDoTickI+0xf0>
        delta = delay;
 800319c:	9b06      	ldr	r3, [sp, #24]
 800319e:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 80031a0:	9b05      	ldr	r3, [sp, #20]
 80031a2:	9904      	ldr	r1, [sp, #16]
 80031a4:	9a07      	ldr	r2, [sp, #28]
 80031a6:	4618      	mov	r0, r3
 80031a8:	f7ff fd5a 	bl	8002c60 <ch_dlist_insert>
  while (true) {
 80031ac:	e786      	b.n	80030bc <chVTDoTickI+0xc>
      break;
 80031ae:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 80031b0:	9b05      	ldr	r3, [sp, #20]
 80031b2:	4618      	mov	r0, r3
 80031b4:	f7ff fcf4 	bl	8002ba0 <ch_dlist_isempty>
 80031b8:	4603      	mov	r3, r0
 80031ba:	2b00      	cmp	r3, #0
 80031bc:	d112      	bne.n	80031e4 <chVTDoTickI+0x134>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 80031be:	9b05      	ldr	r3, [sp, #20]
 80031c0:	68da      	ldr	r2, [r3, #12]
 80031c2:	9b02      	ldr	r3, [sp, #8]
 80031c4:	441a      	add	r2, r3
 80031c6:	9b05      	ldr	r3, [sp, #20]
 80031c8:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 80031ca:	9b04      	ldr	r3, [sp, #16]
 80031cc:	689a      	ldr	r2, [r3, #8]
 80031ce:	9b02      	ldr	r3, [sp, #8]
 80031d0:	1ad2      	subs	r2, r2, r3
 80031d2:	9b04      	ldr	r3, [sp, #16]
 80031d4:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 80031d6:	9b04      	ldr	r3, [sp, #16]
 80031d8:	689b      	ldr	r3, [r3, #8]
 80031da:	4619      	mov	r1, r3
 80031dc:	9803      	ldr	r0, [sp, #12]
 80031de:	f7ff fdef 	bl	8002dc0 <vt_set_alarm>
 80031e2:	e000      	b.n	80031e6 <chVTDoTickI+0x136>
    return;
 80031e4:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80031e6:	b009      	add	sp, #36	@ 0x24
 80031e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80031ec:	200008f8 	.word	0x200008f8

080031f0 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80031f0:	b082      	sub	sp, #8
 80031f2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80031f4:	9b01      	ldr	r3, [sp, #4]
 80031f6:	685b      	ldr	r3, [r3, #4]
 80031f8:	9a01      	ldr	r2, [sp, #4]
 80031fa:	6812      	ldr	r2, [r2, #0]
 80031fc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80031fe:	9b01      	ldr	r3, [sp, #4]
 8003200:	681b      	ldr	r3, [r3, #0]
 8003202:	9a01      	ldr	r2, [sp, #4]
 8003204:	6852      	ldr	r2, [r2, #4]
 8003206:	605a      	str	r2, [r3, #4]
  return p;
 8003208:	9b01      	ldr	r3, [sp, #4]
}
 800320a:	4618      	mov	r0, r3
 800320c:	b002      	add	sp, #8
 800320e:	4770      	bx	lr

08003210 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 8003210:	b084      	sub	sp, #16
 8003212:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 8003214:	9b01      	ldr	r3, [sp, #4]
 8003216:	681b      	ldr	r3, [r3, #0]
 8003218:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 800321a:	9b03      	ldr	r3, [sp, #12]
 800321c:	681a      	ldr	r2, [r3, #0]
 800321e:	9b01      	ldr	r3, [sp, #4]
 8003220:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 8003222:	9b01      	ldr	r3, [sp, #4]
 8003224:	681b      	ldr	r3, [r3, #0]
 8003226:	9a01      	ldr	r2, [sp, #4]
 8003228:	605a      	str	r2, [r3, #4]
  return p;
 800322a:	9b03      	ldr	r3, [sp, #12]
}
 800322c:	4618      	mov	r0, r3
 800322e:	b004      	add	sp, #16
 8003230:	4770      	bx	lr
 8003232:	bf00      	nop
	...

08003240 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8003240:	b082      	sub	sp, #8
 8003242:	9001      	str	r0, [sp, #4]
 8003244:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003246:	9b01      	ldr	r3, [sp, #4]
 8003248:	681b      	ldr	r3, [r3, #0]
 800324a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 800324c:	9b01      	ldr	r3, [sp, #4]
 800324e:	689a      	ldr	r2, [r3, #8]
 8003250:	9b00      	ldr	r3, [sp, #0]
 8003252:	689b      	ldr	r3, [r3, #8]
 8003254:	429a      	cmp	r2, r3
 8003256:	bf2c      	ite	cs
 8003258:	2301      	movcs	r3, #1
 800325a:	2300      	movcc	r3, #0
 800325c:	b2db      	uxtb	r3, r3
 800325e:	2b00      	cmp	r3, #0
 8003260:	d1f1      	bne.n	8003246 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8003262:	9b00      	ldr	r3, [sp, #0]
 8003264:	9a01      	ldr	r2, [sp, #4]
 8003266:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003268:	9b01      	ldr	r3, [sp, #4]
 800326a:	685a      	ldr	r2, [r3, #4]
 800326c:	9b00      	ldr	r3, [sp, #0]
 800326e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003270:	9b00      	ldr	r3, [sp, #0]
 8003272:	685b      	ldr	r3, [r3, #4]
 8003274:	9a00      	ldr	r2, [sp, #0]
 8003276:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003278:	9b01      	ldr	r3, [sp, #4]
 800327a:	9a00      	ldr	r2, [sp, #0]
 800327c:	605a      	str	r2, [r3, #4]
  return p;
 800327e:	9b00      	ldr	r3, [sp, #0]
}
 8003280:	4618      	mov	r0, r3
 8003282:	b002      	add	sp, #8
 8003284:	4770      	bx	lr
 8003286:	bf00      	nop
	...

08003290 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8003290:	b082      	sub	sp, #8
 8003292:	9001      	str	r0, [sp, #4]
 8003294:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003296:	9b01      	ldr	r3, [sp, #4]
 8003298:	681b      	ldr	r3, [r3, #0]
 800329a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 800329c:	9b01      	ldr	r3, [sp, #4]
 800329e:	689a      	ldr	r2, [r3, #8]
 80032a0:	9b00      	ldr	r3, [sp, #0]
 80032a2:	689b      	ldr	r3, [r3, #8]
 80032a4:	429a      	cmp	r2, r3
 80032a6:	bf8c      	ite	hi
 80032a8:	2301      	movhi	r3, #1
 80032aa:	2300      	movls	r3, #0
 80032ac:	b2db      	uxtb	r3, r3
 80032ae:	2b00      	cmp	r3, #0
 80032b0:	d1f1      	bne.n	8003296 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 80032b2:	9b00      	ldr	r3, [sp, #0]
 80032b4:	9a01      	ldr	r2, [sp, #4]
 80032b6:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 80032b8:	9b01      	ldr	r3, [sp, #4]
 80032ba:	685a      	ldr	r2, [r3, #4]
 80032bc:	9b00      	ldr	r3, [sp, #0]
 80032be:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 80032c0:	9b00      	ldr	r3, [sp, #0]
 80032c2:	685b      	ldr	r3, [r3, #4]
 80032c4:	9a00      	ldr	r2, [sp, #0]
 80032c6:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 80032c8:	9b01      	ldr	r3, [sp, #4]
 80032ca:	9a00      	ldr	r2, [sp, #0]
 80032cc:	605a      	str	r2, [r3, #4]
  return p;
 80032ce:	9b00      	ldr	r3, [sp, #0]
}
 80032d0:	4618      	mov	r0, r3
 80032d2:	b002      	add	sp, #8
 80032d4:	4770      	bx	lr
 80032d6:	bf00      	nop
	...

080032e0 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 80032e0:	b500      	push	{lr}
 80032e2:	b083      	sub	sp, #12
 80032e4:	2330      	movs	r3, #48	@ 0x30
 80032e6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80032e8:	9b01      	ldr	r3, [sp, #4]
 80032ea:	f383 8811 	msr	BASEPRI, r3
}
 80032ee:	bf00      	nop
}
 80032f0:	bf00      	nop
}
 80032f2:	bf00      	nop
  __dbg_check_lock_from_isr();
 80032f4:	f7ff fb24 	bl	8002940 <__dbg_check_lock_from_isr>
}
 80032f8:	bf00      	nop
 80032fa:	b003      	add	sp, #12
 80032fc:	f85d fb04 	ldr.w	pc, [sp], #4

08003300 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 8003300:	b500      	push	{lr}
 8003302:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8003304:	f7ff fb44 	bl	8002990 <__dbg_check_unlock_from_isr>
 8003308:	2300      	movs	r3, #0
 800330a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800330c:	9b01      	ldr	r3, [sp, #4]
 800330e:	f383 8811 	msr	BASEPRI, r3
}
 8003312:	bf00      	nop
}
 8003314:	bf00      	nop
}
 8003316:	bf00      	nop
}
 8003318:	bf00      	nop
 800331a:	b003      	add	sp, #12
 800331c:	f85d fb04 	ldr.w	pc, [sp], #4

08003320 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8003320:	b500      	push	{lr}
 8003322:	b083      	sub	sp, #12
 8003324:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003326:	f7ff fbd3 	bl	8002ad0 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 800332a:	9b01      	ldr	r3, [sp, #4]
 800332c:	681b      	ldr	r3, [r3, #0]
 800332e:	2b00      	cmp	r3, #0
 8003330:	bf14      	ite	ne
 8003332:	2301      	movne	r3, #1
 8003334:	2300      	moveq	r3, #0
 8003336:	b2db      	uxtb	r3, r3
}
 8003338:	4618      	mov	r0, r3
 800333a:	b003      	add	sp, #12
 800333c:	f85d fb04 	ldr.w	pc, [sp], #4

08003340 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8003340:	b500      	push	{lr}
 8003342:	b083      	sub	sp, #12
 8003344:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003346:	f7ff fbc3 	bl	8002ad0 <chDbgCheckClassI>

  sp->cnt++;
 800334a:	9b01      	ldr	r3, [sp, #4]
 800334c:	689b      	ldr	r3, [r3, #8]
 800334e:	1c5a      	adds	r2, r3, #1
 8003350:	9b01      	ldr	r3, [sp, #4]
 8003352:	609a      	str	r2, [r3, #8]
}
 8003354:	bf00      	nop
 8003356:	b003      	add	sp, #12
 8003358:	f85d fb04 	ldr.w	pc, [sp], #4
 800335c:	0000      	movs	r0, r0
	...

08003360 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8003360:	b500      	push	{lr}
 8003362:	b083      	sub	sp, #12
 8003364:	9001      	str	r0, [sp, #4]

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003366:	9b01      	ldr	r3, [sp, #4]
 8003368:	2200      	movs	r2, #0
 800336a:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800336e:	9b01      	ldr	r3, [sp, #4]
 8003370:	699b      	ldr	r3, [r3, #24]
 8003372:	461a      	mov	r2, r3
 8003374:	9b01      	ldr	r3, [sp, #4]
 8003376:	4619      	mov	r1, r3
 8003378:	4610      	mov	r0, r2
 800337a:	f7ff ff61 	bl	8003240 <ch_pqueue_insert_behind>
 800337e:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
 8003380:	4618      	mov	r0, r3
 8003382:	b003      	add	sp, #12
 8003384:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003390 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8003390:	b500      	push	{lr}
 8003392:	b083      	sub	sp, #12
 8003394:	9001      	str	r0, [sp, #4]

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003396:	9b01      	ldr	r3, [sp, #4]
 8003398:	2200      	movs	r2, #0
 800339a:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 800339e:	9b01      	ldr	r3, [sp, #4]
 80033a0:	699b      	ldr	r3, [r3, #24]
 80033a2:	461a      	mov	r2, r3
 80033a4:	9b01      	ldr	r3, [sp, #4]
 80033a6:	4619      	mov	r1, r3
 80033a8:	4610      	mov	r0, r2
 80033aa:	f7ff ff71 	bl	8003290 <ch_pqueue_insert_ahead>
 80033ae:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
 80033b0:	4618      	mov	r0, r3
 80033b2:	b003      	add	sp, #12
 80033b4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080033c0 <__sch_reschedule_ahead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_ahead(void) {
 80033c0:	b500      	push	{lr}
 80033c2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80033c4:	4b0e      	ldr	r3, [pc, #56]	@ (8003400 <__sch_reschedule_ahead+0x40>)
 80033c6:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 80033c8:	9b03      	ldr	r3, [sp, #12]
 80033ca:	68db      	ldr	r3, [r3, #12]
 80033cc:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 80033ce:	9b03      	ldr	r3, [sp, #12]
 80033d0:	4618      	mov	r0, r3
 80033d2:	f7ff ff1d 	bl	8003210 <ch_pqueue_remove_highest>
 80033d6:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 80033d8:	9b01      	ldr	r3, [sp, #4]
 80033da:	2201      	movs	r2, #1
 80033dc:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 80033e0:	9b03      	ldr	r3, [sp, #12]
 80033e2:	9a01      	ldr	r2, [sp, #4]
 80033e4:	60da      	str	r2, [r3, #12]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = __sch_ready_ahead(otp);
 80033e6:	9802      	ldr	r0, [sp, #8]
 80033e8:	f7ff ffd2 	bl	8003390 <__sch_ready_ahead>
 80033ec:	9002      	str	r0, [sp, #8]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80033ee:	9902      	ldr	r1, [sp, #8]
 80033f0:	9801      	ldr	r0, [sp, #4]
 80033f2:	f7fc ff25 	bl	8000240 <__port_switch>
}
 80033f6:	bf00      	nop
 80033f8:	b005      	add	sp, #20
 80033fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80033fe:	bf00      	nop
 8003400:	200008e8 	.word	0x200008e8
	...

08003410 <__sch_wakeup>:

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8003410:	b500      	push	{lr}
 8003412:	b085      	sub	sp, #20
 8003414:	9001      	str	r0, [sp, #4]
 8003416:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 8003418:	9b00      	ldr	r3, [sp, #0]
 800341a:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 800341c:	f7ff ff60 	bl	80032e0 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
 8003420:	9b03      	ldr	r3, [sp, #12]
 8003422:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003426:	2b0c      	cmp	r3, #12
 8003428:	d82e      	bhi.n	8003488 <__sch_wakeup+0x78>
 800342a:	a201      	add	r2, pc, #4	@ (adr r2, 8003430 <__sch_wakeup+0x20>)
 800342c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003430:	08003465 	.word	0x08003465
 8003434:	08003489 	.word	0x08003489
 8003438:	08003489 	.word	0x08003489
 800343c:	0800346b 	.word	0x0800346b
 8003440:	0800347f 	.word	0x0800347f
 8003444:	08003475 	.word	0x08003475
 8003448:	08003489 	.word	0x08003489
 800344c:	0800347f 	.word	0x0800347f
 8003450:	08003489 	.word	0x08003489
 8003454:	08003489 	.word	0x08003489
 8003458:	08003489 	.word	0x08003489
 800345c:	08003489 	.word	0x08003489
 8003460:	0800347f 	.word	0x0800347f
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8003464:	f7ff ff4c 	bl	8003300 <chSysUnlockFromISR.lto_priv.4>
    return;
 8003468:	e019      	b.n	800349e <__sch_wakeup+0x8e>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800346a:	9b03      	ldr	r3, [sp, #12]
 800346c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800346e:	2200      	movs	r2, #0
 8003470:	601a      	str	r2, [r3, #0]
    break;
 8003472:	e00a      	b.n	800348a <__sch_wakeup+0x7a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8003474:	9b03      	ldr	r3, [sp, #12]
 8003476:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003478:	4618      	mov	r0, r3
 800347a:	f7ff ff61 	bl	8003340 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 800347e:	9b03      	ldr	r3, [sp, #12]
 8003480:	4618      	mov	r0, r3
 8003482:	f7ff feb5 	bl	80031f0 <ch_queue_dequeue.lto_priv.0>
    break;
 8003486:	e000      	b.n	800348a <__sch_wakeup+0x7a>
  default:
    /* Any other state, nothing to do.*/
    break;
 8003488:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 800348a:	9b03      	ldr	r3, [sp, #12]
 800348c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003490:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 8003492:	9803      	ldr	r0, [sp, #12]
 8003494:	f7ff ff64 	bl	8003360 <__sch_ready_behind>
  chSysUnlockFromISR();
 8003498:	f7ff ff32 	bl	8003300 <chSysUnlockFromISR.lto_priv.4>

  return;
 800349c:	bf00      	nop
}
 800349e:	b005      	add	sp, #20
 80034a0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080034b0 <ch_sch_prio_insert>:
 * @param[in] qp        the pointer to the threads list header
 * @param[in] tp        the pointer to the thread to be inserted in the list
 *
 * @notapi
 */
void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 80034b0:	b084      	sub	sp, #16
 80034b2:	9001      	str	r0, [sp, #4]
 80034b4:	9100      	str	r1, [sp, #0]

  ch_queue_t *cp = qp;
 80034b6:	9b01      	ldr	r3, [sp, #4]
 80034b8:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->next;
 80034ba:	9b03      	ldr	r3, [sp, #12]
 80034bc:	681b      	ldr	r3, [r3, #0]
 80034be:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
 80034c0:	9a03      	ldr	r2, [sp, #12]
 80034c2:	9b01      	ldr	r3, [sp, #4]
 80034c4:	429a      	cmp	r2, r3
 80034c6:	d005      	beq.n	80034d4 <ch_sch_prio_insert+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 80034c8:	9b03      	ldr	r3, [sp, #12]
 80034ca:	689a      	ldr	r2, [r3, #8]
 80034cc:	9b00      	ldr	r3, [sp, #0]
 80034ce:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
 80034d0:	429a      	cmp	r2, r3
 80034d2:	d2f2      	bcs.n	80034ba <ch_sch_prio_insert+0xa>
  tp->next       = cp;
 80034d4:	9b00      	ldr	r3, [sp, #0]
 80034d6:	9a03      	ldr	r2, [sp, #12]
 80034d8:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
 80034da:	9b03      	ldr	r3, [sp, #12]
 80034dc:	685a      	ldr	r2, [r3, #4]
 80034de:	9b00      	ldr	r3, [sp, #0]
 80034e0:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
 80034e2:	9b00      	ldr	r3, [sp, #0]
 80034e4:	685b      	ldr	r3, [r3, #4]
 80034e6:	9a00      	ldr	r2, [sp, #0]
 80034e8:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
 80034ea:	9b03      	ldr	r3, [sp, #12]
 80034ec:	9a00      	ldr	r2, [sp, #0]
 80034ee:	605a      	str	r2, [r3, #4]
}
 80034f0:	bf00      	nop
 80034f2:	b004      	add	sp, #16
 80034f4:	4770      	bx	lr
 80034f6:	bf00      	nop
	...

08003500 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003500:	b500      	push	{lr}
 8003502:	b083      	sub	sp, #12
 8003504:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003506:	f7ff fae3 	bl	8002ad0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800350a:	9b01      	ldr	r3, [sp, #4]
 800350c:	2b00      	cmp	r3, #0
 800350e:	bf0c      	ite	eq
 8003510:	2301      	moveq	r3, #1
 8003512:	2300      	movne	r3, #0
 8003514:	b2db      	uxtb	r3, r3
 8003516:	2b00      	cmp	r3, #0
 8003518:	d002      	beq.n	8003520 <chSchReadyI+0x20>
 800351a:	4805      	ldr	r0, [pc, #20]	@ (8003530 <chSchReadyI+0x30>)
 800351c:	f7ff f990 	bl	8002840 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 8003520:	9801      	ldr	r0, [sp, #4]
 8003522:	f7ff ff1d 	bl	8003360 <__sch_ready_behind>
 8003526:	4603      	mov	r3, r0
}
 8003528:	4618      	mov	r0, r3
 800352a:	b003      	add	sp, #12
 800352c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003530:	08004c80 	.word	0x08004c80
	...

08003540 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003540:	b500      	push	{lr}
 8003542:	b087      	sub	sp, #28
 8003544:	4603      	mov	r3, r0
 8003546:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
 800354a:	4b10      	ldr	r3, [pc, #64]	@ (800358c <chSchGoSleepS+0x4c>)
 800354c:	9304      	str	r3, [sp, #16]
  thread_t *otp = __instance_get_currthread(oip);
 800354e:	9b04      	ldr	r3, [sp, #16]
 8003550:	68db      	ldr	r3, [r3, #12]
 8003552:	9303      	str	r3, [sp, #12]
  thread_t *ntp;

  chDbgCheckClassS();
 8003554:	f7ff fadc 	bl	8002b10 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
 8003558:	9b03      	ldr	r3, [sp, #12]
 800355a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800355e:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8003562:	9b04      	ldr	r3, [sp, #16]
 8003564:	4618      	mov	r0, r3
 8003566:	f7ff fe53 	bl	8003210 <ch_pqueue_remove_highest>
 800356a:	9005      	str	r0, [sp, #20]
  ntp->state = CH_STATE_CURRENT;
 800356c:	9b05      	ldr	r3, [sp, #20]
 800356e:	2201      	movs	r2, #1
 8003570:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8003574:	9b04      	ldr	r3, [sp, #16]
 8003576:	9a05      	ldr	r2, [sp, #20]
 8003578:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800357a:	9903      	ldr	r1, [sp, #12]
 800357c:	9805      	ldr	r0, [sp, #20]
 800357e:	f7fc fe5f 	bl	8000240 <__port_switch>
}
 8003582:	bf00      	nop
 8003584:	b007      	add	sp, #28
 8003586:	f85d fb04 	ldr.w	pc, [sp], #4
 800358a:	bf00      	nop
 800358c:	200008e8 	.word	0x200008e8

08003590 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8003590:	b500      	push	{lr}
 8003592:	b08b      	sub	sp, #44	@ 0x2c
 8003594:	4603      	mov	r3, r0
 8003596:	9100      	str	r1, [sp, #0]
 8003598:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 800359c:	4b15      	ldr	r3, [pc, #84]	@ (80035f4 <chSchGoSleepTimeoutS+0x64>)
 800359e:	68db      	ldr	r3, [r3, #12]
 80035a0:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();
 80035a2:	f7ff fab5 	bl	8002b10 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 80035a6:	9b00      	ldr	r3, [sp, #0]
 80035a8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80035ac:	d016      	beq.n	80035dc <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 80035ae:	a803      	add	r0, sp, #12
 80035b0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80035b2:	4a11      	ldr	r2, [pc, #68]	@ (80035f8 <chSchGoSleepTimeoutS+0x68>)
 80035b4:	9900      	ldr	r1, [sp, #0]
 80035b6:	f7ff fccb 	bl	8002f50 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80035ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80035be:	4618      	mov	r0, r3
 80035c0:	f7ff ffbe 	bl	8003540 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80035c4:	ab03      	add	r3, sp, #12
 80035c6:	4618      	mov	r0, r3
 80035c8:	f7ff feaa 	bl	8003320 <chVTIsArmedI>
 80035cc:	4603      	mov	r3, r0
 80035ce:	2b00      	cmp	r3, #0
 80035d0:	d009      	beq.n	80035e6 <chSchGoSleepTimeoutS+0x56>
      chVTDoResetI(&vt);
 80035d2:	ab03      	add	r3, sp, #12
 80035d4:	4618      	mov	r0, r3
 80035d6:	f7ff fcfb 	bl	8002fd0 <chVTDoResetI>
 80035da:	e004      	b.n	80035e6 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
 80035dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80035e0:	4618      	mov	r0, r3
 80035e2:	f7ff ffad 	bl	8003540 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 80035e6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80035e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
}
 80035ea:	4618      	mov	r0, r3
 80035ec:	b00b      	add	sp, #44	@ 0x2c
 80035ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80035f2:	bf00      	nop
 80035f4:	200008e8 	.word	0x200008e8
 80035f8:	08003411 	.word	0x08003411
 80035fc:	00000000 	.word	0x00000000

08003600 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003600:	b500      	push	{lr}
 8003602:	b085      	sub	sp, #20
 8003604:	9001      	str	r0, [sp, #4]
 8003606:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8003608:	4b15      	ldr	r3, [pc, #84]	@ (8003660 <chSchWakeupS+0x60>)
 800360a:	9302      	str	r3, [sp, #8]
  thread_t *otp = __instance_get_currthread(oip);
 800360c:	9b02      	ldr	r3, [sp, #8]
 800360e:	68db      	ldr	r3, [r3, #12]
 8003610:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();
 8003612:	f7ff fa7d 	bl	8002b10 <chDbgCheckClassS>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8003616:	9b01      	ldr	r3, [sp, #4]
 8003618:	9a00      	ldr	r2, [sp, #0]
 800361a:	629a      	str	r2, [r3, #40]	@ 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 800361c:	9b01      	ldr	r3, [sp, #4]
 800361e:	689a      	ldr	r2, [r3, #8]
 8003620:	9b03      	ldr	r3, [sp, #12]
 8003622:	689b      	ldr	r3, [r3, #8]
 8003624:	429a      	cmp	r2, r3
 8003626:	bf94      	ite	ls
 8003628:	2301      	movls	r3, #1
 800362a:	2300      	movhi	r3, #0
 800362c:	b2db      	uxtb	r3, r3
 800362e:	2b00      	cmp	r3, #0
 8003630:	d003      	beq.n	800363a <chSchWakeupS+0x3a>
    (void) __sch_ready_behind(ntp);
 8003632:	9801      	ldr	r0, [sp, #4]
 8003634:	f7ff fe94 	bl	8003360 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8003638:	e00e      	b.n	8003658 <chSchWakeupS+0x58>
    otp = __sch_ready_ahead(otp);
 800363a:	9803      	ldr	r0, [sp, #12]
 800363c:	f7ff fea8 	bl	8003390 <__sch_ready_ahead>
 8003640:	9003      	str	r0, [sp, #12]
    ntp->state = CH_STATE_CURRENT;
 8003642:	9b01      	ldr	r3, [sp, #4]
 8003644:	2201      	movs	r2, #1
 8003646:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    __instance_set_currthread(oip, ntp);
 800364a:	9b02      	ldr	r3, [sp, #8]
 800364c:	9a01      	ldr	r2, [sp, #4]
 800364e:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 8003650:	9903      	ldr	r1, [sp, #12]
 8003652:	9801      	ldr	r0, [sp, #4]
 8003654:	f7fc fdf4 	bl	8000240 <__port_switch>
}
 8003658:	bf00      	nop
 800365a:	b005      	add	sp, #20
 800365c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003660:	200008e8 	.word	0x200008e8
	...

08003670 <chSchRescheduleS>:
 * @note    Only local threads are considered, other cores are signaled
 *          and perform a reschedule locally.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8003670:	b500      	push	{lr}
 8003672:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003674:	4b0c      	ldr	r3, [pc, #48]	@ (80036a8 <chSchRescheduleS+0x38>)
 8003676:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
 8003678:	9b01      	ldr	r3, [sp, #4]
 800367a:	68db      	ldr	r3, [r3, #12]
 800367c:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();
 800367e:	f7ff fa47 	bl	8002b10 <chDbgCheckClassS>

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 8003682:	9b01      	ldr	r3, [sp, #4]
 8003684:	681b      	ldr	r3, [r3, #0]
 8003686:	689a      	ldr	r2, [r3, #8]
 8003688:	9b00      	ldr	r3, [sp, #0]
 800368a:	689b      	ldr	r3, [r3, #8]
 800368c:	429a      	cmp	r2, r3
 800368e:	bf8c      	ite	hi
 8003690:	2301      	movhi	r3, #1
 8003692:	2300      	movls	r3, #0
 8003694:	b2db      	uxtb	r3, r3
 8003696:	2b00      	cmp	r3, #0
 8003698:	d001      	beq.n	800369e <chSchRescheduleS+0x2e>
    __sch_reschedule_ahead();
 800369a:	f7ff fe91 	bl	80033c0 <__sch_reschedule_ahead>
  }
}
 800369e:	bf00      	nop
 80036a0:	b003      	add	sp, #12
 80036a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80036a6:	bf00      	nop
 80036a8:	200008e8 	.word	0x200008e8
 80036ac:	00000000 	.word	0x00000000

080036b0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 80036b0:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 80036b2:	4b0b      	ldr	r3, [pc, #44]	@ (80036e0 <chSchIsPreemptionRequired+0x30>)
 80036b4:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 80036b6:	9b03      	ldr	r3, [sp, #12]
 80036b8:	68db      	ldr	r3, [r3, #12]
 80036ba:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 80036bc:	9b03      	ldr	r3, [sp, #12]
 80036be:	681b      	ldr	r3, [r3, #0]
 80036c0:	689b      	ldr	r3, [r3, #8]
 80036c2:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 80036c4:	9b02      	ldr	r3, [sp, #8]
 80036c6:	689b      	ldr	r3, [r3, #8]
 80036c8:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80036ca:	9a01      	ldr	r2, [sp, #4]
 80036cc:	9b00      	ldr	r3, [sp, #0]
 80036ce:	429a      	cmp	r2, r3
 80036d0:	bf8c      	ite	hi
 80036d2:	2301      	movhi	r3, #1
 80036d4:	2300      	movls	r3, #0
 80036d6:	b2db      	uxtb	r3, r3
#endif
}
 80036d8:	4618      	mov	r0, r3
 80036da:	b004      	add	sp, #16
 80036dc:	4770      	bx	lr
 80036de:	bf00      	nop
 80036e0:	200008e8 	.word	0x200008e8
	...

080036f0 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 80036f0:	b500      	push	{lr}
 80036f2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80036f4:	4b0e      	ldr	r3, [pc, #56]	@ (8003730 <chSchDoPreemption+0x40>)
 80036f6:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 80036f8:	9b03      	ldr	r3, [sp, #12]
 80036fa:	68db      	ldr	r3, [r3, #12]
 80036fc:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 80036fe:	9b03      	ldr	r3, [sp, #12]
 8003700:	4618      	mov	r0, r3
 8003702:	f7ff fd85 	bl	8003210 <ch_pqueue_remove_highest>
 8003706:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 8003708:	9b01      	ldr	r3, [sp, #4]
 800370a:	2201      	movs	r2, #1
 800370c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8003710:	9b03      	ldr	r3, [sp, #12]
 8003712:	9a01      	ldr	r2, [sp, #4]
 8003714:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 8003716:	9802      	ldr	r0, [sp, #8]
 8003718:	f7ff fe3a 	bl	8003390 <__sch_ready_ahead>
 800371c:	9002      	str	r0, [sp, #8]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800371e:	9902      	ldr	r1, [sp, #8]
 8003720:	9801      	ldr	r0, [sp, #4]
 8003722:	f7fc fd8d 	bl	8000240 <__port_switch>
}
 8003726:	bf00      	nop
 8003728:	b005      	add	sp, #20
 800372a:	f85d fb04 	ldr.w	pc, [sp], #4
 800372e:	bf00      	nop
 8003730:	200008e8 	.word	0x200008e8
	...

08003740 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 8003740:	b082      	sub	sp, #8
 8003742:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 8003744:	9b01      	ldr	r3, [sp, #4]
 8003746:	2200      	movs	r2, #0
 8003748:	601a      	str	r2, [r3, #0]
}
 800374a:	bf00      	nop
 800374c:	b002      	add	sp, #8
 800374e:	4770      	bx	lr

08003750 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 8003750:	b082      	sub	sp, #8
 8003752:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 8003754:	9b01      	ldr	r3, [sp, #4]
 8003756:	2200      	movs	r2, #0
 8003758:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 800375a:	9b01      	ldr	r3, [sp, #4]
 800375c:	2200      	movs	r2, #0
 800375e:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 8003760:	9b01      	ldr	r3, [sp, #4]
 8003762:	2201      	movs	r2, #1
 8003764:	609a      	str	r2, [r3, #8]
#endif
}
 8003766:	bf00      	nop
 8003768:	b002      	add	sp, #8
 800376a:	4770      	bx	lr
 800376c:	0000      	movs	r0, r0
	...

08003770 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003770:	b082      	sub	sp, #8
 8003772:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8003774:	9b01      	ldr	r3, [sp, #4]
 8003776:	9a01      	ldr	r2, [sp, #4]
 8003778:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800377a:	9b01      	ldr	r3, [sp, #4]
 800377c:	9a01      	ldr	r2, [sp, #4]
 800377e:	605a      	str	r2, [r3, #4]
}
 8003780:	bf00      	nop
 8003782:	b002      	add	sp, #8
 8003784:	4770      	bx	lr
 8003786:	bf00      	nop
	...

08003790 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 8003790:	b082      	sub	sp, #8
 8003792:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 8003794:	9b01      	ldr	r3, [sp, #4]
 8003796:	9a01      	ldr	r2, [sp, #4]
 8003798:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 800379a:	9b01      	ldr	r3, [sp, #4]
 800379c:	9a01      	ldr	r2, [sp, #4]
 800379e:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 80037a0:	9b01      	ldr	r3, [sp, #4]
 80037a2:	2200      	movs	r2, #0
 80037a4:	609a      	str	r2, [r3, #8]
}
 80037a6:	bf00      	nop
 80037a8:	b002      	add	sp, #8
 80037aa:	4770      	bx	lr
 80037ac:	0000      	movs	r0, r0
	...

080037b0 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 80037b0:	b082      	sub	sp, #8
 80037b2:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 80037b4:	9b01      	ldr	r3, [sp, #4]
 80037b6:	9a01      	ldr	r2, [sp, #4]
 80037b8:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 80037ba:	9b01      	ldr	r3, [sp, #4]
 80037bc:	9a01      	ldr	r2, [sp, #4]
 80037be:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 80037c0:	9b01      	ldr	r3, [sp, #4]
 80037c2:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80037c6:	609a      	str	r2, [r3, #8]
}
 80037c8:	bf00      	nop
 80037ca:	b002      	add	sp, #8
 80037cc:	4770      	bx	lr
 80037ce:	bf00      	nop

080037d0 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 80037d0:	b508      	push	{r3, lr}
  return stGetCounter();
 80037d2:	f7fc fe15 	bl	8000400 <stGetCounter>
 80037d6:	4603      	mov	r3, r0
}
 80037d8:	4618      	mov	r0, r3
 80037da:	bd08      	pop	{r3, pc}
 80037dc:	0000      	movs	r0, r0
	...

080037e0 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 80037e0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 80037e2:	f7ff fff5 	bl	80037d0 <port_timer_get_time.lto_priv.1>
 80037e6:	4603      	mov	r3, r0
}
 80037e8:	4618      	mov	r0, r3
 80037ea:	bd08      	pop	{r3, pc}
 80037ec:	0000      	movs	r0, r0
	...

080037f0 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 80037f0:	b530      	push	{r4, r5, lr}
 80037f2:	b083      	sub	sp, #12
 80037f4:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 80037f6:	9b01      	ldr	r3, [sp, #4]
 80037f8:	4618      	mov	r0, r3
 80037fa:	f7ff ffd9 	bl	80037b0 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 80037fe:	9b01      	ldr	r3, [sp, #4]
 8003800:	2200      	movs	r2, #0
 8003802:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003804:	f7ff ffec 	bl	80037e0 <chVTGetSystemTimeX.lto_priv.1>
 8003808:	4603      	mov	r3, r0
 800380a:	2200      	movs	r2, #0
 800380c:	461c      	mov	r4, r3
 800380e:	4615      	mov	r5, r2
 8003810:	9b01      	ldr	r3, [sp, #4]
 8003812:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 8003816:	bf00      	nop
 8003818:	b003      	add	sp, #12
 800381a:	bd30      	pop	{r4, r5, pc}
 800381c:	0000      	movs	r0, r0
	...

08003820 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8003820:	b500      	push	{lr}
 8003822:	b083      	sub	sp, #12
 8003824:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 8003826:	9b01      	ldr	r3, [sp, #4]
 8003828:	4618      	mov	r0, r3
 800382a:	f7ff ffa1 	bl	8003770 <ch_queue_init.lto_priv.2>
}
 800382e:	bf00      	nop
 8003830:	b003      	add	sp, #12
 8003832:	f85d fb04 	ldr.w	pc, [sp], #4
 8003836:	bf00      	nop
	...

08003840 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8003840:	b082      	sub	sp, #8
 8003842:	9001      	str	r0, [sp, #4]
__STATIC_FORCEINLINE void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8003844:	bf00      	nop
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
    asm volatile ("nop");
 8003846:	bf00      	nop
    port_wait_for_interrupt();
 8003848:	bf00      	nop
 800384a:	e7fb      	b.n	8003844 <__idle_thread+0x4>
 800384c:	0000      	movs	r0, r0
	...

08003850 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8003850:	b500      	push	{lr}
 8003852:	b08b      	sub	sp, #44	@ 0x2c
 8003854:	9001      	str	r0, [sp, #4]
 8003856:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 8003858:	2300      	movs	r3, #0
 800385a:	9309      	str	r3, [sp, #36]	@ 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 800385c:	4a28      	ldr	r2, [pc, #160]	@ (8003900 <chInstanceObjectInit+0xb0>)
 800385e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003860:	009b      	lsls	r3, r3, #2
 8003862:	4413      	add	r3, r2
 8003864:	9a01      	ldr	r2, [sp, #4]
 8003866:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 8003868:	9b01      	ldr	r3, [sp, #4]
 800386a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800386c:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 800386e:	9b01      	ldr	r3, [sp, #4]
 8003870:	9a00      	ldr	r2, [sp, #0]
 8003872:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 8003874:	9801      	ldr	r0, [sp, #4]
 8003876:	f000 fedb 	bl	8004630 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 800387a:	9b01      	ldr	r3, [sp, #4]
 800387c:	4618      	mov	r0, r3
 800387e:	f7ff ff87 	bl	8003790 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 8003882:	9b01      	ldr	r3, [sp, #4]
 8003884:	3328      	adds	r3, #40	@ 0x28
 8003886:	4618      	mov	r0, r3
 8003888:	f7ff ffca 	bl	8003820 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 800388c:	9b01      	ldr	r3, [sp, #4]
 800388e:	3334      	adds	r3, #52	@ 0x34
 8003890:	4618      	mov	r0, r3
 8003892:	f7ff ff55 	bl	8003740 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8003896:	9b01      	ldr	r3, [sp, #4]
 8003898:	3310      	adds	r3, #16
 800389a:	4618      	mov	r0, r3
 800389c:	f7ff ffa8 	bl	80037f0 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 80038a0:	9b01      	ldr	r3, [sp, #4]
 80038a2:	3384      	adds	r3, #132	@ 0x84
 80038a4:	4618      	mov	r0, r3
 80038a6:	f7ff ff53 	bl	8003750 <__dbg_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 80038aa:	9b01      	ldr	r3, [sp, #4]
 80038ac:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 80038b0:	2380      	movs	r3, #128	@ 0x80
 80038b2:	4a14      	ldr	r2, [pc, #80]	@ (8003904 <chInstanceObjectInit+0xb4>)
 80038b4:	9801      	ldr	r0, [sp, #4]
 80038b6:	f000 f8cb 	bl	8003a50 <__thd_object_init>
 80038ba:	4602      	mov	r2, r0
 80038bc:	9b01      	ldr	r3, [sp, #4]
 80038be:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 80038c0:	9b01      	ldr	r3, [sp, #4]
 80038c2:	68db      	ldr	r3, [r3, #12]
 80038c4:	9a00      	ldr	r2, [sp, #0]
 80038c6:	6852      	ldr	r2, [r2, #4]
 80038c8:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 80038ca:	9b01      	ldr	r3, [sp, #4]
 80038cc:	68db      	ldr	r3, [r3, #12]
 80038ce:	2201      	movs	r2, #1
 80038d0:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 80038d4:	4b0c      	ldr	r3, [pc, #48]	@ (8003908 <chInstanceObjectInit+0xb8>)
 80038d6:	9303      	str	r3, [sp, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 80038d8:	9b00      	ldr	r3, [sp, #0]
 80038da:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 80038dc:	9304      	str	r3, [sp, #16]
      .wend     = oicp->idlethread_end,
 80038de:	9b00      	ldr	r3, [sp, #0]
 80038e0:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 80038e2:	9305      	str	r3, [sp, #20]
 80038e4:	2301      	movs	r3, #1
 80038e6:	9306      	str	r3, [sp, #24]
 80038e8:	4b08      	ldr	r3, [pc, #32]	@ (800390c <chInstanceObjectInit+0xbc>)
 80038ea:	9307      	str	r3, [sp, #28]
 80038ec:	2300      	movs	r3, #0
 80038ee:	9308      	str	r3, [sp, #32]
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 80038f0:	ab03      	add	r3, sp, #12
 80038f2:	4618      	mov	r0, r3
 80038f4:	f000 f97c 	bl	8003bf0 <chThdCreateI>
  }
#endif
}
 80038f8:	bf00      	nop
 80038fa:	b00b      	add	sp, #44	@ 0x2c
 80038fc:	f85d fb04 	ldr.w	pc, [sp], #4
 8003900:	200008dc 	.word	0x200008dc
 8003904:	08004cc4 	.word	0x08004cc4
 8003908:	08004c2c 	.word	0x08004c2c
 800390c:	08003841 	.word	0x08003841

08003910 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 8003910:	b082      	sub	sp, #8
 8003912:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 8003914:	9b01      	ldr	r3, [sp, #4]
 8003916:	9a01      	ldr	r2, [sp, #4]
 8003918:	601a      	str	r2, [r3, #0]
}
 800391a:	bf00      	nop
 800391c:	b002      	add	sp, #8
 800391e:	4770      	bx	lr

08003920 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 8003920:	b082      	sub	sp, #8
 8003922:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 8003924:	9b01      	ldr	r3, [sp, #4]
 8003926:	681b      	ldr	r3, [r3, #0]
 8003928:	9a01      	ldr	r2, [sp, #4]
 800392a:	429a      	cmp	r2, r3
 800392c:	bf14      	ite	ne
 800392e:	2301      	movne	r3, #1
 8003930:	2300      	moveq	r3, #0
 8003932:	b2db      	uxtb	r3, r3
}
 8003934:	4618      	mov	r0, r3
 8003936:	b002      	add	sp, #8
 8003938:	4770      	bx	lr
 800393a:	bf00      	nop
 800393c:	0000      	movs	r0, r0
	...

08003940 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 8003940:	b084      	sub	sp, #16
 8003942:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 8003944:	9b01      	ldr	r3, [sp, #4]
 8003946:	681b      	ldr	r3, [r3, #0]
 8003948:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 800394a:	9b03      	ldr	r3, [sp, #12]
 800394c:	681a      	ldr	r2, [r3, #0]
 800394e:	9b01      	ldr	r3, [sp, #4]
 8003950:	601a      	str	r2, [r3, #0]
  return p;
 8003952:	9b03      	ldr	r3, [sp, #12]
}
 8003954:	4618      	mov	r0, r3
 8003956:	b004      	add	sp, #16
 8003958:	4770      	bx	lr
 800395a:	bf00      	nop
 800395c:	0000      	movs	r0, r0
	...

08003960 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003960:	b082      	sub	sp, #8
 8003962:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8003964:	9b01      	ldr	r3, [sp, #4]
 8003966:	9a01      	ldr	r2, [sp, #4]
 8003968:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800396a:	9b01      	ldr	r3, [sp, #4]
 800396c:	9a01      	ldr	r2, [sp, #4]
 800396e:	605a      	str	r2, [r3, #4]
}
 8003970:	bf00      	nop
 8003972:	b002      	add	sp, #8
 8003974:	4770      	bx	lr
 8003976:	bf00      	nop
	...

08003980 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8003980:	b082      	sub	sp, #8
 8003982:	9001      	str	r0, [sp, #4]
 8003984:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 8003986:	9b00      	ldr	r3, [sp, #0]
 8003988:	9a01      	ldr	r2, [sp, #4]
 800398a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 800398c:	9b01      	ldr	r3, [sp, #4]
 800398e:	685a      	ldr	r2, [r3, #4]
 8003990:	9b00      	ldr	r3, [sp, #0]
 8003992:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003994:	9b00      	ldr	r3, [sp, #0]
 8003996:	685b      	ldr	r3, [r3, #4]
 8003998:	9a00      	ldr	r2, [sp, #0]
 800399a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 800399c:	9b01      	ldr	r3, [sp, #4]
 800399e:	9a00      	ldr	r2, [sp, #0]
 80039a0:	605a      	str	r2, [r3, #4]
}
 80039a2:	bf00      	nop
 80039a4:	b002      	add	sp, #8
 80039a6:	4770      	bx	lr
	...

080039b0 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80039b0:	b082      	sub	sp, #8
 80039b2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80039b4:	9b01      	ldr	r3, [sp, #4]
 80039b6:	685b      	ldr	r3, [r3, #4]
 80039b8:	9a01      	ldr	r2, [sp, #4]
 80039ba:	6812      	ldr	r2, [r2, #0]
 80039bc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80039be:	9b01      	ldr	r3, [sp, #4]
 80039c0:	681b      	ldr	r3, [r3, #0]
 80039c2:	9a01      	ldr	r2, [sp, #4]
 80039c4:	6852      	ldr	r2, [r2, #4]
 80039c6:	605a      	str	r2, [r3, #4]
  return p;
 80039c8:	9b01      	ldr	r3, [sp, #4]
}
 80039ca:	4618      	mov	r0, r3
 80039cc:	b002      	add	sp, #8
 80039ce:	4770      	bx	lr

080039d0 <chSysLock.lto_priv.7>:
static inline void chSysLock(void) {
 80039d0:	b500      	push	{lr}
 80039d2:	b083      	sub	sp, #12
 80039d4:	2330      	movs	r3, #48	@ 0x30
 80039d6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80039d8:	9b01      	ldr	r3, [sp, #4]
 80039da:	f383 8811 	msr	BASEPRI, r3
}
 80039de:	bf00      	nop
}
 80039e0:	bf00      	nop
  __dbg_check_lock();
 80039e2:	f7fe ff5d 	bl	80028a0 <__dbg_check_lock>
}
 80039e6:	bf00      	nop
 80039e8:	b003      	add	sp, #12
 80039ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80039ee:	bf00      	nop

080039f0 <chSysUnlock.lto_priv.7>:
static inline void chSysUnlock(void) {
 80039f0:	b500      	push	{lr}
 80039f2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80039f4:	f7fe ff7c 	bl	80028f0 <__dbg_check_unlock>
 80039f8:	2300      	movs	r3, #0
 80039fa:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80039fc:	9b01      	ldr	r3, [sp, #4]
 80039fe:	f383 8811 	msr	BASEPRI, r3
}
 8003a02:	bf00      	nop
}
 8003a04:	bf00      	nop
}
 8003a06:	bf00      	nop
 8003a08:	b003      	add	sp, #12
 8003a0a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a0e:	bf00      	nop

08003a10 <chThdGetSelfX.lto_priv.0>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8003a10:	4b01      	ldr	r3, [pc, #4]	@ (8003a18 <chThdGetSelfX.lto_priv.0+0x8>)
 8003a12:	68db      	ldr	r3, [r3, #12]
}
 8003a14:	4618      	mov	r0, r3
 8003a16:	4770      	bx	lr
 8003a18:	200008e8 	.word	0x200008e8
 8003a1c:	00000000 	.word	0x00000000

08003a20 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 8003a20:	b500      	push	{lr}
 8003a22:	b083      	sub	sp, #12
 8003a24:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8003a26:	9b01      	ldr	r3, [sp, #4]
 8003a28:	2b00      	cmp	r3, #0
 8003a2a:	bf0c      	ite	eq
 8003a2c:	2301      	moveq	r3, #1
 8003a2e:	2300      	movne	r3, #0
 8003a30:	b2db      	uxtb	r3, r3
 8003a32:	2b00      	cmp	r3, #0
 8003a34:	d002      	beq.n	8003a3c <chThdSleepS+0x1c>
 8003a36:	4805      	ldr	r0, [pc, #20]	@ (8003a4c <chThdSleepS+0x2c>)
 8003a38:	f7fe ff02 	bl	8002840 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8003a3c:	9901      	ldr	r1, [sp, #4]
 8003a3e:	2008      	movs	r0, #8
 8003a40:	f7ff fda6 	bl	8003590 <chSchGoSleepTimeoutS>
}
 8003a44:	bf00      	nop
 8003a46:	b003      	add	sp, #12
 8003a48:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a4c:	08004cb8 	.word	0x08004cb8

08003a50 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8003a50:	b500      	push	{lr}
 8003a52:	b085      	sub	sp, #20
 8003a54:	9003      	str	r0, [sp, #12]
 8003a56:	9102      	str	r1, [sp, #8]
 8003a58:	9201      	str	r2, [sp, #4]
 8003a5a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 8003a5c:	9b02      	ldr	r3, [sp, #8]
 8003a5e:	9a00      	ldr	r2, [sp, #0]
 8003a60:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8003a62:	9b02      	ldr	r3, [sp, #8]
 8003a64:	2202      	movs	r2, #2
 8003a66:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 8003a6a:	9b02      	ldr	r3, [sp, #8]
 8003a6c:	2200      	movs	r2, #0
 8003a6e:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  tp->owner             = oip;
 8003a72:	9b02      	ldr	r3, [sp, #8]
 8003a74:	9a03      	ldr	r2, [sp, #12]
 8003a76:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8003a78:	9b02      	ldr	r3, [sp, #8]
 8003a7a:	9a00      	ldr	r2, [sp, #0]
 8003a7c:	641a      	str	r2, [r3, #64]	@ 0x40
  tp->mtxlist           = NULL;
 8003a7e:	9b02      	ldr	r3, [sp, #8]
 8003a80:	2200      	movs	r2, #0
 8003a82:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8003a84:	9b02      	ldr	r3, [sp, #8]
 8003a86:	2200      	movs	r2, #0
 8003a88:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 8003a8a:	9b02      	ldr	r3, [sp, #8]
 8003a8c:	2201      	movs	r2, #1
 8003a8e:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
  tp->name              = name;
 8003a92:	9b02      	ldr	r3, [sp, #8]
 8003a94:	9a01      	ldr	r2, [sp, #4]
 8003a96:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 8003a98:	9b03      	ldr	r3, [sp, #12]
 8003a9a:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 8003a9e:	9b02      	ldr	r3, [sp, #8]
 8003aa0:	3310      	adds	r3, #16
 8003aa2:	4619      	mov	r1, r3
 8003aa4:	4610      	mov	r0, r2
 8003aa6:	f7ff ff6b 	bl	8003980 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 8003aaa:	9b02      	ldr	r3, [sp, #8]
 8003aac:	332c      	adds	r3, #44	@ 0x2c
 8003aae:	4618      	mov	r0, r3
 8003ab0:	f7ff ff2e 	bl	8003910 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8003ab4:	9b02      	ldr	r3, [sp, #8]
 8003ab6:	3330      	adds	r3, #48	@ 0x30
 8003ab8:	4618      	mov	r0, r3
 8003aba:	f7ff ff51 	bl	8003960 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8003abe:	9b02      	ldr	r3, [sp, #8]
}
 8003ac0:	4618      	mov	r0, r3
 8003ac2:	b005      	add	sp, #20
 8003ac4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003ad0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8003ad0:	b500      	push	{lr}
 8003ad2:	b085      	sub	sp, #20
 8003ad4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8003ad6:	f7fe fffb 	bl	8002ad0 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8003ada:	9b01      	ldr	r3, [sp, #4]
 8003adc:	2b00      	cmp	r3, #0
 8003ade:	bf0c      	ite	eq
 8003ae0:	2301      	moveq	r3, #1
 8003ae2:	2300      	movne	r3, #0
 8003ae4:	b2db      	uxtb	r3, r3
 8003ae6:	2b00      	cmp	r3, #0
 8003ae8:	d002      	beq.n	8003af0 <chThdCreateSuspendedI+0x20>
 8003aea:	483d      	ldr	r0, [pc, #244]	@ (8003be0 <chThdCreateSuspendedI+0x110>)
 8003aec:	f7fe fea8 	bl	8002840 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8003af0:	9b01      	ldr	r3, [sp, #4]
 8003af2:	685b      	ldr	r3, [r3, #4]
 8003af4:	f003 0307 	and.w	r3, r3, #7
 8003af8:	2b00      	cmp	r3, #0
 8003afa:	bf14      	ite	ne
 8003afc:	2301      	movne	r3, #1
 8003afe:	2300      	moveq	r3, #0
 8003b00:	b2db      	uxtb	r3, r3
 8003b02:	2b00      	cmp	r3, #0
 8003b04:	d10a      	bne.n	8003b1c <chThdCreateSuspendedI+0x4c>
 8003b06:	9b01      	ldr	r3, [sp, #4]
 8003b08:	689b      	ldr	r3, [r3, #8]
 8003b0a:	f003 0307 	and.w	r3, r3, #7
 8003b0e:	2b00      	cmp	r3, #0
 8003b10:	bf14      	ite	ne
 8003b12:	2301      	movne	r3, #1
 8003b14:	2300      	moveq	r3, #0
 8003b16:	b2db      	uxtb	r3, r3
 8003b18:	2b00      	cmp	r3, #0
 8003b1a:	d001      	beq.n	8003b20 <chThdCreateSuspendedI+0x50>
 8003b1c:	2301      	movs	r3, #1
 8003b1e:	e000      	b.n	8003b22 <chThdCreateSuspendedI+0x52>
 8003b20:	2300      	movs	r3, #0
 8003b22:	2b00      	cmp	r3, #0
 8003b24:	d10a      	bne.n	8003b3c <chThdCreateSuspendedI+0x6c>
 8003b26:	9b01      	ldr	r3, [sp, #4]
 8003b28:	689a      	ldr	r2, [r3, #8]
 8003b2a:	9b01      	ldr	r3, [sp, #4]
 8003b2c:	685b      	ldr	r3, [r3, #4]
 8003b2e:	429a      	cmp	r2, r3
 8003b30:	bf94      	ite	ls
 8003b32:	2301      	movls	r3, #1
 8003b34:	2300      	movhi	r3, #0
 8003b36:	b2db      	uxtb	r3, r3
 8003b38:	2b00      	cmp	r3, #0
 8003b3a:	d001      	beq.n	8003b40 <chThdCreateSuspendedI+0x70>
 8003b3c:	2301      	movs	r3, #1
 8003b3e:	e000      	b.n	8003b42 <chThdCreateSuspendedI+0x72>
 8003b40:	2300      	movs	r3, #0
 8003b42:	2b00      	cmp	r3, #0
 8003b44:	d10c      	bne.n	8003b60 <chThdCreateSuspendedI+0x90>
 8003b46:	9b01      	ldr	r3, [sp, #4]
 8003b48:	689b      	ldr	r3, [r3, #8]
 8003b4a:	461a      	mov	r2, r3
 8003b4c:	9b01      	ldr	r3, [sp, #4]
 8003b4e:	685b      	ldr	r3, [r3, #4]
 8003b50:	1ad3      	subs	r3, r2, r3
 8003b52:	2bef      	cmp	r3, #239	@ 0xef
 8003b54:	bf94      	ite	ls
 8003b56:	2301      	movls	r3, #1
 8003b58:	2300      	movhi	r3, #0
 8003b5a:	b2db      	uxtb	r3, r3
 8003b5c:	2b00      	cmp	r3, #0
 8003b5e:	d002      	beq.n	8003b66 <chThdCreateSuspendedI+0x96>
 8003b60:	481f      	ldr	r0, [pc, #124]	@ (8003be0 <chThdCreateSuspendedI+0x110>)
 8003b62:	f7fe fe6d 	bl	8002840 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8003b66:	9b01      	ldr	r3, [sp, #4]
 8003b68:	68db      	ldr	r3, [r3, #12]
 8003b6a:	2bff      	cmp	r3, #255	@ 0xff
 8003b6c:	bf8c      	ite	hi
 8003b6e:	2301      	movhi	r3, #1
 8003b70:	2300      	movls	r3, #0
 8003b72:	b2db      	uxtb	r3, r3
 8003b74:	2b00      	cmp	r3, #0
 8003b76:	d108      	bne.n	8003b8a <chThdCreateSuspendedI+0xba>
 8003b78:	9b01      	ldr	r3, [sp, #4]
 8003b7a:	691b      	ldr	r3, [r3, #16]
 8003b7c:	2b00      	cmp	r3, #0
 8003b7e:	bf0c      	ite	eq
 8003b80:	2301      	moveq	r3, #1
 8003b82:	2300      	movne	r3, #0
 8003b84:	b2db      	uxtb	r3, r3
 8003b86:	2b00      	cmp	r3, #0
 8003b88:	d002      	beq.n	8003b90 <chThdCreateSuspendedI+0xc0>
 8003b8a:	4815      	ldr	r0, [pc, #84]	@ (8003be0 <chThdCreateSuspendedI+0x110>)
 8003b8c:	f7fe fe58 	bl	8002840 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 8003b90:	9b01      	ldr	r3, [sp, #4]
 8003b92:	689b      	ldr	r3, [r3, #8]
 8003b94:	3b48      	subs	r3, #72	@ 0x48
 8003b96:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8003b98:	9b01      	ldr	r3, [sp, #4]
 8003b9a:	685a      	ldr	r2, [r3, #4]
 8003b9c:	9b03      	ldr	r3, [sp, #12]
 8003b9e:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003ba0:	9b03      	ldr	r3, [sp, #12]
 8003ba2:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8003ba6:	9b03      	ldr	r3, [sp, #12]
 8003ba8:	60da      	str	r2, [r3, #12]
 8003baa:	9b01      	ldr	r3, [sp, #4]
 8003bac:	691a      	ldr	r2, [r3, #16]
 8003bae:	9b03      	ldr	r3, [sp, #12]
 8003bb0:	68db      	ldr	r3, [r3, #12]
 8003bb2:	601a      	str	r2, [r3, #0]
 8003bb4:	9b01      	ldr	r3, [sp, #4]
 8003bb6:	695a      	ldr	r2, [r3, #20]
 8003bb8:	9b03      	ldr	r3, [sp, #12]
 8003bba:	68db      	ldr	r3, [r3, #12]
 8003bbc:	605a      	str	r2, [r3, #4]
 8003bbe:	9b03      	ldr	r3, [sp, #12]
 8003bc0:	68db      	ldr	r3, [r3, #12]
 8003bc2:	4a08      	ldr	r2, [pc, #32]	@ (8003be4 <chThdCreateSuspendedI+0x114>)
 8003bc4:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8003bc6:	9b01      	ldr	r3, [sp, #4]
 8003bc8:	681a      	ldr	r2, [r3, #0]
 8003bca:	9b01      	ldr	r3, [sp, #4]
 8003bcc:	68db      	ldr	r3, [r3, #12]
 8003bce:	9903      	ldr	r1, [sp, #12]
 8003bd0:	4805      	ldr	r0, [pc, #20]	@ (8003be8 <chThdCreateSuspendedI+0x118>)
 8003bd2:	f7ff ff3d 	bl	8003a50 <__thd_object_init>
 8003bd6:	4603      	mov	r3, r0
}
 8003bd8:	4618      	mov	r0, r3
 8003bda:	b005      	add	sp, #20
 8003bdc:	f85d fb04 	ldr.w	pc, [sp], #4
 8003be0:	08004c8c 	.word	0x08004c8c
 8003be4:	08000251 	.word	0x08000251
 8003be8:	200008e8 	.word	0x200008e8
 8003bec:	00000000 	.word	0x00000000

08003bf0 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8003bf0:	b500      	push	{lr}
 8003bf2:	b083      	sub	sp, #12
 8003bf4:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8003bf6:	9801      	ldr	r0, [sp, #4]
 8003bf8:	f7ff ff6a 	bl	8003ad0 <chThdCreateSuspendedI>
 8003bfc:	4603      	mov	r3, r0
 8003bfe:	4618      	mov	r0, r3
 8003c00:	f7ff fc7e 	bl	8003500 <chSchReadyI>
 8003c04:	4603      	mov	r3, r0
}
 8003c06:	4618      	mov	r0, r3
 8003c08:	b003      	add	sp, #12
 8003c0a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c0e:	bf00      	nop

08003c10 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003c10:	b500      	push	{lr}
 8003c12:	b087      	sub	sp, #28
 8003c14:	9003      	str	r0, [sp, #12]
 8003c16:	9102      	str	r1, [sp, #8]
 8003c18:	9201      	str	r2, [sp, #4]
 8003c1a:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 8003c1c:	9b03      	ldr	r3, [sp, #12]
 8003c1e:	2b00      	cmp	r3, #0
 8003c20:	bf0c      	ite	eq
 8003c22:	2301      	moveq	r3, #1
 8003c24:	2300      	movne	r3, #0
 8003c26:	b2db      	uxtb	r3, r3
 8003c28:	2b00      	cmp	r3, #0
 8003c2a:	d109      	bne.n	8003c40 <chThdCreateStatic+0x30>
 8003c2c:	9b03      	ldr	r3, [sp, #12]
 8003c2e:	f003 0307 	and.w	r3, r3, #7
 8003c32:	2b00      	cmp	r3, #0
 8003c34:	bf14      	ite	ne
 8003c36:	2301      	movne	r3, #1
 8003c38:	2300      	moveq	r3, #0
 8003c3a:	b2db      	uxtb	r3, r3
 8003c3c:	2b00      	cmp	r3, #0
 8003c3e:	d001      	beq.n	8003c44 <chThdCreateStatic+0x34>
 8003c40:	2301      	movs	r3, #1
 8003c42:	e000      	b.n	8003c46 <chThdCreateStatic+0x36>
 8003c44:	2300      	movs	r3, #0
 8003c46:	2b00      	cmp	r3, #0
 8003c48:	d107      	bne.n	8003c5a <chThdCreateStatic+0x4a>
 8003c4a:	9b02      	ldr	r3, [sp, #8]
 8003c4c:	2bef      	cmp	r3, #239	@ 0xef
 8003c4e:	bf94      	ite	ls
 8003c50:	2301      	movls	r3, #1
 8003c52:	2300      	movhi	r3, #0
 8003c54:	b2db      	uxtb	r3, r3
 8003c56:	2b00      	cmp	r3, #0
 8003c58:	d001      	beq.n	8003c5e <chThdCreateStatic+0x4e>
 8003c5a:	2301      	movs	r3, #1
 8003c5c:	e000      	b.n	8003c60 <chThdCreateStatic+0x50>
 8003c5e:	2300      	movs	r3, #0
 8003c60:	2b00      	cmp	r3, #0
 8003c62:	d109      	bne.n	8003c78 <chThdCreateStatic+0x68>
 8003c64:	9b02      	ldr	r3, [sp, #8]
 8003c66:	f003 0307 	and.w	r3, r3, #7
 8003c6a:	2b00      	cmp	r3, #0
 8003c6c:	bf14      	ite	ne
 8003c6e:	2301      	movne	r3, #1
 8003c70:	2300      	moveq	r3, #0
 8003c72:	b2db      	uxtb	r3, r3
 8003c74:	2b00      	cmp	r3, #0
 8003c76:	d001      	beq.n	8003c7c <chThdCreateStatic+0x6c>
 8003c78:	2301      	movs	r3, #1
 8003c7a:	e000      	b.n	8003c7e <chThdCreateStatic+0x6e>
 8003c7c:	2300      	movs	r3, #0
 8003c7e:	2b00      	cmp	r3, #0
 8003c80:	d107      	bne.n	8003c92 <chThdCreateStatic+0x82>
 8003c82:	9b01      	ldr	r3, [sp, #4]
 8003c84:	2bff      	cmp	r3, #255	@ 0xff
 8003c86:	bf8c      	ite	hi
 8003c88:	2301      	movhi	r3, #1
 8003c8a:	2300      	movls	r3, #0
 8003c8c:	b2db      	uxtb	r3, r3
 8003c8e:	2b00      	cmp	r3, #0
 8003c90:	d001      	beq.n	8003c96 <chThdCreateStatic+0x86>
 8003c92:	2301      	movs	r3, #1
 8003c94:	e000      	b.n	8003c98 <chThdCreateStatic+0x88>
 8003c96:	2300      	movs	r3, #0
 8003c98:	2b00      	cmp	r3, #0
 8003c9a:	d107      	bne.n	8003cac <chThdCreateStatic+0x9c>
 8003c9c:	9b00      	ldr	r3, [sp, #0]
 8003c9e:	2b00      	cmp	r3, #0
 8003ca0:	bf0c      	ite	eq
 8003ca2:	2301      	moveq	r3, #1
 8003ca4:	2300      	movne	r3, #0
 8003ca6:	b2db      	uxtb	r3, r3
 8003ca8:	2b00      	cmp	r3, #0
 8003caa:	d002      	beq.n	8003cb2 <chThdCreateStatic+0xa2>
 8003cac:	4817      	ldr	r0, [pc, #92]	@ (8003d0c <chThdCreateStatic+0xfc>)
 8003cae:	f7fe fdc7 	bl	8002840 <chSysHalt>

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wsp, (uint8_t *)wsp + size);
#endif

  chSysLock();
 8003cb2:	f7ff fe8d 	bl	80039d0 <chSysLock.lto_priv.7>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 8003cb6:	9b02      	ldr	r3, [sp, #8]
 8003cb8:	3b48      	subs	r3, #72	@ 0x48
 8003cba:	9a03      	ldr	r2, [sp, #12]
 8003cbc:	4413      	add	r3, r2
 8003cbe:	9305      	str	r3, [sp, #20]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8003cc0:	9b05      	ldr	r3, [sp, #20]
 8003cc2:	9a03      	ldr	r2, [sp, #12]
 8003cc4:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003cc6:	9b05      	ldr	r3, [sp, #20]
 8003cc8:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8003ccc:	9b05      	ldr	r3, [sp, #20]
 8003cce:	60da      	str	r2, [r3, #12]
 8003cd0:	9b05      	ldr	r3, [sp, #20]
 8003cd2:	68db      	ldr	r3, [r3, #12]
 8003cd4:	9a00      	ldr	r2, [sp, #0]
 8003cd6:	601a      	str	r2, [r3, #0]
 8003cd8:	9b05      	ldr	r3, [sp, #20]
 8003cda:	68db      	ldr	r3, [r3, #12]
 8003cdc:	9a08      	ldr	r2, [sp, #32]
 8003cde:	605a      	str	r2, [r3, #4]
 8003ce0:	9b05      	ldr	r3, [sp, #20]
 8003ce2:	68db      	ldr	r3, [r3, #12]
 8003ce4:	4a0a      	ldr	r2, [pc, #40]	@ (8003d10 <chThdCreateStatic+0x100>)
 8003ce6:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 8003ce8:	9b01      	ldr	r3, [sp, #4]
 8003cea:	4a0a      	ldr	r2, [pc, #40]	@ (8003d14 <chThdCreateStatic+0x104>)
 8003cec:	9905      	ldr	r1, [sp, #20]
 8003cee:	480a      	ldr	r0, [pc, #40]	@ (8003d18 <chThdCreateStatic+0x108>)
 8003cf0:	f7ff feae 	bl	8003a50 <__thd_object_init>
 8003cf4:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8003cf6:	2100      	movs	r1, #0
 8003cf8:	9805      	ldr	r0, [sp, #20]
 8003cfa:	f7ff fc81 	bl	8003600 <chSchWakeupS>
  chSysUnlock();
 8003cfe:	f7ff fe77 	bl	80039f0 <chSysUnlock.lto_priv.7>

  return tp;
 8003d02:	9b05      	ldr	r3, [sp, #20]
}
 8003d04:	4618      	mov	r0, r3
 8003d06:	b007      	add	sp, #28
 8003d08:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d0c:	08004ca4 	.word	0x08004ca4
 8003d10:	08000251 	.word	0x08000251
 8003d14:	08004c34 	.word	0x08004c34
 8003d18:	200008e8 	.word	0x200008e8
 8003d1c:	00000000 	.word	0x00000000

08003d20 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8003d20:	b500      	push	{lr}
 8003d22:	b083      	sub	sp, #12
 8003d24:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003d26:	f7ff fe53 	bl	80039d0 <chSysLock.lto_priv.7>
  chThdExitS(msg);
 8003d2a:	9801      	ldr	r0, [sp, #4]
 8003d2c:	f000 f808 	bl	8003d40 <chThdExitS>
  /* The thread never returns here.*/
}
 8003d30:	bf00      	nop
 8003d32:	b003      	add	sp, #12
 8003d34:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003d40 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8003d40:	b500      	push	{lr}
 8003d42:	b085      	sub	sp, #20
 8003d44:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8003d46:	f7ff fe63 	bl	8003a10 <chThdGetSelfX.lto_priv.0>
 8003d4a:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 8003d4c:	9b03      	ldr	r3, [sp, #12]
 8003d4e:	9a01      	ldr	r2, [sp, #4]
 8003d50:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003d52:	e008      	b.n	8003d66 <chThdExitS+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8003d54:	9b03      	ldr	r3, [sp, #12]
 8003d56:	332c      	adds	r3, #44	@ 0x2c
 8003d58:	4618      	mov	r0, r3
 8003d5a:	f7ff fdf1 	bl	8003940 <ch_list_unlink>
 8003d5e:	4603      	mov	r3, r0
 8003d60:	4618      	mov	r0, r3
 8003d62:	f7ff fbcd 	bl	8003500 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003d66:	9b03      	ldr	r3, [sp, #12]
 8003d68:	332c      	adds	r3, #44	@ 0x2c
 8003d6a:	4618      	mov	r0, r3
 8003d6c:	f7ff fdd8 	bl	8003920 <ch_list_notempty>
 8003d70:	4603      	mov	r3, r0
 8003d72:	2b00      	cmp	r3, #0
 8003d74:	d1ee      	bne.n	8003d54 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8003d76:	9b03      	ldr	r3, [sp, #12]
 8003d78:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8003d7c:	2b00      	cmp	r3, #0
 8003d7e:	bf0c      	ite	eq
 8003d80:	2301      	moveq	r3, #1
 8003d82:	2300      	movne	r3, #0
 8003d84:	b2db      	uxtb	r3, r3
 8003d86:	2b00      	cmp	r3, #0
 8003d88:	d010      	beq.n	8003dac <chThdExitS+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8003d8a:	9b03      	ldr	r3, [sp, #12]
 8003d8c:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8003d90:	f003 0303 	and.w	r3, r3, #3
 8003d94:	2b00      	cmp	r3, #0
 8003d96:	bf0c      	ite	eq
 8003d98:	2301      	moveq	r3, #1
 8003d9a:	2300      	movne	r3, #0
 8003d9c:	b2db      	uxtb	r3, r3
 8003d9e:	2b00      	cmp	r3, #0
 8003da0:	d004      	beq.n	8003dac <chThdExitS+0x6c>
      REG_REMOVE(currtp);
 8003da2:	9b03      	ldr	r3, [sp, #12]
 8003da4:	3310      	adds	r3, #16
 8003da6:	4618      	mov	r0, r3
 8003da8:	f7ff fe02 	bl	80039b0 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003dac:	200f      	movs	r0, #15
 8003dae:	f7ff fbc7 	bl	8003540 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8003db2:	bf00      	nop
 8003db4:	b005      	add	sp, #20
 8003db6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dba:	bf00      	nop
 8003dbc:	0000      	movs	r0, r0
	...

08003dc0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8003dc0:	b500      	push	{lr}
 8003dc2:	b083      	sub	sp, #12
 8003dc4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003dc6:	f7ff fe03 	bl	80039d0 <chSysLock.lto_priv.7>
  chThdSleepS(time);
 8003dca:	9801      	ldr	r0, [sp, #4]
 8003dcc:	f7ff fe28 	bl	8003a20 <chThdSleepS>
  chSysUnlock();
 8003dd0:	f7ff fe0e 	bl	80039f0 <chSysUnlock.lto_priv.7>
}
 8003dd4:	bf00      	nop
 8003dd6:	b003      	add	sp, #12
 8003dd8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ddc:	0000      	movs	r0, r0
	...

08003de0 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8003de0:	b500      	push	{lr}
 8003de2:	b085      	sub	sp, #20
 8003de4:	9001      	str	r0, [sp, #4]
 8003de6:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8003de8:	f7ff fe12 	bl	8003a10 <chThdGetSelfX.lto_priv.0>
 8003dec:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8003dee:	9b00      	ldr	r3, [sp, #0]
 8003df0:	2b00      	cmp	r3, #0
 8003df2:	bf0c      	ite	eq
 8003df4:	2301      	moveq	r3, #1
 8003df6:	2300      	movne	r3, #0
 8003df8:	b2db      	uxtb	r3, r3
 8003dfa:	2b00      	cmp	r3, #0
 8003dfc:	d002      	beq.n	8003e04 <chThdSuspendTimeoutS+0x24>
    return MSG_TIMEOUT;
 8003dfe:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8003e02:	e00a      	b.n	8003e1a <chThdSuspendTimeoutS+0x3a>
  }

  *trp = tp;
 8003e04:	9b01      	ldr	r3, [sp, #4]
 8003e06:	9a03      	ldr	r2, [sp, #12]
 8003e08:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8003e0a:	9b03      	ldr	r3, [sp, #12]
 8003e0c:	9a01      	ldr	r2, [sp, #4]
 8003e0e:	629a      	str	r2, [r3, #40]	@ 0x28

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003e10:	9900      	ldr	r1, [sp, #0]
 8003e12:	2003      	movs	r0, #3
 8003e14:	f7ff fbbc 	bl	8003590 <chSchGoSleepTimeoutS>
 8003e18:	4603      	mov	r3, r0
}
 8003e1a:	4618      	mov	r0, r3
 8003e1c:	b005      	add	sp, #20
 8003e1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e22:	bf00      	nop
	...

08003e30 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8003e30:	b500      	push	{lr}
 8003e32:	b085      	sub	sp, #20
 8003e34:	9001      	str	r0, [sp, #4]
 8003e36:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8003e38:	9b01      	ldr	r3, [sp, #4]
 8003e3a:	681b      	ldr	r3, [r3, #0]
 8003e3c:	2b00      	cmp	r3, #0
 8003e3e:	d00b      	beq.n	8003e58 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 8003e40:	9b01      	ldr	r3, [sp, #4]
 8003e42:	681b      	ldr	r3, [r3, #0]
 8003e44:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8003e46:	9b01      	ldr	r3, [sp, #4]
 8003e48:	2200      	movs	r2, #0
 8003e4a:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8003e4c:	9b03      	ldr	r3, [sp, #12]
 8003e4e:	9a00      	ldr	r2, [sp, #0]
 8003e50:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 8003e52:	9803      	ldr	r0, [sp, #12]
 8003e54:	f7ff fb54 	bl	8003500 <chSchReadyI>
  }
}
 8003e58:	bf00      	nop
 8003e5a:	b005      	add	sp, #20
 8003e5c:	f85d fb04 	ldr.w	pc, [sp], #4

08003e60 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8003e60:	b500      	push	{lr}
 8003e62:	b085      	sub	sp, #20
 8003e64:	9001      	str	r0, [sp, #4]
 8003e66:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8003e68:	9b01      	ldr	r3, [sp, #4]
 8003e6a:	681b      	ldr	r3, [r3, #0]
 8003e6c:	2b00      	cmp	r3, #0
 8003e6e:	d009      	beq.n	8003e84 <chThdResumeS+0x24>
    thread_t *tp = *trp;
 8003e70:	9b01      	ldr	r3, [sp, #4]
 8003e72:	681b      	ldr	r3, [r3, #0]
 8003e74:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8003e76:	9b01      	ldr	r3, [sp, #4]
 8003e78:	2200      	movs	r2, #0
 8003e7a:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 8003e7c:	9900      	ldr	r1, [sp, #0]
 8003e7e:	9803      	ldr	r0, [sp, #12]
 8003e80:	f7ff fbbe 	bl	8003600 <chSchWakeupS>
  }
}
 8003e84:	bf00      	nop
 8003e86:	b005      	add	sp, #20
 8003e88:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e8c:	0000      	movs	r0, r0
	...

08003e90 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8003e90:	b4f0      	push	{r4, r5, r6, r7}
 8003e92:	b084      	sub	sp, #16
 8003e94:	9003      	str	r0, [sp, #12]
 8003e96:	9102      	str	r1, [sp, #8]
 8003e98:	9201      	str	r2, [sp, #4]

  tmp->n++;
 8003e9a:	9b03      	ldr	r3, [sp, #12]
 8003e9c:	68db      	ldr	r3, [r3, #12]
 8003e9e:	1c5a      	adds	r2, r3, #1
 8003ea0:	9b03      	ldr	r3, [sp, #12]
 8003ea2:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8003ea4:	9b03      	ldr	r3, [sp, #12]
 8003ea6:	689b      	ldr	r3, [r3, #8]
 8003ea8:	9a02      	ldr	r2, [sp, #8]
 8003eaa:	1ad2      	subs	r2, r2, r3
 8003eac:	9b01      	ldr	r3, [sp, #4]
 8003eae:	1ad2      	subs	r2, r2, r3
 8003eb0:	9b03      	ldr	r3, [sp, #12]
 8003eb2:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8003eb4:	9b03      	ldr	r3, [sp, #12]
 8003eb6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003eba:	9903      	ldr	r1, [sp, #12]
 8003ebc:	6889      	ldr	r1, [r1, #8]
 8003ebe:	2000      	movs	r0, #0
 8003ec0:	460c      	mov	r4, r1
 8003ec2:	4605      	mov	r5, r0
 8003ec4:	1916      	adds	r6, r2, r4
 8003ec6:	eb43 0705 	adc.w	r7, r3, r5
 8003eca:	9b03      	ldr	r3, [sp, #12]
 8003ecc:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
 8003ed0:	9b03      	ldr	r3, [sp, #12]
 8003ed2:	689a      	ldr	r2, [r3, #8]
 8003ed4:	9b03      	ldr	r3, [sp, #12]
 8003ed6:	685b      	ldr	r3, [r3, #4]
 8003ed8:	429a      	cmp	r2, r3
 8003eda:	d903      	bls.n	8003ee4 <tm_stop+0x54>
    tmp->worst = tmp->last;
 8003edc:	9b03      	ldr	r3, [sp, #12]
 8003ede:	689a      	ldr	r2, [r3, #8]
 8003ee0:	9b03      	ldr	r3, [sp, #12]
 8003ee2:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8003ee4:	9b03      	ldr	r3, [sp, #12]
 8003ee6:	689a      	ldr	r2, [r3, #8]
 8003ee8:	9b03      	ldr	r3, [sp, #12]
 8003eea:	681b      	ldr	r3, [r3, #0]
 8003eec:	429a      	cmp	r2, r3
 8003eee:	d203      	bcs.n	8003ef8 <tm_stop+0x68>
    tmp->best = tmp->last;
 8003ef0:	9b03      	ldr	r3, [sp, #12]
 8003ef2:	689a      	ldr	r2, [r3, #8]
 8003ef4:	9b03      	ldr	r3, [sp, #12]
 8003ef6:	601a      	str	r2, [r3, #0]
  }
}
 8003ef8:	bf00      	nop
 8003efa:	b004      	add	sp, #16
 8003efc:	bcf0      	pop	{r4, r5, r6, r7}
 8003efe:	4770      	bx	lr

08003f00 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8003f00:	b082      	sub	sp, #8
 8003f02:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8003f04:	9b01      	ldr	r3, [sp, #4]
 8003f06:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003f0a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 8003f0c:	9b01      	ldr	r3, [sp, #4]
 8003f0e:	2200      	movs	r2, #0
 8003f10:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8003f12:	9b01      	ldr	r3, [sp, #4]
 8003f14:	2200      	movs	r2, #0
 8003f16:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8003f18:	9b01      	ldr	r3, [sp, #4]
 8003f1a:	2200      	movs	r2, #0
 8003f1c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 8003f1e:	9901      	ldr	r1, [sp, #4]
 8003f20:	f04f 0200 	mov.w	r2, #0
 8003f24:	f04f 0300 	mov.w	r3, #0
 8003f28:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 8003f2c:	bf00      	nop
 8003f2e:	b002      	add	sp, #8
 8003f30:	4770      	bx	lr
 8003f32:	bf00      	nop
	...

08003f40 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8003f40:	b082      	sub	sp, #8
 8003f42:	9001      	str	r0, [sp, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8003f44:	4b03      	ldr	r3, [pc, #12]	@ (8003f54 <chTMStartMeasurementX+0x14>)
 8003f46:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8003f48:	9b01      	ldr	r3, [sp, #4]
 8003f4a:	609a      	str	r2, [r3, #8]
}
 8003f4c:	bf00      	nop
 8003f4e:	b002      	add	sp, #8
 8003f50:	4770      	bx	lr
 8003f52:	bf00      	nop
 8003f54:	e0001000 	.word	0xe0001000
	...

08003f60 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8003f60:	b500      	push	{lr}
 8003f62:	b083      	sub	sp, #12
 8003f64:	9001      	str	r0, [sp, #4]
 8003f66:	4b06      	ldr	r3, [pc, #24]	@ (8003f80 <chTMStopMeasurementX+0x20>)
 8003f68:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8003f6a:	4a06      	ldr	r2, [pc, #24]	@ (8003f84 <chTMStopMeasurementX+0x24>)
 8003f6c:	6892      	ldr	r2, [r2, #8]
 8003f6e:	4619      	mov	r1, r3
 8003f70:	9801      	ldr	r0, [sp, #4]
 8003f72:	f7ff ff8d 	bl	8003e90 <tm_stop>
}
 8003f76:	bf00      	nop
 8003f78:	b003      	add	sp, #12
 8003f7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f7e:	bf00      	nop
 8003f80:	e0001000 	.word	0xe0001000
 8003f84:	200008dc 	.word	0x200008dc
	...

08003f90 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003f90:	b082      	sub	sp, #8
 8003f92:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8003f94:	9b01      	ldr	r3, [sp, #4]
 8003f96:	9a01      	ldr	r2, [sp, #4]
 8003f98:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8003f9a:	9b01      	ldr	r3, [sp, #4]
 8003f9c:	9a01      	ldr	r2, [sp, #4]
 8003f9e:	605a      	str	r2, [r3, #4]
}
 8003fa0:	bf00      	nop
 8003fa2:	b002      	add	sp, #8
 8003fa4:	4770      	bx	lr
 8003fa6:	bf00      	nop
	...

08003fb0 <ch_queue_notempty.lto_priv.2>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 8003fb0:	b082      	sub	sp, #8
 8003fb2:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 8003fb4:	9b01      	ldr	r3, [sp, #4]
 8003fb6:	681b      	ldr	r3, [r3, #0]
 8003fb8:	9a01      	ldr	r2, [sp, #4]
 8003fba:	429a      	cmp	r2, r3
 8003fbc:	bf14      	ite	ne
 8003fbe:	2301      	movne	r3, #1
 8003fc0:	2300      	moveq	r3, #0
 8003fc2:	b2db      	uxtb	r3, r3
}
 8003fc4:	4618      	mov	r0, r3
 8003fc6:	b002      	add	sp, #8
 8003fc8:	4770      	bx	lr
 8003fca:	bf00      	nop
 8003fcc:	0000      	movs	r0, r0
	...

08003fd0 <ch_queue_fifo_remove.lto_priv.2>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 8003fd0:	b084      	sub	sp, #16
 8003fd2:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 8003fd4:	9b01      	ldr	r3, [sp, #4]
 8003fd6:	681b      	ldr	r3, [r3, #0]
 8003fd8:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 8003fda:	9b03      	ldr	r3, [sp, #12]
 8003fdc:	681a      	ldr	r2, [r3, #0]
 8003fde:	9b01      	ldr	r3, [sp, #4]
 8003fe0:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 8003fe2:	9b01      	ldr	r3, [sp, #4]
 8003fe4:	681b      	ldr	r3, [r3, #0]
 8003fe6:	9a01      	ldr	r2, [sp, #4]
 8003fe8:	605a      	str	r2, [r3, #4]
  return p;
 8003fea:	9b03      	ldr	r3, [sp, #12]
}
 8003fec:	4618      	mov	r0, r3
 8003fee:	b004      	add	sp, #16
 8003ff0:	4770      	bx	lr
 8003ff2:	bf00      	nop
	...

08004000 <ch_queue_dequeue.lto_priv.2>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8004000:	b082      	sub	sp, #8
 8004002:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8004004:	9b01      	ldr	r3, [sp, #4]
 8004006:	685b      	ldr	r3, [r3, #4]
 8004008:	9a01      	ldr	r2, [sp, #4]
 800400a:	6812      	ldr	r2, [r2, #0]
 800400c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800400e:	9b01      	ldr	r3, [sp, #4]
 8004010:	681b      	ldr	r3, [r3, #0]
 8004012:	9a01      	ldr	r2, [sp, #4]
 8004014:	6852      	ldr	r2, [r2, #4]
 8004016:	605a      	str	r2, [r3, #4]
  return p;
 8004018:	9b01      	ldr	r3, [sp, #4]
}
 800401a:	4618      	mov	r0, r3
 800401c:	b002      	add	sp, #8
 800401e:	4770      	bx	lr

08004020 <chSysLock.lto_priv.10>:
static inline void chSysLock(void) {
 8004020:	b500      	push	{lr}
 8004022:	b083      	sub	sp, #12
 8004024:	2330      	movs	r3, #48	@ 0x30
 8004026:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004028:	9b01      	ldr	r3, [sp, #4]
 800402a:	f383 8811 	msr	BASEPRI, r3
}
 800402e:	bf00      	nop
}
 8004030:	bf00      	nop
  __dbg_check_lock();
 8004032:	f7fe fc35 	bl	80028a0 <__dbg_check_lock>
}
 8004036:	bf00      	nop
 8004038:	b003      	add	sp, #12
 800403a:	f85d fb04 	ldr.w	pc, [sp], #4
 800403e:	bf00      	nop

08004040 <chSysUnlock.lto_priv.10>:
static inline void chSysUnlock(void) {
 8004040:	b500      	push	{lr}
 8004042:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004044:	f7fe fc54 	bl	80028f0 <__dbg_check_unlock>
 8004048:	2300      	movs	r3, #0
 800404a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800404c:	9b01      	ldr	r3, [sp, #4]
 800404e:	f383 8811 	msr	BASEPRI, r3
}
 8004052:	bf00      	nop
}
 8004054:	bf00      	nop
}
 8004056:	bf00      	nop
 8004058:	b003      	add	sp, #12
 800405a:	f85d fb04 	ldr.w	pc, [sp], #4
 800405e:	bf00      	nop

08004060 <chThdGetSelfX.lto_priv.2>:
  return __sch_get_currthread();
 8004060:	4b01      	ldr	r3, [pc, #4]	@ (8004068 <chThdGetSelfX.lto_priv.2+0x8>)
 8004062:	68db      	ldr	r3, [r3, #12]
}
 8004064:	4618      	mov	r0, r3
 8004066:	4770      	bx	lr
 8004068:	200008e8 	.word	0x200008e8
 800406c:	00000000 	.word	0x00000000

08004070 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8004070:	b500      	push	{lr}
 8004072:	b083      	sub	sp, #12
 8004074:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8004076:	f7fe fd4b 	bl	8002b10 <chDbgCheckClassS>

  return ch_queue_notempty(&mp->queue);
 800407a:	9b01      	ldr	r3, [sp, #4]
 800407c:	4618      	mov	r0, r3
 800407e:	f7ff ff97 	bl	8003fb0 <ch_queue_notempty.lto_priv.2>
 8004082:	4603      	mov	r3, r0
}
 8004084:	4618      	mov	r0, r3
 8004086:	b003      	add	sp, #12
 8004088:	f85d fb04 	ldr.w	pc, [sp], #4
 800408c:	0000      	movs	r0, r0
	...

08004090 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8004090:	b500      	push	{lr}
 8004092:	b083      	sub	sp, #12
 8004094:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8004096:	9b01      	ldr	r3, [sp, #4]
 8004098:	2b00      	cmp	r3, #0
 800409a:	bf0c      	ite	eq
 800409c:	2301      	moveq	r3, #1
 800409e:	2300      	movne	r3, #0
 80040a0:	b2db      	uxtb	r3, r3
 80040a2:	2b00      	cmp	r3, #0
 80040a4:	d002      	beq.n	80040ac <chMtxObjectInit+0x1c>
 80040a6:	4807      	ldr	r0, [pc, #28]	@ (80040c4 <chMtxObjectInit+0x34>)
 80040a8:	f7fe fbca 	bl	8002840 <chSysHalt>

  ch_queue_init(&mp->queue);
 80040ac:	9b01      	ldr	r3, [sp, #4]
 80040ae:	4618      	mov	r0, r3
 80040b0:	f7ff ff6e 	bl	8003f90 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 80040b4:	9b01      	ldr	r3, [sp, #4]
 80040b6:	2200      	movs	r2, #0
 80040b8:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 80040ba:	bf00      	nop
 80040bc:	b003      	add	sp, #12
 80040be:	f85d fb04 	ldr.w	pc, [sp], #4
 80040c2:	bf00      	nop
 80040c4:	08004cf0 	.word	0x08004cf0
	...

080040d0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80040d0:	b500      	push	{lr}
 80040d2:	b083      	sub	sp, #12
 80040d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80040d6:	f7ff ffa3 	bl	8004020 <chSysLock.lto_priv.10>
  chMtxLockS(mp);
 80040da:	9801      	ldr	r0, [sp, #4]
 80040dc:	f000 f808 	bl	80040f0 <chMtxLockS>
  chSysUnlock();
 80040e0:	f7ff ffae 	bl	8004040 <chSysUnlock.lto_priv.10>
}
 80040e4:	bf00      	nop
 80040e6:	b003      	add	sp, #12
 80040e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80040ec:	0000      	movs	r0, r0
	...

080040f0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80040f0:	b510      	push	{r4, lr}
 80040f2:	b084      	sub	sp, #16
 80040f4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 80040f6:	f7ff ffb3 	bl	8004060 <chThdGetSelfX.lto_priv.2>
 80040fa:	9002      	str	r0, [sp, #8]

  chDbgCheckClassS();
 80040fc:	f7fe fd08 	bl	8002b10 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8004100:	9b01      	ldr	r3, [sp, #4]
 8004102:	2b00      	cmp	r3, #0
 8004104:	bf0c      	ite	eq
 8004106:	2301      	moveq	r3, #1
 8004108:	2300      	movne	r3, #0
 800410a:	b2db      	uxtb	r3, r3
 800410c:	2b00      	cmp	r3, #0
 800410e:	d002      	beq.n	8004116 <chMtxLockS+0x26>
 8004110:	4831      	ldr	r0, [pc, #196]	@ (80041d8 <chMtxLockS+0xe8>)
 8004112:	f7fe fb95 	bl	8002840 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8004116:	9b01      	ldr	r3, [sp, #4]
 8004118:	689b      	ldr	r3, [r3, #8]
 800411a:	2b00      	cmp	r3, #0
 800411c:	d04e      	beq.n	80041bc <chMtxLockS+0xcc>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 800411e:	9b01      	ldr	r3, [sp, #4]
 8004120:	689b      	ldr	r3, [r3, #8]
 8004122:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8004124:	e037      	b.n	8004196 <chMtxLockS+0xa6>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8004126:	9b02      	ldr	r3, [sp, #8]
 8004128:	689a      	ldr	r2, [r3, #8]
 800412a:	9b03      	ldr	r3, [sp, #12]
 800412c:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800412e:	9b03      	ldr	r3, [sp, #12]
 8004130:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004134:	2b07      	cmp	r3, #7
 8004136:	d016      	beq.n	8004166 <chMtxLockS+0x76>
 8004138:	2b07      	cmp	r3, #7
 800413a:	dc2a      	bgt.n	8004192 <chMtxLockS+0xa2>
 800413c:	2b00      	cmp	r3, #0
 800413e:	d01f      	beq.n	8004180 <chMtxLockS+0x90>
 8004140:	2b06      	cmp	r3, #6
 8004142:	d126      	bne.n	8004192 <chMtxLockS+0xa2>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004144:	9b03      	ldr	r3, [sp, #12]
 8004146:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004148:	461c      	mov	r4, r3
 800414a:	9b03      	ldr	r3, [sp, #12]
 800414c:	4618      	mov	r0, r3
 800414e:	f7ff ff57 	bl	8004000 <ch_queue_dequeue.lto_priv.2>
 8004152:	4603      	mov	r3, r0
 8004154:	4619      	mov	r1, r3
 8004156:	4620      	mov	r0, r4
 8004158:	f7ff f9aa 	bl	80034b0 <ch_sch_prio_insert>
                             ch_queue_dequeue(&tp->hdr.queue));
          tp = tp->u.wtmtxp->owner;
 800415c:	9b03      	ldr	r3, [sp, #12]
 800415e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004160:	689b      	ldr	r3, [r3, #8]
 8004162:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8004164:	e017      	b.n	8004196 <chMtxLockS+0xa6>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8004166:	9b03      	ldr	r3, [sp, #12]
 8004168:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800416a:	461c      	mov	r4, r3
 800416c:	9b03      	ldr	r3, [sp, #12]
 800416e:	4618      	mov	r0, r3
 8004170:	f7ff ff46 	bl	8004000 <ch_queue_dequeue.lto_priv.2>
 8004174:	4603      	mov	r3, r0
 8004176:	4619      	mov	r1, r3
 8004178:	4620      	mov	r0, r4
 800417a:	f7ff f999 	bl	80034b0 <ch_sch_prio_insert>
                             ch_queue_dequeue(&tp->hdr.queue));
          break;
 800417e:	e009      	b.n	8004194 <chMtxLockS+0xa4>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 8004180:	9b03      	ldr	r3, [sp, #12]
 8004182:	4618      	mov	r0, r3
 8004184:	f7ff ff3c 	bl	8004000 <ch_queue_dequeue.lto_priv.2>
 8004188:	4603      	mov	r3, r0
 800418a:	4618      	mov	r0, r3
 800418c:	f7ff f9b8 	bl	8003500 <chSchReadyI>
          break;
 8004190:	e000      	b.n	8004194 <chMtxLockS+0xa4>
        default:
          /* Nothing to do for other states.*/
          break;
 8004192:	bf00      	nop
        }
        break;
 8004194:	e005      	b.n	80041a2 <chMtxLockS+0xb2>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8004196:	9b03      	ldr	r3, [sp, #12]
 8004198:	689a      	ldr	r2, [r3, #8]
 800419a:	9b02      	ldr	r3, [sp, #8]
 800419c:	689b      	ldr	r3, [r3, #8]
 800419e:	429a      	cmp	r2, r3
 80041a0:	d3c1      	bcc.n	8004126 <chMtxLockS+0x36>
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
 80041a2:	9b01      	ldr	r3, [sp, #4]
 80041a4:	9a02      	ldr	r2, [sp, #8]
 80041a6:	4611      	mov	r1, r2
 80041a8:	4618      	mov	r0, r3
 80041aa:	f7ff f981 	bl	80034b0 <ch_sch_prio_insert>
      currtp->u.wtmtxp = mp;
 80041ae:	9b02      	ldr	r3, [sp, #8]
 80041b0:	9a01      	ldr	r2, [sp, #4]
 80041b2:	629a      	str	r2, [r3, #40]	@ 0x28
      chSchGoSleepS(CH_STATE_WTMTX);
 80041b4:	2006      	movs	r0, #6
 80041b6:	f7ff f9c3 	bl	8003540 <chSchGoSleepS>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 80041ba:	e009      	b.n	80041d0 <chMtxLockS+0xe0>
    mp->owner = currtp;
 80041bc:	9b01      	ldr	r3, [sp, #4]
 80041be:	9a02      	ldr	r2, [sp, #8]
 80041c0:	609a      	str	r2, [r3, #8]
    mp->next = currtp->mtxlist;
 80041c2:	9b02      	ldr	r3, [sp, #8]
 80041c4:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80041c6:	9b01      	ldr	r3, [sp, #4]
 80041c8:	60da      	str	r2, [r3, #12]
    currtp->mtxlist = mp;
 80041ca:	9b02      	ldr	r3, [sp, #8]
 80041cc:	9a01      	ldr	r2, [sp, #4]
 80041ce:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 80041d0:	bf00      	nop
 80041d2:	b004      	add	sp, #16
 80041d4:	bd10      	pop	{r4, pc}
 80041d6:	bf00      	nop
 80041d8:	08004d00 	.word	0x08004d00
 80041dc:	00000000 	.word	0x00000000

080041e0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80041e0:	b500      	push	{lr}
 80041e2:	b087      	sub	sp, #28
 80041e4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 80041e6:	f7ff ff3b 	bl	8004060 <chThdGetSelfX.lto_priv.2>
 80041ea:	9005      	str	r0, [sp, #20]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 80041ec:	9b01      	ldr	r3, [sp, #4]
 80041ee:	2b00      	cmp	r3, #0
 80041f0:	bf0c      	ite	eq
 80041f2:	2301      	moveq	r3, #1
 80041f4:	2300      	movne	r3, #0
 80041f6:	b2db      	uxtb	r3, r3
 80041f8:	2b00      	cmp	r3, #0
 80041fa:	d002      	beq.n	8004202 <chMtxUnlock+0x22>
 80041fc:	4826      	ldr	r0, [pc, #152]	@ (8004298 <chMtxUnlock+0xb8>)
 80041fe:	f7fe fb1f 	bl	8002840 <chSysHalt>

  chSysLock();
 8004202:	f7ff ff0d 	bl	8004020 <chSysLock.lto_priv.10>
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 8004206:	9b01      	ldr	r3, [sp, #4]
 8004208:	68da      	ldr	r2, [r3, #12]
 800420a:	9b05      	ldr	r3, [sp, #20]
 800420c:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800420e:	9801      	ldr	r0, [sp, #4]
 8004210:	f7ff ff2e 	bl	8004070 <chMtxQueueNotEmptyS>
 8004214:	4603      	mov	r3, r0
 8004216:	2b00      	cmp	r3, #0
 8004218:	d034      	beq.n	8004284 <chMtxUnlock+0xa4>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 800421a:	9b05      	ldr	r3, [sp, #20]
 800421c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800421e:	9303      	str	r3, [sp, #12]
      lmp = currtp->mtxlist;
 8004220:	9b05      	ldr	r3, [sp, #20]
 8004222:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8004224:	9304      	str	r3, [sp, #16]
      while (lmp != NULL) {
 8004226:	e012      	b.n	800424e <chMtxUnlock+0x6e>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8004228:	9804      	ldr	r0, [sp, #16]
 800422a:	f7ff ff21 	bl	8004070 <chMtxQueueNotEmptyS>
 800422e:	4603      	mov	r3, r0
 8004230:	2b00      	cmp	r3, #0
 8004232:	d009      	beq.n	8004248 <chMtxUnlock+0x68>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 8004234:	9b04      	ldr	r3, [sp, #16]
 8004236:	681b      	ldr	r3, [r3, #0]
 8004238:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 800423a:	9a03      	ldr	r2, [sp, #12]
 800423c:	429a      	cmp	r2, r3
 800423e:	d203      	bcs.n	8004248 <chMtxUnlock+0x68>
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
 8004240:	9b04      	ldr	r3, [sp, #16]
 8004242:	681b      	ldr	r3, [r3, #0]
 8004244:	689b      	ldr	r3, [r3, #8]
 8004246:	9303      	str	r3, [sp, #12]
        }
        lmp = lmp->next;
 8004248:	9b04      	ldr	r3, [sp, #16]
 800424a:	68db      	ldr	r3, [r3, #12]
 800424c:	9304      	str	r3, [sp, #16]
      while (lmp != NULL) {
 800424e:	9b04      	ldr	r3, [sp, #16]
 8004250:	2b00      	cmp	r3, #0
 8004252:	d1e9      	bne.n	8004228 <chMtxUnlock+0x48>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 8004254:	9b05      	ldr	r3, [sp, #20]
 8004256:	9a03      	ldr	r2, [sp, #12]
 8004258:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
 800425a:	9b01      	ldr	r3, [sp, #4]
 800425c:	4618      	mov	r0, r3
 800425e:	f7ff feb7 	bl	8003fd0 <ch_queue_fifo_remove.lto_priv.2>
 8004262:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 8004264:	9b01      	ldr	r3, [sp, #4]
 8004266:	9a02      	ldr	r2, [sp, #8]
 8004268:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800426a:	9b02      	ldr	r3, [sp, #8]
 800426c:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800426e:	9b01      	ldr	r3, [sp, #4]
 8004270:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8004272:	9b02      	ldr	r3, [sp, #8]
 8004274:	9a01      	ldr	r2, [sp, #4]
 8004276:	63da      	str	r2, [r3, #60]	@ 0x3c

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8004278:	9802      	ldr	r0, [sp, #8]
 800427a:	f7ff f941 	bl	8003500 <chSchReadyI>
      chSchRescheduleS();
 800427e:	f7ff f9f7 	bl	8003670 <chSchRescheduleS>
 8004282:	e002      	b.n	800428a <chMtxUnlock+0xaa>
    }
    else {
      mp->owner = NULL;
 8004284:	9b01      	ldr	r3, [sp, #4]
 8004286:	2200      	movs	r2, #0
 8004288:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 800428a:	f7ff fed9 	bl	8004040 <chSysUnlock.lto_priv.10>
}
 800428e:	bf00      	nop
 8004290:	b007      	add	sp, #28
 8004292:	f85d fb04 	ldr.w	pc, [sp], #4
 8004296:	bf00      	nop
 8004298:	08004d0c 	.word	0x08004d0c
 800429c:	00000000 	.word	0x00000000

080042a0 <chSysLock.lto_priv.16>:
static inline void chSysLock(void) {
 80042a0:	b500      	push	{lr}
 80042a2:	b083      	sub	sp, #12
 80042a4:	2330      	movs	r3, #48	@ 0x30
 80042a6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80042a8:	9b01      	ldr	r3, [sp, #4]
 80042aa:	f383 8811 	msr	BASEPRI, r3
}
 80042ae:	bf00      	nop
}
 80042b0:	bf00      	nop
  __dbg_check_lock();
 80042b2:	f7fe faf5 	bl	80028a0 <__dbg_check_lock>
}
 80042b6:	bf00      	nop
 80042b8:	b003      	add	sp, #12
 80042ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80042be:	bf00      	nop

080042c0 <chSysUnlock.lto_priv.16>:
static inline void chSysUnlock(void) {
 80042c0:	b500      	push	{lr}
 80042c2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80042c4:	f7fe fb14 	bl	80028f0 <__dbg_check_unlock>
 80042c8:	2300      	movs	r3, #0
 80042ca:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80042cc:	9b01      	ldr	r3, [sp, #4]
 80042ce:	f383 8811 	msr	BASEPRI, r3
}
 80042d2:	bf00      	nop
}
 80042d4:	bf00      	nop
}
 80042d6:	bf00      	nop
 80042d8:	b003      	add	sp, #12
 80042da:	f85d fb04 	ldr.w	pc, [sp], #4
 80042de:	bf00      	nop

080042e0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 80042e0:	4b03      	ldr	r3, [pc, #12]	@ (80042f0 <__core_init+0x10>)
 80042e2:	4a04      	ldr	r2, [pc, #16]	@ (80042f4 <__core_init+0x14>)
 80042e4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 80042e6:	4b02      	ldr	r3, [pc, #8]	@ (80042f0 <__core_init+0x10>)
 80042e8:	4a03      	ldr	r2, [pc, #12]	@ (80042f8 <__core_init+0x18>)
 80042ea:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 80042ec:	bf00      	nop
 80042ee:	4770      	bx	lr
 80042f0:	20000aa8 	.word	0x20000aa8
 80042f4:	20000e98 	.word	0x20000e98
 80042f8:	20008000 	.word	0x20008000
 80042fc:	00000000 	.word	0x00000000

08004300 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8004300:	b500      	push	{lr}
 8004302:	b087      	sub	sp, #28
 8004304:	9003      	str	r0, [sp, #12]
 8004306:	9102      	str	r1, [sp, #8]
 8004308:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 800430a:	f7fe fbe1 	bl	8002ad0 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800430e:	9b02      	ldr	r3, [sp, #8]
 8004310:	2b00      	cmp	r3, #0
 8004312:	bf0c      	ite	eq
 8004314:	2301      	moveq	r3, #1
 8004316:	2300      	movne	r3, #0
 8004318:	b2db      	uxtb	r3, r3
 800431a:	2b00      	cmp	r3, #0
 800431c:	d10a      	bne.n	8004334 <chCoreAllocFromTopI+0x34>
 800431e:	9b02      	ldr	r3, [sp, #8]
 8004320:	1e5a      	subs	r2, r3, #1
 8004322:	9b02      	ldr	r3, [sp, #8]
 8004324:	4013      	ands	r3, r2
 8004326:	2b00      	cmp	r3, #0
 8004328:	bf14      	ite	ne
 800432a:	2301      	movne	r3, #1
 800432c:	2300      	moveq	r3, #0
 800432e:	b2db      	uxtb	r3, r3
 8004330:	2b00      	cmp	r3, #0
 8004332:	d002      	beq.n	800433a <chCoreAllocFromTopI+0x3a>
 8004334:	4812      	ldr	r0, [pc, #72]	@ (8004380 <chCoreAllocFromTopI+0x80>)
 8004336:	f7fe fa83 	bl	8002840 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 800433a:	4b12      	ldr	r3, [pc, #72]	@ (8004384 <chCoreAllocFromTopI+0x84>)
 800433c:	685a      	ldr	r2, [r3, #4]
 800433e:	9b03      	ldr	r3, [sp, #12]
 8004340:	425b      	negs	r3, r3
 8004342:	4413      	add	r3, r2
 8004344:	461a      	mov	r2, r3
 8004346:	9b02      	ldr	r3, [sp, #8]
 8004348:	425b      	negs	r3, r3
 800434a:	4013      	ands	r3, r2
 800434c:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 800434e:	9b01      	ldr	r3, [sp, #4]
 8004350:	425b      	negs	r3, r3
 8004352:	9a05      	ldr	r2, [sp, #20]
 8004354:	4413      	add	r3, r2
 8004356:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8004358:	4b0a      	ldr	r3, [pc, #40]	@ (8004384 <chCoreAllocFromTopI+0x84>)
 800435a:	681b      	ldr	r3, [r3, #0]
 800435c:	9a04      	ldr	r2, [sp, #16]
 800435e:	429a      	cmp	r2, r3
 8004360:	d304      	bcc.n	800436c <chCoreAllocFromTopI+0x6c>
 8004362:	4b08      	ldr	r3, [pc, #32]	@ (8004384 <chCoreAllocFromTopI+0x84>)
 8004364:	685b      	ldr	r3, [r3, #4]
 8004366:	9a04      	ldr	r2, [sp, #16]
 8004368:	429a      	cmp	r2, r3
 800436a:	d901      	bls.n	8004370 <chCoreAllocFromTopI+0x70>
    return NULL;
 800436c:	2300      	movs	r3, #0
 800436e:	e003      	b.n	8004378 <chCoreAllocFromTopI+0x78>
  }

  ch_memcore.topmem = prev;
 8004370:	4a04      	ldr	r2, [pc, #16]	@ (8004384 <chCoreAllocFromTopI+0x84>)
 8004372:	9b04      	ldr	r3, [sp, #16]
 8004374:	6053      	str	r3, [r2, #4]

  return p;
 8004376:	9b05      	ldr	r3, [sp, #20]
}
 8004378:	4618      	mov	r0, r3
 800437a:	b007      	add	sp, #28
 800437c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004380:	08004d18 	.word	0x08004d18
 8004384:	20000aa8 	.word	0x20000aa8
	...

08004390 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8004390:	b500      	push	{lr}
 8004392:	b087      	sub	sp, #28
 8004394:	9003      	str	r0, [sp, #12]
 8004396:	9102      	str	r1, [sp, #8]
 8004398:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 800439a:	f7ff ff81 	bl	80042a0 <chSysLock.lto_priv.16>
  p = chCoreAllocFromTopI(size, align, offset);
 800439e:	9a01      	ldr	r2, [sp, #4]
 80043a0:	9902      	ldr	r1, [sp, #8]
 80043a2:	9803      	ldr	r0, [sp, #12]
 80043a4:	f7ff ffac 	bl	8004300 <chCoreAllocFromTopI>
 80043a8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 80043aa:	f7ff ff89 	bl	80042c0 <chSysUnlock.lto_priv.16>

  return p;
 80043ae:	9b05      	ldr	r3, [sp, #20]
}
 80043b0:	4618      	mov	r0, r3
 80043b2:	b007      	add	sp, #28
 80043b4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080043c0 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 80043c0:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80043c2:	4b07      	ldr	r3, [pc, #28]	@ (80043e0 <__heap_init+0x20>)
 80043c4:	4a07      	ldr	r2, [pc, #28]	@ (80043e4 <__heap_init+0x24>)
 80043c6:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 80043c8:	4b05      	ldr	r3, [pc, #20]	@ (80043e0 <__heap_init+0x20>)
 80043ca:	2200      	movs	r2, #0
 80043cc:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 80043ce:	4b04      	ldr	r3, [pc, #16]	@ (80043e0 <__heap_init+0x20>)
 80043d0:	2200      	movs	r2, #0
 80043d2:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80043d4:	4804      	ldr	r0, [pc, #16]	@ (80043e8 <__heap_init+0x28>)
 80043d6:	f7ff fe5b 	bl	8004090 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 80043da:	bf00      	nop
 80043dc:	bd08      	pop	{r3, pc}
 80043de:	bf00      	nop
 80043e0:	20000ab0 	.word	0x20000ab0
 80043e4:	08004391 	.word	0x08004391
 80043e8:	20000abc 	.word	0x20000abc
 80043ec:	00000000 	.word	0x00000000

080043f0 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 80043f0:	b500      	push	{lr}
 80043f2:	b085      	sub	sp, #20
 80043f4:	9003      	str	r0, [sp, #12]
 80043f6:	9102      	str	r1, [sp, #8]
 80043f8:	9201      	str	r2, [sp, #4]
 80043fa:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 80043fc:	9b03      	ldr	r3, [sp, #12]
 80043fe:	2b00      	cmp	r3, #0
 8004400:	bf0c      	ite	eq
 8004402:	2301      	moveq	r3, #1
 8004404:	2300      	movne	r3, #0
 8004406:	b2db      	uxtb	r3, r3
 8004408:	2b00      	cmp	r3, #0
 800440a:	d107      	bne.n	800441c <chPoolObjectInitAligned+0x2c>
 800440c:	9b02      	ldr	r3, [sp, #8]
 800440e:	2b03      	cmp	r3, #3
 8004410:	bf94      	ite	ls
 8004412:	2301      	movls	r3, #1
 8004414:	2300      	movhi	r3, #0
 8004416:	b2db      	uxtb	r3, r3
 8004418:	2b00      	cmp	r3, #0
 800441a:	d001      	beq.n	8004420 <chPoolObjectInitAligned+0x30>
 800441c:	2301      	movs	r3, #1
 800441e:	e000      	b.n	8004422 <chPoolObjectInitAligned+0x32>
 8004420:	2300      	movs	r3, #0
 8004422:	2b00      	cmp	r3, #0
 8004424:	d107      	bne.n	8004436 <chPoolObjectInitAligned+0x46>
 8004426:	9b01      	ldr	r3, [sp, #4]
 8004428:	2b03      	cmp	r3, #3
 800442a:	bf94      	ite	ls
 800442c:	2301      	movls	r3, #1
 800442e:	2300      	movhi	r3, #0
 8004430:	b2db      	uxtb	r3, r3
 8004432:	2b00      	cmp	r3, #0
 8004434:	d001      	beq.n	800443a <chPoolObjectInitAligned+0x4a>
 8004436:	2301      	movs	r3, #1
 8004438:	e000      	b.n	800443c <chPoolObjectInitAligned+0x4c>
 800443a:	2300      	movs	r3, #0
 800443c:	2b00      	cmp	r3, #0
 800443e:	d117      	bne.n	8004470 <chPoolObjectInitAligned+0x80>
 8004440:	9b01      	ldr	r3, [sp, #4]
 8004442:	2b00      	cmp	r3, #0
 8004444:	bf0c      	ite	eq
 8004446:	2301      	moveq	r3, #1
 8004448:	2300      	movne	r3, #0
 800444a:	b2db      	uxtb	r3, r3
 800444c:	2b00      	cmp	r3, #0
 800444e:	d10a      	bne.n	8004466 <chPoolObjectInitAligned+0x76>
 8004450:	9b01      	ldr	r3, [sp, #4]
 8004452:	1e5a      	subs	r2, r3, #1
 8004454:	9b01      	ldr	r3, [sp, #4]
 8004456:	4013      	ands	r3, r2
 8004458:	2b00      	cmp	r3, #0
 800445a:	bf14      	ite	ne
 800445c:	2301      	movne	r3, #1
 800445e:	2300      	moveq	r3, #0
 8004460:	b2db      	uxtb	r3, r3
 8004462:	2b00      	cmp	r3, #0
 8004464:	d001      	beq.n	800446a <chPoolObjectInitAligned+0x7a>
 8004466:	2301      	movs	r3, #1
 8004468:	e000      	b.n	800446c <chPoolObjectInitAligned+0x7c>
 800446a:	2300      	movs	r3, #0
 800446c:	2b00      	cmp	r3, #0
 800446e:	d002      	beq.n	8004476 <chPoolObjectInitAligned+0x86>
 8004470:	4809      	ldr	r0, [pc, #36]	@ (8004498 <chPoolObjectInitAligned+0xa8>)
 8004472:	f7fe f9e5 	bl	8002840 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8004476:	9b03      	ldr	r3, [sp, #12]
 8004478:	2200      	movs	r2, #0
 800447a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 800447c:	9b03      	ldr	r3, [sp, #12]
 800447e:	9a02      	ldr	r2, [sp, #8]
 8004480:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8004482:	9b03      	ldr	r3, [sp, #12]
 8004484:	9a01      	ldr	r2, [sp, #4]
 8004486:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8004488:	9b03      	ldr	r3, [sp, #12]
 800448a:	9a00      	ldr	r2, [sp, #0]
 800448c:	60da      	str	r2, [r3, #12]
}
 800448e:	bf00      	nop
 8004490:	b005      	add	sp, #20
 8004492:	f85d fb04 	ldr.w	pc, [sp], #4
 8004496:	bf00      	nop
 8004498:	08004d2c 	.word	0x08004d2c
 800449c:	00000000 	.word	0x00000000

080044a0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80044a0:	b500      	push	{lr}
 80044a2:	b083      	sub	sp, #12
 80044a4:	9001      	str	r0, [sp, #4]
 80044a6:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 80044a8:	2200      	movs	r2, #0
 80044aa:	9900      	ldr	r1, [sp, #0]
 80044ac:	9801      	ldr	r0, [sp, #4]
 80044ae:	f7ff ff27 	bl	8004300 <chCoreAllocFromTopI>
 80044b2:	4603      	mov	r3, r0
}
 80044b4:	4618      	mov	r0, r3
 80044b6:	b003      	add	sp, #12
 80044b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80044bc:	0000      	movs	r0, r0
	...

080044c0 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 80044c0:	b500      	push	{lr}
 80044c2:	b085      	sub	sp, #20
 80044c4:	9003      	str	r0, [sp, #12]
 80044c6:	9102      	str	r1, [sp, #8]
 80044c8:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 80044ca:	9b01      	ldr	r3, [sp, #4]
 80044cc:	2204      	movs	r2, #4
 80044ce:	9902      	ldr	r1, [sp, #8]
 80044d0:	9803      	ldr	r0, [sp, #12]
 80044d2:	f7ff ff8d 	bl	80043f0 <chPoolObjectInitAligned>
}
 80044d6:	bf00      	nop
 80044d8:	b005      	add	sp, #20
 80044da:	f85d fb04 	ldr.w	pc, [sp], #4
 80044de:	bf00      	nop

080044e0 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 80044e0:	b082      	sub	sp, #8
 80044e2:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 80044e4:	9b01      	ldr	r3, [sp, #4]
 80044e6:	9a01      	ldr	r2, [sp, #4]
 80044e8:	601a      	str	r2, [r3, #0]
}
 80044ea:	bf00      	nop
 80044ec:	b002      	add	sp, #8
 80044ee:	4770      	bx	lr

080044f0 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 80044f0:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 80044f2:	4810      	ldr	r0, [pc, #64]	@ (8004534 <__factory_init+0x44>)
 80044f4:	f7ff fdcc 	bl	8004090 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 80044f8:	480f      	ldr	r0, [pc, #60]	@ (8004538 <__factory_init+0x48>)
 80044fa:	f7ff fff1 	bl	80044e0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 80044fe:	4a0f      	ldr	r2, [pc, #60]	@ (800453c <__factory_init+0x4c>)
 8004500:	2114      	movs	r1, #20
 8004502:	480f      	ldr	r0, [pc, #60]	@ (8004540 <__factory_init+0x50>)
 8004504:	f7ff ffdc 	bl	80044c0 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8004508:	480e      	ldr	r0, [pc, #56]	@ (8004544 <__factory_init+0x54>)
 800450a:	f7ff ffe9 	bl	80044e0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 800450e:	480e      	ldr	r0, [pc, #56]	@ (8004548 <__factory_init+0x58>)
 8004510:	f7ff ffe6 	bl	80044e0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8004514:	4a09      	ldr	r2, [pc, #36]	@ (800453c <__factory_init+0x4c>)
 8004516:	211c      	movs	r1, #28
 8004518:	480c      	ldr	r0, [pc, #48]	@ (800454c <__factory_init+0x5c>)
 800451a:	f7ff ffd1 	bl	80044c0 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 800451e:	480c      	ldr	r0, [pc, #48]	@ (8004550 <__factory_init+0x60>)
 8004520:	f7ff ffde 	bl	80044e0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8004524:	480b      	ldr	r0, [pc, #44]	@ (8004554 <__factory_init+0x64>)
 8004526:	f7ff ffdb 	bl	80044e0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 800452a:	480b      	ldr	r0, [pc, #44]	@ (8004558 <__factory_init+0x68>)
 800452c:	f7ff ffd8 	bl	80044e0 <dyn_list_init>
#endif
}
 8004530:	bf00      	nop
 8004532:	bd08      	pop	{r3, pc}
 8004534:	20000acc 	.word	0x20000acc
 8004538:	20000adc 	.word	0x20000adc
 800453c:	080044a1 	.word	0x080044a1
 8004540:	20000ae0 	.word	0x20000ae0
 8004544:	20000af0 	.word	0x20000af0
 8004548:	20000af4 	.word	0x20000af4
 800454c:	20000af8 	.word	0x20000af8
 8004550:	20000b08 	.word	0x20000b08
 8004554:	20000b0c 	.word	0x20000b0c
 8004558:	20000b10 	.word	0x20000b10
 800455c:	00000000 	.word	0x00000000

08004560 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8004560:	b084      	sub	sp, #16
 8004562:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8004564:	9b01      	ldr	r3, [sp, #4]
 8004566:	f003 0307 	and.w	r3, r3, #7
 800456a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800456c:	4b0b      	ldr	r3, [pc, #44]	@ (800459c <__NVIC_SetPriorityGrouping+0x3c>)
 800456e:	68db      	ldr	r3, [r3, #12]
 8004570:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8004572:	9a02      	ldr	r2, [sp, #8]
 8004574:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8004578:	4013      	ands	r3, r2
 800457a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800457c:	9b03      	ldr	r3, [sp, #12]
 800457e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8004580:	9b02      	ldr	r3, [sp, #8]
 8004582:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8004584:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8004588:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800458c:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 800458e:	4a03      	ldr	r2, [pc, #12]	@ (800459c <__NVIC_SetPriorityGrouping+0x3c>)
 8004590:	9b02      	ldr	r3, [sp, #8]
 8004592:	60d3      	str	r3, [r2, #12]
}
 8004594:	bf00      	nop
 8004596:	b004      	add	sp, #16
 8004598:	4770      	bx	lr
 800459a:	bf00      	nop
 800459c:	e000ed00 	.word	0xe000ed00

080045a0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80045a0:	b082      	sub	sp, #8
 80045a2:	4603      	mov	r3, r0
 80045a4:	9100      	str	r1, [sp, #0]
 80045a6:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 80045aa:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 80045ae:	2b00      	cmp	r3, #0
 80045b0:	db0a      	blt.n	80045c8 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80045b2:	9b00      	ldr	r3, [sp, #0]
 80045b4:	b2da      	uxtb	r2, r3
 80045b6:	490c      	ldr	r1, [pc, #48]	@ (80045e8 <__NVIC_SetPriority+0x48>)
 80045b8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 80045bc:	0112      	lsls	r2, r2, #4
 80045be:	b2d2      	uxtb	r2, r2
 80045c0:	440b      	add	r3, r1
 80045c2:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80045c6:	e00b      	b.n	80045e0 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80045c8:	9b00      	ldr	r3, [sp, #0]
 80045ca:	b2da      	uxtb	r2, r3
 80045cc:	4907      	ldr	r1, [pc, #28]	@ (80045ec <__NVIC_SetPriority+0x4c>)
 80045ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80045d2:	f003 030f 	and.w	r3, r3, #15
 80045d6:	3b04      	subs	r3, #4
 80045d8:	0112      	lsls	r2, r2, #4
 80045da:	b2d2      	uxtb	r2, r2
 80045dc:	440b      	add	r3, r1
 80045de:	761a      	strb	r2, [r3, #24]
}
 80045e0:	bf00      	nop
 80045e2:	b002      	add	sp, #8
 80045e4:	4770      	bx	lr
 80045e6:	bf00      	nop
 80045e8:	e000e100 	.word	0xe000e100
 80045ec:	e000ed00 	.word	0xe000ed00

080045f0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 80045f0:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80045f2:	f3ef 8309 	mrs	r3, PSP
 80045f6:	9300      	str	r3, [sp, #0]
  return(result);
 80045f8:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 80045fa:	9303      	str	r3, [sp, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 80045fc:	9b03      	ldr	r3, [sp, #12]
 80045fe:	3320      	adds	r3, #32
 8004600:	9303      	str	r3, [sp, #12]
 8004602:	9b03      	ldr	r3, [sp, #12]
 8004604:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004606:	9b01      	ldr	r3, [sp, #4]
 8004608:	f383 8809 	msr	PSP, r3
}
 800460c:	bf00      	nop
 800460e:	2300      	movs	r3, #0
 8004610:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004612:	9b02      	ldr	r3, [sp, #8]
 8004614:	f383 8811 	msr	BASEPRI, r3
}
 8004618:	bf00      	nop
 800461a:	bf00      	nop
}
 800461c:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 800461e:	bf00      	nop
 8004620:	b004      	add	sp, #16
 8004622:	4770      	bx	lr
	...

08004630 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004630:	b500      	push	{lr}
 8004632:	b085      	sub	sp, #20
 8004634:	9001      	str	r0, [sp, #4]
 8004636:	2330      	movs	r3, #48	@ 0x30
 8004638:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800463a:	9b03      	ldr	r3, [sp, #12]
 800463c:	f383 8811 	msr	BASEPRI, r3
}
 8004640:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8004642:	b662      	cpsie	i
}
 8004644:	bf00      	nop
}
 8004646:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8004648:	2003      	movs	r0, #3
 800464a:	f7ff ff89 	bl	8004560 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800464e:	4b0d      	ldr	r3, [pc, #52]	@ (8004684 <port_init+0x54>)
 8004650:	68db      	ldr	r3, [r3, #12]
 8004652:	4a0c      	ldr	r2, [pc, #48]	@ (8004684 <port_init+0x54>)
 8004654:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004658:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800465a:	4b0b      	ldr	r3, [pc, #44]	@ (8004688 <port_init+0x58>)
 800465c:	681b      	ldr	r3, [r3, #0]
 800465e:	4a0a      	ldr	r2, [pc, #40]	@ (8004688 <port_init+0x58>)
 8004660:	f043 0301 	orr.w	r3, r3, #1
 8004664:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8004666:	2102      	movs	r1, #2
 8004668:	f06f 0004 	mvn.w	r0, #4
 800466c:	f7ff ff98 	bl	80045a0 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004670:	2103      	movs	r1, #3
 8004672:	f06f 0001 	mvn.w	r0, #1
 8004676:	f7ff ff93 	bl	80045a0 <__NVIC_SetPriority>

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 800467a:	bf00      	nop
 800467c:	b005      	add	sp, #20
 800467e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004682:	bf00      	nop
 8004684:	e000edf0 	.word	0xe000edf0
 8004688:	e0001000 	.word	0xe0001000
 800468c:	00000000 	.word	0x00000000

08004690 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 8004690:	b500      	push	{lr}
 8004692:	b087      	sub	sp, #28
 8004694:	2330      	movs	r3, #48	@ 0x30
 8004696:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004698:	9b03      	ldr	r3, [sp, #12]
 800469a:	f383 8811 	msr	BASEPRI, r3
}
 800469e:	bf00      	nop
}
 80046a0:	bf00      	nop
}
 80046a2:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80046a4:	4b18      	ldr	r3, [pc, #96]	@ (8004708 <__port_irq_epilogue+0x78>)
 80046a6:	685b      	ldr	r3, [r3, #4]
 80046a8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 80046ac:	2b00      	cmp	r3, #0
 80046ae:	d020      	beq.n	80046f2 <__port_irq_epilogue+0x62>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80046b0:	f3ef 8309 	mrs	r3, PSP
 80046b4:	9301      	str	r3, [sp, #4]
  return(result);
 80046b6:	9b01      	ldr	r3, [sp, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 80046b8:	9305      	str	r3, [sp, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 80046ba:	9b05      	ldr	r3, [sp, #20]
 80046bc:	3b20      	subs	r3, #32
 80046be:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 80046c0:	9b05      	ldr	r3, [sp, #20]
 80046c2:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 80046c4:	9b04      	ldr	r3, [sp, #16]
 80046c6:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 80046ca:	61da      	str	r2, [r3, #28]
 80046cc:	9b05      	ldr	r3, [sp, #20]
 80046ce:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80046d0:	9b02      	ldr	r3, [sp, #8]
 80046d2:	f383 8809 	msr	PSP, r3
}
 80046d6:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80046d8:	f7fe ffea 	bl	80036b0 <chSchIsPreemptionRequired>
 80046dc:	4603      	mov	r3, r0
 80046de:	2b00      	cmp	r3, #0
 80046e0:	d003      	beq.n	80046ea <__port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 80046e2:	4a0a      	ldr	r2, [pc, #40]	@ (800470c <__port_irq_epilogue+0x7c>)
 80046e4:	9b04      	ldr	r3, [sp, #16]
 80046e6:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 80046e8:	e00b      	b.n	8004702 <__port_irq_epilogue+0x72>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 80046ea:	4a09      	ldr	r2, [pc, #36]	@ (8004710 <__port_irq_epilogue+0x80>)
 80046ec:	9b04      	ldr	r3, [sp, #16]
 80046ee:	619a      	str	r2, [r3, #24]
    return;
 80046f0:	e007      	b.n	8004702 <__port_irq_epilogue+0x72>
 80046f2:	2300      	movs	r3, #0
 80046f4:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80046f6:	9b00      	ldr	r3, [sp, #0]
 80046f8:	f383 8811 	msr	BASEPRI, r3
}
 80046fc:	bf00      	nop
}
 80046fe:	bf00      	nop
}
 8004700:	bf00      	nop
  }
  port_unlock_from_isr();
}
 8004702:	b007      	add	sp, #28
 8004704:	f85d fb04 	ldr.w	pc, [sp], #4
 8004708:	e000ed00 	.word	0xe000ed00
 800470c:	08000267 	.word	0x08000267
 8004710:	08000272 	.word	0x08000272
	...

08004720 <portab_setup>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

void portab_setup(void) {
 8004720:	b508      	push	{r3, lr}

  /* ADC inputs.*/
  palSetGroupMode(GPIOB, PAL_PORT_BIT(2) | PAL_PORT_BIT(10),
 8004722:	f640 0203 	movw	r2, #2051	@ 0x803
 8004726:	f240 4104 	movw	r1, #1028	@ 0x404
 800472a:	4802      	ldr	r0, [pc, #8]	@ (8004734 <portab_setup+0x14>)
 800472c:	f7fd fd30 	bl	8002190 <_pal_lld_setgroupmode>
                  0, PAL_MODE_INPUT_ANALOG);
}
 8004730:	bf00      	nop
 8004732:	bd08      	pop	{r3, pc}
 8004734:	48000400 	.word	0x48000400
	...

08004740 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8004740:	b082      	sub	sp, #8
 8004742:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8004744:	4b03      	ldr	r3, [pc, #12]	@ (8004754 <chRegSetThreadName+0x14>)
 8004746:	68db      	ldr	r3, [r3, #12]
 8004748:	9a01      	ldr	r2, [sp, #4]
 800474a:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 800474c:	bf00      	nop
 800474e:	b002      	add	sp, #8
 8004750:	4770      	bx	lr
 8004752:	bf00      	nop
 8004754:	200008e8 	.word	0x200008e8
	...

08004760 <adccallback>:

/*
 * ADC streaming callback.
 */
size_t n= 0, nx = 0, ny = 0;
void adccallback(ADCDriver *adcp) {
 8004760:	b082      	sub	sp, #8
 8004762:	9001      	str	r0, [sp, #4]

  /* Updating counters.*/
  n++;
 8004764:	4b0b      	ldr	r3, [pc, #44]	@ (8004794 <adccallback+0x34>)
 8004766:	681b      	ldr	r3, [r3, #0]
 8004768:	3301      	adds	r3, #1
 800476a:	4a0a      	ldr	r2, [pc, #40]	@ (8004794 <adccallback+0x34>)
 800476c:	6013      	str	r3, [r2, #0]
  if (adcIsBufferComplete(adcp)) {
 800476e:	9b01      	ldr	r3, [sp, #4]
 8004770:	781b      	ldrb	r3, [r3, #0]
 8004772:	2b04      	cmp	r3, #4
 8004774:	d105      	bne.n	8004782 <adccallback+0x22>
    nx += 1;
 8004776:	4b08      	ldr	r3, [pc, #32]	@ (8004798 <adccallback+0x38>)
 8004778:	681b      	ldr	r3, [r3, #0]
 800477a:	3301      	adds	r3, #1
 800477c:	4a06      	ldr	r2, [pc, #24]	@ (8004798 <adccallback+0x38>)
 800477e:	6013      	str	r3, [r2, #0]
 8004780:	e004      	b.n	800478c <adccallback+0x2c>
  }
  else {
    ny += 1;
 8004782:	4b06      	ldr	r3, [pc, #24]	@ (800479c <adccallback+0x3c>)
 8004784:	681b      	ldr	r3, [r3, #0]
 8004786:	3301      	adds	r3, #1
 8004788:	4a04      	ldr	r2, [pc, #16]	@ (800479c <adccallback+0x3c>)
 800478a:	6013      	str	r3, [r2, #0]
  if ((n % 200) == 0U) {
#if defined(PORTAB_LINE_LED2)
    palToggleLine(PORTAB_LINE_LED2);
#endif
  }
}
 800478c:	bf00      	nop
 800478e:	b002      	add	sp, #8
 8004790:	4770      	bx	lr
 8004792:	bf00      	nop
 8004794:	20000d18 	.word	0x20000d18
 8004798:	20000d1c 	.word	0x20000d1c
 800479c:	20000d20 	.word	0x20000d20

080047a0 <adcerrorcallback>:

/*
 * ADC errors callback, should never happen.
 */
void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 80047a0:	b500      	push	{lr}
 80047a2:	b083      	sub	sp, #12
 80047a4:	9001      	str	r0, [sp, #4]
 80047a6:	9100      	str	r1, [sp, #0]

  (void)adcp;
  (void)err;

  chSysHalt("it happened");
 80047a8:	4803      	ldr	r0, [pc, #12]	@ (80047b8 <adcerrorcallback+0x18>)
 80047aa:	f7fe f849 	bl	8002840 <chSysHalt>
}
 80047ae:	bf00      	nop
 80047b0:	b003      	add	sp, #12
 80047b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80047b6:	bf00      	nop
 80047b8:	08004c3c 	.word	0x08004c3c
 80047bc:	00000000 	.word	0x00000000

080047c0 <Thread1>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED attached to TP1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 80047c0:	b500      	push	{lr}
 80047c2:	b083      	sub	sp, #12
 80047c4:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 80047c6:	480a      	ldr	r0, [pc, #40]	@ (80047f0 <Thread1+0x30>)
 80047c8:	f7ff ffba 	bl	8004740 <chRegSetThreadName>
  while (true) {
    palSetLine(PORTAB_LINE_LED1);
 80047cc:	4b09      	ldr	r3, [pc, #36]	@ (80047f4 <Thread1+0x34>)
 80047ce:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80047d2:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 80047d4:	f241 3088 	movw	r0, #5000	@ 0x1388
 80047d8:	f7ff faf2 	bl	8003dc0 <chThdSleep>
    palClearLine(PORTAB_LINE_LED1);
 80047dc:	4b05      	ldr	r3, [pc, #20]	@ (80047f4 <Thread1+0x34>)
 80047de:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80047e2:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 80047e4:	f241 3088 	movw	r0, #5000	@ 0x1388
 80047e8:	f7ff faea 	bl	8003dc0 <chThdSleep>
    palSetLine(PORTAB_LINE_LED1);
 80047ec:	bf00      	nop
 80047ee:	e7ed      	b.n	80047cc <Thread1+0xc>
 80047f0:	08004c48 	.word	0x08004c48
 80047f4:	48000400 	.word	0x48000400
	...

08004800 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8004800:	b500      	push	{lr}
 8004802:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8004804:	f7fb fda4 	bl	8000350 <halInit>
  chSysInit();
 8004808:	f7fd ffea 	bl	80027e0 <chSysInit>

  /* Board-dependent GPIO setup code.*/
  portab_setup();
 800480c:	f7ff ff88 	bl	8004720 <portab_setup>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8004810:	2300      	movs	r3, #0
 8004812:	9300      	str	r3, [sp, #0]
 8004814:	4b1b      	ldr	r3, [pc, #108]	@ (8004884 <main+0x84>)
 8004816:	2280      	movs	r2, #128	@ 0x80
 8004818:	f44f 71b8 	mov.w	r1, #368	@ 0x170
 800481c:	481a      	ldr	r0, [pc, #104]	@ (8004888 <main+0x88>)
 800481e:	f7ff f9f7 	bl	8003c10 <chThdCreateStatic>

  /*
   * Starting PORTAB_ADC1 driver and the temperature sensor.
   */
  adcStart(&PORTAB_ADC1, &portab_adccfg1);
 8004822:	491a      	ldr	r1, [pc, #104]	@ (800488c <main+0x8c>)
 8004824:	481a      	ldr	r0, [pc, #104]	@ (8004890 <main+0x90>)
 8004826:	f7fb fecb 	bl	80005c0 <adcStart>
  adcSTM32EnableVREF(&PORTAB_ADC1);
 800482a:	4819      	ldr	r0, [pc, #100]	@ (8004890 <main+0x90>)
 800482c:	f7fd fa30 	bl	8001c90 <adcSTM32EnableVREF>
  adcSTM32EnableTS(&PORTAB_ADC1);
 8004830:	4817      	ldr	r0, [pc, #92]	@ (8004890 <main+0x90>)
 8004832:	f7fd fa3d 	bl	8001cb0 <adcSTM32EnableTS>

  /* Performing a one-shot conversion on two channels.*/
  adcConvert(&PORTAB_ADC1, &portab_adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
 8004836:	2302      	movs	r3, #2
 8004838:	4a16      	ldr	r2, [pc, #88]	@ (8004894 <main+0x94>)
 800483a:	4917      	ldr	r1, [pc, #92]	@ (8004898 <main+0x98>)
 800483c:	4814      	ldr	r0, [pc, #80]	@ (8004890 <main+0x90>)
 800483e:	f7fb ff9f 	bl	8000780 <adcConvert>
  cacheBufferInvalidate(samples1, sizeof (samples1) / sizeof (adcsample_t));

  /*
   * Starting PORTAB_GPT1 driver, it is used for triggering the ADC.
   */
  gptStart(&PORTAB_GPT1, &portab_gptcfg1);
 8004842:	4916      	ldr	r1, [pc, #88]	@ (800489c <main+0x9c>)
 8004844:	4816      	ldr	r0, [pc, #88]	@ (80048a0 <main+0xa0>)
 8004846:	f7fc f873 	bl	8000930 <gptStart>

  /*
   * Starting an ADC continuous conversion triggered with a period of
   * 1/10000 second.
   */
  adcStartConversion(&PORTAB_ADC1, &portab_adcgrpcfg2,
 800484a:	2340      	movs	r3, #64	@ 0x40
 800484c:	4a15      	ldr	r2, [pc, #84]	@ (80048a4 <main+0xa4>)
 800484e:	4916      	ldr	r1, [pc, #88]	@ (80048a8 <main+0xa8>)
 8004850:	480f      	ldr	r0, [pc, #60]	@ (8004890 <main+0x90>)
 8004852:	f7fb fee5 	bl	8000620 <adcStartConversion>
                     samples2, ADC_GRP2_BUF_DEPTH);
  gptStartContinuous(&PORTAB_GPT1, 100U);
 8004856:	2164      	movs	r1, #100	@ 0x64
 8004858:	4811      	ldr	r0, [pc, #68]	@ (80048a0 <main+0xa0>)
 800485a:	f7fc f8a1 	bl	80009a0 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the
   * conversion is stopped.
   */
  while (true) {
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 800485e:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8004862:	691b      	ldr	r3, [r3, #16]
 8004864:	f003 0301 	and.w	r3, r3, #1
 8004868:	2b00      	cmp	r3, #0
 800486a:	d105      	bne.n	8004878 <main+0x78>
      gptStopTimer(&PORTAB_GPT1);
 800486c:	480c      	ldr	r0, [pc, #48]	@ (80048a0 <main+0xa0>)
 800486e:	f7fc f8c7 	bl	8000a00 <gptStopTimer>
      adcStopConversion(&PORTAB_ADC1);
 8004872:	4807      	ldr	r0, [pc, #28]	@ (8004890 <main+0x90>)
 8004874:	f7fb ff54 	bl	8000720 <adcStopConversion>
    }
    chThdSleepMilliseconds(500);
 8004878:	f241 3088 	movw	r0, #5000	@ 0x1388
 800487c:	f7ff faa0 	bl	8003dc0 <chThdSleep>
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8004880:	e7ed      	b.n	800485e <main+0x5e>
 8004882:	bf00      	nop
 8004884:	080047c1 	.word	0x080047c1
 8004888:	20000d28 	.word	0x20000d28
 800488c:	08004d54 	.word	0x08004d54
 8004890:	20000820 	.word	0x20000820
 8004894:	20000b14 	.word	0x20000b14
 8004898:	08004d58 	.word	0x08004d58
 800489c:	08004d44 	.word	0x08004d44
 80048a0:	200008cc 	.word	0x200008cc
 80048a4:	20000b18 	.word	0x20000b18
 80048a8:	08004d84 	.word	0x08004d84
