
build/stm32wb55rg_nucleo68/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000219 	.word	0x08000219
 8000008:	0800021b 	.word	0x0800021b
 800000c:	0800021b 	.word	0x0800021b
 8000010:	0800021b 	.word	0x0800021b
 8000014:	0800021b 	.word	0x0800021b
 8000018:	0800021b 	.word	0x0800021b
 800001c:	0800021b 	.word	0x0800021b
 8000020:	0800021b 	.word	0x0800021b
 8000024:	0800021b 	.word	0x0800021b
 8000028:	0800021b 	.word	0x0800021b
 800002c:	08004ef1 	.word	0x08004ef1
 8000030:	0800021b 	.word	0x0800021b
 8000034:	0800021b 	.word	0x0800021b
 8000038:	0800021b 	.word	0x0800021b
 800003c:	0800021b 	.word	0x0800021b
 8000040:	0800021b 	.word	0x0800021b
 8000044:	0800021b 	.word	0x0800021b
 8000048:	0800021b 	.word	0x0800021b
 800004c:	0800021b 	.word	0x0800021b
 8000050:	0800021b 	.word	0x0800021b
 8000054:	0800021b 	.word	0x0800021b
 8000058:	08001361 	.word	0x08001361
 800005c:	080013d1 	.word	0x080013d1
 8000060:	08001441 	.word	0x08001441
 8000064:	080014b1 	.word	0x080014b1
 8000068:	08001521 	.word	0x08001521
 800006c:	080025b1 	.word	0x080025b1
 8000070:	080025d1 	.word	0x080025d1
 8000074:	080025f1 	.word	0x080025f1
 8000078:	08002611 	.word	0x08002611
 800007c:	08002631 	.word	0x08002631
 8000080:	08002651 	.word	0x08002651
 8000084:	08002671 	.word	0x08002671
 8000088:	08002221 	.word	0x08002221
 800008c:	0800021b 	.word	0x0800021b
 8000090:	0800021b 	.word	0x0800021b
 8000094:	0800021b 	.word	0x0800021b
 8000098:	0800021b 	.word	0x0800021b
 800009c:	08001591 	.word	0x08001591
 80000a0:	08001821 	.word	0x08001821
 80000a4:	08001841 	.word	0x08001841
 80000a8:	08001861 	.word	0x08001861
 80000ac:	08001881 	.word	0x08001881
 80000b0:	080018b1 	.word	0x080018b1
 80000b4:	0800021b 	.word	0x0800021b
 80000b8:	0800021b 	.word	0x0800021b
 80000bc:	0800021b 	.word	0x0800021b
 80000c0:	0800021b 	.word	0x0800021b
 80000c4:	0800021b 	.word	0x0800021b
 80000c8:	0800021b 	.word	0x0800021b
 80000cc:	0800021b 	.word	0x0800021b
 80000d0:	080017c1 	.word	0x080017c1
 80000d4:	0800021b 	.word	0x0800021b
 80000d8:	0800021b 	.word	0x0800021b
 80000dc:	0800021b 	.word	0x0800021b
 80000e0:	08001671 	.word	0x08001671
 80000e4:	0800021b 	.word	0x0800021b
 80000e8:	0800021b 	.word	0x0800021b
 80000ec:	0800021b 	.word	0x0800021b
 80000f0:	0800021b 	.word	0x0800021b
 80000f4:	0800021b 	.word	0x0800021b
 80000f8:	0800021b 	.word	0x0800021b
 80000fc:	0800021b 	.word	0x0800021b
 8000100:	0800021b 	.word	0x0800021b
 8000104:	0800021b 	.word	0x0800021b
 8000108:	0800021b 	.word	0x0800021b
 800010c:	0800021b 	.word	0x0800021b
 8000110:	0800021b 	.word	0x0800021b
 8000114:	0800021b 	.word	0x0800021b
 8000118:	0800021b 	.word	0x0800021b
 800011c:	08002691 	.word	0x08002691
 8000120:	080026b1 	.word	0x080026b1
 8000124:	080026d1 	.word	0x080026d1
 8000128:	080026f1 	.word	0x080026f1
 800012c:	08002711 	.word	0x08002711
 8000130:	08002731 	.word	0x08002731
 8000134:	08002751 	.word	0x08002751
 8000138:	0800021b 	.word	0x0800021b
 800013c:	0800021b 	.word	0x0800021b

Disassembly of section .text:

08000140 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000140:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000142:	4826      	ldr	r0, [pc, #152]	@ (80001dc <endfiniloop+0x6>)
                msr     MSP, r0
 8000144:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000148:	4825      	ldr	r0, [pc, #148]	@ (80001e0 <endfiniloop+0xa>)
                msr     PSP, r0
 800014a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 800014e:	4825      	ldr	r0, [pc, #148]	@ (80001e4 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 8000150:	4925      	ldr	r1, [pc, #148]	@ (80001e8 <endfiniloop+0x12>)
                str     r0, [r1]
 8000152:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 8000154:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000156:	f380 8814 	msr	CONTROL, r0
                isb
 800015a:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 800015e:	f000 f88f 	bl	8000280 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000162:	f002 fffd 	bl	8003160 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000166:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800016a:	4920      	ldr	r1, [pc, #128]	@ (80001ec <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800016c:	4a1b      	ldr	r2, [pc, #108]	@ (80001dc <endfiniloop+0x6>)

0800016e <msloop>:
msloop:
                cmp     r1, r2
 800016e:	4291      	cmp	r1, r2
                itt     lo
 8000170:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000172:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000176:	e7fa      	bcc.n	800016e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000178:	491d      	ldr	r1, [pc, #116]	@ (80001f0 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800017a:	4a19      	ldr	r2, [pc, #100]	@ (80001e0 <endfiniloop+0xa>)

0800017c <psloop>:
psloop:
                cmp     r1, r2
 800017c:	4291      	cmp	r1, r2
                itt     lo
 800017e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000180:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000184:	e7fa      	bcc.n	800017c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000186:	491b      	ldr	r1, [pc, #108]	@ (80001f4 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000188:	4a1b      	ldr	r2, [pc, #108]	@ (80001f8 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800018a:	4b1c      	ldr	r3, [pc, #112]	@ (80001fc <endfiniloop+0x26>)

0800018c <dloop>:
dloop:
                cmp     r2, r3
 800018c:	429a      	cmp	r2, r3
                ittt    lo
 800018e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000190:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000194:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000198:	e7f8      	bcc.n	800018c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800019a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800019c:	4918      	ldr	r1, [pc, #96]	@ (8000200 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800019e:	4a19      	ldr	r2, [pc, #100]	@ (8000204 <endfiniloop+0x2e>)

080001a0 <bloop>:
bloop:
                cmp     r1, r2
 80001a0:	4291      	cmp	r1, r2
                itt     lo
 80001a2:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001a4:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 80001a8:	e7fa      	bcc.n	80001a0 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 80001aa:	f000 f881 	bl	80002b0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 80001ae:	f000 f86f 	bl	8000290 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 80001b2:	4c15      	ldr	r4, [pc, #84]	@ (8000208 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 80001b4:	4d15      	ldr	r5, [pc, #84]	@ (800020c <endfiniloop+0x36>)

080001b6 <initloop>:
initloop:
                cmp     r4, r5
 80001b6:	42ac      	cmp	r4, r5
                bge     endinitloop
 80001b8:	da03      	bge.n	80001c2 <endinitloop>
                ldr     r1, [r4], #4
 80001ba:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80001be:	4788      	blx	r1
                b       initloop
 80001c0:	e7f9      	b.n	80001b6 <initloop>

080001c2 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80001c2:	f004 ffad 	bl	8005120 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80001c6:	4c12      	ldr	r4, [pc, #72]	@ (8000210 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 80001c8:	4d12      	ldr	r5, [pc, #72]	@ (8000214 <endfiniloop+0x3e>)

080001ca <finiloop>:
finiloop:
                cmp     r4, r5
 80001ca:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80001cc:	da03      	bge.n	80001d6 <endfiniloop>
                ldr     r1, [r4], #4
 80001ce:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80001d2:	4788      	blx	r1
                b       finiloop
 80001d4:	e7f9      	b.n	80001ca <finiloop>

080001d6 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80001d6:	f000 b863 	b.w	80002a0 <__default_exit>
 80001da:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 80001dc:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 80001e0:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 80001e4:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 80001e8:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 80001ec:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80001f0:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 80001f4:	08005724 	.word	0x08005724
                ldr     r2, =__data_base__
 80001f8:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 80001fc:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 8000200:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 8000204:	20000e80 	.word	0x20000e80
                ldr     r4, =__init_array_base__
 8000208:	08000140 	.word	0x08000140
                ldr     r5, =__init_array_end__
 800020c:	08000140 	.word	0x08000140
                ldr     r4, =__fini_array_base__
 8000210:	08000140 	.word	0x08000140
                ldr     r5, =__fini_array_end__
 8000214:	08000140 	.word	0x08000140

08000218 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000218:	e792      	b.n	8000140 <_crt0_entry>

0800021a <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 800021a:	f000 f800 	bl	800021e <_unhandled_exception>

0800021e <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 800021e:	e7fe      	b.n	800021e <_unhandled_exception>

08000220 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000220:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000224:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000228:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 800022a:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800022c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000230 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 8000230:	f003 f8ae 	bl	8003390 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000234:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000236:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 800023a:	4628      	mov	r0, r5
                blx     r4
 800023c:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800023e:	2000      	movs	r0, #0
                bl      chThdExit
 8000240:	f004 fa8e 	bl	8004760 <chThdExit>

08000244 <.zombies>:
.zombies:       b       .zombies
 8000244:	e7fe      	b.n	8000244 <.zombies>

08000246 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 8000246:	f003 f87b 	bl	8003340 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 800024a:	f003 ff31 	bl	80040b0 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 800024e:	f003 f89f 	bl	8003390 <__dbg_check_unlock>

08000252 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000252:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000254:	e7fe      	b.n	8000254 <__port_exit_from_isr+0x2>

08000256 <memcpy>:
 8000256:	440a      	add	r2, r1
 8000258:	4291      	cmp	r1, r2
 800025a:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
 800025e:	d100      	bne.n	8000262 <memcpy+0xc>
 8000260:	4770      	bx	lr
 8000262:	b510      	push	{r4, lr}
 8000264:	f811 4b01 	ldrb.w	r4, [r1], #1
 8000268:	f803 4f01 	strb.w	r4, [r3, #1]!
 800026c:	4291      	cmp	r1, r2
 800026e:	d1f9      	bne.n	8000264 <memcpy+0xe>
 8000270:	bd10      	pop	{r4, pc}
	...

08000280 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000280:	bf00      	nop
 8000282:	4770      	bx	lr
	...

08000290 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000290:	bf00      	nop
 8000292:	4770      	bx	lr
	...

080002a0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
     asm volatile ("nop");
 80002a0:	bf00      	nop
 80002a2:	e7fd      	b.n	80002a0 <__default_exit>
	...

080002b0 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80002b0:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80002b2:	4b17      	ldr	r3, [pc, #92]	@ (8000310 <__init_ram_areas+0x60>)
 80002b4:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 80002b6:	9b03      	ldr	r3, [sp, #12]
 80002b8:	681b      	ldr	r3, [r3, #0]
 80002ba:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 80002bc:	9b03      	ldr	r3, [sp, #12]
 80002be:	685b      	ldr	r3, [r3, #4]
 80002c0:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80002c2:	e009      	b.n	80002d8 <__init_ram_areas+0x28>
      *p = *tp;
 80002c4:	9b02      	ldr	r3, [sp, #8]
 80002c6:	681a      	ldr	r2, [r3, #0]
 80002c8:	9b01      	ldr	r3, [sp, #4]
 80002ca:	601a      	str	r2, [r3, #0]
      p++;
 80002cc:	9b01      	ldr	r3, [sp, #4]
 80002ce:	3304      	adds	r3, #4
 80002d0:	9301      	str	r3, [sp, #4]
      tp++;
 80002d2:	9b02      	ldr	r3, [sp, #8]
 80002d4:	3304      	adds	r3, #4
 80002d6:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 80002d8:	9b03      	ldr	r3, [sp, #12]
 80002da:	689b      	ldr	r3, [r3, #8]
 80002dc:	9a01      	ldr	r2, [sp, #4]
 80002de:	429a      	cmp	r2, r3
 80002e0:	d3f0      	bcc.n	80002c4 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80002e2:	e005      	b.n	80002f0 <__init_ram_areas+0x40>
      *p = 0;
 80002e4:	9b01      	ldr	r3, [sp, #4]
 80002e6:	2200      	movs	r2, #0
 80002e8:	601a      	str	r2, [r3, #0]
      p++;
 80002ea:	9b01      	ldr	r3, [sp, #4]
 80002ec:	3304      	adds	r3, #4
 80002ee:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 80002f0:	9b03      	ldr	r3, [sp, #12]
 80002f2:	68db      	ldr	r3, [r3, #12]
 80002f4:	9a01      	ldr	r2, [sp, #4]
 80002f6:	429a      	cmp	r2, r3
 80002f8:	d3f4      	bcc.n	80002e4 <__init_ram_areas+0x34>
    }
    rap++;
 80002fa:	9b03      	ldr	r3, [sp, #12]
 80002fc:	3310      	adds	r3, #16
 80002fe:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000300:	9b03      	ldr	r3, [sp, #12]
 8000302:	4a04      	ldr	r2, [pc, #16]	@ (8000314 <__init_ram_areas+0x64>)
 8000304:	4293      	cmp	r3, r2
 8000306:	d3d6      	bcc.n	80002b6 <__init_ram_areas+0x6>
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8000308:	bf00      	nop
 800030a:	bf00      	nop
 800030c:	b004      	add	sp, #16
 800030e:	4770      	bx	lr
 8000310:	080051cc 	.word	0x080051cc
 8000314:	0800524c 	.word	0x0800524c
	...

08000320 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000320:	bf00      	nop
 8000322:	4770      	bx	lr
	...

08000330 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000330:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000332:	f7ff fff5 	bl	8000320 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000336:	f001 fcbb 	bl	8001cb0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 800033a:	f002 fb91 	bl	8002a60 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800033e:	f000 fc3f 	bl	8000bc0 <adcInit>
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 8000342:	f000 fd95 	bl	8000e70 <gptInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000346:	f000 ff53 	bl	80011f0 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 800034a:	f002 ff11 	bl	8003170 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800034e:	f000 f83f 	bl	80003d0 <stInit>
#endif
}
 8000352:	bf00      	nop
 8000354:	bd08      	pop	{r3, pc}
 8000356:	bf00      	nop
	...

08000360 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000360:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000364:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
}
 8000366:	4618      	mov	r0, r3
 8000368:	4770      	bx	lr
 800036a:	bf00      	nop
 800036c:	0000      	movs	r0, r0
	...

08000370 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 8000370:	b082      	sub	sp, #8
 8000372:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000374:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000378:	9b01      	ldr	r3, [sp, #4]
 800037a:	6353      	str	r3, [r2, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 800037c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000380:	2200      	movs	r2, #0
 8000382:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000384:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000388:	2202      	movs	r2, #2
 800038a:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 800038c:	bf00      	nop
 800038e:	b002      	add	sp, #8
 8000390:	4770      	bx	lr
 8000392:	bf00      	nop
	...

080003a0 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 80003a0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80003a4:	2200      	movs	r2, #0
 80003a6:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 80003a8:	bf00      	nop
 80003aa:	4770      	bx	lr
 80003ac:	0000      	movs	r0, r0
	...

080003b0 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 80003b0:	b082      	sub	sp, #8
 80003b2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003b4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80003b8:	9b01      	ldr	r3, [sp, #4]
 80003ba:	6353      	str	r3, [r2, #52]	@ 0x34
}
 80003bc:	bf00      	nop
 80003be:	b002      	add	sp, #8
 80003c0:	4770      	bx	lr
 80003c2:	bf00      	nop
	...

080003d0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80003d0:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 80003d2:	f002 fb9d 	bl	8002b10 <st_lld_init>
}
 80003d6:	bf00      	nop
 80003d8:	bd08      	pop	{r3, pc}
 80003da:	bf00      	nop
 80003dc:	0000      	movs	r0, r0
	...

080003e0 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 80003e0:	b508      	push	{r3, lr}

  return st_lld_get_counter();
 80003e2:	f7ff ffbd 	bl	8000360 <st_lld_get_counter>
 80003e6:	4603      	mov	r3, r0
}
 80003e8:	4618      	mov	r0, r3
 80003ea:	bd08      	pop	{r3, pc}
 80003ec:	0000      	movs	r0, r0
	...

080003f0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 80003f0:	b500      	push	{lr}
 80003f2:	b083      	sub	sp, #12
 80003f4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 80003f6:	9801      	ldr	r0, [sp, #4]
 80003f8:	f7ff ffba 	bl	8000370 <st_lld_start_alarm>
}
 80003fc:	bf00      	nop
 80003fe:	b003      	add	sp, #12
 8000400:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000410 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000410:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8000412:	f7ff ffc5 	bl	80003a0 <st_lld_stop_alarm>
}
 8000416:	bf00      	nop
 8000418:	bd08      	pop	{r3, pc}
 800041a:	bf00      	nop
 800041c:	0000      	movs	r0, r0
	...

08000420 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000420:	b500      	push	{lr}
 8000422:	b083      	sub	sp, #12
 8000424:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8000426:	9801      	ldr	r0, [sp, #4]
 8000428:	f7ff ffc2 	bl	80003b0 <st_lld_set_alarm>
}
 800042c:	bf00      	nop
 800042e:	b003      	add	sp, #12
 8000430:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000440 <ch_queue_init.lto_priv.1>:
 *
 * @param[out] qp       pointer to the queue header
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {
 8000440:	b082      	sub	sp, #8
 8000442:	9001      	str	r0, [sp, #4]

  qp->next = qp;
 8000444:	9b01      	ldr	r3, [sp, #4]
 8000446:	9a01      	ldr	r2, [sp, #4]
 8000448:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800044a:	9b01      	ldr	r3, [sp, #4]
 800044c:	9a01      	ldr	r2, [sp, #4]
 800044e:	605a      	str	r2, [r3, #4]
}
 8000450:	bf00      	nop
 8000452:	b002      	add	sp, #8
 8000454:	4770      	bx	lr
 8000456:	bf00      	nop
	...

08000460 <chSysLock.lto_priv.1>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 8000460:	b500      	push	{lr}
 8000462:	b083      	sub	sp, #12
 8000464:	2330      	movs	r3, #48	@ 0x30
 8000466:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000468:	9b01      	ldr	r3, [sp, #4]
 800046a:	f383 8811 	msr	BASEPRI, r3
}
 800046e:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000470:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 8000472:	f002 ff65 	bl	8003340 <__dbg_check_lock>
}
 8000476:	bf00      	nop
 8000478:	b003      	add	sp, #12
 800047a:	f85d fb04 	ldr.w	pc, [sp], #4
 800047e:	bf00      	nop

08000480 <chSysUnlock.lto_priv.1>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000480:	b500      	push	{lr}
 8000482:	b083      	sub	sp, #12

  __dbg_check_unlock();
 8000484:	f002 ff84 	bl	8003390 <__dbg_check_unlock>
 8000488:	2300      	movs	r3, #0
 800048a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800048c:	9b01      	ldr	r3, [sp, #4]
 800048e:	f383 8811 	msr	BASEPRI, r3
}
 8000492:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000494:	bf00      	nop
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 8000496:	bf00      	nop
 8000498:	b003      	add	sp, #12
 800049a:	f85d fb04 	ldr.w	pc, [sp], #4
 800049e:	bf00      	nop

080004a0 <chThdQueueObjectInit.lto_priv.1>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80004a0:	b500      	push	{lr}
 80004a2:	b083      	sub	sp, #12
 80004a4:	9001      	str	r0, [sp, #4]

  ch_queue_init(&tqp->queue);
 80004a6:	9b01      	ldr	r3, [sp, #4]
 80004a8:	4618      	mov	r0, r3
 80004aa:	f7ff ffc9 	bl	8000440 <ch_queue_init.lto_priv.1>
}
 80004ae:	bf00      	nop
 80004b0:	b003      	add	sp, #12
 80004b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80004b6:	bf00      	nop
	...

080004c0 <osalSysLock.lto_priv.1>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80004c0:	b508      	push	{r3, lr}

  chSysLock();
 80004c2:	f7ff ffcd 	bl	8000460 <chSysLock.lto_priv.1>
}
 80004c6:	bf00      	nop
 80004c8:	bd08      	pop	{r3, pc}
 80004ca:	bf00      	nop
 80004cc:	0000      	movs	r0, r0
	...

080004d0 <osalSysUnlock.lto_priv.1>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80004d0:	b508      	push	{r3, lr}

  chSysUnlock();
 80004d2:	f7ff ffd5 	bl	8000480 <chSysUnlock.lto_priv.1>
}
 80004d6:	bf00      	nop
 80004d8:	bd08      	pop	{r3, pc}
 80004da:	bf00      	nop
 80004dc:	0000      	movs	r0, r0
	...

080004e0 <osalThreadQueueObjectInit.lto_priv.1>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 80004e0:	b500      	push	{lr}
 80004e2:	b083      	sub	sp, #12
 80004e4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 80004e6:	9801      	ldr	r0, [sp, #4]
 80004e8:	f7ff ffda 	bl	80004a0 <chThdQueueObjectInit.lto_priv.1>
}
 80004ec:	bf00      	nop
 80004ee:	b003      	add	sp, #12
 80004f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000500 <osalThreadEnqueueTimeoutS.lto_priv.1>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {
 8000500:	b500      	push	{lr}
 8000502:	b083      	sub	sp, #12
 8000504:	9001      	str	r0, [sp, #4]
 8000506:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, timeout);
 8000508:	9900      	ldr	r1, [sp, #0]
 800050a:	9801      	ldr	r0, [sp, #4]
 800050c:	f004 f9e0 	bl	80048d0 <chThdEnqueueTimeoutS>
 8000510:	4603      	mov	r3, r0
}
 8000512:	4618      	mov	r0, r3
 8000514:	b003      	add	sp, #12
 8000516:	f85d fb04 	ldr.w	pc, [sp], #4
 800051a:	bf00      	nop
 800051c:	0000      	movs	r0, r0
	...

08000520 <osalThreadDequeueNextI.lto_priv.1>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000520:	b500      	push	{lr}
 8000522:	b083      	sub	sp, #12
 8000524:	9001      	str	r0, [sp, #4]
 8000526:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8000528:	9900      	ldr	r1, [sp, #0]
 800052a:	9801      	ldr	r0, [sp, #4]
 800052c:	f004 f9f0 	bl	8004910 <chThdDequeueNextI>
}
 8000530:	bf00      	nop
 8000532:	b003      	add	sp, #12
 8000534:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000540 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8000540:	b500      	push	{lr}
 8000542:	b087      	sub	sp, #28
 8000544:	9003      	str	r0, [sp, #12]
 8000546:	9102      	str	r1, [sp, #8]
 8000548:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);
 800054a:	9b01      	ldr	r3, [sp, #4]
 800054c:	2b00      	cmp	r3, #0
 800054e:	bf0c      	ite	eq
 8000550:	2301      	moveq	r3, #1
 8000552:	2300      	movne	r3, #0
 8000554:	b2db      	uxtb	r3, r3
 8000556:	2b00      	cmp	r3, #0
 8000558:	d002      	beq.n	8000560 <iq_read+0x20>
 800055a:	482d      	ldr	r0, [pc, #180]	@ (8000610 <iq_read+0xd0>)
 800055c:	f002 fe88 	bl	8003270 <chSysHalt>

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8000560:	9b03      	ldr	r3, [sp, #12]
 8000562:	689b      	ldr	r3, [r3, #8]
 8000564:	9a01      	ldr	r2, [sp, #4]
 8000566:	429a      	cmp	r2, r3
 8000568:	d902      	bls.n	8000570 <iq_read+0x30>
    n = iqGetFullI(iqp);
 800056a:	9b03      	ldr	r3, [sp, #12]
 800056c:	689b      	ldr	r3, [r3, #8]
 800056e:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000570:	9b03      	ldr	r3, [sp, #12]
 8000572:	691a      	ldr	r2, [r3, #16]
 8000574:	9b03      	ldr	r3, [sp, #12]
 8000576:	699b      	ldr	r3, [r3, #24]
 8000578:	1ad3      	subs	r3, r2, r3
 800057a:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 800057c:	9a01      	ldr	r2, [sp, #4]
 800057e:	9b05      	ldr	r3, [sp, #20]
 8000580:	429a      	cmp	r2, r3
 8000582:	d20d      	bcs.n	80005a0 <iq_read+0x60>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000584:	9b03      	ldr	r3, [sp, #12]
 8000586:	699b      	ldr	r3, [r3, #24]
 8000588:	9a01      	ldr	r2, [sp, #4]
 800058a:	4619      	mov	r1, r3
 800058c:	9802      	ldr	r0, [sp, #8]
 800058e:	f7ff fe62 	bl	8000256 <memcpy>
    iqp->q_rdptr += n;
 8000592:	9b03      	ldr	r3, [sp, #12]
 8000594:	699a      	ldr	r2, [r3, #24]
 8000596:	9b01      	ldr	r3, [sp, #4]
 8000598:	441a      	add	r2, r3
 800059a:	9b03      	ldr	r3, [sp, #12]
 800059c:	619a      	str	r2, [r3, #24]
 800059e:	e02b      	b.n	80005f8 <iq_read+0xb8>
  }
  else if (n > s1) {
 80005a0:	9a01      	ldr	r2, [sp, #4]
 80005a2:	9b05      	ldr	r3, [sp, #20]
 80005a4:	429a      	cmp	r2, r3
 80005a6:	d91c      	bls.n	80005e2 <iq_read+0xa2>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 80005a8:	9b03      	ldr	r3, [sp, #12]
 80005aa:	699b      	ldr	r3, [r3, #24]
 80005ac:	9a05      	ldr	r2, [sp, #20]
 80005ae:	4619      	mov	r1, r3
 80005b0:	9802      	ldr	r0, [sp, #8]
 80005b2:	f7ff fe50 	bl	8000256 <memcpy>
    bp += s1;
 80005b6:	9a02      	ldr	r2, [sp, #8]
 80005b8:	9b05      	ldr	r3, [sp, #20]
 80005ba:	4413      	add	r3, r2
 80005bc:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 80005be:	9a01      	ldr	r2, [sp, #4]
 80005c0:	9b05      	ldr	r3, [sp, #20]
 80005c2:	1ad3      	subs	r3, r2, r3
 80005c4:	9304      	str	r3, [sp, #16]
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 80005c6:	9b03      	ldr	r3, [sp, #12]
 80005c8:	68db      	ldr	r3, [r3, #12]
 80005ca:	9a04      	ldr	r2, [sp, #16]
 80005cc:	4619      	mov	r1, r3
 80005ce:	9802      	ldr	r0, [sp, #8]
 80005d0:	f7ff fe41 	bl	8000256 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 80005d4:	9b03      	ldr	r3, [sp, #12]
 80005d6:	68da      	ldr	r2, [r3, #12]
 80005d8:	9b04      	ldr	r3, [sp, #16]
 80005da:	441a      	add	r2, r3
 80005dc:	9b03      	ldr	r3, [sp, #12]
 80005de:	619a      	str	r2, [r3, #24]
 80005e0:	e00a      	b.n	80005f8 <iq_read+0xb8>
  }
  else {
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 80005e2:	9b03      	ldr	r3, [sp, #12]
 80005e4:	699b      	ldr	r3, [r3, #24]
 80005e6:	9a01      	ldr	r2, [sp, #4]
 80005e8:	4619      	mov	r1, r3
 80005ea:	9802      	ldr	r0, [sp, #8]
 80005ec:	f7ff fe33 	bl	8000256 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 80005f0:	9b03      	ldr	r3, [sp, #12]
 80005f2:	68da      	ldr	r2, [r3, #12]
 80005f4:	9b03      	ldr	r3, [sp, #12]
 80005f6:	619a      	str	r2, [r3, #24]
  }

  iqp->q_counter -= n;
 80005f8:	9b03      	ldr	r3, [sp, #12]
 80005fa:	689a      	ldr	r2, [r3, #8]
 80005fc:	9b01      	ldr	r3, [sp, #4]
 80005fe:	1ad2      	subs	r2, r2, r3
 8000600:	9b03      	ldr	r3, [sp, #12]
 8000602:	609a      	str	r2, [r3, #8]
  return n;
 8000604:	9b01      	ldr	r3, [sp, #4]
}
 8000606:	4618      	mov	r0, r3
 8000608:	b007      	add	sp, #28
 800060a:	f85d fb04 	ldr.w	pc, [sp], #4
 800060e:	bf00      	nop
 8000610:	0800524c 	.word	0x0800524c
	...

08000620 <oq_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8000620:	b500      	push	{lr}
 8000622:	b087      	sub	sp, #28
 8000624:	9003      	str	r0, [sp, #12]
 8000626:	9102      	str	r1, [sp, #8]
 8000628:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);
 800062a:	9b01      	ldr	r3, [sp, #4]
 800062c:	2b00      	cmp	r3, #0
 800062e:	bf0c      	ite	eq
 8000630:	2301      	moveq	r3, #1
 8000632:	2300      	movne	r3, #0
 8000634:	b2db      	uxtb	r3, r3
 8000636:	2b00      	cmp	r3, #0
 8000638:	d002      	beq.n	8000640 <oq_write+0x20>
 800063a:	482d      	ldr	r0, [pc, #180]	@ (80006f0 <oq_write+0xd0>)
 800063c:	f002 fe18 	bl	8003270 <chSysHalt>

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 8000640:	9b03      	ldr	r3, [sp, #12]
 8000642:	689b      	ldr	r3, [r3, #8]
 8000644:	9a01      	ldr	r2, [sp, #4]
 8000646:	429a      	cmp	r2, r3
 8000648:	d902      	bls.n	8000650 <oq_write+0x30>
    n = oqGetEmptyI(oqp);
 800064a:	9b03      	ldr	r3, [sp, #12]
 800064c:	689b      	ldr	r3, [r3, #8]
 800064e:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000650:	9b03      	ldr	r3, [sp, #12]
 8000652:	691a      	ldr	r2, [r3, #16]
 8000654:	9b03      	ldr	r3, [sp, #12]
 8000656:	695b      	ldr	r3, [r3, #20]
 8000658:	1ad3      	subs	r3, r2, r3
 800065a:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 800065c:	9a01      	ldr	r2, [sp, #4]
 800065e:	9b05      	ldr	r3, [sp, #20]
 8000660:	429a      	cmp	r2, r3
 8000662:	d20d      	bcs.n	8000680 <oq_write+0x60>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000664:	9b03      	ldr	r3, [sp, #12]
 8000666:	695b      	ldr	r3, [r3, #20]
 8000668:	9a01      	ldr	r2, [sp, #4]
 800066a:	9902      	ldr	r1, [sp, #8]
 800066c:	4618      	mov	r0, r3
 800066e:	f7ff fdf2 	bl	8000256 <memcpy>
    oqp->q_wrptr += n;
 8000672:	9b03      	ldr	r3, [sp, #12]
 8000674:	695a      	ldr	r2, [r3, #20]
 8000676:	9b01      	ldr	r3, [sp, #4]
 8000678:	441a      	add	r2, r3
 800067a:	9b03      	ldr	r3, [sp, #12]
 800067c:	615a      	str	r2, [r3, #20]
 800067e:	e02b      	b.n	80006d8 <oq_write+0xb8>
  }
  else if (n > s1) {
 8000680:	9a01      	ldr	r2, [sp, #4]
 8000682:	9b05      	ldr	r3, [sp, #20]
 8000684:	429a      	cmp	r2, r3
 8000686:	d91c      	bls.n	80006c2 <oq_write+0xa2>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000688:	9b03      	ldr	r3, [sp, #12]
 800068a:	695b      	ldr	r3, [r3, #20]
 800068c:	9a05      	ldr	r2, [sp, #20]
 800068e:	9902      	ldr	r1, [sp, #8]
 8000690:	4618      	mov	r0, r3
 8000692:	f7ff fde0 	bl	8000256 <memcpy>
    bp += s1;
 8000696:	9a02      	ldr	r2, [sp, #8]
 8000698:	9b05      	ldr	r3, [sp, #20]
 800069a:	4413      	add	r3, r2
 800069c:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 800069e:	9a01      	ldr	r2, [sp, #4]
 80006a0:	9b05      	ldr	r3, [sp, #20]
 80006a2:	1ad3      	subs	r3, r2, r3
 80006a4:	9304      	str	r3, [sp, #16]
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 80006a6:	9b03      	ldr	r3, [sp, #12]
 80006a8:	68db      	ldr	r3, [r3, #12]
 80006aa:	9a04      	ldr	r2, [sp, #16]
 80006ac:	9902      	ldr	r1, [sp, #8]
 80006ae:	4618      	mov	r0, r3
 80006b0:	f7ff fdd1 	bl	8000256 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 80006b4:	9b03      	ldr	r3, [sp, #12]
 80006b6:	68da      	ldr	r2, [r3, #12]
 80006b8:	9b04      	ldr	r3, [sp, #16]
 80006ba:	441a      	add	r2, r3
 80006bc:	9b03      	ldr	r3, [sp, #12]
 80006be:	615a      	str	r2, [r3, #20]
 80006c0:	e00a      	b.n	80006d8 <oq_write+0xb8>
  }
  else {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80006c2:	9b03      	ldr	r3, [sp, #12]
 80006c4:	695b      	ldr	r3, [r3, #20]
 80006c6:	9a01      	ldr	r2, [sp, #4]
 80006c8:	9902      	ldr	r1, [sp, #8]
 80006ca:	4618      	mov	r0, r3
 80006cc:	f7ff fdc3 	bl	8000256 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 80006d0:	9b03      	ldr	r3, [sp, #12]
 80006d2:	68da      	ldr	r2, [r3, #12]
 80006d4:	9b03      	ldr	r3, [sp, #12]
 80006d6:	615a      	str	r2, [r3, #20]
  }

  oqp->q_counter -= n;
 80006d8:	9b03      	ldr	r3, [sp, #12]
 80006da:	689a      	ldr	r2, [r3, #8]
 80006dc:	9b01      	ldr	r3, [sp, #4]
 80006de:	1ad2      	subs	r2, r2, r3
 80006e0:	9b03      	ldr	r3, [sp, #12]
 80006e2:	609a      	str	r2, [r3, #8]
  return n;
 80006e4:	9b01      	ldr	r3, [sp, #4]
}
 80006e6:	4618      	mov	r0, r3
 80006e8:	b007      	add	sp, #28
 80006ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80006ee:	bf00      	nop
 80006f0:	08005254 	.word	0x08005254
	...

08000700 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8000700:	b500      	push	{lr}
 8000702:	b085      	sub	sp, #20
 8000704:	9003      	str	r0, [sp, #12]
 8000706:	9102      	str	r1, [sp, #8]
 8000708:	9201      	str	r2, [sp, #4]
 800070a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 800070c:	9b03      	ldr	r3, [sp, #12]
 800070e:	4618      	mov	r0, r3
 8000710:	f7ff fee6 	bl	80004e0 <osalThreadQueueObjectInit.lto_priv.1>
  iqp->q_counter = 0;
 8000714:	9b03      	ldr	r3, [sp, #12]
 8000716:	2200      	movs	r2, #0
 8000718:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800071a:	9b03      	ldr	r3, [sp, #12]
 800071c:	9a02      	ldr	r2, [sp, #8]
 800071e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8000720:	9b03      	ldr	r3, [sp, #12]
 8000722:	9a02      	ldr	r2, [sp, #8]
 8000724:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8000726:	9b03      	ldr	r3, [sp, #12]
 8000728:	9a02      	ldr	r2, [sp, #8]
 800072a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800072c:	9a02      	ldr	r2, [sp, #8]
 800072e:	9b01      	ldr	r3, [sp, #4]
 8000730:	441a      	add	r2, r3
 8000732:	9b03      	ldr	r3, [sp, #12]
 8000734:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8000736:	9b03      	ldr	r3, [sp, #12]
 8000738:	9a00      	ldr	r2, [sp, #0]
 800073a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800073c:	9b03      	ldr	r3, [sp, #12]
 800073e:	9a06      	ldr	r2, [sp, #24]
 8000740:	621a      	str	r2, [r3, #32]
}
 8000742:	bf00      	nop
 8000744:	b005      	add	sp, #20
 8000746:	f85d fb04 	ldr.w	pc, [sp], #4
 800074a:	bf00      	nop
 800074c:	0000      	movs	r0, r0
	...

08000750 <iqPutI>:
 * @retval MSG_OK       if the operation has been completed with success.
 * @retval MSG_TIMEOUT  if the queue is full.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8000750:	b500      	push	{lr}
 8000752:	b083      	sub	sp, #12
 8000754:	9001      	str	r0, [sp, #4]
 8000756:	460b      	mov	r3, r1
 8000758:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 800075c:	f002 ff08 	bl	8003570 <chDbgCheckClassI>

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 8000760:	9b01      	ldr	r3, [sp, #4]
 8000762:	695a      	ldr	r2, [r3, #20]
 8000764:	9b01      	ldr	r3, [sp, #4]
 8000766:	699b      	ldr	r3, [r3, #24]
 8000768:	429a      	cmp	r2, r3
 800076a:	d105      	bne.n	8000778 <iqPutI+0x28>
 800076c:	9b01      	ldr	r3, [sp, #4]
 800076e:	689b      	ldr	r3, [r3, #8]
 8000770:	2b00      	cmp	r3, #0
 8000772:	d001      	beq.n	8000778 <iqPutI+0x28>
 8000774:	2301      	movs	r3, #1
 8000776:	e000      	b.n	800077a <iqPutI+0x2a>
 8000778:	2300      	movs	r3, #0
 800077a:	f003 0301 	and.w	r3, r3, #1
 800077e:	b2db      	uxtb	r3, r3
 8000780:	f083 0301 	eor.w	r3, r3, #1
 8000784:	b2db      	uxtb	r3, r3
 8000786:	2b00      	cmp	r3, #0
 8000788:	d01d      	beq.n	80007c6 <iqPutI+0x76>
    iqp->q_counter++;
 800078a:	9b01      	ldr	r3, [sp, #4]
 800078c:	689b      	ldr	r3, [r3, #8]
 800078e:	1c5a      	adds	r2, r3, #1
 8000790:	9b01      	ldr	r3, [sp, #4]
 8000792:	609a      	str	r2, [r3, #8]
    *iqp->q_wrptr++ = b;
 8000794:	9b01      	ldr	r3, [sp, #4]
 8000796:	695b      	ldr	r3, [r3, #20]
 8000798:	1c59      	adds	r1, r3, #1
 800079a:	9a01      	ldr	r2, [sp, #4]
 800079c:	6151      	str	r1, [r2, #20]
 800079e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80007a2:	701a      	strb	r2, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 80007a4:	9b01      	ldr	r3, [sp, #4]
 80007a6:	695a      	ldr	r2, [r3, #20]
 80007a8:	9b01      	ldr	r3, [sp, #4]
 80007aa:	691b      	ldr	r3, [r3, #16]
 80007ac:	429a      	cmp	r2, r3
 80007ae:	d303      	bcc.n	80007b8 <iqPutI+0x68>
      iqp->q_wrptr = iqp->q_buffer;
 80007b0:	9b01      	ldr	r3, [sp, #4]
 80007b2:	68da      	ldr	r2, [r3, #12]
 80007b4:	9b01      	ldr	r3, [sp, #4]
 80007b6:	615a      	str	r2, [r3, #20]
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 80007b8:	9b01      	ldr	r3, [sp, #4]
 80007ba:	2100      	movs	r1, #0
 80007bc:	4618      	mov	r0, r3
 80007be:	f7ff feaf 	bl	8000520 <osalThreadDequeueNextI.lto_priv.1>

    return MSG_OK;
 80007c2:	2300      	movs	r3, #0
 80007c4:	e001      	b.n	80007ca <iqPutI+0x7a>
  }

  return MSG_TIMEOUT;
 80007c6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
 80007ca:	4618      	mov	r0, r3
 80007cc:	b003      	add	sp, #12
 80007ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80007d2:	bf00      	nop
	...

080007e0 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 80007e0:	b500      	push	{lr}
 80007e2:	b085      	sub	sp, #20
 80007e4:	9001      	str	r0, [sp, #4]
 80007e6:	9100      	str	r1, [sp, #0]
  uint8_t b;

  osalSysLock();
 80007e8:	f7ff fe6a 	bl	80004c0 <osalSysLock.lto_priv.1>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 80007ec:	e00c      	b.n	8000808 <iqGetTimeout+0x28>
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80007ee:	9b01      	ldr	r3, [sp, #4]
 80007f0:	9900      	ldr	r1, [sp, #0]
 80007f2:	4618      	mov	r0, r3
 80007f4:	f7ff fe84 	bl	8000500 <osalThreadEnqueueTimeoutS.lto_priv.1>
 80007f8:	9002      	str	r0, [sp, #8]
    if (msg < MSG_OK) {
 80007fa:	9b02      	ldr	r3, [sp, #8]
 80007fc:	2b00      	cmp	r3, #0
 80007fe:	da03      	bge.n	8000808 <iqGetTimeout+0x28>
      osalSysUnlock();
 8000800:	f7ff fe66 	bl	80004d0 <osalSysUnlock.lto_priv.1>
      return msg;
 8000804:	9b02      	ldr	r3, [sp, #8]
 8000806:	e026      	b.n	8000856 <iqGetTimeout+0x76>
  while (iqIsEmptyI(iqp)) {
 8000808:	9b01      	ldr	r3, [sp, #4]
 800080a:	689b      	ldr	r3, [r3, #8]
 800080c:	2b00      	cmp	r3, #0
 800080e:	d0ee      	beq.n	80007ee <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8000810:	9b01      	ldr	r3, [sp, #4]
 8000812:	689b      	ldr	r3, [r3, #8]
 8000814:	1e5a      	subs	r2, r3, #1
 8000816:	9b01      	ldr	r3, [sp, #4]
 8000818:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800081a:	9b01      	ldr	r3, [sp, #4]
 800081c:	699b      	ldr	r3, [r3, #24]
 800081e:	1c59      	adds	r1, r3, #1
 8000820:	9a01      	ldr	r2, [sp, #4]
 8000822:	6191      	str	r1, [r2, #24]
 8000824:	781b      	ldrb	r3, [r3, #0]
 8000826:	f88d 300f 	strb.w	r3, [sp, #15]
  if (iqp->q_rdptr >= iqp->q_top) {
 800082a:	9b01      	ldr	r3, [sp, #4]
 800082c:	699a      	ldr	r2, [r3, #24]
 800082e:	9b01      	ldr	r3, [sp, #4]
 8000830:	691b      	ldr	r3, [r3, #16]
 8000832:	429a      	cmp	r2, r3
 8000834:	d303      	bcc.n	800083e <iqGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
 8000836:	9b01      	ldr	r3, [sp, #4]
 8000838:	68da      	ldr	r2, [r3, #12]
 800083a:	9b01      	ldr	r3, [sp, #4]
 800083c:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 800083e:	9b01      	ldr	r3, [sp, #4]
 8000840:	69db      	ldr	r3, [r3, #28]
 8000842:	2b00      	cmp	r3, #0
 8000844:	d003      	beq.n	800084e <iqGetTimeout+0x6e>
    iqp->q_notify(iqp);
 8000846:	9b01      	ldr	r3, [sp, #4]
 8000848:	69db      	ldr	r3, [r3, #28]
 800084a:	9801      	ldr	r0, [sp, #4]
 800084c:	4798      	blx	r3
  }

  osalSysUnlock();
 800084e:	f7ff fe3f 	bl	80004d0 <osalSysUnlock.lto_priv.1>

  return (msg_t)b;
 8000852:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8000856:	4618      	mov	r0, r3
 8000858:	b005      	add	sp, #20
 800085a:	f85d fb04 	ldr.w	pc, [sp], #4
 800085e:	bf00      	nop

08000860 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8000860:	b500      	push	{lr}
 8000862:	b089      	sub	sp, #36	@ 0x24
 8000864:	9003      	str	r0, [sp, #12]
 8000866:	9102      	str	r1, [sp, #8]
 8000868:	9201      	str	r2, [sp, #4]
 800086a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800086c:	9b03      	ldr	r3, [sp, #12]
 800086e:	69db      	ldr	r3, [r3, #28]
 8000870:	9307      	str	r3, [sp, #28]
  size_t max = n;
 8000872:	9b01      	ldr	r3, [sp, #4]
 8000874:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);
 8000876:	9b01      	ldr	r3, [sp, #4]
 8000878:	2b00      	cmp	r3, #0
 800087a:	bf0c      	ite	eq
 800087c:	2301      	moveq	r3, #1
 800087e:	2300      	movne	r3, #0
 8000880:	b2db      	uxtb	r3, r3
 8000882:	2b00      	cmp	r3, #0
 8000884:	d002      	beq.n	800088c <iqReadTimeout+0x2c>
 8000886:	481b      	ldr	r0, [pc, #108]	@ (80008f4 <iqReadTimeout+0x94>)
 8000888:	f002 fcf2 	bl	8003270 <chSysHalt>

  osalSysLock();
 800088c:	f7ff fe18 	bl	80004c0 <osalSysLock.lto_priv.1>

  while (n > 0U) {
 8000890:	e024      	b.n	80008dc <iqReadTimeout+0x7c>
    size_t done;

    done = iq_read(iqp, bp, n);
 8000892:	9a01      	ldr	r2, [sp, #4]
 8000894:	9902      	ldr	r1, [sp, #8]
 8000896:	9803      	ldr	r0, [sp, #12]
 8000898:	f7ff fe52 	bl	8000540 <iq_read>
 800089c:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 800089e:	9b05      	ldr	r3, [sp, #20]
 80008a0:	2b00      	cmp	r3, #0
 80008a2:	d109      	bne.n	80008b8 <iqReadTimeout+0x58>
      msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80008a4:	9b03      	ldr	r3, [sp, #12]
 80008a6:	9900      	ldr	r1, [sp, #0]
 80008a8:	4618      	mov	r0, r3
 80008aa:	f7ff fe29 	bl	8000500 <osalThreadEnqueueTimeoutS.lto_priv.1>
 80008ae:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80008b0:	9b04      	ldr	r3, [sp, #16]
 80008b2:	2b00      	cmp	r3, #0
 80008b4:	d012      	beq.n	80008dc <iqReadTimeout+0x7c>
        break;
 80008b6:	e014      	b.n	80008e2 <iqReadTimeout+0x82>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
 80008b8:	9b07      	ldr	r3, [sp, #28]
 80008ba:	2b00      	cmp	r3, #0
 80008bc:	d002      	beq.n	80008c4 <iqReadTimeout+0x64>
        nfy(iqp);
 80008be:	9b07      	ldr	r3, [sp, #28]
 80008c0:	9803      	ldr	r0, [sp, #12]
 80008c2:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 80008c4:	f7ff fe04 	bl	80004d0 <osalSysUnlock.lto_priv.1>

      n  -= done;
 80008c8:	9a01      	ldr	r2, [sp, #4]
 80008ca:	9b05      	ldr	r3, [sp, #20]
 80008cc:	1ad3      	subs	r3, r2, r3
 80008ce:	9301      	str	r3, [sp, #4]
      bp += done;
 80008d0:	9a02      	ldr	r2, [sp, #8]
 80008d2:	9b05      	ldr	r3, [sp, #20]
 80008d4:	4413      	add	r3, r2
 80008d6:	9302      	str	r3, [sp, #8]

      osalSysLock();
 80008d8:	f7ff fdf2 	bl	80004c0 <osalSysLock.lto_priv.1>
  while (n > 0U) {
 80008dc:	9b01      	ldr	r3, [sp, #4]
 80008de:	2b00      	cmp	r3, #0
 80008e0:	d1d7      	bne.n	8000892 <iqReadTimeout+0x32>
    }
  }

  osalSysUnlock();
 80008e2:	f7ff fdf5 	bl	80004d0 <osalSysUnlock.lto_priv.1>
  return max - n;
 80008e6:	9a06      	ldr	r2, [sp, #24]
 80008e8:	9b01      	ldr	r3, [sp, #4]
 80008ea:	1ad3      	subs	r3, r2, r3
}
 80008ec:	4618      	mov	r0, r3
 80008ee:	b009      	add	sp, #36	@ 0x24
 80008f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80008f4:	08005260 	.word	0x08005260
	...

08000900 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8000900:	b500      	push	{lr}
 8000902:	b085      	sub	sp, #20
 8000904:	9003      	str	r0, [sp, #12]
 8000906:	9102      	str	r1, [sp, #8]
 8000908:	9201      	str	r2, [sp, #4]
 800090a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 800090c:	9b03      	ldr	r3, [sp, #12]
 800090e:	4618      	mov	r0, r3
 8000910:	f7ff fde6 	bl	80004e0 <osalThreadQueueObjectInit.lto_priv.1>
  oqp->q_counter = size;
 8000914:	9b03      	ldr	r3, [sp, #12]
 8000916:	9a01      	ldr	r2, [sp, #4]
 8000918:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800091a:	9b03      	ldr	r3, [sp, #12]
 800091c:	9a02      	ldr	r2, [sp, #8]
 800091e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8000920:	9b03      	ldr	r3, [sp, #12]
 8000922:	9a02      	ldr	r2, [sp, #8]
 8000924:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8000926:	9b03      	ldr	r3, [sp, #12]
 8000928:	9a02      	ldr	r2, [sp, #8]
 800092a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800092c:	9a02      	ldr	r2, [sp, #8]
 800092e:	9b01      	ldr	r3, [sp, #4]
 8000930:	441a      	add	r2, r3
 8000932:	9b03      	ldr	r3, [sp, #12]
 8000934:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8000936:	9b03      	ldr	r3, [sp, #12]
 8000938:	9a00      	ldr	r2, [sp, #0]
 800093a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800093c:	9b03      	ldr	r3, [sp, #12]
 800093e:	9a06      	ldr	r2, [sp, #24]
 8000940:	621a      	str	r2, [r3, #32]
}
 8000942:	bf00      	nop
 8000944:	b005      	add	sp, #20
 8000946:	f85d fb04 	ldr.w	pc, [sp], #4
 800094a:	bf00      	nop
 800094c:	0000      	movs	r0, r0
	...

08000950 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000950:	b500      	push	{lr}
 8000952:	b087      	sub	sp, #28
 8000954:	9003      	str	r0, [sp, #12]
 8000956:	460b      	mov	r3, r1
 8000958:	9201      	str	r2, [sp, #4]
 800095a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalSysLock();
 800095e:	f7ff fdaf 	bl	80004c0 <osalSysLock.lto_priv.1>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8000962:	e00c      	b.n	800097e <oqPutTimeout+0x2e>
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000964:	9b03      	ldr	r3, [sp, #12]
 8000966:	9901      	ldr	r1, [sp, #4]
 8000968:	4618      	mov	r0, r3
 800096a:	f7ff fdc9 	bl	8000500 <osalThreadEnqueueTimeoutS.lto_priv.1>
 800096e:	9005      	str	r0, [sp, #20]
    if (msg < MSG_OK) {
 8000970:	9b05      	ldr	r3, [sp, #20]
 8000972:	2b00      	cmp	r3, #0
 8000974:	da03      	bge.n	800097e <oqPutTimeout+0x2e>
      osalSysUnlock();
 8000976:	f7ff fdab 	bl	80004d0 <osalSysUnlock.lto_priv.1>
      return msg;
 800097a:	9b05      	ldr	r3, [sp, #20]
 800097c:	e025      	b.n	80009ca <oqPutTimeout+0x7a>
  while (oqIsFullI(oqp)) {
 800097e:	9b03      	ldr	r3, [sp, #12]
 8000980:	689b      	ldr	r3, [r3, #8]
 8000982:	2b00      	cmp	r3, #0
 8000984:	d0ee      	beq.n	8000964 <oqPutTimeout+0x14>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8000986:	9b03      	ldr	r3, [sp, #12]
 8000988:	689b      	ldr	r3, [r3, #8]
 800098a:	1e5a      	subs	r2, r3, #1
 800098c:	9b03      	ldr	r3, [sp, #12]
 800098e:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8000990:	9b03      	ldr	r3, [sp, #12]
 8000992:	695b      	ldr	r3, [r3, #20]
 8000994:	1c59      	adds	r1, r3, #1
 8000996:	9a03      	ldr	r2, [sp, #12]
 8000998:	6151      	str	r1, [r2, #20]
 800099a:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800099e:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80009a0:	9b03      	ldr	r3, [sp, #12]
 80009a2:	695a      	ldr	r2, [r3, #20]
 80009a4:	9b03      	ldr	r3, [sp, #12]
 80009a6:	691b      	ldr	r3, [r3, #16]
 80009a8:	429a      	cmp	r2, r3
 80009aa:	d303      	bcc.n	80009b4 <oqPutTimeout+0x64>
    oqp->q_wrptr = oqp->q_buffer;
 80009ac:	9b03      	ldr	r3, [sp, #12]
 80009ae:	68da      	ldr	r2, [r3, #12]
 80009b0:	9b03      	ldr	r3, [sp, #12]
 80009b2:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80009b4:	9b03      	ldr	r3, [sp, #12]
 80009b6:	69db      	ldr	r3, [r3, #28]
 80009b8:	2b00      	cmp	r3, #0
 80009ba:	d003      	beq.n	80009c4 <oqPutTimeout+0x74>
    oqp->q_notify(oqp);
 80009bc:	9b03      	ldr	r3, [sp, #12]
 80009be:	69db      	ldr	r3, [r3, #28]
 80009c0:	9803      	ldr	r0, [sp, #12]
 80009c2:	4798      	blx	r3
  }

  osalSysUnlock();
 80009c4:	f7ff fd84 	bl	80004d0 <osalSysUnlock.lto_priv.1>

  return MSG_OK;
 80009c8:	2300      	movs	r3, #0
}
 80009ca:	4618      	mov	r0, r3
 80009cc:	b007      	add	sp, #28
 80009ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80009d2:	bf00      	nop
	...

080009e0 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 80009e0:	b500      	push	{lr}
 80009e2:	b085      	sub	sp, #20
 80009e4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 80009e6:	f002 fdc3 	bl	8003570 <chDbgCheckClassI>

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 80009ea:	9b01      	ldr	r3, [sp, #4]
 80009ec:	695a      	ldr	r2, [r3, #20]
 80009ee:	9b01      	ldr	r3, [sp, #4]
 80009f0:	699b      	ldr	r3, [r3, #24]
 80009f2:	429a      	cmp	r2, r3
 80009f4:	d105      	bne.n	8000a02 <oqGetI+0x22>
 80009f6:	9b01      	ldr	r3, [sp, #4]
 80009f8:	689b      	ldr	r3, [r3, #8]
 80009fa:	2b00      	cmp	r3, #0
 80009fc:	d001      	beq.n	8000a02 <oqGetI+0x22>
 80009fe:	2301      	movs	r3, #1
 8000a00:	e000      	b.n	8000a04 <oqGetI+0x24>
 8000a02:	2300      	movs	r3, #0
 8000a04:	f003 0301 	and.w	r3, r3, #1
 8000a08:	b2db      	uxtb	r3, r3
 8000a0a:	f083 0301 	eor.w	r3, r3, #1
 8000a0e:	b2db      	uxtb	r3, r3
 8000a10:	2b00      	cmp	r3, #0
 8000a12:	d01e      	beq.n	8000a52 <oqGetI+0x72>
    uint8_t b;

    oqp->q_counter++;
 8000a14:	9b01      	ldr	r3, [sp, #4]
 8000a16:	689b      	ldr	r3, [r3, #8]
 8000a18:	1c5a      	adds	r2, r3, #1
 8000a1a:	9b01      	ldr	r3, [sp, #4]
 8000a1c:	609a      	str	r2, [r3, #8]
    b = *oqp->q_rdptr++;
 8000a1e:	9b01      	ldr	r3, [sp, #4]
 8000a20:	699b      	ldr	r3, [r3, #24]
 8000a22:	1c59      	adds	r1, r3, #1
 8000a24:	9a01      	ldr	r2, [sp, #4]
 8000a26:	6191      	str	r1, [r2, #24]
 8000a28:	781b      	ldrb	r3, [r3, #0]
 8000a2a:	f88d 300f 	strb.w	r3, [sp, #15]
    if (oqp->q_rdptr >= oqp->q_top) {
 8000a2e:	9b01      	ldr	r3, [sp, #4]
 8000a30:	699a      	ldr	r2, [r3, #24]
 8000a32:	9b01      	ldr	r3, [sp, #4]
 8000a34:	691b      	ldr	r3, [r3, #16]
 8000a36:	429a      	cmp	r2, r3
 8000a38:	d303      	bcc.n	8000a42 <oqGetI+0x62>
      oqp->q_rdptr = oqp->q_buffer;
 8000a3a:	9b01      	ldr	r3, [sp, #4]
 8000a3c:	68da      	ldr	r2, [r3, #12]
 8000a3e:	9b01      	ldr	r3, [sp, #4]
 8000a40:	619a      	str	r2, [r3, #24]
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8000a42:	9b01      	ldr	r3, [sp, #4]
 8000a44:	2100      	movs	r1, #0
 8000a46:	4618      	mov	r0, r3
 8000a48:	f7ff fd6a 	bl	8000520 <osalThreadDequeueNextI.lto_priv.1>

    return (msg_t)b;
 8000a4c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8000a50:	e001      	b.n	8000a56 <oqGetI+0x76>
  }

  return MSG_TIMEOUT;
 8000a52:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
 8000a56:	4618      	mov	r0, r3
 8000a58:	b005      	add	sp, #20
 8000a5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a5e:	bf00      	nop

08000a60 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000a60:	b500      	push	{lr}
 8000a62:	b089      	sub	sp, #36	@ 0x24
 8000a64:	9003      	str	r0, [sp, #12]
 8000a66:	9102      	str	r1, [sp, #8]
 8000a68:	9201      	str	r2, [sp, #4]
 8000a6a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 8000a6c:	9b03      	ldr	r3, [sp, #12]
 8000a6e:	69db      	ldr	r3, [r3, #28]
 8000a70:	9307      	str	r3, [sp, #28]
  size_t max = n;
 8000a72:	9b01      	ldr	r3, [sp, #4]
 8000a74:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);
 8000a76:	9b01      	ldr	r3, [sp, #4]
 8000a78:	2b00      	cmp	r3, #0
 8000a7a:	bf0c      	ite	eq
 8000a7c:	2301      	moveq	r3, #1
 8000a7e:	2300      	movne	r3, #0
 8000a80:	b2db      	uxtb	r3, r3
 8000a82:	2b00      	cmp	r3, #0
 8000a84:	d002      	beq.n	8000a8c <oqWriteTimeout+0x2c>
 8000a86:	481b      	ldr	r0, [pc, #108]	@ (8000af4 <oqWriteTimeout+0x94>)
 8000a88:	f002 fbf2 	bl	8003270 <chSysHalt>

  osalSysLock();
 8000a8c:	f7ff fd18 	bl	80004c0 <osalSysLock.lto_priv.1>

  while (n > 0U) {
 8000a90:	e024      	b.n	8000adc <oqWriteTimeout+0x7c>
    size_t done;

    done = oq_write(oqp, bp, n);
 8000a92:	9a01      	ldr	r2, [sp, #4]
 8000a94:	9902      	ldr	r1, [sp, #8]
 8000a96:	9803      	ldr	r0, [sp, #12]
 8000a98:	f7ff fdc2 	bl	8000620 <oq_write>
 8000a9c:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 8000a9e:	9b05      	ldr	r3, [sp, #20]
 8000aa0:	2b00      	cmp	r3, #0
 8000aa2:	d109      	bne.n	8000ab8 <oqWriteTimeout+0x58>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000aa4:	9b03      	ldr	r3, [sp, #12]
 8000aa6:	9900      	ldr	r1, [sp, #0]
 8000aa8:	4618      	mov	r0, r3
 8000aaa:	f7ff fd29 	bl	8000500 <osalThreadEnqueueTimeoutS.lto_priv.1>
 8000aae:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8000ab0:	9b04      	ldr	r3, [sp, #16]
 8000ab2:	2b00      	cmp	r3, #0
 8000ab4:	d012      	beq.n	8000adc <oqWriteTimeout+0x7c>
        break;
 8000ab6:	e014      	b.n	8000ae2 <oqWriteTimeout+0x82>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8000ab8:	9b07      	ldr	r3, [sp, #28]
 8000aba:	2b00      	cmp	r3, #0
 8000abc:	d002      	beq.n	8000ac4 <oqWriteTimeout+0x64>
        nfy(oqp);
 8000abe:	9b07      	ldr	r3, [sp, #28]
 8000ac0:	9803      	ldr	r0, [sp, #12]
 8000ac2:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 8000ac4:	f7ff fd04 	bl	80004d0 <osalSysUnlock.lto_priv.1>

      n  -= done;
 8000ac8:	9a01      	ldr	r2, [sp, #4]
 8000aca:	9b05      	ldr	r3, [sp, #20]
 8000acc:	1ad3      	subs	r3, r2, r3
 8000ace:	9301      	str	r3, [sp, #4]
      bp += done;
 8000ad0:	9a02      	ldr	r2, [sp, #8]
 8000ad2:	9b05      	ldr	r3, [sp, #20]
 8000ad4:	4413      	add	r3, r2
 8000ad6:	9302      	str	r3, [sp, #8]

      osalSysLock();
 8000ad8:	f7ff fcf2 	bl	80004c0 <osalSysLock.lto_priv.1>
  while (n > 0U) {
 8000adc:	9b01      	ldr	r3, [sp, #4]
 8000ade:	2b00      	cmp	r3, #0
 8000ae0:	d1d7      	bne.n	8000a92 <oqWriteTimeout+0x32>
    }
  }

  osalSysUnlock();
 8000ae2:	f7ff fcf5 	bl	80004d0 <osalSysUnlock.lto_priv.1>
  return max - n;
 8000ae6:	9a06      	ldr	r2, [sp, #24]
 8000ae8:	9b01      	ldr	r3, [sp, #4]
 8000aea:	1ad3      	subs	r3, r2, r3
}
 8000aec:	4618      	mov	r0, r3
 8000aee:	b009      	add	sp, #36	@ 0x24
 8000af0:	f85d fb04 	ldr.w	pc, [sp], #4
 8000af4:	08005270 	.word	0x08005270
	...

08000b00 <chSysLock.lto_priv.2>:
static inline void chSysLock(void) {
 8000b00:	b500      	push	{lr}
 8000b02:	b083      	sub	sp, #12
 8000b04:	2330      	movs	r3, #48	@ 0x30
 8000b06:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000b08:	9b01      	ldr	r3, [sp, #4]
 8000b0a:	f383 8811 	msr	BASEPRI, r3
}
 8000b0e:	bf00      	nop
}
 8000b10:	bf00      	nop
  __dbg_check_lock();
 8000b12:	f002 fc15 	bl	8003340 <__dbg_check_lock>
}
 8000b16:	bf00      	nop
 8000b18:	b003      	add	sp, #12
 8000b1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b1e:	bf00      	nop

08000b20 <chSysUnlock.lto_priv.2>:
static inline void chSysUnlock(void) {
 8000b20:	b500      	push	{lr}
 8000b22:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8000b24:	f002 fc34 	bl	8003390 <__dbg_check_unlock>
 8000b28:	2300      	movs	r3, #0
 8000b2a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000b2c:	9b01      	ldr	r3, [sp, #4]
 8000b2e:	f383 8811 	msr	BASEPRI, r3
}
 8000b32:	bf00      	nop
}
 8000b34:	bf00      	nop
}
 8000b36:	bf00      	nop
 8000b38:	b003      	add	sp, #12
 8000b3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b3e:	bf00      	nop

08000b40 <osalSysLock.lto_priv.2>:
static inline void osalSysLock(void) {
 8000b40:	b508      	push	{r3, lr}
  chSysLock();
 8000b42:	f7ff ffdd 	bl	8000b00 <chSysLock.lto_priv.2>
}
 8000b46:	bf00      	nop
 8000b48:	bd08      	pop	{r3, pc}
 8000b4a:	bf00      	nop
 8000b4c:	0000      	movs	r0, r0
	...

08000b50 <osalSysUnlock.lto_priv.2>:
static inline void osalSysUnlock(void) {
 8000b50:	b508      	push	{r3, lr}
  chSysUnlock();
 8000b52:	f7ff ffe5 	bl	8000b20 <chSysUnlock.lto_priv.2>
}
 8000b56:	bf00      	nop
 8000b58:	bd08      	pop	{r3, pc}
 8000b5a:	bf00      	nop
 8000b5c:	0000      	movs	r0, r0
	...

08000b60 <osalThreadSuspendS>:
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8000b60:	b500      	push	{lr}
 8000b62:	b083      	sub	sp, #12
 8000b64:	9001      	str	r0, [sp, #4]
  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8000b66:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8000b6a:	9801      	ldr	r0, [sp, #4]
 8000b6c:	f003 fe58 	bl	8004820 <chThdSuspendTimeoutS>
 8000b70:	4603      	mov	r3, r0
}
 8000b72:	4618      	mov	r0, r3
 8000b74:	b003      	add	sp, #12
 8000b76:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b7a:	bf00      	nop
 8000b7c:	0000      	movs	r0, r0
	...

08000b80 <osalThreadResumeS>:
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 8000b80:	b500      	push	{lr}
 8000b82:	b083      	sub	sp, #12
 8000b84:	9001      	str	r0, [sp, #4]
 8000b86:	9100      	str	r1, [sp, #0]
  chThdResumeS(trp, msg);
 8000b88:	9900      	ldr	r1, [sp, #0]
 8000b8a:	9801      	ldr	r0, [sp, #4]
 8000b8c:	f003 fe88 	bl	80048a0 <chThdResumeS>
}
 8000b90:	bf00      	nop
 8000b92:	b003      	add	sp, #12
 8000b94:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000ba0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8000ba0:	b500      	push	{lr}
 8000ba2:	b083      	sub	sp, #12
 8000ba4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8000ba6:	9801      	ldr	r0, [sp, #4]
 8000ba8:	f003 ff5a 	bl	8004a60 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 8000bac:	bf00      	nop
 8000bae:	b003      	add	sp, #12
 8000bb0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000bc0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 8000bc0:	b508      	push	{r3, lr}

  adc_lld_init();
 8000bc2:	f001 fb4d 	bl	8002260 <adc_lld_init>
}
 8000bc6:	bf00      	nop
 8000bc8:	bd08      	pop	{r3, pc}
 8000bca:	bf00      	nop
 8000bcc:	0000      	movs	r0, r0
	...

08000bd0 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 8000bd0:	b500      	push	{lr}
 8000bd2:	b083      	sub	sp, #12
 8000bd4:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 8000bd6:	9b01      	ldr	r3, [sp, #4]
 8000bd8:	2201      	movs	r2, #1
 8000bda:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 8000bdc:	9b01      	ldr	r3, [sp, #4]
 8000bde:	2200      	movs	r2, #0
 8000be0:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 8000be2:	9b01      	ldr	r3, [sp, #4]
 8000be4:	2200      	movs	r2, #0
 8000be6:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 8000be8:	9b01      	ldr	r3, [sp, #4]
 8000bea:	2200      	movs	r2, #0
 8000bec:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 8000bee:	9b01      	ldr	r3, [sp, #4]
 8000bf0:	2200      	movs	r2, #0
 8000bf2:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8000bf4:	9b01      	ldr	r3, [sp, #4]
 8000bf6:	2200      	movs	r2, #0
 8000bf8:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 8000bfa:	9b01      	ldr	r3, [sp, #4]
 8000bfc:	3318      	adds	r3, #24
 8000bfe:	4618      	mov	r0, r3
 8000c00:	f7ff ffce 	bl	8000ba0 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 8000c04:	bf00      	nop
 8000c06:	b003      	add	sp, #12
 8000c08:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c0c:	0000      	movs	r0, r0
	...

08000c10 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8000c10:	b500      	push	{lr}
 8000c12:	b085      	sub	sp, #20
 8000c14:	9001      	str	r0, [sp, #4]
 8000c16:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(adcp != NULL);
 8000c18:	9b01      	ldr	r3, [sp, #4]
 8000c1a:	2b00      	cmp	r3, #0
 8000c1c:	bf0c      	ite	eq
 8000c1e:	2301      	moveq	r3, #1
 8000c20:	2300      	movne	r3, #0
 8000c22:	b2db      	uxtb	r3, r3
 8000c24:	2b00      	cmp	r3, #0
 8000c26:	d002      	beq.n	8000c2e <adcStart+0x1e>
 8000c28:	480e      	ldr	r0, [pc, #56]	@ (8000c64 <adcStart+0x54>)
 8000c2a:	f002 fb21 	bl	8003270 <chSysHalt>

  osalSysLock();
 8000c2e:	f7ff ff87 	bl	8000b40 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 8000c32:	9b01      	ldr	r3, [sp, #4]
 8000c34:	9a00      	ldr	r2, [sp, #0]
 8000c36:	605a      	str	r2, [r3, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
#else
  adc_lld_start(adcp);
 8000c38:	9801      	ldr	r0, [sp, #4]
 8000c3a:	f001 fb71 	bl	8002320 <adc_lld_start>
  msg = HAL_RET_SUCCESS;
 8000c3e:	2300      	movs	r3, #0
 8000c40:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 8000c42:	9b03      	ldr	r3, [sp, #12]
 8000c44:	2b00      	cmp	r3, #0
 8000c46:	d103      	bne.n	8000c50 <adcStart+0x40>
    adcp->state = ADC_READY;
 8000c48:	9b01      	ldr	r3, [sp, #4]
 8000c4a:	2202      	movs	r2, #2
 8000c4c:	701a      	strb	r2, [r3, #0]
 8000c4e:	e002      	b.n	8000c56 <adcStart+0x46>
  }
  else {
    adcp->state = ADC_STOP;
 8000c50:	9b01      	ldr	r3, [sp, #4]
 8000c52:	2201      	movs	r2, #1
 8000c54:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000c56:	f7ff ff7b 	bl	8000b50 <osalSysUnlock.lto_priv.2>

  return msg;
 8000c5a:	9b03      	ldr	r3, [sp, #12]
}
 8000c5c:	4618      	mov	r0, r3
 8000c5e:	b005      	add	sp, #20
 8000c60:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c64:	08005280 	.word	0x08005280
	...

08000c70 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 8000c70:	b500      	push	{lr}
 8000c72:	b085      	sub	sp, #20
 8000c74:	9003      	str	r0, [sp, #12]
 8000c76:	9102      	str	r1, [sp, #8]
 8000c78:	9201      	str	r2, [sp, #4]
 8000c7a:	9300      	str	r3, [sp, #0]

  osalSysLock();
 8000c7c:	f7ff ff60 	bl	8000b40 <osalSysLock.lto_priv.2>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000c80:	9b00      	ldr	r3, [sp, #0]
 8000c82:	9a01      	ldr	r2, [sp, #4]
 8000c84:	9902      	ldr	r1, [sp, #8]
 8000c86:	9803      	ldr	r0, [sp, #12]
 8000c88:	f000 f80a 	bl	8000ca0 <adcStartConversionI>
  osalSysUnlock();
 8000c8c:	f7ff ff60 	bl	8000b50 <osalSysUnlock.lto_priv.2>
}
 8000c90:	bf00      	nop
 8000c92:	b005      	add	sp, #20
 8000c94:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000ca0 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
 8000ca0:	b500      	push	{lr}
 8000ca2:	b085      	sub	sp, #20
 8000ca4:	9003      	str	r0, [sp, #12]
 8000ca6:	9102      	str	r1, [sp, #8]
 8000ca8:	9201      	str	r2, [sp, #4]
 8000caa:	9300      	str	r3, [sp, #0]

  osalDbgCheckClassI();
 8000cac:	f002 fc60 	bl	8003570 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
 8000cb0:	9b03      	ldr	r3, [sp, #12]
 8000cb2:	2b00      	cmp	r3, #0
 8000cb4:	bf0c      	ite	eq
 8000cb6:	2301      	moveq	r3, #1
 8000cb8:	2300      	movne	r3, #0
 8000cba:	b2db      	uxtb	r3, r3
 8000cbc:	2b00      	cmp	r3, #0
 8000cbe:	d107      	bne.n	8000cd0 <adcStartConversionI+0x30>
 8000cc0:	9b02      	ldr	r3, [sp, #8]
 8000cc2:	2b00      	cmp	r3, #0
 8000cc4:	bf0c      	ite	eq
 8000cc6:	2301      	moveq	r3, #1
 8000cc8:	2300      	movne	r3, #0
 8000cca:	b2db      	uxtb	r3, r3
 8000ccc:	2b00      	cmp	r3, #0
 8000cce:	d001      	beq.n	8000cd4 <adcStartConversionI+0x34>
 8000cd0:	2301      	movs	r3, #1
 8000cd2:	e000      	b.n	8000cd6 <adcStartConversionI+0x36>
 8000cd4:	2300      	movs	r3, #0
 8000cd6:	2b00      	cmp	r3, #0
 8000cd8:	d107      	bne.n	8000cea <adcStartConversionI+0x4a>
 8000cda:	9b01      	ldr	r3, [sp, #4]
 8000cdc:	2b00      	cmp	r3, #0
 8000cde:	bf0c      	ite	eq
 8000ce0:	2301      	moveq	r3, #1
 8000ce2:	2300      	movne	r3, #0
 8000ce4:	b2db      	uxtb	r3, r3
 8000ce6:	2b00      	cmp	r3, #0
 8000ce8:	d001      	beq.n	8000cee <adcStartConversionI+0x4e>
 8000cea:	2301      	movs	r3, #1
 8000cec:	e000      	b.n	8000cf0 <adcStartConversionI+0x50>
 8000cee:	2300      	movs	r3, #0
 8000cf0:	2b00      	cmp	r3, #0
 8000cf2:	d107      	bne.n	8000d04 <adcStartConversionI+0x64>
 8000cf4:	9b00      	ldr	r3, [sp, #0]
 8000cf6:	2b00      	cmp	r3, #0
 8000cf8:	bf0c      	ite	eq
 8000cfa:	2301      	moveq	r3, #1
 8000cfc:	2300      	movne	r3, #0
 8000cfe:	b2db      	uxtb	r3, r3
 8000d00:	2b00      	cmp	r3, #0
 8000d02:	d001      	beq.n	8000d08 <adcStartConversionI+0x68>
 8000d04:	2301      	movs	r3, #1
 8000d06:	e000      	b.n	8000d0a <adcStartConversionI+0x6a>
 8000d08:	2300      	movs	r3, #0
 8000d0a:	2b00      	cmp	r3, #0
 8000d0c:	d111      	bne.n	8000d32 <adcStartConversionI+0x92>
 8000d0e:	9b00      	ldr	r3, [sp, #0]
 8000d10:	2b01      	cmp	r3, #1
 8000d12:	bf14      	ite	ne
 8000d14:	2301      	movne	r3, #1
 8000d16:	2300      	moveq	r3, #0
 8000d18:	b2db      	uxtb	r3, r3
 8000d1a:	2b00      	cmp	r3, #0
 8000d1c:	d006      	beq.n	8000d2c <adcStartConversionI+0x8c>
 8000d1e:	9b00      	ldr	r3, [sp, #0]
 8000d20:	f003 0301 	and.w	r3, r3, #1
 8000d24:	2b00      	cmp	r3, #0
 8000d26:	d001      	beq.n	8000d2c <adcStartConversionI+0x8c>
 8000d28:	2301      	movs	r3, #1
 8000d2a:	e000      	b.n	8000d2e <adcStartConversionI+0x8e>
 8000d2c:	2300      	movs	r3, #0
 8000d2e:	2b00      	cmp	r3, #0
 8000d30:	d002      	beq.n	8000d38 <adcStartConversionI+0x98>
 8000d32:	480b      	ldr	r0, [pc, #44]	@ (8000d60 <adcStartConversionI+0xc0>)
 8000d34:	f002 fa9c 	bl	8003270 <chSysHalt>
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 8000d38:	9b03      	ldr	r3, [sp, #12]
 8000d3a:	9a01      	ldr	r2, [sp, #4]
 8000d3c:	609a      	str	r2, [r3, #8]
  adcp->depth    = depth;
 8000d3e:	9b03      	ldr	r3, [sp, #12]
 8000d40:	9a00      	ldr	r2, [sp, #0]
 8000d42:	60da      	str	r2, [r3, #12]
  adcp->grpp     = grpp;
 8000d44:	9b03      	ldr	r3, [sp, #12]
 8000d46:	9a02      	ldr	r2, [sp, #8]
 8000d48:	611a      	str	r2, [r3, #16]
  adcp->state    = ADC_ACTIVE;
 8000d4a:	9b03      	ldr	r3, [sp, #12]
 8000d4c:	2203      	movs	r2, #3
 8000d4e:	701a      	strb	r2, [r3, #0]
  adc_lld_start_conversion(adcp);
 8000d50:	9803      	ldr	r0, [sp, #12]
 8000d52:	f001 fb45 	bl	80023e0 <adc_lld_start_conversion>
}
 8000d56:	bf00      	nop
 8000d58:	b005      	add	sp, #20
 8000d5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d5e:	bf00      	nop
 8000d60:	0800528c 	.word	0x0800528c
	...

08000d70 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
 8000d70:	b500      	push	{lr}
 8000d72:	b083      	sub	sp, #12
 8000d74:	9001      	str	r0, [sp, #4]

  osalDbgCheck(adcp != NULL);
 8000d76:	9b01      	ldr	r3, [sp, #4]
 8000d78:	2b00      	cmp	r3, #0
 8000d7a:	bf0c      	ite	eq
 8000d7c:	2301      	moveq	r3, #1
 8000d7e:	2300      	movne	r3, #0
 8000d80:	b2db      	uxtb	r3, r3
 8000d82:	2b00      	cmp	r3, #0
 8000d84:	d002      	beq.n	8000d8c <adcStopConversion+0x1c>
 8000d86:	480f      	ldr	r0, [pc, #60]	@ (8000dc4 <adcStopConversion+0x54>)
 8000d88:	f002 fa72 	bl	8003270 <chSysHalt>

  osalSysLock();
 8000d8c:	f7ff fed8 	bl	8000b40 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_READY) || (adcp->state == ADC_ACTIVE),
                "invalid state");
  if (adcp->state != ADC_READY) {
 8000d90:	9b01      	ldr	r3, [sp, #4]
 8000d92:	781b      	ldrb	r3, [r3, #0]
 8000d94:	2b02      	cmp	r3, #2
 8000d96:	d00f      	beq.n	8000db8 <adcStopConversion+0x48>
    adc_lld_stop_conversion(adcp);
 8000d98:	9801      	ldr	r0, [sp, #4]
 8000d9a:	f001 fbc9 	bl	8002530 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
 8000d9e:	9b01      	ldr	r3, [sp, #4]
 8000da0:	2200      	movs	r2, #0
 8000da2:	611a      	str	r2, [r3, #16]
    adcp->state = ADC_READY;
 8000da4:	9b01      	ldr	r3, [sp, #4]
 8000da6:	2202      	movs	r2, #2
 8000da8:	701a      	strb	r2, [r3, #0]
    _adc_reset_s(adcp);
 8000daa:	9b01      	ldr	r3, [sp, #4]
 8000dac:	3314      	adds	r3, #20
 8000dae:	f06f 0101 	mvn.w	r1, #1
 8000db2:	4618      	mov	r0, r3
 8000db4:	f7ff fee4 	bl	8000b80 <osalThreadResumeS>
  }
  osalSysUnlock();
 8000db8:	f7ff feca 	bl	8000b50 <osalSysUnlock.lto_priv.2>
}
 8000dbc:	bf00      	nop
 8000dbe:	b003      	add	sp, #12
 8000dc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8000dc4:	080052a0 	.word	0x080052a0
	...

08000dd0 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8000dd0:	b500      	push	{lr}
 8000dd2:	b087      	sub	sp, #28
 8000dd4:	9003      	str	r0, [sp, #12]
 8000dd6:	9102      	str	r1, [sp, #8]
 8000dd8:	9201      	str	r2, [sp, #4]
 8000dda:	9300      	str	r3, [sp, #0]
  msg_t msg;

  osalSysLock();
 8000ddc:	f7ff feb0 	bl	8000b40 <osalSysLock.lto_priv.2>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
  adcStartConversionI(adcp, grpp, samples, depth);
 8000de0:	9b00      	ldr	r3, [sp, #0]
 8000de2:	9a01      	ldr	r2, [sp, #4]
 8000de4:	9902      	ldr	r1, [sp, #8]
 8000de6:	9803      	ldr	r0, [sp, #12]
 8000de8:	f7ff ff5a 	bl	8000ca0 <adcStartConversionI>
  msg = osalThreadSuspendS(&adcp->thread);
 8000dec:	9b03      	ldr	r3, [sp, #12]
 8000dee:	3314      	adds	r3, #20
 8000df0:	4618      	mov	r0, r3
 8000df2:	f7ff feb5 	bl	8000b60 <osalThreadSuspendS>
 8000df6:	9005      	str	r0, [sp, #20]
  osalSysUnlock();
 8000df8:	f7ff feaa 	bl	8000b50 <osalSysUnlock.lto_priv.2>
  return msg;
 8000dfc:	9b05      	ldr	r3, [sp, #20]
}
 8000dfe:	4618      	mov	r0, r3
 8000e00:	b007      	add	sp, #28
 8000e02:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e06:	bf00      	nop
	...

08000e10 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
 8000e10:	b500      	push	{lr}
 8000e12:	b083      	sub	sp, #12
 8000e14:	2330      	movs	r3, #48	@ 0x30
 8000e16:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000e18:	9b01      	ldr	r3, [sp, #4]
 8000e1a:	f383 8811 	msr	BASEPRI, r3
}
 8000e1e:	bf00      	nop
}
 8000e20:	bf00      	nop
  __dbg_check_lock();
 8000e22:	f002 fa8d 	bl	8003340 <__dbg_check_lock>
}
 8000e26:	bf00      	nop
 8000e28:	b003      	add	sp, #12
 8000e2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e2e:	bf00      	nop

08000e30 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
 8000e30:	b500      	push	{lr}
 8000e32:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8000e34:	f002 faac 	bl	8003390 <__dbg_check_unlock>
 8000e38:	2300      	movs	r3, #0
 8000e3a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000e3c:	9b01      	ldr	r3, [sp, #4]
 8000e3e:	f383 8811 	msr	BASEPRI, r3
}
 8000e42:	bf00      	nop
}
 8000e44:	bf00      	nop
}
 8000e46:	bf00      	nop
 8000e48:	b003      	add	sp, #12
 8000e4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e4e:	bf00      	nop

08000e50 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
 8000e50:	b508      	push	{r3, lr}
  chSysLock();
 8000e52:	f7ff ffdd 	bl	8000e10 <chSysLock.lto_priv.3>
}
 8000e56:	bf00      	nop
 8000e58:	bd08      	pop	{r3, pc}
 8000e5a:	bf00      	nop
 8000e5c:	0000      	movs	r0, r0
	...

08000e60 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
 8000e60:	b508      	push	{r3, lr}
  chSysUnlock();
 8000e62:	f7ff ffe5 	bl	8000e30 <chSysUnlock.lto_priv.3>
}
 8000e66:	bf00      	nop
 8000e68:	bd08      	pop	{r3, pc}
 8000e6a:	bf00      	nop
 8000e6c:	0000      	movs	r0, r0
	...

08000e70 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8000e70:	b508      	push	{r3, lr}

  gpt_lld_init();
 8000e72:	f001 feb5 	bl	8002be0 <gpt_lld_init>
}
 8000e76:	bf00      	nop
 8000e78:	bd08      	pop	{r3, pc}
 8000e7a:	bf00      	nop
 8000e7c:	0000      	movs	r0, r0
	...

08000e80 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8000e80:	b082      	sub	sp, #8
 8000e82:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 8000e84:	9b01      	ldr	r3, [sp, #4]
 8000e86:	2201      	movs	r2, #1
 8000e88:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 8000e8a:	9b01      	ldr	r3, [sp, #4]
 8000e8c:	2200      	movs	r2, #0
 8000e8e:	605a      	str	r2, [r3, #4]
}
 8000e90:	bf00      	nop
 8000e92:	b002      	add	sp, #8
 8000e94:	4770      	bx	lr
 8000e96:	bf00      	nop
	...

08000ea0 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8000ea0:	b500      	push	{lr}
 8000ea2:	b085      	sub	sp, #20
 8000ea4:	9001      	str	r0, [sp, #4]
 8000ea6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 8000ea8:	9b01      	ldr	r3, [sp, #4]
 8000eaa:	2b00      	cmp	r3, #0
 8000eac:	bf0c      	ite	eq
 8000eae:	2301      	moveq	r3, #1
 8000eb0:	2300      	movne	r3, #0
 8000eb2:	b2db      	uxtb	r3, r3
 8000eb4:	2b00      	cmp	r3, #0
 8000eb6:	d107      	bne.n	8000ec8 <gptStart+0x28>
 8000eb8:	9b00      	ldr	r3, [sp, #0]
 8000eba:	2b00      	cmp	r3, #0
 8000ebc:	bf0c      	ite	eq
 8000ebe:	2301      	moveq	r3, #1
 8000ec0:	2300      	movne	r3, #0
 8000ec2:	b2db      	uxtb	r3, r3
 8000ec4:	2b00      	cmp	r3, #0
 8000ec6:	d002      	beq.n	8000ece <gptStart+0x2e>
 8000ec8:	480e      	ldr	r0, [pc, #56]	@ (8000f04 <gptStart+0x64>)
 8000eca:	f002 f9d1 	bl	8003270 <chSysHalt>

  osalSysLock();
 8000ece:	f7ff ffbf 	bl	8000e50 <osalSysLock.lto_priv.3>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");

  gptp->config = config;
 8000ed2:	9b01      	ldr	r3, [sp, #4]
 8000ed4:	9a00      	ldr	r2, [sp, #0]
 8000ed6:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 8000ed8:	9801      	ldr	r0, [sp, #4]
 8000eda:	f001 fe91 	bl	8002c00 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 8000ede:	2300      	movs	r3, #0
 8000ee0:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 8000ee2:	9b03      	ldr	r3, [sp, #12]
 8000ee4:	2b00      	cmp	r3, #0
 8000ee6:	d103      	bne.n	8000ef0 <gptStart+0x50>
    gptp->state = GPT_READY;
 8000ee8:	9b01      	ldr	r3, [sp, #4]
 8000eea:	2202      	movs	r2, #2
 8000eec:	701a      	strb	r2, [r3, #0]
 8000eee:	e002      	b.n	8000ef6 <gptStart+0x56>
  }
  else {
    gptp->state = GPT_STOP;
 8000ef0:	9b01      	ldr	r3, [sp, #4]
 8000ef2:	2201      	movs	r2, #1
 8000ef4:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000ef6:	f7ff ffb3 	bl	8000e60 <osalSysUnlock.lto_priv.3>

  return msg;
 8000efa:	9b03      	ldr	r3, [sp, #12]
}
 8000efc:	4618      	mov	r0, r3
 8000efe:	b005      	add	sp, #20
 8000f00:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f04:	080052b4 	.word	0x080052b4
	...

08000f10 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 8000f10:	b500      	push	{lr}
 8000f12:	b083      	sub	sp, #12
 8000f14:	9001      	str	r0, [sp, #4]
 8000f16:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8000f18:	f7ff ff9a 	bl	8000e50 <osalSysLock.lto_priv.3>
  gptStartContinuousI(gptp, interval);
 8000f1c:	9900      	ldr	r1, [sp, #0]
 8000f1e:	9801      	ldr	r0, [sp, #4]
 8000f20:	f000 f806 	bl	8000f30 <gptStartContinuousI>
  osalSysUnlock();
 8000f24:	f7ff ff9c 	bl	8000e60 <osalSysUnlock.lto_priv.3>
}
 8000f28:	bf00      	nop
 8000f2a:	b003      	add	sp, #12
 8000f2c:	f85d fb04 	ldr.w	pc, [sp], #4

08000f30 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 8000f30:	b500      	push	{lr}
 8000f32:	b083      	sub	sp, #12
 8000f34:	9001      	str	r0, [sp, #4]
 8000f36:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8000f38:	f002 fb1a 	bl	8003570 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000f3c:	9b01      	ldr	r3, [sp, #4]
 8000f3e:	2b00      	cmp	r3, #0
 8000f40:	bf0c      	ite	eq
 8000f42:	2301      	moveq	r3, #1
 8000f44:	2300      	movne	r3, #0
 8000f46:	b2db      	uxtb	r3, r3
 8000f48:	2b00      	cmp	r3, #0
 8000f4a:	d002      	beq.n	8000f52 <gptStartContinuousI+0x22>
 8000f4c:	4806      	ldr	r0, [pc, #24]	@ (8000f68 <gptStartContinuousI+0x38>)
 8000f4e:	f002 f98f 	bl	8003270 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000f52:	9b01      	ldr	r3, [sp, #4]
 8000f54:	2203      	movs	r2, #3
 8000f56:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 8000f58:	9900      	ldr	r1, [sp, #0]
 8000f5a:	9801      	ldr	r0, [sp, #4]
 8000f5c:	f001 feb8 	bl	8002cd0 <gpt_lld_start_timer>
}
 8000f60:	bf00      	nop
 8000f62:	b003      	add	sp, #12
 8000f64:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f68:	080052c0 	.word	0x080052c0
 8000f6c:	00000000 	.word	0x00000000

08000f70 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000f70:	b500      	push	{lr}
 8000f72:	b083      	sub	sp, #12
 8000f74:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8000f76:	f7ff ff6b 	bl	8000e50 <osalSysLock.lto_priv.3>
  gptStopTimerI(gptp);
 8000f7a:	9801      	ldr	r0, [sp, #4]
 8000f7c:	f000 f808 	bl	8000f90 <gptStopTimerI>
  osalSysUnlock();
 8000f80:	f7ff ff6e 	bl	8000e60 <osalSysUnlock.lto_priv.3>
}
 8000f84:	bf00      	nop
 8000f86:	b003      	add	sp, #12
 8000f88:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f8c:	0000      	movs	r0, r0
	...

08000f90 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000f90:	b500      	push	{lr}
 8000f92:	b083      	sub	sp, #12
 8000f94:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8000f96:	f002 faeb 	bl	8003570 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000f9a:	9b01      	ldr	r3, [sp, #4]
 8000f9c:	2b00      	cmp	r3, #0
 8000f9e:	bf0c      	ite	eq
 8000fa0:	2301      	moveq	r3, #1
 8000fa2:	2300      	movne	r3, #0
 8000fa4:	b2db      	uxtb	r3, r3
 8000fa6:	2b00      	cmp	r3, #0
 8000fa8:	d002      	beq.n	8000fb0 <gptStopTimerI+0x20>
 8000faa:	4806      	ldr	r0, [pc, #24]	@ (8000fc4 <gptStopTimerI+0x34>)
 8000fac:	f002 f960 	bl	8003270 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000fb0:	9b01      	ldr	r3, [sp, #4]
 8000fb2:	2202      	movs	r2, #2
 8000fb4:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000fb6:	9801      	ldr	r0, [sp, #4]
 8000fb8:	f001 feb2 	bl	8002d20 <gpt_lld_stop_timer>
}
 8000fbc:	bf00      	nop
 8000fbe:	b003      	add	sp, #12
 8000fc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8000fc4:	080052d4 	.word	0x080052d4
	...

08000fd0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8000fd0:	b082      	sub	sp, #8
 8000fd2:	9001      	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
 8000fd4:	9b01      	ldr	r3, [sp, #4]
 8000fd6:	9a01      	ldr	r2, [sp, #4]
 8000fd8:	601a      	str	r2, [r3, #0]
}
 8000fda:	bf00      	nop
 8000fdc:	b002      	add	sp, #8
 8000fde:	4770      	bx	lr

08000fe0 <osalEventObjectInit>:
static inline void osalEventObjectInit(event_source_t *esp) {
 8000fe0:	b500      	push	{lr}
 8000fe2:	b083      	sub	sp, #12
 8000fe4:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 8000fe6:	9801      	ldr	r0, [sp, #4]
 8000fe8:	f7ff fff2 	bl	8000fd0 <chEvtObjectInit>
}
 8000fec:	bf00      	nop
 8000fee:	b003      	add	sp, #12
 8000ff0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001000 <osalEventBroadcastFlagsI.lto_priv.1>:
                                            eventflags_t flags) {
 8001000:	b500      	push	{lr}
 8001002:	b083      	sub	sp, #12
 8001004:	9001      	str	r0, [sp, #4]
 8001006:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 8001008:	9900      	ldr	r1, [sp, #0]
 800100a:	9801      	ldr	r0, [sp, #4]
 800100c:	f003 fd88 	bl	8004b20 <chEvtBroadcastFlagsI>
}
 8001010:	bf00      	nop
 8001012:	b003      	add	sp, #12
 8001014:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001020 <_write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8001020:	b500      	push	{lr}
 8001022:	b085      	sub	sp, #20
 8001024:	9003      	str	r0, [sp, #12]
 8001026:	9102      	str	r1, [sp, #8]
 8001028:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800102a:	9b03      	ldr	r3, [sp, #12]
 800102c:	f103 0030 	add.w	r0, r3, #48	@ 0x30
 8001030:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8001034:	9a01      	ldr	r2, [sp, #4]
 8001036:	9902      	ldr	r1, [sp, #8]
 8001038:	f7ff fd12 	bl	8000a60 <oqWriteTimeout>
 800103c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800103e:	4618      	mov	r0, r3
 8001040:	b005      	add	sp, #20
 8001042:	f85d fb04 	ldr.w	pc, [sp], #4
 8001046:	bf00      	nop
	...

08001050 <_read>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8001050:	b500      	push	{lr}
 8001052:	b085      	sub	sp, #20
 8001054:	9003      	str	r0, [sp, #12]
 8001056:	9102      	str	r1, [sp, #8]
 8001058:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800105a:	9b03      	ldr	r3, [sp, #12]
 800105c:	f103 000c 	add.w	r0, r3, #12
 8001060:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8001064:	9a01      	ldr	r2, [sp, #4]
 8001066:	9902      	ldr	r1, [sp, #8]
 8001068:	f7ff fbfa 	bl	8000860 <iqReadTimeout>
 800106c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800106e:	4618      	mov	r0, r3
 8001070:	b005      	add	sp, #20
 8001072:	f85d fb04 	ldr.w	pc, [sp], #4
 8001076:	bf00      	nop
	...

08001080 <_put>:

static msg_t _put(void *ip, uint8_t b) {
 8001080:	b500      	push	{lr}
 8001082:	b083      	sub	sp, #12
 8001084:	9001      	str	r0, [sp, #4]
 8001086:	460b      	mov	r3, r1
 8001088:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800108c:	9b01      	ldr	r3, [sp, #4]
 800108e:	3330      	adds	r3, #48	@ 0x30
 8001090:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8001094:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001098:	4618      	mov	r0, r3
 800109a:	f7ff fc59 	bl	8000950 <oqPutTimeout>
 800109e:	4603      	mov	r3, r0
}
 80010a0:	4618      	mov	r0, r3
 80010a2:	b003      	add	sp, #12
 80010a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080010b0 <_get>:

static msg_t _get(void *ip) {
 80010b0:	b500      	push	{lr}
 80010b2:	b083      	sub	sp, #12
 80010b4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80010b6:	9b01      	ldr	r3, [sp, #4]
 80010b8:	330c      	adds	r3, #12
 80010ba:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 80010be:	4618      	mov	r0, r3
 80010c0:	f7ff fb8e 	bl	80007e0 <iqGetTimeout>
 80010c4:	4603      	mov	r3, r0
}
 80010c6:	4618      	mov	r0, r3
 80010c8:	b003      	add	sp, #12
 80010ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80010ce:	bf00      	nop

080010d0 <_putt>:

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 80010d0:	b500      	push	{lr}
 80010d2:	b085      	sub	sp, #20
 80010d4:	9003      	str	r0, [sp, #12]
 80010d6:	460b      	mov	r3, r1
 80010d8:	9201      	str	r2, [sp, #4]
 80010da:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80010de:	9b03      	ldr	r3, [sp, #12]
 80010e0:	3330      	adds	r3, #48	@ 0x30
 80010e2:	f89d 100b 	ldrb.w	r1, [sp, #11]
 80010e6:	9a01      	ldr	r2, [sp, #4]
 80010e8:	4618      	mov	r0, r3
 80010ea:	f7ff fc31 	bl	8000950 <oqPutTimeout>
 80010ee:	4603      	mov	r3, r0
}
 80010f0:	4618      	mov	r0, r3
 80010f2:	b005      	add	sp, #20
 80010f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001100 <_gett>:

static msg_t _gett(void *ip, sysinterval_t timeout) {
 8001100:	b500      	push	{lr}
 8001102:	b083      	sub	sp, #12
 8001104:	9001      	str	r0, [sp, #4]
 8001106:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001108:	9b01      	ldr	r3, [sp, #4]
 800110a:	330c      	adds	r3, #12
 800110c:	9900      	ldr	r1, [sp, #0]
 800110e:	4618      	mov	r0, r3
 8001110:	f7ff fb66 	bl	80007e0 <iqGetTimeout>
 8001114:	4603      	mov	r3, r0
}
 8001116:	4618      	mov	r0, r3
 8001118:	b003      	add	sp, #12
 800111a:	f85d fb04 	ldr.w	pc, [sp], #4
 800111e:	bf00      	nop

08001120 <_writet>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
 8001120:	b500      	push	{lr}
 8001122:	b085      	sub	sp, #20
 8001124:	9003      	str	r0, [sp, #12]
 8001126:	9102      	str	r1, [sp, #8]
 8001128:	9201      	str	r2, [sp, #4]
 800112a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800112c:	9b03      	ldr	r3, [sp, #12]
 800112e:	f103 0030 	add.w	r0, r3, #48	@ 0x30
 8001132:	9b00      	ldr	r3, [sp, #0]
 8001134:	9a01      	ldr	r2, [sp, #4]
 8001136:	9902      	ldr	r1, [sp, #8]
 8001138:	f7ff fc92 	bl	8000a60 <oqWriteTimeout>
 800113c:	4603      	mov	r3, r0
}
 800113e:	4618      	mov	r0, r3
 8001140:	b005      	add	sp, #20
 8001142:	f85d fb04 	ldr.w	pc, [sp], #4
 8001146:	bf00      	nop
	...

08001150 <_readt>:

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
 8001150:	b500      	push	{lr}
 8001152:	b085      	sub	sp, #20
 8001154:	9003      	str	r0, [sp, #12]
 8001156:	9102      	str	r1, [sp, #8]
 8001158:	9201      	str	r2, [sp, #4]
 800115a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800115c:	9b03      	ldr	r3, [sp, #12]
 800115e:	f103 000c 	add.w	r0, r3, #12
 8001162:	9b00      	ldr	r3, [sp, #0]
 8001164:	9a01      	ldr	r2, [sp, #4]
 8001166:	9902      	ldr	r1, [sp, #8]
 8001168:	f7ff fb7a 	bl	8000860 <iqReadTimeout>
 800116c:	4603      	mov	r3, r0
}
 800116e:	4618      	mov	r0, r3
 8001170:	b005      	add	sp, #20
 8001172:	f85d fb04 	ldr.w	pc, [sp], #4
 8001176:	bf00      	nop
	...

08001180 <_ctl>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 8001180:	b500      	push	{lr}
 8001182:	b087      	sub	sp, #28
 8001184:	9003      	str	r0, [sp, #12]
 8001186:	9102      	str	r1, [sp, #8]
 8001188:	9201      	str	r2, [sp, #4]
  SerialDriver *sdp = (SerialDriver *)ip;
 800118a:	9b03      	ldr	r3, [sp, #12]
 800118c:	9305      	str	r3, [sp, #20]

  osalDbgCheck(sdp != NULL);
 800118e:	9b05      	ldr	r3, [sp, #20]
 8001190:	2b00      	cmp	r3, #0
 8001192:	bf0c      	ite	eq
 8001194:	2301      	moveq	r3, #1
 8001196:	2300      	movne	r3, #0
 8001198:	b2db      	uxtb	r3, r3
 800119a:	2b00      	cmp	r3, #0
 800119c:	d002      	beq.n	80011a4 <_ctl+0x24>
 800119e:	4810      	ldr	r0, [pc, #64]	@ (80011e0 <_ctl+0x60>)
 80011a0:	f002 f866 	bl	8003270 <chSysHalt>

  switch (operation) {
 80011a4:	9b02      	ldr	r3, [sp, #8]
 80011a6:	2b00      	cmp	r3, #0
 80011a8:	d00e      	beq.n	80011c8 <_ctl+0x48>
 80011aa:	9b02      	ldr	r3, [sp, #8]
 80011ac:	2b01      	cmp	r3, #1
 80011ae:	d10e      	bne.n	80011ce <_ctl+0x4e>
  case CHN_CTL_NOP:
    osalDbgCheck(arg == NULL);
 80011b0:	9b01      	ldr	r3, [sp, #4]
 80011b2:	2b00      	cmp	r3, #0
 80011b4:	bf14      	ite	ne
 80011b6:	2301      	movne	r3, #1
 80011b8:	2300      	moveq	r3, #0
 80011ba:	b2db      	uxtb	r3, r3
 80011bc:	2b00      	cmp	r3, #0
 80011be:	d009      	beq.n	80011d4 <_ctl+0x54>
 80011c0:	4807      	ldr	r0, [pc, #28]	@ (80011e0 <_ctl+0x60>)
 80011c2:	f002 f855 	bl	8003270 <chSysHalt>
    break;
 80011c6:	e005      	b.n	80011d4 <_ctl+0x54>
  case CHN_CTL_INVALID:
    return HAL_RET_UNKNOWN_CTL;
 80011c8:	f06f 0313 	mvn.w	r3, #19
 80011cc:	e004      	b.n	80011d8 <_ctl+0x58>
  default:
#if defined(SD_LLD_IMPLEMENTS_CTL)
    /* Delegating to the LLD if supported.*/
    return sd_lld_control(sdp, operation, arg);
#else
    return HAL_RET_UNKNOWN_CTL;
 80011ce:	f06f 0313 	mvn.w	r3, #19
 80011d2:	e001      	b.n	80011d8 <_ctl+0x58>
    break;
 80011d4:	bf00      	nop
#endif
  }
  return HAL_RET_SUCCESS;
 80011d6:	2300      	movs	r3, #0
}
 80011d8:	4618      	mov	r0, r3
 80011da:	b007      	add	sp, #28
 80011dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80011e0:	0800530c 	.word	0x0800530c
	...

080011f0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80011f0:	b508      	push	{r3, lr}

  sd_lld_init();
 80011f2:	f001 fe65 	bl	8002ec0 <sd_lld_init>
}
 80011f6:	bf00      	nop
 80011f8:	bd08      	pop	{r3, pc}
 80011fa:	bf00      	nop
 80011fc:	0000      	movs	r0, r0
	...

08001200 <sdObjectInit>:
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {
 8001200:	b500      	push	{lr}
 8001202:	b083      	sub	sp, #12
 8001204:	9001      	str	r0, [sp, #4]

  sdp->vmt = &vmt;
 8001206:	9b01      	ldr	r3, [sp, #4]
 8001208:	4a06      	ldr	r2, [pc, #24]	@ (8001224 <sdObjectInit+0x24>)
 800120a:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 800120c:	9b01      	ldr	r3, [sp, #4]
 800120e:	3304      	adds	r3, #4
 8001210:	4618      	mov	r0, r3
 8001212:	f7ff fee5 	bl	8000fe0 <osalEventObjectInit>
  sdp->state = SD_STOP;
 8001216:	9b01      	ldr	r3, [sp, #4]
 8001218:	2201      	movs	r2, #1
 800121a:	721a      	strb	r2, [r3, #8]
}
 800121c:	bf00      	nop
 800121e:	b003      	add	sp, #12
 8001220:	f85d fb04 	ldr.w	pc, [sp], #4
 8001224:	080052e4 	.word	0x080052e4
	...

08001230 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001230:	b500      	push	{lr}
 8001232:	b083      	sub	sp, #12
 8001234:	9001      	str	r0, [sp, #4]
 8001236:	460b      	mov	r3, r1
 8001238:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 800123c:	f002 f998 	bl	8003570 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8001240:	9b01      	ldr	r3, [sp, #4]
 8001242:	2b00      	cmp	r3, #0
 8001244:	bf0c      	ite	eq
 8001246:	2301      	moveq	r3, #1
 8001248:	2300      	movne	r3, #0
 800124a:	b2db      	uxtb	r3, r3
 800124c:	2b00      	cmp	r3, #0
 800124e:	d002      	beq.n	8001256 <sdIncomingDataI+0x26>
 8001250:	4811      	ldr	r0, [pc, #68]	@ (8001298 <sdIncomingDataI+0x68>)
 8001252:	f002 f80d 	bl	8003270 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 8001256:	9b01      	ldr	r3, [sp, #4]
 8001258:	695b      	ldr	r3, [r3, #20]
 800125a:	2b00      	cmp	r3, #0
 800125c:	d105      	bne.n	800126a <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800125e:	9b01      	ldr	r3, [sp, #4]
 8001260:	3304      	adds	r3, #4
 8001262:	2104      	movs	r1, #4
 8001264:	4618      	mov	r0, r3
 8001266:	f7ff fecb 	bl	8001000 <osalEventBroadcastFlagsI.lto_priv.1>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 800126a:	9b01      	ldr	r3, [sp, #4]
 800126c:	330c      	adds	r3, #12
 800126e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001272:	4611      	mov	r1, r2
 8001274:	4618      	mov	r0, r3
 8001276:	f7ff fa6b 	bl	8000750 <iqPutI>
 800127a:	4603      	mov	r3, r0
 800127c:	2b00      	cmp	r3, #0
 800127e:	da06      	bge.n	800128e <sdIncomingDataI+0x5e>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 8001280:	9b01      	ldr	r3, [sp, #4]
 8001282:	3304      	adds	r3, #4
 8001284:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8001288:	4618      	mov	r0, r3
 800128a:	f7ff feb9 	bl	8001000 <osalEventBroadcastFlagsI.lto_priv.1>
}
 800128e:	bf00      	nop
 8001290:	b003      	add	sp, #12
 8001292:	f85d fb04 	ldr.w	pc, [sp], #4
 8001296:	bf00      	nop
 8001298:	08005314 	.word	0x08005314
 800129c:	00000000 	.word	0x00000000

080012a0 <nvicInit>:
/*===========================================================================*/

/**
 * @brief   NVIC clearing and initialization.
 */
void nvicInit(void) {
 80012a0:	b082      	sub	sp, #8
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
#else
  uint32_t n = SCnSCB->ICTR;
 80012a2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80012a6:	685b      	ldr	r3, [r3, #4]
 80012a8:	9300      	str	r3, [sp, #0]
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 80012aa:	2300      	movs	r3, #0
 80012ac:	9301      	str	r3, [sp, #4]
 80012ae:	e010      	b.n	80012d2 <nvicInit+0x32>
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 80012b0:	4a0c      	ldr	r2, [pc, #48]	@ (80012e4 <nvicInit+0x44>)
 80012b2:	9b01      	ldr	r3, [sp, #4]
 80012b4:	3320      	adds	r3, #32
 80012b6:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 80012ba:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 80012be:	4a09      	ldr	r2, [pc, #36]	@ (80012e4 <nvicInit+0x44>)
 80012c0:	9b01      	ldr	r3, [sp, #4]
 80012c2:	3360      	adds	r3, #96	@ 0x60
 80012c4:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 80012c8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  for (uint32_t i = 0U; i <= n; i++) {
 80012cc:	9b01      	ldr	r3, [sp, #4]
 80012ce:	3301      	adds	r3, #1
 80012d0:	9301      	str	r3, [sp, #4]
 80012d2:	9a01      	ldr	r2, [sp, #4]
 80012d4:	9b00      	ldr	r3, [sp, #0]
 80012d6:	429a      	cmp	r2, r3
 80012d8:	d9ea      	bls.n	80012b0 <nvicInit+0x10>
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
    NVIC->__ITNS[i] = 0xFFFFFFFFU;
#endif
  }
}
 80012da:	bf00      	nop
 80012dc:	bf00      	nop
 80012de:	b002      	add	sp, #8
 80012e0:	4770      	bx	lr
 80012e2:	bf00      	nop
 80012e4:	e000e100 	.word	0xe000e100
	...

080012f0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80012f0:	b082      	sub	sp, #8
 80012f2:	9001      	str	r0, [sp, #4]
 80012f4:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80012f6:	9b00      	ldr	r3, [sp, #0]
 80012f8:	b2db      	uxtb	r3, r3
 80012fa:	4a11      	ldr	r2, [pc, #68]	@ (8001340 <nvicEnableVector+0x50>)
 80012fc:	011b      	lsls	r3, r3, #4
 80012fe:	b2d9      	uxtb	r1, r3
 8001300:	9b01      	ldr	r3, [sp, #4]
 8001302:	4413      	add	r3, r2
 8001304:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8001308:	460a      	mov	r2, r1
 800130a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800130c:	9b01      	ldr	r3, [sp, #4]
 800130e:	f003 021f 	and.w	r2, r3, #31
 8001312:	490b      	ldr	r1, [pc, #44]	@ (8001340 <nvicEnableVector+0x50>)
 8001314:	9b01      	ldr	r3, [sp, #4]
 8001316:	095b      	lsrs	r3, r3, #5
 8001318:	2001      	movs	r0, #1
 800131a:	fa00 f202 	lsl.w	r2, r0, r2
 800131e:	3360      	adds	r3, #96	@ 0x60
 8001320:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001324:	9b01      	ldr	r3, [sp, #4]
 8001326:	f003 021f 	and.w	r2, r3, #31
 800132a:	4905      	ldr	r1, [pc, #20]	@ (8001340 <nvicEnableVector+0x50>)
 800132c:	9b01      	ldr	r3, [sp, #4]
 800132e:	095b      	lsrs	r3, r3, #5
 8001330:	2001      	movs	r0, #1
 8001332:	fa00 f202 	lsl.w	r2, r0, r2
 8001336:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 800133a:	bf00      	nop
 800133c:	b002      	add	sp, #8
 800133e:	4770      	bx	lr
 8001340:	e000e100 	.word	0xe000e100
	...

08001350 <exti0_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti0_irq_init(void) {
 8001350:	b508      	push	{r3, lr}
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
 8001352:	2106      	movs	r1, #6
 8001354:	2006      	movs	r0, #6
 8001356:	f7ff ffcb 	bl	80012f0 <nvicEnableVector>
#endif
}
 800135a:	bf00      	nop
 800135c:	bd08      	pop	{r3, pc}
 800135e:	bf00      	nop

08001360 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI0_HANDLER) {
 8001360:	b500      	push	{lr}
 8001362:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8001364:	f002 f88c 	bl	8003480 <__dbg_check_enter_isr>

  extiGetAndClearGroup1(1U << 0, pr);
 8001368:	4b10      	ldr	r3, [pc, #64]	@ (80013ac <Vector58+0x4c>)
 800136a:	68db      	ldr	r3, [r3, #12]
 800136c:	f003 0301 	and.w	r3, r3, #1
 8001370:	9301      	str	r3, [sp, #4]
 8001372:	9b01      	ldr	r3, [sp, #4]
 8001374:	9300      	str	r3, [sp, #0]
 8001376:	4a0d      	ldr	r2, [pc, #52]	@ (80013ac <Vector58+0x4c>)
 8001378:	9b01      	ldr	r3, [sp, #4]
 800137a:	60d3      	str	r3, [r2, #12]

  exti_serve_irq(pr, 0);
 800137c:	9b00      	ldr	r3, [sp, #0]
 800137e:	f003 0301 	and.w	r3, r3, #1
 8001382:	2b00      	cmp	r3, #0
 8001384:	d009      	beq.n	800139a <Vector58+0x3a>
 8001386:	4b0a      	ldr	r3, [pc, #40]	@ (80013b0 <Vector58+0x50>)
 8001388:	681b      	ldr	r3, [r3, #0]
 800138a:	2b00      	cmp	r3, #0
 800138c:	d005      	beq.n	800139a <Vector58+0x3a>
 800138e:	4b08      	ldr	r3, [pc, #32]	@ (80013b0 <Vector58+0x50>)
 8001390:	681b      	ldr	r3, [r3, #0]
 8001392:	4a07      	ldr	r2, [pc, #28]	@ (80013b0 <Vector58+0x50>)
 8001394:	6852      	ldr	r2, [r2, #4]
 8001396:	4610      	mov	r0, r2
 8001398:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800139a:	f002 f8a9 	bl	80034f0 <__dbg_check_leave_isr>
 800139e:	f003 fdf7 	bl	8004f90 <__port_irq_epilogue>
}
 80013a2:	bf00      	nop
 80013a4:	b003      	add	sp, #12
 80013a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80013aa:	bf00      	nop
 80013ac:	58000800 	.word	0x58000800
 80013b0:	200008b4 	.word	0x200008b4
	...

080013c0 <exti1_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti1_irq_init(void) {
 80013c0:	b508      	push	{r3, lr}
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
 80013c2:	2106      	movs	r1, #6
 80013c4:	2007      	movs	r0, #7
 80013c6:	f7ff ff93 	bl	80012f0 <nvicEnableVector>
#endif
}
 80013ca:	bf00      	nop
 80013cc:	bd08      	pop	{r3, pc}
 80013ce:	bf00      	nop

080013d0 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI1_HANDLER) {
 80013d0:	b500      	push	{lr}
 80013d2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 80013d4:	f002 f854 	bl	8003480 <__dbg_check_enter_isr>

  extiGetAndClearGroup1(1U << 1, pr);
 80013d8:	4b10      	ldr	r3, [pc, #64]	@ (800141c <Vector5C+0x4c>)
 80013da:	68db      	ldr	r3, [r3, #12]
 80013dc:	f003 0302 	and.w	r3, r3, #2
 80013e0:	9301      	str	r3, [sp, #4]
 80013e2:	9b01      	ldr	r3, [sp, #4]
 80013e4:	9300      	str	r3, [sp, #0]
 80013e6:	4a0d      	ldr	r2, [pc, #52]	@ (800141c <Vector5C+0x4c>)
 80013e8:	9b01      	ldr	r3, [sp, #4]
 80013ea:	60d3      	str	r3, [r2, #12]

  exti_serve_irq(pr, 1);
 80013ec:	9b00      	ldr	r3, [sp, #0]
 80013ee:	f003 0302 	and.w	r3, r3, #2
 80013f2:	2b00      	cmp	r3, #0
 80013f4:	d009      	beq.n	800140a <Vector5C+0x3a>
 80013f6:	4b0a      	ldr	r3, [pc, #40]	@ (8001420 <Vector5C+0x50>)
 80013f8:	689b      	ldr	r3, [r3, #8]
 80013fa:	2b00      	cmp	r3, #0
 80013fc:	d005      	beq.n	800140a <Vector5C+0x3a>
 80013fe:	4b08      	ldr	r3, [pc, #32]	@ (8001420 <Vector5C+0x50>)
 8001400:	689b      	ldr	r3, [r3, #8]
 8001402:	4a07      	ldr	r2, [pc, #28]	@ (8001420 <Vector5C+0x50>)
 8001404:	68d2      	ldr	r2, [r2, #12]
 8001406:	4610      	mov	r0, r2
 8001408:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800140a:	f002 f871 	bl	80034f0 <__dbg_check_leave_isr>
 800140e:	f003 fdbf 	bl	8004f90 <__port_irq_epilogue>
}
 8001412:	bf00      	nop
 8001414:	b003      	add	sp, #12
 8001416:	f85d fb04 	ldr.w	pc, [sp], #4
 800141a:	bf00      	nop
 800141c:	58000800 	.word	0x58000800
 8001420:	200008b4 	.word	0x200008b4
	...

08001430 <exti2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti2_irq_init(void) {
 8001430:	b508      	push	{r3, lr}
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
 8001432:	2106      	movs	r1, #6
 8001434:	2008      	movs	r0, #8
 8001436:	f7ff ff5b 	bl	80012f0 <nvicEnableVector>
#endif
}
 800143a:	bf00      	nop
 800143c:	bd08      	pop	{r3, pc}
 800143e:	bf00      	nop

08001440 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI2_HANDLER) {
 8001440:	b500      	push	{lr}
 8001442:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8001444:	f002 f81c 	bl	8003480 <__dbg_check_enter_isr>

  extiGetAndClearGroup1(1U << 2, pr);
 8001448:	4b10      	ldr	r3, [pc, #64]	@ (800148c <Vector60+0x4c>)
 800144a:	68db      	ldr	r3, [r3, #12]
 800144c:	f003 0304 	and.w	r3, r3, #4
 8001450:	9301      	str	r3, [sp, #4]
 8001452:	9b01      	ldr	r3, [sp, #4]
 8001454:	9300      	str	r3, [sp, #0]
 8001456:	4a0d      	ldr	r2, [pc, #52]	@ (800148c <Vector60+0x4c>)
 8001458:	9b01      	ldr	r3, [sp, #4]
 800145a:	60d3      	str	r3, [r2, #12]

  exti_serve_irq(pr, 2);
 800145c:	9b00      	ldr	r3, [sp, #0]
 800145e:	f003 0304 	and.w	r3, r3, #4
 8001462:	2b00      	cmp	r3, #0
 8001464:	d009      	beq.n	800147a <Vector60+0x3a>
 8001466:	4b0a      	ldr	r3, [pc, #40]	@ (8001490 <Vector60+0x50>)
 8001468:	691b      	ldr	r3, [r3, #16]
 800146a:	2b00      	cmp	r3, #0
 800146c:	d005      	beq.n	800147a <Vector60+0x3a>
 800146e:	4b08      	ldr	r3, [pc, #32]	@ (8001490 <Vector60+0x50>)
 8001470:	691b      	ldr	r3, [r3, #16]
 8001472:	4a07      	ldr	r2, [pc, #28]	@ (8001490 <Vector60+0x50>)
 8001474:	6952      	ldr	r2, [r2, #20]
 8001476:	4610      	mov	r0, r2
 8001478:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800147a:	f002 f839 	bl	80034f0 <__dbg_check_leave_isr>
 800147e:	f003 fd87 	bl	8004f90 <__port_irq_epilogue>
}
 8001482:	bf00      	nop
 8001484:	b003      	add	sp, #12
 8001486:	f85d fb04 	ldr.w	pc, [sp], #4
 800148a:	bf00      	nop
 800148c:	58000800 	.word	0x58000800
 8001490:	200008b4 	.word	0x200008b4
	...

080014a0 <exti3_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti3_irq_init(void) {
 80014a0:	b508      	push	{r3, lr}
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
 80014a2:	2106      	movs	r1, #6
 80014a4:	2009      	movs	r0, #9
 80014a6:	f7ff ff23 	bl	80012f0 <nvicEnableVector>
#endif
}
 80014aa:	bf00      	nop
 80014ac:	bd08      	pop	{r3, pc}
 80014ae:	bf00      	nop

080014b0 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI3_HANDLER) {
 80014b0:	b500      	push	{lr}
 80014b2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 80014b4:	f001 ffe4 	bl	8003480 <__dbg_check_enter_isr>

  extiGetAndClearGroup1(1U << 3, pr);
 80014b8:	4b10      	ldr	r3, [pc, #64]	@ (80014fc <Vector64+0x4c>)
 80014ba:	68db      	ldr	r3, [r3, #12]
 80014bc:	f003 0308 	and.w	r3, r3, #8
 80014c0:	9301      	str	r3, [sp, #4]
 80014c2:	9b01      	ldr	r3, [sp, #4]
 80014c4:	9300      	str	r3, [sp, #0]
 80014c6:	4a0d      	ldr	r2, [pc, #52]	@ (80014fc <Vector64+0x4c>)
 80014c8:	9b01      	ldr	r3, [sp, #4]
 80014ca:	60d3      	str	r3, [r2, #12]

  exti_serve_irq(pr, 3);
 80014cc:	9b00      	ldr	r3, [sp, #0]
 80014ce:	f003 0308 	and.w	r3, r3, #8
 80014d2:	2b00      	cmp	r3, #0
 80014d4:	d009      	beq.n	80014ea <Vector64+0x3a>
 80014d6:	4b0a      	ldr	r3, [pc, #40]	@ (8001500 <Vector64+0x50>)
 80014d8:	699b      	ldr	r3, [r3, #24]
 80014da:	2b00      	cmp	r3, #0
 80014dc:	d005      	beq.n	80014ea <Vector64+0x3a>
 80014de:	4b08      	ldr	r3, [pc, #32]	@ (8001500 <Vector64+0x50>)
 80014e0:	699b      	ldr	r3, [r3, #24]
 80014e2:	4a07      	ldr	r2, [pc, #28]	@ (8001500 <Vector64+0x50>)
 80014e4:	69d2      	ldr	r2, [r2, #28]
 80014e6:	4610      	mov	r0, r2
 80014e8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80014ea:	f002 f801 	bl	80034f0 <__dbg_check_leave_isr>
 80014ee:	f003 fd4f 	bl	8004f90 <__port_irq_epilogue>
}
 80014f2:	bf00      	nop
 80014f4:	b003      	add	sp, #12
 80014f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80014fa:	bf00      	nop
 80014fc:	58000800 	.word	0x58000800
 8001500:	200008b4 	.word	0x200008b4
	...

08001510 <exti4_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti4_irq_init(void) {
 8001510:	b508      	push	{r3, lr}
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
 8001512:	2106      	movs	r1, #6
 8001514:	200a      	movs	r0, #10
 8001516:	f7ff feeb 	bl	80012f0 <nvicEnableVector>
#endif
}
 800151a:	bf00      	nop
 800151c:	bd08      	pop	{r3, pc}
 800151e:	bf00      	nop

08001520 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI4_HANDLER) {
 8001520:	b500      	push	{lr}
 8001522:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8001524:	f001 ffac 	bl	8003480 <__dbg_check_enter_isr>

  extiGetAndClearGroup1(1U << 4, pr);
 8001528:	4b10      	ldr	r3, [pc, #64]	@ (800156c <Vector68+0x4c>)
 800152a:	68db      	ldr	r3, [r3, #12]
 800152c:	f003 0310 	and.w	r3, r3, #16
 8001530:	9301      	str	r3, [sp, #4]
 8001532:	9b01      	ldr	r3, [sp, #4]
 8001534:	9300      	str	r3, [sp, #0]
 8001536:	4a0d      	ldr	r2, [pc, #52]	@ (800156c <Vector68+0x4c>)
 8001538:	9b01      	ldr	r3, [sp, #4]
 800153a:	60d3      	str	r3, [r2, #12]

  exti_serve_irq(pr, 4);
 800153c:	9b00      	ldr	r3, [sp, #0]
 800153e:	f003 0310 	and.w	r3, r3, #16
 8001542:	2b00      	cmp	r3, #0
 8001544:	d009      	beq.n	800155a <Vector68+0x3a>
 8001546:	4b0a      	ldr	r3, [pc, #40]	@ (8001570 <Vector68+0x50>)
 8001548:	6a1b      	ldr	r3, [r3, #32]
 800154a:	2b00      	cmp	r3, #0
 800154c:	d005      	beq.n	800155a <Vector68+0x3a>
 800154e:	4b08      	ldr	r3, [pc, #32]	@ (8001570 <Vector68+0x50>)
 8001550:	6a1b      	ldr	r3, [r3, #32]
 8001552:	4a07      	ldr	r2, [pc, #28]	@ (8001570 <Vector68+0x50>)
 8001554:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8001556:	4610      	mov	r0, r2
 8001558:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800155a:	f001 ffc9 	bl	80034f0 <__dbg_check_leave_isr>
 800155e:	f003 fd17 	bl	8004f90 <__port_irq_epilogue>
}
 8001562:	bf00      	nop
 8001564:	b003      	add	sp, #12
 8001566:	f85d fb04 	ldr.w	pc, [sp], #4
 800156a:	bf00      	nop
 800156c:	58000800 	.word	0x58000800
 8001570:	200008b4 	.word	0x200008b4
	...

08001580 <exti5_9_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti5_9_irq_init(void) {
 8001580:	b508      	push	{r3, lr}
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
 8001582:	2106      	movs	r1, #6
 8001584:	2017      	movs	r0, #23
 8001586:	f7ff feb3 	bl	80012f0 <nvicEnableVector>
#endif
}
 800158a:	bf00      	nop
 800158c:	bd08      	pop	{r3, pc}
 800158e:	bf00      	nop

08001590 <Vector9C>:
/**
 * @brief   EXTI[5]..EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI5_9_HANDLER) {
 8001590:	b500      	push	{lr}
 8001592:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8001594:	f001 ff74 	bl	8003480 <__dbg_check_enter_isr>

  extiGetAndClearGroup1((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 8001598:	4b2e      	ldr	r3, [pc, #184]	@ (8001654 <Vector9C+0xc4>)
 800159a:	68db      	ldr	r3, [r3, #12]
 800159c:	f403 7378 	and.w	r3, r3, #992	@ 0x3e0
 80015a0:	9301      	str	r3, [sp, #4]
 80015a2:	9b01      	ldr	r3, [sp, #4]
 80015a4:	9300      	str	r3, [sp, #0]
 80015a6:	4a2b      	ldr	r2, [pc, #172]	@ (8001654 <Vector9C+0xc4>)
 80015a8:	9b01      	ldr	r3, [sp, #4]
 80015aa:	60d3      	str	r3, [r2, #12]
                        (1U << 9), pr);

  exti_serve_irq(pr, 5);
 80015ac:	9b00      	ldr	r3, [sp, #0]
 80015ae:	f003 0320 	and.w	r3, r3, #32
 80015b2:	2b00      	cmp	r3, #0
 80015b4:	d009      	beq.n	80015ca <Vector9C+0x3a>
 80015b6:	4b28      	ldr	r3, [pc, #160]	@ (8001658 <Vector9C+0xc8>)
 80015b8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015ba:	2b00      	cmp	r3, #0
 80015bc:	d005      	beq.n	80015ca <Vector9C+0x3a>
 80015be:	4b26      	ldr	r3, [pc, #152]	@ (8001658 <Vector9C+0xc8>)
 80015c0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015c2:	4a25      	ldr	r2, [pc, #148]	@ (8001658 <Vector9C+0xc8>)
 80015c4:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80015c6:	4610      	mov	r0, r2
 80015c8:	4798      	blx	r3
  exti_serve_irq(pr, 6);
 80015ca:	9b00      	ldr	r3, [sp, #0]
 80015cc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80015d0:	2b00      	cmp	r3, #0
 80015d2:	d009      	beq.n	80015e8 <Vector9C+0x58>
 80015d4:	4b20      	ldr	r3, [pc, #128]	@ (8001658 <Vector9C+0xc8>)
 80015d6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80015d8:	2b00      	cmp	r3, #0
 80015da:	d005      	beq.n	80015e8 <Vector9C+0x58>
 80015dc:	4b1e      	ldr	r3, [pc, #120]	@ (8001658 <Vector9C+0xc8>)
 80015de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80015e0:	4a1d      	ldr	r2, [pc, #116]	@ (8001658 <Vector9C+0xc8>)
 80015e2:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 80015e4:	4610      	mov	r0, r2
 80015e6:	4798      	blx	r3
  exti_serve_irq(pr, 7);
 80015e8:	9b00      	ldr	r3, [sp, #0]
 80015ea:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80015ee:	2b00      	cmp	r3, #0
 80015f0:	d009      	beq.n	8001606 <Vector9C+0x76>
 80015f2:	4b19      	ldr	r3, [pc, #100]	@ (8001658 <Vector9C+0xc8>)
 80015f4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80015f6:	2b00      	cmp	r3, #0
 80015f8:	d005      	beq.n	8001606 <Vector9C+0x76>
 80015fa:	4b17      	ldr	r3, [pc, #92]	@ (8001658 <Vector9C+0xc8>)
 80015fc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80015fe:	4a16      	ldr	r2, [pc, #88]	@ (8001658 <Vector9C+0xc8>)
 8001600:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8001602:	4610      	mov	r0, r2
 8001604:	4798      	blx	r3
  exti_serve_irq(pr, 8);
 8001606:	9b00      	ldr	r3, [sp, #0]
 8001608:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800160c:	2b00      	cmp	r3, #0
 800160e:	d009      	beq.n	8001624 <Vector9C+0x94>
 8001610:	4b11      	ldr	r3, [pc, #68]	@ (8001658 <Vector9C+0xc8>)
 8001612:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001614:	2b00      	cmp	r3, #0
 8001616:	d005      	beq.n	8001624 <Vector9C+0x94>
 8001618:	4b0f      	ldr	r3, [pc, #60]	@ (8001658 <Vector9C+0xc8>)
 800161a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800161c:	4a0e      	ldr	r2, [pc, #56]	@ (8001658 <Vector9C+0xc8>)
 800161e:	6c52      	ldr	r2, [r2, #68]	@ 0x44
 8001620:	4610      	mov	r0, r2
 8001622:	4798      	blx	r3
  exti_serve_irq(pr, 9);
 8001624:	9b00      	ldr	r3, [sp, #0]
 8001626:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800162a:	2b00      	cmp	r3, #0
 800162c:	d009      	beq.n	8001642 <Vector9C+0xb2>
 800162e:	4b0a      	ldr	r3, [pc, #40]	@ (8001658 <Vector9C+0xc8>)
 8001630:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8001632:	2b00      	cmp	r3, #0
 8001634:	d005      	beq.n	8001642 <Vector9C+0xb2>
 8001636:	4b08      	ldr	r3, [pc, #32]	@ (8001658 <Vector9C+0xc8>)
 8001638:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800163a:	4a07      	ldr	r2, [pc, #28]	@ (8001658 <Vector9C+0xc8>)
 800163c:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 800163e:	4610      	mov	r0, r2
 8001640:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001642:	f001 ff55 	bl	80034f0 <__dbg_check_leave_isr>
 8001646:	f003 fca3 	bl	8004f90 <__port_irq_epilogue>
}
 800164a:	bf00      	nop
 800164c:	b003      	add	sp, #12
 800164e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001652:	bf00      	nop
 8001654:	58000800 	.word	0x58000800
 8001658:	200008b4 	.word	0x200008b4
 800165c:	00000000 	.word	0x00000000

08001660 <exti10_15_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti10_15_irq_init(void) {
 8001660:	b508      	push	{r3, lr}
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
 8001662:	2106      	movs	r1, #6
 8001664:	2028      	movs	r0, #40	@ 0x28
 8001666:	f7ff fe43 	bl	80012f0 <nvicEnableVector>
#endif
}
 800166a:	bf00      	nop
 800166c:	bd08      	pop	{r3, pc}
 800166e:	bf00      	nop

08001670 <VectorE0>:
/**
 * @brief   EXTI[10]..EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI10_15_HANDLER) {
 8001670:	b500      	push	{lr}
 8001672:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8001674:	f001 ff04 	bl	8003480 <__dbg_check_enter_isr>

  extiGetAndClearGroup1((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 8001678:	4b35      	ldr	r3, [pc, #212]	@ (8001750 <VectorE0+0xe0>)
 800167a:	68db      	ldr	r3, [r3, #12]
 800167c:	f403 437c 	and.w	r3, r3, #64512	@ 0xfc00
 8001680:	9301      	str	r3, [sp, #4]
 8001682:	9b01      	ldr	r3, [sp, #4]
 8001684:	9300      	str	r3, [sp, #0]
 8001686:	4a32      	ldr	r2, [pc, #200]	@ (8001750 <VectorE0+0xe0>)
 8001688:	9b01      	ldr	r3, [sp, #4]
 800168a:	60d3      	str	r3, [r2, #12]
                        (1U << 14) | (1U << 15), pr);

  exti_serve_irq(pr, 10);
 800168c:	9b00      	ldr	r3, [sp, #0]
 800168e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8001692:	2b00      	cmp	r3, #0
 8001694:	d009      	beq.n	80016aa <VectorE0+0x3a>
 8001696:	4b2f      	ldr	r3, [pc, #188]	@ (8001754 <VectorE0+0xe4>)
 8001698:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800169a:	2b00      	cmp	r3, #0
 800169c:	d005      	beq.n	80016aa <VectorE0+0x3a>
 800169e:	4b2d      	ldr	r3, [pc, #180]	@ (8001754 <VectorE0+0xe4>)
 80016a0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80016a2:	4a2c      	ldr	r2, [pc, #176]	@ (8001754 <VectorE0+0xe4>)
 80016a4:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 80016a6:	4610      	mov	r0, r2
 80016a8:	4798      	blx	r3
  exti_serve_irq(pr, 11);
 80016aa:	9b00      	ldr	r3, [sp, #0]
 80016ac:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 80016b0:	2b00      	cmp	r3, #0
 80016b2:	d009      	beq.n	80016c8 <VectorE0+0x58>
 80016b4:	4b27      	ldr	r3, [pc, #156]	@ (8001754 <VectorE0+0xe4>)
 80016b6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80016b8:	2b00      	cmp	r3, #0
 80016ba:	d005      	beq.n	80016c8 <VectorE0+0x58>
 80016bc:	4b25      	ldr	r3, [pc, #148]	@ (8001754 <VectorE0+0xe4>)
 80016be:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80016c0:	4a24      	ldr	r2, [pc, #144]	@ (8001754 <VectorE0+0xe4>)
 80016c2:	6dd2      	ldr	r2, [r2, #92]	@ 0x5c
 80016c4:	4610      	mov	r0, r2
 80016c6:	4798      	blx	r3
  exti_serve_irq(pr, 12);
 80016c8:	9b00      	ldr	r3, [sp, #0]
 80016ca:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 80016ce:	2b00      	cmp	r3, #0
 80016d0:	d009      	beq.n	80016e6 <VectorE0+0x76>
 80016d2:	4b20      	ldr	r3, [pc, #128]	@ (8001754 <VectorE0+0xe4>)
 80016d4:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80016d6:	2b00      	cmp	r3, #0
 80016d8:	d005      	beq.n	80016e6 <VectorE0+0x76>
 80016da:	4b1e      	ldr	r3, [pc, #120]	@ (8001754 <VectorE0+0xe4>)
 80016dc:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80016de:	4a1d      	ldr	r2, [pc, #116]	@ (8001754 <VectorE0+0xe4>)
 80016e0:	6e52      	ldr	r2, [r2, #100]	@ 0x64
 80016e2:	4610      	mov	r0, r2
 80016e4:	4798      	blx	r3
  exti_serve_irq(pr, 13);
 80016e6:	9b00      	ldr	r3, [sp, #0]
 80016e8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80016ec:	2b00      	cmp	r3, #0
 80016ee:	d009      	beq.n	8001704 <VectorE0+0x94>
 80016f0:	4b18      	ldr	r3, [pc, #96]	@ (8001754 <VectorE0+0xe4>)
 80016f2:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80016f4:	2b00      	cmp	r3, #0
 80016f6:	d005      	beq.n	8001704 <VectorE0+0x94>
 80016f8:	4b16      	ldr	r3, [pc, #88]	@ (8001754 <VectorE0+0xe4>)
 80016fa:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80016fc:	4a15      	ldr	r2, [pc, #84]	@ (8001754 <VectorE0+0xe4>)
 80016fe:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
 8001700:	4610      	mov	r0, r2
 8001702:	4798      	blx	r3
  exti_serve_irq(pr, 14);
 8001704:	9b00      	ldr	r3, [sp, #0]
 8001706:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800170a:	2b00      	cmp	r3, #0
 800170c:	d009      	beq.n	8001722 <VectorE0+0xb2>
 800170e:	4b11      	ldr	r3, [pc, #68]	@ (8001754 <VectorE0+0xe4>)
 8001710:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8001712:	2b00      	cmp	r3, #0
 8001714:	d005      	beq.n	8001722 <VectorE0+0xb2>
 8001716:	4b0f      	ldr	r3, [pc, #60]	@ (8001754 <VectorE0+0xe4>)
 8001718:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800171a:	4a0e      	ldr	r2, [pc, #56]	@ (8001754 <VectorE0+0xe4>)
 800171c:	6f52      	ldr	r2, [r2, #116]	@ 0x74
 800171e:	4610      	mov	r0, r2
 8001720:	4798      	blx	r3
  exti_serve_irq(pr, 15);
 8001722:	9b00      	ldr	r3, [sp, #0]
 8001724:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8001728:	2b00      	cmp	r3, #0
 800172a:	d009      	beq.n	8001740 <VectorE0+0xd0>
 800172c:	4b09      	ldr	r3, [pc, #36]	@ (8001754 <VectorE0+0xe4>)
 800172e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8001730:	2b00      	cmp	r3, #0
 8001732:	d005      	beq.n	8001740 <VectorE0+0xd0>
 8001734:	4b07      	ldr	r3, [pc, #28]	@ (8001754 <VectorE0+0xe4>)
 8001736:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8001738:	4a06      	ldr	r2, [pc, #24]	@ (8001754 <VectorE0+0xe4>)
 800173a:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
 800173c:	4610      	mov	r0, r2
 800173e:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001740:	f001 fed6 	bl	80034f0 <__dbg_check_leave_isr>
 8001744:	f003 fc24 	bl	8004f90 <__port_irq_epilogue>
}
 8001748:	bf00      	nop
 800174a:	b003      	add	sp, #12
 800174c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001750:	58000800 	.word	0x58000800
 8001754:	200008b4 	.word	0x200008b4
	...

08001760 <exti16_exti31_exti33_irq_init>:
static inline void exti16_exti31_exti33_irq_init(void) {
#if defined(STM32_EXTI16_IS_USED) || defined(STM32_EXTI31_IS_USED) ||       \
    defined(STM32_EXTI33_IS_USED)
  nvicEnableVector(STM32_EXTI1635_38_NUMBER, STM32_IRQ_EXTI16_31_33_PRIORITY);
#endif
}
 8001760:	bf00      	nop
 8001762:	4770      	bx	lr
	...

08001770 <exti17_irq_init>:

static inline void exti17_irq_init(void) {
#if defined(STM32_EXTI17_IS_USED)
  nvicEnableVector(STM32_EXTI17_NUMBER, STM32_IRQ_EXTI17_PRIORITY);
#endif
}
 8001770:	bf00      	nop
 8001772:	4770      	bx	lr
	...

08001780 <exti18_irq_init>:

static inline void exti18_irq_init(void) {
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
 8001780:	bf00      	nop
 8001782:	4770      	bx	lr
	...

08001790 <exti19_irq_init>:

static inline void exti19_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
 8001790:	bf00      	nop
 8001792:	4770      	bx	lr
	...

080017a0 <exti20_exti21_irq_init>:

static inline void exti20_exti21_irq_init(void) {
#if defined(STM32_EXTI20_IS_USED) || defined(STM32_EXTI21_IS_USED)
  nvicEnableVector(STM32_EXTI20_21_NUMBER, STM32_IRQ_EXTI20_21_PRIORITY);
#endif
}
 80017a0:	bf00      	nop
 80017a2:	4770      	bx	lr
	...

080017b0 <usart1_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void usart1_irq_init(void) {
 80017b0:	b508      	push	{r3, lr}
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
 80017b2:	2103      	movs	r1, #3
 80017b4:	2024      	movs	r0, #36	@ 0x24
 80017b6:	f7ff fd9b 	bl	80012f0 <nvicEnableVector>
#endif
}
 80017ba:	bf00      	nop
 80017bc:	bd08      	pop	{r3, pc}
 80017be:	bf00      	nop

080017c0 <VectorD0>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 80017c0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80017c2:	f001 fe5d 	bl	8003480 <__dbg_check_enter_isr>

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_USART1
  sd_lld_serve_interrupt(&SD1);
 80017c6:	4804      	ldr	r0, [pc, #16]	@ (80017d8 <VectorD0+0x18>)
 80017c8:	f001 fbaa 	bl	8002f20 <sd_lld_serve_interrupt>
#if STM32_UART_USE_USART1
  uart_lld_serve_interrupt(&UARTD1);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 80017cc:	f001 fe90 	bl	80034f0 <__dbg_check_leave_isr>
 80017d0:	f003 fbde 	bl	8004f90 <__port_irq_epilogue>
}
 80017d4:	bf00      	nop
 80017d6:	bd08      	pop	{r3, pc}
 80017d8:	20000944 	.word	0x20000944
 80017dc:	00000000 	.word	0x00000000

080017e0 <lpuart1_irq_init>:

static inline void lpuart1_irq_init(void) {
#if defined(STM32_LPUART1_IS_USED)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_IRQ_LPUART1_PRIORITY);
#endif
}
 80017e0:	bf00      	nop
 80017e2:	4770      	bx	lr
	...

080017f0 <tim1_tim16_tim17_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim1_tim16_tim17_irq_init(void) {
 80017f0:	b508      	push	{r3, lr}
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_BRK_NUMBER,
 80017f2:	2107      	movs	r1, #7
 80017f4:	2018      	movs	r0, #24
 80017f6:	f7ff fd7b 	bl	80012f0 <nvicEnableVector>
                   STM32_IRQ_TIM1_BRK_PRIORITY);
#endif
#if defined(STM32_TIM1_IS_USED) || defined(STM32_TIM16_IS_USED)
  nvicEnableVector(STM32_TIM1_UP_TIM16_NUMBER,
 80017fa:	2107      	movs	r1, #7
 80017fc:	2019      	movs	r0, #25
 80017fe:	f7ff fd77 	bl	80012f0 <nvicEnableVector>
                   STM32_IRQ_TIM1_UP_TIM16_PRIORITY);
#endif
#if defined(STM32_TIM1_IS_USED) || defined(STM32_TIM17_IS_USED)
  nvicEnableVector(STM32_TIM1_TRGCO_TIM17_NUMBER,
 8001802:	2107      	movs	r1, #7
 8001804:	201a      	movs	r0, #26
 8001806:	f7ff fd73 	bl	80012f0 <nvicEnableVector>
                   STM32_IRQ_TIM1_TRGCO_TIM17_PRIORITY);
#endif
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_CC_NUMBER,
 800180a:	2107      	movs	r1, #7
 800180c:	201b      	movs	r0, #27
 800180e:	f7ff fd6f 	bl	80012f0 <nvicEnableVector>
                   STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8001812:	bf00      	nop
 8001814:	bd08      	pop	{r3, pc}
 8001816:	bf00      	nop
	...

08001820 <VectorA0>:
/**
 * @brief   TIM1-BRK interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_BRK_HANDLER) {
 8001820:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001822:	f001 fe2d 	bl	8003480 <__dbg_check_enter_isr>
  OSAL_IRQ_EPILOGUE();
 8001826:	f001 fe63 	bl	80034f0 <__dbg_check_leave_isr>
 800182a:	f003 fbb1 	bl	8004f90 <__port_irq_epilogue>
}
 800182e:	bf00      	nop
 8001830:	bd08      	pop	{r3, pc}
 8001832:	bf00      	nop
	...

08001840 <VectorA4>:
/**
 * @brief   TIM1-UP, TIM16 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_TIM16_HANDLER) {
 8001840:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001842:	f001 fe1d 	bl	8003480 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM1
  gpt_lld_serve_interrupt(&GPTD1);
 8001846:	4804      	ldr	r0, [pc, #16]	@ (8001858 <VectorA4+0x18>)
 8001848:	f001 fa82 	bl	8002d50 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM16
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 800184c:	f001 fe50 	bl	80034f0 <__dbg_check_leave_isr>
 8001850:	f003 fb9e 	bl	8004f90 <__port_irq_epilogue>
}
 8001854:	bf00      	nop
 8001856:	bd08      	pop	{r3, pc}
 8001858:	20000934 	.word	0x20000934
 800185c:	00000000 	.word	0x00000000

08001860 <VectorA8>:
/**
 * @brief   TIM1-TRG-COM, TIM17 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_TRGCO_TIM17_HANDLER) {
 8001860:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001862:	f001 fe0d 	bl	8003480 <__dbg_check_enter_isr>
#if STM32_ST_USE_TIM17
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001866:	f001 fe43 	bl	80034f0 <__dbg_check_leave_isr>
 800186a:	f003 fb91 	bl	8004f90 <__port_irq_epilogue>
}
 800186e:	bf00      	nop
 8001870:	bd08      	pop	{r3, pc}
 8001872:	bf00      	nop
	...

08001880 <VectorAC>:
/**
 * @brief   TIM1-CC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 8001880:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001882:	f001 fdfd 	bl	8003480 <__dbg_check_enter_isr>
#endif
#if 1
  /* Not used by ST.*/
#endif

  OSAL_IRQ_EPILOGUE();
 8001886:	f001 fe33 	bl	80034f0 <__dbg_check_leave_isr>
 800188a:	f003 fb81 	bl	8004f90 <__port_irq_epilogue>
}
 800188e:	bf00      	nop
 8001890:	bd08      	pop	{r3, pc}
 8001892:	bf00      	nop
	...

080018a0 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 80018a0:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 80018a2:	2107      	movs	r1, #7
 80018a4:	201c      	movs	r0, #28
 80018a6:	f7ff fd23 	bl	80012f0 <nvicEnableVector>
#endif
}
 80018aa:	bf00      	nop
 80018ac:	bd08      	pop	{r3, pc}
 80018ae:	bf00      	nop

080018b0 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 80018b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80018b2:	f001 fde5 	bl	8003480 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 80018b6:	f001 f96b 	bl	8002b90 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 80018ba:	f001 fe19 	bl	80034f0 <__dbg_check_leave_isr>
 80018be:	f003 fb67 	bl	8004f90 <__port_irq_epilogue>
}
 80018c2:	bf00      	nop
 80018c4:	bd08      	pop	{r3, pc}
 80018c6:	bf00      	nop
	...

080018d0 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 80018d0:	b508      	push	{r3, lr}

  exti0_irq_init();
 80018d2:	f7ff fd3d 	bl	8001350 <exti0_irq_init>
  exti1_irq_init();
 80018d6:	f7ff fd73 	bl	80013c0 <exti1_irq_init>
  exti2_irq_init();
 80018da:	f7ff fda9 	bl	8001430 <exti2_irq_init>
  exti3_irq_init();
 80018de:	f7ff fddf 	bl	80014a0 <exti3_irq_init>
  exti4_irq_init();
 80018e2:	f7ff fe15 	bl	8001510 <exti4_irq_init>
  exti5_9_irq_init();
 80018e6:	f7ff fe4b 	bl	8001580 <exti5_9_irq_init>
  exti10_15_irq_init();
 80018ea:	f7ff feb9 	bl	8001660 <exti10_15_irq_init>
  exti16_exti31_exti33_irq_init();
 80018ee:	f7ff ff37 	bl	8001760 <exti16_exti31_exti33_irq_init>
  exti17_irq_init();
 80018f2:	f7ff ff3d 	bl	8001770 <exti17_irq_init>
  exti18_irq_init();
 80018f6:	f7ff ff43 	bl	8001780 <exti18_irq_init>
  exti19_irq_init();
 80018fa:	f7ff ff49 	bl	8001790 <exti19_irq_init>
  exti20_exti21_irq_init();
 80018fe:	f7ff ff4f 	bl	80017a0 <exti20_exti21_irq_init>

  tim1_tim16_tim17_irq_init();
 8001902:	f7ff ff75 	bl	80017f0 <tim1_tim16_tim17_irq_init>
  tim2_irq_init();
 8001906:	f7ff ffcb 	bl	80018a0 <tim2_irq_init>

  usart1_irq_init();
 800190a:	f7ff ff51 	bl	80017b0 <usart1_irq_init>
  lpuart1_irq_init();
 800190e:	f7ff ff67 	bl	80017e0 <lpuart1_irq_init>
}
 8001912:	bf00      	nop
 8001914:	bd08      	pop	{r3, pc}
 8001916:	bf00      	nop
	...

08001920 <bd_init>:
/*===========================================================================*/

/**
 * @brief   Initializes the backup domain.
 */
__STATIC_INLINE void bd_init(void) {
 8001920:	b082      	sub	sp, #8
  uint32_t bdcr;

  /* Current settings.*/
  bdcr = RCC->BDCR;
 8001922:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001926:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800192a:	9301      	str	r3, [sp, #4]
    bdcr |= RCC_BDCR_RTCEN;
  }
#endif

  /* Selectors.*/
  bdcr &= ~(STM32_RTCSEL_MASK | STM32_LSCOSEL_MASK);
 800192c:	9b01      	ldr	r3, [sp, #4]
 800192e:	f023 2303 	bic.w	r3, r3, #50332416	@ 0x3000300
 8001932:	9301      	str	r3, [sp, #4]
  bdcr |= STM32_RTCSEL | STM32_LSCOSEL;
 8001934:	9b01      	ldr	r3, [sp, #4]
 8001936:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800193a:	9301      	str	r3, [sp, #4]

  /* Final settings.*/
  RCC->BDCR = bdcr;
 800193c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001940:	9b01      	ldr	r3, [sp, #4]
 8001942:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
}
 8001946:	bf00      	nop
 8001948:	b002      	add	sp, #8
 800194a:	4770      	bx	lr
 800194c:	0000      	movs	r0, r0
	...

08001950 <bd_reset>:
 *          of the whole BKP domain.
 */
__STATIC_INLINE void bd_reset(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001950:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001954:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8001958:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800195c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8001960:	d00a      	beq.n	8001978 <bd_reset+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001962:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001966:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800196a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    RCC->BDCR = 0U;
 800196e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001972:	2200      	movs	r2, #0
 8001974:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  }
}
 8001978:	bf00      	nop
 800197a:	4770      	bx	lr
 800197c:	0000      	movs	r0, r0
	...

08001980 <lse_init>:
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN;
 8001980:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001984:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8001988:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800198c:	f043 0319 	orr.w	r3, r3, #25
 8001990:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  while ((RCC->BDCR & (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) !=
 8001994:	bf00      	nop
 8001996:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800199a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800199e:	f003 0302 	and.w	r3, r3, #2
 80019a2:	2b02      	cmp	r3, #2
 80019a4:	d1f7      	bne.n	8001996 <lse_init+0x16>
         (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) {
  }
#endif
#endif
}
 80019a6:	bf00      	nop
 80019a8:	bf00      	nop
 80019aa:	4770      	bx	lr
 80019ac:	0000      	movs	r0, r0
	...

080019b0 <lsi_init>:

__STATIC_INLINE void lsi_init(void) {

#if STM32_LSI1_ENABLED
  /* LSI1 activation.*/
  RCC->CSR |= RCC_CSR_LSI1ON;
 80019b0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80019b4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80019b8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80019bc:	f043 0301 	orr.w	r3, r3, #1
 80019c0:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
  while ((RCC->CSR & RCC_CSR_LSI1RDY) == 0U) {
 80019c4:	bf00      	nop
 80019c6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80019ca:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80019ce:	f003 0302 	and.w	r3, r3, #2
 80019d2:	2b00      	cmp	r3, #0
 80019d4:	d0f7      	beq.n	80019c6 <lsi_init+0x16>
  /* LSI2 activation.*/
  RCC->CSR |= RCC_CSR_LSI2ON;
  while ((RCC->CSR & RCC_CSR_LSI2RDY) == 0U) {
  }
#endif
}
 80019d6:	bf00      	nop
 80019d8:	bf00      	nop
 80019da:	4770      	bx	lr
 80019dc:	0000      	movs	r0, r0
	...

080019e0 <msi_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void msi_enable(void) {

  RCC->CR |= RCC_CR_MSION;
 80019e0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80019e4:	681b      	ldr	r3, [r3, #0]
 80019e6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80019ea:	f043 0301 	orr.w	r3, r3, #1
 80019ee:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 80019f0:	bf00      	nop
 80019f2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80019f6:	681b      	ldr	r3, [r3, #0]
 80019f8:	f003 0302 	and.w	r3, r3, #2
 80019fc:	2b00      	cmp	r3, #0
 80019fe:	d0f8      	beq.n	80019f2 <msi_enable+0x12>
    /* Wait until MSI is stable.*/
  }
}
 8001a00:	bf00      	nop
 8001a02:	bf00      	nop
 8001a04:	4770      	bx	lr
 8001a06:	bf00      	nop
	...

08001a10 <msi_reset>:
__STATIC_INLINE void msi_disable(void) {

  RCC->CR &= ~RCC_CR_MSION;
}

__STATIC_INLINE void msi_reset(void) {
 8001a10:	b508      	push	{r3, lr}

  /* Resetting MSI defaults.
     Note from RM0432: MSIRANGE can be modified when MSI is OFF (MSION=0)
     or when MSI is ready (MSIRDY=1). MSIRANGE must NOT be modified when
     MSI is ON and NOT ready (MSION=1 and MSIRDY=0).*/
  RCC->CR = (RCC->CR & ~RCC_CR_MSIRANGE_Msk) | RCC_CR_MSIRANGE_6;
 8001a12:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001a16:	681b      	ldr	r3, [r3, #0]
 8001a18:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8001a1c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001a20:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 8001a24:	6013      	str	r3, [r2, #0]

  /* Making sure MSI is active and ready.*/
  msi_enable();
 8001a26:	f7ff ffdb 	bl	80019e0 <msi_enable>

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = RCC_CFGR_SW_MSI;
 8001a2a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001a2e:	2200      	movs	r2, #0
 8001a30:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI) {
 8001a32:	bf00      	nop
 8001a34:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001a38:	689b      	ldr	r3, [r3, #8]
 8001a3a:	f003 030c 	and.w	r3, r3, #12
 8001a3e:	2b00      	cmp	r3, #0
 8001a40:	d1f8      	bne.n	8001a34 <msi_reset+0x24>
    /* Wait until MSI is selected.*/
  }
}
 8001a42:	bf00      	nop
 8001a44:	bf00      	nop
 8001a46:	bd08      	pop	{r3, pc}
	...

08001a50 <msi_init>:

__STATIC_INLINE void msi_init(void) {
 8001a50:	b082      	sub	sp, #8
     Trim fields are not altered from reset values.*/

  /* MSIRANGE can be set only when MSI is OFF or READY, it is ready after
     reset.*/
#if STM32_MSIPLL_ENABLED
  cr = STM32_MSIRANGE | RCC_CR_MSIPLLEN | RCC_CR_MSION;
 8001a52:	2365      	movs	r3, #101	@ 0x65
 8001a54:	9301      	str	r3, [sp, #4]
#else
  cr = STM32_MSIRANGE | RCC_CR_MSION;
#endif
  RCC->CR = cr;
 8001a56:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001a5a:	9b01      	ldr	r3, [sp, #4]
 8001a5c:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8001a5e:	bf00      	nop
 8001a60:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001a64:	681b      	ldr	r3, [r3, #0]
 8001a66:	f003 0302 	and.w	r3, r3, #2
 8001a6a:	2b00      	cmp	r3, #0
 8001a6c:	d0f8      	beq.n	8001a60 <msi_init+0x10>
    /* Wait until MSI is stable.*/
  }

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0U;
 8001a6e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001a72:	2200      	movs	r2, #0
 8001a74:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8001a76:	bf00      	nop
 8001a78:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001a7c:	689b      	ldr	r3, [r3, #8]
 8001a7e:	f003 030c 	and.w	r3, r3, #12
 8001a82:	2b00      	cmp	r3, #0
 8001a84:	d1f8      	bne.n	8001a78 <msi_init+0x28>
    ;                                       /* Wait until MSI is selected.  */
}
 8001a86:	bf00      	nop
 8001a88:	bf00      	nop
 8001a8a:	b002      	add	sp, #8
 8001a8c:	4770      	bx	lr
 8001a8e:	bf00      	nop

08001a90 <hsi16_enable>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void hsi16_enable(void) {

  RCC->CR |= RCC_CR_HSION;
 8001a90:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001a94:	681b      	ldr	r3, [r3, #0]
 8001a96:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001a9a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001a9e:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0U) {
 8001aa0:	bf00      	nop
 8001aa2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001aa6:	681b      	ldr	r3, [r3, #0]
 8001aa8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8001aac:	2b00      	cmp	r3, #0
 8001aae:	d0f8      	beq.n	8001aa2 <hsi16_enable+0x12>
    /* Waiting for HSI16 activation.*/
  }
}
 8001ab0:	bf00      	nop
 8001ab2:	bf00      	nop
 8001ab4:	4770      	bx	lr
 8001ab6:	bf00      	nop
	...

08001ac0 <hsi16_init>:
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI) {
    /* Wait until HSI is selected.*/
  }
}

__STATIC_INLINE void hsi16_init(void) {
 8001ac0:	b508      	push	{r3, lr}

#if STM32_HSI16_ENABLED
  /* HSI activation.*/
  hsi16_enable();
 8001ac2:	f7ff ffe5 	bl	8001a90 <hsi16_enable>
#endif
}
 8001ac6:	bf00      	nop
 8001ac8:	bd08      	pop	{r3, pc}
 8001aca:	bf00      	nop
 8001acc:	0000      	movs	r0, r0
	...

08001ad0 <hsi48_init>:

#if STM32_HSI48_ENABLED
  /* HSI activation.*/
  hsi48_enable();
#endif
}
 8001ad0:	bf00      	nop
 8001ad2:	4770      	bx	lr
	...

08001ae0 <hse32_enable>:
/*===========================================================================*/

__STATIC_INLINE void hse32_enable(void) {

  /* Set HSE32 SYSCLK prescaler.*/
  RCC->CR |= STM32_HSE32PRE;
 8001ae0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001ae4:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001ae8:	681b      	ldr	r3, [r3, #0]
 8001aea:	6013      	str	r3, [r2, #0]

  /* HSE32 activation.*/
  RCC->CR |= RCC_CR_HSEON;
 8001aec:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001af0:	681b      	ldr	r3, [r3, #0]
 8001af2:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001af6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001afa:	6013      	str	r3, [r2, #0]

  while ((RCC->CR & RCC_CR_HSERDY) == 0U) {
 8001afc:	bf00      	nop
 8001afe:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001b02:	681b      	ldr	r3, [r3, #0]
 8001b04:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8001b08:	2b00      	cmp	r3, #0
 8001b0a:	d0f8      	beq.n	8001afe <hse32_enable+0x1e>
    /* Wait until HSE32 is stable.    */
  }
}
 8001b0c:	bf00      	nop
 8001b0e:	bf00      	nop
 8001b10:	4770      	bx	lr
 8001b12:	bf00      	nop
	...

08001b20 <hse32_init>:

__STATIC_INLINE void hse32_init(void) {
 8001b20:	b508      	push	{r3, lr}

#if STM32_HSE32_ENABLED
  hse32_enable();
 8001b22:	f7ff ffdd 	bl	8001ae0 <hse32_enable>
#endif
}
 8001b26:	bf00      	nop
 8001b28:	bd08      	pop	{r3, pc}
 8001b2a:	bf00      	nop
 8001b2c:	0000      	movs	r0, r0
	...

08001b30 <pll_not_locked>:
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE bool pll_not_locked(void) {

  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8001b30:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001b34:	681b      	ldr	r3, [r3, #0]
 8001b36:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8001b3a:	2b00      	cmp	r3, #0
 8001b3c:	bf0c      	ite	eq
 8001b3e:	2301      	moveq	r3, #1
 8001b40:	2300      	movne	r3, #0
 8001b42:	b2db      	uxtb	r3, r3
}
 8001b44:	4618      	mov	r0, r3
 8001b46:	4770      	bx	lr
	...

08001b50 <pll_wait_lock>:

__STATIC_INLINE void pll_wait_lock(void) {
 8001b50:	b508      	push	{r3, lr}

  while (pll_not_locked()) {
 8001b52:	bf00      	nop
 8001b54:	f7ff ffec 	bl	8001b30 <pll_not_locked>
 8001b58:	4603      	mov	r3, r0
 8001b5a:	2b00      	cmp	r3, #0
 8001b5c:	d1fa      	bne.n	8001b54 <pll_wait_lock+0x4>
    /* Waiting for PLL lock.*/
  }
}
 8001b5e:	bf00      	nop
 8001b60:	bf00      	nop
 8001b62:	bd08      	pop	{r3, pc}
	...

08001b70 <pll_init>:

#endif /* STM32_RCC_HAS_PLL */

__STATIC_INLINE void pll_init(void) {
 8001b70:	b508      	push	{r3, lr}

#if STM32_RCC_HAS_PLL
#if STM32_ACTIVATE_PLL
  /* PLLM and PLLSRC are common to all PLLs.*/
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 8001b72:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001b76:	4a07      	ldr	r2, [pc, #28]	@ (8001b94 <pll_init+0x24>)
 8001b78:	60da      	str	r2, [r3, #12]
                 STM32_PLLP   | STM32_PLLPEN |
                 STM32_PLLN   | STM32_PLLM   |
                 STM32_PLLSRC;

  /* PLL activation.*/
  RCC->CR |= RCC_CR_PLLON;
 8001b7a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001b7e:	681b      	ldr	r3, [r3, #0]
 8001b80:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001b84:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001b88:	6013      	str	r3, [r2, #0]

  pll_wait_lock();
 8001b8a:	f7ff ffe1 	bl	8001b50 <pll_wait_lock>
#endif
#endif
}
 8001b8e:	bf00      	nop
 8001b90:	bd08      	pop	{r3, pc}
 8001b92:	bf00      	nop
 8001b94:	22022001 	.word	0x22022001
	...

08001ba0 <pllsai1_init>:
__STATIC_INLINE void pllsai1_init(void) {

#if STM32_RCC_HAS_PLLSAI1
#if STM32_ACTIVATE_PLLSAI1
  /* PLLSAI1 activation.*/
  RCC->PLLSAI1CFGR = STM32_PLLSAI1R | STM32_PLLSAI1REN |
 8001ba0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001ba4:	4a0a      	ldr	r2, [pc, #40]	@ (8001bd0 <pllsai1_init+0x30>)
 8001ba6:	611a      	str	r2, [r3, #16]
                     STM32_PLLSAI1Q | STM32_PLLSAI1QEN |
                     STM32_PLLSAI1P | STM32_PLLSAI1PEN |
                     STM32_PLLSAI1N;
  RCC->CR |= RCC_CR_PLLSAI1ON;
 8001ba8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001bac:	681b      	ldr	r3, [r3, #0]
 8001bae:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001bb2:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8001bb6:	6013      	str	r3, [r2, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0U)
 8001bb8:	bf00      	nop
 8001bba:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001bbe:	681b      	ldr	r3, [r3, #0]
 8001bc0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8001bc4:	2b00      	cmp	r3, #0
 8001bc6:	d0f8      	beq.n	8001bba <pllsai1_init+0x1a>
    ;
#endif
#endif
}
 8001bc8:	bf00      	nop
 8001bca:	bf00      	nop
 8001bcc:	4770      	bx	lr
 8001bce:	bf00      	nop
 8001bd0:	23021800 	.word	0x23021800
	...

08001be0 <flash_set_acr>:
/**
 * @brief   Safe setting of flash ACR register.
 *
 * @param[in] acr       value for the ACR register
 */
__STATIC_INLINE void flash_set_acr(uint32_t acr) {
 8001be0:	b082      	sub	sp, #8
 8001be2:	9001      	str	r0, [sp, #4]

  FLASH->ACR = acr;
 8001be4:	4a07      	ldr	r2, [pc, #28]	@ (8001c04 <flash_set_acr+0x24>)
 8001be6:	9b01      	ldr	r3, [sp, #4]
 8001be8:	6013      	str	r3, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) != (acr & FLASH_ACR_LATENCY_Msk)) {
 8001bea:	bf00      	nop
 8001bec:	4b05      	ldr	r3, [pc, #20]	@ (8001c04 <flash_set_acr+0x24>)
 8001bee:	681a      	ldr	r2, [r3, #0]
 8001bf0:	9b01      	ldr	r3, [sp, #4]
 8001bf2:	4053      	eors	r3, r2
 8001bf4:	f003 0307 	and.w	r3, r3, #7
 8001bf8:	2b00      	cmp	r3, #0
 8001bfa:	d1f7      	bne.n	8001bec <flash_set_acr+0xc>
    /* Waiting for flash wait states setup.*/
  }
}
 8001bfc:	bf00      	nop
 8001bfe:	bf00      	nop
 8001c00:	b002      	add	sp, #8
 8001c02:	4770      	bx	lr
 8001c04:	58004000 	.word	0x58004000
	...

08001c10 <hal_lld_set_static_pwr>:
 * @brief   Configures the PWR unit.
 * @note    CR1, CR2 and CR5 are not initialized inside this function.
 */
__STATIC_INLINE void hal_lld_set_static_pwr(void) {
  /* Static PWR configurations.*/
  PWR->CR3   = STM32_PWR_CR3;
 8001c10:	4b16      	ldr	r3, [pc, #88]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c12:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8001c16:	609a      	str	r2, [r3, #8]
  PWR->CR4   = STM32_PWR_CR4;
 8001c18:	4b14      	ldr	r3, [pc, #80]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c1a:	2200      	movs	r2, #0
 8001c1c:	60da      	str	r2, [r3, #12]
  PWR->PUCRA = STM32_PWR_PUCRA;
 8001c1e:	4b13      	ldr	r3, [pc, #76]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c20:	2200      	movs	r2, #0
 8001c22:	621a      	str	r2, [r3, #32]
  PWR->PDCRA = STM32_PWR_PDCRA;
 8001c24:	4b11      	ldr	r3, [pc, #68]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c26:	2200      	movs	r2, #0
 8001c28:	625a      	str	r2, [r3, #36]	@ 0x24
  PWR->PUCRB = STM32_PWR_PUCRB;
 8001c2a:	4b10      	ldr	r3, [pc, #64]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c2c:	2200      	movs	r2, #0
 8001c2e:	629a      	str	r2, [r3, #40]	@ 0x28
  PWR->PDCRB = STM32_PWR_PDCRB;
 8001c30:	4b0e      	ldr	r3, [pc, #56]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c32:	2200      	movs	r2, #0
 8001c34:	62da      	str	r2, [r3, #44]	@ 0x2c
  PWR->PUCRC = STM32_PWR_PUCRC;
 8001c36:	4b0d      	ldr	r3, [pc, #52]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c38:	2200      	movs	r2, #0
 8001c3a:	631a      	str	r2, [r3, #48]	@ 0x30
  PWR->PDCRC = STM32_PWR_PDCRC;
 8001c3c:	4b0b      	ldr	r3, [pc, #44]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c3e:	2200      	movs	r2, #0
 8001c40:	635a      	str	r2, [r3, #52]	@ 0x34
  PWR->PUCRD = STM32_PWR_PUCRD;
 8001c42:	4b0a      	ldr	r3, [pc, #40]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c44:	2200      	movs	r2, #0
 8001c46:	639a      	str	r2, [r3, #56]	@ 0x38
  PWR->PDCRD = STM32_PWR_PDCRD;
 8001c48:	4b08      	ldr	r3, [pc, #32]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c4a:	2200      	movs	r2, #0
 8001c4c:	63da      	str	r2, [r3, #60]	@ 0x3c
  PWR->PUCRE = STM32_PWR_PUCRE;
 8001c4e:	4b07      	ldr	r3, [pc, #28]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c50:	2200      	movs	r2, #0
 8001c52:	641a      	str	r2, [r3, #64]	@ 0x40
  PWR->PDCRE = STM32_PWR_PDCRE;
 8001c54:	4b05      	ldr	r3, [pc, #20]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c56:	2200      	movs	r2, #0
 8001c58:	645a      	str	r2, [r3, #68]	@ 0x44
  PWR->PUCRH = STM32_PWR_PUCRH;
 8001c5a:	4b04      	ldr	r3, [pc, #16]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c5c:	2200      	movs	r2, #0
 8001c5e:	659a      	str	r2, [r3, #88]	@ 0x58
  PWR->PDCRH = STM32_PWR_PDCRH;
 8001c60:	4b02      	ldr	r3, [pc, #8]	@ (8001c6c <hal_lld_set_static_pwr+0x5c>)
 8001c62:	2200      	movs	r2, #0
 8001c64:	65da      	str	r2, [r3, #92]	@ 0x5c
}
 8001c66:	bf00      	nop
 8001c68:	4770      	bx	lr
 8001c6a:	bf00      	nop
 8001c6c:	58000400 	.word	0x58000400

08001c70 <hal_lld_set_static_clocks>:

/**
 * @brief   Initializes static muxes and dividers.
 */
__STATIC_INLINE void hal_lld_set_static_clocks(void) {
 8001c70:	b082      	sub	sp, #8
  uint32_t ccipr;

  /* Clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 8001c72:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001c76:	2200      	movs	r2, #0
 8001c78:	609a      	str	r2, [r3, #8]
              STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;

  /* Waiting for PPRE2, PPRE1 and HPRE applied. */
  while ((RCC->CFGR & (RCC_CFGR_PPRE2F_Msk | RCC_CFGR_PPRE1F_Msk |
 8001c7a:	bf00      	nop
 8001c7c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001c80:	689b      	ldr	r3, [r3, #8]
 8001c82:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
                       RCC_CFGR_HPREF_Msk)) !=
 8001c86:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
 8001c8a:	d1f7      	bne.n	8001c7c <hal_lld_set_static_clocks+0xc>
         (RCC_CFGR_PPRE2F | RCC_CFGR_PPRE1F | RCC_CFGR_HPREF))
    ;

  /* CCIPR2 register initialization, note, must take care of the _OFF
     pseudo settings.*/
  ccipr = STM32_RNGSEL    | STM32_ADCSEL    | STM32_CLK48SEL  |
 8001c8c:	f04f 5350 	mov.w	r3, #872415232	@ 0x34000000
 8001c90:	9301      	str	r3, [sp, #4]
          STM32_LPTIM2SEL | STM32_LPTIM1SEL | STM32_I2C1SEL   |
          STM32_USART1SEL | STM32_LPUART1SEL;
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
    ccipr |= STM32_SAI1SEL;
#endif
    RCC->CCIPR = ccipr;
 8001c92:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001c96:	9b01      	ldr	r3, [sp, #4]
 8001c98:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
}
 8001c9c:	bf00      	nop
 8001c9e:	b002      	add	sp, #8
 8001ca0:	4770      	bx	lr
 8001ca2:	bf00      	nop
	...

08001cb0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8001cb0:	b508      	push	{r3, lr}

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8001cb2:	f000 fd5d 	bl	8002770 <dmaInit>
#endif

  /* NVIC initialization.*/
  nvicInit();
 8001cb6:	f7ff faf3 	bl	80012a0 <nvicInit>

  /* IRQ subsystem initialization.*/
  irqInit();
 8001cba:	f7ff fe09 	bl	80018d0 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR2 = PWR_CR2_PVDE | (STM32_PLS & STM32_PLS_MASK);
#else
  PWR->CR2 = 0;
 8001cbe:	4b02      	ldr	r3, [pc, #8]	@ (8001cc8 <hal_lld_init+0x18>)
 8001cc0:	2200      	movs	r2, #0
 8001cc2:	605a      	str	r2, [r3, #4]

  /* Enabling independent VDDUSB.*/
#if HAL_USE_USB
  PWR->CR2 |= PWR_CR2_USV;
#endif /* HAL_USE_USB */
}
 8001cc4:	bf00      	nop
 8001cc6:	bd08      	pop	{r3, pc}
 8001cc8:	58000400 	.word	0x58000400
 8001ccc:	00000000 	.word	0x00000000

08001cd0 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8001cd0:	b508      	push	{r3, lr}

#if !STM32_NO_INIT
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~0);
 8001cd2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001cd6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001cd8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001cdc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001ce0:	629a      	str	r2, [r3, #40]	@ 0x28
 8001ce2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001ce6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ce8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001cec:	2200      	movs	r2, #0
 8001cee:	629a      	str	r2, [r3, #40]	@ 0x28
 8001cf0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001cf4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 8001cf6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001cfa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001cfc:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001d00:	f063 039f 	orn	r3, r3, #159	@ 0x9f
 8001d04:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001d06:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d0a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d0c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001d10:	f003 039f 	and.w	r3, r3, #159	@ 0x9f
 8001d14:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8001d16:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d1a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccResetAHB3(~0);
 8001d1c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d20:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001d22:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d26:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001d2a:	631a      	str	r2, [r3, #48]	@ 0x30
 8001d2c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d30:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001d32:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d36:	2200      	movs	r2, #0
 8001d38:	631a      	str	r2, [r3, #48]	@ 0x30
 8001d3a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d3e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
  rccResetAPB1R1(~0);
 8001d40:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d44:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001d46:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d4a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001d4e:	639a      	str	r2, [r3, #56]	@ 0x38
 8001d50:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d54:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001d56:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d5a:	2200      	movs	r2, #0
 8001d5c:	639a      	str	r2, [r3, #56]	@ 0x38
 8001d5e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d62:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
  rccResetAPB1R2(~0);
 8001d64:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d68:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001d6a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d6e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001d72:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001d74:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d78:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001d7a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d7e:	2200      	movs	r2, #0
 8001d80:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001d82:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d86:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  rccResetAPB2(~0);
 8001d88:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d8c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001d8e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d92:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001d96:	641a      	str	r2, [r3, #64]	@ 0x40
 8001d98:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001d9c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001d9e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001da2:	2200      	movs	r2, #0
 8001da4:	641a      	str	r2, [r3, #64]	@ 0x40
 8001da6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001daa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40

  /* Flash setup for selected MSI speed setting.*/
  flash_set_acr(FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 8001dac:	f44f 60e0 	mov.w	r0, #1792	@ 0x700
 8001db0:	f7ff ff16 	bl	8001be0 <flash_set_acr>
                STM32_MSI_FLASHBITS);

  /* Static PWR configurations.*/
  hal_lld_set_static_pwr();
 8001db4:	f7ff ff2c 	bl	8001c10 <hal_lld_set_static_pwr>

  /* Core voltage setup, backup domain access enabled and left open.*/
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 8001db8:	4b28      	ldr	r3, [pc, #160]	@ (8001e5c <stm32_clock_init+0x18c>)
 8001dba:	f44f 7240 	mov.w	r2, #768	@ 0x300
 8001dbe:	601a      	str	r2, [r3, #0]

  /* Additional PWR configurations.*/
  PWR->CR2  = STM32_PWR_CR2;
 8001dc0:	4b26      	ldr	r3, [pc, #152]	@ (8001e5c <stm32_clock_init+0x18c>)
 8001dc2:	2202      	movs	r2, #2
 8001dc4:	605a      	str	r2, [r3, #4]

  /* Wait until regulator is stable. */
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)
 8001dc6:	bf00      	nop
 8001dc8:	4b24      	ldr	r3, [pc, #144]	@ (8001e5c <stm32_clock_init+0x18c>)
 8001dca:	695b      	ldr	r3, [r3, #20]
 8001dcc:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8001dd0:	2b00      	cmp	r3, #0
 8001dd2:	d1f9      	bne.n	8001dc8 <stm32_clock_init+0xf8>
    ;

  /* MSI clock reset.*/
  msi_reset();
 8001dd4:	f7ff fe1c 	bl	8001a10 <msi_reset>

  /* Backup domain reset.*/
  bd_reset();
 8001dd8:	f7ff fdba 	bl	8001950 <bd_reset>

  /* Clocks setup.*/
  lse_init();
 8001ddc:	f7ff fdd0 	bl	8001980 <lse_init>
  lsi_init();
 8001de0:	f7ff fde6 	bl	80019b0 <lsi_init>
  msi_init();
 8001de4:	f7ff fe34 	bl	8001a50 <msi_init>
  hsi16_init();
 8001de8:	f7ff fe6a 	bl	8001ac0 <hsi16_init>
  hsi48_init();
 8001dec:	f7ff fe70 	bl	8001ad0 <hsi48_init>
  hse32_init();
 8001df0:	f7ff fe96 	bl	8001b20 <hse32_init>

  /* Backup domain initializations.*/
  bd_init();
 8001df4:	f7ff fd94 	bl	8001920 <bd_init>

  /* Static clocks setup.*/
  hal_lld_set_static_clocks();
 8001df8:	f7ff ff3a 	bl	8001c70 <hal_lld_set_static_clocks>

  /* PLLs activation, if required.*/
  pll_init();
 8001dfc:	f7ff feb8 	bl	8001b70 <pll_init>
  pllsai1_init();
 8001e00:	f7ff fece 	bl	8001ba0 <pllsai1_init>

  /* Extended clock recovery register (HCLK2, HCLK4, HCLK5). */
  RCC->EXTCFGR = STM32_RFCSSSEL | STM32_C2HPRE | STM32_SHDHPRE;
 8001e04:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001e08:	2280      	movs	r2, #128	@ 0x80
 8001e0a:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

  /* Waiting for C2HPRE and SHDHPRE. */
  while ((RCC->EXTCFGR & (RCC_EXTCFGR_C2HPREF_Msk |
 8001e0e:	bf00      	nop
 8001e10:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001e14:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8001e18:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
                          RCC_EXTCFGR_SHDHPREF_Msk)) !=
 8001e1c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8001e20:	d1f6      	bne.n	8001e10 <stm32_clock_init+0x140>
         (RCC_EXTCFGR_C2HPREF | RCC_EXTCFGR_SHDHPREF))
    ;

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS) {
    flash_set_acr((FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS);
 8001e22:	4b0f      	ldr	r3, [pc, #60]	@ (8001e60 <stm32_clock_init+0x190>)
 8001e24:	681b      	ldr	r3, [r3, #0]
 8001e26:	f023 0307 	bic.w	r3, r3, #7
 8001e2a:	f043 0301 	orr.w	r3, r3, #1
 8001e2e:	4618      	mov	r0, r3
 8001e30:	f7ff fed6 	bl	8001be0 <flash_set_acr>
  }

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001e34:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001e38:	689b      	ldr	r3, [r3, #8]
 8001e3a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8001e3e:	f043 0302 	orr.w	r3, r3, #2
 8001e42:	6093      	str	r3, [r2, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001e44:	bf00      	nop
 8001e46:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8001e4a:	689b      	ldr	r3, [r3, #8]
 8001e4c:	f003 030c 	and.w	r3, r3, #12
 8001e50:	2b08      	cmp	r3, #8
 8001e52:	d1f8      	bne.n	8001e46 <stm32_clock_init+0x176>
  if (STM32_FLASHBITS < STM32_MSI_FLASHBITS) {
    flash_set_acr((FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS);
  }

#endif /* STM32_NO_INIT */
}
 8001e54:	bf00      	nop
 8001e56:	bf00      	nop
 8001e58:	bd08      	pop	{r3, pc}
 8001e5a:	bf00      	nop
 8001e5c:	58000400 	.word	0x58000400
 8001e60:	58004000 	.word	0x58004000
	...

08001e70 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001e70:	b500      	push	{lr}
 8001e72:	b083      	sub	sp, #12
 8001e74:	2330      	movs	r3, #48	@ 0x30
 8001e76:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001e78:	9b01      	ldr	r3, [sp, #4]
 8001e7a:	f383 8811 	msr	BASEPRI, r3
}
 8001e7e:	bf00      	nop
}
 8001e80:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 8001e82:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 8001e84:	f001 faac 	bl	80033e0 <__dbg_check_lock_from_isr>
}
 8001e88:	bf00      	nop
 8001e8a:	b003      	add	sp, #12
 8001e8c:	f85d fb04 	ldr.w	pc, [sp], #4

08001e90 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001e90:	b500      	push	{lr}
 8001e92:	b083      	sub	sp, #12

  __dbg_check_unlock_from_isr();
 8001e94:	f001 facc 	bl	8003430 <__dbg_check_unlock_from_isr>
 8001e98:	2300      	movs	r3, #0
 8001e9a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001e9c:	9b01      	ldr	r3, [sp, #4]
 8001e9e:	f383 8811 	msr	BASEPRI, r3
}
 8001ea2:	bf00      	nop
}
 8001ea4:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 8001ea6:	bf00      	nop
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 8001ea8:	bf00      	nop
 8001eaa:	b003      	add	sp, #12
 8001eac:	f85d fb04 	ldr.w	pc, [sp], #4

08001eb0 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 8001eb0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8001eb2:	f7ff ffdd 	bl	8001e70 <chSysLockFromISR.lto_priv.0>
}
 8001eb6:	bf00      	nop
 8001eb8:	bd08      	pop	{r3, pc}
 8001eba:	bf00      	nop
 8001ebc:	0000      	movs	r0, r0
	...

08001ec0 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 8001ec0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8001ec2:	f7ff ffe5 	bl	8001e90 <chSysUnlockFromISR.lto_priv.0>
}
 8001ec6:	bf00      	nop
 8001ec8:	bd08      	pop	{r3, pc}
 8001eca:	bf00      	nop
 8001ecc:	0000      	movs	r0, r0
	...

08001ed0 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8001ed0:	b500      	push	{lr}
 8001ed2:	b083      	sub	sp, #12
 8001ed4:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 8001ed6:	9801      	ldr	r0, [sp, #4]
 8001ed8:	f001 fa02 	bl	80032e0 <chSysPolledDelayX>
}
 8001edc:	bf00      	nop
 8001ede:	b003      	add	sp, #12
 8001ee0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001ef0 <osalThreadResumeI.lto_priv.1>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001ef0:	b500      	push	{lr}
 8001ef2:	b083      	sub	sp, #12
 8001ef4:	9001      	str	r0, [sp, #4]
 8001ef6:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8001ef8:	9900      	ldr	r1, [sp, #0]
 8001efa:	9801      	ldr	r0, [sp, #4]
 8001efc:	f002 fcb8 	bl	8004870 <chThdResumeI>
}
 8001f00:	bf00      	nop
 8001f02:	b003      	add	sp, #12
 8001f04:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001f10 <adc_lld_vreg_on>:
/**
 * @brief   Enables the ADC voltage regulator.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {
 8001f10:	b500      	push	{lr}
 8001f12:	b083      	sub	sp, #12
 8001f14:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR = 0;   /* See RM.*/
 8001f16:	9b01      	ldr	r3, [sp, #4]
 8001f18:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f1a:	2200      	movs	r2, #0
 8001f1c:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN;
 8001f1e:	9b01      	ldr	r3, [sp, #4]
 8001f20:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f22:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8001f26:	609a      	str	r2, [r3, #8]
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR = STM32_ADC_CR_ADVREGEN;
#endif
  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 8001f28:	f44f 7020 	mov.w	r0, #640	@ 0x280
 8001f2c:	f7ff ffd0 	bl	8001ed0 <osalSysPolledDelayX>
}
 8001f30:	bf00      	nop
 8001f32:	b003      	add	sp, #12
 8001f34:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001f40 <adc_lld_calibrate>:
/**
 * @brief   Calibrates an ADC unit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_calibrate(ADCDriver *adcp) {
 8001f40:	b500      	push	{lr}
 8001f42:	b083      	sub	sp, #12
 8001f44:	9001      	str	r0, [sp, #4]

  osalDbgAssert(adcp->adcm->CR == STM32_ADC_CR_ADVREGEN, "invalid register state");

  /* Differential calibration for master ADC.*/
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCALDIF;
 8001f46:	9b01      	ldr	r3, [sp, #4]
 8001f48:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f4a:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 8001f4e:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCALDIF | ADC_CR_ADCAL;
 8001f50:	9b01      	ldr	r3, [sp, #4]
 8001f52:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f54:	f04f 4250 	mov.w	r2, #3489660928	@ 0xd0000000
 8001f58:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 8001f5a:	bf00      	nop
 8001f5c:	9b01      	ldr	r3, [sp, #4]
 8001f5e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f60:	689b      	ldr	r3, [r3, #8]
 8001f62:	2b00      	cmp	r3, #0
 8001f64:	dbfa      	blt.n	8001f5c <adc_lld_calibrate+0x1c>
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 8001f66:	f44f 7020 	mov.w	r0, #640	@ 0x280
 8001f6a:	f7ff ffb1 	bl	8001ed0 <osalSysPolledDelayX>

  /* Single-ended calibration for master ADC.*/
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN;
 8001f6e:	9b01      	ldr	r3, [sp, #4]
 8001f70:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f72:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8001f76:	609a      	str	r2, [r3, #8]
  adcp->adcm->CR = STM32_ADC_CR_ADVREGEN | ADC_CR_ADCAL;
 8001f78:	9b01      	ldr	r3, [sp, #4]
 8001f7a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f7c:	f04f 4210 	mov.w	r2, #2415919104	@ 0x90000000
 8001f80:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 8001f82:	bf00      	nop
 8001f84:	9b01      	ldr	r3, [sp, #4]
 8001f86:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f88:	689b      	ldr	r3, [r3, #8]
 8001f8a:	2b00      	cmp	r3, #0
 8001f8c:	dbfa      	blt.n	8001f84 <adc_lld_calibrate+0x44>
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
 8001f8e:	f44f 7020 	mov.w	r0, #640	@ 0x280
 8001f92:	f7ff ff9d 	bl	8001ed0 <osalSysPolledDelayX>
  while ((adcp->adcs->CR & ADC_CR_ADCAL) != 0)
    ;

  osalSysPolledDelayX(OSAL_US2RTC(STM32_HCLK, 20));
#endif
}
 8001f96:	bf00      	nop
 8001f98:	b003      	add	sp, #12
 8001f9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f9e:	bf00      	nop

08001fa0 <adc_lld_analog_on>:
/**
 * @brief   Enables the ADC analog circuit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_analog_on(ADCDriver *adcp) {
 8001fa0:	b082      	sub	sp, #8
 8001fa2:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR |= ADC_CR_ADEN;
 8001fa4:	9b01      	ldr	r3, [sp, #4]
 8001fa6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001fa8:	689a      	ldr	r2, [r3, #8]
 8001faa:	9b01      	ldr	r3, [sp, #4]
 8001fac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001fae:	f042 0201 	orr.w	r2, r2, #1
 8001fb2:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRDY) == 0)
 8001fb4:	bf00      	nop
 8001fb6:	9b01      	ldr	r3, [sp, #4]
 8001fb8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001fba:	681b      	ldr	r3, [r3, #0]
 8001fbc:	f003 0301 	and.w	r3, r3, #1
 8001fc0:	2b00      	cmp	r3, #0
 8001fc2:	d0f8      	beq.n	8001fb6 <adc_lld_analog_on+0x16>
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR |= ADC_CR_ADEN;
  while ((adcp->adcs->ISR & ADC_ISR_ADRDY) == 0)
    ;
#endif
}
 8001fc4:	bf00      	nop
 8001fc6:	bf00      	nop
 8001fc8:	b002      	add	sp, #8
 8001fca:	4770      	bx	lr
 8001fcc:	0000      	movs	r0, r0
	...

08001fd0 <adc_lld_stop_adc>:
/**
 * @brief   Stops an ongoing conversion, if any.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_stop_adc(ADCDriver *adcp) {
 8001fd0:	b082      	sub	sp, #8
 8001fd2:	9001      	str	r0, [sp, #4]

  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8001fd4:	9b01      	ldr	r3, [sp, #4]
 8001fd6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001fd8:	689b      	ldr	r3, [r3, #8]
 8001fda:	f003 0304 	and.w	r3, r3, #4
 8001fde:	2b00      	cmp	r3, #0
 8001fe0:	d013      	beq.n	800200a <adc_lld_stop_adc+0x3a>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8001fe2:	9b01      	ldr	r3, [sp, #4]
 8001fe4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001fe6:	689a      	ldr	r2, [r3, #8]
 8001fe8:	9b01      	ldr	r3, [sp, #4]
 8001fea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001fec:	f042 0210 	orr.w	r2, r2, #16
 8001ff0:	609a      	str	r2, [r3, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8001ff2:	bf00      	nop
 8001ff4:	9b01      	ldr	r3, [sp, #4]
 8001ff6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ff8:	689b      	ldr	r3, [r3, #8]
 8001ffa:	f003 0310 	and.w	r3, r3, #16
 8001ffe:	2b00      	cmp	r3, #0
 8002000:	d1f8      	bne.n	8001ff4 <adc_lld_stop_adc+0x24>
      ;
    adcp->adcm->IER = 0;
 8002002:	9b01      	ldr	r3, [sp, #4]
 8002004:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002006:	2200      	movs	r2, #0
 8002008:	605a      	str	r2, [r3, #4]
  }
}
 800200a:	bf00      	nop
 800200c:	b002      	add	sp, #8
 800200e:	4770      	bx	lr

08002010 <adc_lld_serve_dma_interrupt>:
 * @brief   ADC DMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8002010:	b500      	push	{lr}
 8002012:	b083      	sub	sp, #12
 8002014:	9001      	str	r0, [sp, #4]
 8002016:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8002018:	9b00      	ldr	r3, [sp, #0]
 800201a:	f003 0308 	and.w	r3, r3, #8
 800201e:	2b00      	cmp	r3, #0
 8002020:	d02d      	beq.n	800207e <adc_lld_serve_dma_interrupt+0x6e>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8002022:	9801      	ldr	r0, [sp, #4]
 8002024:	f000 fa84 	bl	8002530 <adc_lld_stop_conversion>
 8002028:	9b01      	ldr	r3, [sp, #4]
 800202a:	691b      	ldr	r3, [r3, #16]
 800202c:	689b      	ldr	r3, [r3, #8]
 800202e:	2b00      	cmp	r3, #0
 8002030:	d013      	beq.n	800205a <adc_lld_serve_dma_interrupt+0x4a>
 8002032:	9b01      	ldr	r3, [sp, #4]
 8002034:	2205      	movs	r2, #5
 8002036:	701a      	strb	r2, [r3, #0]
 8002038:	9b01      	ldr	r3, [sp, #4]
 800203a:	691b      	ldr	r3, [r3, #16]
 800203c:	689b      	ldr	r3, [r3, #8]
 800203e:	2101      	movs	r1, #1
 8002040:	9801      	ldr	r0, [sp, #4]
 8002042:	4798      	blx	r3
 8002044:	9b01      	ldr	r3, [sp, #4]
 8002046:	781b      	ldrb	r3, [r3, #0]
 8002048:	2b05      	cmp	r3, #5
 800204a:	d10c      	bne.n	8002066 <adc_lld_serve_dma_interrupt+0x56>
 800204c:	9b01      	ldr	r3, [sp, #4]
 800204e:	2202      	movs	r2, #2
 8002050:	701a      	strb	r2, [r3, #0]
 8002052:	9b01      	ldr	r3, [sp, #4]
 8002054:	2200      	movs	r2, #0
 8002056:	611a      	str	r2, [r3, #16]
 8002058:	e005      	b.n	8002066 <adc_lld_serve_dma_interrupt+0x56>
 800205a:	9b01      	ldr	r3, [sp, #4]
 800205c:	2202      	movs	r2, #2
 800205e:	701a      	strb	r2, [r3, #0]
 8002060:	9b01      	ldr	r3, [sp, #4]
 8002062:	2200      	movs	r2, #0
 8002064:	611a      	str	r2, [r3, #16]
 8002066:	f7ff ff23 	bl	8001eb0 <osalSysLockFromISR.lto_priv.0>
 800206a:	9b01      	ldr	r3, [sp, #4]
 800206c:	3314      	adds	r3, #20
 800206e:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8002072:	4618      	mov	r0, r3
 8002074:	f7ff ff3c 	bl	8001ef0 <osalThreadResumeI.lto_priv.1>
 8002078:	f7ff ff22 	bl	8001ec0 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800207c:	e05d      	b.n	800213a <adc_lld_serve_dma_interrupt+0x12a>
    if (adcp->grpp != NULL) {
 800207e:	9b01      	ldr	r3, [sp, #4]
 8002080:	691b      	ldr	r3, [r3, #16]
 8002082:	2b00      	cmp	r3, #0
 8002084:	d059      	beq.n	800213a <adc_lld_serve_dma_interrupt+0x12a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8002086:	9b00      	ldr	r3, [sp, #0]
 8002088:	f003 0302 	and.w	r3, r3, #2
 800208c:	2b00      	cmp	r3, #0
 800208e:	d045      	beq.n	800211c <adc_lld_serve_dma_interrupt+0x10c>
        _adc_isr_full_code(adcp);
 8002090:	9b01      	ldr	r3, [sp, #4]
 8002092:	691b      	ldr	r3, [r3, #16]
 8002094:	781b      	ldrb	r3, [r3, #0]
 8002096:	2b00      	cmp	r3, #0
 8002098:	d014      	beq.n	80020c4 <adc_lld_serve_dma_interrupt+0xb4>
 800209a:	9b01      	ldr	r3, [sp, #4]
 800209c:	691b      	ldr	r3, [r3, #16]
 800209e:	685b      	ldr	r3, [r3, #4]
 80020a0:	2b00      	cmp	r3, #0
 80020a2:	d04a      	beq.n	800213a <adc_lld_serve_dma_interrupt+0x12a>
 80020a4:	9b01      	ldr	r3, [sp, #4]
 80020a6:	2204      	movs	r2, #4
 80020a8:	701a      	strb	r2, [r3, #0]
 80020aa:	9b01      	ldr	r3, [sp, #4]
 80020ac:	691b      	ldr	r3, [r3, #16]
 80020ae:	685b      	ldr	r3, [r3, #4]
 80020b0:	9801      	ldr	r0, [sp, #4]
 80020b2:	4798      	blx	r3
 80020b4:	9b01      	ldr	r3, [sp, #4]
 80020b6:	781b      	ldrb	r3, [r3, #0]
 80020b8:	2b04      	cmp	r3, #4
 80020ba:	d13e      	bne.n	800213a <adc_lld_serve_dma_interrupt+0x12a>
 80020bc:	9b01      	ldr	r3, [sp, #4]
 80020be:	2203      	movs	r2, #3
 80020c0:	701a      	strb	r2, [r3, #0]
}
 80020c2:	e03a      	b.n	800213a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_full_code(adcp);
 80020c4:	9801      	ldr	r0, [sp, #4]
 80020c6:	f000 fa33 	bl	8002530 <adc_lld_stop_conversion>
 80020ca:	9b01      	ldr	r3, [sp, #4]
 80020cc:	691b      	ldr	r3, [r3, #16]
 80020ce:	685b      	ldr	r3, [r3, #4]
 80020d0:	2b00      	cmp	r3, #0
 80020d2:	d012      	beq.n	80020fa <adc_lld_serve_dma_interrupt+0xea>
 80020d4:	9b01      	ldr	r3, [sp, #4]
 80020d6:	2204      	movs	r2, #4
 80020d8:	701a      	strb	r2, [r3, #0]
 80020da:	9b01      	ldr	r3, [sp, #4]
 80020dc:	691b      	ldr	r3, [r3, #16]
 80020de:	685b      	ldr	r3, [r3, #4]
 80020e0:	9801      	ldr	r0, [sp, #4]
 80020e2:	4798      	blx	r3
 80020e4:	9b01      	ldr	r3, [sp, #4]
 80020e6:	781b      	ldrb	r3, [r3, #0]
 80020e8:	2b04      	cmp	r3, #4
 80020ea:	d10c      	bne.n	8002106 <adc_lld_serve_dma_interrupt+0xf6>
 80020ec:	9b01      	ldr	r3, [sp, #4]
 80020ee:	2202      	movs	r2, #2
 80020f0:	701a      	strb	r2, [r3, #0]
 80020f2:	9b01      	ldr	r3, [sp, #4]
 80020f4:	2200      	movs	r2, #0
 80020f6:	611a      	str	r2, [r3, #16]
 80020f8:	e005      	b.n	8002106 <adc_lld_serve_dma_interrupt+0xf6>
 80020fa:	9b01      	ldr	r3, [sp, #4]
 80020fc:	2202      	movs	r2, #2
 80020fe:	701a      	strb	r2, [r3, #0]
 8002100:	9b01      	ldr	r3, [sp, #4]
 8002102:	2200      	movs	r2, #0
 8002104:	611a      	str	r2, [r3, #16]
 8002106:	f7ff fed3 	bl	8001eb0 <osalSysLockFromISR.lto_priv.0>
 800210a:	9b01      	ldr	r3, [sp, #4]
 800210c:	3314      	adds	r3, #20
 800210e:	2100      	movs	r1, #0
 8002110:	4618      	mov	r0, r3
 8002112:	f7ff feed 	bl	8001ef0 <osalThreadResumeI.lto_priv.1>
 8002116:	f7ff fed3 	bl	8001ec0 <osalSysUnlockFromISR.lto_priv.0>
}
 800211a:	e00e      	b.n	800213a <adc_lld_serve_dma_interrupt+0x12a>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 800211c:	9b00      	ldr	r3, [sp, #0]
 800211e:	f003 0304 	and.w	r3, r3, #4
 8002122:	2b00      	cmp	r3, #0
 8002124:	d009      	beq.n	800213a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_half_code(adcp);
 8002126:	9b01      	ldr	r3, [sp, #4]
 8002128:	691b      	ldr	r3, [r3, #16]
 800212a:	685b      	ldr	r3, [r3, #4]
 800212c:	2b00      	cmp	r3, #0
 800212e:	d004      	beq.n	800213a <adc_lld_serve_dma_interrupt+0x12a>
 8002130:	9b01      	ldr	r3, [sp, #4]
 8002132:	691b      	ldr	r3, [r3, #16]
 8002134:	685b      	ldr	r3, [r3, #4]
 8002136:	9801      	ldr	r0, [sp, #4]
 8002138:	4798      	blx	r3
}
 800213a:	bf00      	nop
 800213c:	b003      	add	sp, #12
 800213e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002142:	bf00      	nop
	...

08002150 <adc_lld_serve_interrupt>:
 * @brief   ADC IRQ service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] isr       content of the ISR register
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 8002150:	b500      	push	{lr}
 8002152:	b085      	sub	sp, #20
 8002154:	9001      	str	r0, [sp, #4]
 8002156:	9100      	str	r1, [sp, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8002158:	9b01      	ldr	r3, [sp, #4]
 800215a:	691b      	ldr	r3, [r3, #16]
 800215c:	2b00      	cmp	r3, #0
 800215e:	d059      	beq.n	8002214 <adc_lld_serve_interrupt+0xc4>
    adcerror_t emask = 0U;
 8002160:	2300      	movs	r3, #0
 8002162:	9303      	str	r3, [sp, #12]

    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the state is checked too.*/
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8002164:	9b00      	ldr	r3, [sp, #0]
 8002166:	f003 0310 	and.w	r3, r3, #16
 800216a:	2b00      	cmp	r3, #0
 800216c:	d007      	beq.n	800217e <adc_lld_serve_interrupt+0x2e>
 800216e:	9b01      	ldr	r3, [sp, #4]
 8002170:	781b      	ldrb	r3, [r3, #0]
 8002172:	2b03      	cmp	r3, #3
 8002174:	d103      	bne.n	800217e <adc_lld_serve_interrupt+0x2e>
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
 8002176:	9b03      	ldr	r3, [sp, #12]
 8002178:	f043 0302 	orr.w	r3, r3, #2
 800217c:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD1) {
 800217e:	9b00      	ldr	r3, [sp, #0]
 8002180:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002184:	2b00      	cmp	r3, #0
 8002186:	d003      	beq.n	8002190 <adc_lld_serve_interrupt+0x40>
      /* Analog watchdog 1 error.*/
      emask |= ADC_ERR_AWD1;
 8002188:	9b03      	ldr	r3, [sp, #12]
 800218a:	f043 0304 	orr.w	r3, r3, #4
 800218e:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD2) {
 8002190:	9b00      	ldr	r3, [sp, #0]
 8002192:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8002196:	2b00      	cmp	r3, #0
 8002198:	d003      	beq.n	80021a2 <adc_lld_serve_interrupt+0x52>
      /* Analog watchdog 2 error.*/
      emask |= ADC_ERR_AWD2;
 800219a:	9b03      	ldr	r3, [sp, #12]
 800219c:	f043 0308 	orr.w	r3, r3, #8
 80021a0:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD3) {
 80021a2:	9b00      	ldr	r3, [sp, #0]
 80021a4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80021a8:	2b00      	cmp	r3, #0
 80021aa:	d003      	beq.n	80021b4 <adc_lld_serve_interrupt+0x64>
      /* Analog watchdog 3 error.*/
      emask |= ADC_ERR_AWD3;
 80021ac:	9b03      	ldr	r3, [sp, #12]
 80021ae:	f043 0310 	orr.w	r3, r3, #16
 80021b2:	9303      	str	r3, [sp, #12]
    }
    if (emask != 0U) {
 80021b4:	9b03      	ldr	r3, [sp, #12]
 80021b6:	2b00      	cmp	r3, #0
 80021b8:	d02c      	beq.n	8002214 <adc_lld_serve_interrupt+0xc4>
      _adc_isr_error_code(adcp, emask);
 80021ba:	9801      	ldr	r0, [sp, #4]
 80021bc:	f000 f9b8 	bl	8002530 <adc_lld_stop_conversion>
 80021c0:	9b01      	ldr	r3, [sp, #4]
 80021c2:	691b      	ldr	r3, [r3, #16]
 80021c4:	689b      	ldr	r3, [r3, #8]
 80021c6:	2b00      	cmp	r3, #0
 80021c8:	d013      	beq.n	80021f2 <adc_lld_serve_interrupt+0xa2>
 80021ca:	9b01      	ldr	r3, [sp, #4]
 80021cc:	2205      	movs	r2, #5
 80021ce:	701a      	strb	r2, [r3, #0]
 80021d0:	9b01      	ldr	r3, [sp, #4]
 80021d2:	691b      	ldr	r3, [r3, #16]
 80021d4:	689b      	ldr	r3, [r3, #8]
 80021d6:	9903      	ldr	r1, [sp, #12]
 80021d8:	9801      	ldr	r0, [sp, #4]
 80021da:	4798      	blx	r3
 80021dc:	9b01      	ldr	r3, [sp, #4]
 80021de:	781b      	ldrb	r3, [r3, #0]
 80021e0:	2b05      	cmp	r3, #5
 80021e2:	d10c      	bne.n	80021fe <adc_lld_serve_interrupt+0xae>
 80021e4:	9b01      	ldr	r3, [sp, #4]
 80021e6:	2202      	movs	r2, #2
 80021e8:	701a      	strb	r2, [r3, #0]
 80021ea:	9b01      	ldr	r3, [sp, #4]
 80021ec:	2200      	movs	r2, #0
 80021ee:	611a      	str	r2, [r3, #16]
 80021f0:	e005      	b.n	80021fe <adc_lld_serve_interrupt+0xae>
 80021f2:	9b01      	ldr	r3, [sp, #4]
 80021f4:	2202      	movs	r2, #2
 80021f6:	701a      	strb	r2, [r3, #0]
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	2200      	movs	r2, #0
 80021fc:	611a      	str	r2, [r3, #16]
 80021fe:	f7ff fe57 	bl	8001eb0 <osalSysLockFromISR.lto_priv.0>
 8002202:	9b01      	ldr	r3, [sp, #4]
 8002204:	3314      	adds	r3, #20
 8002206:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 800220a:	4618      	mov	r0, r3
 800220c:	f7ff fe70 	bl	8001ef0 <osalThreadResumeI.lto_priv.1>
 8002210:	f7ff fe56 	bl	8001ec0 <osalSysUnlockFromISR.lto_priv.0>
    }
  }
}
 8002214:	bf00      	nop
 8002216:	b005      	add	sp, #20
 8002218:	f85d fb04 	ldr.w	pc, [sp], #4
 800221c:	0000      	movs	r0, r0
	...

08002220 <Vector88>:
/**
 * @brief   ADC1/ADC2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8002220:	b500      	push	{lr}
 8002222:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 8002224:	f001 f92c 	bl	8003480 <__dbg_check_enter_isr>
  adc_lld_serve_interrupt(&ADCD1, isr);

#else /* !STM32_ADC_DUAL_MODE */

#if STM32_ADC_USE_ADC1
  isr  = ADC1->ISR;
 8002228:	4b08      	ldr	r3, [pc, #32]	@ (800224c <Vector88+0x2c>)
 800222a:	681b      	ldr	r3, [r3, #0]
 800222c:	9301      	str	r3, [sp, #4]
  ADC1->ISR = isr;
 800222e:	4a07      	ldr	r2, [pc, #28]	@ (800224c <Vector88+0x2c>)
 8002230:	9b01      	ldr	r3, [sp, #4]
 8002232:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD1, isr);
 8002234:	9901      	ldr	r1, [sp, #4]
 8002236:	4806      	ldr	r0, [pc, #24]	@ (8002250 <Vector88+0x30>)
 8002238:	f7ff ff8a 	bl	8002150 <adc_lld_serve_interrupt>
  adc_lld_serve_interrupt(&ADCD2, isr);
#endif

#endif /* !STM32_ADC_DUAL_MODE */

  OSAL_IRQ_EPILOGUE();
 800223c:	f001 f958 	bl	80034f0 <__dbg_check_leave_isr>
 8002240:	f002 fea6 	bl	8004f90 <__port_irq_epilogue>
}
 8002244:	bf00      	nop
 8002246:	b003      	add	sp, #12
 8002248:	f85d fb04 	ldr.w	pc, [sp], #4
 800224c:	50040000 	.word	0x50040000
 8002250:	20000800 	.word	0x20000800
	...

08002260 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8002260:	b508      	push	{r3, lr}

  clkmask = 0;
 8002262:	4b2b      	ldr	r3, [pc, #172]	@ (8002310 <adc_lld_init+0xb0>)
 8002264:	2200      	movs	r2, #0
 8002266:	601a      	str	r2, [r3, #0]

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8002268:	482a      	ldr	r0, [pc, #168]	@ (8002314 <adc_lld_init+0xb4>)
 800226a:	f7fe fcb1 	bl	8000bd0 <adcObjectInit>
#elif defined(ADC12_COMMON)
  ADCD1.adcc = ADC12_COMMON;
#elif defined(ADC123_COMMON)
  ADCD1.adcc = ADC123_COMMON;
#else
  ADCD1.adcc = ADC1_COMMON;
 800226e:	4b29      	ldr	r3, [pc, #164]	@ (8002314 <adc_lld_init+0xb4>)
 8002270:	4a29      	ldr	r2, [pc, #164]	@ (8002318 <adc_lld_init+0xb8>)
 8002272:	62da      	str	r2, [r3, #44]	@ 0x2c
#endif
  ADCD1.adcm    = ADC1;
 8002274:	4b27      	ldr	r3, [pc, #156]	@ (8002314 <adc_lld_init+0xb4>)
 8002276:	4a29      	ldr	r2, [pc, #164]	@ (800231c <adc_lld_init+0xbc>)
 8002278:	629a      	str	r2, [r3, #40]	@ 0x28
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs    = ADC2;
#endif
  ADCD1.dmastp  = NULL;
 800227a:	4b26      	ldr	r3, [pc, #152]	@ (8002314 <adc_lld_init+0xb4>)
 800227c:	2200      	movs	r2, #0
 800227e:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD1.dmamode = ADC_DMA_SIZE |
 8002280:	4b24      	ldr	r3, [pc, #144]	@ (8002314 <adc_lld_init+0xb4>)
 8002282:	f242 528a 	movw	r2, #9610	@ 0x258a
 8002286:	635a      	str	r2, [r3, #52]	@ 0x34
#endif /* STM32_ADC_USE_ADC5 */

  /* IRQs setup.*/
#if STM32_ADC_USE_ADC1 || STM32_ADC_USE_ADC2
#if defined(STM32_ADC_ADC1_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC1_IRQ_PRIORITY);
 8002288:	2105      	movs	r1, #5
 800228a:	2012      	movs	r0, #18
 800228c:	f7ff f830 	bl	80012f0 <nvicEnableVector>
#endif
#endif

#if defined(STM32WBXX)
#if STM32_ADC_USE_ADC1
  rccResetADC1();
 8002290:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002294:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002296:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800229a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800229e:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80022a0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80022a4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80022a6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80022aa:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80022ae:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80022b0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80022b4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableADC1(true);
 80022b6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80022ba:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80022bc:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80022c0:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80022c4:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80022c6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80022ca:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80022cc:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80022d0:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80022d4:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80022d6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80022da:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
  ADC1_COMMON->CCR = STM32_ADC_ADC1_PRESC | STM32_ADC_ADC1_CLOCK_MODE;
 80022dc:	4b0e      	ldr	r3, [pc, #56]	@ (8002318 <adc_lld_init+0xb8>)
 80022de:	f44f 22a0 	mov.w	r2, #327680	@ 0x50000
 80022e2:	609a      	str	r2, [r3, #8]
  rccDisableADC1();
 80022e4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80022e8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80022ea:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80022ee:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80022f2:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80022f4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80022f8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80022fa:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80022fe:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 8002302:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8002304:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002308:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
#endif
}
 800230a:	bf00      	nop
 800230c:	bd08      	pop	{r3, pc}
 800230e:	bf00      	nop
 8002310:	20000838 	.word	0x20000838
 8002314:	20000800 	.word	0x20000800
 8002318:	50040300 	.word	0x50040300
 800231c:	50040000 	.word	0x50040000

08002320 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8002320:	b500      	push	{lr}
 8002322:	b083      	sub	sp, #12
 8002324:	9001      	str	r0, [sp, #4]

  /* Handling the default configuration.*/
  if (adcp->config == NULL) {
 8002326:	9b01      	ldr	r3, [sp, #4]
 8002328:	685b      	ldr	r3, [r3, #4]
 800232a:	2b00      	cmp	r3, #0
 800232c:	d102      	bne.n	8002334 <adc_lld_start+0x14>
    adcp->config = &default_config;
 800232e:	9b01      	ldr	r3, [sp, #4]
 8002330:	4a26      	ldr	r2, [pc, #152]	@ (80023cc <adc_lld_start+0xac>)
 8002332:	605a      	str	r2, [r3, #4]
  }

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8002334:	9b01      	ldr	r3, [sp, #4]
 8002336:	781b      	ldrb	r3, [r3, #0]
 8002338:	2b01      	cmp	r3, #1
 800233a:	d143      	bne.n	80023c4 <adc_lld_start+0xa4>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800233c:	9b01      	ldr	r3, [sp, #4]
 800233e:	4a24      	ldr	r2, [pc, #144]	@ (80023d0 <adc_lld_start+0xb0>)
 8002340:	4293      	cmp	r3, r2
 8002342:	d127      	bne.n	8002394 <adc_lld_start+0x74>

      osalDbgAssert(STM32_ADC1_CLOCK <= STM32_ADCCLK_MAX,
                    "invalid clock frequency");

      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 8002344:	9b01      	ldr	r3, [sp, #4]
 8002346:	4a23      	ldr	r2, [pc, #140]	@ (80023d4 <adc_lld_start+0xb4>)
 8002348:	2105      	movs	r1, #5
 800234a:	2000      	movs	r0, #0
 800234c:	f000 fa48 	bl	80027e0 <dmaStreamAllocI>
 8002350:	4602      	mov	r2, r0
 8002352:	9b01      	ldr	r3, [sp, #4]
 8002354:	631a      	str	r2, [r3, #48]	@ 0x30
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");

      clkmask |= (1 << 0);
 8002356:	4b20      	ldr	r3, [pc, #128]	@ (80023d8 <adc_lld_start+0xb8>)
 8002358:	681b      	ldr	r3, [r3, #0]
 800235a:	f043 0301 	orr.w	r3, r3, #1
 800235e:	4a1e      	ldr	r2, [pc, #120]	@ (80023d8 <adc_lld_start+0xb8>)
 8002360:	6013      	str	r3, [r2, #0]
#endif
#if defined(STM32L4XX) || defined(STM32L4XXP)
      rccEnableADC123(true);
#endif
#if defined(STM32WBXX)
      rccEnableADC1(true);
 8002362:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002366:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002368:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800236c:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8002370:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8002372:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002376:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8002378:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 800237c:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8002380:	66d3      	str	r3, [r2, #108]	@ 0x6c
 8002382:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002386:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
#endif
#if STM32_DMA_SUPPORTS_DMAMUX
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC1);
 8002388:	9b01      	ldr	r3, [sp, #4]
 800238a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800238c:	2105      	movs	r1, #5
 800238e:	4618      	mov	r0, r3
 8002390:	f000 fb46 	bl	8002a20 <dmaSetRequestSource>

    /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcc->CDR);
#else
    dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 8002394:	9b01      	ldr	r3, [sp, #4]
 8002396:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002398:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 800239c:	9b01      	ldr	r3, [sp, #4]
 800239e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80023a0:	685b      	ldr	r3, [r3, #4]
 80023a2:	609a      	str	r2, [r3, #8]
    /* Differential channels setting.*/
#if STM32_ADC_DUAL_MODE
    adcp->adcm->DIFSEL = adcp->config->difsel;
    adcp->adcs->DIFSEL = adcp->config->difsel;
#else
    adcp->adcm->DIFSEL = adcp->config->difsel;
 80023a4:	9b01      	ldr	r3, [sp, #4]
 80023a6:	685a      	ldr	r2, [r3, #4]
 80023a8:	9b01      	ldr	r3, [sp, #4]
 80023aa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80023ac:	6812      	ldr	r2, [r2, #0]
 80023ae:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
#endif

    /* Master ADC calibration.*/
    adc_lld_vreg_on(adcp);
 80023b2:	9801      	ldr	r0, [sp, #4]
 80023b4:	f7ff fdac 	bl	8001f10 <adc_lld_vreg_on>
    adc_lld_calibrate(adcp);
 80023b8:	9801      	ldr	r0, [sp, #4]
 80023ba:	f7ff fdc1 	bl	8001f40 <adc_lld_calibrate>

    /* Master ADC enabled here in order to reduce conversions latencies.*/
    adc_lld_analog_on(adcp);
 80023be:	9801      	ldr	r0, [sp, #4]
 80023c0:	f7ff fdee 	bl	8001fa0 <adc_lld_analog_on>
  }
}
 80023c4:	bf00      	nop
 80023c6:	b003      	add	sp, #12
 80023c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80023cc:	08005324 	.word	0x08005324
 80023d0:	20000800 	.word	0x20000800
 80023d4:	08002011 	.word	0x08002011
 80023d8:	20000838 	.word	0x20000838
 80023dc:	00000000 	.word	0x00000000

080023e0 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 80023e0:	b086      	sub	sp, #24
 80023e2:	9001      	str	r0, [sp, #4]
  uint32_t dmamode, cfgr;
  const ADCConversionGroup *grpp = adcp->grpp;
 80023e4:	9b01      	ldr	r3, [sp, #4]
 80023e6:	691b      	ldr	r3, [r3, #16]
 80023e8:	9303      	str	r3, [sp, #12]

  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
 80023ea:	9b01      	ldr	r3, [sp, #4]
 80023ec:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80023ee:	9305      	str	r3, [sp, #20]
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 80023f0:	9b03      	ldr	r3, [sp, #12]
 80023f2:	68db      	ldr	r3, [r3, #12]
 80023f4:	f043 0301 	orr.w	r3, r3, #1
 80023f8:	9304      	str	r3, [sp, #16]
  if (grpp->circular) {
 80023fa:	9b03      	ldr	r3, [sp, #12]
 80023fc:	781b      	ldrb	r3, [r3, #0]
 80023fe:	2b00      	cmp	r3, #0
 8002400:	d00f      	beq.n	8002422 <adc_lld_start_conversion+0x42>
    dmamode |= STM32_DMA_CR_CIRC;
 8002402:	9b05      	ldr	r3, [sp, #20]
 8002404:	f043 0320 	orr.w	r3, r3, #32
 8002408:	9305      	str	r3, [sp, #20]
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
#else
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
 800240a:	9b04      	ldr	r3, [sp, #16]
 800240c:	f043 0302 	orr.w	r3, r3, #2
 8002410:	9304      	str	r3, [sp, #16]
#endif
    if (adcp->depth > 1) {
 8002412:	9b01      	ldr	r3, [sp, #4]
 8002414:	68db      	ldr	r3, [r3, #12]
 8002416:	2b01      	cmp	r3, #1
 8002418:	d903      	bls.n	8002422 <adc_lld_start_conversion+0x42>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      dmamode |= STM32_DMA_CR_HTIE;
 800241a:	9b05      	ldr	r3, [sp, #20]
 800241c:	f043 0304 	orr.w	r3, r3, #4
 8002420:	9305      	str	r3, [sp, #20]
    }
  }

  /* DMA setup.*/
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8002422:	9b01      	ldr	r3, [sp, #4]
 8002424:	689a      	ldr	r2, [r3, #8]
 8002426:	9b01      	ldr	r3, [sp, #4]
 8002428:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800242a:	685b      	ldr	r3, [r3, #4]
 800242c:	60da      	str	r2, [r3, #12]
#if STM32_ADC_DUAL_MODE
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels/2) *
                                            (uint32_t)adcp->depth);
#else
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800242e:	9b03      	ldr	r3, [sp, #12]
 8002430:	885b      	ldrh	r3, [r3, #2]
 8002432:	4619      	mov	r1, r3
 8002434:	9b01      	ldr	r3, [sp, #4]
 8002436:	68da      	ldr	r2, [r3, #12]
 8002438:	9b01      	ldr	r3, [sp, #4]
 800243a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800243c:	685b      	ldr	r3, [r3, #4]
 800243e:	fb01 f202 	mul.w	r2, r1, r2
 8002442:	605a      	str	r2, [r3, #4]
                                            (uint32_t)adcp->depth);
#endif
  dmaStreamSetMode(adcp->dmastp, dmamode);
 8002444:	9b01      	ldr	r3, [sp, #4]
 8002446:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002448:	685b      	ldr	r3, [r3, #4]
 800244a:	9a05      	ldr	r2, [sp, #20]
 800244c:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(adcp->dmastp);
 800244e:	9b01      	ldr	r3, [sp, #4]
 8002450:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002452:	685b      	ldr	r3, [r3, #4]
 8002454:	681a      	ldr	r2, [r3, #0]
 8002456:	9b01      	ldr	r3, [sp, #4]
 8002458:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800245a:	685b      	ldr	r3, [r3, #4]
 800245c:	f042 0201 	orr.w	r2, r2, #1
 8002460:	601a      	str	r2, [r3, #0]

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8002462:	9b01      	ldr	r3, [sp, #4]
 8002464:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8002466:	9b01      	ldr	r3, [sp, #4]
 8002468:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800246a:	6812      	ldr	r2, [r2, #0]
 800246c:	601a      	str	r2, [r3, #0]
  if (grpp->error_cb != NULL) {
 800246e:	9b03      	ldr	r3, [sp, #12]
 8002470:	689b      	ldr	r3, [r3, #8]
 8002472:	2b00      	cmp	r3, #0
 8002474:	d01f      	beq.n	80024b6 <adc_lld_start_conversion+0xd6>
    adcp->adcm->IER    = ADC_IER_OVRIE | ADC_IER_AWD1IE
 8002476:	9b01      	ldr	r3, [sp, #4]
 8002478:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800247a:	f44f 7264 	mov.w	r2, #912	@ 0x390
 800247e:	605a      	str	r2, [r3, #4]
                                       | ADC_IER_AWD2IE
                                       | ADC_IER_AWD3IE;
    adcp->adcm->TR1    = grpp->tr1;
 8002480:	9b01      	ldr	r3, [sp, #4]
 8002482:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002484:	9a03      	ldr	r2, [sp, #12]
 8002486:	6952      	ldr	r2, [r2, #20]
 8002488:	621a      	str	r2, [r3, #32]
    adcp->adcm->TR2    = grpp->tr2;
 800248a:	9b01      	ldr	r3, [sp, #4]
 800248c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800248e:	9a03      	ldr	r2, [sp, #12]
 8002490:	6992      	ldr	r2, [r2, #24]
 8002492:	625a      	str	r2, [r3, #36]	@ 0x24
    adcp->adcm->TR3    = grpp->tr3;
 8002494:	9b01      	ldr	r3, [sp, #4]
 8002496:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002498:	9a03      	ldr	r2, [sp, #12]
 800249a:	69d2      	ldr	r2, [r2, #28]
 800249c:	629a      	str	r2, [r3, #40]	@ 0x28
    adcp->adcm->AWD2CR = grpp->awd2cr;
 800249e:	9b01      	ldr	r3, [sp, #4]
 80024a0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024a2:	9a03      	ldr	r2, [sp, #12]
 80024a4:	6a12      	ldr	r2, [r2, #32]
 80024a6:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    adcp->adcm->AWD3CR = grpp->awd3cr;
 80024aa:	9b01      	ldr	r3, [sp, #4]
 80024ac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024ae:	9a03      	ldr	r2, [sp, #12]
 80024b0:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80024b2:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
  adcp->adcs->SQR2  = grpp->ssqr[1];
  adcp->adcs->SQR3  = grpp->ssqr[2];
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
 80024b6:	9b01      	ldr	r3, [sp, #4]
 80024b8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024ba:	9a03      	ldr	r2, [sp, #12]
 80024bc:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 80024be:	615a      	str	r2, [r3, #20]
  adcp->adcm->SMPR2 = grpp->smpr[1];
 80024c0:	9b01      	ldr	r3, [sp, #4]
 80024c2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024c4:	9a03      	ldr	r2, [sp, #12]
 80024c6:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80024c8:	619a      	str	r2, [r3, #24]
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 80024ca:	9b03      	ldr	r3, [sp, #12]
 80024cc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80024ce:	9b03      	ldr	r3, [sp, #12]
 80024d0:	885b      	ldrh	r3, [r3, #2]
 80024d2:	3b01      	subs	r3, #1
 80024d4:	4619      	mov	r1, r3
 80024d6:	9b01      	ldr	r3, [sp, #4]
 80024d8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024da:	430a      	orrs	r2, r1
 80024dc:	631a      	str	r2, [r3, #48]	@ 0x30
  adcp->adcm->SQR2  = grpp->sqr[1];
 80024de:	9b01      	ldr	r3, [sp, #4]
 80024e0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024e2:	9a03      	ldr	r2, [sp, #12]
 80024e4:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 80024e6:	635a      	str	r2, [r3, #52]	@ 0x34
  adcp->adcm->SQR3  = grpp->sqr[2];
 80024e8:	9b01      	ldr	r3, [sp, #4]
 80024ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024ec:	9a03      	ldr	r2, [sp, #12]
 80024ee:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 80024f0:	639a      	str	r2, [r3, #56]	@ 0x38
  adcp->adcm->SQR4  = grpp->sqr[3];
 80024f2:	9b01      	ldr	r3, [sp, #4]
 80024f4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024f6:	9a03      	ldr	r2, [sp, #12]
 80024f8:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 80024fa:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif /* !STM32_ADC_DUAL_MODE */

  /* ADC configuration.*/
  adcp->adcm->CFGR  = cfgr;
 80024fc:	9b01      	ldr	r3, [sp, #4]
 80024fe:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002500:	9a04      	ldr	r2, [sp, #16]
 8002502:	60da      	str	r2, [r3, #12]
#if (STM32_ADCV3_OVERSAMPLING == TRUE) || defined(__DOXYGEN__)
  adcp->adcm->CFGR2 = grpp->cfgr2;
 8002504:	9b01      	ldr	r3, [sp, #4]
 8002506:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002508:	9a03      	ldr	r2, [sp, #12]
 800250a:	6912      	ldr	r2, [r2, #16]
 800250c:	611a      	str	r2, [r3, #16]
#endif

  /* Starting conversion.*/
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 800250e:	9b01      	ldr	r3, [sp, #4]
 8002510:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002512:	689a      	ldr	r2, [r3, #8]
 8002514:	9b01      	ldr	r3, [sp, #4]
 8002516:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002518:	f042 0204 	orr.w	r2, r2, #4
 800251c:	609a      	str	r2, [r3, #8]
}
 800251e:	bf00      	nop
 8002520:	b006      	add	sp, #24
 8002522:	4770      	bx	lr
	...

08002530 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8002530:	b500      	push	{lr}
 8002532:	b083      	sub	sp, #12
 8002534:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
 8002536:	9b01      	ldr	r3, [sp, #4]
 8002538:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800253a:	685b      	ldr	r3, [r3, #4]
 800253c:	681a      	ldr	r2, [r3, #0]
 800253e:	9b01      	ldr	r3, [sp, #4]
 8002540:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002542:	685b      	ldr	r3, [r3, #4]
 8002544:	f022 020f 	bic.w	r2, r2, #15
 8002548:	601a      	str	r2, [r3, #0]
 800254a:	9b01      	ldr	r3, [sp, #4]
 800254c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800254e:	7c1b      	ldrb	r3, [r3, #16]
 8002550:	461a      	mov	r2, r3
 8002552:	230e      	movs	r3, #14
 8002554:	fa03 f202 	lsl.w	r2, r3, r2
 8002558:	9b01      	ldr	r3, [sp, #4]
 800255a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800255c:	681b      	ldr	r3, [r3, #0]
 800255e:	605a      	str	r2, [r3, #4]
  adc_lld_stop_adc(adcp);
 8002560:	9801      	ldr	r0, [sp, #4]
 8002562:	f7ff fd35 	bl	8001fd0 <adc_lld_stop_adc>
}
 8002566:	bf00      	nop
 8002568:	b003      	add	sp, #12
 800256a:	f85d fb04 	ldr.w	pc, [sp], #4
 800256e:	bf00      	nop

08002570 <adcSTM32EnableVREF>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableVREF(ADCDriver *adcp) {
 8002570:	b082      	sub	sp, #8
 8002572:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_VREFEN;
 8002574:	9b01      	ldr	r3, [sp, #4]
 8002576:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002578:	689a      	ldr	r2, [r3, #8]
 800257a:	9b01      	ldr	r3, [sp, #4]
 800257c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800257e:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8002582:	609a      	str	r2, [r3, #8]
}
 8002584:	bf00      	nop
 8002586:	b002      	add	sp, #8
 8002588:	4770      	bx	lr
 800258a:	bf00      	nop
 800258c:	0000      	movs	r0, r0
	...

08002590 <adcSTM32EnableTS>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {
 8002590:	b082      	sub	sp, #8
 8002592:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_TSEN;
 8002594:	9b01      	ldr	r3, [sp, #4]
 8002596:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002598:	689a      	ldr	r2, [r3, #8]
 800259a:	9b01      	ldr	r3, [sp, #4]
 800259c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800259e:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 80025a2:	609a      	str	r2, [r3, #8]
}
 80025a4:	bf00      	nop
 80025a6:	b002      	add	sp, #8
 80025a8:	4770      	bx	lr
 80025aa:	bf00      	nop
 80025ac:	0000      	movs	r0, r0
	...

080025b0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80025b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80025b2:	f000 ff65 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 80025b6:	4804      	ldr	r0, [pc, #16]	@ (80025c8 <Vector6C+0x18>)
 80025b8:	f000 f9f2 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 80025bc:	f000 ff98 	bl	80034f0 <__dbg_check_leave_isr>
 80025c0:	f002 fce6 	bl	8004f90 <__port_irq_epilogue>
}
 80025c4:	bf00      	nop
 80025c6:	bd08      	pop	{r3, pc}
 80025c8:	08005328 	.word	0x08005328
 80025cc:	00000000 	.word	0x00000000

080025d0 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80025d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80025d2:	f000 ff55 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 80025d6:	4804      	ldr	r0, [pc, #16]	@ (80025e8 <Vector70+0x18>)
 80025d8:	f000 f9e2 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 80025dc:	f000 ff88 	bl	80034f0 <__dbg_check_leave_isr>
 80025e0:	f002 fcd6 	bl	8004f90 <__port_irq_epilogue>
}
 80025e4:	bf00      	nop
 80025e6:	bd08      	pop	{r3, pc}
 80025e8:	0800533c 	.word	0x0800533c
 80025ec:	00000000 	.word	0x00000000

080025f0 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80025f0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80025f2:	f000 ff45 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80025f6:	4804      	ldr	r0, [pc, #16]	@ (8002608 <Vector74+0x18>)
 80025f8:	f000 f9d2 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 80025fc:	f000 ff78 	bl	80034f0 <__dbg_check_leave_isr>
 8002600:	f002 fcc6 	bl	8004f90 <__port_irq_epilogue>
}
 8002604:	bf00      	nop
 8002606:	bd08      	pop	{r3, pc}
 8002608:	08005350 	.word	0x08005350
 800260c:	00000000 	.word	0x00000000

08002610 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002610:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002612:	f000 ff35 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8002616:	4804      	ldr	r0, [pc, #16]	@ (8002628 <Vector78+0x18>)
 8002618:	f000 f9c2 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800261c:	f000 ff68 	bl	80034f0 <__dbg_check_leave_isr>
 8002620:	f002 fcb6 	bl	8004f90 <__port_irq_epilogue>
}
 8002624:	bf00      	nop
 8002626:	bd08      	pop	{r3, pc}
 8002628:	08005364 	.word	0x08005364
 800262c:	00000000 	.word	0x00000000

08002630 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8002630:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002632:	f000 ff25 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8002636:	4804      	ldr	r0, [pc, #16]	@ (8002648 <Vector7C+0x18>)
 8002638:	f000 f9b2 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800263c:	f000 ff58 	bl	80034f0 <__dbg_check_leave_isr>
 8002640:	f002 fca6 	bl	8004f90 <__port_irq_epilogue>
}
 8002644:	bf00      	nop
 8002646:	bd08      	pop	{r3, pc}
 8002648:	08005378 	.word	0x08005378
 800264c:	00000000 	.word	0x00000000

08002650 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8002650:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002652:	f000 ff15 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8002656:	4804      	ldr	r0, [pc, #16]	@ (8002668 <Vector80+0x18>)
 8002658:	f000 f9a2 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800265c:	f000 ff48 	bl	80034f0 <__dbg_check_leave_isr>
 8002660:	f002 fc96 	bl	8004f90 <__port_irq_epilogue>
}
 8002664:	bf00      	nop
 8002666:	bd08      	pop	{r3, pc}
 8002668:	0800538c 	.word	0x0800538c
 800266c:	00000000 	.word	0x00000000

08002670 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002670:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002672:	f000 ff05 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8002676:	4804      	ldr	r0, [pc, #16]	@ (8002688 <Vector84+0x18>)
 8002678:	f000 f992 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800267c:	f000 ff38 	bl	80034f0 <__dbg_check_leave_isr>
 8002680:	f002 fc86 	bl	8004f90 <__port_irq_epilogue>
}
 8002684:	bf00      	nop
 8002686:	bd08      	pop	{r3, pc}
 8002688:	080053a0 	.word	0x080053a0
 800268c:	00000000 	.word	0x00000000

08002690 <Vector11C>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8002690:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002692:	f000 fef5 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8002696:	4804      	ldr	r0, [pc, #16]	@ (80026a8 <Vector11C+0x18>)
 8002698:	f000 f982 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800269c:	f000 ff28 	bl	80034f0 <__dbg_check_leave_isr>
 80026a0:	f002 fc76 	bl	8004f90 <__port_irq_epilogue>
}
 80026a4:	bf00      	nop
 80026a6:	bd08      	pop	{r3, pc}
 80026a8:	080053b4 	.word	0x080053b4
 80026ac:	00000000 	.word	0x00000000

080026b0 <Vector120>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80026b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80026b2:	f000 fee5 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 80026b6:	4804      	ldr	r0, [pc, #16]	@ (80026c8 <Vector120+0x18>)
 80026b8:	f000 f972 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 80026bc:	f000 ff18 	bl	80034f0 <__dbg_check_leave_isr>
 80026c0:	f002 fc66 	bl	8004f90 <__port_irq_epilogue>
}
 80026c4:	bf00      	nop
 80026c6:	bd08      	pop	{r3, pc}
 80026c8:	080053c8 	.word	0x080053c8
 80026cc:	00000000 	.word	0x00000000

080026d0 <Vector124>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 80026d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80026d2:	f000 fed5 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 80026d6:	4804      	ldr	r0, [pc, #16]	@ (80026e8 <Vector124+0x18>)
 80026d8:	f000 f962 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 80026dc:	f000 ff08 	bl	80034f0 <__dbg_check_leave_isr>
 80026e0:	f002 fc56 	bl	8004f90 <__port_irq_epilogue>
}
 80026e4:	bf00      	nop
 80026e6:	bd08      	pop	{r3, pc}
 80026e8:	080053dc 	.word	0x080053dc
 80026ec:	00000000 	.word	0x00000000

080026f0 <Vector128>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 80026f0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80026f2:	f000 fec5 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 80026f6:	4804      	ldr	r0, [pc, #16]	@ (8002708 <Vector128+0x18>)
 80026f8:	f000 f952 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 80026fc:	f000 fef8 	bl	80034f0 <__dbg_check_leave_isr>
 8002700:	f002 fc46 	bl	8004f90 <__port_irq_epilogue>
}
 8002704:	bf00      	nop
 8002706:	bd08      	pop	{r3, pc}
 8002708:	080053f0 	.word	0x080053f0
 800270c:	00000000 	.word	0x00000000

08002710 <Vector12C>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8002710:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002712:	f000 feb5 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8002716:	4804      	ldr	r0, [pc, #16]	@ (8002728 <Vector12C+0x18>)
 8002718:	f000 f942 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800271c:	f000 fee8 	bl	80034f0 <__dbg_check_leave_isr>
 8002720:	f002 fc36 	bl	8004f90 <__port_irq_epilogue>
}
 8002724:	bf00      	nop
 8002726:	bd08      	pop	{r3, pc}
 8002728:	08005404 	.word	0x08005404
 800272c:	00000000 	.word	0x00000000

08002730 <Vector130>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8002730:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002732:	f000 fea5 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8002736:	4804      	ldr	r0, [pc, #16]	@ (8002748 <Vector130+0x18>)
 8002738:	f000 f932 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800273c:	f000 fed8 	bl	80034f0 <__dbg_check_leave_isr>
 8002740:	f002 fc26 	bl	8004f90 <__port_irq_epilogue>
}
 8002744:	bf00      	nop
 8002746:	bd08      	pop	{r3, pc}
 8002748:	08005418 	.word	0x08005418
 800274c:	00000000 	.word	0x00000000

08002750 <Vector134>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8002750:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002752:	f000 fe95 	bl	8003480 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 8002756:	4804      	ldr	r0, [pc, #16]	@ (8002768 <Vector134+0x18>)
 8002758:	f000 f922 	bl	80029a0 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800275c:	f000 fec8 	bl	80034f0 <__dbg_check_leave_isr>
 8002760:	f002 fc16 	bl	8004f90 <__port_irq_epilogue>
}
 8002764:	bf00      	nop
 8002766:	bd08      	pop	{r3, pc}
 8002768:	0800542c 	.word	0x0800542c
 800276c:	00000000 	.word	0x00000000

08002770 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8002770:	b082      	sub	sp, #8
  int i;

  dma.allocated_mask = 0U;
 8002772:	4b15      	ldr	r3, [pc, #84]	@ (80027c8 <dmaInit+0x58>)
 8002774:	2200      	movs	r2, #0
 8002776:	601a      	str	r2, [r3, #0]
  dma.isr_mask       = 0U;
 8002778:	4b13      	ldr	r3, [pc, #76]	@ (80027c8 <dmaInit+0x58>)
 800277a:	2200      	movs	r2, #0
 800277c:	605a      	str	r2, [r3, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800277e:	2300      	movs	r3, #0
 8002780:	9301      	str	r3, [sp, #4]
 8002782:	e013      	b.n	80027ac <dmaInit+0x3c>
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8002784:	4911      	ldr	r1, [pc, #68]	@ (80027cc <dmaInit+0x5c>)
 8002786:	9a01      	ldr	r2, [sp, #4]
 8002788:	4613      	mov	r3, r2
 800278a:	009b      	lsls	r3, r3, #2
 800278c:	4413      	add	r3, r2
 800278e:	009b      	lsls	r3, r3, #2
 8002790:	440b      	add	r3, r1
 8002792:	3304      	adds	r3, #4
 8002794:	681b      	ldr	r3, [r3, #0]
 8002796:	2200      	movs	r2, #0
 8002798:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 800279a:	4a0b      	ldr	r2, [pc, #44]	@ (80027c8 <dmaInit+0x58>)
 800279c:	9b01      	ldr	r3, [sp, #4]
 800279e:	3301      	adds	r3, #1
 80027a0:	2100      	movs	r1, #0
 80027a2:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80027a6:	9b01      	ldr	r3, [sp, #4]
 80027a8:	3301      	adds	r3, #1
 80027aa:	9301      	str	r3, [sp, #4]
 80027ac:	9b01      	ldr	r3, [sp, #4]
 80027ae:	2b0d      	cmp	r3, #13
 80027b0:	dde8      	ble.n	8002784 <dmaInit+0x14>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 80027b2:	4b07      	ldr	r3, [pc, #28]	@ (80027d0 <dmaInit+0x60>)
 80027b4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80027b8:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 80027ba:	4b06      	ldr	r3, [pc, #24]	@ (80027d4 <dmaInit+0x64>)
 80027bc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80027c0:	605a      	str	r2, [r3, #4]
#endif
}
 80027c2:	bf00      	nop
 80027c4:	b002      	add	sp, #8
 80027c6:	4770      	bx	lr
 80027c8:	2000083c 	.word	0x2000083c
 80027cc:	08005328 	.word	0x08005328
 80027d0:	40020000 	.word	0x40020000
 80027d4:	40020400 	.word	0x40020400
	...

080027e0 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 80027e0:	b500      	push	{lr}
 80027e2:	b08b      	sub	sp, #44	@ 0x2c
 80027e4:	9003      	str	r0, [sp, #12]
 80027e6:	9102      	str	r1, [sp, #8]
 80027e8:	9201      	str	r2, [sp, #4]
 80027ea:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 80027ec:	f000 fec0 	bl	8003570 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 80027f0:	9b03      	ldr	r3, [sp, #12]
 80027f2:	2b0d      	cmp	r3, #13
 80027f4:	d804      	bhi.n	8002800 <dmaStreamAllocI+0x20>
    startid = id;
 80027f6:	9b03      	ldr	r3, [sp, #12]
 80027f8:	9308      	str	r3, [sp, #32]
    endid   = id;
 80027fa:	9b03      	ldr	r3, [sp, #12]
 80027fc:	9307      	str	r3, [sp, #28]
 80027fe:	e01c      	b.n	800283a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA_SUPPORTS_DMAMUX == TRUE
  else if (id == STM32_DMA_STREAM_ID_ANY) {
 8002800:	9b03      	ldr	r3, [sp, #12]
 8002802:	2b0e      	cmp	r3, #14
 8002804:	d104      	bne.n	8002810 <dmaStreamAllocI+0x30>
    startid = 0U;
 8002806:	2300      	movs	r3, #0
 8002808:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 800280a:	230d      	movs	r3, #13
 800280c:	9307      	str	r3, [sp, #28]
 800280e:	e014      	b.n	800283a <dmaStreamAllocI+0x5a>
  }
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA1) {
 8002810:	9b03      	ldr	r3, [sp, #12]
 8002812:	2b0f      	cmp	r3, #15
 8002814:	d104      	bne.n	8002820 <dmaStreamAllocI+0x40>
    startid = 0U;
 8002816:	2300      	movs	r3, #0
 8002818:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA1_NUM_CHANNELS - 1U;
 800281a:	2306      	movs	r3, #6
 800281c:	9307      	str	r3, [sp, #28]
 800281e:	e00c      	b.n	800283a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA2) {
 8002820:	9b03      	ldr	r3, [sp, #12]
 8002822:	2b10      	cmp	r3, #16
 8002824:	d104      	bne.n	8002830 <dmaStreamAllocI+0x50>
    startid = STM32_DMA1_NUM_CHANNELS;
 8002826:	2307      	movs	r3, #7
 8002828:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 800282a:	230d      	movs	r3, #13
 800282c:	9307      	str	r3, [sp, #28]
 800282e:	e004      	b.n	800283a <dmaStreamAllocI+0x5a>
  }
#endif
#endif
  else {
    osalDbgCheck(false);
 8002830:	4857      	ldr	r0, [pc, #348]	@ (8002990 <dmaStreamAllocI+0x1b0>)
 8002832:	f000 fd1d 	bl	8003270 <chSysHalt>
    return NULL;
 8002836:	2300      	movs	r3, #0
 8002838:	e0a6      	b.n	8002988 <dmaStreamAllocI+0x1a8>
  }

  for (i = startid; i <= endid; i++) {
 800283a:	9b08      	ldr	r3, [sp, #32]
 800283c:	9309      	str	r3, [sp, #36]	@ 0x24
 800283e:	e09d      	b.n	800297c <dmaStreamAllocI+0x19c>
    uint32_t mask = (1U << i);
 8002840:	2201      	movs	r2, #1
 8002842:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002844:	fa02 f303 	lsl.w	r3, r2, r3
 8002848:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 800284a:	4b52      	ldr	r3, [pc, #328]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 800284c:	681a      	ldr	r2, [r3, #0]
 800284e:	9b06      	ldr	r3, [sp, #24]
 8002850:	4013      	ands	r3, r2
 8002852:	2b00      	cmp	r3, #0
 8002854:	f040 808f 	bne.w	8002976 <dmaStreamAllocI+0x196>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8002858:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800285a:	4613      	mov	r3, r2
 800285c:	009b      	lsls	r3, r3, #2
 800285e:	4413      	add	r3, r2
 8002860:	009b      	lsls	r3, r3, #2
 8002862:	4a4d      	ldr	r2, [pc, #308]	@ (8002998 <dmaStreamAllocI+0x1b8>)
 8002864:	4413      	add	r3, r2
 8002866:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8002868:	494a      	ldr	r1, [pc, #296]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 800286a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800286c:	3301      	adds	r3, #1
 800286e:	9a01      	ldr	r2, [sp, #4]
 8002870:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
      dma.streams[i].param = param;
 8002874:	4a47      	ldr	r2, [pc, #284]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 8002876:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002878:	3301      	adds	r3, #1
 800287a:	00db      	lsls	r3, r3, #3
 800287c:	4413      	add	r3, r2
 800287e:	9a00      	ldr	r2, [sp, #0]
 8002880:	605a      	str	r2, [r3, #4]
      dma.allocated_mask  |= mask;
 8002882:	4b44      	ldr	r3, [pc, #272]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 8002884:	681a      	ldr	r2, [r3, #0]
 8002886:	9b06      	ldr	r3, [sp, #24]
 8002888:	4313      	orrs	r3, r2
 800288a:	4a42      	ldr	r2, [pc, #264]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 800288c:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 800288e:	9b06      	ldr	r3, [sp, #24]
 8002890:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8002894:	2b00      	cmp	r3, #0
 8002896:	d012      	beq.n	80028be <dmaStreamAllocI+0xde>
        rccEnableDMA1(true);
 8002898:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800289c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800289e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80028a2:	f043 0301 	orr.w	r3, r3, #1
 80028a6:	6493      	str	r3, [r2, #72]	@ 0x48
 80028a8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80028ac:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80028ae:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80028b2:	f043 0301 	orr.w	r3, r3, #1
 80028b6:	6693      	str	r3, [r2, #104]	@ 0x68
 80028b8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80028bc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#if STM32_DMA2_NUM_CHANNELS > 0
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 80028be:	9b06      	ldr	r3, [sp, #24]
 80028c0:	f403 537e 	and.w	r3, r3, #16256	@ 0x3f80
 80028c4:	2b00      	cmp	r3, #0
 80028c6:	d012      	beq.n	80028ee <dmaStreamAllocI+0x10e>
        rccEnableDMA2(true);
 80028c8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80028cc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80028ce:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80028d2:	f043 0302 	orr.w	r3, r3, #2
 80028d6:	6493      	str	r3, [r2, #72]	@ 0x48
 80028d8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80028dc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80028de:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80028e2:	f043 0302 	orr.w	r3, r3, #2
 80028e6:	6693      	str	r3, [r2, #104]	@ 0x68
 80028e8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80028ec:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

#if (STM32_DMA_SUPPORTS_DMAMUX == TRUE) && defined(rccEnableDMAMUX)
      /* Enabling DMAMUX if present.*/
      if (dma.allocated_mask != 0U) {
 80028ee:	4b29      	ldr	r3, [pc, #164]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 80028f0:	681b      	ldr	r3, [r3, #0]
 80028f2:	2b00      	cmp	r3, #0
 80028f4:	d012      	beq.n	800291c <dmaStreamAllocI+0x13c>
        rccEnableDMAMUX(true);
 80028f6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80028fa:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80028fc:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002900:	f043 0304 	orr.w	r3, r3, #4
 8002904:	6493      	str	r3, [r2, #72]	@ 0x48
 8002906:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800290a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800290c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002910:	f043 0304 	orr.w	r3, r3, #4
 8002914:	6693      	str	r3, [r2, #104]	@ 0x68
 8002916:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800291a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 800291c:	9b01      	ldr	r3, [sp, #4]
 800291e:	2b00      	cmp	r3, #0
 8002920:	d012      	beq.n	8002948 <dmaStreamAllocI+0x168>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8002922:	4b1c      	ldr	r3, [pc, #112]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 8002924:	685a      	ldr	r2, [r3, #4]
 8002926:	9b05      	ldr	r3, [sp, #20]
 8002928:	689b      	ldr	r3, [r3, #8]
 800292a:	4013      	ands	r3, r2
 800292c:	2b00      	cmp	r3, #0
 800292e:	d105      	bne.n	800293c <dmaStreamAllocI+0x15c>
          nvicEnableVector(dmastp->vector, priority);
 8002930:	9b05      	ldr	r3, [sp, #20]
 8002932:	7c9b      	ldrb	r3, [r3, #18]
 8002934:	9902      	ldr	r1, [sp, #8]
 8002936:	4618      	mov	r0, r3
 8002938:	f7fe fcda 	bl	80012f0 <nvicEnableVector>
        }
        dma.isr_mask |= mask;
 800293c:	4b15      	ldr	r3, [pc, #84]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 800293e:	685a      	ldr	r2, [r3, #4]
 8002940:	9b06      	ldr	r3, [sp, #24]
 8002942:	4313      	orrs	r3, r2
 8002944:	4a13      	ldr	r2, [pc, #76]	@ (8002994 <dmaStreamAllocI+0x1b4>)
 8002946:	6053      	str	r3, [r2, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 8002948:	9b05      	ldr	r3, [sp, #20]
 800294a:	685b      	ldr	r3, [r3, #4]
 800294c:	681a      	ldr	r2, [r3, #0]
 800294e:	9b05      	ldr	r3, [sp, #20]
 8002950:	685b      	ldr	r3, [r3, #4]
 8002952:	f022 020f 	bic.w	r2, r2, #15
 8002956:	601a      	str	r2, [r3, #0]
 8002958:	9b05      	ldr	r3, [sp, #20]
 800295a:	7c1b      	ldrb	r3, [r3, #16]
 800295c:	461a      	mov	r2, r3
 800295e:	230e      	movs	r3, #14
 8002960:	fa03 f202 	lsl.w	r2, r3, r2
 8002964:	9b05      	ldr	r3, [sp, #20]
 8002966:	681b      	ldr	r3, [r3, #0]
 8002968:	605a      	str	r2, [r3, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 800296a:	9b05      	ldr	r3, [sp, #20]
 800296c:	685b      	ldr	r3, [r3, #4]
 800296e:	2200      	movs	r2, #0
 8002970:	601a      	str	r2, [r3, #0]

      return dmastp;
 8002972:	9b05      	ldr	r3, [sp, #20]
 8002974:	e008      	b.n	8002988 <dmaStreamAllocI+0x1a8>
  for (i = startid; i <= endid; i++) {
 8002976:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002978:	3301      	adds	r3, #1
 800297a:	9309      	str	r3, [sp, #36]	@ 0x24
 800297c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800297e:	9b07      	ldr	r3, [sp, #28]
 8002980:	429a      	cmp	r2, r3
 8002982:	f67f af5d 	bls.w	8002840 <dmaStreamAllocI+0x60>
    }
  }

  return NULL;
 8002986:	2300      	movs	r3, #0
}
 8002988:	4618      	mov	r0, r3
 800298a:	b00b      	add	sp, #44	@ 0x2c
 800298c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002990:	08005440 	.word	0x08005440
 8002994:	2000083c 	.word	0x2000083c
 8002998:	08005328 	.word	0x08005328
 800299c:	00000000 	.word	0x00000000

080029a0 <dmaServeInterrupt>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
 80029a0:	b500      	push	{lr}
 80029a2:	b085      	sub	sp, #20
 80029a4:	9001      	str	r0, [sp, #4]
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;
 80029a6:	9b01      	ldr	r3, [sp, #4]
 80029a8:	7c5b      	ldrb	r3, [r3, #17]
 80029aa:	9303      	str	r3, [sp, #12]

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 80029ac:	9b01      	ldr	r3, [sp, #4]
 80029ae:	681b      	ldr	r3, [r3, #0]
 80029b0:	681b      	ldr	r3, [r3, #0]
 80029b2:	9a01      	ldr	r2, [sp, #4]
 80029b4:	7c12      	ldrb	r2, [r2, #16]
 80029b6:	40d3      	lsrs	r3, r2
 80029b8:	f003 030e 	and.w	r3, r3, #14
 80029bc:	9302      	str	r3, [sp, #8]
  if (flags & dmastp->channel->CCR) {
 80029be:	9b01      	ldr	r3, [sp, #4]
 80029c0:	685b      	ldr	r3, [r3, #4]
 80029c2:	681a      	ldr	r2, [r3, #0]
 80029c4:	9b02      	ldr	r3, [sp, #8]
 80029c6:	4013      	ands	r3, r2
 80029c8:	2b00      	cmp	r3, #0
 80029ca:	d01c      	beq.n	8002a06 <dmaServeInterrupt+0x66>
    dmastp->dma->IFCR = flags << dmastp->shift;
 80029cc:	9b01      	ldr	r3, [sp, #4]
 80029ce:	7c1b      	ldrb	r3, [r3, #16]
 80029d0:	4619      	mov	r1, r3
 80029d2:	9b01      	ldr	r3, [sp, #4]
 80029d4:	681b      	ldr	r3, [r3, #0]
 80029d6:	9a02      	ldr	r2, [sp, #8]
 80029d8:	408a      	lsls	r2, r1
 80029da:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 80029dc:	4a0c      	ldr	r2, [pc, #48]	@ (8002a10 <dmaServeInterrupt+0x70>)
 80029de:	9b03      	ldr	r3, [sp, #12]
 80029e0:	3301      	adds	r3, #1
 80029e2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80029e6:	2b00      	cmp	r3, #0
 80029e8:	d00d      	beq.n	8002a06 <dmaServeInterrupt+0x66>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 80029ea:	4a09      	ldr	r2, [pc, #36]	@ (8002a10 <dmaServeInterrupt+0x70>)
 80029ec:	9b03      	ldr	r3, [sp, #12]
 80029ee:	3301      	adds	r3, #1
 80029f0:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 80029f4:	4906      	ldr	r1, [pc, #24]	@ (8002a10 <dmaServeInterrupt+0x70>)
 80029f6:	9b03      	ldr	r3, [sp, #12]
 80029f8:	3301      	adds	r3, #1
 80029fa:	00db      	lsls	r3, r3, #3
 80029fc:	440b      	add	r3, r1
 80029fe:	685b      	ldr	r3, [r3, #4]
 8002a00:	9902      	ldr	r1, [sp, #8]
 8002a02:	4618      	mov	r0, r3
 8002a04:	4790      	blx	r2
    }
  }
}
 8002a06:	bf00      	nop
 8002a08:	b005      	add	sp, #20
 8002a0a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a0e:	bf00      	nop
 8002a10:	2000083c 	.word	0x2000083c
	...

08002a20 <dmaSetRequestSource>:
 * @param[in] dmastp    pointer to a @p stm32_dma_stream_t structure
 * @param[in] per       peripheral identifier
 *
 * @special
 */
void dmaSetRequestSource(const stm32_dma_stream_t *dmastp, uint32_t per) {
 8002a20:	b500      	push	{lr}
 8002a22:	b083      	sub	sp, #12
 8002a24:	9001      	str	r0, [sp, #4]
 8002a26:	9100      	str	r1, [sp, #0]

  osalDbgCheck(per < 256U);
 8002a28:	9b00      	ldr	r3, [sp, #0]
 8002a2a:	2bff      	cmp	r3, #255	@ 0xff
 8002a2c:	bf8c      	ite	hi
 8002a2e:	2301      	movhi	r3, #1
 8002a30:	2300      	movls	r3, #0
 8002a32:	b2db      	uxtb	r3, r3
 8002a34:	2b00      	cmp	r3, #0
 8002a36:	d002      	beq.n	8002a3e <dmaSetRequestSource+0x1e>
 8002a38:	4805      	ldr	r0, [pc, #20]	@ (8002a50 <dmaSetRequestSource+0x30>)
 8002a3a:	f000 fc19 	bl	8003270 <chSysHalt>

  dmastp->mux->CCR = per;
 8002a3e:	9b01      	ldr	r3, [sp, #4]
 8002a40:	68db      	ldr	r3, [r3, #12]
 8002a42:	9a00      	ldr	r2, [sp, #0]
 8002a44:	601a      	str	r2, [r3, #0]
}
 8002a46:	bf00      	nop
 8002a48:	b003      	add	sp, #12
 8002a4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a4e:	bf00      	nop
 8002a50:	08005450 	.word	0x08005450
	...

08002a60 <_pal_lld_init>:
/**
 * @brief   PAL driver initialization.
 *
 * @notapi
 */
void _pal_lld_init(void) {
 8002a60:	b082      	sub	sp, #8

#if PAL_USE_CALLBACKS || PAL_USE_WAIT || defined(__DOXYGEN__)
  unsigned i;

  for (i = 0; i < 16; i++) {
 8002a62:	2300      	movs	r3, #0
 8002a64:	9301      	str	r3, [sp, #4]
 8002a66:	e00d      	b.n	8002a84 <_pal_lld_init+0x24>
    _pal_init_event(i);
 8002a68:	4a0a      	ldr	r2, [pc, #40]	@ (8002a94 <_pal_lld_init+0x34>)
 8002a6a:	9b01      	ldr	r3, [sp, #4]
 8002a6c:	2100      	movs	r1, #0
 8002a6e:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
 8002a72:	4a08      	ldr	r2, [pc, #32]	@ (8002a94 <_pal_lld_init+0x34>)
 8002a74:	9b01      	ldr	r3, [sp, #4]
 8002a76:	00db      	lsls	r3, r3, #3
 8002a78:	4413      	add	r3, r2
 8002a7a:	2200      	movs	r2, #0
 8002a7c:	605a      	str	r2, [r3, #4]
  for (i = 0; i < 16; i++) {
 8002a7e:	9b01      	ldr	r3, [sp, #4]
 8002a80:	3301      	adds	r3, #1
 8002a82:	9301      	str	r3, [sp, #4]
 8002a84:	9b01      	ldr	r3, [sp, #4]
 8002a86:	2b0f      	cmp	r3, #15
 8002a88:	d9ee      	bls.n	8002a68 <_pal_lld_init+0x8>
  }
#endif
}
 8002a8a:	bf00      	nop
 8002a8c:	bf00      	nop
 8002a8e:	b002      	add	sp, #8
 8002a90:	4770      	bx	lr
 8002a92:	bf00      	nop
 8002a94:	200008b4 	.word	0x200008b4
	...

08002aa0 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 8002aa0:	b500      	push	{lr}
 8002aa2:	b083      	sub	sp, #12
 8002aa4:	2330      	movs	r3, #48	@ 0x30
 8002aa6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002aa8:	9b01      	ldr	r3, [sp, #4]
 8002aaa:	f383 8811 	msr	BASEPRI, r3
}
 8002aae:	bf00      	nop
}
 8002ab0:	bf00      	nop
}
 8002ab2:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002ab4:	f000 fc94 	bl	80033e0 <__dbg_check_lock_from_isr>
}
 8002ab8:	bf00      	nop
 8002aba:	b003      	add	sp, #12
 8002abc:	f85d fb04 	ldr.w	pc, [sp], #4

08002ac0 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8002ac0:	b500      	push	{lr}
 8002ac2:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002ac4:	f000 fcb4 	bl	8003430 <__dbg_check_unlock_from_isr>
 8002ac8:	2300      	movs	r3, #0
 8002aca:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002acc:	9b01      	ldr	r3, [sp, #4]
 8002ace:	f383 8811 	msr	BASEPRI, r3
}
 8002ad2:	bf00      	nop
}
 8002ad4:	bf00      	nop
}
 8002ad6:	bf00      	nop
}
 8002ad8:	bf00      	nop
 8002ada:	b003      	add	sp, #12
 8002adc:	f85d fb04 	ldr.w	pc, [sp], #4

08002ae0 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 8002ae0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002ae2:	f7ff ffdd 	bl	8002aa0 <chSysLockFromISR.lto_priv.1>
}
 8002ae6:	bf00      	nop
 8002ae8:	bd08      	pop	{r3, pc}
 8002aea:	bf00      	nop
 8002aec:	0000      	movs	r0, r0
	...

08002af0 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 8002af0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002af2:	f7ff ffe5 	bl	8002ac0 <chSysUnlockFromISR.lto_priv.1>
}
 8002af6:	bf00      	nop
 8002af8:	bd08      	pop	{r3, pc}
 8002afa:	bf00      	nop
 8002afc:	0000      	movs	r0, r0
	...

08002b00 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 8002b00:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 8002b02:	f000 fbcd 	bl	80032a0 <chSysTimerHandlerI>
}
 8002b06:	bf00      	nop
 8002b08:	bd08      	pop	{r3, pc}
 8002b0a:	bf00      	nop
 8002b0c:	0000      	movs	r0, r0
	...

08002b10 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002b10:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002b14:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002b16:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002b1a:	f043 0301 	orr.w	r3, r3, #1
 8002b1e:	6593      	str	r3, [r2, #88]	@ 0x58
 8002b20:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002b24:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8002b26:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002b2a:	f043 0301 	orr.w	r3, r3, #1
 8002b2e:	6793      	str	r3, [r2, #120]	@ 0x78
 8002b30:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002b34:	6f9b      	ldr	r3, [r3, #120]	@ 0x78

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002b36:	4b15      	ldr	r3, [pc, #84]	@ (8002b8c <st_lld_init+0x7c>)
 8002b38:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002b3a:	4a14      	ldr	r2, [pc, #80]	@ (8002b8c <st_lld_init+0x7c>)
 8002b3c:	f043 0301 	orr.w	r3, r3, #1
 8002b40:	63d3      	str	r3, [r2, #60]	@ 0x3c

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002b42:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b46:	f640 427f 	movw	r2, #3199	@ 0xc7f
 8002b4a:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002b4c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b50:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8002b54:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002b56:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b5a:	2200      	movs	r2, #0
 8002b5c:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002b5e:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b62:	2200      	movs	r2, #0
 8002b64:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 8002b66:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b6a:	2200      	movs	r2, #0
 8002b6c:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002b6e:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b72:	2200      	movs	r2, #0
 8002b74:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002b76:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b7a:	2201      	movs	r2, #1
 8002b7c:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002b7e:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b82:	2201      	movs	r2, #1
 8002b84:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8002b86:	bf00      	nop
 8002b88:	4770      	bx	lr
 8002b8a:	bf00      	nop
 8002b8c:	e0042000 	.word	0xe0042000

08002b90 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8002b90:	b500      	push	{lr}
 8002b92:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8002b94:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002b98:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 8002b9a:	9b01      	ldr	r3, [sp, #4]
 8002b9c:	691b      	ldr	r3, [r3, #16]
 8002b9e:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002ba0:	9b01      	ldr	r3, [sp, #4]
 8002ba2:	68db      	ldr	r3, [r3, #12]
 8002ba4:	b2db      	uxtb	r3, r3
 8002ba6:	9a00      	ldr	r2, [sp, #0]
 8002ba8:	4013      	ands	r3, r2
 8002baa:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 8002bac:	9b00      	ldr	r3, [sp, #0]
 8002bae:	43da      	mvns	r2, r3
 8002bb0:	9b01      	ldr	r3, [sp, #4]
 8002bb2:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8002bb4:	9b00      	ldr	r3, [sp, #0]
 8002bb6:	f003 0302 	and.w	r3, r3, #2
 8002bba:	2b00      	cmp	r3, #0
 8002bbc:	d005      	beq.n	8002bca <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 8002bbe:	f7ff ff8f 	bl	8002ae0 <osalSysLockFromISR.lto_priv.1>
    osalOsTimerHandlerI();
 8002bc2:	f7ff ff9d 	bl	8002b00 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8002bc6:	f7ff ff93 	bl	8002af0 <osalSysUnlockFromISR.lto_priv.1>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 8002bca:	bf00      	nop
 8002bcc:	b003      	add	sp, #12
 8002bce:	f85d fb04 	ldr.w	pc, [sp], #4
 8002bd2:	bf00      	nop
	...

08002be0 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8002be0:	b508      	push	{r3, lr}

#if STM32_GPT_USE_TIM1
  /* Driver initialization.*/
  GPTD1.tim = STM32_TIM1;
 8002be2:	4b04      	ldr	r3, [pc, #16]	@ (8002bf4 <gpt_lld_init+0x14>)
 8002be4:	4a04      	ldr	r2, [pc, #16]	@ (8002bf8 <gpt_lld_init+0x18>)
 8002be6:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD1);
 8002be8:	4802      	ldr	r0, [pc, #8]	@ (8002bf4 <gpt_lld_init+0x14>)
 8002bea:	f7fe f949 	bl	8000e80 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 8002bee:	bf00      	nop
 8002bf0:	bd08      	pop	{r3, pc}
 8002bf2:	bf00      	nop
 8002bf4:	20000934 	.word	0x20000934
 8002bf8:	40012c00 	.word	0x40012c00
 8002bfc:	00000000 	.word	0x00000000

08002c00 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 8002c00:	b084      	sub	sp, #16
 8002c02:	9001      	str	r0, [sp, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 8002c04:	9b01      	ldr	r3, [sp, #4]
 8002c06:	781b      	ldrb	r3, [r3, #0]
 8002c08:	2b01      	cmp	r3, #1
 8002c0a:	d12f      	bne.n	8002c6c <gpt_lld_start+0x6c>
    /* Clock activation.*/
#if STM32_GPT_USE_TIM1
    if (&GPTD1 == gptp) {
 8002c0c:	9b01      	ldr	r3, [sp, #4]
 8002c0e:	4a2c      	ldr	r2, [pc, #176]	@ (8002cc0 <gpt_lld_start+0xc0>)
 8002c10:	4293      	cmp	r3, r2
 8002c12:	d12b      	bne.n	8002c6c <gpt_lld_start+0x6c>
      rccEnableTIM1(true);
 8002c14:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002c18:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8002c1a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002c1e:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8002c22:	6613      	str	r3, [r2, #96]	@ 0x60
 8002c24:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002c28:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8002c2c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002c30:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8002c34:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 8002c38:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002c3c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
      rccResetTIM1();
 8002c40:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002c44:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002c46:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002c4a:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8002c4e:	6413      	str	r3, [r2, #64]	@ 0x40
 8002c50:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002c54:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002c56:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002c5a:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8002c5e:	6413      	str	r3, [r2, #64]	@ 0x40
 8002c60:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002c64:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_GPT_TIM1_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM1CLK)
      gptp->clock = STM32_TIM1CLK;
#else
      gptp->clock = STM32_TIMCLK2;
 8002c66:	9b01      	ldr	r3, [sp, #4]
 8002c68:	4a16      	ldr	r2, [pc, #88]	@ (8002cc4 <gpt_lld_start+0xc4>)
 8002c6a:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8002c6c:	9b01      	ldr	r3, [sp, #4]
 8002c6e:	689a      	ldr	r2, [r3, #8]
 8002c70:	9b01      	ldr	r3, [sp, #4]
 8002c72:	685b      	ldr	r3, [r3, #4]
 8002c74:	681b      	ldr	r3, [r3, #0]
 8002c76:	fbb2 f3f3 	udiv	r3, r2, r3
 8002c7a:	b29b      	uxth	r3, r3
 8002c7c:	3b01      	subs	r3, #1
 8002c7e:	f8ad 300e 	strh.w	r3, [sp, #14]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0U;                         /* Initially stopped.       */
 8002c82:	9b01      	ldr	r3, [sp, #4]
 8002c84:	68db      	ldr	r3, [r3, #12]
 8002c86:	2200      	movs	r2, #0
 8002c88:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 8002c8a:	9b01      	ldr	r3, [sp, #4]
 8002c8c:	685a      	ldr	r2, [r3, #4]
 8002c8e:	9b01      	ldr	r3, [sp, #4]
 8002c90:	68db      	ldr	r3, [r3, #12]
 8002c92:	6892      	ldr	r2, [r2, #8]
 8002c94:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8002c96:	9b01      	ldr	r3, [sp, #4]
 8002c98:	68db      	ldr	r3, [r3, #12]
 8002c9a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 8002c9e:	629a      	str	r2, [r3, #40]	@ 0x28
  gptp->tim->SR   = 0U;                         /* Clear pending IRQs.      */
 8002ca0:	9b01      	ldr	r3, [sp, #4]
 8002ca2:	68db      	ldr	r3, [r3, #12]
 8002ca4:	2200      	movs	r2, #0
 8002ca6:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 8002ca8:	9b01      	ldr	r3, [sp, #4]
 8002caa:	685b      	ldr	r3, [r3, #4]
 8002cac:	68da      	ldr	r2, [r3, #12]
 8002cae:	9b01      	ldr	r3, [sp, #4]
 8002cb0:	68db      	ldr	r3, [r3, #12]
 8002cb2:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002cb6:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 8002cb8:	bf00      	nop
 8002cba:	b004      	add	sp, #16
 8002cbc:	4770      	bx	lr
 8002cbe:	bf00      	nop
 8002cc0:	20000934 	.word	0x20000934
 8002cc4:	01e84800 	.word	0x01e84800
	...

08002cd0 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 8002cd0:	b082      	sub	sp, #8
 8002cd2:	9001      	str	r0, [sp, #4]
 8002cd4:	9100      	str	r1, [sp, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8002cd6:	9b01      	ldr	r3, [sp, #4]
 8002cd8:	68db      	ldr	r3, [r3, #12]
 8002cda:	9a00      	ldr	r2, [sp, #0]
 8002cdc:	3a01      	subs	r2, #1
 8002cde:	62da      	str	r2, [r3, #44]	@ 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 8002ce0:	9b01      	ldr	r3, [sp, #4]
 8002ce2:	68db      	ldr	r3, [r3, #12]
 8002ce4:	2201      	movs	r2, #1
 8002ce6:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0U;                          /* Reset counter.           */
 8002ce8:	9b01      	ldr	r3, [sp, #4]
 8002cea:	68db      	ldr	r3, [r3, #12]
 8002cec:	2200      	movs	r2, #0
 8002cee:	625a      	str	r2, [r3, #36]	@ 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8002cf0:	9b01      	ldr	r3, [sp, #4]
 8002cf2:	68db      	ldr	r3, [r3, #12]
 8002cf4:	2200      	movs	r2, #0
 8002cf6:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8002cf8:	9b01      	ldr	r3, [sp, #4]
 8002cfa:	685b      	ldr	r3, [r3, #4]
 8002cfc:	685b      	ldr	r3, [r3, #4]
 8002cfe:	2b00      	cmp	r3, #0
 8002d00:	d007      	beq.n	8002d12 <gpt_lld_start_timer+0x42>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8002d02:	9b01      	ldr	r3, [sp, #4]
 8002d04:	68db      	ldr	r3, [r3, #12]
 8002d06:	68da      	ldr	r2, [r3, #12]
 8002d08:	9b01      	ldr	r3, [sp, #4]
 8002d0a:	68db      	ldr	r3, [r3, #12]
 8002d0c:	f042 0201 	orr.w	r2, r2, #1
 8002d10:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8002d12:	9b01      	ldr	r3, [sp, #4]
 8002d14:	68db      	ldr	r3, [r3, #12]
 8002d16:	2285      	movs	r2, #133	@ 0x85
 8002d18:	601a      	str	r2, [r3, #0]
}
 8002d1a:	bf00      	nop
 8002d1c:	b002      	add	sp, #8
 8002d1e:	4770      	bx	lr

08002d20 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 8002d20:	b082      	sub	sp, #8
 8002d22:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1 = 0U;                          /* Initially stopped.       */
 8002d24:	9b01      	ldr	r3, [sp, #4]
 8002d26:	68db      	ldr	r3, [r3, #12]
 8002d28:	2200      	movs	r2, #0
 8002d2a:	601a      	str	r2, [r3, #0]
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8002d2c:	9b01      	ldr	r3, [sp, #4]
 8002d2e:	68db      	ldr	r3, [r3, #12]
 8002d30:	2200      	movs	r2, #0
 8002d32:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8002d34:	9b01      	ldr	r3, [sp, #4]
 8002d36:	68db      	ldr	r3, [r3, #12]
 8002d38:	68da      	ldr	r2, [r3, #12]
 8002d3a:	9b01      	ldr	r3, [sp, #4]
 8002d3c:	68db      	ldr	r3, [r3, #12]
 8002d3e:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002d42:	60da      	str	r2, [r3, #12]
}
 8002d44:	bf00      	nop
 8002d46:	b002      	add	sp, #8
 8002d48:	4770      	bx	lr
 8002d4a:	bf00      	nop
 8002d4c:	0000      	movs	r0, r0
	...

08002d50 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 8002d50:	b500      	push	{lr}
 8002d52:	b085      	sub	sp, #20
 8002d54:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 8002d56:	9b01      	ldr	r3, [sp, #4]
 8002d58:	68db      	ldr	r3, [r3, #12]
 8002d5a:	691b      	ldr	r3, [r3, #16]
 8002d5c:	9303      	str	r3, [sp, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002d5e:	9b01      	ldr	r3, [sp, #4]
 8002d60:	68db      	ldr	r3, [r3, #12]
 8002d62:	68db      	ldr	r3, [r3, #12]
 8002d64:	b2db      	uxtb	r3, r3
 8002d66:	9a03      	ldr	r2, [sp, #12]
 8002d68:	4013      	ands	r3, r2
 8002d6a:	9303      	str	r3, [sp, #12]
  gptp->tim->SR = ~sr;
 8002d6c:	9b01      	ldr	r3, [sp, #4]
 8002d6e:	68db      	ldr	r3, [r3, #12]
 8002d70:	9a03      	ldr	r2, [sp, #12]
 8002d72:	43d2      	mvns	r2, r2
 8002d74:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8002d76:	9b03      	ldr	r3, [sp, #12]
 8002d78:	f003 0301 	and.w	r3, r3, #1
 8002d7c:	2b00      	cmp	r3, #0
 8002d7e:	d013      	beq.n	8002da8 <gpt_lld_serve_interrupt+0x58>
    _gpt_isr_invoke_cb(gptp);
 8002d80:	9b01      	ldr	r3, [sp, #4]
 8002d82:	781b      	ldrb	r3, [r3, #0]
 8002d84:	2b04      	cmp	r3, #4
 8002d86:	d105      	bne.n	8002d94 <gpt_lld_serve_interrupt+0x44>
 8002d88:	9b01      	ldr	r3, [sp, #4]
 8002d8a:	2202      	movs	r2, #2
 8002d8c:	701a      	strb	r2, [r3, #0]
 8002d8e:	9801      	ldr	r0, [sp, #4]
 8002d90:	f7ff ffc6 	bl	8002d20 <gpt_lld_stop_timer>
 8002d94:	9b01      	ldr	r3, [sp, #4]
 8002d96:	685b      	ldr	r3, [r3, #4]
 8002d98:	685b      	ldr	r3, [r3, #4]
 8002d9a:	2b00      	cmp	r3, #0
 8002d9c:	d004      	beq.n	8002da8 <gpt_lld_serve_interrupt+0x58>
 8002d9e:	9b01      	ldr	r3, [sp, #4]
 8002da0:	685b      	ldr	r3, [r3, #4]
 8002da2:	685b      	ldr	r3, [r3, #4]
 8002da4:	9801      	ldr	r0, [sp, #4]
 8002da6:	4798      	blx	r3
  }
}
 8002da8:	bf00      	nop
 8002daa:	b005      	add	sp, #20
 8002dac:	f85d fb04 	ldr.w	pc, [sp], #4

08002db0 <chSysLockFromISR.lto_priv.2>:
static inline void chSysLockFromISR(void) {
 8002db0:	b500      	push	{lr}
 8002db2:	b083      	sub	sp, #12
 8002db4:	2330      	movs	r3, #48	@ 0x30
 8002db6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002db8:	9b01      	ldr	r3, [sp, #4]
 8002dba:	f383 8811 	msr	BASEPRI, r3
}
 8002dbe:	bf00      	nop
}
 8002dc0:	bf00      	nop
}
 8002dc2:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002dc4:	f000 fb0c 	bl	80033e0 <__dbg_check_lock_from_isr>
}
 8002dc8:	bf00      	nop
 8002dca:	b003      	add	sp, #12
 8002dcc:	f85d fb04 	ldr.w	pc, [sp], #4

08002dd0 <chSysUnlockFromISR.lto_priv.2>:
static inline void chSysUnlockFromISR(void) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002dd4:	f000 fb2c 	bl	8003430 <__dbg_check_unlock_from_isr>
 8002dd8:	2300      	movs	r3, #0
 8002dda:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002ddc:	9b01      	ldr	r3, [sp, #4]
 8002dde:	f383 8811 	msr	BASEPRI, r3
}
 8002de2:	bf00      	nop
}
 8002de4:	bf00      	nop
}
 8002de6:	bf00      	nop
}
 8002de8:	bf00      	nop
 8002dea:	b003      	add	sp, #12
 8002dec:	f85d fb04 	ldr.w	pc, [sp], #4

08002df0 <osalSysLockFromISR.lto_priv.2>:
static inline void osalSysLockFromISR(void) {
 8002df0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002df2:	f7ff ffdd 	bl	8002db0 <chSysLockFromISR.lto_priv.2>
}
 8002df6:	bf00      	nop
 8002df8:	bd08      	pop	{r3, pc}
 8002dfa:	bf00      	nop
 8002dfc:	0000      	movs	r0, r0
	...

08002e00 <osalSysUnlockFromISR.lto_priv.2>:
static inline void osalSysUnlockFromISR(void) {
 8002e00:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002e02:	f7ff ffe5 	bl	8002dd0 <chSysUnlockFromISR.lto_priv.2>
}
 8002e06:	bf00      	nop
 8002e08:	bd08      	pop	{r3, pc}
 8002e0a:	bf00      	nop
 8002e0c:	0000      	movs	r0, r0
	...

08002e10 <osalEventBroadcastFlagsI.lto_priv.2>:
                                            eventflags_t flags) {
 8002e10:	b500      	push	{lr}
 8002e12:	b083      	sub	sp, #12
 8002e14:	9001      	str	r0, [sp, #4]
 8002e16:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 8002e18:	9900      	ldr	r1, [sp, #0]
 8002e1a:	9801      	ldr	r0, [sp, #4]
 8002e1c:	f001 fe80 	bl	8004b20 <chEvtBroadcastFlagsI>
}
 8002e20:	bf00      	nop
 8002e22:	b003      	add	sp, #12
 8002e24:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002e30 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 8002e30:	b500      	push	{lr}
 8002e32:	b085      	sub	sp, #20
 8002e34:	9001      	str	r0, [sp, #4]
 8002e36:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 8002e38:	2300      	movs	r3, #0
 8002e3a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 8002e3c:	9b00      	ldr	r3, [sp, #0]
 8002e3e:	f003 0308 	and.w	r3, r3, #8
 8002e42:	2b00      	cmp	r3, #0
 8002e44:	d003      	beq.n	8002e4e <set_error+0x1e>
    sts |= SD_OVERRUN_ERROR;
 8002e46:	9b03      	ldr	r3, [sp, #12]
 8002e48:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8002e4c:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 8002e4e:	9b00      	ldr	r3, [sp, #0]
 8002e50:	f003 0301 	and.w	r3, r3, #1
 8002e54:	2b00      	cmp	r3, #0
 8002e56:	d003      	beq.n	8002e60 <set_error+0x30>
    sts |= SD_PARITY_ERROR;
 8002e58:	9b03      	ldr	r3, [sp, #12]
 8002e5a:	f043 0320 	orr.w	r3, r3, #32
 8002e5e:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 8002e60:	9b00      	ldr	r3, [sp, #0]
 8002e62:	f003 0302 	and.w	r3, r3, #2
 8002e66:	2b00      	cmp	r3, #0
 8002e68:	d003      	beq.n	8002e72 <set_error+0x42>
    sts |= SD_FRAMING_ERROR;
 8002e6a:	9b03      	ldr	r3, [sp, #12]
 8002e6c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8002e70:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 8002e72:	9b00      	ldr	r3, [sp, #0]
 8002e74:	f003 0304 	and.w	r3, r3, #4
 8002e78:	2b00      	cmp	r3, #0
 8002e7a:	d003      	beq.n	8002e84 <set_error+0x54>
    sts |= SD_NOISE_ERROR;
 8002e7c:	9b03      	ldr	r3, [sp, #12]
 8002e7e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8002e82:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 8002e84:	f7ff ffb4 	bl	8002df0 <osalSysLockFromISR.lto_priv.2>
  chnAddFlagsI(sdp, sts);
 8002e88:	9b01      	ldr	r3, [sp, #4]
 8002e8a:	3304      	adds	r3, #4
 8002e8c:	9903      	ldr	r1, [sp, #12]
 8002e8e:	4618      	mov	r0, r3
 8002e90:	f7ff ffbe 	bl	8002e10 <osalEventBroadcastFlagsI.lto_priv.2>
  osalSysUnlockFromISR();
 8002e94:	f7ff ffb4 	bl	8002e00 <osalSysUnlockFromISR.lto_priv.2>
}
 8002e98:	bf00      	nop
 8002e9a:	b005      	add	sp, #20
 8002e9c:	f85d fb04 	ldr.w	pc, [sp], #4

08002ea0 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 8002ea0:	b082      	sub	sp, #8
 8002ea2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8002ea4:	4b04      	ldr	r3, [pc, #16]	@ (8002eb8 <notify1+0x18>)
 8002ea6:	681b      	ldr	r3, [r3, #0]
 8002ea8:	4a03      	ldr	r2, [pc, #12]	@ (8002eb8 <notify1+0x18>)
 8002eaa:	f043 03c0 	orr.w	r3, r3, #192	@ 0xc0
 8002eae:	6013      	str	r3, [r2, #0]
}
 8002eb0:	bf00      	nop
 8002eb2:	b002      	add	sp, #8
 8002eb4:	4770      	bx	lr
 8002eb6:	bf00      	nop
 8002eb8:	40013800 	.word	0x40013800
 8002ebc:	00000000 	.word	0x00000000

08002ec0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8002ec0:	b500      	push	{lr}
 8002ec2:	b083      	sub	sp, #12

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1);
 8002ec4:	480e      	ldr	r0, [pc, #56]	@ (8002f00 <sd_lld_init+0x40>)
 8002ec6:	f7fe f99b 	bl	8001200 <sdObjectInit>
  iqObjectInit(&SD1.iqueue, sd_in_buf1, sizeof sd_in_buf1, NULL, &SD1);
 8002eca:	4b0d      	ldr	r3, [pc, #52]	@ (8002f00 <sd_lld_init+0x40>)
 8002ecc:	9300      	str	r3, [sp, #0]
 8002ece:	2300      	movs	r3, #0
 8002ed0:	2210      	movs	r2, #16
 8002ed2:	490c      	ldr	r1, [pc, #48]	@ (8002f04 <sd_lld_init+0x44>)
 8002ed4:	480c      	ldr	r0, [pc, #48]	@ (8002f08 <sd_lld_init+0x48>)
 8002ed6:	f7fd fc13 	bl	8000700 <iqObjectInit>
  oqObjectInit(&SD1.oqueue, sd_out_buf1, sizeof sd_out_buf1, notify1, &SD1);
 8002eda:	4b09      	ldr	r3, [pc, #36]	@ (8002f00 <sd_lld_init+0x40>)
 8002edc:	9300      	str	r3, [sp, #0]
 8002ede:	4b0b      	ldr	r3, [pc, #44]	@ (8002f0c <sd_lld_init+0x4c>)
 8002ee0:	2210      	movs	r2, #16
 8002ee2:	490b      	ldr	r1, [pc, #44]	@ (8002f10 <sd_lld_init+0x50>)
 8002ee4:	480b      	ldr	r0, [pc, #44]	@ (8002f14 <sd_lld_init+0x54>)
 8002ee6:	f7fd fd0b 	bl	8000900 <oqObjectInit>
  SD1.usart = USART1;
 8002eea:	4b05      	ldr	r3, [pc, #20]	@ (8002f00 <sd_lld_init+0x40>)
 8002eec:	4a0a      	ldr	r2, [pc, #40]	@ (8002f18 <sd_lld_init+0x58>)
 8002eee:	655a      	str	r2, [r3, #84]	@ 0x54
  SD1.clock = STM32_USART1CLK;
 8002ef0:	4b03      	ldr	r3, [pc, #12]	@ (8002f00 <sd_lld_init+0x40>)
 8002ef2:	4a0a      	ldr	r2, [pc, #40]	@ (8002f1c <sd_lld_init+0x5c>)
 8002ef4:	659a      	str	r2, [r3, #88]	@ 0x58
  LPSD1.clock = STM32_LPUART1CLK;
#if !defined(STM32_LPUART1_SUPPRESS_ISR) && defined(STM32_LPUART1_NUMBER)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_SERIAL_LPUART1_PRIORITY);
#endif
#endif
}
 8002ef6:	bf00      	nop
 8002ef8:	b003      	add	sp, #12
 8002efa:	f85d fb04 	ldr.w	pc, [sp], #4
 8002efe:	bf00      	nop
 8002f00:	20000944 	.word	0x20000944
 8002f04:	200009a4 	.word	0x200009a4
 8002f08:	20000950 	.word	0x20000950
 8002f0c:	08002ea1 	.word	0x08002ea1
 8002f10:	200009b4 	.word	0x200009b4
 8002f14:	20000974 	.word	0x20000974
 8002f18:	40013800 	.word	0x40013800
 8002f1c:	01e84800 	.word	0x01e84800

08002f20 <sd_lld_serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 8002f20:	b500      	push	{lr}
 8002f22:	b087      	sub	sp, #28
 8002f24:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8002f26:	9b01      	ldr	r3, [sp, #4]
 8002f28:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002f2a:	9303      	str	r3, [sp, #12]
  uint32_t cr1;
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8002f2c:	9b03      	ldr	r3, [sp, #12]
 8002f2e:	69db      	ldr	r3, [r3, #28]
 8002f30:	9304      	str	r3, [sp, #16]
  u->ICR = isr;
 8002f32:	9b03      	ldr	r3, [sp, #12]
 8002f34:	9a04      	ldr	r2, [sp, #16]
 8002f36:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8002f38:	9b04      	ldr	r3, [sp, #16]
 8002f3a:	f003 030f 	and.w	r3, r3, #15
 8002f3e:	2b00      	cmp	r3, #0
 8002f40:	d003      	beq.n	8002f4a <sd_lld_serve_interrupt+0x2a>
    set_error(sdp, isr);
 8002f42:	9904      	ldr	r1, [sp, #16]
 8002f44:	9801      	ldr	r0, [sp, #4]
 8002f46:	f7ff ff73 	bl	8002e30 <set_error>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8002f4a:	9b04      	ldr	r3, [sp, #16]
 8002f4c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8002f50:	2b00      	cmp	r3, #0
 8002f52:	d01e      	beq.n	8002f92 <sd_lld_serve_interrupt+0x72>
    osalSysLockFromISR();
 8002f54:	f7ff ff4c 	bl	8002df0 <osalSysLockFromISR.lto_priv.2>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8002f58:	9b01      	ldr	r3, [sp, #4]
 8002f5a:	3304      	adds	r3, #4
 8002f5c:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8002f60:	4618      	mov	r0, r3
 8002f62:	f7ff ff55 	bl	8002e10 <osalEventBroadcastFlagsI.lto_priv.2>
    osalSysUnlockFromISR();
 8002f66:	f7ff ff4b 	bl	8002e00 <osalSysUnlockFromISR.lto_priv.2>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 8002f6a:	e012      	b.n	8002f92 <sd_lld_serve_interrupt+0x72>
    osalSysLockFromISR();
 8002f6c:	f7ff ff40 	bl	8002df0 <osalSysLockFromISR.lto_priv.2>
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8002f70:	9b03      	ldr	r3, [sp, #12]
 8002f72:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002f74:	b2da      	uxtb	r2, r3
 8002f76:	9b01      	ldr	r3, [sp, #4]
 8002f78:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8002f7c:	4013      	ands	r3, r2
 8002f7e:	b2db      	uxtb	r3, r3
 8002f80:	4619      	mov	r1, r3
 8002f82:	9801      	ldr	r0, [sp, #4]
 8002f84:	f7fe f954 	bl	8001230 <sdIncomingDataI>
    osalSysUnlockFromISR();
 8002f88:	f7ff ff3a 	bl	8002e00 <osalSysUnlockFromISR.lto_priv.2>

    isr = u->ISR;
 8002f8c:	9b03      	ldr	r3, [sp, #12]
 8002f8e:	69db      	ldr	r3, [r3, #28]
 8002f90:	9304      	str	r3, [sp, #16]
  while (isr & USART_ISR_RXNE) {
 8002f92:	9b04      	ldr	r3, [sp, #16]
 8002f94:	f003 0320 	and.w	r3, r3, #32
 8002f98:	2b00      	cmp	r3, #0
 8002f9a:	d1e7      	bne.n	8002f6c <sd_lld_serve_interrupt+0x4c>
  }

  /* Caching CR1.*/
  cr1 = u->CR1;
 8002f9c:	9b03      	ldr	r3, [sp, #12]
 8002f9e:	681b      	ldr	r3, [r3, #0]
 8002fa0:	9305      	str	r3, [sp, #20]
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
 8002fa2:	9b05      	ldr	r3, [sp, #20]
 8002fa4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002fa8:	2b00      	cmp	r3, #0
 8002faa:	d025      	beq.n	8002ff8 <sd_lld_serve_interrupt+0xd8>
    while (isr & USART_ISR_TXE) {
 8002fac:	e01f      	b.n	8002fee <sd_lld_serve_interrupt+0xce>
      msg_t b;

      osalSysLockFromISR();
 8002fae:	f7ff ff1f 	bl	8002df0 <osalSysLockFromISR.lto_priv.2>
      b = oqGetI(&sdp->oqueue);
 8002fb2:	9b01      	ldr	r3, [sp, #4]
 8002fb4:	3330      	adds	r3, #48	@ 0x30
 8002fb6:	4618      	mov	r0, r3
 8002fb8:	f7fd fd12 	bl	80009e0 <oqGetI>
 8002fbc:	9002      	str	r0, [sp, #8]
      if (b < MSG_OK) {
 8002fbe:	9b02      	ldr	r3, [sp, #8]
 8002fc0:	2b00      	cmp	r3, #0
 8002fc2:	da0c      	bge.n	8002fde <sd_lld_serve_interrupt+0xbe>
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8002fc4:	9b01      	ldr	r3, [sp, #4]
 8002fc6:	3304      	adds	r3, #4
 8002fc8:	2108      	movs	r1, #8
 8002fca:	4618      	mov	r0, r3
 8002fcc:	f7ff ff20 	bl	8002e10 <osalEventBroadcastFlagsI.lto_priv.2>
        cr1 &= ~USART_CR1_TXEIE;
 8002fd0:	9b05      	ldr	r3, [sp, #20]
 8002fd2:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8002fd6:	9305      	str	r3, [sp, #20]
        osalSysUnlockFromISR();
 8002fd8:	f7ff ff12 	bl	8002e00 <osalSysUnlockFromISR.lto_priv.2>
        break;
 8002fdc:	e00c      	b.n	8002ff8 <sd_lld_serve_interrupt+0xd8>
      }
      u->TDR = b;
 8002fde:	9a02      	ldr	r2, [sp, #8]
 8002fe0:	9b03      	ldr	r3, [sp, #12]
 8002fe2:	629a      	str	r2, [r3, #40]	@ 0x28
      osalSysUnlockFromISR();
 8002fe4:	f7ff ff0c 	bl	8002e00 <osalSysUnlockFromISR.lto_priv.2>

      isr = u->ISR;
 8002fe8:	9b03      	ldr	r3, [sp, #12]
 8002fea:	69db      	ldr	r3, [r3, #28]
 8002fec:	9304      	str	r3, [sp, #16]
    while (isr & USART_ISR_TXE) {
 8002fee:	9b04      	ldr	r3, [sp, #16]
 8002ff0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002ff4:	2b00      	cmp	r3, #0
 8002ff6:	d1da      	bne.n	8002fae <sd_lld_serve_interrupt+0x8e>
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 8002ff8:	9b05      	ldr	r3, [sp, #20]
 8002ffa:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002ffe:	2b00      	cmp	r3, #0
 8003000:	d024      	beq.n	800304c <sd_lld_serve_interrupt+0x12c>
 8003002:	9b04      	ldr	r3, [sp, #16]
 8003004:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8003008:	2b00      	cmp	r3, #0
 800300a:	d01f      	beq.n	800304c <sd_lld_serve_interrupt+0x12c>
    osalSysLockFromISR();
 800300c:	f7ff fef0 	bl	8002df0 <osalSysLockFromISR.lto_priv.2>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8003010:	9b01      	ldr	r3, [sp, #4]
 8003012:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8003014:	9b01      	ldr	r3, [sp, #4]
 8003016:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8003018:	429a      	cmp	r2, r3
 800301a:	d105      	bne.n	8003028 <sd_lld_serve_interrupt+0x108>
 800301c:	9b01      	ldr	r3, [sp, #4]
 800301e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8003020:	2b00      	cmp	r3, #0
 8003022:	d001      	beq.n	8003028 <sd_lld_serve_interrupt+0x108>
 8003024:	2301      	movs	r3, #1
 8003026:	e000      	b.n	800302a <sd_lld_serve_interrupt+0x10a>
 8003028:	2300      	movs	r3, #0
 800302a:	f003 0301 	and.w	r3, r3, #1
 800302e:	b2db      	uxtb	r3, r3
 8003030:	2b00      	cmp	r3, #0
 8003032:	d009      	beq.n	8003048 <sd_lld_serve_interrupt+0x128>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8003034:	9b01      	ldr	r3, [sp, #4]
 8003036:	3304      	adds	r3, #4
 8003038:	2110      	movs	r1, #16
 800303a:	4618      	mov	r0, r3
 800303c:	f7ff fee8 	bl	8002e10 <osalEventBroadcastFlagsI.lto_priv.2>
      cr1 &= ~USART_CR1_TCIE;
 8003040:	9b05      	ldr	r3, [sp, #20]
 8003042:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8003046:	9305      	str	r3, [sp, #20]
    }
    osalSysUnlockFromISR();
 8003048:	f7ff feda 	bl	8002e00 <osalSysUnlockFromISR.lto_priv.2>
  }

  /* Writing CR1 once.*/
  u->CR1 = cr1;
 800304c:	9b03      	ldr	r3, [sp, #12]
 800304e:	9a05      	ldr	r2, [sp, #20]
 8003050:	601a      	str	r2, [r3, #0]
}
 8003052:	bf00      	nop
 8003054:	b007      	add	sp, #28
 8003056:	f85d fb04 	ldr.w	pc, [sp], #4
 800305a:	bf00      	nop
 800305c:	0000      	movs	r0, r0
	...

08003060 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8003060:	b082      	sub	sp, #8
 8003062:	9001      	str	r0, [sp, #4]
 8003064:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8003066:	9b00      	ldr	r3, [sp, #0]
 8003068:	685a      	ldr	r2, [r3, #4]
 800306a:	9b01      	ldr	r3, [sp, #4]
 800306c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800306e:	9b00      	ldr	r3, [sp, #0]
 8003070:	689a      	ldr	r2, [r3, #8]
 8003072:	9b01      	ldr	r3, [sp, #4]
 8003074:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8003076:	9b00      	ldr	r3, [sp, #0]
 8003078:	68da      	ldr	r2, [r3, #12]
 800307a:	9b01      	ldr	r3, [sp, #4]
 800307c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800307e:	9b00      	ldr	r3, [sp, #0]
 8003080:	691a      	ldr	r2, [r3, #16]
 8003082:	9b01      	ldr	r3, [sp, #4]
 8003084:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8003086:	9b00      	ldr	r3, [sp, #0]
 8003088:	695a      	ldr	r2, [r3, #20]
 800308a:	9b01      	ldr	r3, [sp, #4]
 800308c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800308e:	9b00      	ldr	r3, [sp, #0]
 8003090:	699a      	ldr	r2, [r3, #24]
 8003092:	9b01      	ldr	r3, [sp, #4]
 8003094:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8003096:	9b00      	ldr	r3, [sp, #0]
 8003098:	681a      	ldr	r2, [r3, #0]
 800309a:	9b01      	ldr	r3, [sp, #4]
 800309c:	601a      	str	r2, [r3, #0]
  gpiop->LOCKR   = config->lockr;
 800309e:	9b00      	ldr	r3, [sp, #0]
 80030a0:	69da      	ldr	r2, [r3, #28]
 80030a2:	9b01      	ldr	r3, [sp, #4]
 80030a4:	61da      	str	r2, [r3, #28]
}
 80030a6:	bf00      	nop
 80030a8:	b002      	add	sp, #8
 80030aa:	4770      	bx	lr
 80030ac:	0000      	movs	r0, r0
	...

080030b0 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 80030b0:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB2(STM32_GPIO_EN_MASK);
 80030b2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80030b6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80030b8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80030bc:	f043 039f 	orr.w	r3, r3, #159	@ 0x9f
 80030c0:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80030c2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80030c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80030c8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80030cc:	f023 039f 	bic.w	r3, r3, #159	@ 0x9f
 80030d0:	62d3      	str	r3, [r2, #44]	@ 0x2c
 80030d2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80030d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 80030d8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80030dc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80030de:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80030e2:	f043 039f 	orr.w	r3, r3, #159	@ 0x9f
 80030e6:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80030e8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80030ec:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80030ee:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80030f2:	f043 039f 	orr.w	r3, r3, #159	@ 0x9f
 80030f6:	66d3      	str	r3, [r2, #108]	@ 0x6c
 80030f8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80030fc:	6edb      	ldr	r3, [r3, #108]	@ 0x6c

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 80030fe:	490d      	ldr	r1, [pc, #52]	@ (8003134 <stm32_gpio_init+0x84>)
 8003100:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8003104:	f7ff ffac 	bl	8003060 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8003108:	490b      	ldr	r1, [pc, #44]	@ (8003138 <stm32_gpio_init+0x88>)
 800310a:	480c      	ldr	r0, [pc, #48]	@ (800313c <stm32_gpio_init+0x8c>)
 800310c:	f7ff ffa8 	bl	8003060 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 8003110:	490b      	ldr	r1, [pc, #44]	@ (8003140 <stm32_gpio_init+0x90>)
 8003112:	480c      	ldr	r0, [pc, #48]	@ (8003144 <stm32_gpio_init+0x94>)
 8003114:	f7ff ffa4 	bl	8003060 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8003118:	490b      	ldr	r1, [pc, #44]	@ (8003148 <stm32_gpio_init+0x98>)
 800311a:	480c      	ldr	r0, [pc, #48]	@ (800314c <stm32_gpio_init+0x9c>)
 800311c:	f7ff ffa0 	bl	8003060 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 8003120:	490b      	ldr	r1, [pc, #44]	@ (8003150 <stm32_gpio_init+0xa0>)
 8003122:	480c      	ldr	r0, [pc, #48]	@ (8003154 <stm32_gpio_init+0xa4>)
 8003124:	f7ff ff9c 	bl	8003060 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8003128:	490b      	ldr	r1, [pc, #44]	@ (8003158 <stm32_gpio_init+0xa8>)
 800312a:	480c      	ldr	r0, [pc, #48]	@ (800315c <stm32_gpio_init+0xac>)
 800312c:	f7ff ff98 	bl	8003060 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8003130:	bf00      	nop
 8003132:	bd08      	pop	{r3, pc}
 8003134:	08005464 	.word	0x08005464
 8003138:	08005484 	.word	0x08005484
 800313c:	48000400 	.word	0x48000400
 8003140:	080054a4 	.word	0x080054a4
 8003144:	48000800 	.word	0x48000800
 8003148:	080054c4 	.word	0x080054c4
 800314c:	48000c00 	.word	0x48000c00
 8003150:	080054e4 	.word	0x080054e4
 8003154:	48001000 	.word	0x48001000
 8003158:	08005504 	.word	0x08005504
 800315c:	48001c00 	.word	0x48001c00

08003160 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8003160:	b508      	push	{r3, lr}

  stm32_gpio_init();
 8003162:	f7ff ffa5 	bl	80030b0 <stm32_gpio_init>
  stm32_clock_init();
 8003166:	f7fe fdb3 	bl	8001cd0 <stm32_clock_init>
}
 800316a:	bf00      	nop
 800316c:	bd08      	pop	{r3, pc}
 800316e:	bf00      	nop

08003170 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 8003170:	bf00      	nop
 8003172:	4770      	bx	lr
	...

08003180 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 8003180:	b500      	push	{lr}
 8003182:	b08b      	sub	sp, #44	@ 0x2c
 8003184:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8003186:	9b01      	ldr	r3, [sp, #4]
 8003188:	2200      	movs	r2, #0
 800318a:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 800318c:	ab02      	add	r3, sp, #8
 800318e:	4618      	mov	r0, r3
 8003190:	f001 fc0e 	bl	80049b0 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 8003194:	2304      	movs	r3, #4
 8003196:	9309      	str	r3, [sp, #36]	@ 0x24
  do {
    chTMStartMeasurementX(&tm);
 8003198:	ab02      	add	r3, sp, #8
 800319a:	4618      	mov	r0, r3
 800319c:	f001 fc28 	bl	80049f0 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 80031a0:	ab02      	add	r3, sp, #8
 80031a2:	4618      	mov	r0, r3
 80031a4:	f001 fc34 	bl	8004a10 <chTMStopMeasurementX>
    i--;
 80031a8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80031aa:	3b01      	subs	r3, #1
 80031ac:	9309      	str	r3, [sp, #36]	@ 0x24
  } while (i > 0U);
 80031ae:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80031b0:	2b00      	cmp	r3, #0
 80031b2:	d1f1      	bne.n	8003198 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
 80031b4:	9a02      	ldr	r2, [sp, #8]
 80031b6:	9b01      	ldr	r3, [sp, #4]
 80031b8:	601a      	str	r2, [r3, #0]
}
 80031ba:	bf00      	nop
 80031bc:	b00b      	add	sp, #44	@ 0x2c
 80031be:	f85d fb04 	ldr.w	pc, [sp], #4
 80031c2:	bf00      	nop
	...

080031d0 <chSysUnlock.lto_priv.6>:
static inline void chSysUnlock(void) {
 80031d0:	b500      	push	{lr}
 80031d2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80031d4:	f000 f8dc 	bl	8003390 <__dbg_check_unlock>
 80031d8:	2300      	movs	r3, #0
 80031da:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80031dc:	9b01      	ldr	r3, [sp, #4]
 80031de:	f383 8811 	msr	BASEPRI, r3
}
 80031e2:	bf00      	nop
}
 80031e4:	bf00      	nop
}
 80031e6:	bf00      	nop
 80031e8:	b003      	add	sp, #12
 80031ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80031ee:	bf00      	nop

080031f0 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 80031f0:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 80031f2:	f001 fcf5 	bl	8004be0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 80031f6:	f001 fd63 	bl	8004cc0 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 80031fa:	f001 fdf9 	bl	8004df0 <__factory_init>
#endif
}
 80031fe:	bf00      	nop
 8003200:	bd08      	pop	{r3, pc}
 8003202:	bf00      	nop
	...

08003210 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 8003210:	b500      	push	{lr}
 8003212:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8003214:	4b11      	ldr	r3, [pc, #68]	@ (800325c <chSysInit+0x4c>)
 8003216:	2201      	movs	r2, #1
 8003218:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 800321a:	2300      	movs	r3, #0
 800321c:	9301      	str	r3, [sp, #4]
 800321e:	e008      	b.n	8003232 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
 8003220:	4a0e      	ldr	r2, [pc, #56]	@ (800325c <chSysInit+0x4c>)
 8003222:	9b01      	ldr	r3, [sp, #4]
 8003224:	009b      	lsls	r3, r3, #2
 8003226:	4413      	add	r3, r2
 8003228:	2200      	movs	r2, #0
 800322a:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 800322c:	9b01      	ldr	r3, [sp, #4]
 800322e:	3301      	adds	r3, #1
 8003230:	9301      	str	r3, [sp, #4]
 8003232:	9b01      	ldr	r3, [sp, #4]
 8003234:	2b00      	cmp	r3, #0
 8003236:	d0f3      	beq.n	8003220 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 8003238:	4809      	ldr	r0, [pc, #36]	@ (8003260 <chSysInit+0x50>)
 800323a:	f7ff ffa1 	bl	8003180 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 800323e:	f7ff ffd7 	bl	80031f0 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 8003242:	4908      	ldr	r1, [pc, #32]	@ (8003264 <chSysInit+0x54>)
 8003244:	4808      	ldr	r0, [pc, #32]	@ (8003268 <chSysInit+0x58>)
 8003246:	f000 ffe3 	bl	8004210 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 800324a:	4b04      	ldr	r3, [pc, #16]	@ (800325c <chSysInit+0x4c>)
 800324c:	2202      	movs	r2, #2
 800324e:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 8003250:	f7ff ffbe 	bl	80031d0 <chSysUnlock.lto_priv.6>
}
 8003254:	bf00      	nop
 8003256:	b003      	add	sp, #12
 8003258:	f85d fb04 	ldr.w	pc, [sp], #4
 800325c:	200009c4 	.word	0x200009c4
 8003260:	200009cc 	.word	0x200009cc
 8003264:	0800558c 	.word	0x0800558c
 8003268:	200009d0 	.word	0x200009d0
 800326c:	00000000 	.word	0x00000000

08003270 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8003270:	b082      	sub	sp, #8
 8003272:	9001      	str	r0, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8003274:	b672      	cpsid	i
}
 8003276:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 8003278:	bf00      	nop

  /* Logging the event.*/
  __trace_halt(reason);

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 800327a:	4a04      	ldr	r2, [pc, #16]	@ (800328c <chSysHalt+0x1c>)
 800327c:	9b01      	ldr	r3, [sp, #4]
 800327e:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8003282:	4b03      	ldr	r3, [pc, #12]	@ (8003290 <chSysHalt+0x20>)
 8003284:	2203      	movs	r2, #3
 8003286:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
     asm volatile ("nop");
 8003288:	bf00      	nop
 800328a:	e7fd      	b.n	8003288 <chSysHalt+0x18>
 800328c:	200009d0 	.word	0x200009d0
 8003290:	200009c4 	.word	0x200009c4
	...

080032a0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80032a0:	b508      	push	{r3, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 80032a2:	f000 f965 	bl	8003570 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 80032a6:	f000 fc53 	bl	8003b50 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 80032aa:	bf00      	nop
 80032ac:	bd08      	pop	{r3, pc}
 80032ae:	bf00      	nop

080032b0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 80032b0:	b084      	sub	sp, #16
 80032b2:	9003      	str	r0, [sp, #12]
 80032b4:	9102      	str	r1, [sp, #8]
 80032b6:	9201      	str	r2, [sp, #4]

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 80032b8:	9a03      	ldr	r2, [sp, #12]
 80032ba:	9b02      	ldr	r3, [sp, #8]
 80032bc:	1ad2      	subs	r2, r2, r3
                ((rtcnt_t)end - (rtcnt_t)start));
 80032be:	9901      	ldr	r1, [sp, #4]
 80032c0:	9b02      	ldr	r3, [sp, #8]
 80032c2:	1acb      	subs	r3, r1, r3
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 80032c4:	429a      	cmp	r2, r3
 80032c6:	bf34      	ite	cc
 80032c8:	2301      	movcc	r3, #1
 80032ca:	2300      	movcs	r3, #0
 80032cc:	b2db      	uxtb	r3, r3
}
 80032ce:	4618      	mov	r0, r3
 80032d0:	b004      	add	sp, #16
 80032d2:	4770      	bx	lr
	...

080032e0 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 80032e0:	b500      	push	{lr}
 80032e2:	b085      	sub	sp, #20
 80032e4:	9001      	str	r0, [sp, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80032e6:	4b0b      	ldr	r3, [pc, #44]	@ (8003314 <chSysPolledDelayX+0x34>)
 80032e8:	685b      	ldr	r3, [r3, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 80032ea:	9303      	str	r3, [sp, #12]
  rtcnt_t end  = start + cycles;
 80032ec:	9a03      	ldr	r2, [sp, #12]
 80032ee:	9b01      	ldr	r3, [sp, #4]
 80032f0:	4413      	add	r3, r2
 80032f2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80032f4:	bf00      	nop
 80032f6:	4b07      	ldr	r3, [pc, #28]	@ (8003314 <chSysPolledDelayX+0x34>)
 80032f8:	685b      	ldr	r3, [r3, #4]
 80032fa:	9a02      	ldr	r2, [sp, #8]
 80032fc:	9903      	ldr	r1, [sp, #12]
 80032fe:	4618      	mov	r0, r3
 8003300:	f7ff ffd6 	bl	80032b0 <chSysIsCounterWithinX>
 8003304:	4603      	mov	r3, r0
 8003306:	2b00      	cmp	r3, #0
 8003308:	d1f5      	bne.n	80032f6 <chSysPolledDelayX+0x16>
  }
}
 800330a:	bf00      	nop
 800330c:	bf00      	nop
 800330e:	b005      	add	sp, #20
 8003310:	f85d fb04 	ldr.w	pc, [sp], #4
 8003314:	e0001000 	.word	0xe0001000
	...

08003320 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 8003320:	b082      	sub	sp, #8
 8003322:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8003324:	4b04      	ldr	r3, [pc, #16]	@ (8003338 <chRFCUCollectFaultsI+0x18>)
 8003326:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8003328:	9b01      	ldr	r3, [sp, #4]
 800332a:	4313      	orrs	r3, r2
 800332c:	4a02      	ldr	r2, [pc, #8]	@ (8003338 <chRFCUCollectFaultsI+0x18>)
 800332e:	6353      	str	r3, [r2, #52]	@ 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8003330:	bf00      	nop
 8003332:	b002      	add	sp, #8
 8003334:	4770      	bx	lr
 8003336:	bf00      	nop
 8003338:	200009d0 	.word	0x200009d0
 800333c:	00000000 	.word	0x00000000

08003340 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 8003340:	b500      	push	{lr}
 8003342:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003344:	4b10      	ldr	r3, [pc, #64]	@ (8003388 <__dbg_check_lock+0x48>)
 8003346:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8003348:	9b01      	ldr	r3, [sp, #4]
 800334a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800334e:	2b00      	cmp	r3, #0
 8003350:	bf14      	ite	ne
 8003352:	2301      	movne	r3, #1
 8003354:	2300      	moveq	r3, #0
 8003356:	b2db      	uxtb	r3, r3
 8003358:	2b00      	cmp	r3, #0
 800335a:	d109      	bne.n	8003370 <__dbg_check_lock+0x30>
 800335c:	9b01      	ldr	r3, [sp, #4]
 800335e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003362:	2b00      	cmp	r3, #0
 8003364:	bf14      	ite	ne
 8003366:	2301      	movne	r3, #1
 8003368:	2300      	moveq	r3, #0
 800336a:	b2db      	uxtb	r3, r3
 800336c:	2b00      	cmp	r3, #0
 800336e:	d002      	beq.n	8003376 <__dbg_check_lock+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 8003370:	4806      	ldr	r0, [pc, #24]	@ (800338c <__dbg_check_lock+0x4c>)
 8003372:	f7ff ff7d 	bl	8003270 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8003376:	9b01      	ldr	r3, [sp, #4]
 8003378:	2201      	movs	r2, #1
 800337a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800337e:	bf00      	nop
 8003380:	b003      	add	sp, #12
 8003382:	f85d fb04 	ldr.w	pc, [sp], #4
 8003386:	bf00      	nop
 8003388:	200009d0 	.word	0x200009d0
 800338c:	08005528 	.word	0x08005528

08003390 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 8003390:	b500      	push	{lr}
 8003392:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003394:	4b10      	ldr	r3, [pc, #64]	@ (80033d8 <__dbg_check_unlock+0x48>)
 8003396:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8003398:	9b01      	ldr	r3, [sp, #4]
 800339a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800339e:	2b00      	cmp	r3, #0
 80033a0:	bf14      	ite	ne
 80033a2:	2301      	movne	r3, #1
 80033a4:	2300      	moveq	r3, #0
 80033a6:	b2db      	uxtb	r3, r3
 80033a8:	2b00      	cmp	r3, #0
 80033aa:	d109      	bne.n	80033c0 <__dbg_check_unlock+0x30>
 80033ac:	9b01      	ldr	r3, [sp, #4]
 80033ae:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80033b2:	2b00      	cmp	r3, #0
 80033b4:	bfd4      	ite	le
 80033b6:	2301      	movle	r3, #1
 80033b8:	2300      	movgt	r3, #0
 80033ba:	b2db      	uxtb	r3, r3
 80033bc:	2b00      	cmp	r3, #0
 80033be:	d002      	beq.n	80033c6 <__dbg_check_unlock+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 80033c0:	4806      	ldr	r0, [pc, #24]	@ (80033dc <__dbg_check_unlock+0x4c>)
 80033c2:	f7ff ff55 	bl	8003270 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 80033c6:	9b01      	ldr	r3, [sp, #4]
 80033c8:	2200      	movs	r2, #0
 80033ca:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 80033ce:	bf00      	nop
 80033d0:	b003      	add	sp, #12
 80033d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80033d6:	bf00      	nop
 80033d8:	200009d0 	.word	0x200009d0
 80033dc:	08005530 	.word	0x08005530

080033e0 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 80033e0:	b500      	push	{lr}
 80033e2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80033e4:	4b10      	ldr	r3, [pc, #64]	@ (8003428 <__dbg_check_lock_from_isr+0x48>)
 80033e6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80033e8:	9b01      	ldr	r3, [sp, #4]
 80033ea:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80033ee:	2b00      	cmp	r3, #0
 80033f0:	bfd4      	ite	le
 80033f2:	2301      	movle	r3, #1
 80033f4:	2300      	movgt	r3, #0
 80033f6:	b2db      	uxtb	r3, r3
 80033f8:	2b00      	cmp	r3, #0
 80033fa:	d109      	bne.n	8003410 <__dbg_check_lock_from_isr+0x30>
 80033fc:	9b01      	ldr	r3, [sp, #4]
 80033fe:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003402:	2b00      	cmp	r3, #0
 8003404:	bf14      	ite	ne
 8003406:	2301      	movne	r3, #1
 8003408:	2300      	moveq	r3, #0
 800340a:	b2db      	uxtb	r3, r3
 800340c:	2b00      	cmp	r3, #0
 800340e:	d002      	beq.n	8003416 <__dbg_check_lock_from_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 8003410:	4806      	ldr	r0, [pc, #24]	@ (800342c <__dbg_check_lock_from_isr+0x4c>)
 8003412:	f7ff ff2d 	bl	8003270 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8003416:	9b01      	ldr	r3, [sp, #4]
 8003418:	2201      	movs	r2, #1
 800341a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800341e:	bf00      	nop
 8003420:	b003      	add	sp, #12
 8003422:	f85d fb04 	ldr.w	pc, [sp], #4
 8003426:	bf00      	nop
 8003428:	200009d0 	.word	0x200009d0
 800342c:	08005538 	.word	0x08005538

08003430 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 8003430:	b500      	push	{lr}
 8003432:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003434:	4b10      	ldr	r3, [pc, #64]	@ (8003478 <__dbg_check_unlock_from_isr+0x48>)
 8003436:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8003438:	9b01      	ldr	r3, [sp, #4]
 800343a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800343e:	2b00      	cmp	r3, #0
 8003440:	bfd4      	ite	le
 8003442:	2301      	movle	r3, #1
 8003444:	2300      	movgt	r3, #0
 8003446:	b2db      	uxtb	r3, r3
 8003448:	2b00      	cmp	r3, #0
 800344a:	d109      	bne.n	8003460 <__dbg_check_unlock_from_isr+0x30>
 800344c:	9b01      	ldr	r3, [sp, #4]
 800344e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003452:	2b00      	cmp	r3, #0
 8003454:	bfd4      	ite	le
 8003456:	2301      	movle	r3, #1
 8003458:	2300      	movgt	r3, #0
 800345a:	b2db      	uxtb	r3, r3
 800345c:	2b00      	cmp	r3, #0
 800345e:	d002      	beq.n	8003466 <__dbg_check_unlock_from_isr+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 8003460:	4806      	ldr	r0, [pc, #24]	@ (800347c <__dbg_check_unlock_from_isr+0x4c>)
 8003462:	f7ff ff05 	bl	8003270 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8003466:	9b01      	ldr	r3, [sp, #4]
 8003468:	2200      	movs	r2, #0
 800346a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 800346e:	bf00      	nop
 8003470:	b003      	add	sp, #12
 8003472:	f85d fb04 	ldr.w	pc, [sp], #4
 8003476:	bf00      	nop
 8003478:	200009d0 	.word	0x200009d0
 800347c:	08005540 	.word	0x08005540

08003480 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 8003480:	b500      	push	{lr}
 8003482:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8003484:	4b18      	ldr	r3, [pc, #96]	@ (80034e8 <__dbg_check_enter_isr+0x68>)
 8003486:	9303      	str	r3, [sp, #12]
 8003488:	2330      	movs	r3, #48	@ 0x30
 800348a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800348c:	9b02      	ldr	r3, [sp, #8]
 800348e:	f383 8811 	msr	BASEPRI, r3
}
 8003492:	bf00      	nop
}
 8003494:	bf00      	nop
}
 8003496:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8003498:	9b03      	ldr	r3, [sp, #12]
 800349a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800349e:	0fdb      	lsrs	r3, r3, #31
 80034a0:	b2db      	uxtb	r3, r3
 80034a2:	2b00      	cmp	r3, #0
 80034a4:	d109      	bne.n	80034ba <__dbg_check_enter_isr+0x3a>
 80034a6:	9b03      	ldr	r3, [sp, #12]
 80034a8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80034ac:	2b00      	cmp	r3, #0
 80034ae:	bf14      	ite	ne
 80034b0:	2301      	movne	r3, #1
 80034b2:	2300      	moveq	r3, #0
 80034b4:	b2db      	uxtb	r3, r3
 80034b6:	2b00      	cmp	r3, #0
 80034b8:	d002      	beq.n	80034c0 <__dbg_check_enter_isr+0x40>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 80034ba:	480c      	ldr	r0, [pc, #48]	@ (80034ec <__dbg_check_enter_isr+0x6c>)
 80034bc:	f7ff fed8 	bl	8003270 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 80034c0:	9b03      	ldr	r3, [sp, #12]
 80034c2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80034c6:	1c5a      	adds	r2, r3, #1
 80034c8:	9b03      	ldr	r3, [sp, #12]
 80034ca:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 80034ce:	2300      	movs	r3, #0
 80034d0:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80034d2:	9b01      	ldr	r3, [sp, #4]
 80034d4:	f383 8811 	msr	BASEPRI, r3
}
 80034d8:	bf00      	nop
}
 80034da:	bf00      	nop
}
 80034dc:	bf00      	nop
  port_unlock_from_isr();
}
 80034de:	bf00      	nop
 80034e0:	b005      	add	sp, #20
 80034e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80034e6:	bf00      	nop
 80034e8:	200009d0 	.word	0x200009d0
 80034ec:	08005548 	.word	0x08005548

080034f0 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 80034f0:	b500      	push	{lr}
 80034f2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80034f4:	4b19      	ldr	r3, [pc, #100]	@ (800355c <__dbg_check_leave_isr+0x6c>)
 80034f6:	9303      	str	r3, [sp, #12]
 80034f8:	2330      	movs	r3, #48	@ 0x30
 80034fa:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80034fc:	9b02      	ldr	r3, [sp, #8]
 80034fe:	f383 8811 	msr	BASEPRI, r3
}
 8003502:	bf00      	nop
}
 8003504:	bf00      	nop
}
 8003506:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8003508:	9b03      	ldr	r3, [sp, #12]
 800350a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800350e:	2b00      	cmp	r3, #0
 8003510:	bfd4      	ite	le
 8003512:	2301      	movle	r3, #1
 8003514:	2300      	movgt	r3, #0
 8003516:	b2db      	uxtb	r3, r3
 8003518:	2b00      	cmp	r3, #0
 800351a:	d109      	bne.n	8003530 <__dbg_check_leave_isr+0x40>
 800351c:	9b03      	ldr	r3, [sp, #12]
 800351e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003522:	2b00      	cmp	r3, #0
 8003524:	bf14      	ite	ne
 8003526:	2301      	movne	r3, #1
 8003528:	2300      	moveq	r3, #0
 800352a:	b2db      	uxtb	r3, r3
 800352c:	2b00      	cmp	r3, #0
 800352e:	d002      	beq.n	8003536 <__dbg_check_leave_isr+0x46>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 8003530:	480b      	ldr	r0, [pc, #44]	@ (8003560 <__dbg_check_leave_isr+0x70>)
 8003532:	f7ff fe9d 	bl	8003270 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 8003536:	9b03      	ldr	r3, [sp, #12]
 8003538:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800353c:	1e5a      	subs	r2, r3, #1
 800353e:	9b03      	ldr	r3, [sp, #12]
 8003540:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8003544:	2300      	movs	r3, #0
 8003546:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003548:	9b01      	ldr	r3, [sp, #4]
 800354a:	f383 8811 	msr	BASEPRI, r3
}
 800354e:	bf00      	nop
}
 8003550:	bf00      	nop
}
 8003552:	bf00      	nop
  port_unlock_from_isr();
}
 8003554:	bf00      	nop
 8003556:	b005      	add	sp, #20
 8003558:	f85d fb04 	ldr.w	pc, [sp], #4
 800355c:	200009d0 	.word	0x200009d0
 8003560:	08005550 	.word	0x08005550
	...

08003570 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8003570:	b500      	push	{lr}
 8003572:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003574:	4b0c      	ldr	r3, [pc, #48]	@ (80035a8 <chDbgCheckClassI+0x38>)
 8003576:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8003578:	9b01      	ldr	r3, [sp, #4]
 800357a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800357e:	0fdb      	lsrs	r3, r3, #31
 8003580:	b2db      	uxtb	r3, r3
 8003582:	2b00      	cmp	r3, #0
 8003584:	d109      	bne.n	800359a <chDbgCheckClassI+0x2a>
 8003586:	9b01      	ldr	r3, [sp, #4]
 8003588:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800358c:	2b00      	cmp	r3, #0
 800358e:	bfd4      	ite	le
 8003590:	2301      	movle	r3, #1
 8003592:	2300      	movgt	r3, #0
 8003594:	b2db      	uxtb	r3, r3
 8003596:	2b00      	cmp	r3, #0
 8003598:	d002      	beq.n	80035a0 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 800359a:	4804      	ldr	r0, [pc, #16]	@ (80035ac <chDbgCheckClassI+0x3c>)
 800359c:	f7ff fe68 	bl	8003270 <chSysHalt>
  }
}
 80035a0:	bf00      	nop
 80035a2:	b003      	add	sp, #12
 80035a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80035a8:	200009d0 	.word	0x200009d0
 80035ac:	08005558 	.word	0x08005558

080035b0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 80035b0:	b500      	push	{lr}
 80035b2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80035b4:	4b0e      	ldr	r3, [pc, #56]	@ (80035f0 <chDbgCheckClassS+0x40>)
 80035b6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80035b8:	9b01      	ldr	r3, [sp, #4]
 80035ba:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80035be:	2b00      	cmp	r3, #0
 80035c0:	bf14      	ite	ne
 80035c2:	2301      	movne	r3, #1
 80035c4:	2300      	moveq	r3, #0
 80035c6:	b2db      	uxtb	r3, r3
 80035c8:	2b00      	cmp	r3, #0
 80035ca:	d109      	bne.n	80035e0 <chDbgCheckClassS+0x30>
 80035cc:	9b01      	ldr	r3, [sp, #4]
 80035ce:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80035d2:	2b00      	cmp	r3, #0
 80035d4:	bfd4      	ite	le
 80035d6:	2301      	movle	r3, #1
 80035d8:	2300      	movgt	r3, #0
 80035da:	b2db      	uxtb	r3, r3
 80035dc:	2b00      	cmp	r3, #0
 80035de:	d002      	beq.n	80035e6 <chDbgCheckClassS+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 80035e0:	4804      	ldr	r0, [pc, #16]	@ (80035f4 <chDbgCheckClassS+0x44>)
 80035e2:	f7ff fe45 	bl	8003270 <chSysHalt>
  }
}
 80035e6:	bf00      	nop
 80035e8:	b003      	add	sp, #12
 80035ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80035ee:	bf00      	nop
 80035f0:	200009d0 	.word	0x200009d0
 80035f4:	08005560 	.word	0x08005560
	...

08003600 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8003600:	b082      	sub	sp, #8
 8003602:	9001      	str	r0, [sp, #4]
 8003604:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8003606:	9a01      	ldr	r2, [sp, #4]
 8003608:	9b00      	ldr	r3, [sp, #0]
 800360a:	4413      	add	r3, r2
}
 800360c:	4618      	mov	r0, r3
 800360e:	b002      	add	sp, #8
 8003610:	4770      	bx	lr
 8003612:	bf00      	nop
	...

08003620 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8003620:	b082      	sub	sp, #8
 8003622:	9001      	str	r0, [sp, #4]
 8003624:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8003626:	9a00      	ldr	r2, [sp, #0]
 8003628:	9b01      	ldr	r3, [sp, #4]
 800362a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 800362c:	4618      	mov	r0, r3
 800362e:	b002      	add	sp, #8
 8003630:	4770      	bx	lr
 8003632:	bf00      	nop
	...

08003640 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8003640:	b082      	sub	sp, #8
 8003642:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8003644:	9b01      	ldr	r3, [sp, #4]
 8003646:	681b      	ldr	r3, [r3, #0]
 8003648:	9a01      	ldr	r2, [sp, #4]
 800364a:	429a      	cmp	r2, r3
 800364c:	bf0c      	ite	eq
 800364e:	2301      	moveq	r3, #1
 8003650:	2300      	movne	r3, #0
 8003652:	b2db      	uxtb	r3, r3
}
 8003654:	4618      	mov	r0, r3
 8003656:	b002      	add	sp, #8
 8003658:	4770      	bx	lr
 800365a:	bf00      	nop
 800365c:	0000      	movs	r0, r0
	...

08003660 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8003660:	b082      	sub	sp, #8
 8003662:	9001      	str	r0, [sp, #4]
 8003664:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8003666:	9b01      	ldr	r3, [sp, #4]
 8003668:	681b      	ldr	r3, [r3, #0]
 800366a:	9a00      	ldr	r2, [sp, #0]
 800366c:	429a      	cmp	r2, r3
 800366e:	bf0c      	ite	eq
 8003670:	2301      	moveq	r3, #1
 8003672:	2300      	movne	r3, #0
 8003674:	b2db      	uxtb	r3, r3
}
 8003676:	4618      	mov	r0, r3
 8003678:	b002      	add	sp, #8
 800367a:	4770      	bx	lr
 800367c:	0000      	movs	r0, r0
	...

08003680 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 8003680:	b084      	sub	sp, #16
 8003682:	9003      	str	r0, [sp, #12]
 8003684:	9102      	str	r1, [sp, #8]
 8003686:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8003688:	9b02      	ldr	r3, [sp, #8]
 800368a:	9a01      	ldr	r2, [sp, #4]
 800368c:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 800368e:	9b02      	ldr	r3, [sp, #8]
 8003690:	9a03      	ldr	r2, [sp, #12]
 8003692:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8003694:	9b02      	ldr	r3, [sp, #8]
 8003696:	685b      	ldr	r3, [r3, #4]
 8003698:	681a      	ldr	r2, [r3, #0]
 800369a:	9b02      	ldr	r3, [sp, #8]
 800369c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 800369e:	9b02      	ldr	r3, [sp, #8]
 80036a0:	681b      	ldr	r3, [r3, #0]
 80036a2:	9a02      	ldr	r2, [sp, #8]
 80036a4:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 80036a6:	9b03      	ldr	r3, [sp, #12]
 80036a8:	9a02      	ldr	r2, [sp, #8]
 80036aa:	601a      	str	r2, [r3, #0]
}
 80036ac:	bf00      	nop
 80036ae:	b004      	add	sp, #16
 80036b0:	4770      	bx	lr
 80036b2:	bf00      	nop
	...

080036c0 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 80036c0:	b084      	sub	sp, #16
 80036c2:	9003      	str	r0, [sp, #12]
 80036c4:	9102      	str	r1, [sp, #8]
 80036c6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 80036c8:	9b02      	ldr	r3, [sp, #8]
 80036ca:	9a01      	ldr	r2, [sp, #4]
 80036cc:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 80036ce:	9b02      	ldr	r3, [sp, #8]
 80036d0:	9a03      	ldr	r2, [sp, #12]
 80036d2:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 80036d4:	9b02      	ldr	r3, [sp, #8]
 80036d6:	681b      	ldr	r3, [r3, #0]
 80036d8:	685a      	ldr	r2, [r3, #4]
 80036da:	9b02      	ldr	r3, [sp, #8]
 80036dc:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 80036de:	9b02      	ldr	r3, [sp, #8]
 80036e0:	685b      	ldr	r3, [r3, #4]
 80036e2:	9a02      	ldr	r2, [sp, #8]
 80036e4:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 80036e6:	9b03      	ldr	r3, [sp, #12]
 80036e8:	9a02      	ldr	r2, [sp, #8]
 80036ea:	605a      	str	r2, [r3, #4]
}
 80036ec:	bf00      	nop
 80036ee:	b004      	add	sp, #16
 80036f0:	4770      	bx	lr
 80036f2:	bf00      	nop
	...

08003700 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8003700:	b500      	push	{lr}
 8003702:	b087      	sub	sp, #28
 8003704:	9003      	str	r0, [sp, #12]
 8003706:	9102      	str	r1, [sp, #8]
 8003708:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 800370a:	9b03      	ldr	r3, [sp, #12]
 800370c:	681b      	ldr	r3, [r3, #0]
 800370e:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8003710:	e007      	b.n	8003722 <ch_dlist_insert+0x22>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
 8003712:	9b05      	ldr	r3, [sp, #20]
 8003714:	689b      	ldr	r3, [r3, #8]
 8003716:	9a01      	ldr	r2, [sp, #4]
 8003718:	1ad3      	subs	r3, r2, r3
 800371a:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 800371c:	9b05      	ldr	r3, [sp, #20]
 800371e:	681b      	ldr	r3, [r3, #0]
 8003720:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8003722:	9b05      	ldr	r3, [sp, #20]
 8003724:	689b      	ldr	r3, [r3, #8]
 8003726:	9a01      	ldr	r2, [sp, #4]
 8003728:	429a      	cmp	r2, r3
 800372a:	bf8c      	ite	hi
 800372c:	2301      	movhi	r3, #1
 800372e:	2300      	movls	r3, #0
 8003730:	b2db      	uxtb	r3, r3
 8003732:	2b00      	cmp	r3, #0
 8003734:	d1ed      	bne.n	8003712 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 8003736:	9a01      	ldr	r2, [sp, #4]
 8003738:	9902      	ldr	r1, [sp, #8]
 800373a:	9805      	ldr	r0, [sp, #20]
 800373c:	f7ff ffc0 	bl	80036c0 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8003740:	9b05      	ldr	r3, [sp, #20]
 8003742:	689a      	ldr	r2, [r3, #8]
 8003744:	9b01      	ldr	r3, [sp, #4]
 8003746:	1ad2      	subs	r2, r2, r3
 8003748:	9b05      	ldr	r3, [sp, #20]
 800374a:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 800374c:	9b03      	ldr	r3, [sp, #12]
 800374e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003752:	609a      	str	r2, [r3, #8]
}
 8003754:	bf00      	nop
 8003756:	b007      	add	sp, #28
 8003758:	f85d fb04 	ldr.w	pc, [sp], #4
 800375c:	0000      	movs	r0, r0
	...

08003760 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8003760:	b084      	sub	sp, #16
 8003762:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8003764:	9b01      	ldr	r3, [sp, #4]
 8003766:	681b      	ldr	r3, [r3, #0]
 8003768:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 800376a:	9b03      	ldr	r3, [sp, #12]
 800376c:	681a      	ldr	r2, [r3, #0]
 800376e:	9b01      	ldr	r3, [sp, #4]
 8003770:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8003772:	9b01      	ldr	r3, [sp, #4]
 8003774:	681b      	ldr	r3, [r3, #0]
 8003776:	9a01      	ldr	r2, [sp, #4]
 8003778:	605a      	str	r2, [r3, #4]

  return dlp;
 800377a:	9b03      	ldr	r3, [sp, #12]
}
 800377c:	4618      	mov	r0, r3
 800377e:	b004      	add	sp, #16
 8003780:	4770      	bx	lr
 8003782:	bf00      	nop
	...

08003790 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 8003790:	b082      	sub	sp, #8
 8003792:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 8003794:	9b01      	ldr	r3, [sp, #4]
 8003796:	685b      	ldr	r3, [r3, #4]
 8003798:	9a01      	ldr	r2, [sp, #4]
 800379a:	6812      	ldr	r2, [r2, #0]
 800379c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 800379e:	9b01      	ldr	r3, [sp, #4]
 80037a0:	681b      	ldr	r3, [r3, #0]
 80037a2:	9a01      	ldr	r2, [sp, #4]
 80037a4:	6852      	ldr	r2, [r2, #4]
 80037a6:	605a      	str	r2, [r3, #4]

  return dlp;
 80037a8:	9b01      	ldr	r3, [sp, #4]
}
 80037aa:	4618      	mov	r0, r3
 80037ac:	b002      	add	sp, #8
 80037ae:	4770      	bx	lr

080037b0 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 80037b0:	b500      	push	{lr}
 80037b2:	b083      	sub	sp, #12
 80037b4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 80037b6:	9801      	ldr	r0, [sp, #4]
 80037b8:	f7fc fe1a 	bl	80003f0 <stStartAlarm>
}
 80037bc:	bf00      	nop
 80037be:	b003      	add	sp, #12
 80037c0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080037d0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 80037d0:	b508      	push	{r3, lr}

  stStopAlarm();
 80037d2:	f7fc fe1d 	bl	8000410 <stStopAlarm>
}
 80037d6:	bf00      	nop
 80037d8:	bd08      	pop	{r3, pc}
 80037da:	bf00      	nop
 80037dc:	0000      	movs	r0, r0
	...

080037e0 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 80037e0:	b500      	push	{lr}
 80037e2:	b083      	sub	sp, #12
 80037e4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 80037e6:	9801      	ldr	r0, [sp, #4]
 80037e8:	f7fc fe1a 	bl	8000420 <stSetAlarm>
}
 80037ec:	bf00      	nop
 80037ee:	b003      	add	sp, #12
 80037f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003800 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8003800:	b508      	push	{r3, lr}

  return stGetCounter();
 8003802:	f7fc fded 	bl	80003e0 <stGetCounter>
 8003806:	4603      	mov	r3, r0
}
 8003808:	4618      	mov	r0, r3
 800380a:	bd08      	pop	{r3, pc}
 800380c:	0000      	movs	r0, r0
	...

08003810 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 8003810:	b500      	push	{lr}
 8003812:	b083      	sub	sp, #12
 8003814:	2330      	movs	r3, #48	@ 0x30
 8003816:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003818:	9b01      	ldr	r3, [sp, #4]
 800381a:	f383 8811 	msr	BASEPRI, r3
}
 800381e:	bf00      	nop
}
 8003820:	bf00      	nop
}
 8003822:	bf00      	nop
  __dbg_check_lock_from_isr();
 8003824:	f7ff fddc 	bl	80033e0 <__dbg_check_lock_from_isr>
}
 8003828:	bf00      	nop
 800382a:	b003      	add	sp, #12
 800382c:	f85d fb04 	ldr.w	pc, [sp], #4

08003830 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 8003830:	b500      	push	{lr}
 8003832:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8003834:	f7ff fdfc 	bl	8003430 <__dbg_check_unlock_from_isr>
 8003838:	2300      	movs	r3, #0
 800383a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800383c:	9b01      	ldr	r3, [sp, #4]
 800383e:	f383 8811 	msr	BASEPRI, r3
}
 8003842:	bf00      	nop
}
 8003844:	bf00      	nop
}
 8003846:	bf00      	nop
}
 8003848:	bf00      	nop
 800384a:	b003      	add	sp, #12
 800384c:	f85d fb04 	ldr.w	pc, [sp], #4

08003850 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8003850:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8003852:	f7ff ffd5 	bl	8003800 <port_timer_get_time.lto_priv.0>
 8003856:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003858:	4618      	mov	r0, r3
 800385a:	bd08      	pop	{r3, pc}
 800385c:	0000      	movs	r0, r0
	...

08003860 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 8003860:	b500      	push	{lr}
 8003862:	b087      	sub	sp, #28
 8003864:	9001      	str	r0, [sp, #4]
 8003866:	9100      	str	r1, [sp, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003868:	2302      	movs	r3, #2
 800386a:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 800386c:	9a00      	ldr	r2, [sp, #0]
 800386e:	9b05      	ldr	r3, [sp, #20]
 8003870:	429a      	cmp	r2, r3
 8003872:	d201      	bcs.n	8003878 <vt_set_alarm+0x18>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8003874:	9b05      	ldr	r3, [sp, #20]
 8003876:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 8003878:	9900      	ldr	r1, [sp, #0]
 800387a:	9801      	ldr	r0, [sp, #4]
 800387c:	f7ff fec0 	bl	8003600 <chTimeAddX>
 8003880:	4603      	mov	r3, r0
 8003882:	4618      	mov	r0, r3
 8003884:	f7ff ffac 	bl	80037e0 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8003888:	f7ff ffe2 	bl	8003850 <chVTGetSystemTimeX.lto_priv.0>
 800388c:	9004      	str	r0, [sp, #16]
    nowdelta = chTimeDiffX(now, newnow);
 800388e:	9904      	ldr	r1, [sp, #16]
 8003890:	9801      	ldr	r0, [sp, #4]
 8003892:	f7ff fec5 	bl	8003620 <chTimeDiffX.lto_priv.0>
 8003896:	9003      	str	r0, [sp, #12]
    if (likely(nowdelta < delay)) {
 8003898:	9a03      	ldr	r2, [sp, #12]
 800389a:	9b00      	ldr	r3, [sp, #0]
 800389c:	429a      	cmp	r2, r3
 800389e:	bf34      	ite	cc
 80038a0:	2301      	movcc	r3, #1
 80038a2:	2300      	movcs	r3, #0
 80038a4:	b2db      	uxtb	r3, r3
 80038a6:	2b00      	cmp	r3, #0
 80038a8:	d107      	bne.n	80038ba <vt_set_alarm+0x5a>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 80038aa:	9b05      	ldr	r3, [sp, #20]
 80038ac:	3301      	adds	r3, #1
 80038ae:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 80038b0:	9b04      	ldr	r3, [sp, #16]
 80038b2:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 80038b4:	9b05      	ldr	r3, [sp, #20]
 80038b6:	9300      	str	r3, [sp, #0]
  while (true) {
 80038b8:	e7de      	b.n	8003878 <vt_set_alarm+0x18>
      break;
 80038ba:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80038bc:	9b05      	ldr	r3, [sp, #20]
 80038be:	2b02      	cmp	r3, #2
 80038c0:	d902      	bls.n	80038c8 <vt_set_alarm+0x68>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 80038c2:	2001      	movs	r0, #1
 80038c4:	f7ff fd2c 	bl	8003320 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80038c8:	bf00      	nop
 80038ca:	b007      	add	sp, #28
 80038cc:	f85d fb04 	ldr.w	pc, [sp], #4

080038d0 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 80038d0:	b500      	push	{lr}
 80038d2:	b087      	sub	sp, #28
 80038d4:	9003      	str	r0, [sp, #12]
 80038d6:	9102      	str	r1, [sp, #8]
 80038d8:	9201      	str	r2, [sp, #4]
 80038da:	9300      	str	r3, [sp, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 80038dc:	9b03      	ldr	r3, [sp, #12]
 80038de:	9a01      	ldr	r2, [sp, #4]
 80038e0:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 80038e2:	9b03      	ldr	r3, [sp, #12]
 80038e4:	9902      	ldr	r1, [sp, #8]
 80038e6:	9a00      	ldr	r2, [sp, #0]
 80038e8:	4618      	mov	r0, r3
 80038ea:	f7ff fec9 	bl	8003680 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80038ee:	2302      	movs	r3, #2
 80038f0:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 80038f2:	9a00      	ldr	r2, [sp, #0]
 80038f4:	9b05      	ldr	r3, [sp, #20]
 80038f6:	429a      	cmp	r2, r3
 80038f8:	d201      	bcs.n	80038fe <vt_insert_first+0x2e>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 80038fa:	9b05      	ldr	r3, [sp, #20]
 80038fc:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 80038fe:	9b03      	ldr	r3, [sp, #12]
 8003900:	68db      	ldr	r3, [r3, #12]
 8003902:	9900      	ldr	r1, [sp, #0]
 8003904:	4618      	mov	r0, r3
 8003906:	f7ff fe7b 	bl	8003600 <chTimeAddX>
 800390a:	4603      	mov	r3, r0
 800390c:	4618      	mov	r0, r3
 800390e:	f7ff ff4f 	bl	80037b0 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8003912:	f7ff ff9d 	bl	8003850 <chVTGetSystemTimeX.lto_priv.0>
 8003916:	9004      	str	r0, [sp, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8003918:	9904      	ldr	r1, [sp, #16]
 800391a:	9801      	ldr	r0, [sp, #4]
 800391c:	f7ff fe80 	bl	8003620 <chTimeDiffX.lto_priv.0>
 8003920:	4602      	mov	r2, r0
 8003922:	9b00      	ldr	r3, [sp, #0]
 8003924:	4293      	cmp	r3, r2
 8003926:	bf8c      	ite	hi
 8003928:	2301      	movhi	r3, #1
 800392a:	2300      	movls	r3, #0
 800392c:	b2db      	uxtb	r3, r3
 800392e:	2b00      	cmp	r3, #0
 8003930:	d10f      	bne.n	8003952 <vt_insert_first+0x82>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8003932:	9b05      	ldr	r3, [sp, #20]
 8003934:	3301      	adds	r3, #1
 8003936:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8003938:	9905      	ldr	r1, [sp, #20]
 800393a:	9801      	ldr	r0, [sp, #4]
 800393c:	f7ff fe60 	bl	8003600 <chTimeAddX>
 8003940:	4603      	mov	r3, r0
 8003942:	4618      	mov	r0, r3
 8003944:	f7ff ff4c 	bl	80037e0 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8003948:	9b04      	ldr	r3, [sp, #16]
 800394a:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 800394c:	9b05      	ldr	r3, [sp, #20]
 800394e:	9300      	str	r3, [sp, #0]
  while (true) {
 8003950:	e7df      	b.n	8003912 <vt_insert_first+0x42>
      break;
 8003952:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8003954:	9b05      	ldr	r3, [sp, #20]
 8003956:	2b02      	cmp	r3, #2
 8003958:	d902      	bls.n	8003960 <vt_insert_first+0x90>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 800395a:	2001      	movs	r0, #1
 800395c:	f7ff fce0 	bl	8003320 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8003960:	bf00      	nop
 8003962:	b007      	add	sp, #28
 8003964:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003970 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 8003970:	b500      	push	{lr}
 8003972:	b089      	sub	sp, #36	@ 0x24
 8003974:	9003      	str	r0, [sp, #12]
 8003976:	9102      	str	r1, [sp, #8]
 8003978:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 800397a:	f7ff ff69 	bl	8003850 <chVTGetSystemTimeX.lto_priv.0>
 800397e:	9006      	str	r0, [sp, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003980:	9b03      	ldr	r3, [sp, #12]
 8003982:	4618      	mov	r0, r3
 8003984:	f7ff fe5c 	bl	8003640 <ch_dlist_isempty>
 8003988:	4603      	mov	r3, r0
 800398a:	2b00      	cmp	r3, #0
 800398c:	d006      	beq.n	800399c <vt_enqueue+0x2c>

      vt_insert_first(vtlp, vtp, now, delay);
 800398e:	9b01      	ldr	r3, [sp, #4]
 8003990:	9a06      	ldr	r2, [sp, #24]
 8003992:	9902      	ldr	r1, [sp, #8]
 8003994:	9803      	ldr	r0, [sp, #12]
 8003996:	f7ff ff9b 	bl	80038d0 <vt_insert_first>

      return;
 800399a:	e020      	b.n	80039de <vt_enqueue+0x6e>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 800399c:	9b03      	ldr	r3, [sp, #12]
 800399e:	68db      	ldr	r3, [r3, #12]
 80039a0:	9906      	ldr	r1, [sp, #24]
 80039a2:	4618      	mov	r0, r3
 80039a4:	f7ff fe3c 	bl	8003620 <chTimeDiffX.lto_priv.0>
 80039a8:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
 80039aa:	9a05      	ldr	r2, [sp, #20]
 80039ac:	9b01      	ldr	r3, [sp, #4]
 80039ae:	4413      	add	r3, r2
 80039b0:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 80039b2:	9a07      	ldr	r2, [sp, #28]
 80039b4:	9b05      	ldr	r3, [sp, #20]
 80039b6:	429a      	cmp	r2, r3
 80039b8:	d201      	bcs.n	80039be <vt_enqueue+0x4e>
      delta = delay;
 80039ba:	9b01      	ldr	r3, [sp, #4]
 80039bc:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 80039be:	9b03      	ldr	r3, [sp, #12]
 80039c0:	681b      	ldr	r3, [r3, #0]
 80039c2:	689b      	ldr	r3, [r3, #8]
 80039c4:	9a07      	ldr	r2, [sp, #28]
 80039c6:	429a      	cmp	r2, r3
 80039c8:	d203      	bcs.n	80039d2 <vt_enqueue+0x62>

      vt_set_alarm(now, delay);
 80039ca:	9901      	ldr	r1, [sp, #4]
 80039cc:	9806      	ldr	r0, [sp, #24]
 80039ce:	f7ff ff47 	bl	8003860 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 80039d2:	9b03      	ldr	r3, [sp, #12]
 80039d4:	9902      	ldr	r1, [sp, #8]
 80039d6:	9a07      	ldr	r2, [sp, #28]
 80039d8:	4618      	mov	r0, r3
 80039da:	f7ff fe91 	bl	8003700 <ch_dlist_insert>
}
 80039de:	b009      	add	sp, #36	@ 0x24
 80039e0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080039f0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 80039f0:	b500      	push	{lr}
 80039f2:	b087      	sub	sp, #28
 80039f4:	9003      	str	r0, [sp, #12]
 80039f6:	9102      	str	r1, [sp, #8]
 80039f8:	9201      	str	r2, [sp, #4]
 80039fa:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 80039fc:	4b1a      	ldr	r3, [pc, #104]	@ (8003a68 <chVTDoSetI+0x78>)
 80039fe:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8003a00:	f7ff fdb6 	bl	8003570 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8003a04:	9b03      	ldr	r3, [sp, #12]
 8003a06:	2b00      	cmp	r3, #0
 8003a08:	bf0c      	ite	eq
 8003a0a:	2301      	moveq	r3, #1
 8003a0c:	2300      	movne	r3, #0
 8003a0e:	b2db      	uxtb	r3, r3
 8003a10:	2b00      	cmp	r3, #0
 8003a12:	d107      	bne.n	8003a24 <chVTDoSetI+0x34>
 8003a14:	9b01      	ldr	r3, [sp, #4]
 8003a16:	2b00      	cmp	r3, #0
 8003a18:	bf0c      	ite	eq
 8003a1a:	2301      	moveq	r3, #1
 8003a1c:	2300      	movne	r3, #0
 8003a1e:	b2db      	uxtb	r3, r3
 8003a20:	2b00      	cmp	r3, #0
 8003a22:	d001      	beq.n	8003a28 <chVTDoSetI+0x38>
 8003a24:	2301      	movs	r3, #1
 8003a26:	e000      	b.n	8003a2a <chVTDoSetI+0x3a>
 8003a28:	2300      	movs	r3, #0
 8003a2a:	2b00      	cmp	r3, #0
 8003a2c:	d107      	bne.n	8003a3e <chVTDoSetI+0x4e>
 8003a2e:	9b02      	ldr	r3, [sp, #8]
 8003a30:	2b00      	cmp	r3, #0
 8003a32:	bf0c      	ite	eq
 8003a34:	2301      	moveq	r3, #1
 8003a36:	2300      	movne	r3, #0
 8003a38:	b2db      	uxtb	r3, r3
 8003a3a:	2b00      	cmp	r3, #0
 8003a3c:	d002      	beq.n	8003a44 <chVTDoSetI+0x54>
 8003a3e:	480b      	ldr	r0, [pc, #44]	@ (8003a6c <chVTDoSetI+0x7c>)
 8003a40:	f7ff fc16 	bl	8003270 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8003a44:	9b03      	ldr	r3, [sp, #12]
 8003a46:	9a00      	ldr	r2, [sp, #0]
 8003a48:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 8003a4a:	9b03      	ldr	r3, [sp, #12]
 8003a4c:	9a01      	ldr	r2, [sp, #4]
 8003a4e:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8003a50:	9b03      	ldr	r3, [sp, #12]
 8003a52:	2200      	movs	r2, #0
 8003a54:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8003a56:	9a02      	ldr	r2, [sp, #8]
 8003a58:	9903      	ldr	r1, [sp, #12]
 8003a5a:	9805      	ldr	r0, [sp, #20]
 8003a5c:	f7ff ff88 	bl	8003970 <vt_enqueue>
}
 8003a60:	bf00      	nop
 8003a62:	b007      	add	sp, #28
 8003a64:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a68:	200009e0 	.word	0x200009e0
 8003a6c:	080055a0 	.word	0x080055a0

08003a70 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8003a70:	b500      	push	{lr}
 8003a72:	b087      	sub	sp, #28
 8003a74:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003a76:	4b34      	ldr	r3, [pc, #208]	@ (8003b48 <chVTDoResetI+0xd8>)
 8003a78:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8003a7a:	f7ff fd79 	bl	8003570 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8003a7e:	9b01      	ldr	r3, [sp, #4]
 8003a80:	2b00      	cmp	r3, #0
 8003a82:	bf0c      	ite	eq
 8003a84:	2301      	moveq	r3, #1
 8003a86:	2300      	movne	r3, #0
 8003a88:	b2db      	uxtb	r3, r3
 8003a8a:	2b00      	cmp	r3, #0
 8003a8c:	d002      	beq.n	8003a94 <chVTDoResetI+0x24>
 8003a8e:	482f      	ldr	r0, [pc, #188]	@ (8003b4c <chVTDoResetI+0xdc>)
 8003a90:	f7ff fbee 	bl	8003270 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8003a94:	9b05      	ldr	r3, [sp, #20]
 8003a96:	9a01      	ldr	r2, [sp, #4]
 8003a98:	4611      	mov	r1, r2
 8003a9a:	4618      	mov	r0, r3
 8003a9c:	f7ff fde0 	bl	8003660 <ch_dlist_isfirst>
 8003aa0:	4603      	mov	r3, r0
 8003aa2:	f083 0301 	eor.w	r3, r3, #1
 8003aa6:	b2db      	uxtb	r3, r3
 8003aa8:	2b00      	cmp	r3, #0
 8003aaa:	d014      	beq.n	8003ad6 <chVTDoResetI+0x66>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8003aac:	9b01      	ldr	r3, [sp, #4]
 8003aae:	4618      	mov	r0, r3
 8003ab0:	f7ff fe6e 	bl	8003790 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8003ab4:	9b01      	ldr	r3, [sp, #4]
 8003ab6:	681b      	ldr	r3, [r3, #0]
 8003ab8:	6899      	ldr	r1, [r3, #8]
 8003aba:	9b01      	ldr	r3, [sp, #4]
 8003abc:	689a      	ldr	r2, [r3, #8]
 8003abe:	9b01      	ldr	r3, [sp, #4]
 8003ac0:	681b      	ldr	r3, [r3, #0]
 8003ac2:	440a      	add	r2, r1
 8003ac4:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8003ac6:	9b01      	ldr	r3, [sp, #4]
 8003ac8:	2200      	movs	r2, #0
 8003aca:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8003acc:	9b05      	ldr	r3, [sp, #20]
 8003ace:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003ad2:	609a      	str	r2, [r3, #8]

    return;
 8003ad4:	e035      	b.n	8003b42 <chVTDoResetI+0xd2>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8003ad6:	9b05      	ldr	r3, [sp, #20]
 8003ad8:	4618      	mov	r0, r3
 8003ada:	f7ff fe41 	bl	8003760 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8003ade:	9b01      	ldr	r3, [sp, #4]
 8003ae0:	2200      	movs	r2, #0
 8003ae2:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003ae4:	9b05      	ldr	r3, [sp, #20]
 8003ae6:	4618      	mov	r0, r3
 8003ae8:	f7ff fdaa 	bl	8003640 <ch_dlist_isempty>
 8003aec:	4603      	mov	r3, r0
 8003aee:	2b00      	cmp	r3, #0
 8003af0:	d002      	beq.n	8003af8 <chVTDoResetI+0x88>

    port_timer_stop_alarm();
 8003af2:	f7ff fe6d 	bl	80037d0 <port_timer_stop_alarm>

    return;
 8003af6:	e024      	b.n	8003b42 <chVTDoResetI+0xd2>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8003af8:	9b05      	ldr	r3, [sp, #20]
 8003afa:	681b      	ldr	r3, [r3, #0]
 8003afc:	6899      	ldr	r1, [r3, #8]
 8003afe:	9b01      	ldr	r3, [sp, #4]
 8003b00:	689a      	ldr	r2, [r3, #8]
 8003b02:	9b05      	ldr	r3, [sp, #20]
 8003b04:	681b      	ldr	r3, [r3, #0]
 8003b06:	440a      	add	r2, r1
 8003b08:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 8003b0a:	f7ff fea1 	bl	8003850 <chVTGetSystemTimeX.lto_priv.0>
 8003b0e:	9004      	str	r0, [sp, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003b10:	9b05      	ldr	r3, [sp, #20]
 8003b12:	68db      	ldr	r3, [r3, #12]
 8003b14:	9904      	ldr	r1, [sp, #16]
 8003b16:	4618      	mov	r0, r3
 8003b18:	f7ff fd82 	bl	8003620 <chTimeDiffX.lto_priv.0>
 8003b1c:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8003b1e:	9b05      	ldr	r3, [sp, #20]
 8003b20:	681b      	ldr	r3, [r3, #0]
 8003b22:	689b      	ldr	r3, [r3, #8]
 8003b24:	9a03      	ldr	r2, [sp, #12]
 8003b26:	429a      	cmp	r2, r3
 8003b28:	d20a      	bcs.n	8003b40 <chVTDoResetI+0xd0>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8003b2a:	9b05      	ldr	r3, [sp, #20]
 8003b2c:	681b      	ldr	r3, [r3, #0]
 8003b2e:	689a      	ldr	r2, [r3, #8]
 8003b30:	9b03      	ldr	r3, [sp, #12]
 8003b32:	1ad3      	subs	r3, r2, r3
 8003b34:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 8003b36:	9902      	ldr	r1, [sp, #8]
 8003b38:	9804      	ldr	r0, [sp, #16]
 8003b3a:	f7ff fe91 	bl	8003860 <vt_set_alarm>
 8003b3e:	e000      	b.n	8003b42 <chVTDoResetI+0xd2>
    return;
 8003b40:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003b42:	b007      	add	sp, #28
 8003b44:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b48:	200009e0 	.word	0x200009e0
 8003b4c:	080055ac 	.word	0x080055ac

08003b50 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8003b50:	b500      	push	{lr}
 8003b52:	b089      	sub	sp, #36	@ 0x24
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003b54:	4b4d      	ldr	r3, [pc, #308]	@ (8003c8c <chVTDoTickI+0x13c>)
 8003b56:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8003b58:	f7ff fd0a 	bl	8003570 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8003b5c:	9b05      	ldr	r3, [sp, #20]
 8003b5e:	681b      	ldr	r3, [r3, #0]
 8003b60:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 8003b62:	f7ff fe75 	bl	8003850 <chVTGetSystemTimeX.lto_priv.0>
 8003b66:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003b68:	9b05      	ldr	r3, [sp, #20]
 8003b6a:	68db      	ldr	r3, [r3, #12]
 8003b6c:	9903      	ldr	r1, [sp, #12]
 8003b6e:	4618      	mov	r0, r3
 8003b70:	f7ff fd56 	bl	8003620 <chTimeDiffX.lto_priv.0>
 8003b74:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 8003b76:	9b04      	ldr	r3, [sp, #16]
 8003b78:	689b      	ldr	r3, [r3, #8]
 8003b7a:	9a02      	ldr	r2, [sp, #8]
 8003b7c:	429a      	cmp	r2, r3
 8003b7e:	d366      	bcc.n	8003c4e <chVTDoTickI+0xfe>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 8003b80:	9b05      	ldr	r3, [sp, #20]
 8003b82:	68da      	ldr	r2, [r3, #12]
 8003b84:	9b04      	ldr	r3, [sp, #16]
 8003b86:	689b      	ldr	r3, [r3, #8]
 8003b88:	4619      	mov	r1, r3
 8003b8a:	4610      	mov	r0, r2
 8003b8c:	f7ff fd38 	bl	8003600 <chTimeAddX>
 8003b90:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
 8003b92:	9b05      	ldr	r3, [sp, #20]
 8003b94:	9a01      	ldr	r2, [sp, #4]
 8003b96:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8003b98:	9b04      	ldr	r3, [sp, #16]
 8003b9a:	4618      	mov	r0, r3
 8003b9c:	f7ff fdf8 	bl	8003790 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8003ba0:	9b04      	ldr	r3, [sp, #16]
 8003ba2:	2200      	movs	r2, #0
 8003ba4:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003ba6:	9b05      	ldr	r3, [sp, #20]
 8003ba8:	4618      	mov	r0, r3
 8003baa:	f7ff fd49 	bl	8003640 <ch_dlist_isempty>
 8003bae:	4603      	mov	r3, r0
 8003bb0:	2b00      	cmp	r3, #0
 8003bb2:	d001      	beq.n	8003bb8 <chVTDoTickI+0x68>
      port_timer_stop_alarm();
 8003bb4:	f7ff fe0c 	bl	80037d0 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 8003bb8:	f7ff fe3a 	bl	8003830 <chSysUnlockFromISR.lto_priv.4>

    vtp->func(vtp, vtp->par);
 8003bbc:	9b04      	ldr	r3, [sp, #16]
 8003bbe:	68db      	ldr	r3, [r3, #12]
 8003bc0:	9a04      	ldr	r2, [sp, #16]
 8003bc2:	6912      	ldr	r2, [r2, #16]
 8003bc4:	4611      	mov	r1, r2
 8003bc6:	9804      	ldr	r0, [sp, #16]
 8003bc8:	4798      	blx	r3

    chSysLockFromISR();
 8003bca:	f7ff fe21 	bl	8003810 <chSysLockFromISR.lto_priv.4>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8003bce:	9b04      	ldr	r3, [sp, #16]
 8003bd0:	695b      	ldr	r3, [r3, #20]
 8003bd2:	2b00      	cmp	r3, #0
 8003bd4:	bf14      	ite	ne
 8003bd6:	2301      	movne	r3, #1
 8003bd8:	2300      	moveq	r3, #0
 8003bda:	b2db      	uxtb	r3, r3
 8003bdc:	2b00      	cmp	r3, #0
 8003bde:	d0bd      	beq.n	8003b5c <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8003be0:	f7ff fe36 	bl	8003850 <chVTGetSystemTimeX.lto_priv.0>
 8003be4:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 8003be6:	9903      	ldr	r1, [sp, #12]
 8003be8:	9801      	ldr	r0, [sp, #4]
 8003bea:	f7ff fd19 	bl	8003620 <chTimeDiffX.lto_priv.0>
 8003bee:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8003bf0:	9b04      	ldr	r3, [sp, #16]
 8003bf2:	695b      	ldr	r3, [r3, #20]
 8003bf4:	9a02      	ldr	r2, [sp, #8]
 8003bf6:	429a      	cmp	r2, r3
 8003bf8:	d905      	bls.n	8003c06 <chVTDoTickI+0xb6>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8003bfa:	2002      	movs	r0, #2
 8003bfc:	f7ff fb90 	bl	8003320 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8003c00:	2300      	movs	r3, #0
 8003c02:	9306      	str	r3, [sp, #24]
 8003c04:	e004      	b.n	8003c10 <chVTDoTickI+0xc0>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 8003c06:	9b04      	ldr	r3, [sp, #16]
 8003c08:	695a      	ldr	r2, [r3, #20]
 8003c0a:	9b02      	ldr	r3, [sp, #8]
 8003c0c:	1ad3      	subs	r3, r2, r3
 8003c0e:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8003c10:	9b05      	ldr	r3, [sp, #20]
 8003c12:	4618      	mov	r0, r3
 8003c14:	f7ff fd14 	bl	8003640 <ch_dlist_isempty>
 8003c18:	4603      	mov	r3, r0
 8003c1a:	2b00      	cmp	r3, #0
 8003c1c:	d006      	beq.n	8003c2c <chVTDoTickI+0xdc>

        vt_insert_first(vtlp, vtp, now, delay);
 8003c1e:	9b06      	ldr	r3, [sp, #24]
 8003c20:	9a03      	ldr	r2, [sp, #12]
 8003c22:	9904      	ldr	r1, [sp, #16]
 8003c24:	9805      	ldr	r0, [sp, #20]
 8003c26:	f7ff fe53 	bl	80038d0 <vt_insert_first>

        return;
 8003c2a:	e02c      	b.n	8003c86 <chVTDoTickI+0x136>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8003c2c:	9a02      	ldr	r2, [sp, #8]
 8003c2e:	9b06      	ldr	r3, [sp, #24]
 8003c30:	4413      	add	r3, r2
 8003c32:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 8003c34:	9a07      	ldr	r2, [sp, #28]
 8003c36:	9b02      	ldr	r3, [sp, #8]
 8003c38:	429a      	cmp	r2, r3
 8003c3a:	d201      	bcs.n	8003c40 <chVTDoTickI+0xf0>
        delta = delay;
 8003c3c:	9b06      	ldr	r3, [sp, #24]
 8003c3e:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003c40:	9b05      	ldr	r3, [sp, #20]
 8003c42:	9904      	ldr	r1, [sp, #16]
 8003c44:	9a07      	ldr	r2, [sp, #28]
 8003c46:	4618      	mov	r0, r3
 8003c48:	f7ff fd5a 	bl	8003700 <ch_dlist_insert>
  while (true) {
 8003c4c:	e786      	b.n	8003b5c <chVTDoTickI+0xc>
      break;
 8003c4e:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003c50:	9b05      	ldr	r3, [sp, #20]
 8003c52:	4618      	mov	r0, r3
 8003c54:	f7ff fcf4 	bl	8003640 <ch_dlist_isempty>
 8003c58:	4603      	mov	r3, r0
 8003c5a:	2b00      	cmp	r3, #0
 8003c5c:	d112      	bne.n	8003c84 <chVTDoTickI+0x134>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 8003c5e:	9b05      	ldr	r3, [sp, #20]
 8003c60:	68da      	ldr	r2, [r3, #12]
 8003c62:	9b02      	ldr	r3, [sp, #8]
 8003c64:	441a      	add	r2, r3
 8003c66:	9b05      	ldr	r3, [sp, #20]
 8003c68:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 8003c6a:	9b04      	ldr	r3, [sp, #16]
 8003c6c:	689a      	ldr	r2, [r3, #8]
 8003c6e:	9b02      	ldr	r3, [sp, #8]
 8003c70:	1ad2      	subs	r2, r2, r3
 8003c72:	9b04      	ldr	r3, [sp, #16]
 8003c74:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 8003c76:	9b04      	ldr	r3, [sp, #16]
 8003c78:	689b      	ldr	r3, [r3, #8]
 8003c7a:	4619      	mov	r1, r3
 8003c7c:	9803      	ldr	r0, [sp, #12]
 8003c7e:	f7ff fdef 	bl	8003860 <vt_set_alarm>
 8003c82:	e000      	b.n	8003c86 <chVTDoTickI+0x136>
    return;
 8003c84:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003c86:	b009      	add	sp, #36	@ 0x24
 8003c88:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c8c:	200009e0 	.word	0x200009e0

08003c90 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003c90:	b082      	sub	sp, #8
 8003c92:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003c94:	9b01      	ldr	r3, [sp, #4]
 8003c96:	685b      	ldr	r3, [r3, #4]
 8003c98:	9a01      	ldr	r2, [sp, #4]
 8003c9a:	6812      	ldr	r2, [r2, #0]
 8003c9c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8003c9e:	9b01      	ldr	r3, [sp, #4]
 8003ca0:	681b      	ldr	r3, [r3, #0]
 8003ca2:	9a01      	ldr	r2, [sp, #4]
 8003ca4:	6852      	ldr	r2, [r2, #4]
 8003ca6:	605a      	str	r2, [r3, #4]
  return p;
 8003ca8:	9b01      	ldr	r3, [sp, #4]
}
 8003caa:	4618      	mov	r0, r3
 8003cac:	b002      	add	sp, #8
 8003cae:	4770      	bx	lr

08003cb0 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 8003cb0:	b084      	sub	sp, #16
 8003cb2:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 8003cb4:	9b01      	ldr	r3, [sp, #4]
 8003cb6:	681b      	ldr	r3, [r3, #0]
 8003cb8:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 8003cba:	9b03      	ldr	r3, [sp, #12]
 8003cbc:	681a      	ldr	r2, [r3, #0]
 8003cbe:	9b01      	ldr	r3, [sp, #4]
 8003cc0:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 8003cc2:	9b01      	ldr	r3, [sp, #4]
 8003cc4:	681b      	ldr	r3, [r3, #0]
 8003cc6:	9a01      	ldr	r2, [sp, #4]
 8003cc8:	605a      	str	r2, [r3, #4]
  return p;
 8003cca:	9b03      	ldr	r3, [sp, #12]
}
 8003ccc:	4618      	mov	r0, r3
 8003cce:	b004      	add	sp, #16
 8003cd0:	4770      	bx	lr
 8003cd2:	bf00      	nop
	...

08003ce0 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8003ce0:	b082      	sub	sp, #8
 8003ce2:	9001      	str	r0, [sp, #4]
 8003ce4:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003ce6:	9b01      	ldr	r3, [sp, #4]
 8003ce8:	681b      	ldr	r3, [r3, #0]
 8003cea:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 8003cec:	9b01      	ldr	r3, [sp, #4]
 8003cee:	689a      	ldr	r2, [r3, #8]
 8003cf0:	9b00      	ldr	r3, [sp, #0]
 8003cf2:	689b      	ldr	r3, [r3, #8]
 8003cf4:	429a      	cmp	r2, r3
 8003cf6:	bf2c      	ite	cs
 8003cf8:	2301      	movcs	r3, #1
 8003cfa:	2300      	movcc	r3, #0
 8003cfc:	b2db      	uxtb	r3, r3
 8003cfe:	2b00      	cmp	r3, #0
 8003d00:	d1f1      	bne.n	8003ce6 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8003d02:	9b00      	ldr	r3, [sp, #0]
 8003d04:	9a01      	ldr	r2, [sp, #4]
 8003d06:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003d08:	9b01      	ldr	r3, [sp, #4]
 8003d0a:	685a      	ldr	r2, [r3, #4]
 8003d0c:	9b00      	ldr	r3, [sp, #0]
 8003d0e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003d10:	9b00      	ldr	r3, [sp, #0]
 8003d12:	685b      	ldr	r3, [r3, #4]
 8003d14:	9a00      	ldr	r2, [sp, #0]
 8003d16:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003d18:	9b01      	ldr	r3, [sp, #4]
 8003d1a:	9a00      	ldr	r2, [sp, #0]
 8003d1c:	605a      	str	r2, [r3, #4]
  return p;
 8003d1e:	9b00      	ldr	r3, [sp, #0]
}
 8003d20:	4618      	mov	r0, r3
 8003d22:	b002      	add	sp, #8
 8003d24:	4770      	bx	lr
 8003d26:	bf00      	nop
	...

08003d30 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8003d30:	b082      	sub	sp, #8
 8003d32:	9001      	str	r0, [sp, #4]
 8003d34:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003d36:	9b01      	ldr	r3, [sp, #4]
 8003d38:	681b      	ldr	r3, [r3, #0]
 8003d3a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 8003d3c:	9b01      	ldr	r3, [sp, #4]
 8003d3e:	689a      	ldr	r2, [r3, #8]
 8003d40:	9b00      	ldr	r3, [sp, #0]
 8003d42:	689b      	ldr	r3, [r3, #8]
 8003d44:	429a      	cmp	r2, r3
 8003d46:	bf8c      	ite	hi
 8003d48:	2301      	movhi	r3, #1
 8003d4a:	2300      	movls	r3, #0
 8003d4c:	b2db      	uxtb	r3, r3
 8003d4e:	2b00      	cmp	r3, #0
 8003d50:	d1f1      	bne.n	8003d36 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 8003d52:	9b00      	ldr	r3, [sp, #0]
 8003d54:	9a01      	ldr	r2, [sp, #4]
 8003d56:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003d58:	9b01      	ldr	r3, [sp, #4]
 8003d5a:	685a      	ldr	r2, [r3, #4]
 8003d5c:	9b00      	ldr	r3, [sp, #0]
 8003d5e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003d60:	9b00      	ldr	r3, [sp, #0]
 8003d62:	685b      	ldr	r3, [r3, #4]
 8003d64:	9a00      	ldr	r2, [sp, #0]
 8003d66:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003d68:	9b01      	ldr	r3, [sp, #4]
 8003d6a:	9a00      	ldr	r2, [sp, #0]
 8003d6c:	605a      	str	r2, [r3, #4]
  return p;
 8003d6e:	9b00      	ldr	r3, [sp, #0]
}
 8003d70:	4618      	mov	r0, r3
 8003d72:	b002      	add	sp, #8
 8003d74:	4770      	bx	lr
 8003d76:	bf00      	nop
	...

08003d80 <chSysLockFromISR.lto_priv.5>:
static inline void chSysLockFromISR(void) {
 8003d80:	b500      	push	{lr}
 8003d82:	b083      	sub	sp, #12
 8003d84:	2330      	movs	r3, #48	@ 0x30
 8003d86:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003d88:	9b01      	ldr	r3, [sp, #4]
 8003d8a:	f383 8811 	msr	BASEPRI, r3
}
 8003d8e:	bf00      	nop
}
 8003d90:	bf00      	nop
}
 8003d92:	bf00      	nop
  __dbg_check_lock_from_isr();
 8003d94:	f7ff fb24 	bl	80033e0 <__dbg_check_lock_from_isr>
}
 8003d98:	bf00      	nop
 8003d9a:	b003      	add	sp, #12
 8003d9c:	f85d fb04 	ldr.w	pc, [sp], #4

08003da0 <chSysUnlockFromISR.lto_priv.5>:
static inline void chSysUnlockFromISR(void) {
 8003da0:	b500      	push	{lr}
 8003da2:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8003da4:	f7ff fb44 	bl	8003430 <__dbg_check_unlock_from_isr>
 8003da8:	2300      	movs	r3, #0
 8003daa:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003dac:	9b01      	ldr	r3, [sp, #4]
 8003dae:	f383 8811 	msr	BASEPRI, r3
}
 8003db2:	bf00      	nop
}
 8003db4:	bf00      	nop
}
 8003db6:	bf00      	nop
}
 8003db8:	bf00      	nop
 8003dba:	b003      	add	sp, #12
 8003dbc:	f85d fb04 	ldr.w	pc, [sp], #4

08003dc0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8003dc0:	b500      	push	{lr}
 8003dc2:	b083      	sub	sp, #12
 8003dc4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003dc6:	f7ff fbd3 	bl	8003570 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 8003dca:	9b01      	ldr	r3, [sp, #4]
 8003dcc:	681b      	ldr	r3, [r3, #0]
 8003dce:	2b00      	cmp	r3, #0
 8003dd0:	bf14      	ite	ne
 8003dd2:	2301      	movne	r3, #1
 8003dd4:	2300      	moveq	r3, #0
 8003dd6:	b2db      	uxtb	r3, r3
}
 8003dd8:	4618      	mov	r0, r3
 8003dda:	b003      	add	sp, #12
 8003ddc:	f85d fb04 	ldr.w	pc, [sp], #4

08003de0 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8003de0:	b500      	push	{lr}
 8003de2:	b083      	sub	sp, #12
 8003de4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003de6:	f7ff fbc3 	bl	8003570 <chDbgCheckClassI>

  sp->cnt++;
 8003dea:	9b01      	ldr	r3, [sp, #4]
 8003dec:	689b      	ldr	r3, [r3, #8]
 8003dee:	1c5a      	adds	r2, r3, #1
 8003df0:	9b01      	ldr	r3, [sp, #4]
 8003df2:	609a      	str	r2, [r3, #8]
}
 8003df4:	bf00      	nop
 8003df6:	b003      	add	sp, #12
 8003df8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dfc:	0000      	movs	r0, r0
	...

08003e00 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8003e00:	b500      	push	{lr}
 8003e02:	b083      	sub	sp, #12
 8003e04:	9001      	str	r0, [sp, #4]

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003e06:	9b01      	ldr	r3, [sp, #4]
 8003e08:	2200      	movs	r2, #0
 8003e0a:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8003e0e:	9b01      	ldr	r3, [sp, #4]
 8003e10:	699b      	ldr	r3, [r3, #24]
 8003e12:	461a      	mov	r2, r3
 8003e14:	9b01      	ldr	r3, [sp, #4]
 8003e16:	4619      	mov	r1, r3
 8003e18:	4610      	mov	r0, r2
 8003e1a:	f7ff ff61 	bl	8003ce0 <ch_pqueue_insert_behind>
 8003e1e:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
 8003e20:	4618      	mov	r0, r3
 8003e22:	b003      	add	sp, #12
 8003e24:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003e30 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8003e30:	b500      	push	{lr}
 8003e32:	b083      	sub	sp, #12
 8003e34:	9001      	str	r0, [sp, #4]

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003e36:	9b01      	ldr	r3, [sp, #4]
 8003e38:	2200      	movs	r2, #0
 8003e3a:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8003e3e:	9b01      	ldr	r3, [sp, #4]
 8003e40:	699b      	ldr	r3, [r3, #24]
 8003e42:	461a      	mov	r2, r3
 8003e44:	9b01      	ldr	r3, [sp, #4]
 8003e46:	4619      	mov	r1, r3
 8003e48:	4610      	mov	r0, r2
 8003e4a:	f7ff ff71 	bl	8003d30 <ch_pqueue_insert_ahead>
 8003e4e:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
 8003e50:	4618      	mov	r0, r3
 8003e52:	b003      	add	sp, #12
 8003e54:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003e60 <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8003e60:	b500      	push	{lr}
 8003e62:	b085      	sub	sp, #20
 8003e64:	9001      	str	r0, [sp, #4]
 8003e66:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 8003e68:	9b00      	ldr	r3, [sp, #0]
 8003e6a:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 8003e6c:	f7ff ff88 	bl	8003d80 <chSysLockFromISR.lto_priv.5>
  switch (tp->state) {
 8003e70:	9b03      	ldr	r3, [sp, #12]
 8003e72:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8003e76:	2b0c      	cmp	r3, #12
 8003e78:	d82e      	bhi.n	8003ed8 <__sch_wakeup+0x78>
 8003e7a:	a201      	add	r2, pc, #4	@ (adr r2, 8003e80 <__sch_wakeup+0x20>)
 8003e7c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003e80:	08003eb5 	.word	0x08003eb5
 8003e84:	08003ed9 	.word	0x08003ed9
 8003e88:	08003ed9 	.word	0x08003ed9
 8003e8c:	08003ebb 	.word	0x08003ebb
 8003e90:	08003ecf 	.word	0x08003ecf
 8003e94:	08003ec5 	.word	0x08003ec5
 8003e98:	08003ed9 	.word	0x08003ed9
 8003e9c:	08003ecf 	.word	0x08003ecf
 8003ea0:	08003ed9 	.word	0x08003ed9
 8003ea4:	08003ed9 	.word	0x08003ed9
 8003ea8:	08003ed9 	.word	0x08003ed9
 8003eac:	08003ed9 	.word	0x08003ed9
 8003eb0:	08003ecf 	.word	0x08003ecf
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8003eb4:	f7ff ff74 	bl	8003da0 <chSysUnlockFromISR.lto_priv.5>
    return;
 8003eb8:	e019      	b.n	8003eee <__sch_wakeup+0x8e>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8003eba:	9b03      	ldr	r3, [sp, #12]
 8003ebc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003ebe:	2200      	movs	r2, #0
 8003ec0:	601a      	str	r2, [r3, #0]
    break;
 8003ec2:	e00a      	b.n	8003eda <__sch_wakeup+0x7a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8003ec4:	9b03      	ldr	r3, [sp, #12]
 8003ec6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003ec8:	4618      	mov	r0, r3
 8003eca:	f7ff ff89 	bl	8003de0 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 8003ece:	9b03      	ldr	r3, [sp, #12]
 8003ed0:	4618      	mov	r0, r3
 8003ed2:	f7ff fedd 	bl	8003c90 <ch_queue_dequeue.lto_priv.0>
    break;
 8003ed6:	e000      	b.n	8003eda <__sch_wakeup+0x7a>
  default:
    /* Any other state, nothing to do.*/
    break;
 8003ed8:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 8003eda:	9b03      	ldr	r3, [sp, #12]
 8003edc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8003ee0:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 8003ee2:	9803      	ldr	r0, [sp, #12]
 8003ee4:	f7ff ff8c 	bl	8003e00 <__sch_ready_behind>
  chSysUnlockFromISR();
 8003ee8:	f7ff ff5a 	bl	8003da0 <chSysUnlockFromISR.lto_priv.5>

  return;
 8003eec:	bf00      	nop
}
 8003eee:	b005      	add	sp, #20
 8003ef0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003f00 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003f00:	b500      	push	{lr}
 8003f02:	b083      	sub	sp, #12
 8003f04:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003f06:	f7ff fb33 	bl	8003570 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8003f0a:	9b01      	ldr	r3, [sp, #4]
 8003f0c:	2b00      	cmp	r3, #0
 8003f0e:	bf0c      	ite	eq
 8003f10:	2301      	moveq	r3, #1
 8003f12:	2300      	movne	r3, #0
 8003f14:	b2db      	uxtb	r3, r3
 8003f16:	2b00      	cmp	r3, #0
 8003f18:	d002      	beq.n	8003f20 <chSchReadyI+0x20>
 8003f1a:	4805      	ldr	r0, [pc, #20]	@ (8003f30 <chSchReadyI+0x30>)
 8003f1c:	f7ff f9a8 	bl	8003270 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 8003f20:	9801      	ldr	r0, [sp, #4]
 8003f22:	f7ff ff6d 	bl	8003e00 <__sch_ready_behind>
 8003f26:	4603      	mov	r3, r0
}
 8003f28:	4618      	mov	r0, r3
 8003f2a:	b003      	add	sp, #12
 8003f2c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f30:	080055bc 	.word	0x080055bc
	...

08003f40 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003f40:	b500      	push	{lr}
 8003f42:	b087      	sub	sp, #28
 8003f44:	4603      	mov	r3, r0
 8003f46:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
 8003f4a:	4b10      	ldr	r3, [pc, #64]	@ (8003f8c <chSchGoSleepS+0x4c>)
 8003f4c:	9304      	str	r3, [sp, #16]
  thread_t *otp = __instance_get_currthread(oip);
 8003f4e:	9b04      	ldr	r3, [sp, #16]
 8003f50:	68db      	ldr	r3, [r3, #12]
 8003f52:	9303      	str	r3, [sp, #12]
  thread_t *ntp;

  chDbgCheckClassS();
 8003f54:	f7ff fb2c 	bl	80035b0 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
 8003f58:	9b03      	ldr	r3, [sp, #12]
 8003f5a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8003f5e:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8003f62:	9b04      	ldr	r3, [sp, #16]
 8003f64:	4618      	mov	r0, r3
 8003f66:	f7ff fea3 	bl	8003cb0 <ch_pqueue_remove_highest>
 8003f6a:	9005      	str	r0, [sp, #20]
  ntp->state = CH_STATE_CURRENT;
 8003f6c:	9b05      	ldr	r3, [sp, #20]
 8003f6e:	2201      	movs	r2, #1
 8003f70:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8003f74:	9b04      	ldr	r3, [sp, #16]
 8003f76:	9a05      	ldr	r2, [sp, #20]
 8003f78:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8003f7a:	9903      	ldr	r1, [sp, #12]
 8003f7c:	9805      	ldr	r0, [sp, #20]
 8003f7e:	f7fc f94f 	bl	8000220 <__port_switch>
}
 8003f82:	bf00      	nop
 8003f84:	b007      	add	sp, #28
 8003f86:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f8a:	bf00      	nop
 8003f8c:	200009d0 	.word	0x200009d0

08003f90 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8003f90:	b500      	push	{lr}
 8003f92:	b08b      	sub	sp, #44	@ 0x2c
 8003f94:	4603      	mov	r3, r0
 8003f96:	9100      	str	r1, [sp, #0]
 8003f98:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 8003f9c:	4b15      	ldr	r3, [pc, #84]	@ (8003ff4 <chSchGoSleepTimeoutS+0x64>)
 8003f9e:	68db      	ldr	r3, [r3, #12]
 8003fa0:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();
 8003fa2:	f7ff fb05 	bl	80035b0 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 8003fa6:	9b00      	ldr	r3, [sp, #0]
 8003fa8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8003fac:	d016      	beq.n	8003fdc <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 8003fae:	a803      	add	r0, sp, #12
 8003fb0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003fb2:	4a11      	ldr	r2, [pc, #68]	@ (8003ff8 <chSchGoSleepTimeoutS+0x68>)
 8003fb4:	9900      	ldr	r1, [sp, #0]
 8003fb6:	f7ff fd1b 	bl	80039f0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8003fba:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003fbe:	4618      	mov	r0, r3
 8003fc0:	f7ff ffbe 	bl	8003f40 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8003fc4:	ab03      	add	r3, sp, #12
 8003fc6:	4618      	mov	r0, r3
 8003fc8:	f7ff fefa 	bl	8003dc0 <chVTIsArmedI>
 8003fcc:	4603      	mov	r3, r0
 8003fce:	2b00      	cmp	r3, #0
 8003fd0:	d009      	beq.n	8003fe6 <chSchGoSleepTimeoutS+0x56>
      chVTDoResetI(&vt);
 8003fd2:	ab03      	add	r3, sp, #12
 8003fd4:	4618      	mov	r0, r3
 8003fd6:	f7ff fd4b 	bl	8003a70 <chVTDoResetI>
 8003fda:	e004      	b.n	8003fe6 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8003fdc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003fe0:	4618      	mov	r0, r3
 8003fe2:	f7ff ffad 	bl	8003f40 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 8003fe6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003fe8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
}
 8003fea:	4618      	mov	r0, r3
 8003fec:	b00b      	add	sp, #44	@ 0x2c
 8003fee:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ff2:	bf00      	nop
 8003ff4:	200009d0 	.word	0x200009d0
 8003ff8:	08003e61 	.word	0x08003e61
 8003ffc:	00000000 	.word	0x00000000

08004000 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8004000:	b500      	push	{lr}
 8004002:	b085      	sub	sp, #20
 8004004:	9001      	str	r0, [sp, #4]
 8004006:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8004008:	4b15      	ldr	r3, [pc, #84]	@ (8004060 <chSchWakeupS+0x60>)
 800400a:	9302      	str	r3, [sp, #8]
  thread_t *otp = __instance_get_currthread(oip);
 800400c:	9b02      	ldr	r3, [sp, #8]
 800400e:	68db      	ldr	r3, [r3, #12]
 8004010:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();
 8004012:	f7ff facd 	bl	80035b0 <chDbgCheckClassS>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8004016:	9b01      	ldr	r3, [sp, #4]
 8004018:	9a00      	ldr	r2, [sp, #0]
 800401a:	629a      	str	r2, [r3, #40]	@ 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 800401c:	9b01      	ldr	r3, [sp, #4]
 800401e:	689a      	ldr	r2, [r3, #8]
 8004020:	9b03      	ldr	r3, [sp, #12]
 8004022:	689b      	ldr	r3, [r3, #8]
 8004024:	429a      	cmp	r2, r3
 8004026:	bf94      	ite	ls
 8004028:	2301      	movls	r3, #1
 800402a:	2300      	movhi	r3, #0
 800402c:	b2db      	uxtb	r3, r3
 800402e:	2b00      	cmp	r3, #0
 8004030:	d003      	beq.n	800403a <chSchWakeupS+0x3a>
    (void) __sch_ready_behind(ntp);
 8004032:	9801      	ldr	r0, [sp, #4]
 8004034:	f7ff fee4 	bl	8003e00 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8004038:	e00e      	b.n	8004058 <chSchWakeupS+0x58>
    otp = __sch_ready_ahead(otp);
 800403a:	9803      	ldr	r0, [sp, #12]
 800403c:	f7ff fef8 	bl	8003e30 <__sch_ready_ahead>
 8004040:	9003      	str	r0, [sp, #12]
    ntp->state = CH_STATE_CURRENT;
 8004042:	9b01      	ldr	r3, [sp, #4]
 8004044:	2201      	movs	r2, #1
 8004046:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    __instance_set_currthread(oip, ntp);
 800404a:	9b02      	ldr	r3, [sp, #8]
 800404c:	9a01      	ldr	r2, [sp, #4]
 800404e:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 8004050:	9903      	ldr	r1, [sp, #12]
 8004052:	9801      	ldr	r0, [sp, #4]
 8004054:	f7fc f8e4 	bl	8000220 <__port_switch>
}
 8004058:	bf00      	nop
 800405a:	b005      	add	sp, #20
 800405c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004060:	200009d0 	.word	0x200009d0
	...

08004070 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8004070:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 8004072:	4b0b      	ldr	r3, [pc, #44]	@ (80040a0 <chSchIsPreemptionRequired+0x30>)
 8004074:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 8004076:	9b03      	ldr	r3, [sp, #12]
 8004078:	68db      	ldr	r3, [r3, #12]
 800407a:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 800407c:	9b03      	ldr	r3, [sp, #12]
 800407e:	681b      	ldr	r3, [r3, #0]
 8004080:	689b      	ldr	r3, [r3, #8]
 8004082:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8004084:	9b02      	ldr	r3, [sp, #8]
 8004086:	689b      	ldr	r3, [r3, #8]
 8004088:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800408a:	9a01      	ldr	r2, [sp, #4]
 800408c:	9b00      	ldr	r3, [sp, #0]
 800408e:	429a      	cmp	r2, r3
 8004090:	bf8c      	ite	hi
 8004092:	2301      	movhi	r3, #1
 8004094:	2300      	movls	r3, #0
 8004096:	b2db      	uxtb	r3, r3
#endif
}
 8004098:	4618      	mov	r0, r3
 800409a:	b004      	add	sp, #16
 800409c:	4770      	bx	lr
 800409e:	bf00      	nop
 80040a0:	200009d0 	.word	0x200009d0
	...

080040b0 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 80040b0:	b500      	push	{lr}
 80040b2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80040b4:	4b0e      	ldr	r3, [pc, #56]	@ (80040f0 <chSchDoPreemption+0x40>)
 80040b6:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 80040b8:	9b03      	ldr	r3, [sp, #12]
 80040ba:	68db      	ldr	r3, [r3, #12]
 80040bc:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 80040be:	9b03      	ldr	r3, [sp, #12]
 80040c0:	4618      	mov	r0, r3
 80040c2:	f7ff fdf5 	bl	8003cb0 <ch_pqueue_remove_highest>
 80040c6:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 80040c8:	9b01      	ldr	r3, [sp, #4]
 80040ca:	2201      	movs	r2, #1
 80040cc:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 80040d0:	9b03      	ldr	r3, [sp, #12]
 80040d2:	9a01      	ldr	r2, [sp, #4]
 80040d4:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 80040d6:	9802      	ldr	r0, [sp, #8]
 80040d8:	f7ff feaa 	bl	8003e30 <__sch_ready_ahead>
 80040dc:	9002      	str	r0, [sp, #8]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80040de:	9902      	ldr	r1, [sp, #8]
 80040e0:	9801      	ldr	r0, [sp, #4]
 80040e2:	f7fc f89d 	bl	8000220 <__port_switch>
}
 80040e6:	bf00      	nop
 80040e8:	b005      	add	sp, #20
 80040ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80040ee:	bf00      	nop
 80040f0:	200009d0 	.word	0x200009d0
	...

08004100 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 8004100:	b082      	sub	sp, #8
 8004102:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 8004104:	9b01      	ldr	r3, [sp, #4]
 8004106:	2200      	movs	r2, #0
 8004108:	601a      	str	r2, [r3, #0]
}
 800410a:	bf00      	nop
 800410c:	b002      	add	sp, #8
 800410e:	4770      	bx	lr

08004110 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 8004110:	b082      	sub	sp, #8
 8004112:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 8004114:	9b01      	ldr	r3, [sp, #4]
 8004116:	2200      	movs	r2, #0
 8004118:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 800411a:	9b01      	ldr	r3, [sp, #4]
 800411c:	2200      	movs	r2, #0
 800411e:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 8004120:	9b01      	ldr	r3, [sp, #4]
 8004122:	2201      	movs	r2, #1
 8004124:	609a      	str	r2, [r3, #8]
#endif
}
 8004126:	bf00      	nop
 8004128:	b002      	add	sp, #8
 800412a:	4770      	bx	lr
 800412c:	0000      	movs	r0, r0
	...

08004130 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004130:	b082      	sub	sp, #8
 8004132:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004134:	9b01      	ldr	r3, [sp, #4]
 8004136:	9a01      	ldr	r2, [sp, #4]
 8004138:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800413a:	9b01      	ldr	r3, [sp, #4]
 800413c:	9a01      	ldr	r2, [sp, #4]
 800413e:	605a      	str	r2, [r3, #4]
}
 8004140:	bf00      	nop
 8004142:	b002      	add	sp, #8
 8004144:	4770      	bx	lr
 8004146:	bf00      	nop
	...

08004150 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 8004150:	b082      	sub	sp, #8
 8004152:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 8004154:	9b01      	ldr	r3, [sp, #4]
 8004156:	9a01      	ldr	r2, [sp, #4]
 8004158:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 800415a:	9b01      	ldr	r3, [sp, #4]
 800415c:	9a01      	ldr	r2, [sp, #4]
 800415e:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 8004160:	9b01      	ldr	r3, [sp, #4]
 8004162:	2200      	movs	r2, #0
 8004164:	609a      	str	r2, [r3, #8]
}
 8004166:	bf00      	nop
 8004168:	b002      	add	sp, #8
 800416a:	4770      	bx	lr
 800416c:	0000      	movs	r0, r0
	...

08004170 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 8004170:	b082      	sub	sp, #8
 8004172:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 8004174:	9b01      	ldr	r3, [sp, #4]
 8004176:	9a01      	ldr	r2, [sp, #4]
 8004178:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 800417a:	9b01      	ldr	r3, [sp, #4]
 800417c:	9a01      	ldr	r2, [sp, #4]
 800417e:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 8004180:	9b01      	ldr	r3, [sp, #4]
 8004182:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8004186:	609a      	str	r2, [r3, #8]
}
 8004188:	bf00      	nop
 800418a:	b002      	add	sp, #8
 800418c:	4770      	bx	lr
 800418e:	bf00      	nop

08004190 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 8004190:	b508      	push	{r3, lr}
  return stGetCounter();
 8004192:	f7fc f925 	bl	80003e0 <stGetCounter>
 8004196:	4603      	mov	r3, r0
}
 8004198:	4618      	mov	r0, r3
 800419a:	bd08      	pop	{r3, pc}
 800419c:	0000      	movs	r0, r0
	...

080041a0 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 80041a0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 80041a2:	f7ff fff5 	bl	8004190 <port_timer_get_time.lto_priv.1>
 80041a6:	4603      	mov	r3, r0
}
 80041a8:	4618      	mov	r0, r3
 80041aa:	bd08      	pop	{r3, pc}
 80041ac:	0000      	movs	r0, r0
	...

080041b0 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 80041b0:	b530      	push	{r4, r5, lr}
 80041b2:	b083      	sub	sp, #12
 80041b4:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 80041b6:	9b01      	ldr	r3, [sp, #4]
 80041b8:	4618      	mov	r0, r3
 80041ba:	f7ff ffd9 	bl	8004170 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 80041be:	9b01      	ldr	r3, [sp, #4]
 80041c0:	2200      	movs	r2, #0
 80041c2:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 80041c4:	f7ff ffec 	bl	80041a0 <chVTGetSystemTimeX.lto_priv.1>
 80041c8:	4603      	mov	r3, r0
 80041ca:	2200      	movs	r2, #0
 80041cc:	461c      	mov	r4, r3
 80041ce:	4615      	mov	r5, r2
 80041d0:	9b01      	ldr	r3, [sp, #4]
 80041d2:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 80041d6:	bf00      	nop
 80041d8:	b003      	add	sp, #12
 80041da:	bd30      	pop	{r4, r5, pc}
 80041dc:	0000      	movs	r0, r0
	...

080041e0 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 80041e0:	b500      	push	{lr}
 80041e2:	b083      	sub	sp, #12
 80041e4:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 80041e6:	9b01      	ldr	r3, [sp, #4]
 80041e8:	4618      	mov	r0, r3
 80041ea:	f7ff ffa1 	bl	8004130 <ch_queue_init.lto_priv.2>
}
 80041ee:	bf00      	nop
 80041f0:	b003      	add	sp, #12
 80041f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80041f6:	bf00      	nop
	...

08004200 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8004200:	b082      	sub	sp, #8
 8004202:	9001      	str	r0, [sp, #4]
}
 8004204:	bf00      	nop
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
    asm volatile ("nop");
 8004206:	bf00      	nop
    port_wait_for_interrupt();
 8004208:	bf00      	nop
 800420a:	e7fb      	b.n	8004204 <__idle_thread+0x4>
 800420c:	0000      	movs	r0, r0
	...

08004210 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8004210:	b500      	push	{lr}
 8004212:	b08b      	sub	sp, #44	@ 0x2c
 8004214:	9001      	str	r0, [sp, #4]
 8004216:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 8004218:	2300      	movs	r3, #0
 800421a:	9309      	str	r3, [sp, #36]	@ 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 800421c:	4a28      	ldr	r2, [pc, #160]	@ (80042c0 <chInstanceObjectInit+0xb0>)
 800421e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8004220:	009b      	lsls	r3, r3, #2
 8004222:	4413      	add	r3, r2
 8004224:	9a01      	ldr	r2, [sp, #4]
 8004226:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 8004228:	9b01      	ldr	r3, [sp, #4]
 800422a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800422c:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 800422e:	9b01      	ldr	r3, [sp, #4]
 8004230:	9a00      	ldr	r2, [sp, #0]
 8004232:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 8004234:	9801      	ldr	r0, [sp, #4]
 8004236:	f000 fe7b 	bl	8004f30 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 800423a:	9b01      	ldr	r3, [sp, #4]
 800423c:	4618      	mov	r0, r3
 800423e:	f7ff ff87 	bl	8004150 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 8004242:	9b01      	ldr	r3, [sp, #4]
 8004244:	3328      	adds	r3, #40	@ 0x28
 8004246:	4618      	mov	r0, r3
 8004248:	f7ff ffca 	bl	80041e0 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 800424c:	9b01      	ldr	r3, [sp, #4]
 800424e:	3334      	adds	r3, #52	@ 0x34
 8004250:	4618      	mov	r0, r3
 8004252:	f7ff ff55 	bl	8004100 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8004256:	9b01      	ldr	r3, [sp, #4]
 8004258:	3310      	adds	r3, #16
 800425a:	4618      	mov	r0, r3
 800425c:	f7ff ffa8 	bl	80041b0 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 8004260:	9b01      	ldr	r3, [sp, #4]
 8004262:	3384      	adds	r3, #132	@ 0x84
 8004264:	4618      	mov	r0, r3
 8004266:	f7ff ff53 	bl	8004110 <__dbg_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 800426a:	9b01      	ldr	r3, [sp, #4]
 800426c:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 8004270:	2380      	movs	r3, #128	@ 0x80
 8004272:	4a14      	ldr	r2, [pc, #80]	@ (80042c4 <chInstanceObjectInit+0xb4>)
 8004274:	9801      	ldr	r0, [sp, #4]
 8004276:	f000 f90b 	bl	8004490 <__thd_object_init>
 800427a:	4602      	mov	r2, r0
 800427c:	9b01      	ldr	r3, [sp, #4]
 800427e:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 8004280:	9b01      	ldr	r3, [sp, #4]
 8004282:	68db      	ldr	r3, [r3, #12]
 8004284:	9a00      	ldr	r2, [sp, #0]
 8004286:	6852      	ldr	r2, [r2, #4]
 8004288:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 800428a:	9b01      	ldr	r3, [sp, #4]
 800428c:	68db      	ldr	r3, [r3, #12]
 800428e:	2201      	movs	r2, #1
 8004290:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 8004294:	4b0c      	ldr	r3, [pc, #48]	@ (80042c8 <chInstanceObjectInit+0xb8>)
 8004296:	9303      	str	r3, [sp, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8004298:	9b00      	ldr	r3, [sp, #0]
 800429a:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 800429c:	9304      	str	r3, [sp, #16]
      .wend     = oicp->idlethread_end,
 800429e:	9b00      	ldr	r3, [sp, #0]
 80042a0:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 80042a2:	9305      	str	r3, [sp, #20]
 80042a4:	2301      	movs	r3, #1
 80042a6:	9306      	str	r3, [sp, #24]
 80042a8:	4b08      	ldr	r3, [pc, #32]	@ (80042cc <chInstanceObjectInit+0xbc>)
 80042aa:	9307      	str	r3, [sp, #28]
 80042ac:	2300      	movs	r3, #0
 80042ae:	9308      	str	r3, [sp, #32]
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 80042b0:	ab03      	add	r3, sp, #12
 80042b2:	4618      	mov	r0, r3
 80042b4:	f000 f9bc 	bl	8004630 <chThdCreateI>
  }
#endif
}
 80042b8:	bf00      	nop
 80042ba:	b00b      	add	sp, #44	@ 0x2c
 80042bc:	f85d fb04 	ldr.w	pc, [sp], #4
 80042c0:	200009c4 	.word	0x200009c4
 80042c4:	08005600 	.word	0x08005600
 80042c8:	08005568 	.word	0x08005568
 80042cc:	08004201 	.word	0x08004201

080042d0 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 80042d0:	b082      	sub	sp, #8
 80042d2:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 80042d4:	9b01      	ldr	r3, [sp, #4]
 80042d6:	9a01      	ldr	r2, [sp, #4]
 80042d8:	601a      	str	r2, [r3, #0]
}
 80042da:	bf00      	nop
 80042dc:	b002      	add	sp, #8
 80042de:	4770      	bx	lr

080042e0 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 80042e0:	b082      	sub	sp, #8
 80042e2:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 80042e4:	9b01      	ldr	r3, [sp, #4]
 80042e6:	681b      	ldr	r3, [r3, #0]
 80042e8:	9a01      	ldr	r2, [sp, #4]
 80042ea:	429a      	cmp	r2, r3
 80042ec:	bf14      	ite	ne
 80042ee:	2301      	movne	r3, #1
 80042f0:	2300      	moveq	r3, #0
 80042f2:	b2db      	uxtb	r3, r3
}
 80042f4:	4618      	mov	r0, r3
 80042f6:	b002      	add	sp, #8
 80042f8:	4770      	bx	lr
 80042fa:	bf00      	nop
 80042fc:	0000      	movs	r0, r0
	...

08004300 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 8004300:	b084      	sub	sp, #16
 8004302:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 8004304:	9b01      	ldr	r3, [sp, #4]
 8004306:	681b      	ldr	r3, [r3, #0]
 8004308:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 800430a:	9b03      	ldr	r3, [sp, #12]
 800430c:	681a      	ldr	r2, [r3, #0]
 800430e:	9b01      	ldr	r3, [sp, #4]
 8004310:	601a      	str	r2, [r3, #0]
  return p;
 8004312:	9b03      	ldr	r3, [sp, #12]
}
 8004314:	4618      	mov	r0, r3
 8004316:	b004      	add	sp, #16
 8004318:	4770      	bx	lr
 800431a:	bf00      	nop
 800431c:	0000      	movs	r0, r0
	...

08004320 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004320:	b082      	sub	sp, #8
 8004322:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004324:	9b01      	ldr	r3, [sp, #4]
 8004326:	9a01      	ldr	r2, [sp, #4]
 8004328:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800432a:	9b01      	ldr	r3, [sp, #4]
 800432c:	9a01      	ldr	r2, [sp, #4]
 800432e:	605a      	str	r2, [r3, #4]
}
 8004330:	bf00      	nop
 8004332:	b002      	add	sp, #8
 8004334:	4770      	bx	lr
 8004336:	bf00      	nop
	...

08004340 <ch_queue_notempty.lto_priv.0>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 8004340:	b082      	sub	sp, #8
 8004342:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 8004344:	9b01      	ldr	r3, [sp, #4]
 8004346:	681b      	ldr	r3, [r3, #0]
 8004348:	9a01      	ldr	r2, [sp, #4]
 800434a:	429a      	cmp	r2, r3
 800434c:	bf14      	ite	ne
 800434e:	2301      	movne	r3, #1
 8004350:	2300      	moveq	r3, #0
 8004352:	b2db      	uxtb	r3, r3
}
 8004354:	4618      	mov	r0, r3
 8004356:	b002      	add	sp, #8
 8004358:	4770      	bx	lr
 800435a:	bf00      	nop
 800435c:	0000      	movs	r0, r0
	...

08004360 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8004360:	b082      	sub	sp, #8
 8004362:	9001      	str	r0, [sp, #4]
 8004364:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 8004366:	9b00      	ldr	r3, [sp, #0]
 8004368:	9a01      	ldr	r2, [sp, #4]
 800436a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 800436c:	9b01      	ldr	r3, [sp, #4]
 800436e:	685a      	ldr	r2, [r3, #4]
 8004370:	9b00      	ldr	r3, [sp, #0]
 8004372:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8004374:	9b00      	ldr	r3, [sp, #0]
 8004376:	685b      	ldr	r3, [r3, #4]
 8004378:	9a00      	ldr	r2, [sp, #0]
 800437a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 800437c:	9b01      	ldr	r3, [sp, #4]
 800437e:	9a00      	ldr	r2, [sp, #0]
 8004380:	605a      	str	r2, [r3, #4]
}
 8004382:	bf00      	nop
 8004384:	b002      	add	sp, #8
 8004386:	4770      	bx	lr
	...

08004390 <ch_queue_fifo_remove.lto_priv.0>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 8004390:	b084      	sub	sp, #16
 8004392:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 8004394:	9b01      	ldr	r3, [sp, #4]
 8004396:	681b      	ldr	r3, [r3, #0]
 8004398:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 800439a:	9b03      	ldr	r3, [sp, #12]
 800439c:	681a      	ldr	r2, [r3, #0]
 800439e:	9b01      	ldr	r3, [sp, #4]
 80043a0:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 80043a2:	9b01      	ldr	r3, [sp, #4]
 80043a4:	681b      	ldr	r3, [r3, #0]
 80043a6:	9a01      	ldr	r2, [sp, #4]
 80043a8:	605a      	str	r2, [r3, #4]
  return p;
 80043aa:	9b03      	ldr	r3, [sp, #12]
}
 80043ac:	4618      	mov	r0, r3
 80043ae:	b004      	add	sp, #16
 80043b0:	4770      	bx	lr
 80043b2:	bf00      	nop
	...

080043c0 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80043c0:	b082      	sub	sp, #8
 80043c2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80043c4:	9b01      	ldr	r3, [sp, #4]
 80043c6:	685b      	ldr	r3, [r3, #4]
 80043c8:	9a01      	ldr	r2, [sp, #4]
 80043ca:	6812      	ldr	r2, [r2, #0]
 80043cc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80043ce:	9b01      	ldr	r3, [sp, #4]
 80043d0:	681b      	ldr	r3, [r3, #0]
 80043d2:	9a01      	ldr	r2, [sp, #4]
 80043d4:	6852      	ldr	r2, [r2, #4]
 80043d6:	605a      	str	r2, [r3, #4]
  return p;
 80043d8:	9b01      	ldr	r3, [sp, #4]
}
 80043da:	4618      	mov	r0, r3
 80043dc:	b002      	add	sp, #8
 80043de:	4770      	bx	lr

080043e0 <chSysLock.lto_priv.7>:
static inline void chSysLock(void) {
 80043e0:	b500      	push	{lr}
 80043e2:	b083      	sub	sp, #12
 80043e4:	2330      	movs	r3, #48	@ 0x30
 80043e6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80043e8:	9b01      	ldr	r3, [sp, #4]
 80043ea:	f383 8811 	msr	BASEPRI, r3
}
 80043ee:	bf00      	nop
}
 80043f0:	bf00      	nop
  __dbg_check_lock();
 80043f2:	f7fe ffa5 	bl	8003340 <__dbg_check_lock>
}
 80043f6:	bf00      	nop
 80043f8:	b003      	add	sp, #12
 80043fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80043fe:	bf00      	nop

08004400 <chSysUnlock.lto_priv.7>:
static inline void chSysUnlock(void) {
 8004400:	b500      	push	{lr}
 8004402:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004404:	f7fe ffc4 	bl	8003390 <__dbg_check_unlock>
 8004408:	2300      	movs	r3, #0
 800440a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800440c:	9b01      	ldr	r3, [sp, #4]
 800440e:	f383 8811 	msr	BASEPRI, r3
}
 8004412:	bf00      	nop
}
 8004414:	bf00      	nop
}
 8004416:	bf00      	nop
 8004418:	b003      	add	sp, #12
 800441a:	f85d fb04 	ldr.w	pc, [sp], #4
 800441e:	bf00      	nop

08004420 <chThdGetSelfX.lto_priv.0>:
  return __sch_get_currthread();
 8004420:	4b01      	ldr	r3, [pc, #4]	@ (8004428 <chThdGetSelfX.lto_priv.0+0x8>)
 8004422:	68db      	ldr	r3, [r3, #12]
}
 8004424:	4618      	mov	r0, r3
 8004426:	4770      	bx	lr
 8004428:	200009d0 	.word	0x200009d0
 800442c:	00000000 	.word	0x00000000

08004430 <chThdSleepS>:
static inline void chThdSleepS(sysinterval_t ticks) {
 8004430:	b500      	push	{lr}
 8004432:	b083      	sub	sp, #12
 8004434:	9001      	str	r0, [sp, #4]
  chDbgCheck(ticks != TIME_IMMEDIATE);
 8004436:	9b01      	ldr	r3, [sp, #4]
 8004438:	2b00      	cmp	r3, #0
 800443a:	bf0c      	ite	eq
 800443c:	2301      	moveq	r3, #1
 800443e:	2300      	movne	r3, #0
 8004440:	b2db      	uxtb	r3, r3
 8004442:	2b00      	cmp	r3, #0
 8004444:	d002      	beq.n	800444c <chThdSleepS+0x1c>
 8004446:	4805      	ldr	r0, [pc, #20]	@ (800445c <chThdSleepS+0x2c>)
 8004448:	f7fe ff12 	bl	8003270 <chSysHalt>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800444c:	9901      	ldr	r1, [sp, #4]
 800444e:	2008      	movs	r0, #8
 8004450:	f7ff fd9e 	bl	8003f90 <chSchGoSleepTimeoutS>
}
 8004454:	bf00      	nop
 8004456:	b003      	add	sp, #12
 8004458:	f85d fb04 	ldr.w	pc, [sp], #4
 800445c:	080055f4 	.word	0x080055f4

08004460 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8004460:	b500      	push	{lr}
 8004462:	b085      	sub	sp, #20
 8004464:	9001      	str	r0, [sp, #4]
 8004466:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(ch_queue_notempty(&tqp->queue), "empty queue");

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));
 8004468:	9b01      	ldr	r3, [sp, #4]
 800446a:	4618      	mov	r0, r3
 800446c:	f7ff ff90 	bl	8004390 <ch_queue_fifo_remove.lto_priv.0>
 8004470:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8004472:	9b03      	ldr	r3, [sp, #12]
 8004474:	9a00      	ldr	r2, [sp, #0]
 8004476:	629a      	str	r2, [r3, #40]	@ 0x28
  (void) chSchReadyI(tp);
 8004478:	9803      	ldr	r0, [sp, #12]
 800447a:	f7ff fd41 	bl	8003f00 <chSchReadyI>
}
 800447e:	bf00      	nop
 8004480:	b005      	add	sp, #20
 8004482:	f85d fb04 	ldr.w	pc, [sp], #4
 8004486:	bf00      	nop
	...

08004490 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8004490:	b500      	push	{lr}
 8004492:	b085      	sub	sp, #20
 8004494:	9003      	str	r0, [sp, #12]
 8004496:	9102      	str	r1, [sp, #8]
 8004498:	9201      	str	r2, [sp, #4]
 800449a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 800449c:	9b02      	ldr	r3, [sp, #8]
 800449e:	9a00      	ldr	r2, [sp, #0]
 80044a0:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 80044a2:	9b02      	ldr	r3, [sp, #8]
 80044a4:	2202      	movs	r2, #2
 80044a6:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 80044aa:	9b02      	ldr	r3, [sp, #8]
 80044ac:	2200      	movs	r2, #0
 80044ae:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  tp->owner             = oip;
 80044b2:	9b02      	ldr	r3, [sp, #8]
 80044b4:	9a03      	ldr	r2, [sp, #12]
 80044b6:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 80044b8:	9b02      	ldr	r3, [sp, #8]
 80044ba:	9a00      	ldr	r2, [sp, #0]
 80044bc:	641a      	str	r2, [r3, #64]	@ 0x40
  tp->mtxlist           = NULL;
 80044be:	9b02      	ldr	r3, [sp, #8]
 80044c0:	2200      	movs	r2, #0
 80044c2:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 80044c4:	9b02      	ldr	r3, [sp, #8]
 80044c6:	2200      	movs	r2, #0
 80044c8:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 80044ca:	9b02      	ldr	r3, [sp, #8]
 80044cc:	2201      	movs	r2, #1
 80044ce:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
  tp->name              = name;
 80044d2:	9b02      	ldr	r3, [sp, #8]
 80044d4:	9a01      	ldr	r2, [sp, #4]
 80044d6:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 80044d8:	9b03      	ldr	r3, [sp, #12]
 80044da:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 80044de:	9b02      	ldr	r3, [sp, #8]
 80044e0:	3310      	adds	r3, #16
 80044e2:	4619      	mov	r1, r3
 80044e4:	4610      	mov	r0, r2
 80044e6:	f7ff ff3b 	bl	8004360 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 80044ea:	9b02      	ldr	r3, [sp, #8]
 80044ec:	332c      	adds	r3, #44	@ 0x2c
 80044ee:	4618      	mov	r0, r3
 80044f0:	f7ff feee 	bl	80042d0 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 80044f4:	9b02      	ldr	r3, [sp, #8]
 80044f6:	3330      	adds	r3, #48	@ 0x30
 80044f8:	4618      	mov	r0, r3
 80044fa:	f7ff ff11 	bl	8004320 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 80044fe:	9b02      	ldr	r3, [sp, #8]
}
 8004500:	4618      	mov	r0, r3
 8004502:	b005      	add	sp, #20
 8004504:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004510 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8004510:	b500      	push	{lr}
 8004512:	b085      	sub	sp, #20
 8004514:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8004516:	f7ff f82b 	bl	8003570 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 800451a:	9b01      	ldr	r3, [sp, #4]
 800451c:	2b00      	cmp	r3, #0
 800451e:	bf0c      	ite	eq
 8004520:	2301      	moveq	r3, #1
 8004522:	2300      	movne	r3, #0
 8004524:	b2db      	uxtb	r3, r3
 8004526:	2b00      	cmp	r3, #0
 8004528:	d002      	beq.n	8004530 <chThdCreateSuspendedI+0x20>
 800452a:	483d      	ldr	r0, [pc, #244]	@ (8004620 <chThdCreateSuspendedI+0x110>)
 800452c:	f7fe fea0 	bl	8003270 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8004530:	9b01      	ldr	r3, [sp, #4]
 8004532:	685b      	ldr	r3, [r3, #4]
 8004534:	f003 0307 	and.w	r3, r3, #7
 8004538:	2b00      	cmp	r3, #0
 800453a:	bf14      	ite	ne
 800453c:	2301      	movne	r3, #1
 800453e:	2300      	moveq	r3, #0
 8004540:	b2db      	uxtb	r3, r3
 8004542:	2b00      	cmp	r3, #0
 8004544:	d10a      	bne.n	800455c <chThdCreateSuspendedI+0x4c>
 8004546:	9b01      	ldr	r3, [sp, #4]
 8004548:	689b      	ldr	r3, [r3, #8]
 800454a:	f003 0307 	and.w	r3, r3, #7
 800454e:	2b00      	cmp	r3, #0
 8004550:	bf14      	ite	ne
 8004552:	2301      	movne	r3, #1
 8004554:	2300      	moveq	r3, #0
 8004556:	b2db      	uxtb	r3, r3
 8004558:	2b00      	cmp	r3, #0
 800455a:	d001      	beq.n	8004560 <chThdCreateSuspendedI+0x50>
 800455c:	2301      	movs	r3, #1
 800455e:	e000      	b.n	8004562 <chThdCreateSuspendedI+0x52>
 8004560:	2300      	movs	r3, #0
 8004562:	2b00      	cmp	r3, #0
 8004564:	d10a      	bne.n	800457c <chThdCreateSuspendedI+0x6c>
 8004566:	9b01      	ldr	r3, [sp, #4]
 8004568:	689a      	ldr	r2, [r3, #8]
 800456a:	9b01      	ldr	r3, [sp, #4]
 800456c:	685b      	ldr	r3, [r3, #4]
 800456e:	429a      	cmp	r2, r3
 8004570:	bf94      	ite	ls
 8004572:	2301      	movls	r3, #1
 8004574:	2300      	movhi	r3, #0
 8004576:	b2db      	uxtb	r3, r3
 8004578:	2b00      	cmp	r3, #0
 800457a:	d001      	beq.n	8004580 <chThdCreateSuspendedI+0x70>
 800457c:	2301      	movs	r3, #1
 800457e:	e000      	b.n	8004582 <chThdCreateSuspendedI+0x72>
 8004580:	2300      	movs	r3, #0
 8004582:	2b00      	cmp	r3, #0
 8004584:	d10c      	bne.n	80045a0 <chThdCreateSuspendedI+0x90>
 8004586:	9b01      	ldr	r3, [sp, #4]
 8004588:	689b      	ldr	r3, [r3, #8]
 800458a:	461a      	mov	r2, r3
 800458c:	9b01      	ldr	r3, [sp, #4]
 800458e:	685b      	ldr	r3, [r3, #4]
 8004590:	1ad3      	subs	r3, r2, r3
 8004592:	2bef      	cmp	r3, #239	@ 0xef
 8004594:	bf94      	ite	ls
 8004596:	2301      	movls	r3, #1
 8004598:	2300      	movhi	r3, #0
 800459a:	b2db      	uxtb	r3, r3
 800459c:	2b00      	cmp	r3, #0
 800459e:	d002      	beq.n	80045a6 <chThdCreateSuspendedI+0x96>
 80045a0:	481f      	ldr	r0, [pc, #124]	@ (8004620 <chThdCreateSuspendedI+0x110>)
 80045a2:	f7fe fe65 	bl	8003270 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 80045a6:	9b01      	ldr	r3, [sp, #4]
 80045a8:	68db      	ldr	r3, [r3, #12]
 80045aa:	2bff      	cmp	r3, #255	@ 0xff
 80045ac:	bf8c      	ite	hi
 80045ae:	2301      	movhi	r3, #1
 80045b0:	2300      	movls	r3, #0
 80045b2:	b2db      	uxtb	r3, r3
 80045b4:	2b00      	cmp	r3, #0
 80045b6:	d108      	bne.n	80045ca <chThdCreateSuspendedI+0xba>
 80045b8:	9b01      	ldr	r3, [sp, #4]
 80045ba:	691b      	ldr	r3, [r3, #16]
 80045bc:	2b00      	cmp	r3, #0
 80045be:	bf0c      	ite	eq
 80045c0:	2301      	moveq	r3, #1
 80045c2:	2300      	movne	r3, #0
 80045c4:	b2db      	uxtb	r3, r3
 80045c6:	2b00      	cmp	r3, #0
 80045c8:	d002      	beq.n	80045d0 <chThdCreateSuspendedI+0xc0>
 80045ca:	4815      	ldr	r0, [pc, #84]	@ (8004620 <chThdCreateSuspendedI+0x110>)
 80045cc:	f7fe fe50 	bl	8003270 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 80045d0:	9b01      	ldr	r3, [sp, #4]
 80045d2:	689b      	ldr	r3, [r3, #8]
 80045d4:	3b48      	subs	r3, #72	@ 0x48
 80045d6:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80045d8:	9b01      	ldr	r3, [sp, #4]
 80045da:	685a      	ldr	r2, [r3, #4]
 80045dc:	9b03      	ldr	r3, [sp, #12]
 80045de:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80045e0:	9b03      	ldr	r3, [sp, #12]
 80045e2:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 80045e6:	9b03      	ldr	r3, [sp, #12]
 80045e8:	60da      	str	r2, [r3, #12]
 80045ea:	9b01      	ldr	r3, [sp, #4]
 80045ec:	691a      	ldr	r2, [r3, #16]
 80045ee:	9b03      	ldr	r3, [sp, #12]
 80045f0:	68db      	ldr	r3, [r3, #12]
 80045f2:	601a      	str	r2, [r3, #0]
 80045f4:	9b01      	ldr	r3, [sp, #4]
 80045f6:	695a      	ldr	r2, [r3, #20]
 80045f8:	9b03      	ldr	r3, [sp, #12]
 80045fa:	68db      	ldr	r3, [r3, #12]
 80045fc:	605a      	str	r2, [r3, #4]
 80045fe:	9b03      	ldr	r3, [sp, #12]
 8004600:	68db      	ldr	r3, [r3, #12]
 8004602:	4a08      	ldr	r2, [pc, #32]	@ (8004624 <chThdCreateSuspendedI+0x114>)
 8004604:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8004606:	9b01      	ldr	r3, [sp, #4]
 8004608:	681a      	ldr	r2, [r3, #0]
 800460a:	9b01      	ldr	r3, [sp, #4]
 800460c:	68db      	ldr	r3, [r3, #12]
 800460e:	9903      	ldr	r1, [sp, #12]
 8004610:	4805      	ldr	r0, [pc, #20]	@ (8004628 <chThdCreateSuspendedI+0x118>)
 8004612:	f7ff ff3d 	bl	8004490 <__thd_object_init>
 8004616:	4603      	mov	r3, r0
}
 8004618:	4618      	mov	r0, r3
 800461a:	b005      	add	sp, #20
 800461c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004620:	080055c8 	.word	0x080055c8
 8004624:	08000231 	.word	0x08000231
 8004628:	200009d0 	.word	0x200009d0
 800462c:	00000000 	.word	0x00000000

08004630 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8004630:	b500      	push	{lr}
 8004632:	b083      	sub	sp, #12
 8004634:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8004636:	9801      	ldr	r0, [sp, #4]
 8004638:	f7ff ff6a 	bl	8004510 <chThdCreateSuspendedI>
 800463c:	4603      	mov	r3, r0
 800463e:	4618      	mov	r0, r3
 8004640:	f7ff fc5e 	bl	8003f00 <chSchReadyI>
 8004644:	4603      	mov	r3, r0
}
 8004646:	4618      	mov	r0, r3
 8004648:	b003      	add	sp, #12
 800464a:	f85d fb04 	ldr.w	pc, [sp], #4
 800464e:	bf00      	nop

08004650 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8004650:	b500      	push	{lr}
 8004652:	b087      	sub	sp, #28
 8004654:	9003      	str	r0, [sp, #12]
 8004656:	9102      	str	r1, [sp, #8]
 8004658:	9201      	str	r2, [sp, #4]
 800465a:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 800465c:	9b03      	ldr	r3, [sp, #12]
 800465e:	2b00      	cmp	r3, #0
 8004660:	bf0c      	ite	eq
 8004662:	2301      	moveq	r3, #1
 8004664:	2300      	movne	r3, #0
 8004666:	b2db      	uxtb	r3, r3
 8004668:	2b00      	cmp	r3, #0
 800466a:	d109      	bne.n	8004680 <chThdCreateStatic+0x30>
 800466c:	9b03      	ldr	r3, [sp, #12]
 800466e:	f003 0307 	and.w	r3, r3, #7
 8004672:	2b00      	cmp	r3, #0
 8004674:	bf14      	ite	ne
 8004676:	2301      	movne	r3, #1
 8004678:	2300      	moveq	r3, #0
 800467a:	b2db      	uxtb	r3, r3
 800467c:	2b00      	cmp	r3, #0
 800467e:	d001      	beq.n	8004684 <chThdCreateStatic+0x34>
 8004680:	2301      	movs	r3, #1
 8004682:	e000      	b.n	8004686 <chThdCreateStatic+0x36>
 8004684:	2300      	movs	r3, #0
 8004686:	2b00      	cmp	r3, #0
 8004688:	d107      	bne.n	800469a <chThdCreateStatic+0x4a>
 800468a:	9b02      	ldr	r3, [sp, #8]
 800468c:	2bef      	cmp	r3, #239	@ 0xef
 800468e:	bf94      	ite	ls
 8004690:	2301      	movls	r3, #1
 8004692:	2300      	movhi	r3, #0
 8004694:	b2db      	uxtb	r3, r3
 8004696:	2b00      	cmp	r3, #0
 8004698:	d001      	beq.n	800469e <chThdCreateStatic+0x4e>
 800469a:	2301      	movs	r3, #1
 800469c:	e000      	b.n	80046a0 <chThdCreateStatic+0x50>
 800469e:	2300      	movs	r3, #0
 80046a0:	2b00      	cmp	r3, #0
 80046a2:	d109      	bne.n	80046b8 <chThdCreateStatic+0x68>
 80046a4:	9b02      	ldr	r3, [sp, #8]
 80046a6:	f003 0307 	and.w	r3, r3, #7
 80046aa:	2b00      	cmp	r3, #0
 80046ac:	bf14      	ite	ne
 80046ae:	2301      	movne	r3, #1
 80046b0:	2300      	moveq	r3, #0
 80046b2:	b2db      	uxtb	r3, r3
 80046b4:	2b00      	cmp	r3, #0
 80046b6:	d001      	beq.n	80046bc <chThdCreateStatic+0x6c>
 80046b8:	2301      	movs	r3, #1
 80046ba:	e000      	b.n	80046be <chThdCreateStatic+0x6e>
 80046bc:	2300      	movs	r3, #0
 80046be:	2b00      	cmp	r3, #0
 80046c0:	d107      	bne.n	80046d2 <chThdCreateStatic+0x82>
 80046c2:	9b01      	ldr	r3, [sp, #4]
 80046c4:	2bff      	cmp	r3, #255	@ 0xff
 80046c6:	bf8c      	ite	hi
 80046c8:	2301      	movhi	r3, #1
 80046ca:	2300      	movls	r3, #0
 80046cc:	b2db      	uxtb	r3, r3
 80046ce:	2b00      	cmp	r3, #0
 80046d0:	d001      	beq.n	80046d6 <chThdCreateStatic+0x86>
 80046d2:	2301      	movs	r3, #1
 80046d4:	e000      	b.n	80046d8 <chThdCreateStatic+0x88>
 80046d6:	2300      	movs	r3, #0
 80046d8:	2b00      	cmp	r3, #0
 80046da:	d107      	bne.n	80046ec <chThdCreateStatic+0x9c>
 80046dc:	9b00      	ldr	r3, [sp, #0]
 80046de:	2b00      	cmp	r3, #0
 80046e0:	bf0c      	ite	eq
 80046e2:	2301      	moveq	r3, #1
 80046e4:	2300      	movne	r3, #0
 80046e6:	b2db      	uxtb	r3, r3
 80046e8:	2b00      	cmp	r3, #0
 80046ea:	d002      	beq.n	80046f2 <chThdCreateStatic+0xa2>
 80046ec:	4817      	ldr	r0, [pc, #92]	@ (800474c <chThdCreateStatic+0xfc>)
 80046ee:	f7fe fdbf 	bl	8003270 <chSysHalt>

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wsp, (uint8_t *)wsp + size);
#endif

  chSysLock();
 80046f2:	f7ff fe75 	bl	80043e0 <chSysLock.lto_priv.7>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 80046f6:	9b02      	ldr	r3, [sp, #8]
 80046f8:	3b48      	subs	r3, #72	@ 0x48
 80046fa:	9a03      	ldr	r2, [sp, #12]
 80046fc:	4413      	add	r3, r2
 80046fe:	9305      	str	r3, [sp, #20]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8004700:	9b05      	ldr	r3, [sp, #20]
 8004702:	9a03      	ldr	r2, [sp, #12]
 8004704:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8004706:	9b05      	ldr	r3, [sp, #20]
 8004708:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 800470c:	9b05      	ldr	r3, [sp, #20]
 800470e:	60da      	str	r2, [r3, #12]
 8004710:	9b05      	ldr	r3, [sp, #20]
 8004712:	68db      	ldr	r3, [r3, #12]
 8004714:	9a00      	ldr	r2, [sp, #0]
 8004716:	601a      	str	r2, [r3, #0]
 8004718:	9b05      	ldr	r3, [sp, #20]
 800471a:	68db      	ldr	r3, [r3, #12]
 800471c:	9a08      	ldr	r2, [sp, #32]
 800471e:	605a      	str	r2, [r3, #4]
 8004720:	9b05      	ldr	r3, [sp, #20]
 8004722:	68db      	ldr	r3, [r3, #12]
 8004724:	4a0a      	ldr	r2, [pc, #40]	@ (8004750 <chThdCreateStatic+0x100>)
 8004726:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 8004728:	9b01      	ldr	r3, [sp, #4]
 800472a:	4a0a      	ldr	r2, [pc, #40]	@ (8004754 <chThdCreateStatic+0x104>)
 800472c:	9905      	ldr	r1, [sp, #20]
 800472e:	480a      	ldr	r0, [pc, #40]	@ (8004758 <chThdCreateStatic+0x108>)
 8004730:	f7ff feae 	bl	8004490 <__thd_object_init>
 8004734:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8004736:	2100      	movs	r1, #0
 8004738:	9805      	ldr	r0, [sp, #20]
 800473a:	f7ff fc61 	bl	8004000 <chSchWakeupS>
  chSysUnlock();
 800473e:	f7ff fe5f 	bl	8004400 <chSysUnlock.lto_priv.7>

  return tp;
 8004742:	9b05      	ldr	r3, [sp, #20]
}
 8004744:	4618      	mov	r0, r3
 8004746:	b007      	add	sp, #28
 8004748:	f85d fb04 	ldr.w	pc, [sp], #4
 800474c:	080055e0 	.word	0x080055e0
 8004750:	08000231 	.word	0x08000231
 8004754:	08005570 	.word	0x08005570
 8004758:	200009d0 	.word	0x200009d0
 800475c:	00000000 	.word	0x00000000

08004760 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8004760:	b500      	push	{lr}
 8004762:	b083      	sub	sp, #12
 8004764:	9001      	str	r0, [sp, #4]

  chSysLock();
 8004766:	f7ff fe3b 	bl	80043e0 <chSysLock.lto_priv.7>
  chThdExitS(msg);
 800476a:	9801      	ldr	r0, [sp, #4]
 800476c:	f000 f808 	bl	8004780 <chThdExitS>
  /* The thread never returns here.*/
}
 8004770:	bf00      	nop
 8004772:	b003      	add	sp, #12
 8004774:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004780 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8004780:	b500      	push	{lr}
 8004782:	b085      	sub	sp, #20
 8004784:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004786:	f7ff fe4b 	bl	8004420 <chThdGetSelfX.lto_priv.0>
 800478a:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 800478c:	9b03      	ldr	r3, [sp, #12]
 800478e:	9a01      	ldr	r2, [sp, #4]
 8004790:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8004792:	e008      	b.n	80047a6 <chThdExitS+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8004794:	9b03      	ldr	r3, [sp, #12]
 8004796:	332c      	adds	r3, #44	@ 0x2c
 8004798:	4618      	mov	r0, r3
 800479a:	f7ff fdb1 	bl	8004300 <ch_list_unlink>
 800479e:	4603      	mov	r3, r0
 80047a0:	4618      	mov	r0, r3
 80047a2:	f7ff fbad 	bl	8003f00 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80047a6:	9b03      	ldr	r3, [sp, #12]
 80047a8:	332c      	adds	r3, #44	@ 0x2c
 80047aa:	4618      	mov	r0, r3
 80047ac:	f7ff fd98 	bl	80042e0 <ch_list_notempty>
 80047b0:	4603      	mov	r3, r0
 80047b2:	2b00      	cmp	r3, #0
 80047b4:	d1ee      	bne.n	8004794 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 80047b6:	9b03      	ldr	r3, [sp, #12]
 80047b8:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 80047bc:	2b00      	cmp	r3, #0
 80047be:	bf0c      	ite	eq
 80047c0:	2301      	moveq	r3, #1
 80047c2:	2300      	movne	r3, #0
 80047c4:	b2db      	uxtb	r3, r3
 80047c6:	2b00      	cmp	r3, #0
 80047c8:	d010      	beq.n	80047ec <chThdExitS+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 80047ca:	9b03      	ldr	r3, [sp, #12]
 80047cc:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 80047d0:	f003 0303 	and.w	r3, r3, #3
 80047d4:	2b00      	cmp	r3, #0
 80047d6:	bf0c      	ite	eq
 80047d8:	2301      	moveq	r3, #1
 80047da:	2300      	movne	r3, #0
 80047dc:	b2db      	uxtb	r3, r3
 80047de:	2b00      	cmp	r3, #0
 80047e0:	d004      	beq.n	80047ec <chThdExitS+0x6c>
      REG_REMOVE(currtp);
 80047e2:	9b03      	ldr	r3, [sp, #12]
 80047e4:	3310      	adds	r3, #16
 80047e6:	4618      	mov	r0, r3
 80047e8:	f7ff fdea 	bl	80043c0 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80047ec:	200f      	movs	r0, #15
 80047ee:	f7ff fba7 	bl	8003f40 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80047f2:	bf00      	nop
 80047f4:	b005      	add	sp, #20
 80047f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80047fa:	bf00      	nop
 80047fc:	0000      	movs	r0, r0
	...

08004800 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8004800:	b500      	push	{lr}
 8004802:	b083      	sub	sp, #12
 8004804:	9001      	str	r0, [sp, #4]

  chSysLock();
 8004806:	f7ff fdeb 	bl	80043e0 <chSysLock.lto_priv.7>
  chThdSleepS(time);
 800480a:	9801      	ldr	r0, [sp, #4]
 800480c:	f7ff fe10 	bl	8004430 <chThdSleepS>
  chSysUnlock();
 8004810:	f7ff fdf6 	bl	8004400 <chSysUnlock.lto_priv.7>
}
 8004814:	bf00      	nop
 8004816:	b003      	add	sp, #12
 8004818:	f85d fb04 	ldr.w	pc, [sp], #4
 800481c:	0000      	movs	r0, r0
	...

08004820 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8004820:	b500      	push	{lr}
 8004822:	b085      	sub	sp, #20
 8004824:	9001      	str	r0, [sp, #4]
 8004826:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8004828:	f7ff fdfa 	bl	8004420 <chThdGetSelfX.lto_priv.0>
 800482c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 800482e:	9b00      	ldr	r3, [sp, #0]
 8004830:	2b00      	cmp	r3, #0
 8004832:	bf0c      	ite	eq
 8004834:	2301      	moveq	r3, #1
 8004836:	2300      	movne	r3, #0
 8004838:	b2db      	uxtb	r3, r3
 800483a:	2b00      	cmp	r3, #0
 800483c:	d002      	beq.n	8004844 <chThdSuspendTimeoutS+0x24>
    return MSG_TIMEOUT;
 800483e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8004842:	e00a      	b.n	800485a <chThdSuspendTimeoutS+0x3a>
  }

  *trp = tp;
 8004844:	9b01      	ldr	r3, [sp, #4]
 8004846:	9a03      	ldr	r2, [sp, #12]
 8004848:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 800484a:	9b03      	ldr	r3, [sp, #12]
 800484c:	9a01      	ldr	r2, [sp, #4]
 800484e:	629a      	str	r2, [r3, #40]	@ 0x28

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8004850:	9900      	ldr	r1, [sp, #0]
 8004852:	2003      	movs	r0, #3
 8004854:	f7ff fb9c 	bl	8003f90 <chSchGoSleepTimeoutS>
 8004858:	4603      	mov	r3, r0
}
 800485a:	4618      	mov	r0, r3
 800485c:	b005      	add	sp, #20
 800485e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004862:	bf00      	nop
	...

08004870 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8004870:	b500      	push	{lr}
 8004872:	b085      	sub	sp, #20
 8004874:	9001      	str	r0, [sp, #4]
 8004876:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8004878:	9b01      	ldr	r3, [sp, #4]
 800487a:	681b      	ldr	r3, [r3, #0]
 800487c:	2b00      	cmp	r3, #0
 800487e:	d00b      	beq.n	8004898 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 8004880:	9b01      	ldr	r3, [sp, #4]
 8004882:	681b      	ldr	r3, [r3, #0]
 8004884:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8004886:	9b01      	ldr	r3, [sp, #4]
 8004888:	2200      	movs	r2, #0
 800488a:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800488c:	9b03      	ldr	r3, [sp, #12]
 800488e:	9a00      	ldr	r2, [sp, #0]
 8004890:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 8004892:	9803      	ldr	r0, [sp, #12]
 8004894:	f7ff fb34 	bl	8003f00 <chSchReadyI>
  }
}
 8004898:	bf00      	nop
 800489a:	b005      	add	sp, #20
 800489c:	f85d fb04 	ldr.w	pc, [sp], #4

080048a0 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 80048a0:	b500      	push	{lr}
 80048a2:	b085      	sub	sp, #20
 80048a4:	9001      	str	r0, [sp, #4]
 80048a6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80048a8:	9b01      	ldr	r3, [sp, #4]
 80048aa:	681b      	ldr	r3, [r3, #0]
 80048ac:	2b00      	cmp	r3, #0
 80048ae:	d009      	beq.n	80048c4 <chThdResumeS+0x24>
    thread_t *tp = *trp;
 80048b0:	9b01      	ldr	r3, [sp, #4]
 80048b2:	681b      	ldr	r3, [r3, #0]
 80048b4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 80048b6:	9b01      	ldr	r3, [sp, #4]
 80048b8:	2200      	movs	r2, #0
 80048ba:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 80048bc:	9900      	ldr	r1, [sp, #0]
 80048be:	9803      	ldr	r0, [sp, #12]
 80048c0:	f7ff fb9e 	bl	8004000 <chSchWakeupS>
  }
}
 80048c4:	bf00      	nop
 80048c6:	b005      	add	sp, #20
 80048c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80048cc:	0000      	movs	r0, r0
	...

080048d0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 80048d0:	b500      	push	{lr}
 80048d2:	b085      	sub	sp, #20
 80048d4:	9001      	str	r0, [sp, #4]
 80048d6:	9100      	str	r1, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
 80048d8:	f7ff fda2 	bl	8004420 <chThdGetSelfX.lto_priv.0>
 80048dc:	9003      	str	r0, [sp, #12]

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 80048de:	9b00      	ldr	r3, [sp, #0]
 80048e0:	2b00      	cmp	r3, #0
 80048e2:	bf0c      	ite	eq
 80048e4:	2301      	moveq	r3, #1
 80048e6:	2300      	movne	r3, #0
 80048e8:	b2db      	uxtb	r3, r3
 80048ea:	2b00      	cmp	r3, #0
 80048ec:	d002      	beq.n	80048f4 <chThdEnqueueTimeoutS+0x24>
    return MSG_TIMEOUT;
 80048ee:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80048f2:	e009      	b.n	8004908 <chThdEnqueueTimeoutS+0x38>
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);
 80048f4:	9b01      	ldr	r3, [sp, #4]
 80048f6:	9903      	ldr	r1, [sp, #12]
 80048f8:	4618      	mov	r0, r3
 80048fa:	f7ff fd31 	bl	8004360 <ch_queue_insert.lto_priv.0>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80048fe:	9900      	ldr	r1, [sp, #0]
 8004900:	2004      	movs	r0, #4
 8004902:	f7ff fb45 	bl	8003f90 <chSchGoSleepTimeoutS>
 8004906:	4603      	mov	r3, r0
}
 8004908:	4618      	mov	r0, r3
 800490a:	b005      	add	sp, #20
 800490c:	f85d fb04 	ldr.w	pc, [sp], #4

08004910 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8004910:	b500      	push	{lr}
 8004912:	b083      	sub	sp, #12
 8004914:	9001      	str	r0, [sp, #4]
 8004916:	9100      	str	r1, [sp, #0]

  if (ch_queue_notempty(&tqp->queue)) {
 8004918:	9b01      	ldr	r3, [sp, #4]
 800491a:	4618      	mov	r0, r3
 800491c:	f7ff fd10 	bl	8004340 <ch_queue_notempty.lto_priv.0>
 8004920:	4603      	mov	r3, r0
 8004922:	2b00      	cmp	r3, #0
 8004924:	d003      	beq.n	800492e <chThdDequeueNextI+0x1e>
    chThdDoDequeueNextI(tqp, msg);
 8004926:	9900      	ldr	r1, [sp, #0]
 8004928:	9801      	ldr	r0, [sp, #4]
 800492a:	f7ff fd99 	bl	8004460 <chThdDoDequeueNextI>
  }
}
 800492e:	bf00      	nop
 8004930:	b003      	add	sp, #12
 8004932:	f85d fb04 	ldr.w	pc, [sp], #4
 8004936:	bf00      	nop
	...

08004940 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8004940:	b4f0      	push	{r4, r5, r6, r7}
 8004942:	b084      	sub	sp, #16
 8004944:	9003      	str	r0, [sp, #12]
 8004946:	9102      	str	r1, [sp, #8]
 8004948:	9201      	str	r2, [sp, #4]

  tmp->n++;
 800494a:	9b03      	ldr	r3, [sp, #12]
 800494c:	68db      	ldr	r3, [r3, #12]
 800494e:	1c5a      	adds	r2, r3, #1
 8004950:	9b03      	ldr	r3, [sp, #12]
 8004952:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8004954:	9b03      	ldr	r3, [sp, #12]
 8004956:	689b      	ldr	r3, [r3, #8]
 8004958:	9a02      	ldr	r2, [sp, #8]
 800495a:	1ad2      	subs	r2, r2, r3
 800495c:	9b01      	ldr	r3, [sp, #4]
 800495e:	1ad2      	subs	r2, r2, r3
 8004960:	9b03      	ldr	r3, [sp, #12]
 8004962:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8004964:	9b03      	ldr	r3, [sp, #12]
 8004966:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800496a:	9903      	ldr	r1, [sp, #12]
 800496c:	6889      	ldr	r1, [r1, #8]
 800496e:	2000      	movs	r0, #0
 8004970:	460c      	mov	r4, r1
 8004972:	4605      	mov	r5, r0
 8004974:	1916      	adds	r6, r2, r4
 8004976:	eb43 0705 	adc.w	r7, r3, r5
 800497a:	9b03      	ldr	r3, [sp, #12]
 800497c:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
 8004980:	9b03      	ldr	r3, [sp, #12]
 8004982:	689a      	ldr	r2, [r3, #8]
 8004984:	9b03      	ldr	r3, [sp, #12]
 8004986:	685b      	ldr	r3, [r3, #4]
 8004988:	429a      	cmp	r2, r3
 800498a:	d903      	bls.n	8004994 <tm_stop+0x54>
    tmp->worst = tmp->last;
 800498c:	9b03      	ldr	r3, [sp, #12]
 800498e:	689a      	ldr	r2, [r3, #8]
 8004990:	9b03      	ldr	r3, [sp, #12]
 8004992:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8004994:	9b03      	ldr	r3, [sp, #12]
 8004996:	689a      	ldr	r2, [r3, #8]
 8004998:	9b03      	ldr	r3, [sp, #12]
 800499a:	681b      	ldr	r3, [r3, #0]
 800499c:	429a      	cmp	r2, r3
 800499e:	d203      	bcs.n	80049a8 <tm_stop+0x68>
    tmp->best = tmp->last;
 80049a0:	9b03      	ldr	r3, [sp, #12]
 80049a2:	689a      	ldr	r2, [r3, #8]
 80049a4:	9b03      	ldr	r3, [sp, #12]
 80049a6:	601a      	str	r2, [r3, #0]
  }
}
 80049a8:	bf00      	nop
 80049aa:	b004      	add	sp, #16
 80049ac:	bcf0      	pop	{r4, r5, r6, r7}
 80049ae:	4770      	bx	lr

080049b0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80049b0:	b082      	sub	sp, #8
 80049b2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80049b4:	9b01      	ldr	r3, [sp, #4]
 80049b6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80049ba:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80049bc:	9b01      	ldr	r3, [sp, #4]
 80049be:	2200      	movs	r2, #0
 80049c0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80049c2:	9b01      	ldr	r3, [sp, #4]
 80049c4:	2200      	movs	r2, #0
 80049c6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80049c8:	9b01      	ldr	r3, [sp, #4]
 80049ca:	2200      	movs	r2, #0
 80049cc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80049ce:	9901      	ldr	r1, [sp, #4]
 80049d0:	f04f 0200 	mov.w	r2, #0
 80049d4:	f04f 0300 	mov.w	r3, #0
 80049d8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 80049dc:	bf00      	nop
 80049de:	b002      	add	sp, #8
 80049e0:	4770      	bx	lr
 80049e2:	bf00      	nop
	...

080049f0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80049f0:	b082      	sub	sp, #8
 80049f2:	9001      	str	r0, [sp, #4]
  return DWT->CYCCNT;
 80049f4:	4b03      	ldr	r3, [pc, #12]	@ (8004a04 <chTMStartMeasurementX+0x14>)
 80049f6:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80049f8:	9b01      	ldr	r3, [sp, #4]
 80049fa:	609a      	str	r2, [r3, #8]
}
 80049fc:	bf00      	nop
 80049fe:	b002      	add	sp, #8
 8004a00:	4770      	bx	lr
 8004a02:	bf00      	nop
 8004a04:	e0001000 	.word	0xe0001000
	...

08004a10 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8004a10:	b500      	push	{lr}
 8004a12:	b083      	sub	sp, #12
 8004a14:	9001      	str	r0, [sp, #4]
 8004a16:	4b06      	ldr	r3, [pc, #24]	@ (8004a30 <chTMStopMeasurementX+0x20>)
 8004a18:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8004a1a:	4a06      	ldr	r2, [pc, #24]	@ (8004a34 <chTMStopMeasurementX+0x24>)
 8004a1c:	6892      	ldr	r2, [r2, #8]
 8004a1e:	4619      	mov	r1, r3
 8004a20:	9801      	ldr	r0, [sp, #4]
 8004a22:	f7ff ff8d 	bl	8004940 <tm_stop>
}
 8004a26:	bf00      	nop
 8004a28:	b003      	add	sp, #12
 8004a2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a2e:	bf00      	nop
 8004a30:	e0001000 	.word	0xe0001000
 8004a34:	200009c4 	.word	0x200009c4
	...

08004a40 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004a40:	b082      	sub	sp, #8
 8004a42:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004a44:	9b01      	ldr	r3, [sp, #4]
 8004a46:	9a01      	ldr	r2, [sp, #4]
 8004a48:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8004a4a:	9b01      	ldr	r3, [sp, #4]
 8004a4c:	9a01      	ldr	r2, [sp, #4]
 8004a4e:	605a      	str	r2, [r3, #4]
}
 8004a50:	bf00      	nop
 8004a52:	b002      	add	sp, #8
 8004a54:	4770      	bx	lr
 8004a56:	bf00      	nop
	...

08004a60 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8004a60:	b500      	push	{lr}
 8004a62:	b083      	sub	sp, #12
 8004a64:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8004a66:	9b01      	ldr	r3, [sp, #4]
 8004a68:	2b00      	cmp	r3, #0
 8004a6a:	bf0c      	ite	eq
 8004a6c:	2301      	moveq	r3, #1
 8004a6e:	2300      	movne	r3, #0
 8004a70:	b2db      	uxtb	r3, r3
 8004a72:	2b00      	cmp	r3, #0
 8004a74:	d002      	beq.n	8004a7c <chMtxObjectInit+0x1c>
 8004a76:	4807      	ldr	r0, [pc, #28]	@ (8004a94 <chMtxObjectInit+0x34>)
 8004a78:	f7fe fbfa 	bl	8003270 <chSysHalt>

  ch_queue_init(&mp->queue);
 8004a7c:	9b01      	ldr	r3, [sp, #4]
 8004a7e:	4618      	mov	r0, r3
 8004a80:	f7ff ffde 	bl	8004a40 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 8004a84:	9b01      	ldr	r3, [sp, #4]
 8004a86:	2200      	movs	r2, #0
 8004a88:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8004a8a:	bf00      	nop
 8004a8c:	b003      	add	sp, #12
 8004a8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a92:	bf00      	nop
 8004a94:	0800562c 	.word	0x0800562c
	...

08004aa0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8004aa0:	b500      	push	{lr}
 8004aa2:	b083      	sub	sp, #12
 8004aa4:	9001      	str	r0, [sp, #4]
 8004aa6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8004aa8:	f7fe fd62 	bl	8003570 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8004aac:	9b01      	ldr	r3, [sp, #4]
 8004aae:	2b00      	cmp	r3, #0
 8004ab0:	bf0c      	ite	eq
 8004ab2:	2301      	moveq	r3, #1
 8004ab4:	2300      	movne	r3, #0
 8004ab6:	b2db      	uxtb	r3, r3
 8004ab8:	2b00      	cmp	r3, #0
 8004aba:	d002      	beq.n	8004ac2 <chEvtSignalI+0x22>
 8004abc:	4816      	ldr	r0, [pc, #88]	@ (8004b18 <chEvtSignalI+0x78>)
 8004abe:	f7fe fbd7 	bl	8003270 <chSysHalt>

  tp->epending |= events;
 8004ac2:	9b01      	ldr	r3, [sp, #4]
 8004ac4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8004ac6:	9b00      	ldr	r3, [sp, #0]
 8004ac8:	431a      	orrs	r2, r3
 8004aca:	9b01      	ldr	r3, [sp, #4]
 8004acc:	639a      	str	r2, [r3, #56]	@ 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004ace:	9b01      	ldr	r3, [sp, #4]
 8004ad0:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004ad4:	2b0a      	cmp	r3, #10
 8004ad6:	d106      	bne.n	8004ae6 <chEvtSignalI+0x46>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8004ad8:	9b01      	ldr	r3, [sp, #4]
 8004ada:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8004adc:	9b01      	ldr	r3, [sp, #4]
 8004ade:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004ae0:	4013      	ands	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004ae2:	2b00      	cmp	r3, #0
 8004ae4:	d10d      	bne.n	8004b02 <chEvtSignalI+0x62>
      ((tp->state == CH_STATE_WTANDEVT) &&
 8004ae6:	9b01      	ldr	r3, [sp, #4]
 8004ae8:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8004aec:	2b0b      	cmp	r3, #11
 8004aee:	d10e      	bne.n	8004b0e <chEvtSignalI+0x6e>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8004af0:	9b01      	ldr	r3, [sp, #4]
 8004af2:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8004af4:	9b01      	ldr	r3, [sp, #4]
 8004af6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004af8:	401a      	ands	r2, r3
 8004afa:	9b01      	ldr	r3, [sp, #4]
 8004afc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
      ((tp->state == CH_STATE_WTANDEVT) &&
 8004afe:	429a      	cmp	r2, r3
 8004b00:	d105      	bne.n	8004b0e <chEvtSignalI+0x6e>
    tp->u.rdymsg = MSG_OK;
 8004b02:	9b01      	ldr	r3, [sp, #4]
 8004b04:	2200      	movs	r2, #0
 8004b06:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 8004b08:	9801      	ldr	r0, [sp, #4]
 8004b0a:	f7ff f9f9 	bl	8003f00 <chSchReadyI>
  }
}
 8004b0e:	bf00      	nop
 8004b10:	b003      	add	sp, #12
 8004b12:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b16:	bf00      	nop
 8004b18:	0800563c 	.word	0x0800563c
 8004b1c:	00000000 	.word	0x00000000

08004b20 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8004b20:	b500      	push	{lr}
 8004b22:	b085      	sub	sp, #20
 8004b24:	9001      	str	r0, [sp, #4]
 8004b26:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 8004b28:	f7fe fd22 	bl	8003570 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8004b2c:	9b01      	ldr	r3, [sp, #4]
 8004b2e:	2b00      	cmp	r3, #0
 8004b30:	bf0c      	ite	eq
 8004b32:	2301      	moveq	r3, #1
 8004b34:	2300      	movne	r3, #0
 8004b36:	b2db      	uxtb	r3, r3
 8004b38:	2b00      	cmp	r3, #0
 8004b3a:	d002      	beq.n	8004b42 <chEvtBroadcastFlagsI+0x22>
 8004b3c:	4814      	ldr	r0, [pc, #80]	@ (8004b90 <chEvtBroadcastFlagsI+0x70>)
 8004b3e:	f7fe fb97 	bl	8003270 <chSysHalt>

  elp = esp->next;
 8004b42:	9b01      	ldr	r3, [sp, #4]
 8004b44:	681b      	ldr	r3, [r3, #0]
 8004b46:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8004b48:	e019      	b.n	8004b7e <chEvtBroadcastFlagsI+0x5e>
  /*lint -restore*/
    elp->flags |= flags;
 8004b4a:	9b03      	ldr	r3, [sp, #12]
 8004b4c:	68da      	ldr	r2, [r3, #12]
 8004b4e:	9b00      	ldr	r3, [sp, #0]
 8004b50:	431a      	orrs	r2, r3
 8004b52:	9b03      	ldr	r3, [sp, #12]
 8004b54:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8004b56:	9b00      	ldr	r3, [sp, #0]
 8004b58:	2b00      	cmp	r3, #0
 8004b5a:	d005      	beq.n	8004b68 <chEvtBroadcastFlagsI+0x48>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8004b5c:	9b03      	ldr	r3, [sp, #12]
 8004b5e:	691a      	ldr	r2, [r3, #16]
 8004b60:	9b00      	ldr	r3, [sp, #0]
 8004b62:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
 8004b64:	2b00      	cmp	r3, #0
 8004b66:	d007      	beq.n	8004b78 <chEvtBroadcastFlagsI+0x58>
      chEvtSignalI(elp->listener, elp->events);
 8004b68:	9b03      	ldr	r3, [sp, #12]
 8004b6a:	685a      	ldr	r2, [r3, #4]
 8004b6c:	9b03      	ldr	r3, [sp, #12]
 8004b6e:	689b      	ldr	r3, [r3, #8]
 8004b70:	4619      	mov	r1, r3
 8004b72:	4610      	mov	r0, r2
 8004b74:	f7ff ff94 	bl	8004aa0 <chEvtSignalI>
    }
    elp = elp->next;
 8004b78:	9b03      	ldr	r3, [sp, #12]
 8004b7a:	681b      	ldr	r3, [r3, #0]
 8004b7c:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
 8004b7e:	9a03      	ldr	r2, [sp, #12]
 8004b80:	9b01      	ldr	r3, [sp, #4]
 8004b82:	429a      	cmp	r2, r3
 8004b84:	d1e1      	bne.n	8004b4a <chEvtBroadcastFlagsI+0x2a>
  }
}
 8004b86:	bf00      	nop
 8004b88:	bf00      	nop
 8004b8a:	b005      	add	sp, #20
 8004b8c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b90:	0800564c 	.word	0x0800564c
	...

08004ba0 <chSysLock.lto_priv.16>:
static inline void chSysLock(void) {
 8004ba0:	b500      	push	{lr}
 8004ba2:	b083      	sub	sp, #12
 8004ba4:	2330      	movs	r3, #48	@ 0x30
 8004ba6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004ba8:	9b01      	ldr	r3, [sp, #4]
 8004baa:	f383 8811 	msr	BASEPRI, r3
}
 8004bae:	bf00      	nop
}
 8004bb0:	bf00      	nop
  __dbg_check_lock();
 8004bb2:	f7fe fbc5 	bl	8003340 <__dbg_check_lock>
}
 8004bb6:	bf00      	nop
 8004bb8:	b003      	add	sp, #12
 8004bba:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bbe:	bf00      	nop

08004bc0 <chSysUnlock.lto_priv.16>:
static inline void chSysUnlock(void) {
 8004bc0:	b500      	push	{lr}
 8004bc2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8004bc4:	f7fe fbe4 	bl	8003390 <__dbg_check_unlock>
 8004bc8:	2300      	movs	r3, #0
 8004bca:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004bcc:	9b01      	ldr	r3, [sp, #4]
 8004bce:	f383 8811 	msr	BASEPRI, r3
}
 8004bd2:	bf00      	nop
}
 8004bd4:	bf00      	nop
}
 8004bd6:	bf00      	nop
 8004bd8:	b003      	add	sp, #12
 8004bda:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bde:	bf00      	nop

08004be0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8004be0:	4b03      	ldr	r3, [pc, #12]	@ (8004bf0 <__core_init+0x10>)
 8004be2:	4a04      	ldr	r2, [pc, #16]	@ (8004bf4 <__core_init+0x14>)
 8004be4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 8004be6:	4b02      	ldr	r3, [pc, #8]	@ (8004bf0 <__core_init+0x10>)
 8004be8:	4a03      	ldr	r2, [pc, #12]	@ (8004bf8 <__core_init+0x18>)
 8004bea:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8004bec:	bf00      	nop
 8004bee:	4770      	bx	lr
 8004bf0:	20000b90 	.word	0x20000b90
 8004bf4:	20000e80 	.word	0x20000e80
 8004bf8:	20030000 	.word	0x20030000
 8004bfc:	00000000 	.word	0x00000000

08004c00 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8004c00:	b500      	push	{lr}
 8004c02:	b087      	sub	sp, #28
 8004c04:	9003      	str	r0, [sp, #12]
 8004c06:	9102      	str	r1, [sp, #8]
 8004c08:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 8004c0a:	f7fe fcb1 	bl	8003570 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8004c0e:	9b02      	ldr	r3, [sp, #8]
 8004c10:	2b00      	cmp	r3, #0
 8004c12:	bf0c      	ite	eq
 8004c14:	2301      	moveq	r3, #1
 8004c16:	2300      	movne	r3, #0
 8004c18:	b2db      	uxtb	r3, r3
 8004c1a:	2b00      	cmp	r3, #0
 8004c1c:	d10a      	bne.n	8004c34 <chCoreAllocFromTopI+0x34>
 8004c1e:	9b02      	ldr	r3, [sp, #8]
 8004c20:	1e5a      	subs	r2, r3, #1
 8004c22:	9b02      	ldr	r3, [sp, #8]
 8004c24:	4013      	ands	r3, r2
 8004c26:	2b00      	cmp	r3, #0
 8004c28:	bf14      	ite	ne
 8004c2a:	2301      	movne	r3, #1
 8004c2c:	2300      	moveq	r3, #0
 8004c2e:	b2db      	uxtb	r3, r3
 8004c30:	2b00      	cmp	r3, #0
 8004c32:	d002      	beq.n	8004c3a <chCoreAllocFromTopI+0x3a>
 8004c34:	4812      	ldr	r0, [pc, #72]	@ (8004c80 <chCoreAllocFromTopI+0x80>)
 8004c36:	f7fe fb1b 	bl	8003270 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8004c3a:	4b12      	ldr	r3, [pc, #72]	@ (8004c84 <chCoreAllocFromTopI+0x84>)
 8004c3c:	685a      	ldr	r2, [r3, #4]
 8004c3e:	9b03      	ldr	r3, [sp, #12]
 8004c40:	425b      	negs	r3, r3
 8004c42:	4413      	add	r3, r2
 8004c44:	461a      	mov	r2, r3
 8004c46:	9b02      	ldr	r3, [sp, #8]
 8004c48:	425b      	negs	r3, r3
 8004c4a:	4013      	ands	r3, r2
 8004c4c:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 8004c4e:	9b01      	ldr	r3, [sp, #4]
 8004c50:	425b      	negs	r3, r3
 8004c52:	9a05      	ldr	r2, [sp, #20]
 8004c54:	4413      	add	r3, r2
 8004c56:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8004c58:	4b0a      	ldr	r3, [pc, #40]	@ (8004c84 <chCoreAllocFromTopI+0x84>)
 8004c5a:	681b      	ldr	r3, [r3, #0]
 8004c5c:	9a04      	ldr	r2, [sp, #16]
 8004c5e:	429a      	cmp	r2, r3
 8004c60:	d304      	bcc.n	8004c6c <chCoreAllocFromTopI+0x6c>
 8004c62:	4b08      	ldr	r3, [pc, #32]	@ (8004c84 <chCoreAllocFromTopI+0x84>)
 8004c64:	685b      	ldr	r3, [r3, #4]
 8004c66:	9a04      	ldr	r2, [sp, #16]
 8004c68:	429a      	cmp	r2, r3
 8004c6a:	d901      	bls.n	8004c70 <chCoreAllocFromTopI+0x70>
    return NULL;
 8004c6c:	2300      	movs	r3, #0
 8004c6e:	e003      	b.n	8004c78 <chCoreAllocFromTopI+0x78>
  }

  ch_memcore.topmem = prev;
 8004c70:	4a04      	ldr	r2, [pc, #16]	@ (8004c84 <chCoreAllocFromTopI+0x84>)
 8004c72:	9b04      	ldr	r3, [sp, #16]
 8004c74:	6053      	str	r3, [r2, #4]

  return p;
 8004c76:	9b05      	ldr	r3, [sp, #20]
}
 8004c78:	4618      	mov	r0, r3
 8004c7a:	b007      	add	sp, #28
 8004c7c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c80:	08005664 	.word	0x08005664
 8004c84:	20000b90 	.word	0x20000b90
	...

08004c90 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8004c90:	b500      	push	{lr}
 8004c92:	b087      	sub	sp, #28
 8004c94:	9003      	str	r0, [sp, #12]
 8004c96:	9102      	str	r1, [sp, #8]
 8004c98:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 8004c9a:	f7ff ff81 	bl	8004ba0 <chSysLock.lto_priv.16>
  p = chCoreAllocFromTopI(size, align, offset);
 8004c9e:	9a01      	ldr	r2, [sp, #4]
 8004ca0:	9902      	ldr	r1, [sp, #8]
 8004ca2:	9803      	ldr	r0, [sp, #12]
 8004ca4:	f7ff ffac 	bl	8004c00 <chCoreAllocFromTopI>
 8004ca8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8004caa:	f7ff ff89 	bl	8004bc0 <chSysUnlock.lto_priv.16>

  return p;
 8004cae:	9b05      	ldr	r3, [sp, #20]
}
 8004cb0:	4618      	mov	r0, r3
 8004cb2:	b007      	add	sp, #28
 8004cb4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004cc0 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 8004cc0:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8004cc2:	4b07      	ldr	r3, [pc, #28]	@ (8004ce0 <__heap_init+0x20>)
 8004cc4:	4a07      	ldr	r2, [pc, #28]	@ (8004ce4 <__heap_init+0x24>)
 8004cc6:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8004cc8:	4b05      	ldr	r3, [pc, #20]	@ (8004ce0 <__heap_init+0x20>)
 8004cca:	2200      	movs	r2, #0
 8004ccc:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 8004cce:	4b04      	ldr	r3, [pc, #16]	@ (8004ce0 <__heap_init+0x20>)
 8004cd0:	2200      	movs	r2, #0
 8004cd2:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8004cd4:	4804      	ldr	r0, [pc, #16]	@ (8004ce8 <__heap_init+0x28>)
 8004cd6:	f7ff fec3 	bl	8004a60 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 8004cda:	bf00      	nop
 8004cdc:	bd08      	pop	{r3, pc}
 8004cde:	bf00      	nop
 8004ce0:	20000b98 	.word	0x20000b98
 8004ce4:	08004c91 	.word	0x08004c91
 8004ce8:	20000ba4 	.word	0x20000ba4
 8004cec:	00000000 	.word	0x00000000

08004cf0 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8004cf0:	b500      	push	{lr}
 8004cf2:	b085      	sub	sp, #20
 8004cf4:	9003      	str	r0, [sp, #12]
 8004cf6:	9102      	str	r1, [sp, #8]
 8004cf8:	9201      	str	r2, [sp, #4]
 8004cfa:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 8004cfc:	9b03      	ldr	r3, [sp, #12]
 8004cfe:	2b00      	cmp	r3, #0
 8004d00:	bf0c      	ite	eq
 8004d02:	2301      	moveq	r3, #1
 8004d04:	2300      	movne	r3, #0
 8004d06:	b2db      	uxtb	r3, r3
 8004d08:	2b00      	cmp	r3, #0
 8004d0a:	d107      	bne.n	8004d1c <chPoolObjectInitAligned+0x2c>
 8004d0c:	9b02      	ldr	r3, [sp, #8]
 8004d0e:	2b03      	cmp	r3, #3
 8004d10:	bf94      	ite	ls
 8004d12:	2301      	movls	r3, #1
 8004d14:	2300      	movhi	r3, #0
 8004d16:	b2db      	uxtb	r3, r3
 8004d18:	2b00      	cmp	r3, #0
 8004d1a:	d001      	beq.n	8004d20 <chPoolObjectInitAligned+0x30>
 8004d1c:	2301      	movs	r3, #1
 8004d1e:	e000      	b.n	8004d22 <chPoolObjectInitAligned+0x32>
 8004d20:	2300      	movs	r3, #0
 8004d22:	2b00      	cmp	r3, #0
 8004d24:	d107      	bne.n	8004d36 <chPoolObjectInitAligned+0x46>
 8004d26:	9b01      	ldr	r3, [sp, #4]
 8004d28:	2b03      	cmp	r3, #3
 8004d2a:	bf94      	ite	ls
 8004d2c:	2301      	movls	r3, #1
 8004d2e:	2300      	movhi	r3, #0
 8004d30:	b2db      	uxtb	r3, r3
 8004d32:	2b00      	cmp	r3, #0
 8004d34:	d001      	beq.n	8004d3a <chPoolObjectInitAligned+0x4a>
 8004d36:	2301      	movs	r3, #1
 8004d38:	e000      	b.n	8004d3c <chPoolObjectInitAligned+0x4c>
 8004d3a:	2300      	movs	r3, #0
 8004d3c:	2b00      	cmp	r3, #0
 8004d3e:	d117      	bne.n	8004d70 <chPoolObjectInitAligned+0x80>
 8004d40:	9b01      	ldr	r3, [sp, #4]
 8004d42:	2b00      	cmp	r3, #0
 8004d44:	bf0c      	ite	eq
 8004d46:	2301      	moveq	r3, #1
 8004d48:	2300      	movne	r3, #0
 8004d4a:	b2db      	uxtb	r3, r3
 8004d4c:	2b00      	cmp	r3, #0
 8004d4e:	d10a      	bne.n	8004d66 <chPoolObjectInitAligned+0x76>
 8004d50:	9b01      	ldr	r3, [sp, #4]
 8004d52:	1e5a      	subs	r2, r3, #1
 8004d54:	9b01      	ldr	r3, [sp, #4]
 8004d56:	4013      	ands	r3, r2
 8004d58:	2b00      	cmp	r3, #0
 8004d5a:	bf14      	ite	ne
 8004d5c:	2301      	movne	r3, #1
 8004d5e:	2300      	moveq	r3, #0
 8004d60:	b2db      	uxtb	r3, r3
 8004d62:	2b00      	cmp	r3, #0
 8004d64:	d001      	beq.n	8004d6a <chPoolObjectInitAligned+0x7a>
 8004d66:	2301      	movs	r3, #1
 8004d68:	e000      	b.n	8004d6c <chPoolObjectInitAligned+0x7c>
 8004d6a:	2300      	movs	r3, #0
 8004d6c:	2b00      	cmp	r3, #0
 8004d6e:	d002      	beq.n	8004d76 <chPoolObjectInitAligned+0x86>
 8004d70:	4809      	ldr	r0, [pc, #36]	@ (8004d98 <chPoolObjectInitAligned+0xa8>)
 8004d72:	f7fe fa7d 	bl	8003270 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8004d76:	9b03      	ldr	r3, [sp, #12]
 8004d78:	2200      	movs	r2, #0
 8004d7a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8004d7c:	9b03      	ldr	r3, [sp, #12]
 8004d7e:	9a02      	ldr	r2, [sp, #8]
 8004d80:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8004d82:	9b03      	ldr	r3, [sp, #12]
 8004d84:	9a01      	ldr	r2, [sp, #4]
 8004d86:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8004d88:	9b03      	ldr	r3, [sp, #12]
 8004d8a:	9a00      	ldr	r2, [sp, #0]
 8004d8c:	60da      	str	r2, [r3, #12]
}
 8004d8e:	bf00      	nop
 8004d90:	b005      	add	sp, #20
 8004d92:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d96:	bf00      	nop
 8004d98:	08005678 	.word	0x08005678
 8004d9c:	00000000 	.word	0x00000000

08004da0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8004da0:	b500      	push	{lr}
 8004da2:	b083      	sub	sp, #12
 8004da4:	9001      	str	r0, [sp, #4]
 8004da6:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8004da8:	2200      	movs	r2, #0
 8004daa:	9900      	ldr	r1, [sp, #0]
 8004dac:	9801      	ldr	r0, [sp, #4]
 8004dae:	f7ff ff27 	bl	8004c00 <chCoreAllocFromTopI>
 8004db2:	4603      	mov	r3, r0
}
 8004db4:	4618      	mov	r0, r3
 8004db6:	b003      	add	sp, #12
 8004db8:	f85d fb04 	ldr.w	pc, [sp], #4
 8004dbc:	0000      	movs	r0, r0
	...

08004dc0 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8004dc0:	b500      	push	{lr}
 8004dc2:	b085      	sub	sp, #20
 8004dc4:	9003      	str	r0, [sp, #12]
 8004dc6:	9102      	str	r1, [sp, #8]
 8004dc8:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8004dca:	9b01      	ldr	r3, [sp, #4]
 8004dcc:	2204      	movs	r2, #4
 8004dce:	9902      	ldr	r1, [sp, #8]
 8004dd0:	9803      	ldr	r0, [sp, #12]
 8004dd2:	f7ff ff8d 	bl	8004cf0 <chPoolObjectInitAligned>
}
 8004dd6:	bf00      	nop
 8004dd8:	b005      	add	sp, #20
 8004dda:	f85d fb04 	ldr.w	pc, [sp], #4
 8004dde:	bf00      	nop

08004de0 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8004de0:	b082      	sub	sp, #8
 8004de2:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8004de4:	9b01      	ldr	r3, [sp, #4]
 8004de6:	9a01      	ldr	r2, [sp, #4]
 8004de8:	601a      	str	r2, [r3, #0]
}
 8004dea:	bf00      	nop
 8004dec:	b002      	add	sp, #8
 8004dee:	4770      	bx	lr

08004df0 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8004df0:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8004df2:	4810      	ldr	r0, [pc, #64]	@ (8004e34 <__factory_init+0x44>)
 8004df4:	f7ff fe34 	bl	8004a60 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8004df8:	480f      	ldr	r0, [pc, #60]	@ (8004e38 <__factory_init+0x48>)
 8004dfa:	f7ff fff1 	bl	8004de0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8004dfe:	4a0f      	ldr	r2, [pc, #60]	@ (8004e3c <__factory_init+0x4c>)
 8004e00:	2114      	movs	r1, #20
 8004e02:	480f      	ldr	r0, [pc, #60]	@ (8004e40 <__factory_init+0x50>)
 8004e04:	f7ff ffdc 	bl	8004dc0 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8004e08:	480e      	ldr	r0, [pc, #56]	@ (8004e44 <__factory_init+0x54>)
 8004e0a:	f7ff ffe9 	bl	8004de0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8004e0e:	480e      	ldr	r0, [pc, #56]	@ (8004e48 <__factory_init+0x58>)
 8004e10:	f7ff ffe6 	bl	8004de0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8004e14:	4a09      	ldr	r2, [pc, #36]	@ (8004e3c <__factory_init+0x4c>)
 8004e16:	211c      	movs	r1, #28
 8004e18:	480c      	ldr	r0, [pc, #48]	@ (8004e4c <__factory_init+0x5c>)
 8004e1a:	f7ff ffd1 	bl	8004dc0 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8004e1e:	480c      	ldr	r0, [pc, #48]	@ (8004e50 <__factory_init+0x60>)
 8004e20:	f7ff ffde 	bl	8004de0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8004e24:	480b      	ldr	r0, [pc, #44]	@ (8004e54 <__factory_init+0x64>)
 8004e26:	f7ff ffdb 	bl	8004de0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 8004e2a:	480b      	ldr	r0, [pc, #44]	@ (8004e58 <__factory_init+0x68>)
 8004e2c:	f7ff ffd8 	bl	8004de0 <dyn_list_init>
#endif
}
 8004e30:	bf00      	nop
 8004e32:	bd08      	pop	{r3, pc}
 8004e34:	20000bb4 	.word	0x20000bb4
 8004e38:	20000bc4 	.word	0x20000bc4
 8004e3c:	08004da1 	.word	0x08004da1
 8004e40:	20000bc8 	.word	0x20000bc8
 8004e44:	20000bd8 	.word	0x20000bd8
 8004e48:	20000bdc 	.word	0x20000bdc
 8004e4c:	20000be0 	.word	0x20000be0
 8004e50:	20000bf0 	.word	0x20000bf0
 8004e54:	20000bf4 	.word	0x20000bf4
 8004e58:	20000bf8 	.word	0x20000bf8
 8004e5c:	00000000 	.word	0x00000000

08004e60 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8004e60:	b084      	sub	sp, #16
 8004e62:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8004e64:	9b01      	ldr	r3, [sp, #4]
 8004e66:	f003 0307 	and.w	r3, r3, #7
 8004e6a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004e6c:	4b0b      	ldr	r3, [pc, #44]	@ (8004e9c <__NVIC_SetPriorityGrouping+0x3c>)
 8004e6e:	68db      	ldr	r3, [r3, #12]
 8004e70:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8004e72:	9a02      	ldr	r2, [sp, #8]
 8004e74:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8004e78:	4013      	ands	r3, r2
 8004e7a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8004e7c:	9b03      	ldr	r3, [sp, #12]
 8004e7e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8004e80:	9b02      	ldr	r3, [sp, #8]
 8004e82:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8004e84:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8004e88:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004e8c:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 8004e8e:	4a03      	ldr	r2, [pc, #12]	@ (8004e9c <__NVIC_SetPriorityGrouping+0x3c>)
 8004e90:	9b02      	ldr	r3, [sp, #8]
 8004e92:	60d3      	str	r3, [r2, #12]
}
 8004e94:	bf00      	nop
 8004e96:	b004      	add	sp, #16
 8004e98:	4770      	bx	lr
 8004e9a:	bf00      	nop
 8004e9c:	e000ed00 	.word	0xe000ed00

08004ea0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8004ea0:	b082      	sub	sp, #8
 8004ea2:	4603      	mov	r3, r0
 8004ea4:	9100      	str	r1, [sp, #0]
 8004ea6:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 8004eaa:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004eae:	2b00      	cmp	r3, #0
 8004eb0:	db0a      	blt.n	8004ec8 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004eb2:	9b00      	ldr	r3, [sp, #0]
 8004eb4:	b2da      	uxtb	r2, r3
 8004eb6:	490c      	ldr	r1, [pc, #48]	@ (8004ee8 <__NVIC_SetPriority+0x48>)
 8004eb8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004ebc:	0112      	lsls	r2, r2, #4
 8004ebe:	b2d2      	uxtb	r2, r2
 8004ec0:	440b      	add	r3, r1
 8004ec2:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8004ec6:	e00b      	b.n	8004ee0 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004ec8:	9b00      	ldr	r3, [sp, #0]
 8004eca:	b2da      	uxtb	r2, r3
 8004ecc:	4907      	ldr	r1, [pc, #28]	@ (8004eec <__NVIC_SetPriority+0x4c>)
 8004ece:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004ed2:	f003 030f 	and.w	r3, r3, #15
 8004ed6:	3b04      	subs	r3, #4
 8004ed8:	0112      	lsls	r2, r2, #4
 8004eda:	b2d2      	uxtb	r2, r2
 8004edc:	440b      	add	r3, r1
 8004ede:	761a      	strb	r2, [r3, #24]
}
 8004ee0:	bf00      	nop
 8004ee2:	b002      	add	sp, #8
 8004ee4:	4770      	bx	lr
 8004ee6:	bf00      	nop
 8004ee8:	e000e100 	.word	0xe000e100
 8004eec:	e000ed00 	.word	0xe000ed00

08004ef0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004ef0:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004ef2:	f3ef 8309 	mrs	r3, PSP
 8004ef6:	9300      	str	r3, [sp, #0]
  return(result);
 8004ef8:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 8004efa:	9303      	str	r3, [sp, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8004efc:	9b03      	ldr	r3, [sp, #12]
 8004efe:	3320      	adds	r3, #32
 8004f00:	9303      	str	r3, [sp, #12]
 8004f02:	9b03      	ldr	r3, [sp, #12]
 8004f04:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004f06:	9b01      	ldr	r3, [sp, #4]
 8004f08:	f383 8809 	msr	PSP, r3
}
 8004f0c:	bf00      	nop
 8004f0e:	2300      	movs	r3, #0
 8004f10:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004f12:	9b02      	ldr	r3, [sp, #8]
 8004f14:	f383 8811 	msr	BASEPRI, r3
}
 8004f18:	bf00      	nop
 8004f1a:	bf00      	nop
}
 8004f1c:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8004f1e:	bf00      	nop
 8004f20:	b004      	add	sp, #16
 8004f22:	4770      	bx	lr
	...

08004f30 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004f30:	b500      	push	{lr}
 8004f32:	b085      	sub	sp, #20
 8004f34:	9001      	str	r0, [sp, #4]
 8004f36:	2330      	movs	r3, #48	@ 0x30
 8004f38:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004f3a:	9b03      	ldr	r3, [sp, #12]
 8004f3c:	f383 8811 	msr	BASEPRI, r3
}
 8004f40:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8004f42:	b662      	cpsie	i
}
 8004f44:	bf00      	nop
}
 8004f46:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8004f48:	2003      	movs	r0, #3
 8004f4a:	f7ff ff89 	bl	8004e60 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8004f4e:	4b0d      	ldr	r3, [pc, #52]	@ (8004f84 <port_init+0x54>)
 8004f50:	68db      	ldr	r3, [r3, #12]
 8004f52:	4a0c      	ldr	r2, [pc, #48]	@ (8004f84 <port_init+0x54>)
 8004f54:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004f58:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8004f5a:	4b0b      	ldr	r3, [pc, #44]	@ (8004f88 <port_init+0x58>)
 8004f5c:	681b      	ldr	r3, [r3, #0]
 8004f5e:	4a0a      	ldr	r2, [pc, #40]	@ (8004f88 <port_init+0x58>)
 8004f60:	f043 0301 	orr.w	r3, r3, #1
 8004f64:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8004f66:	2102      	movs	r1, #2
 8004f68:	f06f 0004 	mvn.w	r0, #4
 8004f6c:	f7ff ff98 	bl	8004ea0 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004f70:	2103      	movs	r1, #3
 8004f72:	f06f 0001 	mvn.w	r0, #1
 8004f76:	f7ff ff93 	bl	8004ea0 <__NVIC_SetPriority>

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 8004f7a:	bf00      	nop
 8004f7c:	b005      	add	sp, #20
 8004f7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f82:	bf00      	nop
 8004f84:	e000edf0 	.word	0xe000edf0
 8004f88:	e0001000 	.word	0xe0001000
 8004f8c:	00000000 	.word	0x00000000

08004f90 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 8004f90:	b500      	push	{lr}
 8004f92:	b087      	sub	sp, #28
 8004f94:	2330      	movs	r3, #48	@ 0x30
 8004f96:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004f98:	9b03      	ldr	r3, [sp, #12]
 8004f9a:	f383 8811 	msr	BASEPRI, r3
}
 8004f9e:	bf00      	nop
}
 8004fa0:	bf00      	nop
}
 8004fa2:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004fa4:	4b18      	ldr	r3, [pc, #96]	@ (8005008 <__port_irq_epilogue+0x78>)
 8004fa6:	685b      	ldr	r3, [r3, #4]
 8004fa8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8004fac:	2b00      	cmp	r3, #0
 8004fae:	d020      	beq.n	8004ff2 <__port_irq_epilogue+0x62>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004fb0:	f3ef 8309 	mrs	r3, PSP
 8004fb4:	9301      	str	r3, [sp, #4]
  return(result);
 8004fb6:	9b01      	ldr	r3, [sp, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 8004fb8:	9305      	str	r3, [sp, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 8004fba:	9b05      	ldr	r3, [sp, #20]
 8004fbc:	3b20      	subs	r3, #32
 8004fbe:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 8004fc0:	9b05      	ldr	r3, [sp, #20]
 8004fc2:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8004fc4:	9b04      	ldr	r3, [sp, #16]
 8004fc6:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 8004fca:	61da      	str	r2, [r3, #28]
 8004fcc:	9b05      	ldr	r3, [sp, #20]
 8004fce:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004fd0:	9b02      	ldr	r3, [sp, #8]
 8004fd2:	f383 8809 	msr	PSP, r3
}
 8004fd6:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004fd8:	f7ff f84a 	bl	8004070 <chSchIsPreemptionRequired>
 8004fdc:	4603      	mov	r3, r0
 8004fde:	2b00      	cmp	r3, #0
 8004fe0:	d003      	beq.n	8004fea <__port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8004fe2:	4a0a      	ldr	r2, [pc, #40]	@ (800500c <__port_irq_epilogue+0x7c>)
 8004fe4:	9b04      	ldr	r3, [sp, #16]
 8004fe6:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8004fe8:	e00b      	b.n	8005002 <__port_irq_epilogue+0x72>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8004fea:	4a09      	ldr	r2, [pc, #36]	@ (8005010 <__port_irq_epilogue+0x80>)
 8004fec:	9b04      	ldr	r3, [sp, #16]
 8004fee:	619a      	str	r2, [r3, #24]
    return;
 8004ff0:	e007      	b.n	8005002 <__port_irq_epilogue+0x72>
 8004ff2:	2300      	movs	r3, #0
 8004ff4:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004ff6:	9b00      	ldr	r3, [sp, #0]
 8004ff8:	f383 8811 	msr	BASEPRI, r3
}
 8004ffc:	bf00      	nop
}
 8004ffe:	bf00      	nop
}
 8005000:	bf00      	nop
  }
  port_unlock_from_isr();
}
 8005002:	b007      	add	sp, #28
 8005004:	f85d fb04 	ldr.w	pc, [sp], #4
 8005008:	e000ed00 	.word	0xe000ed00
 800500c:	08000247 	.word	0x08000247
 8005010:	08000252 	.word	0x08000252
	...

08005020 <portab_setup>:
/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

void portab_setup(void) {
}
 8005020:	bf00      	nop
 8005022:	4770      	bx	lr
	...

08005030 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8005030:	b082      	sub	sp, #8
 8005032:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8005034:	4b03      	ldr	r3, [pc, #12]	@ (8005044 <chRegSetThreadName+0x14>)
 8005036:	68db      	ldr	r3, [r3, #12]
 8005038:	9a01      	ldr	r2, [sp, #4]
 800503a:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 800503c:	bf00      	nop
 800503e:	b002      	add	sp, #8
 8005040:	4770      	bx	lr
 8005042:	bf00      	nop
 8005044:	200009d0 	.word	0x200009d0
	...

08005050 <adccallback>:

/*
 * ADC streaming callback.
 */
size_t n= 0, nx = 0, ny = 0;
void adccallback(ADCDriver *adcp) {
 8005050:	b082      	sub	sp, #8
 8005052:	9001      	str	r0, [sp, #4]

  /* Updating counters.*/
  n++;
 8005054:	4b14      	ldr	r3, [pc, #80]	@ (80050a8 <adccallback+0x58>)
 8005056:	681b      	ldr	r3, [r3, #0]
 8005058:	3301      	adds	r3, #1
 800505a:	4a13      	ldr	r2, [pc, #76]	@ (80050a8 <adccallback+0x58>)
 800505c:	6013      	str	r3, [r2, #0]
  if (adcIsBufferComplete(adcp)) {
 800505e:	9b01      	ldr	r3, [sp, #4]
 8005060:	781b      	ldrb	r3, [r3, #0]
 8005062:	2b04      	cmp	r3, #4
 8005064:	d105      	bne.n	8005072 <adccallback+0x22>
    nx += 1;
 8005066:	4b11      	ldr	r3, [pc, #68]	@ (80050ac <adccallback+0x5c>)
 8005068:	681b      	ldr	r3, [r3, #0]
 800506a:	3301      	adds	r3, #1
 800506c:	4a0f      	ldr	r2, [pc, #60]	@ (80050ac <adccallback+0x5c>)
 800506e:	6013      	str	r3, [r2, #0]
 8005070:	e004      	b.n	800507c <adccallback+0x2c>
  }
  else {
    ny += 1;
 8005072:	4b0f      	ldr	r3, [pc, #60]	@ (80050b0 <adccallback+0x60>)
 8005074:	681b      	ldr	r3, [r3, #0]
 8005076:	3301      	adds	r3, #1
 8005078:	4a0d      	ldr	r2, [pc, #52]	@ (80050b0 <adccallback+0x60>)
 800507a:	6013      	str	r3, [r2, #0]
  }

  if ((n % 200) == 0U) {
 800507c:	4b0a      	ldr	r3, [pc, #40]	@ (80050a8 <adccallback+0x58>)
 800507e:	681a      	ldr	r2, [r3, #0]
 8005080:	4b0c      	ldr	r3, [pc, #48]	@ (80050b4 <adccallback+0x64>)
 8005082:	fba3 1302 	umull	r1, r3, r3, r2
 8005086:	099b      	lsrs	r3, r3, #6
 8005088:	21c8      	movs	r1, #200	@ 0xc8
 800508a:	fb01 f303 	mul.w	r3, r1, r3
 800508e:	1ad3      	subs	r3, r2, r3
 8005090:	2b00      	cmp	r3, #0
 8005092:	d105      	bne.n	80050a0 <adccallback+0x50>
#if defined(PORTAB_LINE_LED2)
    palToggleLine(PORTAB_LINE_LED2);
 8005094:	4b08      	ldr	r3, [pc, #32]	@ (80050b8 <adccallback+0x68>)
 8005096:	695b      	ldr	r3, [r3, #20]
 8005098:	4a07      	ldr	r2, [pc, #28]	@ (80050b8 <adccallback+0x68>)
 800509a:	f083 0320 	eor.w	r3, r3, #32
 800509e:	6153      	str	r3, [r2, #20]
#endif
  }
}
 80050a0:	bf00      	nop
 80050a2:	b002      	add	sp, #8
 80050a4:	4770      	bx	lr
 80050a6:	bf00      	nop
 80050a8:	20000d04 	.word	0x20000d04
 80050ac:	20000d08 	.word	0x20000d08
 80050b0:	20000d0c 	.word	0x20000d0c
 80050b4:	51eb851f 	.word	0x51eb851f
 80050b8:	48000400 	.word	0x48000400
 80050bc:	00000000 	.word	0x00000000

080050c0 <adcerrorcallback>:

/*
 * ADC errors callback, should never happen.
 */
void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 80050c0:	b500      	push	{lr}
 80050c2:	b083      	sub	sp, #12
 80050c4:	9001      	str	r0, [sp, #4]
 80050c6:	9100      	str	r1, [sp, #0]

  (void)adcp;
  (void)err;

  chSysHalt("it happened");
 80050c8:	4803      	ldr	r0, [pc, #12]	@ (80050d8 <adcerrorcallback+0x18>)
 80050ca:	f7fe f8d1 	bl	8003270 <chSysHalt>
}
 80050ce:	bf00      	nop
 80050d0:	b003      	add	sp, #12
 80050d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80050d6:	bf00      	nop
 80050d8:	08005578 	.word	0x08005578
 80050dc:	00000000 	.word	0x00000000

080050e0 <Thread1>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED attached to TP1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 80050e0:	b500      	push	{lr}
 80050e2:	b083      	sub	sp, #12
 80050e4:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 80050e6:	4809      	ldr	r0, [pc, #36]	@ (800510c <Thread1+0x2c>)
 80050e8:	f7ff ffa2 	bl	8005030 <chRegSetThreadName>
  while (true) {
    palSetLine(PORTAB_LINE_LED1);
 80050ec:	4b08      	ldr	r3, [pc, #32]	@ (8005110 <Thread1+0x30>)
 80050ee:	2201      	movs	r2, #1
 80050f0:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 80050f2:	f241 3088 	movw	r0, #5000	@ 0x1388
 80050f6:	f7ff fb83 	bl	8004800 <chThdSleep>
    palClearLine(PORTAB_LINE_LED1);
 80050fa:	4b05      	ldr	r3, [pc, #20]	@ (8005110 <Thread1+0x30>)
 80050fc:	2201      	movs	r2, #1
 80050fe:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8005100:	f241 3088 	movw	r0, #5000	@ 0x1388
 8005104:	f7ff fb7c 	bl	8004800 <chThdSleep>
    palSetLine(PORTAB_LINE_LED1);
 8005108:	bf00      	nop
 800510a:	e7ef      	b.n	80050ec <Thread1+0xc>
 800510c:	08005584 	.word	0x08005584
 8005110:	48000400 	.word	0x48000400
	...

08005120 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8005120:	b500      	push	{lr}
 8005122:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8005124:	f7fb f904 	bl	8000330 <halInit>
  chSysInit();
 8005128:	f7fe f872 	bl	8003210 <chSysInit>

  /* Board-dependent GPIO setup code.*/
  portab_setup();
 800512c:	f7ff ff78 	bl	8005020 <portab_setup>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8005130:	2300      	movs	r3, #0
 8005132:	9300      	str	r3, [sp, #0]
 8005134:	4b1a      	ldr	r3, [pc, #104]	@ (80051a0 <main+0x80>)
 8005136:	2280      	movs	r2, #128	@ 0x80
 8005138:	f44f 71b8 	mov.w	r1, #368	@ 0x170
 800513c:	4819      	ldr	r0, [pc, #100]	@ (80051a4 <main+0x84>)
 800513e:	f7ff fa87 	bl	8004650 <chThdCreateStatic>

  /*
   * Starting PORTAB_ADC1 driver and the temperature sensor.
   */
  adcStart(&PORTAB_ADC1, &portab_adccfg1);
 8005142:	4919      	ldr	r1, [pc, #100]	@ (80051a8 <main+0x88>)
 8005144:	4819      	ldr	r0, [pc, #100]	@ (80051ac <main+0x8c>)
 8005146:	f7fb fd63 	bl	8000c10 <adcStart>
  adcSTM32EnableVREF(&PORTAB_ADC1);
 800514a:	4818      	ldr	r0, [pc, #96]	@ (80051ac <main+0x8c>)
 800514c:	f7fd fa10 	bl	8002570 <adcSTM32EnableVREF>
  adcSTM32EnableTS(&PORTAB_ADC1);
 8005150:	4816      	ldr	r0, [pc, #88]	@ (80051ac <main+0x8c>)
 8005152:	f7fd fa1d 	bl	8002590 <adcSTM32EnableTS>

  /* Performing a one-shot conversion on two channels.*/
  adcConvert(&PORTAB_ADC1, &portab_adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
 8005156:	2302      	movs	r3, #2
 8005158:	4a15      	ldr	r2, [pc, #84]	@ (80051b0 <main+0x90>)
 800515a:	4916      	ldr	r1, [pc, #88]	@ (80051b4 <main+0x94>)
 800515c:	4813      	ldr	r0, [pc, #76]	@ (80051ac <main+0x8c>)
 800515e:	f7fb fe37 	bl	8000dd0 <adcConvert>
  cacheBufferInvalidate(samples1, sizeof (samples1) / sizeof (adcsample_t));

  /*
   * Starting PORTAB_GPT1 driver, it is used for triggering the ADC.
   */
  gptStart(&PORTAB_GPT1, &portab_gptcfg1);
 8005162:	4915      	ldr	r1, [pc, #84]	@ (80051b8 <main+0x98>)
 8005164:	4815      	ldr	r0, [pc, #84]	@ (80051bc <main+0x9c>)
 8005166:	f7fb fe9b 	bl	8000ea0 <gptStart>

  /*
   * Starting an ADC continuous conversion triggered with a period of
   * 1/10000 second.
   */
  adcStartConversion(&PORTAB_ADC1, &portab_adcgrpcfg2,
 800516a:	2340      	movs	r3, #64	@ 0x40
 800516c:	4a14      	ldr	r2, [pc, #80]	@ (80051c0 <main+0xa0>)
 800516e:	4915      	ldr	r1, [pc, #84]	@ (80051c4 <main+0xa4>)
 8005170:	480e      	ldr	r0, [pc, #56]	@ (80051ac <main+0x8c>)
 8005172:	f7fb fd7d 	bl	8000c70 <adcStartConversion>
                     samples2, ADC_GRP2_BUF_DEPTH);
  gptStartContinuous(&PORTAB_GPT1, 100U);
 8005176:	2164      	movs	r1, #100	@ 0x64
 8005178:	4810      	ldr	r0, [pc, #64]	@ (80051bc <main+0x9c>)
 800517a:	f7fb fec9 	bl	8000f10 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the
   * conversion is stopped.
   */
  while (true) {
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 800517e:	4b12      	ldr	r3, [pc, #72]	@ (80051c8 <main+0xa8>)
 8005180:	691b      	ldr	r3, [r3, #16]
 8005182:	f003 0310 	and.w	r3, r3, #16
 8005186:	2b00      	cmp	r3, #0
 8005188:	d105      	bne.n	8005196 <main+0x76>
      gptStopTimer(&PORTAB_GPT1);
 800518a:	480c      	ldr	r0, [pc, #48]	@ (80051bc <main+0x9c>)
 800518c:	f7fb fef0 	bl	8000f70 <gptStopTimer>
      adcStopConversion(&PORTAB_ADC1);
 8005190:	4806      	ldr	r0, [pc, #24]	@ (80051ac <main+0x8c>)
 8005192:	f7fb fded 	bl	8000d70 <adcStopConversion>
    }
    chThdSleepMilliseconds(500);
 8005196:	f241 3088 	movw	r0, #5000	@ 0x1388
 800519a:	f7ff fb31 	bl	8004800 <chThdSleep>
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 800519e:	e7ee      	b.n	800517e <main+0x5e>
 80051a0:	080050e1 	.word	0x080050e1
 80051a4:	20000d10 	.word	0x20000d10
 80051a8:	080056a0 	.word	0x080056a0
 80051ac:	20000800 	.word	0x20000800
 80051b0:	20000bfc 	.word	0x20000bfc
 80051b4:	080056a4 	.word	0x080056a4
 80051b8:	08005690 	.word	0x08005690
 80051bc:	20000934 	.word	0x20000934
 80051c0:	20000c04 	.word	0x20000c04
 80051c4:	080056e4 	.word	0x080056e4
 80051c8:	48000800 	.word	0x48000800
