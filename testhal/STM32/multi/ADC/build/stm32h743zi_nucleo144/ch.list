
build/stm32h743zi_nucleo144/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080003b9 	.word	0x080003b9
 8000008:	080003bb 	.word	0x080003bb
 800000c:	080003bb 	.word	0x080003bb
 8000010:	080003bb 	.word	0x080003bb
 8000014:	080003bb 	.word	0x080003bb
 8000018:	080003bb 	.word	0x080003bb
 800001c:	080003bb 	.word	0x080003bb
 8000020:	080003bb 	.word	0x080003bb
 8000024:	080003bb 	.word	0x080003bb
 8000028:	080003bb 	.word	0x080003bb
 800002c:	08006571 	.word	0x08006571
 8000030:	080003bb 	.word	0x080003bb
 8000034:	080003bb 	.word	0x080003bb
 8000038:	080003bb 	.word	0x080003bb
 800003c:	080003bb 	.word	0x080003bb
 8000040:	080003bb 	.word	0x080003bb
 8000044:	080003bb 	.word	0x080003bb
 8000048:	080003bb 	.word	0x080003bb
 800004c:	080003bb 	.word	0x080003bb
 8000050:	080003bb 	.word	0x080003bb
 8000054:	080003bb 	.word	0x080003bb
 8000058:	080003bb 	.word	0x080003bb
 800005c:	080003bb 	.word	0x080003bb
 8000060:	080003bb 	.word	0x080003bb
 8000064:	080003bb 	.word	0x080003bb
 8000068:	080003bb 	.word	0x080003bb
 800006c:	08002a91 	.word	0x08002a91
 8000070:	08002af1 	.word	0x08002af1
 8000074:	08002b51 	.word	0x08002b51
 8000078:	08002bb1 	.word	0x08002bb1
 800007c:	08002c11 	.word	0x08002c11
 8000080:	08002c71 	.word	0x08002c71
 8000084:	08002cd1 	.word	0x08002cd1
 8000088:	08001fb1 	.word	0x08001fb1
 800008c:	080003bb 	.word	0x080003bb
 8000090:	080003bb 	.word	0x080003bb
 8000094:	080003bb 	.word	0x080003bb
 8000098:	080003bb 	.word	0x080003bb
 800009c:	080003bb 	.word	0x080003bb
 80000a0:	080003bb 	.word	0x080003bb
 80000a4:	080003bb 	.word	0x080003bb
 80000a8:	080003bb 	.word	0x080003bb
 80000ac:	080003bb 	.word	0x080003bb
 80000b0:	08001041 	.word	0x08001041
 80000b4:	080003bb 	.word	0x080003bb
 80000b8:	08001091 	.word	0x08001091
 80000bc:	080003bb 	.word	0x080003bb
 80000c0:	080003bb 	.word	0x080003bb
 80000c4:	080003bb 	.word	0x080003bb
 80000c8:	080003bb 	.word	0x080003bb
 80000cc:	080003bb 	.word	0x080003bb
 80000d0:	080003bb 	.word	0x080003bb
 80000d4:	080003bb 	.word	0x080003bb
 80000d8:	080003bb 	.word	0x080003bb
 80000dc:	080003bb 	.word	0x080003bb
 80000e0:	080003bb 	.word	0x080003bb
 80000e4:	080003bb 	.word	0x080003bb
 80000e8:	080003bb 	.word	0x080003bb
 80000ec:	080003bb 	.word	0x080003bb
 80000f0:	080003bb 	.word	0x080003bb
 80000f4:	080003bb 	.word	0x080003bb
 80000f8:	080003bb 	.word	0x080003bb
 80000fc:	08002d31 	.word	0x08002d31
 8000100:	080003bb 	.word	0x080003bb
 8000104:	080003bb 	.word	0x080003bb
 8000108:	080003bb 	.word	0x080003bb
 800010c:	080003bb 	.word	0x080003bb
 8000110:	080003bb 	.word	0x080003bb
 8000114:	080003bb 	.word	0x080003bb
 8000118:	080003bb 	.word	0x080003bb
 800011c:	080003bb 	.word	0x080003bb
 8000120:	08002d91 	.word	0x08002d91
 8000124:	08002df1 	.word	0x08002df1
 8000128:	08002e51 	.word	0x08002e51
 800012c:	08002eb1 	.word	0x08002eb1
 8000130:	08002f11 	.word	0x08002f11
 8000134:	080003bb 	.word	0x080003bb
 8000138:	080003bb 	.word	0x080003bb
 800013c:	080003bb 	.word	0x080003bb
 8000140:	080003bb 	.word	0x080003bb
 8000144:	080003bb 	.word	0x080003bb
 8000148:	080003bb 	.word	0x080003bb
 800014c:	080003bb 	.word	0x080003bb
 8000150:	08002f71 	.word	0x08002f71
 8000154:	08002fd1 	.word	0x08002fd1
 8000158:	08003031 	.word	0x08003031
 800015c:	080003bb 	.word	0x080003bb
 8000160:	080003bb 	.word	0x080003bb
 8000164:	080003bb 	.word	0x080003bb
 8000168:	080003bb 	.word	0x080003bb
 800016c:	080003bb 	.word	0x080003bb
 8000170:	080003bb 	.word	0x080003bb
 8000174:	080003bb 	.word	0x080003bb
 8000178:	080003bb 	.word	0x080003bb
 800017c:	080003bb 	.word	0x080003bb
 8000180:	080003bb 	.word	0x080003bb
 8000184:	080003bb 	.word	0x080003bb
 8000188:	080003bb 	.word	0x080003bb
 800018c:	080003bb 	.word	0x080003bb
 8000190:	080003bb 	.word	0x080003bb
 8000194:	080003bb 	.word	0x080003bb
 8000198:	080003bb 	.word	0x080003bb
 800019c:	080003bb 	.word	0x080003bb
 80001a0:	080003bb 	.word	0x080003bb
 80001a4:	080003bb 	.word	0x080003bb
 80001a8:	080003bb 	.word	0x080003bb
 80001ac:	080003bb 	.word	0x080003bb
 80001b0:	080003bb 	.word	0x080003bb
 80001b4:	080003bb 	.word	0x080003bb
 80001b8:	080003bb 	.word	0x080003bb
 80001bc:	080003bb 	.word	0x080003bb
 80001c0:	080003bb 	.word	0x080003bb
 80001c4:	080003bb 	.word	0x080003bb
 80001c8:	080003bb 	.word	0x080003bb
 80001cc:	080003bb 	.word	0x080003bb
 80001d0:	080003bb 	.word	0x080003bb
 80001d4:	080003bb 	.word	0x080003bb
 80001d8:	080003bb 	.word	0x080003bb
 80001dc:	080003bb 	.word	0x080003bb
 80001e0:	080003bb 	.word	0x080003bb
 80001e4:	080003bb 	.word	0x080003bb
 80001e8:	080003bb 	.word	0x080003bb
 80001ec:	080003bb 	.word	0x080003bb
 80001f0:	080003bb 	.word	0x080003bb
 80001f4:	080003bb 	.word	0x080003bb
 80001f8:	080003bb 	.word	0x080003bb
 80001fc:	080003bb 	.word	0x080003bb
 8000200:	080003bb 	.word	0x080003bb
 8000204:	080003bb 	.word	0x080003bb
 8000208:	080003bb 	.word	0x080003bb
 800020c:	080003bb 	.word	0x080003bb
 8000210:	080003bb 	.word	0x080003bb
 8000214:	080003bb 	.word	0x080003bb
 8000218:	080003bb 	.word	0x080003bb
 800021c:	080003bb 	.word	0x080003bb
 8000220:	080003bb 	.word	0x080003bb
 8000224:	080003bb 	.word	0x080003bb
 8000228:	080003bb 	.word	0x080003bb
 800022c:	080003bb 	.word	0x080003bb
 8000230:	080003bb 	.word	0x080003bb
 8000234:	080003bb 	.word	0x080003bb
 8000238:	080003bb 	.word	0x080003bb
 800023c:	08002001 	.word	0x08002001
 8000240:	080003bb 	.word	0x080003bb
 8000244:	08002581 	.word	0x08002581
 8000248:	080025e1 	.word	0x080025e1
 800024c:	08002641 	.word	0x08002641
 8000250:	080026a1 	.word	0x080026a1
 8000254:	08002701 	.word	0x08002701
 8000258:	08002761 	.word	0x08002761
 800025c:	080027c1 	.word	0x080027c1
 8000260:	08002821 	.word	0x08002821
 8000264:	080003bb 	.word	0x080003bb
 8000268:	080003bb 	.word	0x080003bb
 800026c:	080003bb 	.word	0x080003bb
 8000270:	080003bb 	.word	0x080003bb
 8000274:	080003bb 	.word	0x080003bb
 8000278:	080003bb 	.word	0x080003bb
 800027c:	080003bb 	.word	0x080003bb
 8000280:	080003bb 	.word	0x080003bb
 8000284:	080003bb 	.word	0x080003bb
 8000288:	080003bb 	.word	0x080003bb
 800028c:	080003bb 	.word	0x080003bb
 8000290:	080003bb 	.word	0x080003bb
 8000294:	080003bb 	.word	0x080003bb
 8000298:	080003bb 	.word	0x080003bb
 800029c:	080003bb 	.word	0x080003bb
 80002a0:	080003bb 	.word	0x080003bb
 80002a4:	080003bb 	.word	0x080003bb
 80002a8:	080003bb 	.word	0x080003bb
 80002ac:	080003bb 	.word	0x080003bb
 80002b0:	080003bb 	.word	0x080003bb
 80002b4:	080003bb 	.word	0x080003bb
 80002b8:	080003bb 	.word	0x080003bb
 80002bc:	080003bb 	.word	0x080003bb
 80002c0:	080003bb 	.word	0x080003bb
 80002c4:	080003bb 	.word	0x080003bb
 80002c8:	080003bb 	.word	0x080003bb
 80002cc:	080003bb 	.word	0x080003bb
 80002d0:	080003bb 	.word	0x080003bb
 80002d4:	080003bb 	.word	0x080003bb
 80002d8:	080003bb 	.word	0x080003bb
 80002dc:	080003bb 	.word	0x080003bb

Disassembly of section .text:

080002e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80002e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80002e2:	4826      	ldr	r0, [pc, #152]	@ (800037c <endfiniloop+0x6>)
                msr     MSP, r0
 80002e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80002e8:	4825      	ldr	r0, [pc, #148]	@ (8000380 <endfiniloop+0xa>)
                msr     PSP, r0
 80002ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80002ee:	4825      	ldr	r0, [pc, #148]	@ (8000384 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 80002f0:	4925      	ldr	r1, [pc, #148]	@ (8000388 <endfiniloop+0x12>)
                str     r0, [r1]
 80002f2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80002f4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80002f6:	f380 8814 	msr	CONTROL, r0
                isb
 80002fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80002fe:	f000 f92f 	bl	8000560 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000302:	f003 fb65 	bl	80039d0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000306:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800030a:	4920      	ldr	r1, [pc, #128]	@ (800038c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800030c:	4a1b      	ldr	r2, [pc, #108]	@ (800037c <endfiniloop+0x6>)

0800030e <msloop>:
msloop:
                cmp     r1, r2
 800030e:	4291      	cmp	r1, r2
                itt     lo
 8000310:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000312:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000316:	e7fa      	bcc.n	800030e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000318:	491d      	ldr	r1, [pc, #116]	@ (8000390 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800031a:	4a19      	ldr	r2, [pc, #100]	@ (8000380 <endfiniloop+0xa>)

0800031c <psloop>:
psloop:
                cmp     r1, r2
 800031c:	4291      	cmp	r1, r2
                itt     lo
 800031e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000320:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000324:	e7fa      	bcc.n	800031c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000326:	491b      	ldr	r1, [pc, #108]	@ (8000394 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000328:	4a1b      	ldr	r2, [pc, #108]	@ (8000398 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800032a:	4b1c      	ldr	r3, [pc, #112]	@ (800039c <endfiniloop+0x26>)

0800032c <dloop>:
dloop:
                cmp     r2, r3
 800032c:	429a      	cmp	r2, r3
                ittt    lo
 800032e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000330:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000334:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000338:	e7f8      	bcc.n	800032c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800033a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800033c:	4918      	ldr	r1, [pc, #96]	@ (80003a0 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800033e:	4a19      	ldr	r2, [pc, #100]	@ (80003a4 <endfiniloop+0x2e>)

08000340 <bloop>:
bloop:
                cmp     r1, r2
 8000340:	4291      	cmp	r1, r2
                itt     lo
 8000342:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000344:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000348:	e7fa      	bcc.n	8000340 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800034a:	f000 f921 	bl	8000590 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800034e:	f000 f90f 	bl	8000570 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000352:	4c15      	ldr	r4, [pc, #84]	@ (80003a8 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000354:	4d15      	ldr	r5, [pc, #84]	@ (80003ac <endfiniloop+0x36>)

08000356 <initloop>:
initloop:
                cmp     r4, r5
 8000356:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000358:	da03      	bge.n	8000362 <endinitloop>
                ldr     r1, [r4], #4
 800035a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800035e:	4788      	blx	r1
                b       initloop
 8000360:	e7f9      	b.n	8000356 <initloop>

08000362 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000362:	f006 fa35 	bl	80067d0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000366:	4c12      	ldr	r4, [pc, #72]	@ (80003b0 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000368:	4d12      	ldr	r5, [pc, #72]	@ (80003b4 <endfiniloop+0x3e>)

0800036a <finiloop>:
finiloop:
                cmp     r4, r5
 800036a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800036c:	da03      	bge.n	8000376 <endfiniloop>
                ldr     r1, [r4], #4
 800036e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000372:	4788      	blx	r1
                b       finiloop
 8000374:	e7f9      	b.n	800036a <finiloop>

08000376 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000376:	f000 b903 	b.w	8000580 <__default_exit>
 800037a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800037c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000380:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000384:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000388:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800038c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000390:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000394:	08007204 	.word	0x08007204
                ldr     r2, =__data_base__
 8000398:	24000000 	.word	0x24000000
                ldr     r3, =__data_end__
 800039c:	24000000 	.word	0x24000000
                ldr     r1, =__bss_base__
 80003a0:	24000000 	.word	0x24000000
                ldr     r2, =__bss_end__
 80003a4:	24000e40 	.word	0x24000e40
                ldr     r4, =__init_array_base__
 80003a8:	080002e0 	.word	0x080002e0
                ldr     r5, =__init_array_end__
 80003ac:	080002e0 	.word	0x080002e0
                ldr     r4, =__fini_array_base__
 80003b0:	080002e0 	.word	0x080002e0
                ldr     r5, =__fini_array_end__
 80003b4:	080002e0 	.word	0x080002e0

080003b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80003b8:	e792      	b.n	80002e0 <_crt0_entry>

080003ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80003ba:	f000 f800 	bl	80003be <_unhandled_exception>

080003be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80003be:	e7fe      	b.n	80003be <_unhandled_exception>

080003c0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80003c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80003c4:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
 80003c8:	f8d0 d00c 	ldr.w	sp, [r0, #12]

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80003cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080003d0 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80003d0:	f003 fc56 	bl	8003c80 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80003d4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80003d6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80003da:	4628      	mov	r0, r5
                blx     r4
 80003dc:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80003de:	2000      	movs	r0, #0
                bl      chThdExit
 80003e0:	f005 f98e 	bl	8005700 <chThdExit>

080003e4 <.zombies>:
.zombies:       b       .zombies
 80003e4:	e7fe      	b.n	80003e4 <.zombies>

080003e6 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 80003e6:	f003 fc23 	bl	8003c30 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 80003ea:	f004 fd99 	bl	8004f20 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80003ee:	f003 fc47 	bl	8003c80 <__dbg_check_unlock>

080003f2 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80003f2:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80003f4:	e7fe      	b.n	80003f4 <__port_exit_from_isr+0x2>
	...

08000400 <SCB_EnableICache>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000400:	f3bf 8f4f 	dsb	sy
}
 8000404:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000406:	f3bf 8f6f 	isb	sy
}
 800040a:	bf00      	nop
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 800040c:	4b0b      	ldr	r3, [pc, #44]	@ (800043c <SCB_EnableICache+0x3c>)
 800040e:	2200      	movs	r2, #0
 8000410:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000414:	f3bf 8f4f 	dsb	sy
}
 8000418:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800041a:	f3bf 8f6f 	isb	sy
}
 800041e:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8000420:	4b06      	ldr	r3, [pc, #24]	@ (800043c <SCB_EnableICache+0x3c>)
 8000422:	695b      	ldr	r3, [r3, #20]
 8000424:	4a05      	ldr	r2, [pc, #20]	@ (800043c <SCB_EnableICache+0x3c>)
 8000426:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800042a:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 800042c:	f3bf 8f4f 	dsb	sy
}
 8000430:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000432:	f3bf 8f6f 	isb	sy
}
 8000436:	bf00      	nop
    __DSB();
    __ISB();
  #endif
}
 8000438:	bf00      	nop
 800043a:	4770      	bx	lr
 800043c:	e000ed00 	.word	0xe000ed00

08000440 <SCB_InvalidateICache>:
  __ASM volatile ("dsb 0xF":::"memory");
 8000440:	f3bf 8f4f 	dsb	sy
}
 8000444:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000446:	f3bf 8f6f 	isb	sy
}
 800044a:	bf00      	nop
__STATIC_INLINE void SCB_InvalidateICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;
 800044c:	4b05      	ldr	r3, [pc, #20]	@ (8000464 <SCB_InvalidateICache+0x24>)
 800044e:	2200      	movs	r2, #0
 8000450:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000454:	f3bf 8f4f 	dsb	sy
}
 8000458:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800045a:	f3bf 8f6f 	isb	sy
}
 800045e:	bf00      	nop
    __DSB();
    __ISB();
  #endif
}
 8000460:	bf00      	nop
 8000462:	4770      	bx	lr
 8000464:	e000ed00 	.word	0xe000ed00
	...

08000470 <SCB_EnableDCache>:
/**
  \brief   Enable D-Cache
  \details Turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache (void)
{
 8000470:	b084      	sub	sp, #16
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8000472:	4b1e      	ldr	r3, [pc, #120]	@ (80004ec <SCB_EnableDCache+0x7c>)
 8000474:	2200      	movs	r2, #0
 8000476:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 800047a:	f3bf 8f4f 	dsb	sy
}
 800047e:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000480:	4b1a      	ldr	r3, [pc, #104]	@ (80004ec <SCB_EnableDCache+0x7c>)
 8000482:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8000486:	9301      	str	r3, [sp, #4]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000488:	9b01      	ldr	r3, [sp, #4]
 800048a:	0b5b      	lsrs	r3, r3, #13
 800048c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000490:	9303      	str	r3, [sp, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000492:	9b01      	ldr	r3, [sp, #4]
 8000494:	08db      	lsrs	r3, r3, #3
 8000496:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800049a:	9302      	str	r3, [sp, #8]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800049c:	9b03      	ldr	r3, [sp, #12]
 800049e:	015a      	lsls	r2, r3, #5
 80004a0:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
 80004a4:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 80004a6:	9a02      	ldr	r2, [sp, #8]
 80004a8:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80004aa:	4910      	ldr	r1, [pc, #64]	@ (80004ec <SCB_EnableDCache+0x7c>)
 80004ac:	4313      	orrs	r3, r2
 80004ae:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 80004b2:	9b02      	ldr	r3, [sp, #8]
 80004b4:	1e5a      	subs	r2, r3, #1
 80004b6:	9202      	str	r2, [sp, #8]
 80004b8:	2b00      	cmp	r3, #0
 80004ba:	d1ef      	bne.n	800049c <SCB_EnableDCache+0x2c>
    } while(sets-- != 0U);
 80004bc:	9b03      	ldr	r3, [sp, #12]
 80004be:	1e5a      	subs	r2, r3, #1
 80004c0:	9203      	str	r2, [sp, #12]
 80004c2:	2b00      	cmp	r3, #0
 80004c4:	d1e5      	bne.n	8000492 <SCB_EnableDCache+0x22>
  __ASM volatile ("dsb 0xF":::"memory");
 80004c6:	f3bf 8f4f 	dsb	sy
}
 80004ca:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 80004cc:	4b07      	ldr	r3, [pc, #28]	@ (80004ec <SCB_EnableDCache+0x7c>)
 80004ce:	695b      	ldr	r3, [r3, #20]
 80004d0:	4a06      	ldr	r2, [pc, #24]	@ (80004ec <SCB_EnableDCache+0x7c>)
 80004d2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80004d6:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 80004d8:	f3bf 8f4f 	dsb	sy
}
 80004dc:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 80004de:	f3bf 8f6f 	isb	sy
}
 80004e2:	bf00      	nop

    __DSB();
    __ISB();
  #endif
}
 80004e4:	bf00      	nop
 80004e6:	b004      	add	sp, #16
 80004e8:	4770      	bx	lr
 80004ea:	bf00      	nop
 80004ec:	e000ed00 	.word	0xe000ed00

080004f0 <SCB_CleanDCache>:
/**
  \brief   Clean D-Cache
  \details Cleans D-Cache
  */
__STATIC_INLINE void SCB_CleanDCache (void)
{
 80004f0:	b084      	sub	sp, #16
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

     SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80004f2:	4b19      	ldr	r3, [pc, #100]	@ (8000558 <SCB_CleanDCache+0x68>)
 80004f4:	2200      	movs	r2, #0
 80004f6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 80004fa:	f3bf 8f4f 	dsb	sy
}
 80004fe:	bf00      	nop
   __DSB();

    ccsidr = SCB->CCSIDR;
 8000500:	4b15      	ldr	r3, [pc, #84]	@ (8000558 <SCB_CleanDCache+0x68>)
 8000502:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8000506:	9301      	str	r3, [sp, #4]

                                            /* clean D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000508:	9b01      	ldr	r3, [sp, #4]
 800050a:	0b5b      	lsrs	r3, r3, #13
 800050c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000510:	9303      	str	r3, [sp, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000512:	9b01      	ldr	r3, [sp, #4]
 8000514:	08db      	lsrs	r3, r3, #3
 8000516:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800051a:	9302      	str	r3, [sp, #8]
      do {
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 800051c:	9b03      	ldr	r3, [sp, #12]
 800051e:	015a      	lsls	r2, r3, #5
 8000520:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
 8000524:	4013      	ands	r3, r2
                      ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );
 8000526:	9a02      	ldr	r2, [sp, #8]
 8000528:	0792      	lsls	r2, r2, #30
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 800052a:	490b      	ldr	r1, [pc, #44]	@ (8000558 <SCB_CleanDCache+0x68>)
 800052c:	4313      	orrs	r3, r2
 800052e:	f8c1 326c 	str.w	r3, [r1, #620]	@ 0x26c
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8000532:	9b02      	ldr	r3, [sp, #8]
 8000534:	1e5a      	subs	r2, r3, #1
 8000536:	9202      	str	r2, [sp, #8]
 8000538:	2b00      	cmp	r3, #0
 800053a:	d1ef      	bne.n	800051c <SCB_CleanDCache+0x2c>
    } while(sets-- != 0U);
 800053c:	9b03      	ldr	r3, [sp, #12]
 800053e:	1e5a      	subs	r2, r3, #1
 8000540:	9203      	str	r2, [sp, #12]
 8000542:	2b00      	cmp	r3, #0
 8000544:	d1e5      	bne.n	8000512 <SCB_CleanDCache+0x22>
  __ASM volatile ("dsb 0xF":::"memory");
 8000546:	f3bf 8f4f 	dsb	sy
}
 800054a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800054c:	f3bf 8f6f 	isb	sy
}
 8000550:	bf00      	nop

    __DSB();
    __ISB();
  #endif
}
 8000552:	bf00      	nop
 8000554:	b004      	add	sp, #16
 8000556:	4770      	bx	lr
 8000558:	e000ed00 	.word	0xe000ed00
 800055c:	00000000 	.word	0x00000000

08000560 <__cpu_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __cpu_init(void) {
 8000560:	b508      	push	{r3, lr}

#if CORTEX_MODEL == 7
  SCB_EnableICache();
 8000562:	f7ff ff4d 	bl	8000400 <SCB_EnableICache>
  SCB_EnableDCache();
 8000566:	f7ff ff83 	bl	8000470 <SCB_EnableDCache>
#endif
}
 800056a:	bf00      	nop
 800056c:	bd08      	pop	{r3, pc}
 800056e:	bf00      	nop

08000570 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000570:	bf00      	nop
 8000572:	4770      	bx	lr
	...

08000580 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
     asm volatile ("nop");
 8000580:	bf00      	nop
 8000582:	e7fd      	b.n	8000580 <__default_exit>
	...

08000590 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000590:	b500      	push	{lr}
 8000592:	b085      	sub	sp, #20
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000594:	4b19      	ldr	r3, [pc, #100]	@ (80005fc <__init_ram_areas+0x6c>)
 8000596:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000598:	9b03      	ldr	r3, [sp, #12]
 800059a:	681b      	ldr	r3, [r3, #0]
 800059c:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800059e:	9b03      	ldr	r3, [sp, #12]
 80005a0:	685b      	ldr	r3, [r3, #4]
 80005a2:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80005a4:	e009      	b.n	80005ba <__init_ram_areas+0x2a>
      *p = *tp;
 80005a6:	9b02      	ldr	r3, [sp, #8]
 80005a8:	681a      	ldr	r2, [r3, #0]
 80005aa:	9b01      	ldr	r3, [sp, #4]
 80005ac:	601a      	str	r2, [r3, #0]
      p++;
 80005ae:	9b01      	ldr	r3, [sp, #4]
 80005b0:	3304      	adds	r3, #4
 80005b2:	9301      	str	r3, [sp, #4]
      tp++;
 80005b4:	9b02      	ldr	r3, [sp, #8]
 80005b6:	3304      	adds	r3, #4
 80005b8:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 80005ba:	9b03      	ldr	r3, [sp, #12]
 80005bc:	689b      	ldr	r3, [r3, #8]
 80005be:	9a01      	ldr	r2, [sp, #4]
 80005c0:	429a      	cmp	r2, r3
 80005c2:	d3f0      	bcc.n	80005a6 <__init_ram_areas+0x16>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80005c4:	e005      	b.n	80005d2 <__init_ram_areas+0x42>
      *p = 0;
 80005c6:	9b01      	ldr	r3, [sp, #4]
 80005c8:	2200      	movs	r2, #0
 80005ca:	601a      	str	r2, [r3, #0]
      p++;
 80005cc:	9b01      	ldr	r3, [sp, #4]
 80005ce:	3304      	adds	r3, #4
 80005d0:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 80005d2:	9b03      	ldr	r3, [sp, #12]
 80005d4:	68db      	ldr	r3, [r3, #12]
 80005d6:	9a01      	ldr	r2, [sp, #4]
 80005d8:	429a      	cmp	r2, r3
 80005da:	d3f4      	bcc.n	80005c6 <__init_ram_areas+0x36>
    }
    rap++;
 80005dc:	9b03      	ldr	r3, [sp, #12]
 80005de:	3310      	adds	r3, #16
 80005e0:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 80005e2:	9b03      	ldr	r3, [sp, #12]
 80005e4:	4a06      	ldr	r2, [pc, #24]	@ (8000600 <__init_ram_areas+0x70>)
 80005e6:	4293      	cmp	r3, r2
 80005e8:	d3d6      	bcc.n	8000598 <__init_ram_areas+0x8>
#if CORTEX_MODEL == 7
  /* PM0253 - 4.8.7 Cache maintenance design hints and tips - required
     for self-modifying code.*/
  SCB_CleanDCache();
 80005ea:	f7ff ff81 	bl	80004f0 <SCB_CleanDCache>
  SCB_InvalidateICache();
 80005ee:	f7ff ff27 	bl	8000440 <SCB_InvalidateICache>
#endif
#endif
}
 80005f2:	bf00      	nop
 80005f4:	b005      	add	sp, #20
 80005f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80005fa:	bf00      	nop
 80005fc:	080068b8 	.word	0x080068b8
 8000600:	08006938 	.word	0x08006938
	...

08000610 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000610:	bf00      	nop
 8000612:	4770      	bx	lr
	...

08000620 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000620:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000622:	f7ff fff5 	bl	8000610 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000626:	f000 ffdb 	bl	80015e0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 800062a:	f002 fe29 	bl	8003280 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800062e:	f000 f927 	bl	8000880 <adcInit>
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 8000632:	f000 fae5 	bl	8000c00 <gptInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000636:	f003 f9d3 	bl	80039e0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800063a:	f000 f851 	bl	80006e0 <stInit>
#endif
}
 800063e:	bf00      	nop
 8000640:	bd08      	pop	{r3, pc}
 8000642:	bf00      	nop
	...

08000650 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000650:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000654:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
}
 8000656:	4618      	mov	r0, r3
 8000658:	4770      	bx	lr
 800065a:	bf00      	nop
 800065c:	0000      	movs	r0, r0
	...

08000660 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 8000660:	b082      	sub	sp, #8
 8000662:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000664:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000668:	9b01      	ldr	r3, [sp, #4]
 800066a:	6353      	str	r3, [r2, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 800066c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000670:	2200      	movs	r2, #0
 8000672:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000674:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000678:	2202      	movs	r2, #2
 800067a:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 800067c:	bf00      	nop
 800067e:	b002      	add	sp, #8
 8000680:	4770      	bx	lr
 8000682:	bf00      	nop
	...

08000690 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8000690:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000694:	2200      	movs	r2, #0
 8000696:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 8000698:	bf00      	nop
 800069a:	4770      	bx	lr
 800069c:	0000      	movs	r0, r0
	...

080006a0 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 80006a0:	b082      	sub	sp, #8
 80006a2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80006a4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80006a8:	9b01      	ldr	r3, [sp, #4]
 80006aa:	6353      	str	r3, [r2, #52]	@ 0x34
}
 80006ac:	bf00      	nop
 80006ae:	b002      	add	sp, #8
 80006b0:	4770      	bx	lr
 80006b2:	bf00      	nop
	...

080006c0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80006c0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80006c4:	68db      	ldr	r3, [r3, #12]
 80006c6:	f003 0302 	and.w	r3, r3, #2
 80006ca:	2b00      	cmp	r3, #0
 80006cc:	bf14      	ite	ne
 80006ce:	2301      	movne	r3, #1
 80006d0:	2300      	moveq	r3, #0
 80006d2:	b2db      	uxtb	r3, r3
}
 80006d4:	4618      	mov	r0, r3
 80006d6:	4770      	bx	lr
	...

080006e0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80006e0:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 80006e2:	f002 fef5 	bl	80034d0 <st_lld_init>
}
 80006e6:	bf00      	nop
 80006e8:	bd08      	pop	{r3, pc}
 80006ea:	bf00      	nop
 80006ec:	0000      	movs	r0, r0
	...

080006f0 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 80006f0:	b508      	push	{r3, lr}

  return st_lld_get_counter();
 80006f2:	f7ff ffad 	bl	8000650 <st_lld_get_counter>
 80006f6:	4603      	mov	r3, r0
}
 80006f8:	4618      	mov	r0, r3
 80006fa:	bd08      	pop	{r3, pc}
 80006fc:	0000      	movs	r0, r0
	...

08000700 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000700:	b500      	push	{lr}
 8000702:	b083      	sub	sp, #12
 8000704:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000706:	f000 f833 	bl	8000770 <stIsAlarmActive>
 800070a:	4603      	mov	r3, r0
 800070c:	2b00      	cmp	r3, #0
 800070e:	d002      	beq.n	8000716 <stStartAlarm+0x16>
 8000710:	4804      	ldr	r0, [pc, #16]	@ (8000724 <stStartAlarm+0x24>)
 8000712:	f003 fa05 	bl	8003b20 <chSysHalt>

  st_lld_start_alarm(abstime);
 8000716:	9801      	ldr	r0, [sp, #4]
 8000718:	f7ff ffa2 	bl	8000660 <st_lld_start_alarm>
}
 800071c:	bf00      	nop
 800071e:	b003      	add	sp, #12
 8000720:	f85d fb04 	ldr.w	pc, [sp], #4
 8000724:	08006938 	.word	0x08006938
	...

08000730 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000730:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8000732:	f7ff ffad 	bl	8000690 <st_lld_stop_alarm>
}
 8000736:	bf00      	nop
 8000738:	bd08      	pop	{r3, pc}
 800073a:	bf00      	nop
 800073c:	0000      	movs	r0, r0
	...

08000740 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000740:	b500      	push	{lr}
 8000742:	b083      	sub	sp, #12
 8000744:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000746:	f000 f813 	bl	8000770 <stIsAlarmActive>
 800074a:	4603      	mov	r3, r0
 800074c:	f083 0301 	eor.w	r3, r3, #1
 8000750:	b2db      	uxtb	r3, r3
 8000752:	2b00      	cmp	r3, #0
 8000754:	d002      	beq.n	800075c <stSetAlarm+0x1c>
 8000756:	4805      	ldr	r0, [pc, #20]	@ (800076c <stSetAlarm+0x2c>)
 8000758:	f003 f9e2 	bl	8003b20 <chSysHalt>

  st_lld_set_alarm(abstime);
 800075c:	9801      	ldr	r0, [sp, #4]
 800075e:	f7ff ff9f 	bl	80006a0 <st_lld_set_alarm>
}
 8000762:	bf00      	nop
 8000764:	b003      	add	sp, #12
 8000766:	f85d fb04 	ldr.w	pc, [sp], #4
 800076a:	bf00      	nop
 800076c:	08006948 	.word	0x08006948

08000770 <stIsAlarmActive>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @api
 */
bool stIsAlarmActive(void) {
 8000770:	b508      	push	{r3, lr}

  return st_lld_is_alarm_active();
 8000772:	f7ff ffa5 	bl	80006c0 <st_lld_is_alarm_active>
 8000776:	4603      	mov	r3, r0
}
 8000778:	4618      	mov	r0, r3
 800077a:	bd08      	pop	{r3, pc}
 800077c:	0000      	movs	r0, r0
	...

08000780 <chSysLock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 8000780:	b500      	push	{lr}
 8000782:	b083      	sub	sp, #12
 8000784:	2330      	movs	r3, #48	@ 0x30
 8000786:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000788:	9b01      	ldr	r3, [sp, #4]
 800078a:	f383 8811 	msr	BASEPRI, r3
}
 800078e:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000790:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 8000792:	f003 fa4d 	bl	8003c30 <__dbg_check_lock>
}
 8000796:	bf00      	nop
 8000798:	b003      	add	sp, #12
 800079a:	f85d fb04 	ldr.w	pc, [sp], #4
 800079e:	bf00      	nop

080007a0 <chSysUnlock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80007a0:	b500      	push	{lr}
 80007a2:	b083      	sub	sp, #12

  __dbg_check_unlock();
 80007a4:	f003 fa6c 	bl	8003c80 <__dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80007a8:	4b12      	ldr	r3, [pc, #72]	@ (80007f4 <chSysUnlock.lto_priv.2+0x54>)
 80007aa:	681b      	ldr	r3, [r3, #0]
 80007ac:	4a11      	ldr	r2, [pc, #68]	@ (80007f4 <chSysUnlock.lto_priv.2+0x54>)
 80007ae:	4293      	cmp	r3, r2
 80007b0:	bf14      	ite	ne
 80007b2:	2301      	movne	r3, #1
 80007b4:	2300      	moveq	r3, #0
 80007b6:	b2db      	uxtb	r3, r3
 80007b8:	2b00      	cmp	r3, #0
 80007ba:	d00f      	beq.n	80007dc <chSysUnlock.lto_priv.2+0x3c>
 80007bc:	4b0d      	ldr	r3, [pc, #52]	@ (80007f4 <chSysUnlock.lto_priv.2+0x54>)
 80007be:	68db      	ldr	r3, [r3, #12]
 80007c0:	689a      	ldr	r2, [r3, #8]
 80007c2:	4b0c      	ldr	r3, [pc, #48]	@ (80007f4 <chSysUnlock.lto_priv.2+0x54>)
 80007c4:	681b      	ldr	r3, [r3, #0]
 80007c6:	689b      	ldr	r3, [r3, #8]
 80007c8:	429a      	cmp	r2, r3
 80007ca:	bf34      	ite	cc
 80007cc:	2301      	movcc	r3, #1
 80007ce:	2300      	movcs	r3, #0
 80007d0:	b2db      	uxtb	r3, r3
 80007d2:	2b00      	cmp	r3, #0
 80007d4:	d002      	beq.n	80007dc <chSysUnlock.lto_priv.2+0x3c>
 80007d6:	4808      	ldr	r0, [pc, #32]	@ (80007f8 <chSysUnlock.lto_priv.2+0x58>)
 80007d8:	f003 f9a2 	bl	8003b20 <chSysHalt>
 80007dc:	2300      	movs	r3, #0
 80007de:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80007e0:	9b01      	ldr	r3, [sp, #4]
 80007e2:	f383 8811 	msr	BASEPRI, r3
}
 80007e6:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80007e8:	bf00      	nop
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 80007ea:	bf00      	nop
 80007ec:	b003      	add	sp, #12
 80007ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80007f2:	bf00      	nop
 80007f4:	24000158 	.word	0x24000158
 80007f8:	08006960 	.word	0x08006960
 80007fc:	00000000 	.word	0x00000000

08000800 <osalSysLock.lto_priv.2>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000800:	b508      	push	{r3, lr}

  chSysLock();
 8000802:	f7ff ffbd 	bl	8000780 <chSysLock.lto_priv.2>
}
 8000806:	bf00      	nop
 8000808:	bd08      	pop	{r3, pc}
 800080a:	bf00      	nop
 800080c:	0000      	movs	r0, r0
	...

08000810 <osalSysUnlock.lto_priv.2>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8000810:	b508      	push	{r3, lr}

  chSysUnlock();
 8000812:	f7ff ffc5 	bl	80007a0 <chSysUnlock.lto_priv.2>
}
 8000816:	bf00      	nop
 8000818:	bd08      	pop	{r3, pc}
 800081a:	bf00      	nop
 800081c:	0000      	movs	r0, r0
	...

08000820 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8000820:	b500      	push	{lr}
 8000822:	b083      	sub	sp, #12
 8000824:	9001      	str	r0, [sp, #4]

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8000826:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 800082a:	9801      	ldr	r0, [sp, #4]
 800082c:	f004 ffd0 	bl	80057d0 <chThdSuspendTimeoutS>
 8000830:	4603      	mov	r3, r0
}
 8000832:	4618      	mov	r0, r3
 8000834:	b003      	add	sp, #12
 8000836:	f85d fb04 	ldr.w	pc, [sp], #4
 800083a:	bf00      	nop
 800083c:	0000      	movs	r0, r0
	...

08000840 <osalThreadResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 8000840:	b500      	push	{lr}
 8000842:	b083      	sub	sp, #12
 8000844:	9001      	str	r0, [sp, #4]
 8000846:	9100      	str	r1, [sp, #0]

  chThdResumeS(trp, msg);
 8000848:	9900      	ldr	r1, [sp, #0]
 800084a:	9801      	ldr	r0, [sp, #4]
 800084c:	f005 f818 	bl	8005880 <chThdResumeS>
}
 8000850:	bf00      	nop
 8000852:	b003      	add	sp, #12
 8000854:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000860 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8000860:	b500      	push	{lr}
 8000862:	b083      	sub	sp, #12
 8000864:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8000866:	9801      	ldr	r0, [sp, #4]
 8000868:	f005 fa3a 	bl	8005ce0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800086c:	bf00      	nop
 800086e:	b003      	add	sp, #12
 8000870:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000880 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 8000880:	b508      	push	{r3, lr}

  adc_lld_init();
 8000882:	f001 fbe5 	bl	8002050 <adc_lld_init>
}
 8000886:	bf00      	nop
 8000888:	bd08      	pop	{r3, pc}
 800088a:	bf00      	nop
 800088c:	0000      	movs	r0, r0
	...

08000890 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 8000890:	b500      	push	{lr}
 8000892:	b083      	sub	sp, #12
 8000894:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 8000896:	9b01      	ldr	r3, [sp, #4]
 8000898:	2201      	movs	r2, #1
 800089a:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 800089c:	9b01      	ldr	r3, [sp, #4]
 800089e:	2200      	movs	r2, #0
 80008a0:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 80008a2:	9b01      	ldr	r3, [sp, #4]
 80008a4:	2200      	movs	r2, #0
 80008a6:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 80008a8:	9b01      	ldr	r3, [sp, #4]
 80008aa:	2200      	movs	r2, #0
 80008ac:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 80008ae:	9b01      	ldr	r3, [sp, #4]
 80008b0:	2200      	movs	r2, #0
 80008b2:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 80008b4:	9b01      	ldr	r3, [sp, #4]
 80008b6:	2200      	movs	r2, #0
 80008b8:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 80008ba:	9b01      	ldr	r3, [sp, #4]
 80008bc:	3318      	adds	r3, #24
 80008be:	4618      	mov	r0, r3
 80008c0:	f7ff ffce 	bl	8000860 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 80008c4:	bf00      	nop
 80008c6:	b003      	add	sp, #12
 80008c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80008cc:	0000      	movs	r0, r0
	...

080008d0 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 80008d0:	b500      	push	{lr}
 80008d2:	b085      	sub	sp, #20
 80008d4:	9001      	str	r0, [sp, #4]
 80008d6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(adcp != NULL);
 80008d8:	9b01      	ldr	r3, [sp, #4]
 80008da:	2b00      	cmp	r3, #0
 80008dc:	bf0c      	ite	eq
 80008de:	2301      	moveq	r3, #1
 80008e0:	2300      	movne	r3, #0
 80008e2:	b2db      	uxtb	r3, r3
 80008e4:	2b00      	cmp	r3, #0
 80008e6:	d002      	beq.n	80008ee <adcStart+0x1e>
 80008e8:	4818      	ldr	r0, [pc, #96]	@ (800094c <adcStart+0x7c>)
 80008ea:	f003 f919 	bl	8003b20 <chSysHalt>

  osalSysLock();
 80008ee:	f7ff ff87 	bl	8000800 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 80008f2:	9b01      	ldr	r3, [sp, #4]
 80008f4:	781b      	ldrb	r3, [r3, #0]
 80008f6:	2b01      	cmp	r3, #1
 80008f8:	bf14      	ite	ne
 80008fa:	2301      	movne	r3, #1
 80008fc:	2300      	moveq	r3, #0
 80008fe:	b2db      	uxtb	r3, r3
 8000900:	2b00      	cmp	r3, #0
 8000902:	d00b      	beq.n	800091c <adcStart+0x4c>
 8000904:	9b01      	ldr	r3, [sp, #4]
 8000906:	781b      	ldrb	r3, [r3, #0]
 8000908:	2b02      	cmp	r3, #2
 800090a:	bf14      	ite	ne
 800090c:	2301      	movne	r3, #1
 800090e:	2300      	moveq	r3, #0
 8000910:	b2db      	uxtb	r3, r3
 8000912:	2b00      	cmp	r3, #0
 8000914:	d002      	beq.n	800091c <adcStart+0x4c>
 8000916:	480d      	ldr	r0, [pc, #52]	@ (800094c <adcStart+0x7c>)
 8000918:	f003 f902 	bl	8003b20 <chSysHalt>
                "invalid state");
  adcp->config = config;
 800091c:	9b01      	ldr	r3, [sp, #4]
 800091e:	9a00      	ldr	r2, [sp, #0]
 8000920:	605a      	str	r2, [r3, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
 8000922:	9801      	ldr	r0, [sp, #4]
 8000924:	f001 fbec 	bl	8002100 <adc_lld_start>
 8000928:	9003      	str	r0, [sp, #12]
#else
  adc_lld_start(adcp);
  msg = HAL_RET_SUCCESS;
#endif
  if (msg == HAL_RET_SUCCESS) {
 800092a:	9b03      	ldr	r3, [sp, #12]
 800092c:	2b00      	cmp	r3, #0
 800092e:	d103      	bne.n	8000938 <adcStart+0x68>
    adcp->state = ADC_READY;
 8000930:	9b01      	ldr	r3, [sp, #4]
 8000932:	2202      	movs	r2, #2
 8000934:	701a      	strb	r2, [r3, #0]
 8000936:	e002      	b.n	800093e <adcStart+0x6e>
  }
  else {
    adcp->state = ADC_STOP;
 8000938:	9b01      	ldr	r3, [sp, #4]
 800093a:	2201      	movs	r2, #1
 800093c:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 800093e:	f7ff ff67 	bl	8000810 <osalSysUnlock.lto_priv.2>

  return msg;
 8000942:	9b03      	ldr	r3, [sp, #12]
}
 8000944:	4618      	mov	r0, r3
 8000946:	b005      	add	sp, #20
 8000948:	f85d fb04 	ldr.w	pc, [sp], #4
 800094c:	08006954 	.word	0x08006954

08000950 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 8000950:	b500      	push	{lr}
 8000952:	b085      	sub	sp, #20
 8000954:	9003      	str	r0, [sp, #12]
 8000956:	9102      	str	r1, [sp, #8]
 8000958:	9201      	str	r2, [sp, #4]
 800095a:	9300      	str	r3, [sp, #0]

  osalSysLock();
 800095c:	f7ff ff50 	bl	8000800 <osalSysLock.lto_priv.2>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000960:	9b00      	ldr	r3, [sp, #0]
 8000962:	9a01      	ldr	r2, [sp, #4]
 8000964:	9902      	ldr	r1, [sp, #8]
 8000966:	9803      	ldr	r0, [sp, #12]
 8000968:	f000 f80a 	bl	8000980 <adcStartConversionI>
  osalSysUnlock();
 800096c:	f7ff ff50 	bl	8000810 <osalSysUnlock.lto_priv.2>
}
 8000970:	bf00      	nop
 8000972:	b005      	add	sp, #20
 8000974:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000980 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
 8000980:	b500      	push	{lr}
 8000982:	b085      	sub	sp, #20
 8000984:	9003      	str	r0, [sp, #12]
 8000986:	9102      	str	r1, [sp, #8]
 8000988:	9201      	str	r2, [sp, #4]
 800098a:	9300      	str	r3, [sp, #0]

  osalDbgCheckClassI();
 800098c:	f003 fa68 	bl	8003e60 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
 8000990:	9b03      	ldr	r3, [sp, #12]
 8000992:	2b00      	cmp	r3, #0
 8000994:	bf0c      	ite	eq
 8000996:	2301      	moveq	r3, #1
 8000998:	2300      	movne	r3, #0
 800099a:	b2db      	uxtb	r3, r3
 800099c:	2b00      	cmp	r3, #0
 800099e:	d107      	bne.n	80009b0 <adcStartConversionI+0x30>
 80009a0:	9b02      	ldr	r3, [sp, #8]
 80009a2:	2b00      	cmp	r3, #0
 80009a4:	bf0c      	ite	eq
 80009a6:	2301      	moveq	r3, #1
 80009a8:	2300      	movne	r3, #0
 80009aa:	b2db      	uxtb	r3, r3
 80009ac:	2b00      	cmp	r3, #0
 80009ae:	d001      	beq.n	80009b4 <adcStartConversionI+0x34>
 80009b0:	2301      	movs	r3, #1
 80009b2:	e000      	b.n	80009b6 <adcStartConversionI+0x36>
 80009b4:	2300      	movs	r3, #0
 80009b6:	2b00      	cmp	r3, #0
 80009b8:	d107      	bne.n	80009ca <adcStartConversionI+0x4a>
 80009ba:	9b01      	ldr	r3, [sp, #4]
 80009bc:	2b00      	cmp	r3, #0
 80009be:	bf0c      	ite	eq
 80009c0:	2301      	moveq	r3, #1
 80009c2:	2300      	movne	r3, #0
 80009c4:	b2db      	uxtb	r3, r3
 80009c6:	2b00      	cmp	r3, #0
 80009c8:	d001      	beq.n	80009ce <adcStartConversionI+0x4e>
 80009ca:	2301      	movs	r3, #1
 80009cc:	e000      	b.n	80009d0 <adcStartConversionI+0x50>
 80009ce:	2300      	movs	r3, #0
 80009d0:	2b00      	cmp	r3, #0
 80009d2:	d107      	bne.n	80009e4 <adcStartConversionI+0x64>
 80009d4:	9b00      	ldr	r3, [sp, #0]
 80009d6:	2b00      	cmp	r3, #0
 80009d8:	bf0c      	ite	eq
 80009da:	2301      	moveq	r3, #1
 80009dc:	2300      	movne	r3, #0
 80009de:	b2db      	uxtb	r3, r3
 80009e0:	2b00      	cmp	r3, #0
 80009e2:	d001      	beq.n	80009e8 <adcStartConversionI+0x68>
 80009e4:	2301      	movs	r3, #1
 80009e6:	e000      	b.n	80009ea <adcStartConversionI+0x6a>
 80009e8:	2300      	movs	r3, #0
 80009ea:	2b00      	cmp	r3, #0
 80009ec:	d111      	bne.n	8000a12 <adcStartConversionI+0x92>
 80009ee:	9b00      	ldr	r3, [sp, #0]
 80009f0:	2b01      	cmp	r3, #1
 80009f2:	bf14      	ite	ne
 80009f4:	2301      	movne	r3, #1
 80009f6:	2300      	moveq	r3, #0
 80009f8:	b2db      	uxtb	r3, r3
 80009fa:	2b00      	cmp	r3, #0
 80009fc:	d006      	beq.n	8000a0c <adcStartConversionI+0x8c>
 80009fe:	9b00      	ldr	r3, [sp, #0]
 8000a00:	f003 0301 	and.w	r3, r3, #1
 8000a04:	2b00      	cmp	r3, #0
 8000a06:	d001      	beq.n	8000a0c <adcStartConversionI+0x8c>
 8000a08:	2301      	movs	r3, #1
 8000a0a:	e000      	b.n	8000a0e <adcStartConversionI+0x8e>
 8000a0c:	2300      	movs	r3, #0
 8000a0e:	2b00      	cmp	r3, #0
 8000a10:	d002      	beq.n	8000a18 <adcStartConversionI+0x98>
 8000a12:	4815      	ldr	r0, [pc, #84]	@ (8000a68 <adcStartConversionI+0xe8>)
 8000a14:	f003 f884 	bl	8003b20 <chSysHalt>
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
 8000a18:	9b03      	ldr	r3, [sp, #12]
 8000a1a:	781b      	ldrb	r3, [r3, #0]
 8000a1c:	2b02      	cmp	r3, #2
 8000a1e:	bf14      	ite	ne
 8000a20:	2301      	movne	r3, #1
 8000a22:	2300      	moveq	r3, #0
 8000a24:	b2db      	uxtb	r3, r3
 8000a26:	2b00      	cmp	r3, #0
 8000a28:	d00b      	beq.n	8000a42 <adcStartConversionI+0xc2>
 8000a2a:	9b03      	ldr	r3, [sp, #12]
 8000a2c:	781b      	ldrb	r3, [r3, #0]
 8000a2e:	2b05      	cmp	r3, #5
 8000a30:	bf14      	ite	ne
 8000a32:	2301      	movne	r3, #1
 8000a34:	2300      	moveq	r3, #0
 8000a36:	b2db      	uxtb	r3, r3
 8000a38:	2b00      	cmp	r3, #0
 8000a3a:	d002      	beq.n	8000a42 <adcStartConversionI+0xc2>
 8000a3c:	480a      	ldr	r0, [pc, #40]	@ (8000a68 <adcStartConversionI+0xe8>)
 8000a3e:	f003 f86f 	bl	8003b20 <chSysHalt>
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 8000a42:	9b03      	ldr	r3, [sp, #12]
 8000a44:	9a01      	ldr	r2, [sp, #4]
 8000a46:	609a      	str	r2, [r3, #8]
  adcp->depth    = depth;
 8000a48:	9b03      	ldr	r3, [sp, #12]
 8000a4a:	9a00      	ldr	r2, [sp, #0]
 8000a4c:	60da      	str	r2, [r3, #12]
  adcp->grpp     = grpp;
 8000a4e:	9b03      	ldr	r3, [sp, #12]
 8000a50:	9a02      	ldr	r2, [sp, #8]
 8000a52:	611a      	str	r2, [r3, #16]
  adcp->state    = ADC_ACTIVE;
 8000a54:	9b03      	ldr	r3, [sp, #12]
 8000a56:	2203      	movs	r2, #3
 8000a58:	701a      	strb	r2, [r3, #0]
  adc_lld_start_conversion(adcp);
 8000a5a:	9803      	ldr	r0, [sp, #12]
 8000a5c:	f001 fbf0 	bl	8002240 <adc_lld_start_conversion>
}
 8000a60:	bf00      	nop
 8000a62:	b005      	add	sp, #20
 8000a64:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a68:	0800696c 	.word	0x0800696c
 8000a6c:	00000000 	.word	0x00000000

08000a70 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
 8000a70:	b500      	push	{lr}
 8000a72:	b083      	sub	sp, #12
 8000a74:	9001      	str	r0, [sp, #4]

  osalDbgCheck(adcp != NULL);
 8000a76:	9b01      	ldr	r3, [sp, #4]
 8000a78:	2b00      	cmp	r3, #0
 8000a7a:	bf0c      	ite	eq
 8000a7c:	2301      	moveq	r3, #1
 8000a7e:	2300      	movne	r3, #0
 8000a80:	b2db      	uxtb	r3, r3
 8000a82:	2b00      	cmp	r3, #0
 8000a84:	d002      	beq.n	8000a8c <adcStopConversion+0x1c>
 8000a86:	481a      	ldr	r0, [pc, #104]	@ (8000af0 <adcStopConversion+0x80>)
 8000a88:	f003 f84a 	bl	8003b20 <chSysHalt>

  osalSysLock();
 8000a8c:	f7ff feb8 	bl	8000800 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_READY) || (adcp->state == ADC_ACTIVE),
 8000a90:	9b01      	ldr	r3, [sp, #4]
 8000a92:	781b      	ldrb	r3, [r3, #0]
 8000a94:	2b02      	cmp	r3, #2
 8000a96:	bf14      	ite	ne
 8000a98:	2301      	movne	r3, #1
 8000a9a:	2300      	moveq	r3, #0
 8000a9c:	b2db      	uxtb	r3, r3
 8000a9e:	2b00      	cmp	r3, #0
 8000aa0:	d00b      	beq.n	8000aba <adcStopConversion+0x4a>
 8000aa2:	9b01      	ldr	r3, [sp, #4]
 8000aa4:	781b      	ldrb	r3, [r3, #0]
 8000aa6:	2b03      	cmp	r3, #3
 8000aa8:	bf14      	ite	ne
 8000aaa:	2301      	movne	r3, #1
 8000aac:	2300      	moveq	r3, #0
 8000aae:	b2db      	uxtb	r3, r3
 8000ab0:	2b00      	cmp	r3, #0
 8000ab2:	d002      	beq.n	8000aba <adcStopConversion+0x4a>
 8000ab4:	480e      	ldr	r0, [pc, #56]	@ (8000af0 <adcStopConversion+0x80>)
 8000ab6:	f003 f833 	bl	8003b20 <chSysHalt>
                "invalid state");
  if (adcp->state != ADC_READY) {
 8000aba:	9b01      	ldr	r3, [sp, #4]
 8000abc:	781b      	ldrb	r3, [r3, #0]
 8000abe:	2b02      	cmp	r3, #2
 8000ac0:	d00f      	beq.n	8000ae2 <adcStopConversion+0x72>
    adc_lld_stop_conversion(adcp);
 8000ac2:	9801      	ldr	r0, [sp, #4]
 8000ac4:	f001 fcc4 	bl	8002450 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
 8000ac8:	9b01      	ldr	r3, [sp, #4]
 8000aca:	2200      	movs	r2, #0
 8000acc:	611a      	str	r2, [r3, #16]
    adcp->state = ADC_READY;
 8000ace:	9b01      	ldr	r3, [sp, #4]
 8000ad0:	2202      	movs	r2, #2
 8000ad2:	701a      	strb	r2, [r3, #0]
    _adc_reset_s(adcp);
 8000ad4:	9b01      	ldr	r3, [sp, #4]
 8000ad6:	3314      	adds	r3, #20
 8000ad8:	f06f 0101 	mvn.w	r1, #1
 8000adc:	4618      	mov	r0, r3
 8000ade:	f7ff feaf 	bl	8000840 <osalThreadResumeS>
  }
  osalSysUnlock();
 8000ae2:	f7ff fe95 	bl	8000810 <osalSysUnlock.lto_priv.2>
}
 8000ae6:	bf00      	nop
 8000ae8:	b003      	add	sp, #12
 8000aea:	f85d fb04 	ldr.w	pc, [sp], #4
 8000aee:	bf00      	nop
 8000af0:	08006980 	.word	0x08006980
	...

08000b00 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8000b00:	b500      	push	{lr}
 8000b02:	b087      	sub	sp, #28
 8000b04:	9003      	str	r0, [sp, #12]
 8000b06:	9102      	str	r1, [sp, #8]
 8000b08:	9201      	str	r2, [sp, #4]
 8000b0a:	9300      	str	r3, [sp, #0]
  msg_t msg;

  osalSysLock();
 8000b0c:	f7ff fe78 	bl	8000800 <osalSysLock.lto_priv.2>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
 8000b10:	9b03      	ldr	r3, [sp, #12]
 8000b12:	695b      	ldr	r3, [r3, #20]
 8000b14:	2b00      	cmp	r3, #0
 8000b16:	bf14      	ite	ne
 8000b18:	2301      	movne	r3, #1
 8000b1a:	2300      	moveq	r3, #0
 8000b1c:	b2db      	uxtb	r3, r3
 8000b1e:	2b00      	cmp	r3, #0
 8000b20:	d002      	beq.n	8000b28 <adcConvert+0x28>
 8000b22:	480b      	ldr	r0, [pc, #44]	@ (8000b50 <adcConvert+0x50>)
 8000b24:	f002 fffc 	bl	8003b20 <chSysHalt>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000b28:	9b00      	ldr	r3, [sp, #0]
 8000b2a:	9a01      	ldr	r2, [sp, #4]
 8000b2c:	9902      	ldr	r1, [sp, #8]
 8000b2e:	9803      	ldr	r0, [sp, #12]
 8000b30:	f7ff ff26 	bl	8000980 <adcStartConversionI>
  msg = osalThreadSuspendS(&adcp->thread);
 8000b34:	9b03      	ldr	r3, [sp, #12]
 8000b36:	3314      	adds	r3, #20
 8000b38:	4618      	mov	r0, r3
 8000b3a:	f7ff fe71 	bl	8000820 <osalThreadSuspendS>
 8000b3e:	9005      	str	r0, [sp, #20]
  osalSysUnlock();
 8000b40:	f7ff fe66 	bl	8000810 <osalSysUnlock.lto_priv.2>
  return msg;
 8000b44:	9b05      	ldr	r3, [sp, #20]
}
 8000b46:	4618      	mov	r0, r3
 8000b48:	b007      	add	sp, #28
 8000b4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b4e:	bf00      	nop
 8000b50:	08006994 	.word	0x08006994
	...

08000b60 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
 8000b60:	b500      	push	{lr}
 8000b62:	b083      	sub	sp, #12
 8000b64:	2330      	movs	r3, #48	@ 0x30
 8000b66:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000b68:	9b01      	ldr	r3, [sp, #4]
 8000b6a:	f383 8811 	msr	BASEPRI, r3
}
 8000b6e:	bf00      	nop
}
 8000b70:	bf00      	nop
  __dbg_check_lock();
 8000b72:	f003 f85d 	bl	8003c30 <__dbg_check_lock>
}
 8000b76:	bf00      	nop
 8000b78:	b003      	add	sp, #12
 8000b7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b7e:	bf00      	nop

08000b80 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
 8000b80:	b500      	push	{lr}
 8000b82:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8000b84:	f003 f87c 	bl	8003c80 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000b88:	4b12      	ldr	r3, [pc, #72]	@ (8000bd4 <chSysUnlock.lto_priv.3+0x54>)
 8000b8a:	681b      	ldr	r3, [r3, #0]
 8000b8c:	4a11      	ldr	r2, [pc, #68]	@ (8000bd4 <chSysUnlock.lto_priv.3+0x54>)
 8000b8e:	4293      	cmp	r3, r2
 8000b90:	bf14      	ite	ne
 8000b92:	2301      	movne	r3, #1
 8000b94:	2300      	moveq	r3, #0
 8000b96:	b2db      	uxtb	r3, r3
 8000b98:	2b00      	cmp	r3, #0
 8000b9a:	d00f      	beq.n	8000bbc <chSysUnlock.lto_priv.3+0x3c>
 8000b9c:	4b0d      	ldr	r3, [pc, #52]	@ (8000bd4 <chSysUnlock.lto_priv.3+0x54>)
 8000b9e:	68db      	ldr	r3, [r3, #12]
 8000ba0:	689a      	ldr	r2, [r3, #8]
 8000ba2:	4b0c      	ldr	r3, [pc, #48]	@ (8000bd4 <chSysUnlock.lto_priv.3+0x54>)
 8000ba4:	681b      	ldr	r3, [r3, #0]
 8000ba6:	689b      	ldr	r3, [r3, #8]
 8000ba8:	429a      	cmp	r2, r3
 8000baa:	bf34      	ite	cc
 8000bac:	2301      	movcc	r3, #1
 8000bae:	2300      	movcs	r3, #0
 8000bb0:	b2db      	uxtb	r3, r3
 8000bb2:	2b00      	cmp	r3, #0
 8000bb4:	d002      	beq.n	8000bbc <chSysUnlock.lto_priv.3+0x3c>
 8000bb6:	4808      	ldr	r0, [pc, #32]	@ (8000bd8 <chSysUnlock.lto_priv.3+0x58>)
 8000bb8:	f002 ffb2 	bl	8003b20 <chSysHalt>
 8000bbc:	2300      	movs	r3, #0
 8000bbe:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000bc0:	9b01      	ldr	r3, [sp, #4]
 8000bc2:	f383 8811 	msr	BASEPRI, r3
}
 8000bc6:	bf00      	nop
}
 8000bc8:	bf00      	nop
}
 8000bca:	bf00      	nop
 8000bcc:	b003      	add	sp, #12
 8000bce:	f85d fb04 	ldr.w	pc, [sp], #4
 8000bd2:	bf00      	nop
 8000bd4:	24000158 	.word	0x24000158
 8000bd8:	080069ac 	.word	0x080069ac
 8000bdc:	00000000 	.word	0x00000000

08000be0 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
 8000be0:	b508      	push	{r3, lr}
  chSysLock();
 8000be2:	f7ff ffbd 	bl	8000b60 <chSysLock.lto_priv.3>
}
 8000be6:	bf00      	nop
 8000be8:	bd08      	pop	{r3, pc}
 8000bea:	bf00      	nop
 8000bec:	0000      	movs	r0, r0
	...

08000bf0 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
 8000bf0:	b508      	push	{r3, lr}
  chSysUnlock();
 8000bf2:	f7ff ffc5 	bl	8000b80 <chSysUnlock.lto_priv.3>
}
 8000bf6:	bf00      	nop
 8000bf8:	bd08      	pop	{r3, pc}
 8000bfa:	bf00      	nop
 8000bfc:	0000      	movs	r0, r0
	...

08000c00 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8000c00:	b508      	push	{r3, lr}

  gpt_lld_init();
 8000c02:	f002 fd25 	bl	8003650 <gpt_lld_init>
}
 8000c06:	bf00      	nop
 8000c08:	bd08      	pop	{r3, pc}
 8000c0a:	bf00      	nop
 8000c0c:	0000      	movs	r0, r0
	...

08000c10 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8000c10:	b082      	sub	sp, #8
 8000c12:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 8000c14:	9b01      	ldr	r3, [sp, #4]
 8000c16:	2201      	movs	r2, #1
 8000c18:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 8000c1a:	9b01      	ldr	r3, [sp, #4]
 8000c1c:	2200      	movs	r2, #0
 8000c1e:	605a      	str	r2, [r3, #4]
}
 8000c20:	bf00      	nop
 8000c22:	b002      	add	sp, #8
 8000c24:	4770      	bx	lr
 8000c26:	bf00      	nop
	...

08000c30 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8000c30:	b500      	push	{lr}
 8000c32:	b085      	sub	sp, #20
 8000c34:	9001      	str	r0, [sp, #4]
 8000c36:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 8000c38:	9b01      	ldr	r3, [sp, #4]
 8000c3a:	2b00      	cmp	r3, #0
 8000c3c:	bf0c      	ite	eq
 8000c3e:	2301      	moveq	r3, #1
 8000c40:	2300      	movne	r3, #0
 8000c42:	b2db      	uxtb	r3, r3
 8000c44:	2b00      	cmp	r3, #0
 8000c46:	d107      	bne.n	8000c58 <gptStart+0x28>
 8000c48:	9b00      	ldr	r3, [sp, #0]
 8000c4a:	2b00      	cmp	r3, #0
 8000c4c:	bf0c      	ite	eq
 8000c4e:	2301      	moveq	r3, #1
 8000c50:	2300      	movne	r3, #0
 8000c52:	b2db      	uxtb	r3, r3
 8000c54:	2b00      	cmp	r3, #0
 8000c56:	d002      	beq.n	8000c5e <gptStart+0x2e>
 8000c58:	4819      	ldr	r0, [pc, #100]	@ (8000cc0 <gptStart+0x90>)
 8000c5a:	f002 ff61 	bl	8003b20 <chSysHalt>

  osalSysLock();
 8000c5e:	f7ff ffbf 	bl	8000be0 <osalSysLock.lto_priv.3>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
 8000c62:	9b01      	ldr	r3, [sp, #4]
 8000c64:	781b      	ldrb	r3, [r3, #0]
 8000c66:	2b01      	cmp	r3, #1
 8000c68:	bf14      	ite	ne
 8000c6a:	2301      	movne	r3, #1
 8000c6c:	2300      	moveq	r3, #0
 8000c6e:	b2db      	uxtb	r3, r3
 8000c70:	2b00      	cmp	r3, #0
 8000c72:	d00b      	beq.n	8000c8c <gptStart+0x5c>
 8000c74:	9b01      	ldr	r3, [sp, #4]
 8000c76:	781b      	ldrb	r3, [r3, #0]
 8000c78:	2b02      	cmp	r3, #2
 8000c7a:	bf14      	ite	ne
 8000c7c:	2301      	movne	r3, #1
 8000c7e:	2300      	moveq	r3, #0
 8000c80:	b2db      	uxtb	r3, r3
 8000c82:	2b00      	cmp	r3, #0
 8000c84:	d002      	beq.n	8000c8c <gptStart+0x5c>
 8000c86:	480e      	ldr	r0, [pc, #56]	@ (8000cc0 <gptStart+0x90>)
 8000c88:	f002 ff4a 	bl	8003b20 <chSysHalt>
              "invalid state");

  gptp->config = config;
 8000c8c:	9b01      	ldr	r3, [sp, #4]
 8000c8e:	9a00      	ldr	r2, [sp, #0]
 8000c90:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 8000c92:	9801      	ldr	r0, [sp, #4]
 8000c94:	f002 fcec 	bl	8003670 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 8000c98:	2300      	movs	r3, #0
 8000c9a:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 8000c9c:	9b03      	ldr	r3, [sp, #12]
 8000c9e:	2b00      	cmp	r3, #0
 8000ca0:	d103      	bne.n	8000caa <gptStart+0x7a>
    gptp->state = GPT_READY;
 8000ca2:	9b01      	ldr	r3, [sp, #4]
 8000ca4:	2202      	movs	r2, #2
 8000ca6:	701a      	strb	r2, [r3, #0]
 8000ca8:	e002      	b.n	8000cb0 <gptStart+0x80>
  }
  else {
    gptp->state = GPT_STOP;
 8000caa:	9b01      	ldr	r3, [sp, #4]
 8000cac:	2201      	movs	r2, #1
 8000cae:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000cb0:	f7ff ff9e 	bl	8000bf0 <osalSysUnlock.lto_priv.3>

  return msg;
 8000cb4:	9b03      	ldr	r3, [sp, #12]
}
 8000cb6:	4618      	mov	r0, r3
 8000cb8:	b005      	add	sp, #20
 8000cba:	f85d fb04 	ldr.w	pc, [sp], #4
 8000cbe:	bf00      	nop
 8000cc0:	080069a0 	.word	0x080069a0
	...

08000cd0 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 8000cd0:	b500      	push	{lr}
 8000cd2:	b083      	sub	sp, #12
 8000cd4:	9001      	str	r0, [sp, #4]
 8000cd6:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8000cd8:	f7ff ff82 	bl	8000be0 <osalSysLock.lto_priv.3>
  gptStartContinuousI(gptp, interval);
 8000cdc:	9900      	ldr	r1, [sp, #0]
 8000cde:	9801      	ldr	r0, [sp, #4]
 8000ce0:	f000 f806 	bl	8000cf0 <gptStartContinuousI>
  osalSysUnlock();
 8000ce4:	f7ff ff84 	bl	8000bf0 <osalSysUnlock.lto_priv.3>
}
 8000ce8:	bf00      	nop
 8000cea:	b003      	add	sp, #12
 8000cec:	f85d fb04 	ldr.w	pc, [sp], #4

08000cf0 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 8000cf0:	b500      	push	{lr}
 8000cf2:	b083      	sub	sp, #12
 8000cf4:	9001      	str	r0, [sp, #4]
 8000cf6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8000cf8:	f003 f8b2 	bl	8003e60 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000cfc:	9b01      	ldr	r3, [sp, #4]
 8000cfe:	2b00      	cmp	r3, #0
 8000d00:	bf0c      	ite	eq
 8000d02:	2301      	moveq	r3, #1
 8000d04:	2300      	movne	r3, #0
 8000d06:	b2db      	uxtb	r3, r3
 8000d08:	2b00      	cmp	r3, #0
 8000d0a:	d002      	beq.n	8000d12 <gptStartContinuousI+0x22>
 8000d0c:	480c      	ldr	r0, [pc, #48]	@ (8000d40 <gptStartContinuousI+0x50>)
 8000d0e:	f002 ff07 	bl	8003b20 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
 8000d12:	9b01      	ldr	r3, [sp, #4]
 8000d14:	781b      	ldrb	r3, [r3, #0]
 8000d16:	2b02      	cmp	r3, #2
 8000d18:	bf14      	ite	ne
 8000d1a:	2301      	movne	r3, #1
 8000d1c:	2300      	moveq	r3, #0
 8000d1e:	b2db      	uxtb	r3, r3
 8000d20:	2b00      	cmp	r3, #0
 8000d22:	d002      	beq.n	8000d2a <gptStartContinuousI+0x3a>
 8000d24:	4806      	ldr	r0, [pc, #24]	@ (8000d40 <gptStartContinuousI+0x50>)
 8000d26:	f002 fefb 	bl	8003b20 <chSysHalt>
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000d2a:	9b01      	ldr	r3, [sp, #4]
 8000d2c:	2203      	movs	r2, #3
 8000d2e:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 8000d30:	9900      	ldr	r1, [sp, #0]
 8000d32:	9801      	ldr	r0, [sp, #4]
 8000d34:	f002 fcfc 	bl	8003730 <gpt_lld_start_timer>
}
 8000d38:	bf00      	nop
 8000d3a:	b003      	add	sp, #12
 8000d3c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d40:	080069b8 	.word	0x080069b8
	...

08000d50 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000d50:	b500      	push	{lr}
 8000d52:	b083      	sub	sp, #12
 8000d54:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8000d56:	f7ff ff43 	bl	8000be0 <osalSysLock.lto_priv.3>
  gptStopTimerI(gptp);
 8000d5a:	9801      	ldr	r0, [sp, #4]
 8000d5c:	f000 f808 	bl	8000d70 <gptStopTimerI>
  osalSysUnlock();
 8000d60:	f7ff ff46 	bl	8000bf0 <osalSysUnlock.lto_priv.3>
}
 8000d64:	bf00      	nop
 8000d66:	b003      	add	sp, #12
 8000d68:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d6c:	0000      	movs	r0, r0
	...

08000d70 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000d70:	b500      	push	{lr}
 8000d72:	b083      	sub	sp, #12
 8000d74:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8000d76:	f003 f873 	bl	8003e60 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000d7a:	9b01      	ldr	r3, [sp, #4]
 8000d7c:	2b00      	cmp	r3, #0
 8000d7e:	bf0c      	ite	eq
 8000d80:	2301      	moveq	r3, #1
 8000d82:	2300      	movne	r3, #0
 8000d84:	b2db      	uxtb	r3, r3
 8000d86:	2b00      	cmp	r3, #0
 8000d88:	d002      	beq.n	8000d90 <gptStopTimerI+0x20>
 8000d8a:	4818      	ldr	r0, [pc, #96]	@ (8000dec <gptStopTimerI+0x7c>)
 8000d8c:	f002 fec8 	bl	8003b20 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
 8000d90:	9b01      	ldr	r3, [sp, #4]
 8000d92:	781b      	ldrb	r3, [r3, #0]
 8000d94:	2b02      	cmp	r3, #2
 8000d96:	bf14      	ite	ne
 8000d98:	2301      	movne	r3, #1
 8000d9a:	2300      	moveq	r3, #0
 8000d9c:	b2db      	uxtb	r3, r3
 8000d9e:	2b00      	cmp	r3, #0
 8000da0:	d00a      	beq.n	8000db8 <gptStopTimerI+0x48>
 8000da2:	9b01      	ldr	r3, [sp, #4]
 8000da4:	781b      	ldrb	r3, [r3, #0]
 8000da6:	2b03      	cmp	r3, #3
 8000da8:	bf14      	ite	ne
 8000daa:	2301      	movne	r3, #1
 8000dac:	2300      	moveq	r3, #0
 8000dae:	b2db      	uxtb	r3, r3
 8000db0:	2b00      	cmp	r3, #0
 8000db2:	d001      	beq.n	8000db8 <gptStopTimerI+0x48>
 8000db4:	2301      	movs	r3, #1
 8000db6:	e000      	b.n	8000dba <gptStopTimerI+0x4a>
 8000db8:	2300      	movs	r3, #0
 8000dba:	2b00      	cmp	r3, #0
 8000dbc:	d00b      	beq.n	8000dd6 <gptStopTimerI+0x66>
 8000dbe:	9b01      	ldr	r3, [sp, #4]
 8000dc0:	781b      	ldrb	r3, [r3, #0]
 8000dc2:	2b04      	cmp	r3, #4
 8000dc4:	bf14      	ite	ne
 8000dc6:	2301      	movne	r3, #1
 8000dc8:	2300      	moveq	r3, #0
 8000dca:	b2db      	uxtb	r3, r3
 8000dcc:	2b00      	cmp	r3, #0
 8000dce:	d002      	beq.n	8000dd6 <gptStopTimerI+0x66>
 8000dd0:	4806      	ldr	r0, [pc, #24]	@ (8000dec <gptStopTimerI+0x7c>)
 8000dd2:	f002 fea5 	bl	8003b20 <chSysHalt>
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000dd6:	9b01      	ldr	r3, [sp, #4]
 8000dd8:	2202      	movs	r2, #2
 8000dda:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000ddc:	9801      	ldr	r0, [sp, #4]
 8000dde:	f002 fccf 	bl	8003780 <gpt_lld_stop_timer>
}
 8000de2:	bf00      	nop
 8000de4:	b003      	add	sp, #12
 8000de6:	f85d fb04 	ldr.w	pc, [sp], #4
 8000dea:	bf00      	nop
 8000dec:	080069cc 	.word	0x080069cc

08000df0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000df0:	b082      	sub	sp, #8
 8000df2:	9001      	str	r0, [sp, #4]
 8000df4:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8000df6:	9b00      	ldr	r3, [sp, #0]
 8000df8:	b2db      	uxtb	r3, r3
 8000dfa:	4a11      	ldr	r2, [pc, #68]	@ (8000e40 <nvicEnableVector+0x50>)
 8000dfc:	011b      	lsls	r3, r3, #4
 8000dfe:	b2d9      	uxtb	r1, r3
 8000e00:	9b01      	ldr	r3, [sp, #4]
 8000e02:	4413      	add	r3, r2
 8000e04:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8000e08:	460a      	mov	r2, r1
 8000e0a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000e0c:	9b01      	ldr	r3, [sp, #4]
 8000e0e:	f003 021f 	and.w	r2, r3, #31
 8000e12:	490b      	ldr	r1, [pc, #44]	@ (8000e40 <nvicEnableVector+0x50>)
 8000e14:	9b01      	ldr	r3, [sp, #4]
 8000e16:	095b      	lsrs	r3, r3, #5
 8000e18:	2001      	movs	r0, #1
 8000e1a:	fa00 f202 	lsl.w	r2, r0, r2
 8000e1e:	3360      	adds	r3, #96	@ 0x60
 8000e20:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000e24:	9b01      	ldr	r3, [sp, #4]
 8000e26:	f003 021f 	and.w	r2, r3, #31
 8000e2a:	4905      	ldr	r1, [pc, #20]	@ (8000e40 <nvicEnableVector+0x50>)
 8000e2c:	9b01      	ldr	r3, [sp, #4]
 8000e2e:	095b      	lsrs	r3, r3, #5
 8000e30:	2001      	movs	r0, #1
 8000e32:	fa00 f202 	lsl.w	r2, r0, r2
 8000e36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000e3a:	bf00      	nop
 8000e3c:	b002      	add	sp, #8
 8000e3e:	4770      	bx	lr
 8000e40:	e000e100 	.word	0xe000e100
	...

08000e50 <exti0_irq_init>:

static inline void exti0_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
 8000e50:	bf00      	nop
 8000e52:	4770      	bx	lr
	...

08000e60 <exti1_irq_init>:

static inline void exti1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
 8000e60:	bf00      	nop
 8000e62:	4770      	bx	lr
	...

08000e70 <exti2_irq_init>:

static inline void exti2_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
 8000e70:	bf00      	nop
 8000e72:	4770      	bx	lr
	...

08000e80 <exti3_irq_init>:

static inline void exti3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
 8000e80:	bf00      	nop
 8000e82:	4770      	bx	lr
	...

08000e90 <exti4_irq_init>:

static inline void exti4_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
 8000e90:	bf00      	nop
 8000e92:	4770      	bx	lr
	...

08000ea0 <exti5_9_irq_init>:

static inline void exti5_9_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
 8000ea0:	bf00      	nop
 8000ea2:	4770      	bx	lr
	...

08000eb0 <exti10_15_irq_init>:

static inline void exti10_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
 8000eb0:	bf00      	nop
 8000eb2:	4770      	bx	lr
	...

08000ec0 <exti16_irq_init>:

static inline void exti16_irq_init(void) {
#if defined(STM32_EXTI16_IS_USED)
  nvicEnableVector(STM32_EXTI16_NUMBER, STM32_IRQ_EXTI16_PRIORITY);
#endif
}
 8000ec0:	bf00      	nop
 8000ec2:	4770      	bx	lr
	...

08000ed0 <exti17_irq_init>:

static inline void exti17_irq_init(void) {
#if defined(STM32_EXTI17_IS_USED)
  nvicEnableVector(STM32_EXTI17_NUMBER, STM32_IRQ_EXTI17_PRIORITY);
#endif
}
 8000ed0:	bf00      	nop
 8000ed2:	4770      	bx	lr
	...

08000ee0 <exti18_irq_init>:

static inline void exti18_irq_init(void) {
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
 8000ee0:	bf00      	nop
 8000ee2:	4770      	bx	lr
	...

08000ef0 <exti19_irq_init>:

static inline void exti19_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
 8000ef0:	bf00      	nop
 8000ef2:	4770      	bx	lr
	...

08000f00 <exti20_exti21_irq_init>:

static inline void exti20_exti21_irq_init(void) {
#if defined(STM32_EXTI20_IS_USED) || defined(STM32_EXTI21_IS_USED)
  nvicEnableVector(STM32_EXTI20_21_NUMBER, STM32_IRQ_EXTI20_21_PRIORITY);
#endif
}
 8000f00:	bf00      	nop
 8000f02:	4770      	bx	lr
	...

08000f10 <fdcan1_irq_init>:

static inline void fdcan1_irq_init(void) {
#if STM32_FDCAN1_IS_USED
  nvicEnableVector(STM32_FDCAN1_IT0_NUMBER, STM32_IRQ_FDCAN1_PRIORITY);
#endif
}
 8000f10:	bf00      	nop
 8000f12:	4770      	bx	lr
	...

08000f20 <fdcan2_irq_init>:

static inline void fdcan2_irq_init(void) {
#if STM32_FDCAN2_IS_USED
  nvicEnableVector(STM32_FDCAN2_IT0_NUMBER, STM32_IRQ_FDCAN2_PRIORITY);
#endif
}
 8000f20:	bf00      	nop
 8000f22:	4770      	bx	lr
	...

08000f30 <fdcan3_irq_init>:

static inline void fdcan3_irq_init(void) {
#if STM32_FDCAN3_IS_USED
  nvicEnableVector(STM32_FDCAN3_IT0_NUMBER, STM32_IRQ_FDCAN3_PRIORITY);
#endif
}
 8000f30:	bf00      	nop
 8000f32:	4770      	bx	lr
	...

08000f40 <quadspi1_irq_init>:

static inline void quadspi1_irq_init(void) {
#if STM32_QUADSPI1_IS_USED
  nvicEnableVector(STM32_QUADSPI1_NUMBER, STM32_IRQ_QUADSPI1_PRIORITY);
#endif
}
 8000f40:	bf00      	nop
 8000f42:	4770      	bx	lr
	...

08000f50 <sdmmc1_irq_init>:

static inline void sdmmc1_irq_init(void) {
#if STM32_SDMMC1_IS_USED
  nvicEnableVector(STM32_SDMMC1_NUMBER, STM32_IRQ_SDMMC1_PRIORITY);
#endif
}
 8000f50:	bf00      	nop
 8000f52:	4770      	bx	lr
	...

08000f60 <sdmmc2_irq_init>:

static inline void sdmmc2_irq_init(void) {
#if STM32_SDMMC2_IS_USED
  nvicEnableVector(STM32_SDMMC2_NUMBER, STM32_IRQ_SDMMC2_PRIORITY);
#endif
}
 8000f60:	bf00      	nop
 8000f62:	4770      	bx	lr
	...

08000f70 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000f70:	bf00      	nop
 8000f72:	4770      	bx	lr
	...

08000f80 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000f80:	bf00      	nop
 8000f82:	4770      	bx	lr
	...

08000f90 <usart3_irq_init>:

static inline void usart3_irq_init(void) {
#if defined(STM32_USART3_IS_USED)
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
#endif
}
 8000f90:	bf00      	nop
 8000f92:	4770      	bx	lr
	...

08000fa0 <uart4_irq_init>:

static inline void uart4_irq_init(void) {
#if defined(STM32_UART4_IS_USED)
  nvicEnableVector(STM32_UART4_NUMBER, STM32_IRQ_UART4_PRIORITY);
#endif
}
 8000fa0:	bf00      	nop
 8000fa2:	4770      	bx	lr
	...

08000fb0 <uart5_irq_init>:

static inline void uart5_irq_init(void) {
#if defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_IRQ_UART5_PRIORITY);
#endif
}
 8000fb0:	bf00      	nop
 8000fb2:	4770      	bx	lr
	...

08000fc0 <usart6_irq_init>:

static inline void usart6_irq_init(void) {
#if defined(STM32_USART6_IS_USED)
  nvicEnableVector(STM32_USART6_NUMBER, STM32_IRQ_USART6_PRIORITY);
#endif
}
 8000fc0:	bf00      	nop
 8000fc2:	4770      	bx	lr
	...

08000fd0 <uart7_irq_init>:

static inline void uart7_irq_init(void) {
#if defined(STM32_UART7_IS_USED)
  nvicEnableVector(STM32_UART7_NUMBER, STM32_IRQ_UART7_PRIORITY);
#endif
}
 8000fd0:	bf00      	nop
 8000fd2:	4770      	bx	lr
	...

08000fe0 <uart8_irq_init>:

static inline void uart8_irq_init(void) {
#if defined(STM32_UART8_IS_USED)
  nvicEnableVector(STM32_UART8_NUMBER, STM32_IRQ_UART8_PRIORITY);
#endif
}
 8000fe0:	bf00      	nop
 8000fe2:	4770      	bx	lr
	...

08000ff0 <uart9_irq_init>:

static inline void uart9_irq_init(void) {
#if defined(STM32_UART9_IS_USED)
  nvicEnableVector(STM32_UART9_NUMBER, STM32_IRQ_UART9_PRIORITY);
#endif
}
 8000ff0:	bf00      	nop
 8000ff2:	4770      	bx	lr
	...

08001000 <usart10_irq_init>:

static inline void usart10_irq_init(void) {
#if defined(STM32_USART10_IS_USED)
  nvicEnableVector(STM32_USART10_NUMBER, STM32_IRQ_USART10_PRIORITY);
#endif
}
 8001000:	bf00      	nop
 8001002:	4770      	bx	lr
	...

08001010 <lpuart1_irq_init>:

static inline void lpuart1_irq_init(void) {
#if defined(STM32_LPUART1_IS_USED)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_IRQ_LPUART1_PRIORITY);
#endif
}
 8001010:	bf00      	nop
 8001012:	4770      	bx	lr
	...

08001020 <tim1_irq_init>:
static inline void tim1_irq_init(void) {
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_IRQ_TIM1_UP_PRIORITY);
  nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8001020:	bf00      	nop
 8001022:	4770      	bx	lr
	...

08001030 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8001030:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8001032:	2107      	movs	r1, #7
 8001034:	201c      	movs	r0, #28
 8001036:	f7ff fedb 	bl	8000df0 <nvicEnableVector>
#endif
}
 800103a:	bf00      	nop
 800103c:	bd08      	pop	{r3, pc}
 800103e:	bf00      	nop

08001040 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8001040:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001042:	4808      	ldr	r0, [pc, #32]	@ (8001064 <VectorB0+0x24>)
 8001044:	f003 f82c 	bl	80040a0 <__trace_isr_enter>
 8001048:	f002 fe92 	bl	8003d70 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 800104c:	f002 fa78 	bl	8003540 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001050:	f002 fec6 	bl	8003de0 <__dbg_check_leave_isr>
 8001054:	4803      	ldr	r0, [pc, #12]	@ (8001064 <VectorB0+0x24>)
 8001056:	f003 f863 	bl	8004120 <__trace_isr_leave>
 800105a:	f005 fae1 	bl	8006620 <__port_irq_epilogue>
}
 800105e:	bf00      	nop
 8001060:	bd08      	pop	{r3, pc}
 8001062:	bf00      	nop
 8001064:	080069dc 	.word	0x080069dc
	...

08001070 <tim3_irq_init>:

static inline void tim3_irq_init(void) {
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
 8001070:	bf00      	nop
 8001072:	4770      	bx	lr
	...

08001080 <tim4_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim4_irq_init(void) {
 8001080:	b508      	push	{r3, lr}
#if defined(STM32_TIM4_IS_USED)
  nvicEnableVector(STM32_TIM4_NUMBER, STM32_IRQ_TIM4_PRIORITY);
 8001082:	2107      	movs	r1, #7
 8001084:	201e      	movs	r0, #30
 8001086:	f7ff feb3 	bl	8000df0 <nvicEnableVector>
#endif
}
 800108a:	bf00      	nop
 800108c:	bd08      	pop	{r3, pc}
 800108e:	bf00      	nop

08001090 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8001090:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001092:	4808      	ldr	r0, [pc, #32]	@ (80010b4 <VectorB8+0x24>)
 8001094:	f003 f804 	bl	80040a0 <__trace_isr_enter>
 8001098:	f002 fe6a 	bl	8003d70 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM4
  gpt_lld_serve_interrupt(&GPTD4);
 800109c:	4806      	ldr	r0, [pc, #24]	@ (80010b8 <VectorB8+0x28>)
 800109e:	f002 fb87 	bl	80037b0 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM4
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 80010a2:	f002 fe9d 	bl	8003de0 <__dbg_check_leave_isr>
 80010a6:	4803      	ldr	r0, [pc, #12]	@ (80010b4 <VectorB8+0x24>)
 80010a8:	f003 f83a 	bl	8004120 <__trace_isr_leave>
 80010ac:	f005 fab8 	bl	8006620 <__port_irq_epilogue>
}
 80010b0:	bf00      	nop
 80010b2:	bd08      	pop	{r3, pc}
 80010b4:	080069e8 	.word	0x080069e8
 80010b8:	24000138 	.word	0x24000138
 80010bc:	00000000 	.word	0x00000000

080010c0 <tim5_irq_init>:

static inline void tim5_irq_init(void) {
#if defined(STM32_TIM5_IS_USED)
  nvicEnableVector(STM32_TIM5_NUMBER, STM32_IRQ_TIM5_PRIORITY);
#endif
}
 80010c0:	bf00      	nop
 80010c2:	4770      	bx	lr
	...

080010d0 <tim6_irq_init>:

static inline void tim6_irq_init(void) {
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
#endif
}
 80010d0:	bf00      	nop
 80010d2:	4770      	bx	lr
	...

080010e0 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 80010e0:	bf00      	nop
 80010e2:	4770      	bx	lr
	...

080010f0 <tim8_tim12_tim13_tim14_irq_init>:
#endif
#if defined(STM32_TIM8_IS_USED)
  nvicEnableVector(STM32_TIM8_CC_NUMBER,
                   STM32_IRQ_TIM8_CC_PRIORITY);
#endif
}
 80010f0:	bf00      	nop
 80010f2:	4770      	bx	lr
	...

08001100 <tim15_irq_init>:

static inline void tim15_irq_init(void) {
#if defined(STM32_TIM15_IS_USED)
  nvicEnableVector(STM32_TIM15_NUMBER, STM32_IRQ_TIM15_PRIORITY);
#endif
}
 8001100:	bf00      	nop
 8001102:	4770      	bx	lr
	...

08001110 <tim16_irq_init>:

static inline void tim16_irq_init(void) {
#if defined(STM32_TIM16_IS_USED)
  nvicEnableVector(STM32_TIM16_NUMBER, STM32_IRQ_TIM16_PRIORITY);
#endif
}
 8001110:	bf00      	nop
 8001112:	4770      	bx	lr
	...

08001120 <tim17_irq_init>:

static inline void tim17_irq_init(void) {
#if defined(STM32_TIM17_IS_USED)
  nvicEnableVector(STM32_TIM17_NUMBER, STM32_IRQ_TIM17_PRIORITY);
#endif
}
 8001120:	bf00      	nop
 8001122:	4770      	bx	lr
	...

08001130 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8001130:	b508      	push	{r3, lr}

  exti0_irq_init();
 8001132:	f7ff fe8d 	bl	8000e50 <exti0_irq_init>
  exti1_irq_init();
 8001136:	f7ff fe93 	bl	8000e60 <exti1_irq_init>
  exti2_irq_init();
 800113a:	f7ff fe99 	bl	8000e70 <exti2_irq_init>
  exti3_irq_init();
 800113e:	f7ff fe9f 	bl	8000e80 <exti3_irq_init>
  exti4_irq_init();
 8001142:	f7ff fea5 	bl	8000e90 <exti4_irq_init>
  exti5_9_irq_init();
 8001146:	f7ff feab 	bl	8000ea0 <exti5_9_irq_init>
  exti10_15_irq_init();
 800114a:	f7ff feb1 	bl	8000eb0 <exti10_15_irq_init>
  exti16_irq_init();
 800114e:	f7ff feb7 	bl	8000ec0 <exti16_irq_init>
  exti17_irq_init();
 8001152:	f7ff febd 	bl	8000ed0 <exti17_irq_init>
  exti18_irq_init();
 8001156:	f7ff fec3 	bl	8000ee0 <exti18_irq_init>
  exti19_irq_init();
 800115a:	f7ff fec9 	bl	8000ef0 <exti19_irq_init>
  exti20_exti21_irq_init();
 800115e:	f7ff fecf 	bl	8000f00 <exti20_exti21_irq_init>

  fdcan1_irq_init();
 8001162:	f7ff fed5 	bl	8000f10 <fdcan1_irq_init>
  fdcan2_irq_init();
 8001166:	f7ff fedb 	bl	8000f20 <fdcan2_irq_init>
  fdcan3_irq_init();
 800116a:	f7ff fee1 	bl	8000f30 <fdcan3_irq_init>

  mdma_irq_init();
 800116e:	2109      	movs	r1, #9
 8001170:	207a      	movs	r0, #122	@ 0x7a
 8001172:	f7ff fe3d 	bl	8000df0 <nvicEnableVector>

#if defined(HAL_LLD_TYPE1_H)
  quadspi1_irq_init();
 8001176:	f7ff fee3 	bl	8000f40 <quadspi1_irq_init>
#elif defined(HAL_LLD_TYPE2_H)
  octospi1_irq_init();
  octospi2_irq_init();
#endif

  sdmmc1_irq_init();
 800117a:	f7ff fee9 	bl	8000f50 <sdmmc1_irq_init>
  sdmmc2_irq_init();
 800117e:	f7ff feef 	bl	8000f60 <sdmmc2_irq_init>

  tim1_irq_init();
 8001182:	f7ff ff4d 	bl	8001020 <tim1_irq_init>
  tim2_irq_init();
 8001186:	f7ff ff53 	bl	8001030 <tim2_irq_init>
  tim3_irq_init();
 800118a:	f7ff ff71 	bl	8001070 <tim3_irq_init>
  tim4_irq_init();
 800118e:	f7ff ff77 	bl	8001080 <tim4_irq_init>
  tim5_irq_init();
 8001192:	f7ff ff95 	bl	80010c0 <tim5_irq_init>
  tim6_irq_init();
 8001196:	f7ff ff9b 	bl	80010d0 <tim6_irq_init>
  tim7_irq_init();
 800119a:	f7ff ffa1 	bl	80010e0 <tim7_irq_init>
  tim8_tim12_tim13_tim14_irq_init();
 800119e:	f7ff ffa7 	bl	80010f0 <tim8_tim12_tim13_tim14_irq_init>
  tim15_irq_init();
 80011a2:	f7ff ffad 	bl	8001100 <tim15_irq_init>
  tim16_irq_init();
 80011a6:	f7ff ffb3 	bl	8001110 <tim16_irq_init>
  tim17_irq_init();
 80011aa:	f7ff ffb9 	bl	8001120 <tim17_irq_init>

  usart1_irq_init();
 80011ae:	f7ff fedf 	bl	8000f70 <usart1_irq_init>
  usart2_irq_init();
 80011b2:	f7ff fee5 	bl	8000f80 <usart2_irq_init>
  usart3_irq_init();
 80011b6:	f7ff feeb 	bl	8000f90 <usart3_irq_init>
  uart4_irq_init();
 80011ba:	f7ff fef1 	bl	8000fa0 <uart4_irq_init>
  uart5_irq_init();
 80011be:	f7ff fef7 	bl	8000fb0 <uart5_irq_init>
  usart6_irq_init();
 80011c2:	f7ff fefd 	bl	8000fc0 <usart6_irq_init>
  uart7_irq_init();
 80011c6:	f7ff ff03 	bl	8000fd0 <uart7_irq_init>
  uart8_irq_init();
 80011ca:	f7ff ff09 	bl	8000fe0 <uart8_irq_init>
  uart9_irq_init();
 80011ce:	f7ff ff0f 	bl	8000ff0 <uart9_irq_init>
  usart10_irq_init();
 80011d2:	f7ff ff15 	bl	8001000 <usart10_irq_init>
  lpuart1_irq_init();
 80011d6:	f7ff ff1b 	bl	8001010 <lpuart1_irq_init>
}
 80011da:	bf00      	nop
 80011dc:	bd08      	pop	{r3, pc}
 80011de:	bf00      	nop

080011e0 <__rccResetAPB1L.lto_priv.0>:

/*===========================================================================*/
/* Driver macros.                                                            */
/*===========================================================================*/

__STATIC_INLINE void __rccResetAPB1L(uint32_t mask) {
 80011e0:	b082      	sub	sp, #8
 80011e2:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->APB1LRSTR |= mask;
 80011e4:	4b0b      	ldr	r3, [pc, #44]	@ (8001214 <__rccResetAPB1L.lto_priv.0+0x34>)
 80011e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 80011ea:	490a      	ldr	r1, [pc, #40]	@ (8001214 <__rccResetAPB1L.lto_priv.0+0x34>)
 80011ec:	9b01      	ldr	r3, [sp, #4]
 80011ee:	4313      	orrs	r3, r2
 80011f0:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
  RCC->APB1LRSTR &= ~mask;
 80011f4:	4b07      	ldr	r3, [pc, #28]	@ (8001214 <__rccResetAPB1L.lto_priv.0+0x34>)
 80011f6:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 80011fa:	9b01      	ldr	r3, [sp, #4]
 80011fc:	43db      	mvns	r3, r3
 80011fe:	4905      	ldr	r1, [pc, #20]	@ (8001214 <__rccResetAPB1L.lto_priv.0+0x34>)
 8001200:	4013      	ands	r3, r2
 8001202:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
  (void)RCC->APB1LRSTR;
 8001206:	4b03      	ldr	r3, [pc, #12]	@ (8001214 <__rccResetAPB1L.lto_priv.0+0x34>)
 8001208:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
}
 800120c:	bf00      	nop
 800120e:	b002      	add	sp, #8
 8001210:	4770      	bx	lr
 8001212:	bf00      	nop
 8001214:	58024400 	.word	0x58024400
	...

08001220 <__rccResetAPB1H>:

__STATIC_INLINE void __rccResetAPB1H(uint32_t mask) {
 8001220:	b082      	sub	sp, #8
 8001222:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->APB1HRSTR |= mask;
 8001224:	4b0b      	ldr	r3, [pc, #44]	@ (8001254 <__rccResetAPB1H+0x34>)
 8001226:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 800122a:	490a      	ldr	r1, [pc, #40]	@ (8001254 <__rccResetAPB1H+0x34>)
 800122c:	9b01      	ldr	r3, [sp, #4]
 800122e:	4313      	orrs	r3, r2
 8001230:	f8c1 3094 	str.w	r3, [r1, #148]	@ 0x94
  RCC->APB1HRSTR &= ~mask;
 8001234:	4b07      	ldr	r3, [pc, #28]	@ (8001254 <__rccResetAPB1H+0x34>)
 8001236:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 800123a:	9b01      	ldr	r3, [sp, #4]
 800123c:	43db      	mvns	r3, r3
 800123e:	4905      	ldr	r1, [pc, #20]	@ (8001254 <__rccResetAPB1H+0x34>)
 8001240:	4013      	ands	r3, r2
 8001242:	f8c1 3094 	str.w	r3, [r1, #148]	@ 0x94
  (void)RCC->APB1HRSTR;
 8001246:	4b03      	ldr	r3, [pc, #12]	@ (8001254 <__rccResetAPB1H+0x34>)
 8001248:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
}
 800124c:	bf00      	nop
 800124e:	b002      	add	sp, #8
 8001250:	4770      	bx	lr
 8001252:	bf00      	nop
 8001254:	58024400 	.word	0x58024400
	...

08001260 <__rccResetAPB2>:

__STATIC_INLINE void __rccResetAPB2(uint32_t mask) {
 8001260:	b082      	sub	sp, #8
 8001262:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->APB2RSTR |= mask;
 8001264:	4b0b      	ldr	r3, [pc, #44]	@ (8001294 <__rccResetAPB2+0x34>)
 8001266:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
 800126a:	490a      	ldr	r1, [pc, #40]	@ (8001294 <__rccResetAPB2+0x34>)
 800126c:	9b01      	ldr	r3, [sp, #4]
 800126e:	4313      	orrs	r3, r2
 8001270:	f8c1 3098 	str.w	r3, [r1, #152]	@ 0x98
  RCC->APB2RSTR &= ~mask;
 8001274:	4b07      	ldr	r3, [pc, #28]	@ (8001294 <__rccResetAPB2+0x34>)
 8001276:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
 800127a:	9b01      	ldr	r3, [sp, #4]
 800127c:	43db      	mvns	r3, r3
 800127e:	4905      	ldr	r1, [pc, #20]	@ (8001294 <__rccResetAPB2+0x34>)
 8001280:	4013      	ands	r3, r2
 8001282:	f8c1 3098 	str.w	r3, [r1, #152]	@ 0x98
  (void)RCC->APB2RSTR;
 8001286:	4b03      	ldr	r3, [pc, #12]	@ (8001294 <__rccResetAPB2+0x34>)
 8001288:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
}
 800128c:	bf00      	nop
 800128e:	b002      	add	sp, #8
 8001290:	4770      	bx	lr
 8001292:	bf00      	nop
 8001294:	58024400 	.word	0x58024400
	...

080012a0 <__rccResetAPB3>:

__STATIC_INLINE void __rccResetAPB3(uint32_t mask) {
 80012a0:	b082      	sub	sp, #8
 80012a2:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->APB3RSTR |= mask;
 80012a4:	4b0b      	ldr	r3, [pc, #44]	@ (80012d4 <__rccResetAPB3+0x34>)
 80012a6:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 80012aa:	490a      	ldr	r1, [pc, #40]	@ (80012d4 <__rccResetAPB3+0x34>)
 80012ac:	9b01      	ldr	r3, [sp, #4]
 80012ae:	4313      	orrs	r3, r2
 80012b0:	f8c1 308c 	str.w	r3, [r1, #140]	@ 0x8c
  RCC->APB3RSTR &= ~mask;
 80012b4:	4b07      	ldr	r3, [pc, #28]	@ (80012d4 <__rccResetAPB3+0x34>)
 80012b6:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 80012ba:	9b01      	ldr	r3, [sp, #4]
 80012bc:	43db      	mvns	r3, r3
 80012be:	4905      	ldr	r1, [pc, #20]	@ (80012d4 <__rccResetAPB3+0x34>)
 80012c0:	4013      	ands	r3, r2
 80012c2:	f8c1 308c 	str.w	r3, [r1, #140]	@ 0x8c
  (void)RCC->APB3RSTR;
 80012c6:	4b03      	ldr	r3, [pc, #12]	@ (80012d4 <__rccResetAPB3+0x34>)
 80012c8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
}
 80012cc:	bf00      	nop
 80012ce:	b002      	add	sp, #8
 80012d0:	4770      	bx	lr
 80012d2:	bf00      	nop
 80012d4:	58024400 	.word	0x58024400
	...

080012e0 <__rccResetAPB4>:

__STATIC_INLINE void __rccResetAPB4(uint32_t mask) {
 80012e0:	b082      	sub	sp, #8
 80012e2:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->APB4RSTR |= mask;
 80012e4:	4b0b      	ldr	r3, [pc, #44]	@ (8001314 <__rccResetAPB4+0x34>)
 80012e6:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
 80012ea:	490a      	ldr	r1, [pc, #40]	@ (8001314 <__rccResetAPB4+0x34>)
 80012ec:	9b01      	ldr	r3, [sp, #4]
 80012ee:	4313      	orrs	r3, r2
 80012f0:	f8c1 309c 	str.w	r3, [r1, #156]	@ 0x9c
  RCC->APB4RSTR &= ~mask;
 80012f4:	4b07      	ldr	r3, [pc, #28]	@ (8001314 <__rccResetAPB4+0x34>)
 80012f6:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
 80012fa:	9b01      	ldr	r3, [sp, #4]
 80012fc:	43db      	mvns	r3, r3
 80012fe:	4905      	ldr	r1, [pc, #20]	@ (8001314 <__rccResetAPB4+0x34>)
 8001300:	4013      	ands	r3, r2
 8001302:	f8c1 309c 	str.w	r3, [r1, #156]	@ 0x9c
  (void)RCC->APB4RSTR;
 8001306:	4b03      	ldr	r3, [pc, #12]	@ (8001314 <__rccResetAPB4+0x34>)
 8001308:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
}
 800130c:	bf00      	nop
 800130e:	b002      	add	sp, #8
 8001310:	4770      	bx	lr
 8001312:	bf00      	nop
 8001314:	58024400 	.word	0x58024400
	...

08001320 <__rccResetAHB1.lto_priv.0>:

__STATIC_INLINE void __rccResetAHB1(uint32_t mask) {
 8001320:	b082      	sub	sp, #8
 8001322:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->AHB1RSTR |= mask;
 8001324:	4b0b      	ldr	r3, [pc, #44]	@ (8001354 <__rccResetAHB1.lto_priv.0+0x34>)
 8001326:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 800132a:	490a      	ldr	r1, [pc, #40]	@ (8001354 <__rccResetAHB1.lto_priv.0+0x34>)
 800132c:	9b01      	ldr	r3, [sp, #4]
 800132e:	4313      	orrs	r3, r2
 8001330:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
  RCC->AHB1RSTR &= ~mask;
 8001334:	4b07      	ldr	r3, [pc, #28]	@ (8001354 <__rccResetAHB1.lto_priv.0+0x34>)
 8001336:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 800133a:	9b01      	ldr	r3, [sp, #4]
 800133c:	43db      	mvns	r3, r3
 800133e:	4905      	ldr	r1, [pc, #20]	@ (8001354 <__rccResetAHB1.lto_priv.0+0x34>)
 8001340:	4013      	ands	r3, r2
 8001342:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
  (void)RCC->AHB1RSTR;
 8001346:	4b03      	ldr	r3, [pc, #12]	@ (8001354 <__rccResetAHB1.lto_priv.0+0x34>)
 8001348:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
}
 800134c:	bf00      	nop
 800134e:	b002      	add	sp, #8
 8001350:	4770      	bx	lr
 8001352:	bf00      	nop
 8001354:	58024400 	.word	0x58024400
	...

08001360 <__rccResetAHB2>:

__STATIC_INLINE void __rccResetAHB2(uint32_t mask) {
 8001360:	b082      	sub	sp, #8
 8001362:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->AHB2RSTR |= mask;
 8001364:	4b0b      	ldr	r3, [pc, #44]	@ (8001394 <__rccResetAHB2+0x34>)
 8001366:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 800136a:	490a      	ldr	r1, [pc, #40]	@ (8001394 <__rccResetAHB2+0x34>)
 800136c:	9b01      	ldr	r3, [sp, #4]
 800136e:	4313      	orrs	r3, r2
 8001370:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
  RCC->AHB2RSTR &= ~mask;
 8001374:	4b07      	ldr	r3, [pc, #28]	@ (8001394 <__rccResetAHB2+0x34>)
 8001376:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 800137a:	9b01      	ldr	r3, [sp, #4]
 800137c:	43db      	mvns	r3, r3
 800137e:	4905      	ldr	r1, [pc, #20]	@ (8001394 <__rccResetAHB2+0x34>)
 8001380:	4013      	ands	r3, r2
 8001382:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
  (void)RCC->AHB2RSTR;
 8001386:	4b03      	ldr	r3, [pc, #12]	@ (8001394 <__rccResetAHB2+0x34>)
 8001388:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
}
 800138c:	bf00      	nop
 800138e:	b002      	add	sp, #8
 8001390:	4770      	bx	lr
 8001392:	bf00      	nop
 8001394:	58024400 	.word	0x58024400
	...

080013a0 <__rccResetAHB3>:

__STATIC_INLINE void __rccResetAHB3(uint32_t mask) {
 80013a0:	b082      	sub	sp, #8
 80013a2:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->AHB3RSTR |= mask;
 80013a4:	4b08      	ldr	r3, [pc, #32]	@ (80013c8 <__rccResetAHB3+0x28>)
 80013a6:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 80013a8:	4907      	ldr	r1, [pc, #28]	@ (80013c8 <__rccResetAHB3+0x28>)
 80013aa:	9b01      	ldr	r3, [sp, #4]
 80013ac:	4313      	orrs	r3, r2
 80013ae:	67cb      	str	r3, [r1, #124]	@ 0x7c
  RCC->AHB3RSTR &= ~mask;
 80013b0:	4b05      	ldr	r3, [pc, #20]	@ (80013c8 <__rccResetAHB3+0x28>)
 80013b2:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 80013b4:	9b01      	ldr	r3, [sp, #4]
 80013b6:	43db      	mvns	r3, r3
 80013b8:	4903      	ldr	r1, [pc, #12]	@ (80013c8 <__rccResetAHB3+0x28>)
 80013ba:	4013      	ands	r3, r2
 80013bc:	67cb      	str	r3, [r1, #124]	@ 0x7c
  (void)RCC->AHB3RSTR;
 80013be:	4b02      	ldr	r3, [pc, #8]	@ (80013c8 <__rccResetAHB3+0x28>)
 80013c0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
}
 80013c2:	bf00      	nop
 80013c4:	b002      	add	sp, #8
 80013c6:	4770      	bx	lr
 80013c8:	58024400 	.word	0x58024400
 80013cc:	00000000 	.word	0x00000000

080013d0 <__rccResetAHB4.lto_priv.0>:

__STATIC_INLINE void __rccResetAHB4(uint32_t mask) {
 80013d0:	b082      	sub	sp, #8
 80013d2:	9001      	str	r0, [sp, #4]

  /* Resetting the peripherals.*/
  RCC->AHB4RSTR |= mask;
 80013d4:	4b0b      	ldr	r3, [pc, #44]	@ (8001404 <__rccResetAHB4.lto_priv.0+0x34>)
 80013d6:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 80013da:	490a      	ldr	r1, [pc, #40]	@ (8001404 <__rccResetAHB4.lto_priv.0+0x34>)
 80013dc:	9b01      	ldr	r3, [sp, #4]
 80013de:	4313      	orrs	r3, r2
 80013e0:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  RCC->AHB4RSTR &= ~mask;
 80013e4:	4b07      	ldr	r3, [pc, #28]	@ (8001404 <__rccResetAHB4.lto_priv.0+0x34>)
 80013e6:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 80013ea:	9b01      	ldr	r3, [sp, #4]
 80013ec:	43db      	mvns	r3, r3
 80013ee:	4905      	ldr	r1, [pc, #20]	@ (8001404 <__rccResetAHB4.lto_priv.0+0x34>)
 80013f0:	4013      	ands	r3, r2
 80013f2:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  (void)RCC->AHB4RSTR;
 80013f6:	4b03      	ldr	r3, [pc, #12]	@ (8001404 <__rccResetAHB4.lto_priv.0+0x34>)
 80013f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
}
 80013fc:	bf00      	nop
 80013fe:	b002      	add	sp, #8
 8001400:	4770      	bx	lr
 8001402:	bf00      	nop
 8001404:	58024400 	.word	0x58024400
	...

08001410 <rccEnableAPB4>:
 * @param[in] mask              mask of peripherals to be enabled
 * @param[in] lp                low power enable flag
 *
 * @api
 */
__STATIC_INLINE void rccEnableAPB4(uint32_t mask, bool lp) {
 8001410:	b082      	sub	sp, #8
 8001412:	9001      	str	r0, [sp, #4]
 8001414:	460b      	mov	r3, r1
 8001416:	f88d 3003 	strb.w	r3, [sp, #3]

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->APB4ENR |= mask;
 800141a:	4b12      	ldr	r3, [pc, #72]	@ (8001464 <rccEnableAPB4+0x54>)
 800141c:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
 8001420:	4910      	ldr	r1, [pc, #64]	@ (8001464 <rccEnableAPB4+0x54>)
 8001422:	9b01      	ldr	r3, [sp, #4]
 8001424:	4313      	orrs	r3, r2
 8001426:	f8c1 30f4 	str.w	r3, [r1, #244]	@ 0xf4
  if (lp) {
 800142a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800142e:	2b00      	cmp	r3, #0
 8001430:	d008      	beq.n	8001444 <rccEnableAPB4+0x34>
    RCC_C1->APB4LPENR |= mask;
 8001432:	4b0c      	ldr	r3, [pc, #48]	@ (8001464 <rccEnableAPB4+0x54>)
 8001434:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 8001438:	490a      	ldr	r1, [pc, #40]	@ (8001464 <rccEnableAPB4+0x54>)
 800143a:	9b01      	ldr	r3, [sp, #4]
 800143c:	4313      	orrs	r3, r2
 800143e:	f8c1 311c 	str.w	r3, [r1, #284]	@ 0x11c
 8001442:	e008      	b.n	8001456 <rccEnableAPB4+0x46>
  }
  else {
    RCC_C1->APB4LPENR &= ~mask;
 8001444:	4b07      	ldr	r3, [pc, #28]	@ (8001464 <rccEnableAPB4+0x54>)
 8001446:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 800144a:	9b01      	ldr	r3, [sp, #4]
 800144c:	43db      	mvns	r3, r3
 800144e:	4905      	ldr	r1, [pc, #20]	@ (8001464 <rccEnableAPB4+0x54>)
 8001450:	4013      	ands	r3, r2
 8001452:	f8c1 311c 	str.w	r3, [r1, #284]	@ 0x11c
  }
  (void)RCC_C1->APB4LPENR;
 8001456:	4b03      	ldr	r3, [pc, #12]	@ (8001464 <rccEnableAPB4+0x54>)
 8001458:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
  else {
    RCC_C2->APB4LPENR &= ~mask;
  }
  (void)RCC_C2->APB4LPENR;
#endif
}
 800145c:	bf00      	nop
 800145e:	b002      	add	sp, #8
 8001460:	4770      	bx	lr
 8001462:	bf00      	nop
 8001464:	58024400 	.word	0x58024400
	...

08001470 <rccEnableAHB2>:
 * @param[in] mask              mask of peripherals to be enabled
 * @param[in] lp                low power enable flag
 *
 * @api
 */
__STATIC_INLINE void rccEnableAHB2(uint32_t mask, bool lp) {
 8001470:	b082      	sub	sp, #8
 8001472:	9001      	str	r0, [sp, #4]
 8001474:	460b      	mov	r3, r1
 8001476:	f88d 3003 	strb.w	r3, [sp, #3]

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->AHB2ENR |= mask;
 800147a:	4b12      	ldr	r3, [pc, #72]	@ (80014c4 <rccEnableAHB2+0x54>)
 800147c:	f8d3 20dc 	ldr.w	r2, [r3, #220]	@ 0xdc
 8001480:	4910      	ldr	r1, [pc, #64]	@ (80014c4 <rccEnableAHB2+0x54>)
 8001482:	9b01      	ldr	r3, [sp, #4]
 8001484:	4313      	orrs	r3, r2
 8001486:	f8c1 30dc 	str.w	r3, [r1, #220]	@ 0xdc
  if (lp) {
 800148a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800148e:	2b00      	cmp	r3, #0
 8001490:	d008      	beq.n	80014a4 <rccEnableAHB2+0x34>
    RCC_C1->AHB2LPENR |= mask;
 8001492:	4b0c      	ldr	r3, [pc, #48]	@ (80014c4 <rccEnableAHB2+0x54>)
 8001494:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
 8001498:	490a      	ldr	r1, [pc, #40]	@ (80014c4 <rccEnableAHB2+0x54>)
 800149a:	9b01      	ldr	r3, [sp, #4]
 800149c:	4313      	orrs	r3, r2
 800149e:	f8c1 3104 	str.w	r3, [r1, #260]	@ 0x104
 80014a2:	e008      	b.n	80014b6 <rccEnableAHB2+0x46>
  }
  else {
    RCC_C1->AHB2LPENR &= ~mask;
 80014a4:	4b07      	ldr	r3, [pc, #28]	@ (80014c4 <rccEnableAHB2+0x54>)
 80014a6:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
 80014aa:	9b01      	ldr	r3, [sp, #4]
 80014ac:	43db      	mvns	r3, r3
 80014ae:	4905      	ldr	r1, [pc, #20]	@ (80014c4 <rccEnableAHB2+0x54>)
 80014b0:	4013      	ands	r3, r2
 80014b2:	f8c1 3104 	str.w	r3, [r1, #260]	@ 0x104
  }
  (void)RCC_C1->AHB2LPENR;
 80014b6:	4b03      	ldr	r3, [pc, #12]	@ (80014c4 <rccEnableAHB2+0x54>)
 80014b8:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
  else {
    RCC_C2->AHB2LPENR &= ~mask;
  }
  (void)RCC_C2->AHB2LPENR;
#endif
}
 80014bc:	bf00      	nop
 80014be:	b002      	add	sp, #8
 80014c0:	4770      	bx	lr
 80014c2:	bf00      	nop
 80014c4:	58024400 	.word	0x58024400
	...

080014d0 <rccEnableAHB4.lto_priv.0>:
 * @param[in] mask              mask of peripherals to be enabled
 * @param[in] lp                low power enable flag
 *
 * @api
 */
__STATIC_INLINE void rccEnableAHB4(uint32_t mask, bool lp) {
 80014d0:	b082      	sub	sp, #8
 80014d2:	9001      	str	r0, [sp, #4]
 80014d4:	460b      	mov	r3, r1
 80014d6:	f88d 3003 	strb.w	r3, [sp, #3]

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->AHB4ENR |= mask;
 80014da:	4b12      	ldr	r3, [pc, #72]	@ (8001524 <rccEnableAHB4.lto_priv.0+0x54>)
 80014dc:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80014e0:	4910      	ldr	r1, [pc, #64]	@ (8001524 <rccEnableAHB4.lto_priv.0+0x54>)
 80014e2:	9b01      	ldr	r3, [sp, #4]
 80014e4:	4313      	orrs	r3, r2
 80014e6:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  if (lp) {
 80014ea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80014ee:	2b00      	cmp	r3, #0
 80014f0:	d008      	beq.n	8001504 <rccEnableAHB4.lto_priv.0+0x34>
    RCC_C1->AHB4LPENR |= mask;
 80014f2:	4b0c      	ldr	r3, [pc, #48]	@ (8001524 <rccEnableAHB4.lto_priv.0+0x54>)
 80014f4:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 80014f8:	490a      	ldr	r1, [pc, #40]	@ (8001524 <rccEnableAHB4.lto_priv.0+0x54>)
 80014fa:	9b01      	ldr	r3, [sp, #4]
 80014fc:	4313      	orrs	r3, r2
 80014fe:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
 8001502:	e008      	b.n	8001516 <rccEnableAHB4.lto_priv.0+0x46>
  }
  else {
    RCC_C1->AHB4LPENR &= ~mask;
 8001504:	4b07      	ldr	r3, [pc, #28]	@ (8001524 <rccEnableAHB4.lto_priv.0+0x54>)
 8001506:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 800150a:	9b01      	ldr	r3, [sp, #4]
 800150c:	43db      	mvns	r3, r3
 800150e:	4905      	ldr	r1, [pc, #20]	@ (8001524 <rccEnableAHB4.lto_priv.0+0x54>)
 8001510:	4013      	ands	r3, r2
 8001512:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
  }
  (void)RCC_C1->AHB4LPENR;
 8001516:	4b03      	ldr	r3, [pc, #12]	@ (8001524 <rccEnableAHB4.lto_priv.0+0x54>)
 8001518:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  else {
    RCC_C2->AHB4LPENR &= ~mask;
  }
  (void)RCC_C2->AHB4LPENR;
#endif
}
 800151c:	bf00      	nop
 800151e:	b002      	add	sp, #8
 8001520:	4770      	bx	lr
 8001522:	bf00      	nop
 8001524:	58024400 	.word	0x58024400
	...

08001530 <init_bkp_domain>:
 *          of the whole BKP domain.
 */
static inline void init_bkp_domain(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001530:	4b0e      	ldr	r3, [pc, #56]	@ (800156c <init_bkp_domain+0x3c>)
 8001532:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8001534:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8001538:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800153c:	d006      	beq.n	800154c <init_bkp_domain+0x1c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800153e:	4b0b      	ldr	r3, [pc, #44]	@ (800156c <init_bkp_domain+0x3c>)
 8001540:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8001544:	671a      	str	r2, [r3, #112]	@ 0x70
    RCC->BDCR = 0;
 8001546:	4b09      	ldr	r3, [pc, #36]	@ (800156c <init_bkp_domain+0x3c>)
 8001548:	2200      	movs	r2, #0
 800154a:	671a      	str	r2, [r3, #112]	@ 0x70
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 800154c:	4b07      	ldr	r3, [pc, #28]	@ (800156c <init_bkp_domain+0x3c>)
 800154e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8001550:	4a06      	ldr	r2, [pc, #24]	@ (800156c <init_bkp_domain+0x3c>)
 8001552:	f043 0319 	orr.w	r3, r3, #25
 8001556:	6713      	str	r3, [r2, #112]	@ 0x70
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 8001558:	bf00      	nop
 800155a:	4b04      	ldr	r3, [pc, #16]	@ (800156c <init_bkp_domain+0x3c>)
 800155c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800155e:	f003 0302 	and.w	r3, r3, #2
 8001562:	2b00      	cmp	r3, #0
 8001564:	d0f9      	beq.n	800155a <init_bkp_domain+0x2a>

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
  }
#endif /* HAL_USE_RTC */
}
 8001566:	bf00      	nop
 8001568:	bf00      	nop
 800156a:	4770      	bx	lr
 800156c:	58024400 	.word	0x58024400

08001570 <init_pwr>:

/**
 * @brief   Initializes the PWR unit.
 */
static inline void init_pwr(void) {
 8001570:	b508      	push	{r3, lr}
  PWR_TypeDef *pwr = PWR; /* For inspection.*/
  (void)pwr;
#endif
  /* Lower C3 byte, it must be programmed at very first, then waiting for
     power supply to stabilize.*/
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 8001572:	4b17      	ldr	r3, [pc, #92]	@ (80015d0 <init_pwr+0x60>)
 8001574:	2202      	movs	r2, #2
 8001576:	60da      	str	r2, [r3, #12]
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0)
 8001578:	bf00      	nop
 800157a:	4b15      	ldr	r3, [pc, #84]	@ (80015d0 <init_pwr+0x60>)
 800157c:	685b      	ldr	r3, [r3, #4]
 800157e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8001582:	2b00      	cmp	r3, #0
 8001584:	d0f9      	beq.n	800157a <init_pwr+0xa>
    ; /* CHTODO timeout handling.*/

  /* Backup domain access enabled and left open.*/
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U | PWR_CR1_DBP;
 8001586:	4b12      	ldr	r3, [pc, #72]	@ (80015d0 <init_pwr+0x60>)
 8001588:	4a12      	ldr	r2, [pc, #72]	@ (80015d4 <init_pwr+0x64>)
 800158a:	601a      	str	r2, [r3, #0]

  PWR->CR2   = STM32_PWR_CR2;
 800158c:	4b10      	ldr	r3, [pc, #64]	@ (80015d0 <init_pwr+0x60>)
 800158e:	2211      	movs	r2, #17
 8001590:	609a      	str	r2, [r3, #8]
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 8001592:	4b0f      	ldr	r3, [pc, #60]	@ (80015d0 <init_pwr+0x60>)
 8001594:	4a10      	ldr	r2, [pc, #64]	@ (80015d8 <init_pwr+0x68>)
 8001596:	60da      	str	r2, [r3, #12]
  PWR->CPUCR = STM32_PWR_CPUCR;
 8001598:	4b0d      	ldr	r3, [pc, #52]	@ (80015d0 <init_pwr+0x60>)
 800159a:	2200      	movs	r2, #0
 800159c:	611a      	str	r2, [r3, #16]
#if defined(HAL_LLD_TYPE3_H)
  PWR->SRDCR = STM32_VOS;
#else
  PWR->D3CR  = STM32_VOS;
 800159e:	4b0c      	ldr	r3, [pc, #48]	@ (80015d0 <init_pwr+0x60>)
 80015a0:	f44f 4240 	mov.w	r2, #49152	@ 0xc000
 80015a4:	619a      	str	r2, [r3, #24]
#endif
#endif
#if defined(HAL_LLD_TYPE3_H)
  while ((PWR->SRDCR & PWR_SRDCR_VOSRDY) == 0)
#else
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 80015a6:	bf00      	nop
 80015a8:	4b09      	ldr	r3, [pc, #36]	@ (80015d0 <init_pwr+0x60>)
 80015aa:	699b      	ldr	r3, [r3, #24]
 80015ac:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80015b0:	2b00      	cmp	r3, #0
 80015b2:	d0f9      	beq.n	80015a8 <init_pwr+0x38>
#endif
    ; /* CHTODO timeout handling.*/
#if STM32_PWR_CR2 & PWR_CR2_BREN
  while ((PWR->CR2 & PWR_CR2_BRRDY) == 0)
 80015b4:	bf00      	nop
 80015b6:	4b06      	ldr	r3, [pc, #24]	@ (80015d0 <init_pwr+0x60>)
 80015b8:	689b      	ldr	r3, [r3, #8]
 80015ba:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80015be:	2b00      	cmp	r3, #0
 80015c0:	d0f9      	beq.n	80015b6 <init_pwr+0x46>
    ;
  rccEnableBKPRAM(true);
 80015c2:	2101      	movs	r1, #1
 80015c4:	f04f 5080 	mov.w	r0, #268435456	@ 0x10000000
 80015c8:	f7ff ff82 	bl	80014d0 <rccEnableAHB4.lto_priv.0>
#endif
}
 80015cc:	bf00      	nop
 80015ce:	bd08      	pop	{r3, pc}
 80015d0:	58024800 	.word	0x58024800
 80015d4:	f000c100 	.word	0xf000c100
 80015d8:	01000002 	.word	0x01000002
 80015dc:	00000000 	.word	0x00000000

080015e0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80015e0:	b508      	push	{r3, lr}
     Note, GPIOs are not reset because initialized before this point in
     board files.
     Note that there is an undocumented bit in AHB1, presumably the cache
     reset, which must not be touched because the cache is write-back and
     latest writes could be lost.*/
  __rccResetAHB1(~RCC_AHB1RSTR_DONOTTOUCH);
 80015e2:	f06f 4000 	mvn.w	r0, #2147483648	@ 0x80000000
 80015e6:	f7ff fe9b 	bl	8001320 <__rccResetAHB1.lto_priv.0>
  __rccResetAHB2(~0);
 80015ea:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80015ee:	f7ff feb7 	bl	8001360 <__rccResetAHB2>
  __rccResetAHB3(~(RCC_AHB3RSTR_FMCRST    |
 80015f2:	4811      	ldr	r0, [pc, #68]	@ (8001638 <hal_lld_init+0x58>)
 80015f4:	f7ff fed4 	bl	80013a0 <__rccResetAHB3>
                   RCC_AHB3RSTR_OSPI2RST  |
                   RCC_AHB3RSTR_IOMNGRRST |
                   RCC_AHB3RSTR_MDMARST   |
#endif
                   0x80000000U));   /* Was RCC_AHB3RSTR_CPURST in Rev-V.*/
  __rccResetAHB4(~(RCC_APB4RSTR_SYSCFGRST | STM32_GPIO_EN_MASK));
 80015f8:	4810      	ldr	r0, [pc, #64]	@ (800163c <hal_lld_init+0x5c>)
 80015fa:	f7ff fee9 	bl	80013d0 <__rccResetAHB4.lto_priv.0>
  __rccResetAPB1L(~0);
 80015fe:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8001602:	f7ff fded 	bl	80011e0 <__rccResetAPB1L.lto_priv.0>
  __rccResetAPB1H(~0);
 8001606:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800160a:	f7ff fe09 	bl	8001220 <__rccResetAPB1H>
  __rccResetAPB2(~0);
 800160e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8001612:	f7ff fe25 	bl	8001260 <__rccResetAPB2>
  __rccResetAPB3(~0);
 8001616:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800161a:	f7ff fe41 	bl	80012a0 <__rccResetAPB3>
  __rccResetAPB4(~0);
 800161e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8001622:	f7ff fe5d 	bl	80012e0 <__rccResetAPB4>
#endif /* STM32_NO_INIT == FALSE */

  /* DMA subsystems initialization.*/
#if defined(STM32_BDMA_REQUIRED)
  bdmaInit();
 8001626:	f001 f92b 	bl	8002880 <bdmaInit>
#endif
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800162a:	f001 fd31 	bl	8003090 <dmaInit>
#if defined(STM32_MDMA_REQUIRED)
  mdmaInit();
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 800162e:	f7ff fd7f 	bl	8001130 <irqInit>
       immediately.*/
    SCB_CleanInvalidateDCache();
#endif
  }
#endif
}
 8001632:	bf00      	nop
 8001634:	bd08      	pop	{r3, pc}
 8001636:	bf00      	nop
 8001638:	7fffefff 	.word	0x7fffefff
 800163c:	fffff800 	.word	0xfffff800

08001640 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8001640:	b500      	push	{lr}
 8001642:	b085      	sub	sp, #20

#if defined(STM32_ENFORCE_H7_REV_XY)
  /* Fix for errata 2.2.15: Reading from AXI SRAM might lead to data
     read corruption.
     AXI->TARG7_FN_MOD.*/
  *((volatile uint32_t *)(0x51000000 + 0x1108 + 0x7000)) = 0x00000001U;
 8001644:	4b8c      	ldr	r3, [pc, #560]	@ (8001878 <stm32_clock_init+0x238>)
 8001646:	2201      	movs	r2, #1
 8001648:	601a      	str	r2, [r3, #0]
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB4(RCC_APB4ENR_SYSCFGEN, true);
 800164a:	2101      	movs	r1, #1
 800164c:	2002      	movs	r0, #2
 800164e:	f7ff fedf 	bl	8001410 <rccEnableAPB4>

  /* PWR initialization.*/
  init_pwr();
 8001652:	f7ff ff8d 	bl	8001570 <init_pwr>

  /* Backup domain initialization.*/
  init_bkp_domain();
 8001656:	f7ff ff6b 	bl	8001530 <init_bkp_domain>

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800165a:	4b88      	ldr	r3, [pc, #544]	@ (800187c <stm32_clock_init+0x23c>)
 800165c:	681b      	ldr	r3, [r3, #0]
 800165e:	4a87      	ldr	r2, [pc, #540]	@ (800187c <stm32_clock_init+0x23c>)
 8001660:	f043 0301 	orr.w	r3, r3, #1
 8001664:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001666:	bf00      	nop
 8001668:	4b84      	ldr	r3, [pc, #528]	@ (800187c <stm32_clock_init+0x23c>)
 800166a:	681b      	ldr	r3, [r3, #0]
 800166c:	f003 0304 	and.w	r3, r3, #4
 8001670:	2b00      	cmp	r3, #0
 8001672:	d0f9      	beq.n	8001668 <stm32_clock_init+0x28>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. This is only required when using a debugger than can cause
     restarts.*/
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 8001674:	4b81      	ldr	r3, [pc, #516]	@ (800187c <stm32_clock_init+0x23c>)
 8001676:	2200      	movs	r2, #0
 8001678:	611a      	str	r2, [r3, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800167a:	bf00      	nop
 800167c:	4b7f      	ldr	r3, [pc, #508]	@ (800187c <stm32_clock_init+0x23c>)
 800167e:	691b      	ldr	r3, [r3, #16]
 8001680:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8001684:	2b00      	cmp	r3, #0
 8001686:	d1f9      	bne.n	800167c <stm32_clock_init+0x3c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers cleared to reset values.*/
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 8001688:	4b7c      	ldr	r3, [pc, #496]	@ (800187c <stm32_clock_init+0x23c>)
 800168a:	2201      	movs	r2, #1
 800168c:	601a      	str	r2, [r3, #0]
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 800168e:	4b7b      	ldr	r3, [pc, #492]	@ (800187c <stm32_clock_init+0x23c>)
 8001690:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8001694:	605a      	str	r2, [r3, #4]
#if !defined(STM32_ENFORCE_H7_REV_XY)
  RCC->CSICFGR = 0x20000000U;              /* CSICFGR Reset value.         */
#endif
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
 8001696:	4b79      	ldr	r3, [pc, #484]	@ (800187c <stm32_clock_init+0x23c>)
 8001698:	2200      	movs	r2, #0
 800169a:	675a      	str	r2, [r3, #116]	@ 0x74
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 800169c:	4b77      	ldr	r3, [pc, #476]	@ (800187c <stm32_clock_init+0x23c>)
 800169e:	4a78      	ldr	r2, [pc, #480]	@ (8001880 <stm32_clock_init+0x240>)
 80016a0:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Other clock-related settings, done before other things because
     recommended in the RM.*/
  cfgr = STM32_MCO2SEL | RCC_CFGR_MCO2PRE_VALUE(STM32_MCO2PRE_VALUE) |
 80016a2:	4b78      	ldr	r3, [pc, #480]	@ (8001884 <stm32_clock_init+0x244>)
 80016a4:	9303      	str	r3, [sp, #12]
         STM32_STOPKERWUCK | STM32_STOPWUCK;
#if !defined(HAL_LLD_TYPE3_H)
  cfgr |= STM32_HRTIMSEL;
#endif
#if STM32_TIMPRE_ENABLE == TRUE
  cfgr |= RCC_CFGR_TIMPRE;
 80016a6:	9b03      	ldr	r3, [sp, #12]
 80016a8:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80016ac:	9303      	str	r3, [sp, #12]
#endif
  RCC->CFGR = cfgr;
 80016ae:	4a73      	ldr	r2, [pc, #460]	@ (800187c <stm32_clock_init+0x23c>)
 80016b0:	9b03      	ldr	r3, [sp, #12]
 80016b2:	6113      	str	r3, [r2, #16]

  /* HSE activation with optional bypass.*/
#if STM32_HSE_ENABLED == TRUE
#if defined(STM32_HSE_BYPASS)
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 80016b4:	4b71      	ldr	r3, [pc, #452]	@ (800187c <stm32_clock_init+0x23c>)
 80016b6:	681b      	ldr	r3, [r3, #0]
 80016b8:	4a70      	ldr	r2, [pc, #448]	@ (800187c <stm32_clock_init+0x23c>)
 80016ba:	f443 23a0 	orr.w	r3, r3, #327680	@ 0x50000
 80016be:	6013      	str	r3, [r2, #0]
#else
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 80016c0:	bf00      	nop
 80016c2:	4b6e      	ldr	r3, [pc, #440]	@ (800187c <stm32_clock_init+0x23c>)
 80016c4:	681b      	ldr	r3, [r3, #0]
 80016c6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80016ca:	2b00      	cmp	r3, #0
 80016cc:	d0f9      	beq.n	80016c2 <stm32_clock_init+0x82>
    ;                           /* Waits until HSE is stable.               */
#endif /* STM32_HSE_ENABLED == TRUE */

  /* HSI48 activation.*/
#if STM32_HSI48_ENABLED == TRUE
  RCC->CR |= RCC_CR_HSI48ON;
 80016ce:	4b6b      	ldr	r3, [pc, #428]	@ (800187c <stm32_clock_init+0x23c>)
 80016d0:	681b      	ldr	r3, [r3, #0]
 80016d2:	4a6a      	ldr	r2, [pc, #424]	@ (800187c <stm32_clock_init+0x23c>)
 80016d4:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80016d8:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 80016da:	bf00      	nop
 80016dc:	4b67      	ldr	r3, [pc, #412]	@ (800187c <stm32_clock_init+0x23c>)
 80016de:	681b      	ldr	r3, [r3, #0]
 80016e0:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80016e4:	2b00      	cmp	r3, #0
 80016e6:	d0f9      	beq.n	80016dc <stm32_clock_init+0x9c>

#endif /* STM32_HSI48_ENABLED == TRUE */

  /* CSI activation.*/
#if STM32_CSI_ENABLED == TRUE
  RCC->CR |= RCC_CR_CSION;
 80016e8:	4b64      	ldr	r3, [pc, #400]	@ (800187c <stm32_clock_init+0x23c>)
 80016ea:	681b      	ldr	r3, [r3, #0]
 80016ec:	4a63      	ldr	r2, [pc, #396]	@ (800187c <stm32_clock_init+0x23c>)
 80016ee:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80016f2:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_CSIRDY) == 0)
 80016f4:	bf00      	nop
 80016f6:	4b61      	ldr	r3, [pc, #388]	@ (800187c <stm32_clock_init+0x23c>)
 80016f8:	681b      	ldr	r3, [r3, #0]
 80016fa:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80016fe:	2b00      	cmp	r3, #0
 8001700:	d0f9      	beq.n	80016f6 <stm32_clock_init+0xb6>
    ;                           /* Waits until CSI is stable.               */
#endif /* STM32_CSI_ENABLED == TRUE */

  /* LSI activation.*/
#if STM32_LSI_ENABLED == TRUE
  RCC->CSR |= RCC_CSR_LSION;
 8001702:	4b5e      	ldr	r3, [pc, #376]	@ (800187c <stm32_clock_init+0x23c>)
 8001704:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8001706:	4a5d      	ldr	r2, [pc, #372]	@ (800187c <stm32_clock_init+0x23c>)
 8001708:	f043 0301 	orr.w	r3, r3, #1
 800170c:	6753      	str	r3, [r2, #116]	@ 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800170e:	bf00      	nop
 8001710:	4b5a      	ldr	r3, [pc, #360]	@ (800187c <stm32_clock_init+0x23c>)
 8001712:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8001714:	f003 0302 	and.w	r3, r3, #2
 8001718:	2b00      	cmp	r3, #0
 800171a:	d0f9      	beq.n	8001710 <stm32_clock_init+0xd0>
     reduce boot time.*/
#if (STM32_PLL1_ENABLED == TRUE) ||                                         \
    (STM32_PLL2_ENABLED == TRUE) ||                                         \
    (STM32_PLL3_ENABLED == TRUE)
  {
    uint32_t onmask = 0;
 800171c:	2300      	movs	r3, #0
 800171e:	9302      	str	r3, [sp, #8]
    uint32_t rdymask = 0;
 8001720:	2300      	movs	r3, #0
 8001722:	9301      	str	r3, [sp, #4]
    uint32_t cfgmask = 0;
 8001724:	2300      	movs	r3, #0
 8001726:	9300      	str	r3, [sp, #0]

    RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM3_VALUE(STM32_PLL3_DIVM_VALUE) |
 8001728:	4b54      	ldr	r3, [pc, #336]	@ (800187c <stm32_clock_init+0x23c>)
 800172a:	4a57      	ldr	r2, [pc, #348]	@ (8001888 <stm32_clock_init+0x248>)
 800172c:	629a      	str	r2, [r3, #40]	@ 0x28
                     RCC_PLLCKSELR_DIVM2_VALUE(STM32_PLL2_DIVM_VALUE) |
                     RCC_PLLCKSELR_DIVM1_VALUE(STM32_PLL1_DIVM_VALUE) |
                     RCC_PLLCKSELR_PLLSRC_VALUE(STM32_PLLSRC);

    cfgmask = STM32_PLLCFGR_PLL3RGE | STM32_PLLCFGR_PLL3VCOSEL | RCC_PLLCFGR_PLL3FRACEN |
 800172e:	f240 5355 	movw	r3, #1365	@ 0x555
 8001732:	9300      	str	r3, [sp, #0]
              STM32_PLLCFGR_PLL2RGE | STM32_PLLCFGR_PLL2VCOSEL | RCC_PLLCFGR_PLL2FRACEN |
              STM32_PLLCFGR_PLL1RGE | STM32_PLLCFGR_PLL1VCOSEL | RCC_PLLCFGR_PLL1FRACEN;

#if STM32_PLL1_ENABLED == TRUE
    RCC->PLL1FRACR = STM32_PLL1_FRACN;
 8001734:	4b51      	ldr	r3, [pc, #324]	@ (800187c <stm32_clock_init+0x23c>)
 8001736:	2200      	movs	r2, #0
 8001738:	635a      	str	r2, [r3, #52]	@ 0x34
    RCC->PLL1DIVR  = STM32_PLL1_DIVR | STM32_PLL1_DIVQ |
 800173a:	4b50      	ldr	r3, [pc, #320]	@ (800187c <stm32_clock_init+0x23c>)
 800173c:	4a53      	ldr	r2, [pc, #332]	@ (800188c <stm32_clock_init+0x24c>)
 800173e:	631a      	str	r2, [r3, #48]	@ 0x30
                     STM32_PLL1_DIVP | STM32_PLL1_DIVN;
    onmask  |= RCC_CR_PLL1ON;
 8001740:	9b02      	ldr	r3, [sp, #8]
 8001742:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001746:	9302      	str	r3, [sp, #8]
    rdymask |= RCC_CR_PLL1RDY;
 8001748:	9b01      	ldr	r3, [sp, #4]
 800174a:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 800174e:	9301      	str	r3, [sp, #4]
#if STM32_PLL1_P_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVP1EN;
 8001750:	9b00      	ldr	r3, [sp, #0]
 8001752:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001756:	9300      	str	r3, [sp, #0]
#endif
#if STM32_PLL1_Q_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVQ1EN;
 8001758:	9b00      	ldr	r3, [sp, #0]
 800175a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800175e:	9300      	str	r3, [sp, #0]
#endif
#if STM32_PLL1_R_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVR1EN;
 8001760:	9b00      	ldr	r3, [sp, #0]
 8001762:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8001766:	9300      	str	r3, [sp, #0]
#endif
#endif /* STM32_PLL1_ENABLED == TRUE */

#if STM32_PLL2_ENABLED == TRUE
    RCC->PLL2FRACR = STM32_PLL2_FRACN;
 8001768:	4b44      	ldr	r3, [pc, #272]	@ (800187c <stm32_clock_init+0x23c>)
 800176a:	2200      	movs	r2, #0
 800176c:	63da      	str	r2, [r3, #60]	@ 0x3c
    RCC->PLL2DIVR  = STM32_PLL2_DIVR | STM32_PLL2_DIVQ |
 800176e:	4b43      	ldr	r3, [pc, #268]	@ (800187c <stm32_clock_init+0x23c>)
 8001770:	4a47      	ldr	r2, [pc, #284]	@ (8001890 <stm32_clock_init+0x250>)
 8001772:	639a      	str	r2, [r3, #56]	@ 0x38
                     STM32_PLL2_DIVP | STM32_PLL2_DIVN;
    onmask  |= RCC_CR_PLL2ON;
 8001774:	9b02      	ldr	r3, [sp, #8]
 8001776:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 800177a:	9302      	str	r3, [sp, #8]
    rdymask |= RCC_CR_PLL2RDY;
 800177c:	9b01      	ldr	r3, [sp, #4]
 800177e:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8001782:	9301      	str	r3, [sp, #4]
#if STM32_PLL2_P_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVP2EN;
 8001784:	9b00      	ldr	r3, [sp, #0]
 8001786:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800178a:	9300      	str	r3, [sp, #0]
#endif
#if STM32_PLL2_Q_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVQ2EN;
 800178c:	9b00      	ldr	r3, [sp, #0]
 800178e:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8001792:	9300      	str	r3, [sp, #0]
#endif
#if STM32_PLL2_R_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVR2EN;
 8001794:	9b00      	ldr	r3, [sp, #0]
 8001796:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800179a:	9300      	str	r3, [sp, #0]
#endif
#endif /* STM32_PLL2_ENABLED == TRUE */

#if STM32_PLL3_ENABLED == TRUE
    RCC->PLL3FRACR = STM32_PLL3_FRACN;
 800179c:	4b37      	ldr	r3, [pc, #220]	@ (800187c <stm32_clock_init+0x23c>)
 800179e:	2200      	movs	r2, #0
 80017a0:	645a      	str	r2, [r3, #68]	@ 0x44
    RCC->PLL3DIVR  = STM32_PLL3_DIVR | STM32_PLL3_DIVQ |
 80017a2:	4b36      	ldr	r3, [pc, #216]	@ (800187c <stm32_clock_init+0x23c>)
 80017a4:	4a3b      	ldr	r2, [pc, #236]	@ (8001894 <stm32_clock_init+0x254>)
 80017a6:	641a      	str	r2, [r3, #64]	@ 0x40
                     STM32_PLL3_DIVP | STM32_PLL3_DIVN;
    onmask  |= RCC_CR_PLL3ON;
 80017a8:	9b02      	ldr	r3, [sp, #8]
 80017aa:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80017ae:	9302      	str	r3, [sp, #8]
    rdymask |= RCC_CR_PLL3RDY;
 80017b0:	9b01      	ldr	r3, [sp, #4]
 80017b2:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 80017b6:	9301      	str	r3, [sp, #4]
#if STM32_PLL3_P_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVP3EN;
 80017b8:	9b00      	ldr	r3, [sp, #0]
 80017ba:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 80017be:	9300      	str	r3, [sp, #0]
#endif
#if STM32_PLL3_Q_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVQ3EN;
 80017c0:	9b00      	ldr	r3, [sp, #0]
 80017c2:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 80017c6:	9300      	str	r3, [sp, #0]
#endif
#if STM32_PLL3_R_ENABLED == TRUE
    cfgmask |= RCC_PLLCFGR_DIVR3EN;
 80017c8:	9b00      	ldr	r3, [sp, #0]
 80017ca:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 80017ce:	9300      	str	r3, [sp, #0]
#endif
#endif /* STM32_PLL3_ENABLED == TRUE */

    /* Activating enabled PLLs and waiting for all of them to become ready.*/
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 80017d0:	4a2a      	ldr	r2, [pc, #168]	@ (800187c <stm32_clock_init+0x23c>)
 80017d2:	9b00      	ldr	r3, [sp, #0]
 80017d4:	62d3      	str	r3, [r2, #44]	@ 0x2c
    RCC->CR     |= onmask;
 80017d6:	4b29      	ldr	r3, [pc, #164]	@ (800187c <stm32_clock_init+0x23c>)
 80017d8:	681a      	ldr	r2, [r3, #0]
 80017da:	4928      	ldr	r1, [pc, #160]	@ (800187c <stm32_clock_init+0x23c>)
 80017dc:	9b02      	ldr	r3, [sp, #8]
 80017de:	4313      	orrs	r3, r2
 80017e0:	600b      	str	r3, [r1, #0]
    while ((RCC->CR & rdymask) != rdymask)
 80017e2:	bf00      	nop
 80017e4:	4b25      	ldr	r3, [pc, #148]	@ (800187c <stm32_clock_init+0x23c>)
 80017e6:	681a      	ldr	r2, [r3, #0]
 80017e8:	9b01      	ldr	r3, [sp, #4]
 80017ea:	4013      	ands	r3, r2
 80017ec:	9a01      	ldr	r2, [sp, #4]
 80017ee:	429a      	cmp	r2, r3
 80017f0:	d1f8      	bne.n	80017e4 <stm32_clock_init+0x1a4>
#if defined(HAL_LLD_TYPE3_H)
  RCC->CDCFGR1 = STM32_CDCPRE  | STM32_CDPPRE | STM32_CDHPRE;
  RCC->CDCFGR2 = STM32_CDPPRE2 | STM32_CDPPRE1;
  RCC->SRDCFGR = STM32_SRDPPRE;
#else
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 80017f2:	4b22      	ldr	r3, [pc, #136]	@ (800187c <stm32_clock_init+0x23c>)
 80017f4:	2248      	movs	r2, #72	@ 0x48
 80017f6:	619a      	str	r2, [r3, #24]
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 80017f8:	4b20      	ldr	r3, [pc, #128]	@ (800187c <stm32_clock_init+0x23c>)
 80017fa:	f44f 6288 	mov.w	r2, #1088	@ 0x440
 80017fe:	61da      	str	r2, [r3, #28]
  RCC->D3CFGR = STM32_D3PPRE4;
 8001800:	4b1e      	ldr	r3, [pc, #120]	@ (800187c <stm32_clock_init+0x23c>)
 8001802:	2240      	movs	r2, #64	@ 0x40
 8001804:	621a      	str	r2, [r3, #32]
#endif

  /* Peripherals clocks.*/
#if defined(HAL_LLD_TYPE1_H)
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_QSPISEL       |
 8001806:	4b1d      	ldr	r3, [pc, #116]	@ (800187c <stm32_clock_init+0x23c>)
 8001808:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 800180c:	64da      	str	r2, [r3, #76]	@ 0x4c
                  STM32_FMCSEL;
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
 800180e:	4b1b      	ldr	r3, [pc, #108]	@ (800187c <stm32_clock_init+0x23c>)
 8001810:	2200      	movs	r2, #0
 8001812:	651a      	str	r2, [r3, #80]	@ 0x50
                  STM32_SPDIFSEL   | STM32_SPDIFSEL    | STM32_SPI45SEL      |
                  STM32_SPI123SEL  | STM32_SAI23SEL    | STM32_SAI1SEL;
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8001814:	4b19      	ldr	r3, [pc, #100]	@ (800187c <stm32_clock_init+0x23c>)
 8001816:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 800181a:	655a      	str	r2, [r3, #84]	@ 0x54
                  STM32_I2C123SEL  | STM32_RNGSEL      | STM32_USART16SEL    |
                  STM32_USART234578SEL;
  RCC->D3CCIPR  = STM32_SPI6SEL    | STM32_SAI4BSEL    | STM32_SAI4ASEL      |
 800181c:	4b17      	ldr	r3, [pc, #92]	@ (800187c <stm32_clock_init+0x23c>)
 800181e:	2200      	movs	r2, #0
 8001820:	659a      	str	r2, [r3, #88]	@ 0x58
                  STM32_LPTIM3SEL  | STM32_LPTIM2SEL   | STM32_I2C4SEL       |
                  STM32_LPUART1SEL;
#endif

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8001822:	4b1d      	ldr	r3, [pc, #116]	@ (8001898 <stm32_clock_init+0x258>)
 8001824:	2232      	movs	r2, #50	@ 0x32
 8001826:	601a      	str	r2, [r3, #0]
               STM32_FLASHBITS;
  while ((FLASH->ACR & FLASH_ACR_LATENCY) !=
 8001828:	bf00      	nop
 800182a:	4b1b      	ldr	r3, [pc, #108]	@ (8001898 <stm32_clock_init+0x258>)
 800182c:	681b      	ldr	r3, [r3, #0]
 800182e:	f003 030f 	and.w	r3, r3, #15
 8001832:	2b02      	cmp	r3, #2
 8001834:	d1f9      	bne.n	800182a <stm32_clock_init+0x1ea>
  }

  /* Switching to the configured clock source if it is different
     from HSI.*/
#if STM32_SW != STM32_SW_HSI_CK
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001836:	4b11      	ldr	r3, [pc, #68]	@ (800187c <stm32_clock_init+0x23c>)
 8001838:	691b      	ldr	r3, [r3, #16]
 800183a:	4a10      	ldr	r2, [pc, #64]	@ (800187c <stm32_clock_init+0x23c>)
 800183c:	f043 0303 	orr.w	r3, r3, #3
 8001840:	6113      	str	r3, [r2, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != (STM32_SW << RCC_CFGR_SWS_Pos))
 8001842:	bf00      	nop
 8001844:	4b0d      	ldr	r3, [pc, #52]	@ (800187c <stm32_clock_init+0x23c>)
 8001846:	691b      	ldr	r3, [r3, #16]
 8001848:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800184c:	2b18      	cmp	r3, #24
 800184e:	d1f9      	bne.n	8001844 <stm32_clock_init+0x204>
                  STM32_UART4SEL  | STM32_USART3SEL | STM32_USART2SEL |
                  STM32_USART1SEL;
#endif

  /* RAM1 2 and 3 clocks enabled.*/
  rccEnableSRAM1(true);
 8001850:	2101      	movs	r1, #1
 8001852:	f04f 5000 	mov.w	r0, #536870912	@ 0x20000000
 8001856:	f7ff fe0b 	bl	8001470 <rccEnableAHB2>
  rccEnableSRAM2(true);
 800185a:	2101      	movs	r1, #1
 800185c:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8001860:	f7ff fe06 	bl	8001470 <rccEnableAHB2>
#if !(defined(HAL_LLD_TYPE2_H) || defined(HAL_LLD_TYPE3_H))
  rccEnableSRAM3(true);
 8001864:	2101      	movs	r1, #1
 8001866:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 800186a:	f7ff fe01 	bl	8001470 <rccEnableAHB2>
#endif
#endif /* STM32_NO_INIT */
}
 800186e:	bf00      	nop
 8001870:	b005      	add	sp, #20
 8001872:	f85d fb04 	ldr.w	pc, [sp], #4
 8001876:	bf00      	nop
 8001878:	51008108 	.word	0x51008108
 800187c:	58024400 	.word	0x58024400
 8001880:	01ff0000 	.word	0x01ff0000
 8001884:	08100800 	.word	0x08100800
 8001888:	00404042 	.word	0x00404042
 800188c:	0707038f 	.word	0x0707038f
 8001890:	07074f8f 	.word	0x07074f8f
 8001894:	07070f8f 	.word	0x07070f8f
 8001898:	52002000 	.word	0x52002000
 800189c:	00000000 	.word	0x00000000

080018a0 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80018a0:	b500      	push	{lr}
 80018a2:	b083      	sub	sp, #12
 80018a4:	2330      	movs	r3, #48	@ 0x30
 80018a6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80018a8:	9b01      	ldr	r3, [sp, #4]
 80018aa:	f383 8811 	msr	BASEPRI, r3
}
 80018ae:	bf00      	nop
}
 80018b0:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 80018b2:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 80018b4:	f002 fa0c 	bl	8003cd0 <__dbg_check_lock_from_isr>
}
 80018b8:	bf00      	nop
 80018ba:	b003      	add	sp, #12
 80018bc:	f85d fb04 	ldr.w	pc, [sp], #4

080018c0 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80018c0:	b500      	push	{lr}
 80018c2:	b083      	sub	sp, #12

  __dbg_check_unlock_from_isr();
 80018c4:	f002 fa2c 	bl	8003d20 <__dbg_check_unlock_from_isr>
 80018c8:	2300      	movs	r3, #0
 80018ca:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80018cc:	9b01      	ldr	r3, [sp, #4]
 80018ce:	f383 8811 	msr	BASEPRI, r3
}
 80018d2:	bf00      	nop
}
 80018d4:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 80018d6:	bf00      	nop
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 80018d8:	bf00      	nop
 80018da:	b003      	add	sp, #12
 80018dc:	f85d fb04 	ldr.w	pc, [sp], #4

080018e0 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 80018e0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80018e2:	f7ff ffdd 	bl	80018a0 <chSysLockFromISR.lto_priv.0>
}
 80018e6:	bf00      	nop
 80018e8:	bd08      	pop	{r3, pc}
 80018ea:	bf00      	nop
 80018ec:	0000      	movs	r0, r0
	...

080018f0 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 80018f0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80018f2:	f7ff ffe5 	bl	80018c0 <chSysUnlockFromISR.lto_priv.0>
}
 80018f6:	bf00      	nop
 80018f8:	bd08      	pop	{r3, pc}
 80018fa:	bf00      	nop
 80018fc:	0000      	movs	r0, r0
	...

08001900 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8001900:	b500      	push	{lr}
 8001902:	b083      	sub	sp, #12
 8001904:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 8001906:	9801      	ldr	r0, [sp, #4]
 8001908:	f002 f962 	bl	8003bd0 <chSysPolledDelayX>
}
 800190c:	bf00      	nop
 800190e:	b003      	add	sp, #12
 8001910:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001920 <osalThreadResumeI.lto_priv.1>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001920:	b500      	push	{lr}
 8001922:	b083      	sub	sp, #12
 8001924:	9001      	str	r0, [sp, #4]
 8001926:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8001928:	9900      	ldr	r1, [sp, #0]
 800192a:	9801      	ldr	r0, [sp, #4]
 800192c:	f003 ff80 	bl	8005830 <chThdResumeI>
}
 8001930:	bf00      	nop
 8001932:	b003      	add	sp, #12
 8001934:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001940 <__rccResetAHB1.lto_priv.1>:
__STATIC_INLINE void __rccResetAHB1(uint32_t mask) {
 8001940:	b082      	sub	sp, #8
 8001942:	9001      	str	r0, [sp, #4]
  RCC->AHB1RSTR |= mask;
 8001944:	4b0b      	ldr	r3, [pc, #44]	@ (8001974 <__rccResetAHB1.lto_priv.1+0x34>)
 8001946:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 800194a:	490a      	ldr	r1, [pc, #40]	@ (8001974 <__rccResetAHB1.lto_priv.1+0x34>)
 800194c:	9b01      	ldr	r3, [sp, #4]
 800194e:	4313      	orrs	r3, r2
 8001950:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
  RCC->AHB1RSTR &= ~mask;
 8001954:	4b07      	ldr	r3, [pc, #28]	@ (8001974 <__rccResetAHB1.lto_priv.1+0x34>)
 8001956:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 800195a:	9b01      	ldr	r3, [sp, #4]
 800195c:	43db      	mvns	r3, r3
 800195e:	4905      	ldr	r1, [pc, #20]	@ (8001974 <__rccResetAHB1.lto_priv.1+0x34>)
 8001960:	4013      	ands	r3, r2
 8001962:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
  (void)RCC->AHB1RSTR;
 8001966:	4b03      	ldr	r3, [pc, #12]	@ (8001974 <__rccResetAHB1.lto_priv.1+0x34>)
 8001968:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
}
 800196c:	bf00      	nop
 800196e:	b002      	add	sp, #8
 8001970:	4770      	bx	lr
 8001972:	bf00      	nop
 8001974:	58024400 	.word	0x58024400
	...

08001980 <__rccResetAHB4.lto_priv.1>:
__STATIC_INLINE void __rccResetAHB4(uint32_t mask) {
 8001980:	b082      	sub	sp, #8
 8001982:	9001      	str	r0, [sp, #4]
  RCC->AHB4RSTR |= mask;
 8001984:	4b0b      	ldr	r3, [pc, #44]	@ (80019b4 <__rccResetAHB4.lto_priv.1+0x34>)
 8001986:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 800198a:	490a      	ldr	r1, [pc, #40]	@ (80019b4 <__rccResetAHB4.lto_priv.1+0x34>)
 800198c:	9b01      	ldr	r3, [sp, #4]
 800198e:	4313      	orrs	r3, r2
 8001990:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  RCC->AHB4RSTR &= ~mask;
 8001994:	4b07      	ldr	r3, [pc, #28]	@ (80019b4 <__rccResetAHB4.lto_priv.1+0x34>)
 8001996:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 800199a:	9b01      	ldr	r3, [sp, #4]
 800199c:	43db      	mvns	r3, r3
 800199e:	4905      	ldr	r1, [pc, #20]	@ (80019b4 <__rccResetAHB4.lto_priv.1+0x34>)
 80019a0:	4013      	ands	r3, r2
 80019a2:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  (void)RCC->AHB4RSTR;
 80019a6:	4b03      	ldr	r3, [pc, #12]	@ (80019b4 <__rccResetAHB4.lto_priv.1+0x34>)
 80019a8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
}
 80019ac:	bf00      	nop
 80019ae:	b002      	add	sp, #8
 80019b0:	4770      	bx	lr
 80019b2:	bf00      	nop
 80019b4:	58024400 	.word	0x58024400
	...

080019c0 <rccEnableAHB1.lto_priv.0>:
__STATIC_INLINE void rccEnableAHB1(uint32_t mask, bool lp) {
 80019c0:	b082      	sub	sp, #8
 80019c2:	9001      	str	r0, [sp, #4]
 80019c4:	460b      	mov	r3, r1
 80019c6:	f88d 3003 	strb.w	r3, [sp, #3]
  RCC_C1->AHB1ENR |= mask;
 80019ca:	4b12      	ldr	r3, [pc, #72]	@ (8001a14 <rccEnableAHB1.lto_priv.0+0x54>)
 80019cc:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 80019d0:	4910      	ldr	r1, [pc, #64]	@ (8001a14 <rccEnableAHB1.lto_priv.0+0x54>)
 80019d2:	9b01      	ldr	r3, [sp, #4]
 80019d4:	4313      	orrs	r3, r2
 80019d6:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
  if (lp) {
 80019da:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80019de:	2b00      	cmp	r3, #0
 80019e0:	d008      	beq.n	80019f4 <rccEnableAHB1.lto_priv.0+0x34>
    RCC_C1->AHB1LPENR |= mask;
 80019e2:	4b0c      	ldr	r3, [pc, #48]	@ (8001a14 <rccEnableAHB1.lto_priv.0+0x54>)
 80019e4:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
 80019e8:	490a      	ldr	r1, [pc, #40]	@ (8001a14 <rccEnableAHB1.lto_priv.0+0x54>)
 80019ea:	9b01      	ldr	r3, [sp, #4]
 80019ec:	4313      	orrs	r3, r2
 80019ee:	f8c1 3100 	str.w	r3, [r1, #256]	@ 0x100
 80019f2:	e008      	b.n	8001a06 <rccEnableAHB1.lto_priv.0+0x46>
    RCC_C1->AHB1LPENR &= ~mask;
 80019f4:	4b07      	ldr	r3, [pc, #28]	@ (8001a14 <rccEnableAHB1.lto_priv.0+0x54>)
 80019f6:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
 80019fa:	9b01      	ldr	r3, [sp, #4]
 80019fc:	43db      	mvns	r3, r3
 80019fe:	4905      	ldr	r1, [pc, #20]	@ (8001a14 <rccEnableAHB1.lto_priv.0+0x54>)
 8001a00:	4013      	ands	r3, r2
 8001a02:	f8c1 3100 	str.w	r3, [r1, #256]	@ 0x100
  (void)RCC_C1->AHB1LPENR;
 8001a06:	4b03      	ldr	r3, [pc, #12]	@ (8001a14 <rccEnableAHB1.lto_priv.0+0x54>)
 8001a08:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
}
 8001a0c:	bf00      	nop
 8001a0e:	b002      	add	sp, #8
 8001a10:	4770      	bx	lr
 8001a12:	bf00      	nop
 8001a14:	58024400 	.word	0x58024400
	...

08001a20 <rccDisableAHB1.lto_priv.0>:
__STATIC_INLINE void rccDisableAHB1(uint32_t mask) {
 8001a20:	b082      	sub	sp, #8
 8001a22:	9001      	str	r0, [sp, #4]
  RCC_C1->AHB1ENR &= ~mask;
 8001a24:	4b0b      	ldr	r3, [pc, #44]	@ (8001a54 <rccDisableAHB1.lto_priv.0+0x34>)
 8001a26:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 8001a2a:	9b01      	ldr	r3, [sp, #4]
 8001a2c:	43db      	mvns	r3, r3
 8001a2e:	4909      	ldr	r1, [pc, #36]	@ (8001a54 <rccDisableAHB1.lto_priv.0+0x34>)
 8001a30:	4013      	ands	r3, r2
 8001a32:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
  RCC_C1->AHB1LPENR &= ~mask;
 8001a36:	4b07      	ldr	r3, [pc, #28]	@ (8001a54 <rccDisableAHB1.lto_priv.0+0x34>)
 8001a38:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
 8001a3c:	9b01      	ldr	r3, [sp, #4]
 8001a3e:	43db      	mvns	r3, r3
 8001a40:	4904      	ldr	r1, [pc, #16]	@ (8001a54 <rccDisableAHB1.lto_priv.0+0x34>)
 8001a42:	4013      	ands	r3, r2
 8001a44:	f8c1 3100 	str.w	r3, [r1, #256]	@ 0x100
  (void)RCC_C1->AHB1LPENR;
 8001a48:	4b02      	ldr	r3, [pc, #8]	@ (8001a54 <rccDisableAHB1.lto_priv.0+0x34>)
 8001a4a:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
}
 8001a4e:	bf00      	nop
 8001a50:	b002      	add	sp, #8
 8001a52:	4770      	bx	lr
 8001a54:	58024400 	.word	0x58024400
	...

08001a60 <rccResetAHB1>:
__STATIC_INLINE void rccResetAHB1(uint32_t mask) {
 8001a60:	b500      	push	{lr}
 8001a62:	b083      	sub	sp, #12
 8001a64:	9001      	str	r0, [sp, #4]
  __rccResetAHB1(mask);
 8001a66:	9801      	ldr	r0, [sp, #4]
 8001a68:	f7ff ff6a 	bl	8001940 <__rccResetAHB1.lto_priv.1>
}
 8001a6c:	bf00      	nop
 8001a6e:	b003      	add	sp, #12
 8001a70:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001a80 <rccEnableAHB4.lto_priv.1>:
__STATIC_INLINE void rccEnableAHB4(uint32_t mask, bool lp) {
 8001a80:	b082      	sub	sp, #8
 8001a82:	9001      	str	r0, [sp, #4]
 8001a84:	460b      	mov	r3, r1
 8001a86:	f88d 3003 	strb.w	r3, [sp, #3]
  RCC_C1->AHB4ENR |= mask;
 8001a8a:	4b12      	ldr	r3, [pc, #72]	@ (8001ad4 <rccEnableAHB4.lto_priv.1+0x54>)
 8001a8c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8001a90:	4910      	ldr	r1, [pc, #64]	@ (8001ad4 <rccEnableAHB4.lto_priv.1+0x54>)
 8001a92:	9b01      	ldr	r3, [sp, #4]
 8001a94:	4313      	orrs	r3, r2
 8001a96:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  if (lp) {
 8001a9a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001a9e:	2b00      	cmp	r3, #0
 8001aa0:	d008      	beq.n	8001ab4 <rccEnableAHB4.lto_priv.1+0x34>
    RCC_C1->AHB4LPENR |= mask;
 8001aa2:	4b0c      	ldr	r3, [pc, #48]	@ (8001ad4 <rccEnableAHB4.lto_priv.1+0x54>)
 8001aa4:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8001aa8:	490a      	ldr	r1, [pc, #40]	@ (8001ad4 <rccEnableAHB4.lto_priv.1+0x54>)
 8001aaa:	9b01      	ldr	r3, [sp, #4]
 8001aac:	4313      	orrs	r3, r2
 8001aae:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
 8001ab2:	e008      	b.n	8001ac6 <rccEnableAHB4.lto_priv.1+0x46>
    RCC_C1->AHB4LPENR &= ~mask;
 8001ab4:	4b07      	ldr	r3, [pc, #28]	@ (8001ad4 <rccEnableAHB4.lto_priv.1+0x54>)
 8001ab6:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8001aba:	9b01      	ldr	r3, [sp, #4]
 8001abc:	43db      	mvns	r3, r3
 8001abe:	4905      	ldr	r1, [pc, #20]	@ (8001ad4 <rccEnableAHB4.lto_priv.1+0x54>)
 8001ac0:	4013      	ands	r3, r2
 8001ac2:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
  (void)RCC_C1->AHB4LPENR;
 8001ac6:	4b03      	ldr	r3, [pc, #12]	@ (8001ad4 <rccEnableAHB4.lto_priv.1+0x54>)
 8001ac8:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
}
 8001acc:	bf00      	nop
 8001ace:	b002      	add	sp, #8
 8001ad0:	4770      	bx	lr
 8001ad2:	bf00      	nop
 8001ad4:	58024400 	.word	0x58024400
	...

08001ae0 <rccDisableAHB4.lto_priv.0>:
 *
 * @param[in] mask              mask of peripherals to be disabled
 *
 * @api
 */
__STATIC_INLINE void rccDisableAHB4(uint32_t mask) {
 8001ae0:	b082      	sub	sp, #8
 8001ae2:	9001      	str	r0, [sp, #4]
     allocation.*/
  osalDbgAssert((RCC_C1->AHB4ENR & mask) == mask, "peripherals not allocated");
#endif

  /* Disabling the peripherals.*/
  RCC_C1->AHB4ENR &= ~mask;
 8001ae4:	4b0b      	ldr	r3, [pc, #44]	@ (8001b14 <rccDisableAHB4.lto_priv.0+0x34>)
 8001ae6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8001aea:	9b01      	ldr	r3, [sp, #4]
 8001aec:	43db      	mvns	r3, r3
 8001aee:	4909      	ldr	r1, [pc, #36]	@ (8001b14 <rccDisableAHB4.lto_priv.0+0x34>)
 8001af0:	4013      	ands	r3, r2
 8001af2:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  RCC_C1->AHB4LPENR &= ~mask;
 8001af6:	4b07      	ldr	r3, [pc, #28]	@ (8001b14 <rccDisableAHB4.lto_priv.0+0x34>)
 8001af8:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8001afc:	9b01      	ldr	r3, [sp, #4]
 8001afe:	43db      	mvns	r3, r3
 8001b00:	4904      	ldr	r1, [pc, #16]	@ (8001b14 <rccDisableAHB4.lto_priv.0+0x34>)
 8001b02:	4013      	ands	r3, r2
 8001b04:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
  (void)RCC_C1->AHB4LPENR;
 8001b08:	4b02      	ldr	r3, [pc, #8]	@ (8001b14 <rccDisableAHB4.lto_priv.0+0x34>)
 8001b0a:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  /* Disabling the peripherals.*/
  RCC_C2->AHB4ENR &= ~mask;
  RCC_C2->AHB4LPENR &= ~mask;
  (void)RCC_C1->AHB4LPENR;
#endif
}
 8001b0e:	bf00      	nop
 8001b10:	b002      	add	sp, #8
 8001b12:	4770      	bx	lr
 8001b14:	58024400 	.word	0x58024400
	...

08001b20 <rccResetAHB4>:
 *
 * @param[in] mask              mask of peripherals to be reset
 *
 * @api
 */
__STATIC_INLINE void rccResetAHB4(uint32_t mask) {
 8001b20:	b500      	push	{lr}
 8001b22:	b083      	sub	sp, #12
 8001b24:	9001      	str	r0, [sp, #4]
#else
  osalDbgAssert((RCC_C2->AHB4ENR & mask) == mask, "peripherals not allocated");
#endif
#endif

  __rccResetAHB4(mask);
 8001b26:	9801      	ldr	r0, [sp, #4]
 8001b28:	f7ff ff2a 	bl	8001980 <__rccResetAHB4.lto_priv.1>
}
 8001b2c:	bf00      	nop
 8001b2e:	b003      	add	sp, #12
 8001b30:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001b40 <adc_lld_vreg_on>:
/**
 * @brief   Enables the ADC voltage regulator.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {
 8001b40:	b500      	push	{lr}
 8001b42:	b083      	sub	sp, #12
 8001b44:	9001      	str	r0, [sp, #4]

  adcp->adcm->CR = ADC_CR_ADVREGEN;
 8001b46:	9b01      	ldr	r3, [sp, #4]
 8001b48:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b4a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8001b4e:	609a      	str	r2, [r3, #8]
#if STM32_ADC_DUAL_MODE
  if (&ADCD1 == adcp) {
    adcp->adcs->CR = ADC_CR_ADVREGEN;
  }
#endif
  osalSysPolledDelayX(OSAL_US2RTC(STM32_SYS_CK, 10U));
 8001b50:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 8001b54:	f7ff fed4 	bl	8001900 <osalSysPolledDelayX>
}
 8001b58:	bf00      	nop
 8001b5a:	b003      	add	sp, #12
 8001b5c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b60 <adc_lld_analog_on>:
/**
 * @brief   Enables the ADC analog circuit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_analog_on(ADCDriver *adcp) {
 8001b60:	b082      	sub	sp, #8
 8001b62:	9001      	str	r0, [sp, #4]

  adcp->adcm->ISR = ADC_ISR_ADRDY;
 8001b64:	9b01      	ldr	r3, [sp, #4]
 8001b66:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b68:	2201      	movs	r2, #1
 8001b6a:	601a      	str	r2, [r3, #0]
  adcp->adcm->CR |= ADC_CR_ADEN;
 8001b6c:	9b01      	ldr	r3, [sp, #4]
 8001b6e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b70:	689a      	ldr	r2, [r3, #8]
 8001b72:	9b01      	ldr	r3, [sp, #4]
 8001b74:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b76:	f042 0201 	orr.w	r2, r2, #1
 8001b7a:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRDY) == 0U)
 8001b7c:	bf00      	nop
 8001b7e:	9b01      	ldr	r3, [sp, #4]
 8001b80:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001b82:	681b      	ldr	r3, [r3, #0]
 8001b84:	f003 0301 	and.w	r3, r3, #1
 8001b88:	2b00      	cmp	r3, #0
 8001b8a:	d0f8      	beq.n	8001b7e <adc_lld_analog_on+0x1e>
    adcp->adcs->CR |= ADC_CR_ADEN;
    while ((adcp->adcs->ISR & ADC_ISR_ADRDY) == 0U)
      ;
  }
#endif
}
 8001b8c:	bf00      	nop
 8001b8e:	bf00      	nop
 8001b90:	b002      	add	sp, #8
 8001b92:	4770      	bx	lr
	...

08001ba0 <adc_lld_calibrate>:
/**
 * @brief   Calibrates an ADC unit.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_calibrate(ADCDriver *adcp) {
 8001ba0:	b500      	push	{lr}
 8001ba2:	b083      	sub	sp, #12
 8001ba4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(adcp->adcm->CR == ADC_CR_ADVREGEN, "invalid register state");
 8001ba6:	9b01      	ldr	r3, [sp, #4]
 8001ba8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001baa:	689b      	ldr	r3, [r3, #8]
 8001bac:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8001bb0:	bf14      	ite	ne
 8001bb2:	2301      	movne	r3, #1
 8001bb4:	2300      	moveq	r3, #0
 8001bb6:	b2db      	uxtb	r3, r3
 8001bb8:	2b00      	cmp	r3, #0
 8001bba:	d002      	beq.n	8001bc2 <adc_lld_calibrate+0x22>
 8001bbc:	4814      	ldr	r0, [pc, #80]	@ (8001c10 <adc_lld_calibrate+0x70>)
 8001bbe:	f001 ffaf 	bl	8003b20 <chSysHalt>

  adcp->adcm->CR &= ~(ADC_CR_ADCALDIF | ADC_CR_ADCALLIN);
 8001bc2:	9b01      	ldr	r3, [sp, #4]
 8001bc4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001bc6:	6899      	ldr	r1, [r3, #8]
 8001bc8:	9b01      	ldr	r3, [sp, #4]
 8001bca:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001bcc:	4b11      	ldr	r3, [pc, #68]	@ (8001c14 <adc_lld_calibrate+0x74>)
 8001bce:	400b      	ands	r3, r1
 8001bd0:	6093      	str	r3, [r2, #8]
  adcp->adcm->CR |= adcp->config->calibration & (ADC_CR_ADCALDIF |
 8001bd2:	9b01      	ldr	r3, [sp, #4]
 8001bd4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001bd6:	6899      	ldr	r1, [r3, #8]
 8001bd8:	9b01      	ldr	r3, [sp, #4]
 8001bda:	685b      	ldr	r3, [r3, #4]
 8001bdc:	685a      	ldr	r2, [r3, #4]
 8001bde:	4b0e      	ldr	r3, [pc, #56]	@ (8001c18 <adc_lld_calibrate+0x78>)
 8001be0:	4013      	ands	r3, r2
 8001be2:	9a01      	ldr	r2, [sp, #4]
 8001be4:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8001be6:	430b      	orrs	r3, r1
 8001be8:	6093      	str	r3, [r2, #8]
                                                 ADC_CR_ADCALLIN);
  adcp->adcm->CR |= ADC_CR_ADCAL;
 8001bea:	9b01      	ldr	r3, [sp, #4]
 8001bec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001bee:	689a      	ldr	r2, [r3, #8]
 8001bf0:	9b01      	ldr	r3, [sp, #4]
 8001bf2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001bf4:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 8001bf8:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0U)
 8001bfa:	bf00      	nop
 8001bfc:	9b01      	ldr	r3, [sp, #4]
 8001bfe:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c00:	689b      	ldr	r3, [r3, #8]
 8001c02:	2b00      	cmp	r3, #0
 8001c04:	dbfa      	blt.n	8001bfc <adc_lld_calibrate+0x5c>
    adcp->adcs->CR |= ADC_CR_ADCAL;
    while ((adcp->adcs->CR & ADC_CR_ADCAL) != 0U)
      ;
  }
#endif
}
 8001c06:	bf00      	nop
 8001c08:	bf00      	nop
 8001c0a:	b003      	add	sp, #12
 8001c0c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c10:	080069fc 	.word	0x080069fc
 8001c14:	bffeffff 	.word	0xbffeffff
 8001c18:	40010000 	.word	0x40010000
 8001c1c:	00000000 	.word	0x00000000

08001c20 <adc_lld_stop_adc>:
/**
 * @brief   Stops an ongoing conversion, if any.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_stop_adc(ADCDriver *adcp) {
 8001c20:	b082      	sub	sp, #8
 8001c22:	9001      	str	r0, [sp, #4]

  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8001c24:	9b01      	ldr	r3, [sp, #4]
 8001c26:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c28:	689b      	ldr	r3, [r3, #8]
 8001c2a:	f003 0304 	and.w	r3, r3, #4
 8001c2e:	2b00      	cmp	r3, #0
 8001c30:	d00f      	beq.n	8001c52 <adc_lld_stop_adc+0x32>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8001c32:	9b01      	ldr	r3, [sp, #4]
 8001c34:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c36:	689a      	ldr	r2, [r3, #8]
 8001c38:	9b01      	ldr	r3, [sp, #4]
 8001c3a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c3c:	f042 0210 	orr.w	r2, r2, #16
 8001c40:	609a      	str	r2, [r3, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8001c42:	bf00      	nop
 8001c44:	9b01      	ldr	r3, [sp, #4]
 8001c46:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c48:	689b      	ldr	r3, [r3, #8]
 8001c4a:	f003 0310 	and.w	r3, r3, #16
 8001c4e:	2b00      	cmp	r3, #0
 8001c50:	d1f8      	bne.n	8001c44 <adc_lld_stop_adc+0x24>
      ;
  }
  adcp->adcm->PCSEL = 0U;
 8001c52:	9b01      	ldr	r3, [sp, #4]
 8001c54:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c56:	2200      	movs	r2, #0
 8001c58:	61da      	str	r2, [r3, #28]
}
 8001c5a:	bf00      	nop
 8001c5c:	b002      	add	sp, #8
 8001c5e:	4770      	bx	lr

08001c60 <adc_lld_serve_dma_interrupt>:
 * @brief   ADC DMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001c60:	b500      	push	{lr}
 8001c62:	b083      	sub	sp, #12
 8001c64:	9001      	str	r0, [sp, #4]
 8001c66:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001c68:	9b00      	ldr	r3, [sp, #0]
 8001c6a:	f003 030c 	and.w	r3, r3, #12
 8001c6e:	2b00      	cmp	r3, #0
 8001c70:	d02d      	beq.n	8001cce <adc_lld_serve_dma_interrupt+0x6e>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8001c72:	9801      	ldr	r0, [sp, #4]
 8001c74:	f000 fbec 	bl	8002450 <adc_lld_stop_conversion>
 8001c78:	9b01      	ldr	r3, [sp, #4]
 8001c7a:	691b      	ldr	r3, [r3, #16]
 8001c7c:	68db      	ldr	r3, [r3, #12]
 8001c7e:	2b00      	cmp	r3, #0
 8001c80:	d013      	beq.n	8001caa <adc_lld_serve_dma_interrupt+0x4a>
 8001c82:	9b01      	ldr	r3, [sp, #4]
 8001c84:	2205      	movs	r2, #5
 8001c86:	701a      	strb	r2, [r3, #0]
 8001c88:	9b01      	ldr	r3, [sp, #4]
 8001c8a:	691b      	ldr	r3, [r3, #16]
 8001c8c:	68db      	ldr	r3, [r3, #12]
 8001c8e:	2101      	movs	r1, #1
 8001c90:	9801      	ldr	r0, [sp, #4]
 8001c92:	4798      	blx	r3
 8001c94:	9b01      	ldr	r3, [sp, #4]
 8001c96:	781b      	ldrb	r3, [r3, #0]
 8001c98:	2b05      	cmp	r3, #5
 8001c9a:	d10c      	bne.n	8001cb6 <adc_lld_serve_dma_interrupt+0x56>
 8001c9c:	9b01      	ldr	r3, [sp, #4]
 8001c9e:	2202      	movs	r2, #2
 8001ca0:	701a      	strb	r2, [r3, #0]
 8001ca2:	9b01      	ldr	r3, [sp, #4]
 8001ca4:	2200      	movs	r2, #0
 8001ca6:	611a      	str	r2, [r3, #16]
 8001ca8:	e005      	b.n	8001cb6 <adc_lld_serve_dma_interrupt+0x56>
 8001caa:	9b01      	ldr	r3, [sp, #4]
 8001cac:	2202      	movs	r2, #2
 8001cae:	701a      	strb	r2, [r3, #0]
 8001cb0:	9b01      	ldr	r3, [sp, #4]
 8001cb2:	2200      	movs	r2, #0
 8001cb4:	611a      	str	r2, [r3, #16]
 8001cb6:	f7ff fe13 	bl	80018e0 <osalSysLockFromISR.lto_priv.0>
 8001cba:	9b01      	ldr	r3, [sp, #4]
 8001cbc:	3314      	adds	r3, #20
 8001cbe:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8001cc2:	4618      	mov	r0, r3
 8001cc4:	f7ff fe2c 	bl	8001920 <osalThreadResumeI.lto_priv.1>
 8001cc8:	f7ff fe12 	bl	80018f0 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8001ccc:	e05d      	b.n	8001d8a <adc_lld_serve_dma_interrupt+0x12a>
    if (adcp->grpp != NULL) {
 8001cce:	9b01      	ldr	r3, [sp, #4]
 8001cd0:	691b      	ldr	r3, [r3, #16]
 8001cd2:	2b00      	cmp	r3, #0
 8001cd4:	d059      	beq.n	8001d8a <adc_lld_serve_dma_interrupt+0x12a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8001cd6:	9b00      	ldr	r3, [sp, #0]
 8001cd8:	f003 0320 	and.w	r3, r3, #32
 8001cdc:	2b00      	cmp	r3, #0
 8001cde:	d045      	beq.n	8001d6c <adc_lld_serve_dma_interrupt+0x10c>
        _adc_isr_full_code(adcp);
 8001ce0:	9b01      	ldr	r3, [sp, #4]
 8001ce2:	691b      	ldr	r3, [r3, #16]
 8001ce4:	781b      	ldrb	r3, [r3, #0]
 8001ce6:	2b00      	cmp	r3, #0
 8001ce8:	d014      	beq.n	8001d14 <adc_lld_serve_dma_interrupt+0xb4>
 8001cea:	9b01      	ldr	r3, [sp, #4]
 8001cec:	691b      	ldr	r3, [r3, #16]
 8001cee:	689b      	ldr	r3, [r3, #8]
 8001cf0:	2b00      	cmp	r3, #0
 8001cf2:	d04a      	beq.n	8001d8a <adc_lld_serve_dma_interrupt+0x12a>
 8001cf4:	9b01      	ldr	r3, [sp, #4]
 8001cf6:	2204      	movs	r2, #4
 8001cf8:	701a      	strb	r2, [r3, #0]
 8001cfa:	9b01      	ldr	r3, [sp, #4]
 8001cfc:	691b      	ldr	r3, [r3, #16]
 8001cfe:	689b      	ldr	r3, [r3, #8]
 8001d00:	9801      	ldr	r0, [sp, #4]
 8001d02:	4798      	blx	r3
 8001d04:	9b01      	ldr	r3, [sp, #4]
 8001d06:	781b      	ldrb	r3, [r3, #0]
 8001d08:	2b04      	cmp	r3, #4
 8001d0a:	d13e      	bne.n	8001d8a <adc_lld_serve_dma_interrupt+0x12a>
 8001d0c:	9b01      	ldr	r3, [sp, #4]
 8001d0e:	2203      	movs	r2, #3
 8001d10:	701a      	strb	r2, [r3, #0]
}
 8001d12:	e03a      	b.n	8001d8a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_full_code(adcp);
 8001d14:	9801      	ldr	r0, [sp, #4]
 8001d16:	f000 fb9b 	bl	8002450 <adc_lld_stop_conversion>
 8001d1a:	9b01      	ldr	r3, [sp, #4]
 8001d1c:	691b      	ldr	r3, [r3, #16]
 8001d1e:	689b      	ldr	r3, [r3, #8]
 8001d20:	2b00      	cmp	r3, #0
 8001d22:	d012      	beq.n	8001d4a <adc_lld_serve_dma_interrupt+0xea>
 8001d24:	9b01      	ldr	r3, [sp, #4]
 8001d26:	2204      	movs	r2, #4
 8001d28:	701a      	strb	r2, [r3, #0]
 8001d2a:	9b01      	ldr	r3, [sp, #4]
 8001d2c:	691b      	ldr	r3, [r3, #16]
 8001d2e:	689b      	ldr	r3, [r3, #8]
 8001d30:	9801      	ldr	r0, [sp, #4]
 8001d32:	4798      	blx	r3
 8001d34:	9b01      	ldr	r3, [sp, #4]
 8001d36:	781b      	ldrb	r3, [r3, #0]
 8001d38:	2b04      	cmp	r3, #4
 8001d3a:	d10c      	bne.n	8001d56 <adc_lld_serve_dma_interrupt+0xf6>
 8001d3c:	9b01      	ldr	r3, [sp, #4]
 8001d3e:	2202      	movs	r2, #2
 8001d40:	701a      	strb	r2, [r3, #0]
 8001d42:	9b01      	ldr	r3, [sp, #4]
 8001d44:	2200      	movs	r2, #0
 8001d46:	611a      	str	r2, [r3, #16]
 8001d48:	e005      	b.n	8001d56 <adc_lld_serve_dma_interrupt+0xf6>
 8001d4a:	9b01      	ldr	r3, [sp, #4]
 8001d4c:	2202      	movs	r2, #2
 8001d4e:	701a      	strb	r2, [r3, #0]
 8001d50:	9b01      	ldr	r3, [sp, #4]
 8001d52:	2200      	movs	r2, #0
 8001d54:	611a      	str	r2, [r3, #16]
 8001d56:	f7ff fdc3 	bl	80018e0 <osalSysLockFromISR.lto_priv.0>
 8001d5a:	9b01      	ldr	r3, [sp, #4]
 8001d5c:	3314      	adds	r3, #20
 8001d5e:	2100      	movs	r1, #0
 8001d60:	4618      	mov	r0, r3
 8001d62:	f7ff fddd 	bl	8001920 <osalThreadResumeI.lto_priv.1>
 8001d66:	f7ff fdc3 	bl	80018f0 <osalSysUnlockFromISR.lto_priv.0>
}
 8001d6a:	e00e      	b.n	8001d8a <adc_lld_serve_dma_interrupt+0x12a>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8001d6c:	9b00      	ldr	r3, [sp, #0]
 8001d6e:	f003 0310 	and.w	r3, r3, #16
 8001d72:	2b00      	cmp	r3, #0
 8001d74:	d009      	beq.n	8001d8a <adc_lld_serve_dma_interrupt+0x12a>
        _adc_isr_half_code(adcp);
 8001d76:	9b01      	ldr	r3, [sp, #4]
 8001d78:	691b      	ldr	r3, [r3, #16]
 8001d7a:	689b      	ldr	r3, [r3, #8]
 8001d7c:	2b00      	cmp	r3, #0
 8001d7e:	d004      	beq.n	8001d8a <adc_lld_serve_dma_interrupt+0x12a>
 8001d80:	9b01      	ldr	r3, [sp, #4]
 8001d82:	691b      	ldr	r3, [r3, #16]
 8001d84:	689b      	ldr	r3, [r3, #8]
 8001d86:	9801      	ldr	r0, [sp, #4]
 8001d88:	4798      	blx	r3
}
 8001d8a:	bf00      	nop
 8001d8c:	b003      	add	sp, #12
 8001d8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d92:	bf00      	nop
	...

08001da0 <adc_lld_serve_bdma_interrupt>:
 * @brief   ADC BDMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_bdma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001da0:	b500      	push	{lr}
 8001da2:	b083      	sub	sp, #12
 8001da4:	9001      	str	r0, [sp, #4]
 8001da6:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & STM32_BDMA_ISR_TEIF) != 0) {
 8001da8:	9b00      	ldr	r3, [sp, #0]
 8001daa:	f003 0308 	and.w	r3, r3, #8
 8001dae:	2b00      	cmp	r3, #0
 8001db0:	d02d      	beq.n	8001e0e <adc_lld_serve_bdma_interrupt+0x6e>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8001db2:	9801      	ldr	r0, [sp, #4]
 8001db4:	f000 fb4c 	bl	8002450 <adc_lld_stop_conversion>
 8001db8:	9b01      	ldr	r3, [sp, #4]
 8001dba:	691b      	ldr	r3, [r3, #16]
 8001dbc:	68db      	ldr	r3, [r3, #12]
 8001dbe:	2b00      	cmp	r3, #0
 8001dc0:	d013      	beq.n	8001dea <adc_lld_serve_bdma_interrupt+0x4a>
 8001dc2:	9b01      	ldr	r3, [sp, #4]
 8001dc4:	2205      	movs	r2, #5
 8001dc6:	701a      	strb	r2, [r3, #0]
 8001dc8:	9b01      	ldr	r3, [sp, #4]
 8001dca:	691b      	ldr	r3, [r3, #16]
 8001dcc:	68db      	ldr	r3, [r3, #12]
 8001dce:	2101      	movs	r1, #1
 8001dd0:	9801      	ldr	r0, [sp, #4]
 8001dd2:	4798      	blx	r3
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	781b      	ldrb	r3, [r3, #0]
 8001dd8:	2b05      	cmp	r3, #5
 8001dda:	d10c      	bne.n	8001df6 <adc_lld_serve_bdma_interrupt+0x56>
 8001ddc:	9b01      	ldr	r3, [sp, #4]
 8001dde:	2202      	movs	r2, #2
 8001de0:	701a      	strb	r2, [r3, #0]
 8001de2:	9b01      	ldr	r3, [sp, #4]
 8001de4:	2200      	movs	r2, #0
 8001de6:	611a      	str	r2, [r3, #16]
 8001de8:	e005      	b.n	8001df6 <adc_lld_serve_bdma_interrupt+0x56>
 8001dea:	9b01      	ldr	r3, [sp, #4]
 8001dec:	2202      	movs	r2, #2
 8001dee:	701a      	strb	r2, [r3, #0]
 8001df0:	9b01      	ldr	r3, [sp, #4]
 8001df2:	2200      	movs	r2, #0
 8001df4:	611a      	str	r2, [r3, #16]
 8001df6:	f7ff fd73 	bl	80018e0 <osalSysLockFromISR.lto_priv.0>
 8001dfa:	9b01      	ldr	r3, [sp, #4]
 8001dfc:	3314      	adds	r3, #20
 8001dfe:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8001e02:	4618      	mov	r0, r3
 8001e04:	f7ff fd8c 	bl	8001920 <osalThreadResumeI.lto_priv.1>
 8001e08:	f7ff fd72 	bl	80018f0 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8001e0c:	e05d      	b.n	8001eca <adc_lld_serve_bdma_interrupt+0x12a>
    if (adcp->grpp != NULL) {
 8001e0e:	9b01      	ldr	r3, [sp, #4]
 8001e10:	691b      	ldr	r3, [r3, #16]
 8001e12:	2b00      	cmp	r3, #0
 8001e14:	d059      	beq.n	8001eca <adc_lld_serve_bdma_interrupt+0x12a>
      if ((flags & STM32_BDMA_ISR_TCIF) != 0) {
 8001e16:	9b00      	ldr	r3, [sp, #0]
 8001e18:	f003 0302 	and.w	r3, r3, #2
 8001e1c:	2b00      	cmp	r3, #0
 8001e1e:	d045      	beq.n	8001eac <adc_lld_serve_bdma_interrupt+0x10c>
        _adc_isr_full_code(adcp);
 8001e20:	9b01      	ldr	r3, [sp, #4]
 8001e22:	691b      	ldr	r3, [r3, #16]
 8001e24:	781b      	ldrb	r3, [r3, #0]
 8001e26:	2b00      	cmp	r3, #0
 8001e28:	d014      	beq.n	8001e54 <adc_lld_serve_bdma_interrupt+0xb4>
 8001e2a:	9b01      	ldr	r3, [sp, #4]
 8001e2c:	691b      	ldr	r3, [r3, #16]
 8001e2e:	689b      	ldr	r3, [r3, #8]
 8001e30:	2b00      	cmp	r3, #0
 8001e32:	d04a      	beq.n	8001eca <adc_lld_serve_bdma_interrupt+0x12a>
 8001e34:	9b01      	ldr	r3, [sp, #4]
 8001e36:	2204      	movs	r2, #4
 8001e38:	701a      	strb	r2, [r3, #0]
 8001e3a:	9b01      	ldr	r3, [sp, #4]
 8001e3c:	691b      	ldr	r3, [r3, #16]
 8001e3e:	689b      	ldr	r3, [r3, #8]
 8001e40:	9801      	ldr	r0, [sp, #4]
 8001e42:	4798      	blx	r3
 8001e44:	9b01      	ldr	r3, [sp, #4]
 8001e46:	781b      	ldrb	r3, [r3, #0]
 8001e48:	2b04      	cmp	r3, #4
 8001e4a:	d13e      	bne.n	8001eca <adc_lld_serve_bdma_interrupt+0x12a>
 8001e4c:	9b01      	ldr	r3, [sp, #4]
 8001e4e:	2203      	movs	r2, #3
 8001e50:	701a      	strb	r2, [r3, #0]
}
 8001e52:	e03a      	b.n	8001eca <adc_lld_serve_bdma_interrupt+0x12a>
        _adc_isr_full_code(adcp);
 8001e54:	9801      	ldr	r0, [sp, #4]
 8001e56:	f000 fafb 	bl	8002450 <adc_lld_stop_conversion>
 8001e5a:	9b01      	ldr	r3, [sp, #4]
 8001e5c:	691b      	ldr	r3, [r3, #16]
 8001e5e:	689b      	ldr	r3, [r3, #8]
 8001e60:	2b00      	cmp	r3, #0
 8001e62:	d012      	beq.n	8001e8a <adc_lld_serve_bdma_interrupt+0xea>
 8001e64:	9b01      	ldr	r3, [sp, #4]
 8001e66:	2204      	movs	r2, #4
 8001e68:	701a      	strb	r2, [r3, #0]
 8001e6a:	9b01      	ldr	r3, [sp, #4]
 8001e6c:	691b      	ldr	r3, [r3, #16]
 8001e6e:	689b      	ldr	r3, [r3, #8]
 8001e70:	9801      	ldr	r0, [sp, #4]
 8001e72:	4798      	blx	r3
 8001e74:	9b01      	ldr	r3, [sp, #4]
 8001e76:	781b      	ldrb	r3, [r3, #0]
 8001e78:	2b04      	cmp	r3, #4
 8001e7a:	d10c      	bne.n	8001e96 <adc_lld_serve_bdma_interrupt+0xf6>
 8001e7c:	9b01      	ldr	r3, [sp, #4]
 8001e7e:	2202      	movs	r2, #2
 8001e80:	701a      	strb	r2, [r3, #0]
 8001e82:	9b01      	ldr	r3, [sp, #4]
 8001e84:	2200      	movs	r2, #0
 8001e86:	611a      	str	r2, [r3, #16]
 8001e88:	e005      	b.n	8001e96 <adc_lld_serve_bdma_interrupt+0xf6>
 8001e8a:	9b01      	ldr	r3, [sp, #4]
 8001e8c:	2202      	movs	r2, #2
 8001e8e:	701a      	strb	r2, [r3, #0]
 8001e90:	9b01      	ldr	r3, [sp, #4]
 8001e92:	2200      	movs	r2, #0
 8001e94:	611a      	str	r2, [r3, #16]
 8001e96:	f7ff fd23 	bl	80018e0 <osalSysLockFromISR.lto_priv.0>
 8001e9a:	9b01      	ldr	r3, [sp, #4]
 8001e9c:	3314      	adds	r3, #20
 8001e9e:	2100      	movs	r1, #0
 8001ea0:	4618      	mov	r0, r3
 8001ea2:	f7ff fd3d 	bl	8001920 <osalThreadResumeI.lto_priv.1>
 8001ea6:	f7ff fd23 	bl	80018f0 <osalSysUnlockFromISR.lto_priv.0>
}
 8001eaa:	e00e      	b.n	8001eca <adc_lld_serve_bdma_interrupt+0x12a>
      else if ((flags & STM32_BDMA_ISR_HTIF) != 0) {
 8001eac:	9b00      	ldr	r3, [sp, #0]
 8001eae:	f003 0304 	and.w	r3, r3, #4
 8001eb2:	2b00      	cmp	r3, #0
 8001eb4:	d009      	beq.n	8001eca <adc_lld_serve_bdma_interrupt+0x12a>
        _adc_isr_half_code(adcp);
 8001eb6:	9b01      	ldr	r3, [sp, #4]
 8001eb8:	691b      	ldr	r3, [r3, #16]
 8001eba:	689b      	ldr	r3, [r3, #8]
 8001ebc:	2b00      	cmp	r3, #0
 8001ebe:	d004      	beq.n	8001eca <adc_lld_serve_bdma_interrupt+0x12a>
 8001ec0:	9b01      	ldr	r3, [sp, #4]
 8001ec2:	691b      	ldr	r3, [r3, #16]
 8001ec4:	689b      	ldr	r3, [r3, #8]
 8001ec6:	9801      	ldr	r0, [sp, #4]
 8001ec8:	4798      	blx	r3
}
 8001eca:	bf00      	nop
 8001ecc:	b003      	add	sp, #12
 8001ece:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ed2:	bf00      	nop
	...

08001ee0 <adc_lld_serve_interrupt>:
 * @brief   ADC IRQ service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] isr       content of the ISR register
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 8001ee0:	b500      	push	{lr}
 8001ee2:	b085      	sub	sp, #20
 8001ee4:	9001      	str	r0, [sp, #4]
 8001ee6:	9100      	str	r1, [sp, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8001ee8:	9b01      	ldr	r3, [sp, #4]
 8001eea:	691b      	ldr	r3, [r3, #16]
 8001eec:	2b00      	cmp	r3, #0
 8001eee:	d059      	beq.n	8001fa4 <adc_lld_serve_interrupt+0xc4>
    adcerror_t emask = 0U;
 8001ef0:	2300      	movs	r3, #0
 8001ef2:	9303      	str	r3, [sp, #12]

    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the state is checked too.*/
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8001ef4:	9b00      	ldr	r3, [sp, #0]
 8001ef6:	f003 0310 	and.w	r3, r3, #16
 8001efa:	2b00      	cmp	r3, #0
 8001efc:	d007      	beq.n	8001f0e <adc_lld_serve_interrupt+0x2e>
 8001efe:	9b01      	ldr	r3, [sp, #4]
 8001f00:	781b      	ldrb	r3, [r3, #0]
 8001f02:	2b03      	cmp	r3, #3
 8001f04:	d103      	bne.n	8001f0e <adc_lld_serve_interrupt+0x2e>
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
 8001f06:	9b03      	ldr	r3, [sp, #12]
 8001f08:	f043 0302 	orr.w	r3, r3, #2
 8001f0c:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD1) {
 8001f0e:	9b00      	ldr	r3, [sp, #0]
 8001f10:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8001f14:	2b00      	cmp	r3, #0
 8001f16:	d003      	beq.n	8001f20 <adc_lld_serve_interrupt+0x40>
      /* Analog watchdog 1 error.*/
      emask |= ADC_ERR_AWD1;
 8001f18:	9b03      	ldr	r3, [sp, #12]
 8001f1a:	f043 0304 	orr.w	r3, r3, #4
 8001f1e:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD2) {
 8001f20:	9b00      	ldr	r3, [sp, #0]
 8001f22:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8001f26:	2b00      	cmp	r3, #0
 8001f28:	d003      	beq.n	8001f32 <adc_lld_serve_interrupt+0x52>
      /* Analog watchdog 2 error.*/
      emask |= ADC_ERR_AWD2;
 8001f2a:	9b03      	ldr	r3, [sp, #12]
 8001f2c:	f043 0308 	orr.w	r3, r3, #8
 8001f30:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD3) {
 8001f32:	9b00      	ldr	r3, [sp, #0]
 8001f34:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8001f38:	2b00      	cmp	r3, #0
 8001f3a:	d003      	beq.n	8001f44 <adc_lld_serve_interrupt+0x64>
      /* Analog watchdog 3 error.*/
      emask |= ADC_ERR_AWD3;
 8001f3c:	9b03      	ldr	r3, [sp, #12]
 8001f3e:	f043 0310 	orr.w	r3, r3, #16
 8001f42:	9303      	str	r3, [sp, #12]
    }
    if (emask != 0U) {
 8001f44:	9b03      	ldr	r3, [sp, #12]
 8001f46:	2b00      	cmp	r3, #0
 8001f48:	d02c      	beq.n	8001fa4 <adc_lld_serve_interrupt+0xc4>
      _adc_isr_error_code(adcp, emask);
 8001f4a:	9801      	ldr	r0, [sp, #4]
 8001f4c:	f000 fa80 	bl	8002450 <adc_lld_stop_conversion>
 8001f50:	9b01      	ldr	r3, [sp, #4]
 8001f52:	691b      	ldr	r3, [r3, #16]
 8001f54:	68db      	ldr	r3, [r3, #12]
 8001f56:	2b00      	cmp	r3, #0
 8001f58:	d013      	beq.n	8001f82 <adc_lld_serve_interrupt+0xa2>
 8001f5a:	9b01      	ldr	r3, [sp, #4]
 8001f5c:	2205      	movs	r2, #5
 8001f5e:	701a      	strb	r2, [r3, #0]
 8001f60:	9b01      	ldr	r3, [sp, #4]
 8001f62:	691b      	ldr	r3, [r3, #16]
 8001f64:	68db      	ldr	r3, [r3, #12]
 8001f66:	9903      	ldr	r1, [sp, #12]
 8001f68:	9801      	ldr	r0, [sp, #4]
 8001f6a:	4798      	blx	r3
 8001f6c:	9b01      	ldr	r3, [sp, #4]
 8001f6e:	781b      	ldrb	r3, [r3, #0]
 8001f70:	2b05      	cmp	r3, #5
 8001f72:	d10c      	bne.n	8001f8e <adc_lld_serve_interrupt+0xae>
 8001f74:	9b01      	ldr	r3, [sp, #4]
 8001f76:	2202      	movs	r2, #2
 8001f78:	701a      	strb	r2, [r3, #0]
 8001f7a:	9b01      	ldr	r3, [sp, #4]
 8001f7c:	2200      	movs	r2, #0
 8001f7e:	611a      	str	r2, [r3, #16]
 8001f80:	e005      	b.n	8001f8e <adc_lld_serve_interrupt+0xae>
 8001f82:	9b01      	ldr	r3, [sp, #4]
 8001f84:	2202      	movs	r2, #2
 8001f86:	701a      	strb	r2, [r3, #0]
 8001f88:	9b01      	ldr	r3, [sp, #4]
 8001f8a:	2200      	movs	r2, #0
 8001f8c:	611a      	str	r2, [r3, #16]
 8001f8e:	f7ff fca7 	bl	80018e0 <osalSysLockFromISR.lto_priv.0>
 8001f92:	9b01      	ldr	r3, [sp, #4]
 8001f94:	3314      	adds	r3, #20
 8001f96:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8001f9a:	4618      	mov	r0, r3
 8001f9c:	f7ff fcc0 	bl	8001920 <osalThreadResumeI.lto_priv.1>
 8001fa0:	f7ff fca6 	bl	80018f0 <osalSysUnlockFromISR.lto_priv.0>
    }
  }
}
 8001fa4:	bf00      	nop
 8001fa6:	b005      	add	sp, #20
 8001fa8:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fac:	0000      	movs	r0, r0
	...

08001fb0 <Vector88>:
/**
 * @brief   ADC1/ADC2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC12_HANDLER) {
 8001fb0:	b500      	push	{lr}
 8001fb2:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 8001fb4:	480c      	ldr	r0, [pc, #48]	@ (8001fe8 <Vector88+0x38>)
 8001fb6:	f002 f873 	bl	80040a0 <__trace_isr_enter>
 8001fba:	f001 fed9 	bl	8003d70 <__dbg_check_enter_isr>

  /* Handle ADC1 ISR first in adc_lld_serve_interrupt. */
  isr  = ADC1->ISR;
 8001fbe:	4b0b      	ldr	r3, [pc, #44]	@ (8001fec <Vector88+0x3c>)
 8001fc0:	681b      	ldr	r3, [r3, #0]
 8001fc2:	9301      	str	r3, [sp, #4]
  ADC1->ISR = isr;
 8001fc4:	4a09      	ldr	r2, [pc, #36]	@ (8001fec <Vector88+0x3c>)
 8001fc6:	9b01      	ldr	r3, [sp, #4]
 8001fc8:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC12_IRQ_HOOK)
  STM32_ADC_ADC12_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD1, isr);
 8001fca:	9901      	ldr	r1, [sp, #4]
 8001fcc:	4808      	ldr	r0, [pc, #32]	@ (8001ff0 <Vector88+0x40>)
 8001fce:	f7ff ff87 	bl	8001ee0 <adc_lld_serve_interrupt>
  STM32_ADC_ADC12_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD1, isr);
#endif

  OSAL_IRQ_EPILOGUE();
 8001fd2:	f001 ff05 	bl	8003de0 <__dbg_check_leave_isr>
 8001fd6:	4804      	ldr	r0, [pc, #16]	@ (8001fe8 <Vector88+0x38>)
 8001fd8:	f002 f8a2 	bl	8004120 <__trace_isr_leave>
 8001fdc:	f004 fb20 	bl	8006620 <__port_irq_epilogue>
}
 8001fe0:	bf00      	nop
 8001fe2:	b003      	add	sp, #12
 8001fe4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fe8:	08006a10 	.word	0x08006a10
 8001fec:	40022000 	.word	0x40022000
 8001ff0:	24000000 	.word	0x24000000
	...

08002000 <Vector23C>:
/**
 * @brief   ADC3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC3_HANDLER) {
 8002000:	b500      	push	{lr}
 8002002:	b083      	sub	sp, #12
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();
 8002004:	480c      	ldr	r0, [pc, #48]	@ (8002038 <Vector23C+0x38>)
 8002006:	f002 f84b 	bl	80040a0 <__trace_isr_enter>
 800200a:	f001 feb1 	bl	8003d70 <__dbg_check_enter_isr>

  isr  = ADC3->ISR;
 800200e:	4b0b      	ldr	r3, [pc, #44]	@ (800203c <Vector23C+0x3c>)
 8002010:	681b      	ldr	r3, [r3, #0]
 8002012:	9301      	str	r3, [sp, #4]
  ADC3->ISR = isr;
 8002014:	4a09      	ldr	r2, [pc, #36]	@ (800203c <Vector23C+0x3c>)
 8002016:	9b01      	ldr	r3, [sp, #4]
 8002018:	6013      	str	r3, [r2, #0]
#if defined(STM32_ADC_ADC3_IRQ_HOOK)
  STM32_ADC_ADC3_IRQ_HOOK
#endif
  adc_lld_serve_interrupt(&ADCD3, isr);
 800201a:	9901      	ldr	r1, [sp, #4]
 800201c:	4808      	ldr	r0, [pc, #32]	@ (8002040 <Vector23C+0x40>)
 800201e:	f7ff ff5f 	bl	8001ee0 <adc_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8002022:	f001 fedd 	bl	8003de0 <__dbg_check_leave_isr>
 8002026:	4804      	ldr	r0, [pc, #16]	@ (8002038 <Vector23C+0x38>)
 8002028:	f002 f87a 	bl	8004120 <__trace_isr_leave>
 800202c:	f004 faf8 	bl	8006620 <__port_irq_epilogue>
}
 8002030:	bf00      	nop
 8002032:	b003      	add	sp, #12
 8002034:	f85d fb04 	ldr.w	pc, [sp], #4
 8002038:	08006a1c 	.word	0x08006a1c
 800203c:	58026000 	.word	0x58026000
 8002040:	24000038 	.word	0x24000038
	...

08002050 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8002050:	b508      	push	{r3, lr}

#if STM32_ADC_USE_ADC12 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8002052:	4823      	ldr	r0, [pc, #140]	@ (80020e0 <adc_lld_init+0x90>)
 8002054:	f7fe fc1c 	bl	8000890 <adcObjectInit>
  ADCD1.adcc        = ADC12_COMMON;
 8002058:	4b21      	ldr	r3, [pc, #132]	@ (80020e0 <adc_lld_init+0x90>)
 800205a:	4a22      	ldr	r2, [pc, #136]	@ (80020e4 <adc_lld_init+0x94>)
 800205c:	62da      	str	r2, [r3, #44]	@ 0x2c
  ADCD1.adcm        = ADC1;
 800205e:	4b20      	ldr	r3, [pc, #128]	@ (80020e0 <adc_lld_init+0x90>)
 8002060:	4a21      	ldr	r2, [pc, #132]	@ (80020e8 <adc_lld_init+0x98>)
 8002062:	629a      	str	r2, [r3, #40]	@ 0x28
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs        = ADC2;
#endif
  ADCD1.data.dma    = NULL;
 8002064:	4b1e      	ldr	r3, [pc, #120]	@ (80020e0 <adc_lld_init+0x90>)
 8002066:	2200      	movs	r2, #0
 8002068:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD1.dmamode     = ADC12_DMA_SIZE |
 800206a:	4b1d      	ldr	r3, [pc, #116]	@ (80020e0 <adc_lld_init+0x90>)
 800206c:	4a1f      	ldr	r2, [pc, #124]	@ (80020ec <adc_lld_init+0x9c>)
 800206e:	635a      	str	r2, [r3, #52]	@ 0x34
                      STM32_DMA_CR_PL(STM32_ADC_ADC12_DMA_PRIORITY) |
                      STM32_DMA_CR_DIR_P2M  |
                      STM32_DMA_CR_MINC     | STM32_DMA_CR_TCIE     |
                      STM32_DMA_CR_DMEIE    | STM32_DMA_CR_TEIE;
  nvicEnableVector(STM32_ADC12_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 8002070:	2105      	movs	r1, #5
 8002072:	2012      	movs	r0, #18
 8002074:	f7fe febc 	bl	8000df0 <nvicEnableVector>
#endif /* STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_USE_ADC3 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
 8002078:	481d      	ldr	r0, [pc, #116]	@ (80020f0 <adc_lld_init+0xa0>)
 800207a:	f7fe fc09 	bl	8000890 <adcObjectInit>
  ADCD3.adcc        = ADC3_COMMON;
 800207e:	4b1c      	ldr	r3, [pc, #112]	@ (80020f0 <adc_lld_init+0xa0>)
 8002080:	4a1c      	ldr	r2, [pc, #112]	@ (80020f4 <adc_lld_init+0xa4>)
 8002082:	62da      	str	r2, [r3, #44]	@ 0x2c
  ADCD3.adcm        = ADC3;
 8002084:	4b1a      	ldr	r3, [pc, #104]	@ (80020f0 <adc_lld_init+0xa0>)
 8002086:	4a1c      	ldr	r2, [pc, #112]	@ (80020f8 <adc_lld_init+0xa8>)
 8002088:	629a      	str	r2, [r3, #40]	@ 0x28
  ADCD3.data.bdma   = NULL;
 800208a:	4b19      	ldr	r3, [pc, #100]	@ (80020f0 <adc_lld_init+0xa0>)
 800208c:	2200      	movs	r2, #0
 800208e:	631a      	str	r2, [r3, #48]	@ 0x30
  ADCD3.dmamode     = ADC3_BDMA_SIZE |
 8002090:	4b17      	ldr	r3, [pc, #92]	@ (80020f0 <adc_lld_init+0xa0>)
 8002092:	f242 528a 	movw	r2, #9610	@ 0x258a
 8002096:	635a      	str	r2, [r3, #52]	@ 0x34
                      STM32_BDMA_CR_PL(STM32_ADC_ADC3_DMA_PRIORITY)  |
                      STM32_BDMA_CR_DIR_P2M  |
                      STM32_BDMA_CR_MINC     | STM32_BDMA_CR_TCIE     |
                                               STM32_BDMA_CR_TEIE;
  nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
 8002098:	2105      	movs	r1, #5
 800209a:	207f      	movs	r0, #127	@ 0x7f
 800209c:	f7fe fea8 	bl	8000df0 <nvicEnableVector>
#endif /* STM32_ADC_USE_ADC3 == TRUE */

  /* ADC units pre-initializations.*/
#if (STM32_HAS_ADC1 == TRUE) && (STM32_HAS_ADC2 == TRUE)
#if STM32_ADC_USE_ADC12 == TRUE
  rccEnableADC12(true);
 80020a0:	2101      	movs	r1, #1
 80020a2:	2020      	movs	r0, #32
 80020a4:	f7ff fc8c 	bl	80019c0 <rccEnableAHB1.lto_priv.0>
  rccResetADC12();
 80020a8:	2020      	movs	r0, #32
 80020aa:	f7ff fcd9 	bl	8001a60 <rccResetAHB1>
  ADC12_COMMON->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_DAMDF | ADC12_CCR_DUAL;
 80020ae:	4b0d      	ldr	r3, [pc, #52]	@ (80020e4 <adc_lld_init+0x94>)
 80020b0:	2200      	movs	r2, #0
 80020b2:	609a      	str	r2, [r3, #8]
  rccDisableADC12();
 80020b4:	2020      	movs	r0, #32
 80020b6:	f7ff fcb3 	bl	8001a20 <rccDisableAHB1.lto_priv.0>
#endif
#if STM32_ADC_USE_ADC3 == TRUE
  rccEnableADC3(true);
 80020ba:	2101      	movs	r1, #1
 80020bc:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
 80020c0:	f7ff fcde 	bl	8001a80 <rccEnableAHB4.lto_priv.1>
  rccResetADC3();
 80020c4:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
 80020c8:	f7ff fd2a 	bl	8001b20 <rccResetAHB4>
  ADC3_COMMON->CCR = STM32_ADC_ADC3_CLOCK_MODE;
 80020cc:	4b09      	ldr	r3, [pc, #36]	@ (80020f4 <adc_lld_init+0xa4>)
 80020ce:	2200      	movs	r2, #0
 80020d0:	609a      	str	r2, [r3, #8]
  rccDisableADC3();
 80020d2:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
 80020d6:	f7ff fd03 	bl	8001ae0 <rccDisableAHB4.lto_priv.0>
#endif
#endif
}
 80020da:	bf00      	nop
 80020dc:	bd08      	pop	{r3, pc}
 80020de:	bf00      	nop
 80020e0:	24000000 	.word	0x24000000
 80020e4:	40022300 	.word	0x40022300
 80020e8:	40022000 	.word	0x40022000
 80020ec:	00022c16 	.word	0x00022c16
 80020f0:	24000038 	.word	0x24000038
 80020f4:	58026300 	.word	0x58026300
 80020f8:	58026000 	.word	0x58026000
 80020fc:	00000000 	.word	0x00000000

08002100 <adc_lld_start>:
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @return              The operation status.
 *
 * @notapi
 */
msg_t adc_lld_start(ADCDriver *adcp) {
 8002100:	b500      	push	{lr}
 8002102:	b083      	sub	sp, #12
 8002104:	9001      	str	r0, [sp, #4]

  /* Handling the default configuration.*/
  if (adcp->config == NULL) {
 8002106:	9b01      	ldr	r3, [sp, #4]
 8002108:	685b      	ldr	r3, [r3, #4]
 800210a:	2b00      	cmp	r3, #0
 800210c:	d102      	bne.n	8002114 <adc_lld_start+0x14>
    adcp->config = &default_config;
 800210e:	9b01      	ldr	r3, [sp, #4]
 8002110:	4a44      	ldr	r2, [pc, #272]	@ (8002224 <adc_lld_start+0x124>)
 8002112:	605a      	str	r2, [r3, #4]
  }

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8002114:	9b01      	ldr	r3, [sp, #4]
 8002116:	781b      	ldrb	r3, [r3, #0]
 8002118:	2b01      	cmp	r3, #1
 800211a:	d17e      	bne.n	800221a <adc_lld_start+0x11a>
#if STM32_ADC_USE_ADC12 == TRUE
    if (&ADCD1 == adcp) {
 800211c:	9b01      	ldr	r3, [sp, #4]
 800211e:	4a42      	ldr	r2, [pc, #264]	@ (8002228 <adc_lld_start+0x128>)
 8002120:	4293      	cmp	r3, r2
 8002122:	d12b      	bne.n	800217c <adc_lld_start+0x7c>
      adcp->data.dma = dmaStreamAllocI(STM32_ADC_ADC12_DMA_STREAM,
 8002124:	9b01      	ldr	r3, [sp, #4]
 8002126:	4a41      	ldr	r2, [pc, #260]	@ (800222c <adc_lld_start+0x12c>)
 8002128:	2105      	movs	r1, #5
 800212a:	2010      	movs	r0, #16
 800212c:	f000 ffe8 	bl	8003100 <dmaStreamAllocI>
 8002130:	4602      	mov	r2, r0
 8002132:	9b01      	ldr	r3, [sp, #4]
 8002134:	631a      	str	r2, [r3, #48]	@ 0x30
                                       STM32_ADC_ADC12_IRQ_PRIORITY,
                                       (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                                       (void *)adcp);
      if (adcp->data.dma == NULL) {
 8002136:	9b01      	ldr	r3, [sp, #4]
 8002138:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800213a:	2b00      	cmp	r3, #0
 800213c:	d102      	bne.n	8002144 <adc_lld_start+0x44>
        return HAL_RET_NO_RESOURCE;
 800213e:	f06f 0310 	mvn.w	r3, #16
 8002142:	e06b      	b.n	800221c <adc_lld_start+0x11c>
      }

      rccEnableADC12(true);
 8002144:	2101      	movs	r1, #1
 8002146:	2020      	movs	r0, #32
 8002148:	f7ff fc3a 	bl	80019c0 <rccEnableAHB1.lto_priv.0>
      rccResetADC12();
 800214c:	2020      	movs	r0, #32
 800214e:	f7ff fc87 	bl	8001a60 <rccResetAHB1>

      dmaSetRequestSource(adcp->data.dma, STM32_DMAMUX1_ADC1);
 8002152:	9b01      	ldr	r3, [sp, #4]
 8002154:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002156:	2109      	movs	r1, #9
 8002158:	4618      	mov	r0, r3
 800215a:	f001 f871 	bl	8003240 <dmaSetRequestSource>

      /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
      dmaStreamSetPeripheral(adcp->data.dma, &adcp->adcc->CDR);
#else
      dmaStreamSetPeripheral(adcp->data.dma, &adcp->adcm->DR);
 800215e:	9b01      	ldr	r3, [sp, #4]
 8002160:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002162:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 8002166:	9b01      	ldr	r3, [sp, #4]
 8002168:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800216a:	681b      	ldr	r3, [r3, #0]
 800216c:	609a      	str	r2, [r3, #8]
      /* Differential channels setting.*/
#if STM32_ADC_DUAL_MODE
      adcp->adcm->DIFSEL = adcp->config->difsel;
      adcp->adcs->DIFSEL = adcp->config->difsel;
#else
      adcp->adcm->DIFSEL = adcp->config->difsel;
 800216e:	9b01      	ldr	r3, [sp, #4]
 8002170:	685a      	ldr	r2, [r3, #4]
 8002172:	9b01      	ldr	r3, [sp, #4]
 8002174:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002176:	6812      	ldr	r2, [r2, #0]
 8002178:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
#endif
    }
#endif /* STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_USE_ADC3 == TRUE
    if (&ADCD3 == adcp) {
 800217c:	9b01      	ldr	r3, [sp, #4]
 800217e:	4a2c      	ldr	r2, [pc, #176]	@ (8002230 <adc_lld_start+0x130>)
 8002180:	4293      	cmp	r3, r2
 8002182:	d12d      	bne.n	80021e0 <adc_lld_start+0xe0>
      adcp->data.bdma = bdmaStreamAllocI(STM32_ADC_ADC3_BDMA_STREAM,
 8002184:	9b01      	ldr	r3, [sp, #4]
 8002186:	4a2b      	ldr	r2, [pc, #172]	@ (8002234 <adc_lld_start+0x134>)
 8002188:	2105      	movs	r1, #5
 800218a:	2008      	movs	r0, #8
 800218c:	f000 fbb0 	bl	80028f0 <bdmaStreamAllocI>
 8002190:	4602      	mov	r2, r0
 8002192:	9b01      	ldr	r3, [sp, #4]
 8002194:	631a      	str	r2, [r3, #48]	@ 0x30
                                         STM32_ADC_ADC3_IRQ_PRIORITY,
                                         (stm32_dmaisr_t)adc_lld_serve_bdma_interrupt,
                                         (void *)adcp);
      if (adcp->data.bdma == NULL) {
 8002196:	9b01      	ldr	r3, [sp, #4]
 8002198:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800219a:	2b00      	cmp	r3, #0
 800219c:	d102      	bne.n	80021a4 <adc_lld_start+0xa4>
        return HAL_RET_NO_RESOURCE;
 800219e:	f06f 0310 	mvn.w	r3, #16
 80021a2:	e03b      	b.n	800221c <adc_lld_start+0x11c>
      }

      rccEnableADC3(true);
 80021a4:	2101      	movs	r1, #1
 80021a6:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
 80021aa:	f7ff fc69 	bl	8001a80 <rccEnableAHB4.lto_priv.1>
      rccResetADC3();
 80021ae:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
 80021b2:	f7ff fcb5 	bl	8001b20 <rccResetAHB4>

      bdmaSetRequestSource(adcp->data.bdma, STM32_DMAMUX2_ADC3_REQ);
 80021b6:	9b01      	ldr	r3, [sp, #4]
 80021b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80021ba:	2111      	movs	r1, #17
 80021bc:	4618      	mov	r0, r3
 80021be:	f000 fc17 	bl	80029f0 <bdmaSetRequestSource>

      /* Setting DMA peripheral-side pointer.*/
      bdmaStreamSetPeripheral(adcp->data.bdma, &adcp->adcm->DR);
 80021c2:	9b01      	ldr	r3, [sp, #4]
 80021c4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80021c6:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 80021ca:	9b01      	ldr	r3, [sp, #4]
 80021cc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80021ce:	685b      	ldr	r3, [r3, #4]
 80021d0:	609a      	str	r2, [r3, #8]

      /* Differential channels setting.*/
      adcp->adcm->DIFSEL = adcp->config->difsel;
 80021d2:	9b01      	ldr	r3, [sp, #4]
 80021d4:	685a      	ldr	r2, [r3, #4]
 80021d6:	9b01      	ldr	r3, [sp, #4]
 80021d8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80021da:	6812      	ldr	r2, [r2, #0]
 80021dc:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
    }
#endif /* STM32_ADC_USE_ADC3 == TRUE */

    /* Master ADC calibration.*/
    adc_lld_vreg_on(adcp);
 80021e0:	9801      	ldr	r0, [sp, #4]
 80021e2:	f7ff fcad 	bl	8001b40 <adc_lld_vreg_on>
    adc_lld_calibrate(adcp);
 80021e6:	9801      	ldr	r0, [sp, #4]
 80021e8:	f7ff fcda 	bl	8001ba0 <adc_lld_calibrate>

    /* Configure the ADC boost. */
#if STM32_ADC_USE_ADC12 == TRUE
    if (&ADCD1 == adcp) {
 80021ec:	9b01      	ldr	r3, [sp, #4]
 80021ee:	4a0e      	ldr	r2, [pc, #56]	@ (8002228 <adc_lld_start+0x128>)
 80021f0:	4293      	cmp	r3, r2
 80021f2:	d105      	bne.n	8002200 <adc_lld_start+0x100>
      adcp->adcm->CR |= STM32_ADC12_BOOST;
 80021f4:	9b01      	ldr	r3, [sp, #4]
 80021f6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80021fc:	6892      	ldr	r2, [r2, #8]
 80021fe:	609a      	str	r2, [r3, #8]
#endif
    }
#endif

#if STM32_ADC_USE_ADC3 == TRUE
    if (&ADCD3 == adcp) {
 8002200:	9b01      	ldr	r3, [sp, #4]
 8002202:	4a0b      	ldr	r2, [pc, #44]	@ (8002230 <adc_lld_start+0x130>)
 8002204:	4293      	cmp	r3, r2
 8002206:	d105      	bne.n	8002214 <adc_lld_start+0x114>
      adcp->adcm->CR |= STM32_ADC3_BOOST;
 8002208:	9b01      	ldr	r3, [sp, #4]
 800220a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800220c:	9b01      	ldr	r3, [sp, #4]
 800220e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002210:	6892      	ldr	r2, [r2, #8]
 8002212:	609a      	str	r2, [r3, #8]
    }
#endif

    /* Master ADC enabled here in order to reduce conversions latencies.*/
    adc_lld_analog_on(adcp);
 8002214:	9801      	ldr	r0, [sp, #4]
 8002216:	f7ff fca3 	bl	8001b60 <adc_lld_analog_on>
  }

  return HAL_RET_SUCCESS;
 800221a:	2300      	movs	r3, #0
}
 800221c:	4618      	mov	r0, r3
 800221e:	b003      	add	sp, #12
 8002220:	f85d fb04 	ldr.w	pc, [sp], #4
 8002224:	080069f4 	.word	0x080069f4
 8002228:	24000000 	.word	0x24000000
 800222c:	08001c61 	.word	0x08001c61
 8002230:	24000038 	.word	0x24000038
 8002234:	08001da1 	.word	0x08001da1
	...

08002240 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 8002240:	b086      	sub	sp, #24
 8002242:	9001      	str	r0, [sp, #4]
  uint32_t dmamode, cfgr = 0U;
 8002244:	2300      	movs	r3, #0
 8002246:	9304      	str	r3, [sp, #16]
  const ADCConversionGroup *grpp = adcp->grpp;
 8002248:	9b01      	ldr	r3, [sp, #4]
 800224a:	691b      	ldr	r3, [r3, #16]
 800224c:	9303      	str	r3, [sp, #12]

#if STM32_ADC_USE_ADC12 == TRUE
#if STM32_ADC_DUAL_MODE
  uint32_t ccr;
#endif
  if (&ADCD1 == adcp) {
 800224e:	9b01      	ldr	r3, [sp, #4]
 8002250:	4a7c      	ldr	r2, [pc, #496]	@ (8002444 <adc_lld_start_conversion+0x204>)
 8002252:	4293      	cmp	r3, r2
 8002254:	d13c      	bne.n	80022d0 <adc_lld_start_conversion+0x90>
    osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                  "odd number of channels in dual mode");
#endif

    /* Calculating control registers values.*/
    dmamode = adcp->dmamode;
 8002256:	9b01      	ldr	r3, [sp, #4]
 8002258:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800225a:	9305      	str	r3, [sp, #20]
    if (grpp->circular) {
 800225c:	9b03      	ldr	r3, [sp, #12]
 800225e:	781b      	ldrb	r3, [r3, #0]
 8002260:	2b00      	cmp	r3, #0
 8002262:	d011      	beq.n	8002288 <adc_lld_start_conversion+0x48>
      dmamode |= STM32_DMA_CR_CIRC;
 8002264:	9b05      	ldr	r3, [sp, #20]
 8002266:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800226a:	9305      	str	r3, [sp, #20]
      cfgr = grpp->cfgr | ADC_CFGR_DMNGT_CIRCULAR;
 800226c:	9b03      	ldr	r3, [sp, #12]
 800226e:	691b      	ldr	r3, [r3, #16]
 8002270:	f043 0303 	orr.w	r3, r3, #3
 8002274:	9304      	str	r3, [sp, #16]
      if (adcp->depth > 1) {
 8002276:	9b01      	ldr	r3, [sp, #4]
 8002278:	68db      	ldr	r3, [r3, #12]
 800227a:	2b01      	cmp	r3, #1
 800227c:	d909      	bls.n	8002292 <adc_lld_start_conversion+0x52>
        /* If circular buffer depth > 1, then the half transfer interrupt
           is enabled in order to allow streaming processing.*/
        dmamode |= STM32_DMA_CR_HTIE;
 800227e:	9b05      	ldr	r3, [sp, #20]
 8002280:	f043 0308 	orr.w	r3, r3, #8
 8002284:	9305      	str	r3, [sp, #20]
 8002286:	e004      	b.n	8002292 <adc_lld_start_conversion+0x52>
      }
    }
    else {
      cfgr = grpp->cfgr | ADC_CFGR_DMNGT_ONESHOT;
 8002288:	9b03      	ldr	r3, [sp, #12]
 800228a:	691b      	ldr	r3, [r3, #16]
 800228c:	f043 0301 	orr.w	r3, r3, #1
 8002290:	9304      	str	r3, [sp, #16]
    }

    /* DMA setup.*/
    dmaStreamSetMemory0(adcp->data.dma, adcp->samples);
 8002292:	9b01      	ldr	r3, [sp, #4]
 8002294:	689a      	ldr	r2, [r3, #8]
 8002296:	9b01      	ldr	r3, [sp, #4]
 8002298:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800229a:	681b      	ldr	r3, [r3, #0]
 800229c:	60da      	str	r2, [r3, #12]
#if STM32_ADC_DUAL_MODE
    dmaStreamSetTransactionSize(adcp->data.dma, ((uint32_t)grpp->num_channels / 2U) *
                                                (uint32_t)adcp->depth);
#else
    dmaStreamSetTransactionSize(adcp->data.dma, (uint32_t)grpp->num_channels *
 800229e:	9b03      	ldr	r3, [sp, #12]
 80022a0:	685a      	ldr	r2, [r3, #4]
 80022a2:	9b01      	ldr	r3, [sp, #4]
 80022a4:	68d9      	ldr	r1, [r3, #12]
 80022a6:	9b01      	ldr	r3, [sp, #4]
 80022a8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80022aa:	681b      	ldr	r3, [r3, #0]
 80022ac:	fb01 f202 	mul.w	r2, r1, r2
 80022b0:	605a      	str	r2, [r3, #4]
                                                (uint32_t)adcp->depth);
#endif
    dmaStreamSetMode(adcp->data.dma, dmamode);
 80022b2:	9b01      	ldr	r3, [sp, #4]
 80022b4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80022b6:	681b      	ldr	r3, [r3, #0]
 80022b8:	9a05      	ldr	r2, [sp, #20]
 80022ba:	601a      	str	r2, [r3, #0]
    dmaStreamEnable(adcp->data.dma);
 80022bc:	9b01      	ldr	r3, [sp, #4]
 80022be:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80022c0:	681b      	ldr	r3, [r3, #0]
 80022c2:	681a      	ldr	r2, [r3, #0]
 80022c4:	9b01      	ldr	r3, [sp, #4]
 80022c6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80022c8:	681b      	ldr	r3, [r3, #0]
 80022ca:	f042 0201 	orr.w	r2, r2, #1
 80022ce:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_USE_ADC3 == TRUE
  if (&ADCD3 == adcp) {
 80022d0:	9b01      	ldr	r3, [sp, #4]
 80022d2:	4a5d      	ldr	r2, [pc, #372]	@ (8002448 <adc_lld_start_conversion+0x208>)
 80022d4:	4293      	cmp	r3, r2
 80022d6:	d13c      	bne.n	8002352 <adc_lld_start_conversion+0x112>
    /* Calculating control registers values.*/
    dmamode = adcp->dmamode;
 80022d8:	9b01      	ldr	r3, [sp, #4]
 80022da:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80022dc:	9305      	str	r3, [sp, #20]
    if (grpp->circular) {
 80022de:	9b03      	ldr	r3, [sp, #12]
 80022e0:	781b      	ldrb	r3, [r3, #0]
 80022e2:	2b00      	cmp	r3, #0
 80022e4:	d011      	beq.n	800230a <adc_lld_start_conversion+0xca>
      dmamode |= STM32_BDMA_CR_CIRC;
 80022e6:	9b05      	ldr	r3, [sp, #20]
 80022e8:	f043 0320 	orr.w	r3, r3, #32
 80022ec:	9305      	str	r3, [sp, #20]
      cfgr = grpp->cfgr | ADC_CFGR_DMNGT_CIRCULAR;
 80022ee:	9b03      	ldr	r3, [sp, #12]
 80022f0:	691b      	ldr	r3, [r3, #16]
 80022f2:	f043 0303 	orr.w	r3, r3, #3
 80022f6:	9304      	str	r3, [sp, #16]
      if (adcp->depth > 1) {
 80022f8:	9b01      	ldr	r3, [sp, #4]
 80022fa:	68db      	ldr	r3, [r3, #12]
 80022fc:	2b01      	cmp	r3, #1
 80022fe:	d909      	bls.n	8002314 <adc_lld_start_conversion+0xd4>
        /* If circular buffer depth > 1, then the half transfer interrupt
           is enabled in order to allow streaming processing.*/
        dmamode |= STM32_BDMA_CR_HTIE;
 8002300:	9b05      	ldr	r3, [sp, #20]
 8002302:	f043 0304 	orr.w	r3, r3, #4
 8002306:	9305      	str	r3, [sp, #20]
 8002308:	e004      	b.n	8002314 <adc_lld_start_conversion+0xd4>
      }
    }
    else {
      cfgr = grpp->cfgr | ADC_CFGR_DMNGT_ONESHOT;
 800230a:	9b03      	ldr	r3, [sp, #12]
 800230c:	691b      	ldr	r3, [r3, #16]
 800230e:	f043 0301 	orr.w	r3, r3, #1
 8002312:	9304      	str	r3, [sp, #16]
    }

    /* DMA setup.*/
    bdmaStreamSetMemory(adcp->data.bdma, adcp->samples);
 8002314:	9b01      	ldr	r3, [sp, #4]
 8002316:	689a      	ldr	r2, [r3, #8]
 8002318:	9b01      	ldr	r3, [sp, #4]
 800231a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800231c:	685b      	ldr	r3, [r3, #4]
 800231e:	60da      	str	r2, [r3, #12]
    bdmaStreamSetTransactionSize(adcp->data.bdma, (uint32_t)grpp->num_channels *
 8002320:	9b03      	ldr	r3, [sp, #12]
 8002322:	685a      	ldr	r2, [r3, #4]
 8002324:	9b01      	ldr	r3, [sp, #4]
 8002326:	68d9      	ldr	r1, [r3, #12]
 8002328:	9b01      	ldr	r3, [sp, #4]
 800232a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800232c:	685b      	ldr	r3, [r3, #4]
 800232e:	fb01 f202 	mul.w	r2, r1, r2
 8002332:	605a      	str	r2, [r3, #4]
                                                (uint32_t)adcp->depth);
    bdmaStreamSetMode(adcp->data.bdma, dmamode);
 8002334:	9b01      	ldr	r3, [sp, #4]
 8002336:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002338:	685b      	ldr	r3, [r3, #4]
 800233a:	9a05      	ldr	r2, [sp, #20]
 800233c:	601a      	str	r2, [r3, #0]
    bdmaStreamEnable(adcp->data.bdma);
 800233e:	9b01      	ldr	r3, [sp, #4]
 8002340:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002342:	685b      	ldr	r3, [r3, #4]
 8002344:	681a      	ldr	r2, [r3, #0]
 8002346:	9b01      	ldr	r3, [sp, #4]
 8002348:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800234a:	685b      	ldr	r3, [r3, #4]
 800234c:	f042 0201 	orr.w	r2, r2, #1
 8002350:	601a      	str	r2, [r3, #0]
#endif /* STM32_ADC_USE_ADC3 == TRUE */

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  /* clear AWD1..3 flags */
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8002352:	9b01      	ldr	r3, [sp, #4]
 8002354:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8002356:	9b01      	ldr	r3, [sp, #4]
 8002358:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800235a:	6812      	ldr	r2, [r2, #0]
 800235c:	601a      	str	r2, [r3, #0]
  /* If a callback is set enable the overflow and analog watch dog interrupts. */
  if (grpp->error_cb != NULL) {
 800235e:	9b03      	ldr	r3, [sp, #12]
 8002360:	68db      	ldr	r3, [r3, #12]
 8002362:	2b00      	cmp	r3, #0
 8002364:	d004      	beq.n	8002370 <adc_lld_start_conversion+0x130>
    adcp->adcm->IER   = ADC_IER_OVRIE | ADC_IER_AWD1IE |
 8002366:	9b01      	ldr	r3, [sp, #4]
 8002368:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800236a:	f44f 7264 	mov.w	r2, #912	@ 0x390
 800236e:	605a      	str	r2, [r3, #4]
#endif /* STM32_ADC_DUAL_MODE == TRUE && STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_DUAL_MODE == FALSE || STM32_ADC_USE_ADC3 == TRUE
  /* Configuration for ADC3 and single mode ADC1 */

    adcp->adcm->CFGR2   = grpp->cfgr2;
 8002370:	9b01      	ldr	r3, [sp, #4]
 8002372:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002374:	9a03      	ldr	r2, [sp, #12]
 8002376:	6952      	ldr	r2, [r2, #20]
 8002378:	611a      	str	r2, [r3, #16]
    adcp->adcm->PCSEL   = grpp->pcsel;
 800237a:	9b01      	ldr	r3, [sp, #4]
 800237c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800237e:	9a03      	ldr	r2, [sp, #12]
 8002380:	69d2      	ldr	r2, [r2, #28]
 8002382:	61da      	str	r2, [r3, #28]
    adcp->adcm->LTR1    = grpp->ltr1;
 8002384:	9b01      	ldr	r3, [sp, #4]
 8002386:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002388:	9a03      	ldr	r2, [sp, #12]
 800238a:	6a12      	ldr	r2, [r2, #32]
 800238c:	621a      	str	r2, [r3, #32]
    adcp->adcm->HTR1    = grpp->htr1;
 800238e:	9b01      	ldr	r3, [sp, #4]
 8002390:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002392:	9a03      	ldr	r2, [sp, #12]
 8002394:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8002396:	625a      	str	r2, [r3, #36]	@ 0x24
    adcp->adcm->LTR2    = grpp->ltr2;
 8002398:	9b01      	ldr	r3, [sp, #4]
 800239a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800239c:	9a03      	ldr	r2, [sp, #12]
 800239e:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 80023a0:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
    adcp->adcm->HTR2    = grpp->htr2;
 80023a4:	9b01      	ldr	r3, [sp, #4]
 80023a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80023a8:	9a03      	ldr	r2, [sp, #12]
 80023aa:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80023ac:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
    adcp->adcm->LTR3    = grpp->ltr3;
 80023b0:	9b01      	ldr	r3, [sp, #4]
 80023b2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80023b4:	9a03      	ldr	r2, [sp, #12]
 80023b6:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 80023b8:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
    adcp->adcm->HTR3    = grpp->htr3;
 80023bc:	9b01      	ldr	r3, [sp, #4]
 80023be:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80023c0:	9a03      	ldr	r2, [sp, #12]
 80023c2:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 80023c4:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
    adcp->adcm->AWD2CR  = grpp->awd2cr;
 80023c8:	9b01      	ldr	r3, [sp, #4]
 80023ca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80023cc:	9a03      	ldr	r2, [sp, #12]
 80023ce:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 80023d0:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    adcp->adcm->AWD3CR  = grpp->awd3cr;
 80023d4:	9b01      	ldr	r3, [sp, #4]
 80023d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80023d8:	9a03      	ldr	r2, [sp, #12]
 80023da:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 80023dc:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
    adcp->adcm->SMPR1   = grpp->smpr[0];
 80023e0:	9b01      	ldr	r3, [sp, #4]
 80023e2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80023e4:	9a03      	ldr	r2, [sp, #12]
 80023e6:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 80023e8:	615a      	str	r2, [r3, #20]
    adcp->adcm->SMPR2   = grpp->smpr[1];
 80023ea:	9b01      	ldr	r3, [sp, #4]
 80023ec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80023ee:	9a03      	ldr	r2, [sp, #12]
 80023f0:	6c52      	ldr	r2, [r2, #68]	@ 0x44
 80023f2:	619a      	str	r2, [r3, #24]
    adcp->adcm->SQR1    = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 80023f4:	9b03      	ldr	r3, [sp, #12]
 80023f6:	6c99      	ldr	r1, [r3, #72]	@ 0x48
 80023f8:	9b03      	ldr	r3, [sp, #12]
 80023fa:	685b      	ldr	r3, [r3, #4]
 80023fc:	1e5a      	subs	r2, r3, #1
 80023fe:	9b01      	ldr	r3, [sp, #4]
 8002400:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002402:	430a      	orrs	r2, r1
 8002404:	631a      	str	r2, [r3, #48]	@ 0x30
    adcp->adcm->SQR2    = grpp->sqr[1];
 8002406:	9b01      	ldr	r3, [sp, #4]
 8002408:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800240a:	9a03      	ldr	r2, [sp, #12]
 800240c:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 800240e:	635a      	str	r2, [r3, #52]	@ 0x34
    adcp->adcm->SQR3    = grpp->sqr[2];
 8002410:	9b01      	ldr	r3, [sp, #4]
 8002412:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002414:	9a03      	ldr	r2, [sp, #12]
 8002416:	6d12      	ldr	r2, [r2, #80]	@ 0x50
 8002418:	639a      	str	r2, [r3, #56]	@ 0x38
    adcp->adcm->SQR4    = grpp->sqr[3];
 800241a:	9b01      	ldr	r3, [sp, #4]
 800241c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800241e:	9a03      	ldr	r2, [sp, #12]
 8002420:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 8002422:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* ADC configuration.*/
    adcp->adcm->CFGR  = cfgr;
 8002424:	9b01      	ldr	r3, [sp, #4]
 8002426:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002428:	9a04      	ldr	r2, [sp, #16]
 800242a:	60da      	str	r2, [r3, #12]
#endif

  /* Starting conversion.*/
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 800242c:	9b01      	ldr	r3, [sp, #4]
 800242e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002430:	689a      	ldr	r2, [r3, #8]
 8002432:	9b01      	ldr	r3, [sp, #4]
 8002434:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002436:	f042 0204 	orr.w	r2, r2, #4
 800243a:	609a      	str	r2, [r3, #8]
}
 800243c:	bf00      	nop
 800243e:	b006      	add	sp, #24
 8002440:	4770      	bx	lr
 8002442:	bf00      	nop
 8002444:	24000000 	.word	0x24000000
 8002448:	24000038 	.word	0x24000038
 800244c:	00000000 	.word	0x00000000

08002450 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8002450:	b500      	push	{lr}
 8002452:	b083      	sub	sp, #12
 8002454:	9001      	str	r0, [sp, #4]

#if STM32_ADC_USE_ADC12 == TRUE
  if (&ADCD1 == adcp) {
 8002456:	9b01      	ldr	r3, [sp, #4]
 8002458:	4a1e      	ldr	r2, [pc, #120]	@ (80024d4 <adc_lld_stop_conversion+0x84>)
 800245a:	4293      	cmp	r3, r2
 800245c:	d11b      	bne.n	8002496 <adc_lld_stop_conversion+0x46>
    dmaStreamDisable(adcp->data.dma);
 800245e:	9b01      	ldr	r3, [sp, #4]
 8002460:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002462:	681b      	ldr	r3, [r3, #0]
 8002464:	681a      	ldr	r2, [r3, #0]
 8002466:	9b01      	ldr	r3, [sp, #4]
 8002468:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800246a:	681b      	ldr	r3, [r3, #0]
 800246c:	f022 021f 	bic.w	r2, r2, #31
 8002470:	601a      	str	r2, [r3, #0]
 8002472:	9b01      	ldr	r3, [sp, #4]
 8002474:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002476:	681b      	ldr	r3, [r3, #0]
 8002478:	681b      	ldr	r3, [r3, #0]
 800247a:	f003 0301 	and.w	r3, r3, #1
 800247e:	2b00      	cmp	r3, #0
 8002480:	d1f7      	bne.n	8002472 <adc_lld_stop_conversion+0x22>
 8002482:	9b01      	ldr	r3, [sp, #4]
 8002484:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002486:	7b1b      	ldrb	r3, [r3, #12]
 8002488:	4619      	mov	r1, r3
 800248a:	9b01      	ldr	r3, [sp, #4]
 800248c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800248e:	685b      	ldr	r3, [r3, #4]
 8002490:	223d      	movs	r2, #61	@ 0x3d
 8002492:	408a      	lsls	r2, r1
 8002494:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_USE_ADC3 == TRUE
  if (&ADCD3 == adcp) {
 8002496:	9b01      	ldr	r3, [sp, #4]
 8002498:	4a0f      	ldr	r2, [pc, #60]	@ (80024d8 <adc_lld_stop_conversion+0x88>)
 800249a:	4293      	cmp	r3, r2
 800249c:	d113      	bne.n	80024c6 <adc_lld_stop_conversion+0x76>
    bdmaStreamDisable(adcp->data.bdma);
 800249e:	9b01      	ldr	r3, [sp, #4]
 80024a0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80024a2:	685b      	ldr	r3, [r3, #4]
 80024a4:	681a      	ldr	r2, [r3, #0]
 80024a6:	9b01      	ldr	r3, [sp, #4]
 80024a8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80024aa:	685b      	ldr	r3, [r3, #4]
 80024ac:	f022 020f 	bic.w	r2, r2, #15
 80024b0:	601a      	str	r2, [r3, #0]
 80024b2:	9b01      	ldr	r3, [sp, #4]
 80024b4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80024b6:	7a1b      	ldrb	r3, [r3, #8]
 80024b8:	4619      	mov	r1, r3
 80024ba:	9b01      	ldr	r3, [sp, #4]
 80024bc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80024be:	681b      	ldr	r3, [r3, #0]
 80024c0:	220e      	movs	r2, #14
 80024c2:	408a      	lsls	r2, r1
 80024c4:	605a      	str	r2, [r3, #4]
  }
#endif /* STM32_ADC_USE_ADC12 == TRUE */

  adc_lld_stop_adc(adcp);
 80024c6:	9801      	ldr	r0, [sp, #4]
 80024c8:	f7ff fbaa 	bl	8001c20 <adc_lld_stop_adc>
}
 80024cc:	bf00      	nop
 80024ce:	b003      	add	sp, #12
 80024d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024d4:	24000000 	.word	0x24000000
 80024d8:	24000038 	.word	0x24000038
 80024dc:	00000000 	.word	0x00000000

080024e0 <adcSTM32EnableVREF>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableVREF(ADCDriver *adcp) {
 80024e0:	b082      	sub	sp, #8
 80024e2:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_VREFEN;
 80024e4:	9b01      	ldr	r3, [sp, #4]
 80024e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80024e8:	689a      	ldr	r2, [r3, #8]
 80024ea:	9b01      	ldr	r3, [sp, #4]
 80024ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80024ee:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 80024f2:	609a      	str	r2, [r3, #8]
}
 80024f4:	bf00      	nop
 80024f6:	b002      	add	sp, #8
 80024f8:	4770      	bx	lr
 80024fa:	bf00      	nop
 80024fc:	0000      	movs	r0, r0
	...

08002500 <adcSTM32EnableTS>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {
 8002500:	b082      	sub	sp, #8
 8002502:	9001      	str	r0, [sp, #4]

  adcp->adcc->CCR |= ADC_CCR_TSEN;
 8002504:	9b01      	ldr	r3, [sp, #4]
 8002506:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002508:	689a      	ldr	r2, [r3, #8]
 800250a:	9b01      	ldr	r3, [sp, #4]
 800250c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800250e:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 8002512:	609a      	str	r2, [r3, #8]
}
 8002514:	bf00      	nop
 8002516:	b002      	add	sp, #8
 8002518:	4770      	bx	lr
 800251a:	bf00      	nop
 800251c:	0000      	movs	r0, r0
	...

08002520 <rccEnableAHB4.lto_priv.2>:
__STATIC_INLINE void rccEnableAHB4(uint32_t mask, bool lp) {
 8002520:	b082      	sub	sp, #8
 8002522:	9001      	str	r0, [sp, #4]
 8002524:	460b      	mov	r3, r1
 8002526:	f88d 3003 	strb.w	r3, [sp, #3]
  RCC_C1->AHB4ENR |= mask;
 800252a:	4b12      	ldr	r3, [pc, #72]	@ (8002574 <rccEnableAHB4.lto_priv.2+0x54>)
 800252c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8002530:	4910      	ldr	r1, [pc, #64]	@ (8002574 <rccEnableAHB4.lto_priv.2+0x54>)
 8002532:	9b01      	ldr	r3, [sp, #4]
 8002534:	4313      	orrs	r3, r2
 8002536:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  if (lp) {
 800253a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800253e:	2b00      	cmp	r3, #0
 8002540:	d008      	beq.n	8002554 <rccEnableAHB4.lto_priv.2+0x34>
    RCC_C1->AHB4LPENR |= mask;
 8002542:	4b0c      	ldr	r3, [pc, #48]	@ (8002574 <rccEnableAHB4.lto_priv.2+0x54>)
 8002544:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8002548:	490a      	ldr	r1, [pc, #40]	@ (8002574 <rccEnableAHB4.lto_priv.2+0x54>)
 800254a:	9b01      	ldr	r3, [sp, #4]
 800254c:	4313      	orrs	r3, r2
 800254e:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
 8002552:	e008      	b.n	8002566 <rccEnableAHB4.lto_priv.2+0x46>
    RCC_C1->AHB4LPENR &= ~mask;
 8002554:	4b07      	ldr	r3, [pc, #28]	@ (8002574 <rccEnableAHB4.lto_priv.2+0x54>)
 8002556:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 800255a:	9b01      	ldr	r3, [sp, #4]
 800255c:	43db      	mvns	r3, r3
 800255e:	4905      	ldr	r1, [pc, #20]	@ (8002574 <rccEnableAHB4.lto_priv.2+0x54>)
 8002560:	4013      	ands	r3, r2
 8002562:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
  (void)RCC_C1->AHB4LPENR;
 8002566:	4b03      	ldr	r3, [pc, #12]	@ (8002574 <rccEnableAHB4.lto_priv.2+0x54>)
 8002568:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
}
 800256c:	bf00      	nop
 800256e:	b002      	add	sp, #8
 8002570:	4770      	bx	lr
 8002572:	bf00      	nop
 8002574:	58024400 	.word	0x58024400
	...

08002580 <Vector244>:
/**
 * @brief   BDMA1 stream 0 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH0_HANDLER) {
 8002580:	b500      	push	{lr}
 8002582:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002584:	4811      	ldr	r0, [pc, #68]	@ (80025cc <Vector244+0x4c>)
 8002586:	f001 fd8b 	bl	80040a0 <__trace_isr_enter>
 800258a:	f001 fbf1 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 800258e:	4b10      	ldr	r3, [pc, #64]	@ (80025d0 <Vector244+0x50>)
 8002590:	681b      	ldr	r3, [r3, #0]
 8002592:	f003 030e 	and.w	r3, r3, #14
 8002596:	9301      	str	r3, [sp, #4]
  BDMA->IFCR = flags << 0U;
 8002598:	4a0d      	ldr	r2, [pc, #52]	@ (80025d0 <Vector244+0x50>)
 800259a:	9b01      	ldr	r3, [sp, #4]
 800259c:	6053      	str	r3, [r2, #4]
  if (bdma.streams[0].func)
 800259e:	4b0d      	ldr	r3, [pc, #52]	@ (80025d4 <Vector244+0x54>)
 80025a0:	685b      	ldr	r3, [r3, #4]
 80025a2:	2b00      	cmp	r3, #0
 80025a4:	d006      	beq.n	80025b4 <Vector244+0x34>
    bdma.streams[0].func(bdma.streams[0].param, flags);
 80025a6:	4b0b      	ldr	r3, [pc, #44]	@ (80025d4 <Vector244+0x54>)
 80025a8:	685b      	ldr	r3, [r3, #4]
 80025aa:	4a0a      	ldr	r2, [pc, #40]	@ (80025d4 <Vector244+0x54>)
 80025ac:	6892      	ldr	r2, [r2, #8]
 80025ae:	9901      	ldr	r1, [sp, #4]
 80025b0:	4610      	mov	r0, r2
 80025b2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80025b4:	f001 fc14 	bl	8003de0 <__dbg_check_leave_isr>
 80025b8:	4804      	ldr	r0, [pc, #16]	@ (80025cc <Vector244+0x4c>)
 80025ba:	f001 fdb1 	bl	8004120 <__trace_isr_leave>
 80025be:	f004 f82f 	bl	8006620 <__port_irq_epilogue>
}
 80025c2:	bf00      	nop
 80025c4:	b003      	add	sp, #12
 80025c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80025ca:	bf00      	nop
 80025cc:	08006ac8 	.word	0x08006ac8
 80025d0:	58025400 	.word	0x58025400
 80025d4:	24000070 	.word	0x24000070
	...

080025e0 <Vector248>:
/**
 * @brief   BDMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH1_HANDLER) {
 80025e0:	b500      	push	{lr}
 80025e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80025e4:	4812      	ldr	r0, [pc, #72]	@ (8002630 <Vector248+0x50>)
 80025e6:	f001 fd5b 	bl	80040a0 <__trace_isr_enter>
 80025ea:	f001 fbc1 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 80025ee:	4b11      	ldr	r3, [pc, #68]	@ (8002634 <Vector248+0x54>)
 80025f0:	681b      	ldr	r3, [r3, #0]
 80025f2:	091b      	lsrs	r3, r3, #4
 80025f4:	f003 030e 	and.w	r3, r3, #14
 80025f8:	9301      	str	r3, [sp, #4]
  BDMA->IFCR = flags << 4U;
 80025fa:	4a0e      	ldr	r2, [pc, #56]	@ (8002634 <Vector248+0x54>)
 80025fc:	9b01      	ldr	r3, [sp, #4]
 80025fe:	011b      	lsls	r3, r3, #4
 8002600:	6053      	str	r3, [r2, #4]
  if (bdma.streams[1].func)
 8002602:	4b0d      	ldr	r3, [pc, #52]	@ (8002638 <Vector248+0x58>)
 8002604:	68db      	ldr	r3, [r3, #12]
 8002606:	2b00      	cmp	r3, #0
 8002608:	d006      	beq.n	8002618 <Vector248+0x38>
    bdma.streams[1].func(bdma.streams[1].param, flags);
 800260a:	4b0b      	ldr	r3, [pc, #44]	@ (8002638 <Vector248+0x58>)
 800260c:	68db      	ldr	r3, [r3, #12]
 800260e:	4a0a      	ldr	r2, [pc, #40]	@ (8002638 <Vector248+0x58>)
 8002610:	6912      	ldr	r2, [r2, #16]
 8002612:	9901      	ldr	r1, [sp, #4]
 8002614:	4610      	mov	r0, r2
 8002616:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002618:	f001 fbe2 	bl	8003de0 <__dbg_check_leave_isr>
 800261c:	4804      	ldr	r0, [pc, #16]	@ (8002630 <Vector248+0x50>)
 800261e:	f001 fd7f 	bl	8004120 <__trace_isr_leave>
 8002622:	f003 fffd 	bl	8006620 <__port_irq_epilogue>
}
 8002626:	bf00      	nop
 8002628:	b003      	add	sp, #12
 800262a:	f85d fb04 	ldr.w	pc, [sp], #4
 800262e:	bf00      	nop
 8002630:	08006ad4 	.word	0x08006ad4
 8002634:	58025400 	.word	0x58025400
 8002638:	24000070 	.word	0x24000070
 800263c:	00000000 	.word	0x00000000

08002640 <Vector24C>:
/**
 * @brief   BDMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH2_HANDLER) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002644:	4812      	ldr	r0, [pc, #72]	@ (8002690 <Vector24C+0x50>)
 8002646:	f001 fd2b 	bl	80040a0 <__trace_isr_enter>
 800264a:	f001 fb91 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 800264e:	4b11      	ldr	r3, [pc, #68]	@ (8002694 <Vector24C+0x54>)
 8002650:	681b      	ldr	r3, [r3, #0]
 8002652:	0a1b      	lsrs	r3, r3, #8
 8002654:	f003 030e 	and.w	r3, r3, #14
 8002658:	9301      	str	r3, [sp, #4]
  BDMA->IFCR = flags << 8U;
 800265a:	4a0e      	ldr	r2, [pc, #56]	@ (8002694 <Vector24C+0x54>)
 800265c:	9b01      	ldr	r3, [sp, #4]
 800265e:	021b      	lsls	r3, r3, #8
 8002660:	6053      	str	r3, [r2, #4]
  if (bdma.streams[2].func)
 8002662:	4b0d      	ldr	r3, [pc, #52]	@ (8002698 <Vector24C+0x58>)
 8002664:	695b      	ldr	r3, [r3, #20]
 8002666:	2b00      	cmp	r3, #0
 8002668:	d006      	beq.n	8002678 <Vector24C+0x38>
    bdma.streams[2].func(bdma.streams[2].param, flags);
 800266a:	4b0b      	ldr	r3, [pc, #44]	@ (8002698 <Vector24C+0x58>)
 800266c:	695b      	ldr	r3, [r3, #20]
 800266e:	4a0a      	ldr	r2, [pc, #40]	@ (8002698 <Vector24C+0x58>)
 8002670:	6992      	ldr	r2, [r2, #24]
 8002672:	9901      	ldr	r1, [sp, #4]
 8002674:	4610      	mov	r0, r2
 8002676:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002678:	f001 fbb2 	bl	8003de0 <__dbg_check_leave_isr>
 800267c:	4804      	ldr	r0, [pc, #16]	@ (8002690 <Vector24C+0x50>)
 800267e:	f001 fd4f 	bl	8004120 <__trace_isr_leave>
 8002682:	f003 ffcd 	bl	8006620 <__port_irq_epilogue>
}
 8002686:	bf00      	nop
 8002688:	b003      	add	sp, #12
 800268a:	f85d fb04 	ldr.w	pc, [sp], #4
 800268e:	bf00      	nop
 8002690:	08006ae0 	.word	0x08006ae0
 8002694:	58025400 	.word	0x58025400
 8002698:	24000070 	.word	0x24000070
 800269c:	00000000 	.word	0x00000000

080026a0 <Vector250>:
/**
 * @brief   BDMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH3_HANDLER) {
 80026a0:	b500      	push	{lr}
 80026a2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80026a4:	4812      	ldr	r0, [pc, #72]	@ (80026f0 <Vector250+0x50>)
 80026a6:	f001 fcfb 	bl	80040a0 <__trace_isr_enter>
 80026aa:	f001 fb61 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 80026ae:	4b11      	ldr	r3, [pc, #68]	@ (80026f4 <Vector250+0x54>)
 80026b0:	681b      	ldr	r3, [r3, #0]
 80026b2:	0b1b      	lsrs	r3, r3, #12
 80026b4:	f003 030e 	and.w	r3, r3, #14
 80026b8:	9301      	str	r3, [sp, #4]
  BDMA->IFCR = flags << 12U;
 80026ba:	4a0e      	ldr	r2, [pc, #56]	@ (80026f4 <Vector250+0x54>)
 80026bc:	9b01      	ldr	r3, [sp, #4]
 80026be:	031b      	lsls	r3, r3, #12
 80026c0:	6053      	str	r3, [r2, #4]
  if (bdma.streams[3].func)
 80026c2:	4b0d      	ldr	r3, [pc, #52]	@ (80026f8 <Vector250+0x58>)
 80026c4:	69db      	ldr	r3, [r3, #28]
 80026c6:	2b00      	cmp	r3, #0
 80026c8:	d006      	beq.n	80026d8 <Vector250+0x38>
    bdma.streams[3].func(bdma.streams[3].param, flags);
 80026ca:	4b0b      	ldr	r3, [pc, #44]	@ (80026f8 <Vector250+0x58>)
 80026cc:	69db      	ldr	r3, [r3, #28]
 80026ce:	4a0a      	ldr	r2, [pc, #40]	@ (80026f8 <Vector250+0x58>)
 80026d0:	6a12      	ldr	r2, [r2, #32]
 80026d2:	9901      	ldr	r1, [sp, #4]
 80026d4:	4610      	mov	r0, r2
 80026d6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80026d8:	f001 fb82 	bl	8003de0 <__dbg_check_leave_isr>
 80026dc:	4804      	ldr	r0, [pc, #16]	@ (80026f0 <Vector250+0x50>)
 80026de:	f001 fd1f 	bl	8004120 <__trace_isr_leave>
 80026e2:	f003 ff9d 	bl	8006620 <__port_irq_epilogue>
}
 80026e6:	bf00      	nop
 80026e8:	b003      	add	sp, #12
 80026ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80026ee:	bf00      	nop
 80026f0:	08006aec 	.word	0x08006aec
 80026f4:	58025400 	.word	0x58025400
 80026f8:	24000070 	.word	0x24000070
 80026fc:	00000000 	.word	0x00000000

08002700 <Vector254>:
/**
 * @brief   BDMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH4_HANDLER) {
 8002700:	b500      	push	{lr}
 8002702:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002704:	4812      	ldr	r0, [pc, #72]	@ (8002750 <Vector254+0x50>)
 8002706:	f001 fccb 	bl	80040a0 <__trace_isr_enter>
 800270a:	f001 fb31 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 800270e:	4b11      	ldr	r3, [pc, #68]	@ (8002754 <Vector254+0x54>)
 8002710:	681b      	ldr	r3, [r3, #0]
 8002712:	0c1b      	lsrs	r3, r3, #16
 8002714:	f003 030e 	and.w	r3, r3, #14
 8002718:	9301      	str	r3, [sp, #4]
  BDMA->IFCR = flags << 16U;
 800271a:	4a0e      	ldr	r2, [pc, #56]	@ (8002754 <Vector254+0x54>)
 800271c:	9b01      	ldr	r3, [sp, #4]
 800271e:	041b      	lsls	r3, r3, #16
 8002720:	6053      	str	r3, [r2, #4]
  if (bdma.streams[4].func)
 8002722:	4b0d      	ldr	r3, [pc, #52]	@ (8002758 <Vector254+0x58>)
 8002724:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002726:	2b00      	cmp	r3, #0
 8002728:	d006      	beq.n	8002738 <Vector254+0x38>
    bdma.streams[4].func(bdma.streams[4].param, flags);
 800272a:	4b0b      	ldr	r3, [pc, #44]	@ (8002758 <Vector254+0x58>)
 800272c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800272e:	4a0a      	ldr	r2, [pc, #40]	@ (8002758 <Vector254+0x58>)
 8002730:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8002732:	9901      	ldr	r1, [sp, #4]
 8002734:	4610      	mov	r0, r2
 8002736:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002738:	f001 fb52 	bl	8003de0 <__dbg_check_leave_isr>
 800273c:	4804      	ldr	r0, [pc, #16]	@ (8002750 <Vector254+0x50>)
 800273e:	f001 fcef 	bl	8004120 <__trace_isr_leave>
 8002742:	f003 ff6d 	bl	8006620 <__port_irq_epilogue>
}
 8002746:	bf00      	nop
 8002748:	b003      	add	sp, #12
 800274a:	f85d fb04 	ldr.w	pc, [sp], #4
 800274e:	bf00      	nop
 8002750:	08006af8 	.word	0x08006af8
 8002754:	58025400 	.word	0x58025400
 8002758:	24000070 	.word	0x24000070
 800275c:	00000000 	.word	0x00000000

08002760 <Vector258>:
/**
 * @brief   BDMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH5_HANDLER) {
 8002760:	b500      	push	{lr}
 8002762:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002764:	4812      	ldr	r0, [pc, #72]	@ (80027b0 <Vector258+0x50>)
 8002766:	f001 fc9b 	bl	80040a0 <__trace_isr_enter>
 800276a:	f001 fb01 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 800276e:	4b11      	ldr	r3, [pc, #68]	@ (80027b4 <Vector258+0x54>)
 8002770:	681b      	ldr	r3, [r3, #0]
 8002772:	0d1b      	lsrs	r3, r3, #20
 8002774:	f003 030e 	and.w	r3, r3, #14
 8002778:	9301      	str	r3, [sp, #4]
  BDMA->IFCR = flags << 20U;
 800277a:	4a0e      	ldr	r2, [pc, #56]	@ (80027b4 <Vector258+0x54>)
 800277c:	9b01      	ldr	r3, [sp, #4]
 800277e:	051b      	lsls	r3, r3, #20
 8002780:	6053      	str	r3, [r2, #4]
  if (bdma.streams[5].func)
 8002782:	4b0d      	ldr	r3, [pc, #52]	@ (80027b8 <Vector258+0x58>)
 8002784:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002786:	2b00      	cmp	r3, #0
 8002788:	d006      	beq.n	8002798 <Vector258+0x38>
    bdma.streams[5].func(bdma.streams[5].param, flags);
 800278a:	4b0b      	ldr	r3, [pc, #44]	@ (80027b8 <Vector258+0x58>)
 800278c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800278e:	4a0a      	ldr	r2, [pc, #40]	@ (80027b8 <Vector258+0x58>)
 8002790:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 8002792:	9901      	ldr	r1, [sp, #4]
 8002794:	4610      	mov	r0, r2
 8002796:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002798:	f001 fb22 	bl	8003de0 <__dbg_check_leave_isr>
 800279c:	4804      	ldr	r0, [pc, #16]	@ (80027b0 <Vector258+0x50>)
 800279e:	f001 fcbf 	bl	8004120 <__trace_isr_leave>
 80027a2:	f003 ff3d 	bl	8006620 <__port_irq_epilogue>
}
 80027a6:	bf00      	nop
 80027a8:	b003      	add	sp, #12
 80027aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80027ae:	bf00      	nop
 80027b0:	08006b04 	.word	0x08006b04
 80027b4:	58025400 	.word	0x58025400
 80027b8:	24000070 	.word	0x24000070
 80027bc:	00000000 	.word	0x00000000

080027c0 <Vector25C>:
/**
 * @brief   BDMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH6_HANDLER) {
 80027c0:	b500      	push	{lr}
 80027c2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80027c4:	4812      	ldr	r0, [pc, #72]	@ (8002810 <Vector25C+0x50>)
 80027c6:	f001 fc6b 	bl	80040a0 <__trace_isr_enter>
 80027ca:	f001 fad1 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 80027ce:	4b11      	ldr	r3, [pc, #68]	@ (8002814 <Vector25C+0x54>)
 80027d0:	681b      	ldr	r3, [r3, #0]
 80027d2:	0e1b      	lsrs	r3, r3, #24
 80027d4:	f003 030e 	and.w	r3, r3, #14
 80027d8:	9301      	str	r3, [sp, #4]
  BDMA->IFCR = flags << 24U;
 80027da:	4a0e      	ldr	r2, [pc, #56]	@ (8002814 <Vector25C+0x54>)
 80027dc:	9b01      	ldr	r3, [sp, #4]
 80027de:	061b      	lsls	r3, r3, #24
 80027e0:	6053      	str	r3, [r2, #4]
  if (bdma.streams[6].func)
 80027e2:	4b0d      	ldr	r3, [pc, #52]	@ (8002818 <Vector25C+0x58>)
 80027e4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80027e6:	2b00      	cmp	r3, #0
 80027e8:	d006      	beq.n	80027f8 <Vector25C+0x38>
    bdma.streams[6].func(bdma.streams[6].param, flags);
 80027ea:	4b0b      	ldr	r3, [pc, #44]	@ (8002818 <Vector25C+0x58>)
 80027ec:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80027ee:	4a0a      	ldr	r2, [pc, #40]	@ (8002818 <Vector25C+0x58>)
 80027f0:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 80027f2:	9901      	ldr	r1, [sp, #4]
 80027f4:	4610      	mov	r0, r2
 80027f6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80027f8:	f001 faf2 	bl	8003de0 <__dbg_check_leave_isr>
 80027fc:	4804      	ldr	r0, [pc, #16]	@ (8002810 <Vector25C+0x50>)
 80027fe:	f001 fc8f 	bl	8004120 <__trace_isr_leave>
 8002802:	f003 ff0d 	bl	8006620 <__port_irq_epilogue>
}
 8002806:	bf00      	nop
 8002808:	b003      	add	sp, #12
 800280a:	f85d fb04 	ldr.w	pc, [sp], #4
 800280e:	bf00      	nop
 8002810:	08006b10 	.word	0x08006b10
 8002814:	58025400 	.word	0x58025400
 8002818:	24000070 	.word	0x24000070
 800281c:	00000000 	.word	0x00000000

08002820 <Vector260>:
/**
 * @brief   BDMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH7_HANDLER) {
 8002820:	b500      	push	{lr}
 8002822:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002824:	4812      	ldr	r0, [pc, #72]	@ (8002870 <Vector260+0x50>)
 8002826:	f001 fc3b 	bl	80040a0 <__trace_isr_enter>
 800282a:	f001 faa1 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 800282e:	4b11      	ldr	r3, [pc, #68]	@ (8002874 <Vector260+0x54>)
 8002830:	681b      	ldr	r3, [r3, #0]
 8002832:	0f1b      	lsrs	r3, r3, #28
 8002834:	f003 030e 	and.w	r3, r3, #14
 8002838:	9301      	str	r3, [sp, #4]
  BDMA->IFCR = flags << 28U;
 800283a:	4a0e      	ldr	r2, [pc, #56]	@ (8002874 <Vector260+0x54>)
 800283c:	9b01      	ldr	r3, [sp, #4]
 800283e:	071b      	lsls	r3, r3, #28
 8002840:	6053      	str	r3, [r2, #4]
  if (bdma.streams[7].func)
 8002842:	4b0d      	ldr	r3, [pc, #52]	@ (8002878 <Vector260+0x58>)
 8002844:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002846:	2b00      	cmp	r3, #0
 8002848:	d006      	beq.n	8002858 <Vector260+0x38>
    bdma.streams[7].func(bdma.streams[7].param, flags);
 800284a:	4b0b      	ldr	r3, [pc, #44]	@ (8002878 <Vector260+0x58>)
 800284c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800284e:	4a0a      	ldr	r2, [pc, #40]	@ (8002878 <Vector260+0x58>)
 8002850:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 8002852:	9901      	ldr	r1, [sp, #4]
 8002854:	4610      	mov	r0, r2
 8002856:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002858:	f001 fac2 	bl	8003de0 <__dbg_check_leave_isr>
 800285c:	4804      	ldr	r0, [pc, #16]	@ (8002870 <Vector260+0x50>)
 800285e:	f001 fc5f 	bl	8004120 <__trace_isr_leave>
 8002862:	f003 fedd 	bl	8006620 <__port_irq_epilogue>
}
 8002866:	bf00      	nop
 8002868:	b003      	add	sp, #12
 800286a:	f85d fb04 	ldr.w	pc, [sp], #4
 800286e:	bf00      	nop
 8002870:	08006b1c 	.word	0x08006b1c
 8002874:	58025400 	.word	0x58025400
 8002878:	24000070 	.word	0x24000070
 800287c:	00000000 	.word	0x00000000

08002880 <bdmaInit>:
/**
 * @brief   STM32 BDMA helper initialization.
 *
 * @init
 */
void bdmaInit(void) {
 8002880:	b082      	sub	sp, #8
  unsigned i;

  bdma.allocated_mask = 0U;
 8002882:	4b15      	ldr	r3, [pc, #84]	@ (80028d8 <bdmaInit+0x58>)
 8002884:	2200      	movs	r2, #0
 8002886:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 8002888:	2300      	movs	r3, #0
 800288a:	9301      	str	r3, [sp, #4]
 800288c:	e019      	b.n	80028c2 <bdmaInit+0x42>
    _stm32_bdma_streams[i].channel->CCR = 0U;
 800288e:	4913      	ldr	r1, [pc, #76]	@ (80028dc <bdmaInit+0x5c>)
 8002890:	9a01      	ldr	r2, [sp, #4]
 8002892:	4613      	mov	r3, r2
 8002894:	009b      	lsls	r3, r3, #2
 8002896:	4413      	add	r3, r2
 8002898:	009b      	lsls	r3, r3, #2
 800289a:	440b      	add	r3, r1
 800289c:	3304      	adds	r3, #4
 800289e:	681b      	ldr	r3, [r3, #0]
 80028a0:	2200      	movs	r2, #0
 80028a2:	601a      	str	r2, [r3, #0]
    bdma.streams[i].func  = NULL;
 80028a4:	4a0c      	ldr	r2, [pc, #48]	@ (80028d8 <bdmaInit+0x58>)
 80028a6:	9b01      	ldr	r3, [sp, #4]
 80028a8:	00db      	lsls	r3, r3, #3
 80028aa:	4413      	add	r3, r2
 80028ac:	2200      	movs	r2, #0
 80028ae:	605a      	str	r2, [r3, #4]
    bdma.streams[i].param = NULL;
 80028b0:	4a09      	ldr	r2, [pc, #36]	@ (80028d8 <bdmaInit+0x58>)
 80028b2:	9b01      	ldr	r3, [sp, #4]
 80028b4:	00db      	lsls	r3, r3, #3
 80028b6:	4413      	add	r3, r2
 80028b8:	2200      	movs	r2, #0
 80028ba:	609a      	str	r2, [r3, #8]
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 80028bc:	9b01      	ldr	r3, [sp, #4]
 80028be:	3301      	adds	r3, #1
 80028c0:	9301      	str	r3, [sp, #4]
 80028c2:	9b01      	ldr	r3, [sp, #4]
 80028c4:	2b07      	cmp	r3, #7
 80028c6:	d9e2      	bls.n	800288e <bdmaInit+0xe>
  }
  BDMA->IFCR = 0xFFFFFFFFU;
 80028c8:	4b05      	ldr	r3, [pc, #20]	@ (80028e0 <bdmaInit+0x60>)
 80028ca:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80028ce:	605a      	str	r2, [r3, #4]
}
 80028d0:	bf00      	nop
 80028d2:	b002      	add	sp, #8
 80028d4:	4770      	bx	lr
 80028d6:	bf00      	nop
 80028d8:	24000070 	.word	0x24000070
 80028dc:	08006a28 	.word	0x08006a28
 80028e0:	58025400 	.word	0x58025400
	...

080028f0 <bdmaStreamAllocI>:
 * @iclass
 */
const stm32_bdma_stream_t *bdmaStreamAllocI(uint32_t id,
                                            uint32_t priority,
                                            stm32_bdmaisr_t func,
                                            void *param) {
 80028f0:	b500      	push	{lr}
 80028f2:	b08b      	sub	sp, #44	@ 0x2c
 80028f4:	9003      	str	r0, [sp, #12]
 80028f6:	9102      	str	r1, [sp, #8]
 80028f8:	9201      	str	r2, [sp, #4]
 80028fa:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 80028fc:	f001 fab0 	bl	8003e60 <chDbgCheckClassI>

  if (id < STM32_BDMA_STREAMS) {
 8002900:	9b03      	ldr	r3, [sp, #12]
 8002902:	2b07      	cmp	r3, #7
 8002904:	d804      	bhi.n	8002910 <bdmaStreamAllocI+0x20>
    startid = id;
 8002906:	9b03      	ldr	r3, [sp, #12]
 8002908:	9308      	str	r3, [sp, #32]
    endid   = id;
 800290a:	9b03      	ldr	r3, [sp, #12]
 800290c:	9307      	str	r3, [sp, #28]
 800290e:	e00c      	b.n	800292a <bdmaStreamAllocI+0x3a>
  }
  else if (id == STM32_BDMA_STREAM_ID_ANY) {
 8002910:	9b03      	ldr	r3, [sp, #12]
 8002912:	2b08      	cmp	r3, #8
 8002914:	d104      	bne.n	8002920 <bdmaStreamAllocI+0x30>
    startid = 0U;
 8002916:	2300      	movs	r3, #0
 8002918:	9308      	str	r3, [sp, #32]
    endid   = STM32_BDMA_STREAMS - 1U;
 800291a:	2307      	movs	r3, #7
 800291c:	9307      	str	r3, [sp, #28]
 800291e:	e004      	b.n	800292a <bdmaStreamAllocI+0x3a>
  }
  else {
    osalDbgCheck(false);
 8002920:	4830      	ldr	r0, [pc, #192]	@ (80029e4 <bdmaStreamAllocI+0xf4>)
 8002922:	f001 f8fd 	bl	8003b20 <chSysHalt>
    return NULL;
 8002926:	2300      	movs	r3, #0
 8002928:	e057      	b.n	80029da <bdmaStreamAllocI+0xea>
  }

  for (i = startid; i <= endid; i++) {
 800292a:	9b08      	ldr	r3, [sp, #32]
 800292c:	9309      	str	r3, [sp, #36]	@ 0x24
 800292e:	e04f      	b.n	80029d0 <bdmaStreamAllocI+0xe0>
    uint32_t mask = (1U << i);
 8002930:	2201      	movs	r2, #1
 8002932:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002934:	fa02 f303 	lsl.w	r3, r2, r3
 8002938:	9306      	str	r3, [sp, #24]
    if ((bdma.allocated_mask & mask) == 0U) {
 800293a:	4b2b      	ldr	r3, [pc, #172]	@ (80029e8 <bdmaStreamAllocI+0xf8>)
 800293c:	681a      	ldr	r2, [r3, #0]
 800293e:	9b06      	ldr	r3, [sp, #24]
 8002940:	4013      	ands	r3, r2
 8002942:	2b00      	cmp	r3, #0
 8002944:	d141      	bne.n	80029ca <bdmaStreamAllocI+0xda>
      const stm32_bdma_stream_t *stp = STM32_BDMA_STREAM(i);
 8002946:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8002948:	4613      	mov	r3, r2
 800294a:	009b      	lsls	r3, r3, #2
 800294c:	4413      	add	r3, r2
 800294e:	009b      	lsls	r3, r3, #2
 8002950:	4a26      	ldr	r2, [pc, #152]	@ (80029ec <bdmaStreamAllocI+0xfc>)
 8002952:	4413      	add	r3, r2
 8002954:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      bdma.streams[i].func  = func;
 8002956:	4a24      	ldr	r2, [pc, #144]	@ (80029e8 <bdmaStreamAllocI+0xf8>)
 8002958:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800295a:	00db      	lsls	r3, r3, #3
 800295c:	4413      	add	r3, r2
 800295e:	9a01      	ldr	r2, [sp, #4]
 8002960:	605a      	str	r2, [r3, #4]
      bdma.streams[i].param = param;
 8002962:	4a21      	ldr	r2, [pc, #132]	@ (80029e8 <bdmaStreamAllocI+0xf8>)
 8002964:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002966:	00db      	lsls	r3, r3, #3
 8002968:	4413      	add	r3, r2
 800296a:	9a00      	ldr	r2, [sp, #0]
 800296c:	609a      	str	r2, [r3, #8]
      bdma.allocated_mask  |= mask;
 800296e:	4b1e      	ldr	r3, [pc, #120]	@ (80029e8 <bdmaStreamAllocI+0xf8>)
 8002970:	681a      	ldr	r2, [r3, #0]
 8002972:	9b06      	ldr	r3, [sp, #24]
 8002974:	4313      	orrs	r3, r2
 8002976:	4a1c      	ldr	r2, [pc, #112]	@ (80029e8 <bdmaStreamAllocI+0xf8>)
 8002978:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_BDMA_STREAMS_MASK & mask) != 0U) {
 800297a:	9b06      	ldr	r3, [sp, #24]
 800297c:	b2db      	uxtb	r3, r3
 800297e:	2b00      	cmp	r3, #0
 8002980:	d004      	beq.n	800298c <bdmaStreamAllocI+0x9c>
        rccEnableBDMA1(true);
 8002982:	2101      	movs	r1, #1
 8002984:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 8002988:	f7ff fdca 	bl	8002520 <rccEnableAHB4.lto_priv.2>
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 800298c:	9b01      	ldr	r3, [sp, #4]
 800298e:	2b00      	cmp	r3, #0
 8002990:	d005      	beq.n	800299e <bdmaStreamAllocI+0xae>
        nvicEnableVector(stp->vector, priority);
 8002992:	9b05      	ldr	r3, [sp, #20]
 8002994:	7c5b      	ldrb	r3, [r3, #17]
 8002996:	9902      	ldr	r1, [sp, #8]
 8002998:	4618      	mov	r0, r3
 800299a:	f7fe fa29 	bl	8000df0 <nvicEnableVector>
      }

      /* Putting the stream in a known state.*/
      bdmaStreamDisable(stp);
 800299e:	9b05      	ldr	r3, [sp, #20]
 80029a0:	685b      	ldr	r3, [r3, #4]
 80029a2:	681a      	ldr	r2, [r3, #0]
 80029a4:	9b05      	ldr	r3, [sp, #20]
 80029a6:	685b      	ldr	r3, [r3, #4]
 80029a8:	f022 020f 	bic.w	r2, r2, #15
 80029ac:	601a      	str	r2, [r3, #0]
 80029ae:	9b05      	ldr	r3, [sp, #20]
 80029b0:	7a1b      	ldrb	r3, [r3, #8]
 80029b2:	4619      	mov	r1, r3
 80029b4:	9b05      	ldr	r3, [sp, #20]
 80029b6:	681b      	ldr	r3, [r3, #0]
 80029b8:	220e      	movs	r2, #14
 80029ba:	408a      	lsls	r2, r1
 80029bc:	605a      	str	r2, [r3, #4]
      stp->channel->CCR = STM32_BDMA_CR_RESET_VALUE;
 80029be:	9b05      	ldr	r3, [sp, #20]
 80029c0:	685b      	ldr	r3, [r3, #4]
 80029c2:	2200      	movs	r2, #0
 80029c4:	601a      	str	r2, [r3, #0]

      return stp;
 80029c6:	9b05      	ldr	r3, [sp, #20]
 80029c8:	e007      	b.n	80029da <bdmaStreamAllocI+0xea>
  for (i = startid; i <= endid; i++) {
 80029ca:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80029cc:	3301      	adds	r3, #1
 80029ce:	9309      	str	r3, [sp, #36]	@ 0x24
 80029d0:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80029d2:	9b07      	ldr	r3, [sp, #28]
 80029d4:	429a      	cmp	r2, r3
 80029d6:	d9ab      	bls.n	8002930 <bdmaStreamAllocI+0x40>
    }
  }

  return NULL;
 80029d8:	2300      	movs	r3, #0
}
 80029da:	4618      	mov	r0, r3
 80029dc:	b00b      	add	sp, #44	@ 0x2c
 80029de:	f85d fb04 	ldr.w	pc, [sp], #4
 80029e2:	bf00      	nop
 80029e4:	08006b28 	.word	0x08006b28
 80029e8:	24000070 	.word	0x24000070
 80029ec:	08006a28 	.word	0x08006a28

080029f0 <bdmaSetRequestSource>:
 * @param[in] stp       pointer to a @p stm32_bdma_stream_t structure
 * @param[in] per       peripheral identifier
 *
 * @special
 */
void bdmaSetRequestSource(const stm32_bdma_stream_t *stp, uint32_t per) {
 80029f0:	b500      	push	{lr}
 80029f2:	b083      	sub	sp, #12
 80029f4:	9001      	str	r0, [sp, #4]
 80029f6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(per < 256U);
 80029f8:	9b00      	ldr	r3, [sp, #0]
 80029fa:	2bff      	cmp	r3, #255	@ 0xff
 80029fc:	bf8c      	ite	hi
 80029fe:	2301      	movhi	r3, #1
 8002a00:	2300      	movls	r3, #0
 8002a02:	b2db      	uxtb	r3, r3
 8002a04:	2b00      	cmp	r3, #0
 8002a06:	d002      	beq.n	8002a0e <bdmaSetRequestSource+0x1e>
 8002a08:	4805      	ldr	r0, [pc, #20]	@ (8002a20 <bdmaSetRequestSource+0x30>)
 8002a0a:	f001 f889 	bl	8003b20 <chSysHalt>

  stp->mux->CCR = per;
 8002a0e:	9b01      	ldr	r3, [sp, #4]
 8002a10:	68db      	ldr	r3, [r3, #12]
 8002a12:	9a00      	ldr	r2, [sp, #0]
 8002a14:	601a      	str	r2, [r3, #0]
}
 8002a16:	bf00      	nop
 8002a18:	b003      	add	sp, #12
 8002a1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a1e:	bf00      	nop
 8002a20:	08006b3c 	.word	0x08006b3c
	...

08002a30 <rccEnableAHB1.lto_priv.1>:
__STATIC_INLINE void rccEnableAHB1(uint32_t mask, bool lp) {
 8002a30:	b082      	sub	sp, #8
 8002a32:	9001      	str	r0, [sp, #4]
 8002a34:	460b      	mov	r3, r1
 8002a36:	f88d 3003 	strb.w	r3, [sp, #3]
  RCC_C1->AHB1ENR |= mask;
 8002a3a:	4b12      	ldr	r3, [pc, #72]	@ (8002a84 <rccEnableAHB1.lto_priv.1+0x54>)
 8002a3c:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 8002a40:	4910      	ldr	r1, [pc, #64]	@ (8002a84 <rccEnableAHB1.lto_priv.1+0x54>)
 8002a42:	9b01      	ldr	r3, [sp, #4]
 8002a44:	4313      	orrs	r3, r2
 8002a46:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
  if (lp) {
 8002a4a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002a4e:	2b00      	cmp	r3, #0
 8002a50:	d008      	beq.n	8002a64 <rccEnableAHB1.lto_priv.1+0x34>
    RCC_C1->AHB1LPENR |= mask;
 8002a52:	4b0c      	ldr	r3, [pc, #48]	@ (8002a84 <rccEnableAHB1.lto_priv.1+0x54>)
 8002a54:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
 8002a58:	490a      	ldr	r1, [pc, #40]	@ (8002a84 <rccEnableAHB1.lto_priv.1+0x54>)
 8002a5a:	9b01      	ldr	r3, [sp, #4]
 8002a5c:	4313      	orrs	r3, r2
 8002a5e:	f8c1 3100 	str.w	r3, [r1, #256]	@ 0x100
 8002a62:	e008      	b.n	8002a76 <rccEnableAHB1.lto_priv.1+0x46>
    RCC_C1->AHB1LPENR &= ~mask;
 8002a64:	4b07      	ldr	r3, [pc, #28]	@ (8002a84 <rccEnableAHB1.lto_priv.1+0x54>)
 8002a66:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
 8002a6a:	9b01      	ldr	r3, [sp, #4]
 8002a6c:	43db      	mvns	r3, r3
 8002a6e:	4905      	ldr	r1, [pc, #20]	@ (8002a84 <rccEnableAHB1.lto_priv.1+0x54>)
 8002a70:	4013      	ands	r3, r2
 8002a72:	f8c1 3100 	str.w	r3, [r1, #256]	@ 0x100
  (void)RCC_C1->AHB1LPENR;
 8002a76:	4b03      	ldr	r3, [pc, #12]	@ (8002a84 <rccEnableAHB1.lto_priv.1+0x54>)
 8002a78:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
}
 8002a7c:	bf00      	nop
 8002a7e:	b002      	add	sp, #8
 8002a80:	4770      	bx	lr
 8002a82:	bf00      	nop
 8002a84:	58024400 	.word	0x58024400
	...

08002a90 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8002a90:	b500      	push	{lr}
 8002a92:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002a94:	4811      	ldr	r0, [pc, #68]	@ (8002adc <Vector6C+0x4c>)
 8002a96:	f001 fb03 	bl	80040a0 <__trace_isr_enter>
 8002a9a:	f001 f969 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002a9e:	4b10      	ldr	r3, [pc, #64]	@ (8002ae0 <Vector6C+0x50>)
 8002aa0:	681b      	ldr	r3, [r3, #0]
 8002aa2:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002aa6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 8002aa8:	4a0d      	ldr	r2, [pc, #52]	@ (8002ae0 <Vector6C+0x50>)
 8002aaa:	9b01      	ldr	r3, [sp, #4]
 8002aac:	6093      	str	r3, [r2, #8]
  if (dma.streams[0].func)
 8002aae:	4b0d      	ldr	r3, [pc, #52]	@ (8002ae4 <Vector6C+0x54>)
 8002ab0:	685b      	ldr	r3, [r3, #4]
 8002ab2:	2b00      	cmp	r3, #0
 8002ab4:	d006      	beq.n	8002ac4 <Vector6C+0x34>
    dma.streams[0].func(dma.streams[0].param, flags);
 8002ab6:	4b0b      	ldr	r3, [pc, #44]	@ (8002ae4 <Vector6C+0x54>)
 8002ab8:	685b      	ldr	r3, [r3, #4]
 8002aba:	4a0a      	ldr	r2, [pc, #40]	@ (8002ae4 <Vector6C+0x54>)
 8002abc:	6892      	ldr	r2, [r2, #8]
 8002abe:	9901      	ldr	r1, [sp, #4]
 8002ac0:	4610      	mov	r0, r2
 8002ac2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002ac4:	f001 f98c 	bl	8003de0 <__dbg_check_leave_isr>
 8002ac8:	4804      	ldr	r0, [pc, #16]	@ (8002adc <Vector6C+0x4c>)
 8002aca:	f001 fb29 	bl	8004120 <__trace_isr_leave>
 8002ace:	f003 fda7 	bl	8006620 <__port_irq_epilogue>
}
 8002ad2:	bf00      	nop
 8002ad4:	b003      	add	sp, #12
 8002ad6:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ada:	bf00      	nop
 8002adc:	08006c54 	.word	0x08006c54
 8002ae0:	40020000 	.word	0x40020000
 8002ae4:	240000b4 	.word	0x240000b4
	...

08002af0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002af0:	b500      	push	{lr}
 8002af2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002af4:	4812      	ldr	r0, [pc, #72]	@ (8002b40 <Vector70+0x50>)
 8002af6:	f001 fad3 	bl	80040a0 <__trace_isr_enter>
 8002afa:	f001 f939 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002afe:	4b11      	ldr	r3, [pc, #68]	@ (8002b44 <Vector70+0x54>)
 8002b00:	681b      	ldr	r3, [r3, #0]
 8002b02:	099b      	lsrs	r3, r3, #6
 8002b04:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002b08:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 8002b0a:	4a0e      	ldr	r2, [pc, #56]	@ (8002b44 <Vector70+0x54>)
 8002b0c:	9b01      	ldr	r3, [sp, #4]
 8002b0e:	019b      	lsls	r3, r3, #6
 8002b10:	6093      	str	r3, [r2, #8]
  if (dma.streams[1].func)
 8002b12:	4b0d      	ldr	r3, [pc, #52]	@ (8002b48 <Vector70+0x58>)
 8002b14:	68db      	ldr	r3, [r3, #12]
 8002b16:	2b00      	cmp	r3, #0
 8002b18:	d006      	beq.n	8002b28 <Vector70+0x38>
    dma.streams[1].func(dma.streams[1].param, flags);
 8002b1a:	4b0b      	ldr	r3, [pc, #44]	@ (8002b48 <Vector70+0x58>)
 8002b1c:	68db      	ldr	r3, [r3, #12]
 8002b1e:	4a0a      	ldr	r2, [pc, #40]	@ (8002b48 <Vector70+0x58>)
 8002b20:	6912      	ldr	r2, [r2, #16]
 8002b22:	9901      	ldr	r1, [sp, #4]
 8002b24:	4610      	mov	r0, r2
 8002b26:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002b28:	f001 f95a 	bl	8003de0 <__dbg_check_leave_isr>
 8002b2c:	4804      	ldr	r0, [pc, #16]	@ (8002b40 <Vector70+0x50>)
 8002b2e:	f001 faf7 	bl	8004120 <__trace_isr_leave>
 8002b32:	f003 fd75 	bl	8006620 <__port_irq_epilogue>
}
 8002b36:	bf00      	nop
 8002b38:	b003      	add	sp, #12
 8002b3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b3e:	bf00      	nop
 8002b40:	08006c60 	.word	0x08006c60
 8002b44:	40020000 	.word	0x40020000
 8002b48:	240000b4 	.word	0x240000b4
 8002b4c:	00000000 	.word	0x00000000

08002b50 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8002b50:	b500      	push	{lr}
 8002b52:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002b54:	4812      	ldr	r0, [pc, #72]	@ (8002ba0 <Vector74+0x50>)
 8002b56:	f001 faa3 	bl	80040a0 <__trace_isr_enter>
 8002b5a:	f001 f909 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002b5e:	4b11      	ldr	r3, [pc, #68]	@ (8002ba4 <Vector74+0x54>)
 8002b60:	681b      	ldr	r3, [r3, #0]
 8002b62:	0c1b      	lsrs	r3, r3, #16
 8002b64:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002b68:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 8002b6a:	4a0e      	ldr	r2, [pc, #56]	@ (8002ba4 <Vector74+0x54>)
 8002b6c:	9b01      	ldr	r3, [sp, #4]
 8002b6e:	041b      	lsls	r3, r3, #16
 8002b70:	6093      	str	r3, [r2, #8]
  if (dma.streams[2].func)
 8002b72:	4b0d      	ldr	r3, [pc, #52]	@ (8002ba8 <Vector74+0x58>)
 8002b74:	695b      	ldr	r3, [r3, #20]
 8002b76:	2b00      	cmp	r3, #0
 8002b78:	d006      	beq.n	8002b88 <Vector74+0x38>
    dma.streams[2].func(dma.streams[2].param, flags);
 8002b7a:	4b0b      	ldr	r3, [pc, #44]	@ (8002ba8 <Vector74+0x58>)
 8002b7c:	695b      	ldr	r3, [r3, #20]
 8002b7e:	4a0a      	ldr	r2, [pc, #40]	@ (8002ba8 <Vector74+0x58>)
 8002b80:	6992      	ldr	r2, [r2, #24]
 8002b82:	9901      	ldr	r1, [sp, #4]
 8002b84:	4610      	mov	r0, r2
 8002b86:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002b88:	f001 f92a 	bl	8003de0 <__dbg_check_leave_isr>
 8002b8c:	4804      	ldr	r0, [pc, #16]	@ (8002ba0 <Vector74+0x50>)
 8002b8e:	f001 fac7 	bl	8004120 <__trace_isr_leave>
 8002b92:	f003 fd45 	bl	8006620 <__port_irq_epilogue>
}
 8002b96:	bf00      	nop
 8002b98:	b003      	add	sp, #12
 8002b9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b9e:	bf00      	nop
 8002ba0:	08006c6c 	.word	0x08006c6c
 8002ba4:	40020000 	.word	0x40020000
 8002ba8:	240000b4 	.word	0x240000b4
 8002bac:	00000000 	.word	0x00000000

08002bb0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8002bb0:	b500      	push	{lr}
 8002bb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002bb4:	4812      	ldr	r0, [pc, #72]	@ (8002c00 <Vector78+0x50>)
 8002bb6:	f001 fa73 	bl	80040a0 <__trace_isr_enter>
 8002bba:	f001 f8d9 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002bbe:	4b11      	ldr	r3, [pc, #68]	@ (8002c04 <Vector78+0x54>)
 8002bc0:	681b      	ldr	r3, [r3, #0]
 8002bc2:	0d9b      	lsrs	r3, r3, #22
 8002bc4:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002bc8:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 8002bca:	4a0e      	ldr	r2, [pc, #56]	@ (8002c04 <Vector78+0x54>)
 8002bcc:	9b01      	ldr	r3, [sp, #4]
 8002bce:	059b      	lsls	r3, r3, #22
 8002bd0:	6093      	str	r3, [r2, #8]
  if (dma.streams[3].func)
 8002bd2:	4b0d      	ldr	r3, [pc, #52]	@ (8002c08 <Vector78+0x58>)
 8002bd4:	69db      	ldr	r3, [r3, #28]
 8002bd6:	2b00      	cmp	r3, #0
 8002bd8:	d006      	beq.n	8002be8 <Vector78+0x38>
    dma.streams[3].func(dma.streams[3].param, flags);
 8002bda:	4b0b      	ldr	r3, [pc, #44]	@ (8002c08 <Vector78+0x58>)
 8002bdc:	69db      	ldr	r3, [r3, #28]
 8002bde:	4a0a      	ldr	r2, [pc, #40]	@ (8002c08 <Vector78+0x58>)
 8002be0:	6a12      	ldr	r2, [r2, #32]
 8002be2:	9901      	ldr	r1, [sp, #4]
 8002be4:	4610      	mov	r0, r2
 8002be6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002be8:	f001 f8fa 	bl	8003de0 <__dbg_check_leave_isr>
 8002bec:	4804      	ldr	r0, [pc, #16]	@ (8002c00 <Vector78+0x50>)
 8002bee:	f001 fa97 	bl	8004120 <__trace_isr_leave>
 8002bf2:	f003 fd15 	bl	8006620 <__port_irq_epilogue>
}
 8002bf6:	bf00      	nop
 8002bf8:	b003      	add	sp, #12
 8002bfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8002bfe:	bf00      	nop
 8002c00:	08006c78 	.word	0x08006c78
 8002c04:	40020000 	.word	0x40020000
 8002c08:	240000b4 	.word	0x240000b4
 8002c0c:	00000000 	.word	0x00000000

08002c10 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002c10:	b500      	push	{lr}
 8002c12:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c14:	4811      	ldr	r0, [pc, #68]	@ (8002c5c <Vector7C+0x4c>)
 8002c16:	f001 fa43 	bl	80040a0 <__trace_isr_enter>
 8002c1a:	f001 f8a9 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002c1e:	4b10      	ldr	r3, [pc, #64]	@ (8002c60 <Vector7C+0x50>)
 8002c20:	685b      	ldr	r3, [r3, #4]
 8002c22:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002c26:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 8002c28:	4a0d      	ldr	r2, [pc, #52]	@ (8002c60 <Vector7C+0x50>)
 8002c2a:	9b01      	ldr	r3, [sp, #4]
 8002c2c:	60d3      	str	r3, [r2, #12]
  if (dma.streams[4].func)
 8002c2e:	4b0d      	ldr	r3, [pc, #52]	@ (8002c64 <Vector7C+0x54>)
 8002c30:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002c32:	2b00      	cmp	r3, #0
 8002c34:	d006      	beq.n	8002c44 <Vector7C+0x34>
    dma.streams[4].func(dma.streams[4].param, flags);
 8002c36:	4b0b      	ldr	r3, [pc, #44]	@ (8002c64 <Vector7C+0x54>)
 8002c38:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002c3a:	4a0a      	ldr	r2, [pc, #40]	@ (8002c64 <Vector7C+0x54>)
 8002c3c:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8002c3e:	9901      	ldr	r1, [sp, #4]
 8002c40:	4610      	mov	r0, r2
 8002c42:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002c44:	f001 f8cc 	bl	8003de0 <__dbg_check_leave_isr>
 8002c48:	4804      	ldr	r0, [pc, #16]	@ (8002c5c <Vector7C+0x4c>)
 8002c4a:	f001 fa69 	bl	8004120 <__trace_isr_leave>
 8002c4e:	f003 fce7 	bl	8006620 <__port_irq_epilogue>
}
 8002c52:	bf00      	nop
 8002c54:	b003      	add	sp, #12
 8002c56:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c5a:	bf00      	nop
 8002c5c:	08006c84 	.word	0x08006c84
 8002c60:	40020000 	.word	0x40020000
 8002c64:	240000b4 	.word	0x240000b4
	...

08002c70 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8002c70:	b500      	push	{lr}
 8002c72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c74:	4812      	ldr	r0, [pc, #72]	@ (8002cc0 <Vector80+0x50>)
 8002c76:	f001 fa13 	bl	80040a0 <__trace_isr_enter>
 8002c7a:	f001 f879 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002c7e:	4b11      	ldr	r3, [pc, #68]	@ (8002cc4 <Vector80+0x54>)
 8002c80:	685b      	ldr	r3, [r3, #4]
 8002c82:	099b      	lsrs	r3, r3, #6
 8002c84:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002c88:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 8002c8a:	4a0e      	ldr	r2, [pc, #56]	@ (8002cc4 <Vector80+0x54>)
 8002c8c:	9b01      	ldr	r3, [sp, #4]
 8002c8e:	019b      	lsls	r3, r3, #6
 8002c90:	60d3      	str	r3, [r2, #12]
  if (dma.streams[5].func)
 8002c92:	4b0d      	ldr	r3, [pc, #52]	@ (8002cc8 <Vector80+0x58>)
 8002c94:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002c96:	2b00      	cmp	r3, #0
 8002c98:	d006      	beq.n	8002ca8 <Vector80+0x38>
    dma.streams[5].func(dma.streams[5].param, flags);
 8002c9a:	4b0b      	ldr	r3, [pc, #44]	@ (8002cc8 <Vector80+0x58>)
 8002c9c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002c9e:	4a0a      	ldr	r2, [pc, #40]	@ (8002cc8 <Vector80+0x58>)
 8002ca0:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 8002ca2:	9901      	ldr	r1, [sp, #4]
 8002ca4:	4610      	mov	r0, r2
 8002ca6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002ca8:	f001 f89a 	bl	8003de0 <__dbg_check_leave_isr>
 8002cac:	4804      	ldr	r0, [pc, #16]	@ (8002cc0 <Vector80+0x50>)
 8002cae:	f001 fa37 	bl	8004120 <__trace_isr_leave>
 8002cb2:	f003 fcb5 	bl	8006620 <__port_irq_epilogue>
}
 8002cb6:	bf00      	nop
 8002cb8:	b003      	add	sp, #12
 8002cba:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cbe:	bf00      	nop
 8002cc0:	08006c90 	.word	0x08006c90
 8002cc4:	40020000 	.word	0x40020000
 8002cc8:	240000b4 	.word	0x240000b4
 8002ccc:	00000000 	.word	0x00000000

08002cd0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8002cd0:	b500      	push	{lr}
 8002cd2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002cd4:	4812      	ldr	r0, [pc, #72]	@ (8002d20 <Vector84+0x50>)
 8002cd6:	f001 f9e3 	bl	80040a0 <__trace_isr_enter>
 8002cda:	f001 f849 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002cde:	4b11      	ldr	r3, [pc, #68]	@ (8002d24 <Vector84+0x54>)
 8002ce0:	685b      	ldr	r3, [r3, #4]
 8002ce2:	0c1b      	lsrs	r3, r3, #16
 8002ce4:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002ce8:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 8002cea:	4a0e      	ldr	r2, [pc, #56]	@ (8002d24 <Vector84+0x54>)
 8002cec:	9b01      	ldr	r3, [sp, #4]
 8002cee:	041b      	lsls	r3, r3, #16
 8002cf0:	60d3      	str	r3, [r2, #12]
  if (dma.streams[6].func)
 8002cf2:	4b0d      	ldr	r3, [pc, #52]	@ (8002d28 <Vector84+0x58>)
 8002cf4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8002cf6:	2b00      	cmp	r3, #0
 8002cf8:	d006      	beq.n	8002d08 <Vector84+0x38>
    dma.streams[6].func(dma.streams[6].param, flags);
 8002cfa:	4b0b      	ldr	r3, [pc, #44]	@ (8002d28 <Vector84+0x58>)
 8002cfc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8002cfe:	4a0a      	ldr	r2, [pc, #40]	@ (8002d28 <Vector84+0x58>)
 8002d00:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 8002d02:	9901      	ldr	r1, [sp, #4]
 8002d04:	4610      	mov	r0, r2
 8002d06:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002d08:	f001 f86a 	bl	8003de0 <__dbg_check_leave_isr>
 8002d0c:	4804      	ldr	r0, [pc, #16]	@ (8002d20 <Vector84+0x50>)
 8002d0e:	f001 fa07 	bl	8004120 <__trace_isr_leave>
 8002d12:	f003 fc85 	bl	8006620 <__port_irq_epilogue>
}
 8002d16:	bf00      	nop
 8002d18:	b003      	add	sp, #12
 8002d1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d1e:	bf00      	nop
 8002d20:	08006c9c 	.word	0x08006c9c
 8002d24:	40020000 	.word	0x40020000
 8002d28:	240000b4 	.word	0x240000b4
 8002d2c:	00000000 	.word	0x00000000

08002d30 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002d30:	b500      	push	{lr}
 8002d32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d34:	4812      	ldr	r0, [pc, #72]	@ (8002d80 <VectorFC+0x50>)
 8002d36:	f001 f9b3 	bl	80040a0 <__trace_isr_enter>
 8002d3a:	f001 f819 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002d3e:	4b11      	ldr	r3, [pc, #68]	@ (8002d84 <VectorFC+0x54>)
 8002d40:	685b      	ldr	r3, [r3, #4]
 8002d42:	0d9b      	lsrs	r3, r3, #22
 8002d44:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002d48:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 8002d4a:	4a0e      	ldr	r2, [pc, #56]	@ (8002d84 <VectorFC+0x54>)
 8002d4c:	9b01      	ldr	r3, [sp, #4]
 8002d4e:	059b      	lsls	r3, r3, #22
 8002d50:	60d3      	str	r3, [r2, #12]
  if (dma.streams[7].func)
 8002d52:	4b0d      	ldr	r3, [pc, #52]	@ (8002d88 <VectorFC+0x58>)
 8002d54:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002d56:	2b00      	cmp	r3, #0
 8002d58:	d006      	beq.n	8002d68 <VectorFC+0x38>
    dma.streams[7].func(dma.streams[7].param, flags);
 8002d5a:	4b0b      	ldr	r3, [pc, #44]	@ (8002d88 <VectorFC+0x58>)
 8002d5c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002d5e:	4a0a      	ldr	r2, [pc, #40]	@ (8002d88 <VectorFC+0x58>)
 8002d60:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 8002d62:	9901      	ldr	r1, [sp, #4]
 8002d64:	4610      	mov	r0, r2
 8002d66:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002d68:	f001 f83a 	bl	8003de0 <__dbg_check_leave_isr>
 8002d6c:	4804      	ldr	r0, [pc, #16]	@ (8002d80 <VectorFC+0x50>)
 8002d6e:	f001 f9d7 	bl	8004120 <__trace_isr_leave>
 8002d72:	f003 fc55 	bl	8006620 <__port_irq_epilogue>
}
 8002d76:	bf00      	nop
 8002d78:	b003      	add	sp, #12
 8002d7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d7e:	bf00      	nop
 8002d80:	08006ca8 	.word	0x08006ca8
 8002d84:	40020000 	.word	0x40020000
 8002d88:	240000b4 	.word	0x240000b4
 8002d8c:	00000000 	.word	0x00000000

08002d90 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8002d90:	b500      	push	{lr}
 8002d92:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d94:	4811      	ldr	r0, [pc, #68]	@ (8002ddc <Vector120+0x4c>)
 8002d96:	f001 f983 	bl	80040a0 <__trace_isr_enter>
 8002d9a:	f000 ffe9 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002d9e:	4b10      	ldr	r3, [pc, #64]	@ (8002de0 <Vector120+0x50>)
 8002da0:	681b      	ldr	r3, [r3, #0]
 8002da2:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002da6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 8002da8:	4a0d      	ldr	r2, [pc, #52]	@ (8002de0 <Vector120+0x50>)
 8002daa:	9b01      	ldr	r3, [sp, #4]
 8002dac:	6093      	str	r3, [r2, #8]
  if (dma.streams[8].func)
 8002dae:	4b0d      	ldr	r3, [pc, #52]	@ (8002de4 <Vector120+0x54>)
 8002db0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002db2:	2b00      	cmp	r3, #0
 8002db4:	d006      	beq.n	8002dc4 <Vector120+0x34>
    dma.streams[8].func(dma.streams[8].param, flags);
 8002db6:	4b0b      	ldr	r3, [pc, #44]	@ (8002de4 <Vector120+0x54>)
 8002db8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002dba:	4a0a      	ldr	r2, [pc, #40]	@ (8002de4 <Vector120+0x54>)
 8002dbc:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 8002dbe:	9901      	ldr	r1, [sp, #4]
 8002dc0:	4610      	mov	r0, r2
 8002dc2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002dc4:	f001 f80c 	bl	8003de0 <__dbg_check_leave_isr>
 8002dc8:	4804      	ldr	r0, [pc, #16]	@ (8002ddc <Vector120+0x4c>)
 8002dca:	f001 f9a9 	bl	8004120 <__trace_isr_leave>
 8002dce:	f003 fc27 	bl	8006620 <__port_irq_epilogue>
}
 8002dd2:	bf00      	nop
 8002dd4:	b003      	add	sp, #12
 8002dd6:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dda:	bf00      	nop
 8002ddc:	08006cb4 	.word	0x08006cb4
 8002de0:	40020400 	.word	0x40020400
 8002de4:	240000b4 	.word	0x240000b4
	...

08002df0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8002df0:	b500      	push	{lr}
 8002df2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002df4:	4812      	ldr	r0, [pc, #72]	@ (8002e40 <Vector124+0x50>)
 8002df6:	f001 f953 	bl	80040a0 <__trace_isr_enter>
 8002dfa:	f000 ffb9 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002dfe:	4b11      	ldr	r3, [pc, #68]	@ (8002e44 <Vector124+0x54>)
 8002e00:	681b      	ldr	r3, [r3, #0]
 8002e02:	099b      	lsrs	r3, r3, #6
 8002e04:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002e08:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 8002e0a:	4a0e      	ldr	r2, [pc, #56]	@ (8002e44 <Vector124+0x54>)
 8002e0c:	9b01      	ldr	r3, [sp, #4]
 8002e0e:	019b      	lsls	r3, r3, #6
 8002e10:	6093      	str	r3, [r2, #8]
  if (dma.streams[9].func)
 8002e12:	4b0d      	ldr	r3, [pc, #52]	@ (8002e48 <Vector124+0x58>)
 8002e14:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002e16:	2b00      	cmp	r3, #0
 8002e18:	d006      	beq.n	8002e28 <Vector124+0x38>
    dma.streams[9].func(dma.streams[9].param, flags);
 8002e1a:	4b0b      	ldr	r3, [pc, #44]	@ (8002e48 <Vector124+0x58>)
 8002e1c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002e1e:	4a0a      	ldr	r2, [pc, #40]	@ (8002e48 <Vector124+0x58>)
 8002e20:	6d12      	ldr	r2, [r2, #80]	@ 0x50
 8002e22:	9901      	ldr	r1, [sp, #4]
 8002e24:	4610      	mov	r0, r2
 8002e26:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002e28:	f000 ffda 	bl	8003de0 <__dbg_check_leave_isr>
 8002e2c:	4804      	ldr	r0, [pc, #16]	@ (8002e40 <Vector124+0x50>)
 8002e2e:	f001 f977 	bl	8004120 <__trace_isr_leave>
 8002e32:	f003 fbf5 	bl	8006620 <__port_irq_epilogue>
}
 8002e36:	bf00      	nop
 8002e38:	b003      	add	sp, #12
 8002e3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e3e:	bf00      	nop
 8002e40:	08006cc0 	.word	0x08006cc0
 8002e44:	40020400 	.word	0x40020400
 8002e48:	240000b4 	.word	0x240000b4
 8002e4c:	00000000 	.word	0x00000000

08002e50 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8002e50:	b500      	push	{lr}
 8002e52:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002e54:	4812      	ldr	r0, [pc, #72]	@ (8002ea0 <Vector128+0x50>)
 8002e56:	f001 f923 	bl	80040a0 <__trace_isr_enter>
 8002e5a:	f000 ff89 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002e5e:	4b11      	ldr	r3, [pc, #68]	@ (8002ea4 <Vector128+0x54>)
 8002e60:	681b      	ldr	r3, [r3, #0]
 8002e62:	0c1b      	lsrs	r3, r3, #16
 8002e64:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002e68:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 8002e6a:	4a0e      	ldr	r2, [pc, #56]	@ (8002ea4 <Vector128+0x54>)
 8002e6c:	9b01      	ldr	r3, [sp, #4]
 8002e6e:	041b      	lsls	r3, r3, #16
 8002e70:	6093      	str	r3, [r2, #8]
  if (dma.streams[10].func)
 8002e72:	4b0d      	ldr	r3, [pc, #52]	@ (8002ea8 <Vector128+0x58>)
 8002e74:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002e76:	2b00      	cmp	r3, #0
 8002e78:	d006      	beq.n	8002e88 <Vector128+0x38>
    dma.streams[10].func(dma.streams[10].param, flags);
 8002e7a:	4b0b      	ldr	r3, [pc, #44]	@ (8002ea8 <Vector128+0x58>)
 8002e7c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002e7e:	4a0a      	ldr	r2, [pc, #40]	@ (8002ea8 <Vector128+0x58>)
 8002e80:	6d92      	ldr	r2, [r2, #88]	@ 0x58
 8002e82:	9901      	ldr	r1, [sp, #4]
 8002e84:	4610      	mov	r0, r2
 8002e86:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002e88:	f000 ffaa 	bl	8003de0 <__dbg_check_leave_isr>
 8002e8c:	4804      	ldr	r0, [pc, #16]	@ (8002ea0 <Vector128+0x50>)
 8002e8e:	f001 f947 	bl	8004120 <__trace_isr_leave>
 8002e92:	f003 fbc5 	bl	8006620 <__port_irq_epilogue>
}
 8002e96:	bf00      	nop
 8002e98:	b003      	add	sp, #12
 8002e9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e9e:	bf00      	nop
 8002ea0:	08006ccc 	.word	0x08006ccc
 8002ea4:	40020400 	.word	0x40020400
 8002ea8:	240000b4 	.word	0x240000b4
 8002eac:	00000000 	.word	0x00000000

08002eb0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8002eb0:	b500      	push	{lr}
 8002eb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002eb4:	4812      	ldr	r0, [pc, #72]	@ (8002f00 <Vector12C+0x50>)
 8002eb6:	f001 f8f3 	bl	80040a0 <__trace_isr_enter>
 8002eba:	f000 ff59 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002ebe:	4b11      	ldr	r3, [pc, #68]	@ (8002f04 <Vector12C+0x54>)
 8002ec0:	681b      	ldr	r3, [r3, #0]
 8002ec2:	0d9b      	lsrs	r3, r3, #22
 8002ec4:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002ec8:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 8002eca:	4a0e      	ldr	r2, [pc, #56]	@ (8002f04 <Vector12C+0x54>)
 8002ecc:	9b01      	ldr	r3, [sp, #4]
 8002ece:	059b      	lsls	r3, r3, #22
 8002ed0:	6093      	str	r3, [r2, #8]
  if (dma.streams[11].func)
 8002ed2:	4b0d      	ldr	r3, [pc, #52]	@ (8002f08 <Vector12C+0x58>)
 8002ed4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002ed6:	2b00      	cmp	r3, #0
 8002ed8:	d006      	beq.n	8002ee8 <Vector12C+0x38>
    dma.streams[11].func(dma.streams[11].param, flags);
 8002eda:	4b0b      	ldr	r3, [pc, #44]	@ (8002f08 <Vector12C+0x58>)
 8002edc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002ede:	4a0a      	ldr	r2, [pc, #40]	@ (8002f08 <Vector12C+0x58>)
 8002ee0:	6e12      	ldr	r2, [r2, #96]	@ 0x60
 8002ee2:	9901      	ldr	r1, [sp, #4]
 8002ee4:	4610      	mov	r0, r2
 8002ee6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002ee8:	f000 ff7a 	bl	8003de0 <__dbg_check_leave_isr>
 8002eec:	4804      	ldr	r0, [pc, #16]	@ (8002f00 <Vector12C+0x50>)
 8002eee:	f001 f917 	bl	8004120 <__trace_isr_leave>
 8002ef2:	f003 fb95 	bl	8006620 <__port_irq_epilogue>
}
 8002ef6:	bf00      	nop
 8002ef8:	b003      	add	sp, #12
 8002efa:	f85d fb04 	ldr.w	pc, [sp], #4
 8002efe:	bf00      	nop
 8002f00:	08006cd8 	.word	0x08006cd8
 8002f04:	40020400 	.word	0x40020400
 8002f08:	240000b4 	.word	0x240000b4
 8002f0c:	00000000 	.word	0x00000000

08002f10 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8002f10:	b500      	push	{lr}
 8002f12:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002f14:	4811      	ldr	r0, [pc, #68]	@ (8002f5c <Vector130+0x4c>)
 8002f16:	f001 f8c3 	bl	80040a0 <__trace_isr_enter>
 8002f1a:	f000 ff29 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002f1e:	4b10      	ldr	r3, [pc, #64]	@ (8002f60 <Vector130+0x50>)
 8002f20:	685b      	ldr	r3, [r3, #4]
 8002f22:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002f26:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 8002f28:	4a0d      	ldr	r2, [pc, #52]	@ (8002f60 <Vector130+0x50>)
 8002f2a:	9b01      	ldr	r3, [sp, #4]
 8002f2c:	60d3      	str	r3, [r2, #12]
  if (dma.streams[12].func)
 8002f2e:	4b0d      	ldr	r3, [pc, #52]	@ (8002f64 <Vector130+0x54>)
 8002f30:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8002f32:	2b00      	cmp	r3, #0
 8002f34:	d006      	beq.n	8002f44 <Vector130+0x34>
    dma.streams[12].func(dma.streams[12].param, flags);
 8002f36:	4b0b      	ldr	r3, [pc, #44]	@ (8002f64 <Vector130+0x54>)
 8002f38:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8002f3a:	4a0a      	ldr	r2, [pc, #40]	@ (8002f64 <Vector130+0x54>)
 8002f3c:	6e92      	ldr	r2, [r2, #104]	@ 0x68
 8002f3e:	9901      	ldr	r1, [sp, #4]
 8002f40:	4610      	mov	r0, r2
 8002f42:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002f44:	f000 ff4c 	bl	8003de0 <__dbg_check_leave_isr>
 8002f48:	4804      	ldr	r0, [pc, #16]	@ (8002f5c <Vector130+0x4c>)
 8002f4a:	f001 f8e9 	bl	8004120 <__trace_isr_leave>
 8002f4e:	f003 fb67 	bl	8006620 <__port_irq_epilogue>
}
 8002f52:	bf00      	nop
 8002f54:	b003      	add	sp, #12
 8002f56:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f5a:	bf00      	nop
 8002f5c:	08006ce4 	.word	0x08006ce4
 8002f60:	40020400 	.word	0x40020400
 8002f64:	240000b4 	.word	0x240000b4
	...

08002f70 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8002f70:	b500      	push	{lr}
 8002f72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002f74:	4812      	ldr	r0, [pc, #72]	@ (8002fc0 <Vector150+0x50>)
 8002f76:	f001 f893 	bl	80040a0 <__trace_isr_enter>
 8002f7a:	f000 fef9 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002f7e:	4b11      	ldr	r3, [pc, #68]	@ (8002fc4 <Vector150+0x54>)
 8002f80:	685b      	ldr	r3, [r3, #4]
 8002f82:	099b      	lsrs	r3, r3, #6
 8002f84:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002f88:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 8002f8a:	4a0e      	ldr	r2, [pc, #56]	@ (8002fc4 <Vector150+0x54>)
 8002f8c:	9b01      	ldr	r3, [sp, #4]
 8002f8e:	019b      	lsls	r3, r3, #6
 8002f90:	60d3      	str	r3, [r2, #12]
  if (dma.streams[13].func)
 8002f92:	4b0d      	ldr	r3, [pc, #52]	@ (8002fc8 <Vector150+0x58>)
 8002f94:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8002f96:	2b00      	cmp	r3, #0
 8002f98:	d006      	beq.n	8002fa8 <Vector150+0x38>
    dma.streams[13].func(dma.streams[13].param, flags);
 8002f9a:	4b0b      	ldr	r3, [pc, #44]	@ (8002fc8 <Vector150+0x58>)
 8002f9c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8002f9e:	4a0a      	ldr	r2, [pc, #40]	@ (8002fc8 <Vector150+0x58>)
 8002fa0:	6f12      	ldr	r2, [r2, #112]	@ 0x70
 8002fa2:	9901      	ldr	r1, [sp, #4]
 8002fa4:	4610      	mov	r0, r2
 8002fa6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8002fa8:	f000 ff1a 	bl	8003de0 <__dbg_check_leave_isr>
 8002fac:	4804      	ldr	r0, [pc, #16]	@ (8002fc0 <Vector150+0x50>)
 8002fae:	f001 f8b7 	bl	8004120 <__trace_isr_leave>
 8002fb2:	f003 fb35 	bl	8006620 <__port_irq_epilogue>
}
 8002fb6:	bf00      	nop
 8002fb8:	b003      	add	sp, #12
 8002fba:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fbe:	bf00      	nop
 8002fc0:	08006cf0 	.word	0x08006cf0
 8002fc4:	40020400 	.word	0x40020400
 8002fc8:	240000b4 	.word	0x240000b4
 8002fcc:	00000000 	.word	0x00000000

08002fd0 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8002fd0:	b500      	push	{lr}
 8002fd2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002fd4:	4812      	ldr	r0, [pc, #72]	@ (8003020 <Vector154+0x50>)
 8002fd6:	f001 f863 	bl	80040a0 <__trace_isr_enter>
 8002fda:	f000 fec9 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002fde:	4b11      	ldr	r3, [pc, #68]	@ (8003024 <Vector154+0x54>)
 8002fe0:	685b      	ldr	r3, [r3, #4]
 8002fe2:	0c1b      	lsrs	r3, r3, #16
 8002fe4:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8002fe8:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 8002fea:	4a0e      	ldr	r2, [pc, #56]	@ (8003024 <Vector154+0x54>)
 8002fec:	9b01      	ldr	r3, [sp, #4]
 8002fee:	041b      	lsls	r3, r3, #16
 8002ff0:	60d3      	str	r3, [r2, #12]
  if (dma.streams[14].func)
 8002ff2:	4b0d      	ldr	r3, [pc, #52]	@ (8003028 <Vector154+0x58>)
 8002ff4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8002ff6:	2b00      	cmp	r3, #0
 8002ff8:	d006      	beq.n	8003008 <Vector154+0x38>
    dma.streams[14].func(dma.streams[14].param, flags);
 8002ffa:	4b0b      	ldr	r3, [pc, #44]	@ (8003028 <Vector154+0x58>)
 8002ffc:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8002ffe:	4a0a      	ldr	r2, [pc, #40]	@ (8003028 <Vector154+0x58>)
 8003000:	6f92      	ldr	r2, [r2, #120]	@ 0x78
 8003002:	9901      	ldr	r1, [sp, #4]
 8003004:	4610      	mov	r0, r2
 8003006:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003008:	f000 feea 	bl	8003de0 <__dbg_check_leave_isr>
 800300c:	4804      	ldr	r0, [pc, #16]	@ (8003020 <Vector154+0x50>)
 800300e:	f001 f887 	bl	8004120 <__trace_isr_leave>
 8003012:	f003 fb05 	bl	8006620 <__port_irq_epilogue>
}
 8003016:	bf00      	nop
 8003018:	b003      	add	sp, #12
 800301a:	f85d fb04 	ldr.w	pc, [sp], #4
 800301e:	bf00      	nop
 8003020:	08006cfc 	.word	0x08006cfc
 8003024:	40020400 	.word	0x40020400
 8003028:	240000b4 	.word	0x240000b4
 800302c:	00000000 	.word	0x00000000

08003030 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8003030:	b500      	push	{lr}
 8003032:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003034:	4812      	ldr	r0, [pc, #72]	@ (8003080 <Vector158+0x50>)
 8003036:	f001 f833 	bl	80040a0 <__trace_isr_enter>
 800303a:	f000 fe99 	bl	8003d70 <__dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800303e:	4b11      	ldr	r3, [pc, #68]	@ (8003084 <Vector158+0x54>)
 8003040:	685b      	ldr	r3, [r3, #4]
 8003042:	0d9b      	lsrs	r3, r3, #22
 8003044:	f003 033d 	and.w	r3, r3, #61	@ 0x3d
 8003048:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 800304a:	4a0e      	ldr	r2, [pc, #56]	@ (8003084 <Vector158+0x54>)
 800304c:	9b01      	ldr	r3, [sp, #4]
 800304e:	059b      	lsls	r3, r3, #22
 8003050:	60d3      	str	r3, [r2, #12]
  if (dma.streams[15].func)
 8003052:	4b0d      	ldr	r3, [pc, #52]	@ (8003088 <Vector158+0x58>)
 8003054:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8003056:	2b00      	cmp	r3, #0
 8003058:	d007      	beq.n	800306a <Vector158+0x3a>
    dma.streams[15].func(dma.streams[15].param, flags);
 800305a:	4b0b      	ldr	r3, [pc, #44]	@ (8003088 <Vector158+0x58>)
 800305c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800305e:	4a0a      	ldr	r2, [pc, #40]	@ (8003088 <Vector158+0x58>)
 8003060:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
 8003064:	9901      	ldr	r1, [sp, #4]
 8003066:	4610      	mov	r0, r2
 8003068:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800306a:	f000 feb9 	bl	8003de0 <__dbg_check_leave_isr>
 800306e:	4804      	ldr	r0, [pc, #16]	@ (8003080 <Vector158+0x50>)
 8003070:	f001 f856 	bl	8004120 <__trace_isr_leave>
 8003074:	f003 fad4 	bl	8006620 <__port_irq_epilogue>
}
 8003078:	bf00      	nop
 800307a:	b003      	add	sp, #12
 800307c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003080:	08006d08 	.word	0x08006d08
 8003084:	40020400 	.word	0x40020400
 8003088:	240000b4 	.word	0x240000b4
 800308c:	00000000 	.word	0x00000000

08003090 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8003090:	b082      	sub	sp, #8
  unsigned i;

  dma.allocated_mask = 0U;
 8003092:	4b16      	ldr	r3, [pc, #88]	@ (80030ec <dmaInit+0x5c>)
 8003094:	2200      	movs	r2, #0
 8003096:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8003098:	2300      	movs	r3, #0
 800309a:	9301      	str	r3, [sp, #4]
 800309c:	e00f      	b.n	80030be <dmaInit+0x2e>
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 800309e:	4a14      	ldr	r2, [pc, #80]	@ (80030f0 <dmaInit+0x60>)
 80030a0:	9b01      	ldr	r3, [sp, #4]
 80030a2:	011b      	lsls	r3, r3, #4
 80030a4:	4413      	add	r3, r2
 80030a6:	681b      	ldr	r3, [r3, #0]
 80030a8:	2200      	movs	r2, #0
 80030aa:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 80030ac:	4a0f      	ldr	r2, [pc, #60]	@ (80030ec <dmaInit+0x5c>)
 80030ae:	9b01      	ldr	r3, [sp, #4]
 80030b0:	00db      	lsls	r3, r3, #3
 80030b2:	4413      	add	r3, r2
 80030b4:	2200      	movs	r2, #0
 80030b6:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80030b8:	9b01      	ldr	r3, [sp, #4]
 80030ba:	3301      	adds	r3, #1
 80030bc:	9301      	str	r3, [sp, #4]
 80030be:	9b01      	ldr	r3, [sp, #4]
 80030c0:	2b0f      	cmp	r3, #15
 80030c2:	d9ec      	bls.n	800309e <dmaInit+0xe>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80030c4:	4b0b      	ldr	r3, [pc, #44]	@ (80030f4 <dmaInit+0x64>)
 80030c6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80030ca:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 80030cc:	4b09      	ldr	r3, [pc, #36]	@ (80030f4 <dmaInit+0x64>)
 80030ce:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80030d2:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 80030d4:	4b08      	ldr	r3, [pc, #32]	@ (80030f8 <dmaInit+0x68>)
 80030d6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80030da:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 80030dc:	4b06      	ldr	r3, [pc, #24]	@ (80030f8 <dmaInit+0x68>)
 80030de:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80030e2:	60da      	str	r2, [r3, #12]
}
 80030e4:	bf00      	nop
 80030e6:	b002      	add	sp, #8
 80030e8:	4770      	bx	lr
 80030ea:	bf00      	nop
 80030ec:	240000b4 	.word	0x240000b4
 80030f0:	08006b54 	.word	0x08006b54
 80030f4:	40020000 	.word	0x40020000
 80030f8:	40020400 	.word	0x40020400
 80030fc:	00000000 	.word	0x00000000

08003100 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8003100:	b500      	push	{lr}
 8003102:	b08b      	sub	sp, #44	@ 0x2c
 8003104:	9003      	str	r0, [sp, #12]
 8003106:	9102      	str	r1, [sp, #8]
 8003108:	9201      	str	r2, [sp, #4]
 800310a:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 800310c:	f000 fea8 	bl	8003e60 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 8003110:	9b03      	ldr	r3, [sp, #12]
 8003112:	2b0f      	cmp	r3, #15
 8003114:	d804      	bhi.n	8003120 <dmaStreamAllocI+0x20>
    startid = id;
 8003116:	9b03      	ldr	r3, [sp, #12]
 8003118:	9308      	str	r3, [sp, #32]
    endid   = id;
 800311a:	9b03      	ldr	r3, [sp, #12]
 800311c:	9307      	str	r3, [sp, #28]
 800311e:	e01c      	b.n	800315a <dmaStreamAllocI+0x5a>
  }
#if STM32_DMA_SUPPORTS_DMAMUX == TRUE
  else if (id == STM32_DMA_STREAM_ID_ANY) {
 8003120:	9b03      	ldr	r3, [sp, #12]
 8003122:	2b10      	cmp	r3, #16
 8003124:	d104      	bne.n	8003130 <dmaStreamAllocI+0x30>
    startid = 0U;
 8003126:	2300      	movs	r3, #0
 8003128:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 800312a:	230f      	movs	r3, #15
 800312c:	9307      	str	r3, [sp, #28]
 800312e:	e014      	b.n	800315a <dmaStreamAllocI+0x5a>
  }
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA1) {
 8003130:	9b03      	ldr	r3, [sp, #12]
 8003132:	2b11      	cmp	r3, #17
 8003134:	d104      	bne.n	8003140 <dmaStreamAllocI+0x40>
    startid = 0U;
 8003136:	2300      	movs	r3, #0
 8003138:	9308      	str	r3, [sp, #32]
    endid   = (STM32_DMA_STREAMS / 2U) - 1U;
 800313a:	2307      	movs	r3, #7
 800313c:	9307      	str	r3, [sp, #28]
 800313e:	e00c      	b.n	800315a <dmaStreamAllocI+0x5a>
  }
  else if (id == STM32_DMA_STREAM_ID_ANY_DMA2) {
 8003140:	9b03      	ldr	r3, [sp, #12]
 8003142:	2b12      	cmp	r3, #18
 8003144:	d104      	bne.n	8003150 <dmaStreamAllocI+0x50>
    startid = (STM32_DMA_STREAMS / 2U) - 1U;
 8003146:	2307      	movs	r3, #7
 8003148:	9308      	str	r3, [sp, #32]
    endid   = STM32_DMA_STREAMS - 1U;
 800314a:	230f      	movs	r3, #15
 800314c:	9307      	str	r3, [sp, #28]
 800314e:	e004      	b.n	800315a <dmaStreamAllocI+0x5a>
  }
#endif
  else {
    osalDbgCheck(false);
 8003150:	4838      	ldr	r0, [pc, #224]	@ (8003234 <dmaStreamAllocI+0x134>)
 8003152:	f000 fce5 	bl	8003b20 <chSysHalt>
    return NULL;
 8003156:	2300      	movs	r3, #0
 8003158:	e067      	b.n	800322a <dmaStreamAllocI+0x12a>
  }

  for (i = startid; i <= endid; i++) {
 800315a:	9b08      	ldr	r3, [sp, #32]
 800315c:	9309      	str	r3, [sp, #36]	@ 0x24
 800315e:	e05f      	b.n	8003220 <dmaStreamAllocI+0x120>
    uint32_t mask = (1U << i);
 8003160:	2201      	movs	r2, #1
 8003162:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003164:	fa02 f303 	lsl.w	r3, r2, r3
 8003168:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 800316a:	4b33      	ldr	r3, [pc, #204]	@ (8003238 <dmaStreamAllocI+0x138>)
 800316c:	681a      	ldr	r2, [r3, #0]
 800316e:	9b06      	ldr	r3, [sp, #24]
 8003170:	4013      	ands	r3, r2
 8003172:	2b00      	cmp	r3, #0
 8003174:	d151      	bne.n	800321a <dmaStreamAllocI+0x11a>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8003176:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003178:	011b      	lsls	r3, r3, #4
 800317a:	4a30      	ldr	r2, [pc, #192]	@ (800323c <dmaStreamAllocI+0x13c>)
 800317c:	4413      	add	r3, r2
 800317e:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8003180:	4a2d      	ldr	r2, [pc, #180]	@ (8003238 <dmaStreamAllocI+0x138>)
 8003182:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003184:	00db      	lsls	r3, r3, #3
 8003186:	4413      	add	r3, r2
 8003188:	9a01      	ldr	r2, [sp, #4]
 800318a:	605a      	str	r2, [r3, #4]
      dma.streams[i].param = param;
 800318c:	4a2a      	ldr	r2, [pc, #168]	@ (8003238 <dmaStreamAllocI+0x138>)
 800318e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003190:	00db      	lsls	r3, r3, #3
 8003192:	4413      	add	r3, r2
 8003194:	9a00      	ldr	r2, [sp, #0]
 8003196:	609a      	str	r2, [r3, #8]
      dma.allocated_mask  |= mask;
 8003198:	4b27      	ldr	r3, [pc, #156]	@ (8003238 <dmaStreamAllocI+0x138>)
 800319a:	681a      	ldr	r2, [r3, #0]
 800319c:	9b06      	ldr	r3, [sp, #24]
 800319e:	4313      	orrs	r3, r2
 80031a0:	4a25      	ldr	r2, [pc, #148]	@ (8003238 <dmaStreamAllocI+0x138>)
 80031a2:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 80031a4:	9b06      	ldr	r3, [sp, #24]
 80031a6:	b2db      	uxtb	r3, r3
 80031a8:	2b00      	cmp	r3, #0
 80031aa:	d003      	beq.n	80031b4 <dmaStreamAllocI+0xb4>
        rccEnableDMA1(true);
 80031ac:	2101      	movs	r1, #1
 80031ae:	2001      	movs	r0, #1
 80031b0:	f7ff fc3e 	bl	8002a30 <rccEnableAHB1.lto_priv.1>
      }
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 80031b4:	9b06      	ldr	r3, [sp, #24]
 80031b6:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
 80031ba:	2b00      	cmp	r3, #0
 80031bc:	d003      	beq.n	80031c6 <dmaStreamAllocI+0xc6>
        rccEnableDMA2(true);
 80031be:	2101      	movs	r1, #1
 80031c0:	2002      	movs	r0, #2
 80031c2:	f7ff fc35 	bl	8002a30 <rccEnableAHB1.lto_priv.1>
        rccEnableDMAMUX(true);
      }
#endif

      /* Putting the stream in a safe state.*/
      dmaStreamDisable(dmastp);
 80031c6:	9b05      	ldr	r3, [sp, #20]
 80031c8:	681b      	ldr	r3, [r3, #0]
 80031ca:	681a      	ldr	r2, [r3, #0]
 80031cc:	9b05      	ldr	r3, [sp, #20]
 80031ce:	681b      	ldr	r3, [r3, #0]
 80031d0:	f022 021f 	bic.w	r2, r2, #31
 80031d4:	601a      	str	r2, [r3, #0]
 80031d6:	9b05      	ldr	r3, [sp, #20]
 80031d8:	681b      	ldr	r3, [r3, #0]
 80031da:	681b      	ldr	r3, [r3, #0]
 80031dc:	f003 0301 	and.w	r3, r3, #1
 80031e0:	2b00      	cmp	r3, #0
 80031e2:	d1f8      	bne.n	80031d6 <dmaStreamAllocI+0xd6>
 80031e4:	9b05      	ldr	r3, [sp, #20]
 80031e6:	7b1b      	ldrb	r3, [r3, #12]
 80031e8:	4619      	mov	r1, r3
 80031ea:	9b05      	ldr	r3, [sp, #20]
 80031ec:	685b      	ldr	r3, [r3, #4]
 80031ee:	223d      	movs	r2, #61	@ 0x3d
 80031f0:	408a      	lsls	r2, r1
 80031f2:	601a      	str	r2, [r3, #0]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 80031f4:	9b05      	ldr	r3, [sp, #20]
 80031f6:	681b      	ldr	r3, [r3, #0]
 80031f8:	2200      	movs	r2, #0
 80031fa:	601a      	str	r2, [r3, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 80031fc:	9b05      	ldr	r3, [sp, #20]
 80031fe:	681b      	ldr	r3, [r3, #0]
 8003200:	2221      	movs	r2, #33	@ 0x21
 8003202:	615a      	str	r2, [r3, #20]

      /* Enables the associated IRQ vector if a callback is defined.*/
      if (func != NULL) {
 8003204:	9b01      	ldr	r3, [sp, #4]
 8003206:	2b00      	cmp	r3, #0
 8003208:	d005      	beq.n	8003216 <dmaStreamAllocI+0x116>
        nvicEnableVector(dmastp->vector, priority);
 800320a:	9b05      	ldr	r3, [sp, #20]
 800320c:	7b9b      	ldrb	r3, [r3, #14]
 800320e:	9902      	ldr	r1, [sp, #8]
 8003210:	4618      	mov	r0, r3
 8003212:	f7fd fded 	bl	8000df0 <nvicEnableVector>
      }

      return dmastp;
 8003216:	9b05      	ldr	r3, [sp, #20]
 8003218:	e007      	b.n	800322a <dmaStreamAllocI+0x12a>
  for (i = startid; i <= endid; i++) {
 800321a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800321c:	3301      	adds	r3, #1
 800321e:	9309      	str	r3, [sp, #36]	@ 0x24
 8003220:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8003222:	9b07      	ldr	r3, [sp, #28]
 8003224:	429a      	cmp	r2, r3
 8003226:	d99b      	bls.n	8003160 <dmaStreamAllocI+0x60>
    }
  }

  return NULL;
 8003228:	2300      	movs	r3, #0
}
 800322a:	4618      	mov	r0, r3
 800322c:	b00b      	add	sp, #44	@ 0x2c
 800322e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003232:	bf00      	nop
 8003234:	08006d14 	.word	0x08006d14
 8003238:	240000b4 	.word	0x240000b4
 800323c:	08006b54 	.word	0x08006b54

08003240 <dmaSetRequestSource>:
 * @param[in] dmastp    pointer to a @p stm32_dma_stream_t structure
 * @param[in] per       peripheral identifier
 *
 * @special
 */
void dmaSetRequestSource(const stm32_dma_stream_t *dmastp, uint32_t per) {
 8003240:	b500      	push	{lr}
 8003242:	b083      	sub	sp, #12
 8003244:	9001      	str	r0, [sp, #4]
 8003246:	9100      	str	r1, [sp, #0]

  osalDbgCheck(per < 256U);
 8003248:	9b00      	ldr	r3, [sp, #0]
 800324a:	2bff      	cmp	r3, #255	@ 0xff
 800324c:	bf8c      	ite	hi
 800324e:	2301      	movhi	r3, #1
 8003250:	2300      	movls	r3, #0
 8003252:	b2db      	uxtb	r3, r3
 8003254:	2b00      	cmp	r3, #0
 8003256:	d002      	beq.n	800325e <dmaSetRequestSource+0x1e>
 8003258:	4805      	ldr	r0, [pc, #20]	@ (8003270 <dmaSetRequestSource+0x30>)
 800325a:	f000 fc61 	bl	8003b20 <chSysHalt>

  dmastp->mux->CCR = per;
 800325e:	9b01      	ldr	r3, [sp, #4]
 8003260:	689b      	ldr	r3, [r3, #8]
 8003262:	9a00      	ldr	r2, [sp, #0]
 8003264:	601a      	str	r2, [r3, #0]
}
 8003266:	bf00      	nop
 8003268:	b003      	add	sp, #12
 800326a:	f85d fb04 	ldr.w	pc, [sp], #4
 800326e:	bf00      	nop
 8003270:	08006d24 	.word	0x08006d24
	...

08003280 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8003280:	bf00      	nop
 8003282:	4770      	bx	lr
	...

08003290 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8003290:	b08e      	sub	sp, #56	@ 0x38
 8003292:	9003      	str	r0, [sp, #12]
 8003294:	9102      	str	r1, [sp, #8]
 8003296:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8003298:	9b01      	ldr	r3, [sp, #4]
 800329a:	f003 0303 	and.w	r3, r3, #3
 800329e:	930d      	str	r3, [sp, #52]	@ 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80032a0:	9b01      	ldr	r3, [sp, #4]
 80032a2:	089b      	lsrs	r3, r3, #2
 80032a4:	f003 0301 	and.w	r3, r3, #1
 80032a8:	930c      	str	r3, [sp, #48]	@ 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80032aa:	9b01      	ldr	r3, [sp, #4]
 80032ac:	08db      	lsrs	r3, r3, #3
 80032ae:	f003 0303 	and.w	r3, r3, #3
 80032b2:	930b      	str	r3, [sp, #44]	@ 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80032b4:	9b01      	ldr	r3, [sp, #4]
 80032b6:	095b      	lsrs	r3, r3, #5
 80032b8:	f003 0303 	and.w	r3, r3, #3
 80032bc:	930a      	str	r3, [sp, #40]	@ 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80032be:	9b01      	ldr	r3, [sp, #4]
 80032c0:	09db      	lsrs	r3, r3, #7
 80032c2:	f003 030f 	and.w	r3, r3, #15
 80032c6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 80032c8:	2300      	movs	r3, #0
 80032ca:	9309      	str	r3, [sp, #36]	@ 0x24
  while (true) {
    if ((mask & 1) != 0) {
 80032cc:	9b02      	ldr	r3, [sp, #8]
 80032ce:	f003 0301 	and.w	r3, r3, #1
 80032d2:	2b00      	cmp	r3, #0
 80032d4:	d079      	beq.n	80033ca <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80032d6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80032d8:	f003 0307 	and.w	r3, r3, #7
 80032dc:	009b      	lsls	r3, r3, #2
 80032de:	9a08      	ldr	r2, [sp, #32]
 80032e0:	fa02 f303 	lsl.w	r3, r2, r3
 80032e4:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 80032e6:	2201      	movs	r2, #1
 80032e8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80032ea:	fa02 f303 	lsl.w	r3, r2, r3
 80032ee:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 80032f0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80032f2:	005b      	lsls	r3, r3, #1
 80032f4:	2203      	movs	r2, #3
 80032f6:	fa02 f303 	lsl.w	r3, r2, r3
 80032fa:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 80032fc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80032fe:	f003 0307 	and.w	r3, r3, #7
 8003302:	009b      	lsls	r3, r3, #2
 8003304:	220f      	movs	r2, #15
 8003306:	fa02 f303 	lsl.w	r3, r2, r3
 800330a:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800330c:	9b03      	ldr	r3, [sp, #12]
 800330e:	685a      	ldr	r2, [r3, #4]
 8003310:	9b06      	ldr	r3, [sp, #24]
 8003312:	43db      	mvns	r3, r3
 8003314:	401a      	ands	r2, r3
 8003316:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8003318:	431a      	orrs	r2, r3
 800331a:	9b03      	ldr	r3, [sp, #12]
 800331c:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800331e:	9b03      	ldr	r3, [sp, #12]
 8003320:	689a      	ldr	r2, [r3, #8]
 8003322:	9b05      	ldr	r3, [sp, #20]
 8003324:	43db      	mvns	r3, r3
 8003326:	401a      	ands	r2, r3
 8003328:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800332a:	431a      	orrs	r2, r3
 800332c:	9b03      	ldr	r3, [sp, #12]
 800332e:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8003330:	9b03      	ldr	r3, [sp, #12]
 8003332:	68da      	ldr	r2, [r3, #12]
 8003334:	9b05      	ldr	r3, [sp, #20]
 8003336:	43db      	mvns	r3, r3
 8003338:	401a      	ands	r2, r3
 800333a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800333c:	431a      	orrs	r2, r3
 800333e:	9b03      	ldr	r3, [sp, #12]
 8003340:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8003342:	9b01      	ldr	r3, [sp, #4]
 8003344:	f003 0303 	and.w	r3, r3, #3
 8003348:	2b02      	cmp	r3, #2
 800334a:	d11f      	bne.n	800338c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800334c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800334e:	2b07      	cmp	r3, #7
 8003350:	d809      	bhi.n	8003366 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8003352:	9b03      	ldr	r3, [sp, #12]
 8003354:	6a1a      	ldr	r2, [r3, #32]
 8003356:	9b04      	ldr	r3, [sp, #16]
 8003358:	43db      	mvns	r3, r3
 800335a:	401a      	ands	r2, r3
 800335c:	9b07      	ldr	r3, [sp, #28]
 800335e:	431a      	orrs	r2, r3
 8003360:	9b03      	ldr	r3, [sp, #12]
 8003362:	621a      	str	r2, [r3, #32]
 8003364:	e008      	b.n	8003378 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003366:	9b03      	ldr	r3, [sp, #12]
 8003368:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800336a:	9b04      	ldr	r3, [sp, #16]
 800336c:	43db      	mvns	r3, r3
 800336e:	401a      	ands	r2, r3
 8003370:	9b07      	ldr	r3, [sp, #28]
 8003372:	431a      	orrs	r2, r3
 8003374:	9b03      	ldr	r3, [sp, #12]
 8003376:	625a      	str	r2, [r3, #36]	@ 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8003378:	9b03      	ldr	r3, [sp, #12]
 800337a:	681a      	ldr	r2, [r3, #0]
 800337c:	9b05      	ldr	r3, [sp, #20]
 800337e:	43db      	mvns	r3, r3
 8003380:	401a      	ands	r2, r3
 8003382:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8003384:	431a      	orrs	r2, r3
 8003386:	9b03      	ldr	r3, [sp, #12]
 8003388:	601a      	str	r2, [r3, #0]
 800338a:	e01e      	b.n	80033ca <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800338c:	9b03      	ldr	r3, [sp, #12]
 800338e:	681a      	ldr	r2, [r3, #0]
 8003390:	9b05      	ldr	r3, [sp, #20]
 8003392:	43db      	mvns	r3, r3
 8003394:	401a      	ands	r2, r3
 8003396:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8003398:	431a      	orrs	r2, r3
 800339a:	9b03      	ldr	r3, [sp, #12]
 800339c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 800339e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80033a0:	2b07      	cmp	r3, #7
 80033a2:	d809      	bhi.n	80033b8 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80033a4:	9b03      	ldr	r3, [sp, #12]
 80033a6:	6a1a      	ldr	r2, [r3, #32]
 80033a8:	9b04      	ldr	r3, [sp, #16]
 80033aa:	43db      	mvns	r3, r3
 80033ac:	401a      	ands	r2, r3
 80033ae:	9b07      	ldr	r3, [sp, #28]
 80033b0:	431a      	orrs	r2, r3
 80033b2:	9b03      	ldr	r3, [sp, #12]
 80033b4:	621a      	str	r2, [r3, #32]
 80033b6:	e008      	b.n	80033ca <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80033b8:	9b03      	ldr	r3, [sp, #12]
 80033ba:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80033bc:	9b04      	ldr	r3, [sp, #16]
 80033be:	43db      	mvns	r3, r3
 80033c0:	401a      	ands	r2, r3
 80033c2:	9b07      	ldr	r3, [sp, #28]
 80033c4:	431a      	orrs	r2, r3
 80033c6:	9b03      	ldr	r3, [sp, #12]
 80033c8:	625a      	str	r2, [r3, #36]	@ 0x24
      }
    }
    mask >>= 1;
 80033ca:	9b02      	ldr	r3, [sp, #8]
 80033cc:	085b      	lsrs	r3, r3, #1
 80033ce:	9302      	str	r3, [sp, #8]
    if (!mask)
 80033d0:	9b02      	ldr	r3, [sp, #8]
 80033d2:	2b00      	cmp	r3, #0
 80033d4:	d00f      	beq.n	80033f6 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 80033d6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 80033d8:	005b      	lsls	r3, r3, #1
 80033da:	930c      	str	r3, [sp, #48]	@ 0x30
    ospeedr <<= 2;
 80033dc:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80033de:	009b      	lsls	r3, r3, #2
 80033e0:	930b      	str	r3, [sp, #44]	@ 0x2c
    pupdr <<= 2;
 80033e2:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80033e4:	009b      	lsls	r3, r3, #2
 80033e6:	930a      	str	r3, [sp, #40]	@ 0x28
    moder <<= 2;
 80033e8:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 80033ea:	009b      	lsls	r3, r3, #2
 80033ec:	930d      	str	r3, [sp, #52]	@ 0x34
    bit++;
 80033ee:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80033f0:	3301      	adds	r3, #1
 80033f2:	9309      	str	r3, [sp, #36]	@ 0x24
    if ((mask & 1) != 0) {
 80033f4:	e76a      	b.n	80032cc <_pal_lld_setgroupmode+0x3c>
      return;
 80033f6:	bf00      	nop
  }
}
 80033f8:	b00e      	add	sp, #56	@ 0x38
 80033fa:	4770      	bx	lr
 80033fc:	0000      	movs	r0, r0
	...

08003400 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 8003400:	b500      	push	{lr}
 8003402:	b083      	sub	sp, #12
 8003404:	2330      	movs	r3, #48	@ 0x30
 8003406:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003408:	9b01      	ldr	r3, [sp, #4]
 800340a:	f383 8811 	msr	BASEPRI, r3
}
 800340e:	bf00      	nop
}
 8003410:	bf00      	nop
}
 8003412:	bf00      	nop
  __dbg_check_lock_from_isr();
 8003414:	f000 fc5c 	bl	8003cd0 <__dbg_check_lock_from_isr>
}
 8003418:	bf00      	nop
 800341a:	b003      	add	sp, #12
 800341c:	f85d fb04 	ldr.w	pc, [sp], #4

08003420 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8003420:	b500      	push	{lr}
 8003422:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8003424:	f000 fc7c 	bl	8003d20 <__dbg_check_unlock_from_isr>
 8003428:	2300      	movs	r3, #0
 800342a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800342c:	9b01      	ldr	r3, [sp, #4]
 800342e:	f383 8811 	msr	BASEPRI, r3
}
 8003432:	bf00      	nop
}
 8003434:	bf00      	nop
}
 8003436:	bf00      	nop
}
 8003438:	bf00      	nop
 800343a:	b003      	add	sp, #12
 800343c:	f85d fb04 	ldr.w	pc, [sp], #4

08003440 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 8003440:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8003442:	f7ff ffdd 	bl	8003400 <chSysLockFromISR.lto_priv.1>
}
 8003446:	bf00      	nop
 8003448:	bd08      	pop	{r3, pc}
 800344a:	bf00      	nop
 800344c:	0000      	movs	r0, r0
	...

08003450 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 8003450:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8003452:	f7ff ffe5 	bl	8003420 <chSysUnlockFromISR.lto_priv.1>
}
 8003456:	bf00      	nop
 8003458:	bd08      	pop	{r3, pc}
 800345a:	bf00      	nop
 800345c:	0000      	movs	r0, r0
	...

08003460 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 8003460:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 8003462:	f000 fb95 	bl	8003b90 <chSysTimerHandlerI>
}
 8003466:	bf00      	nop
 8003468:	bd08      	pop	{r3, pc}
 800346a:	bf00      	nop
 800346c:	0000      	movs	r0, r0
	...

08003470 <rccEnableAPB1L.lto_priv.0>:
__STATIC_INLINE void rccEnableAPB1L(uint32_t mask, bool lp) {
 8003470:	b082      	sub	sp, #8
 8003472:	9001      	str	r0, [sp, #4]
 8003474:	460b      	mov	r3, r1
 8003476:	f88d 3003 	strb.w	r3, [sp, #3]
  RCC_C1->APB1LENR |= mask;
 800347a:	4b12      	ldr	r3, [pc, #72]	@ (80034c4 <rccEnableAPB1L.lto_priv.0+0x54>)
 800347c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8003480:	4910      	ldr	r1, [pc, #64]	@ (80034c4 <rccEnableAPB1L.lto_priv.0+0x54>)
 8003482:	9b01      	ldr	r3, [sp, #4]
 8003484:	4313      	orrs	r3, r2
 8003486:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8
  if (lp) {
 800348a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800348e:	2b00      	cmp	r3, #0
 8003490:	d008      	beq.n	80034a4 <rccEnableAPB1L.lto_priv.0+0x34>
    RCC_C1->APB1LLPENR |= mask;
 8003492:	4b0c      	ldr	r3, [pc, #48]	@ (80034c4 <rccEnableAPB1L.lto_priv.0+0x54>)
 8003494:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 8003498:	490a      	ldr	r1, [pc, #40]	@ (80034c4 <rccEnableAPB1L.lto_priv.0+0x54>)
 800349a:	9b01      	ldr	r3, [sp, #4]
 800349c:	4313      	orrs	r3, r2
 800349e:	f8c1 3110 	str.w	r3, [r1, #272]	@ 0x110
 80034a2:	e008      	b.n	80034b6 <rccEnableAPB1L.lto_priv.0+0x46>
    RCC_C1->APB1LLPENR &= ~mask;
 80034a4:	4b07      	ldr	r3, [pc, #28]	@ (80034c4 <rccEnableAPB1L.lto_priv.0+0x54>)
 80034a6:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 80034aa:	9b01      	ldr	r3, [sp, #4]
 80034ac:	43db      	mvns	r3, r3
 80034ae:	4905      	ldr	r1, [pc, #20]	@ (80034c4 <rccEnableAPB1L.lto_priv.0+0x54>)
 80034b0:	4013      	ands	r3, r2
 80034b2:	f8c1 3110 	str.w	r3, [r1, #272]	@ 0x110
  (void)RCC_C1->APB1LLPENR;
 80034b6:	4b03      	ldr	r3, [pc, #12]	@ (80034c4 <rccEnableAPB1L.lto_priv.0+0x54>)
 80034b8:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
}
 80034bc:	bf00      	nop
 80034be:	b002      	add	sp, #8
 80034c0:	4770      	bx	lr
 80034c2:	bf00      	nop
 80034c4:	58024400 	.word	0x58024400
	...

080034d0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80034d0:	b508      	push	{r3, lr}
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80034d2:	2101      	movs	r1, #1
 80034d4:	2001      	movs	r0, #1
 80034d6:	f7ff ffcb 	bl	8003470 <rccEnableAPB1L.lto_priv.0>

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80034da:	4b15      	ldr	r3, [pc, #84]	@ (8003530 <st_lld_init+0x60>)
 80034dc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80034de:	4a14      	ldr	r2, [pc, #80]	@ (8003530 <st_lld_init+0x60>)
 80034e0:	f043 0301 	orr.w	r3, r3, #1
 80034e4:	63d3      	str	r3, [r2, #60]	@ 0x3c

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80034e6:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80034ea:	f644 621f 	movw	r2, #19999	@ 0x4e1f
 80034ee:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80034f0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80034f4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80034f8:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80034fa:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80034fe:	2200      	movs	r2, #0
 8003500:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8003502:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8003506:	2200      	movs	r2, #0
 8003508:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 800350a:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800350e:	2200      	movs	r2, #0
 8003510:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8003512:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8003516:	2200      	movs	r2, #0
 8003518:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800351a:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800351e:	2201      	movs	r2, #1
 8003520:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8003522:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8003526:	2201      	movs	r2, #1
 8003528:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800352a:	bf00      	nop
 800352c:	bd08      	pop	{r3, pc}
 800352e:	bf00      	nop
 8003530:	5c001000 	.word	0x5c001000
	...

08003540 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8003540:	b500      	push	{lr}
 8003542:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8003544:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8003548:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 800354a:	9b01      	ldr	r3, [sp, #4]
 800354c:	691b      	ldr	r3, [r3, #16]
 800354e:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8003550:	9b01      	ldr	r3, [sp, #4]
 8003552:	68db      	ldr	r3, [r3, #12]
 8003554:	b2db      	uxtb	r3, r3
 8003556:	9a00      	ldr	r2, [sp, #0]
 8003558:	4013      	ands	r3, r2
 800355a:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 800355c:	9b00      	ldr	r3, [sp, #0]
 800355e:	43da      	mvns	r2, r3
 8003560:	9b01      	ldr	r3, [sp, #4]
 8003562:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8003564:	9b00      	ldr	r3, [sp, #0]
 8003566:	f003 0302 	and.w	r3, r3, #2
 800356a:	2b00      	cmp	r3, #0
 800356c:	d005      	beq.n	800357a <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 800356e:	f7ff ff67 	bl	8003440 <osalSysLockFromISR.lto_priv.1>
    osalOsTimerHandlerI();
 8003572:	f7ff ff75 	bl	8003460 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8003576:	f7ff ff6b 	bl	8003450 <osalSysUnlockFromISR.lto_priv.1>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 800357a:	bf00      	nop
 800357c:	b003      	add	sp, #12
 800357e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003582:	bf00      	nop
	...

08003590 <__rccResetAPB1L.lto_priv.1>:
__STATIC_INLINE void __rccResetAPB1L(uint32_t mask) {
 8003590:	b082      	sub	sp, #8
 8003592:	9001      	str	r0, [sp, #4]
  RCC->APB1LRSTR |= mask;
 8003594:	4b0b      	ldr	r3, [pc, #44]	@ (80035c4 <__rccResetAPB1L.lto_priv.1+0x34>)
 8003596:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 800359a:	490a      	ldr	r1, [pc, #40]	@ (80035c4 <__rccResetAPB1L.lto_priv.1+0x34>)
 800359c:	9b01      	ldr	r3, [sp, #4]
 800359e:	4313      	orrs	r3, r2
 80035a0:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
  RCC->APB1LRSTR &= ~mask;
 80035a4:	4b07      	ldr	r3, [pc, #28]	@ (80035c4 <__rccResetAPB1L.lto_priv.1+0x34>)
 80035a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 80035aa:	9b01      	ldr	r3, [sp, #4]
 80035ac:	43db      	mvns	r3, r3
 80035ae:	4905      	ldr	r1, [pc, #20]	@ (80035c4 <__rccResetAPB1L.lto_priv.1+0x34>)
 80035b0:	4013      	ands	r3, r2
 80035b2:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
  (void)RCC->APB1LRSTR;
 80035b6:	4b03      	ldr	r3, [pc, #12]	@ (80035c4 <__rccResetAPB1L.lto_priv.1+0x34>)
 80035b8:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
}
 80035bc:	bf00      	nop
 80035be:	b002      	add	sp, #8
 80035c0:	4770      	bx	lr
 80035c2:	bf00      	nop
 80035c4:	58024400 	.word	0x58024400
	...

080035d0 <rccEnableAPB1L.lto_priv.1>:
__STATIC_INLINE void rccEnableAPB1L(uint32_t mask, bool lp) {
 80035d0:	b082      	sub	sp, #8
 80035d2:	9001      	str	r0, [sp, #4]
 80035d4:	460b      	mov	r3, r1
 80035d6:	f88d 3003 	strb.w	r3, [sp, #3]
  RCC_C1->APB1LENR |= mask;
 80035da:	4b12      	ldr	r3, [pc, #72]	@ (8003624 <rccEnableAPB1L.lto_priv.1+0x54>)
 80035dc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 80035e0:	4910      	ldr	r1, [pc, #64]	@ (8003624 <rccEnableAPB1L.lto_priv.1+0x54>)
 80035e2:	9b01      	ldr	r3, [sp, #4]
 80035e4:	4313      	orrs	r3, r2
 80035e6:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8
  if (lp) {
 80035ea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80035ee:	2b00      	cmp	r3, #0
 80035f0:	d008      	beq.n	8003604 <rccEnableAPB1L.lto_priv.1+0x34>
    RCC_C1->APB1LLPENR |= mask;
 80035f2:	4b0c      	ldr	r3, [pc, #48]	@ (8003624 <rccEnableAPB1L.lto_priv.1+0x54>)
 80035f4:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 80035f8:	490a      	ldr	r1, [pc, #40]	@ (8003624 <rccEnableAPB1L.lto_priv.1+0x54>)
 80035fa:	9b01      	ldr	r3, [sp, #4]
 80035fc:	4313      	orrs	r3, r2
 80035fe:	f8c1 3110 	str.w	r3, [r1, #272]	@ 0x110
 8003602:	e008      	b.n	8003616 <rccEnableAPB1L.lto_priv.1+0x46>
    RCC_C1->APB1LLPENR &= ~mask;
 8003604:	4b07      	ldr	r3, [pc, #28]	@ (8003624 <rccEnableAPB1L.lto_priv.1+0x54>)
 8003606:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
 800360a:	9b01      	ldr	r3, [sp, #4]
 800360c:	43db      	mvns	r3, r3
 800360e:	4905      	ldr	r1, [pc, #20]	@ (8003624 <rccEnableAPB1L.lto_priv.1+0x54>)
 8003610:	4013      	ands	r3, r2
 8003612:	f8c1 3110 	str.w	r3, [r1, #272]	@ 0x110
  (void)RCC_C1->APB1LLPENR;
 8003616:	4b03      	ldr	r3, [pc, #12]	@ (8003624 <rccEnableAPB1L.lto_priv.1+0x54>)
 8003618:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
}
 800361c:	bf00      	nop
 800361e:	b002      	add	sp, #8
 8003620:	4770      	bx	lr
 8003622:	bf00      	nop
 8003624:	58024400 	.word	0x58024400
	...

08003630 <rccResetAPB1L>:
__STATIC_INLINE void rccResetAPB1L(uint32_t mask) {
 8003630:	b500      	push	{lr}
 8003632:	b083      	sub	sp, #12
 8003634:	9001      	str	r0, [sp, #4]
  __rccResetAPB1L(mask);
 8003636:	9801      	ldr	r0, [sp, #4]
 8003638:	f7ff ffaa 	bl	8003590 <__rccResetAPB1L.lto_priv.1>
}
 800363c:	bf00      	nop
 800363e:	b003      	add	sp, #12
 8003640:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003650 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8003650:	b508      	push	{r3, lr}
  gptObjectInit(&GPTD3);
#endif

#if STM32_GPT_USE_TIM4
  /* Driver initialization.*/
  GPTD4.tim = STM32_TIM4;
 8003652:	4b04      	ldr	r3, [pc, #16]	@ (8003664 <gpt_lld_init+0x14>)
 8003654:	4a04      	ldr	r2, [pc, #16]	@ (8003668 <gpt_lld_init+0x18>)
 8003656:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD4);
 8003658:	4802      	ldr	r0, [pc, #8]	@ (8003664 <gpt_lld_init+0x14>)
 800365a:	f7fd fad9 	bl	8000c10 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 800365e:	bf00      	nop
 8003660:	bd08      	pop	{r3, pc}
 8003662:	bf00      	nop
 8003664:	24000138 	.word	0x24000138
 8003668:	40000800 	.word	0x40000800
 800366c:	00000000 	.word	0x00000000

08003670 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 8003670:	b500      	push	{lr}
 8003672:	b085      	sub	sp, #20
 8003674:	9001      	str	r0, [sp, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 8003676:	9b01      	ldr	r3, [sp, #4]
 8003678:	781b      	ldrb	r3, [r3, #0]
 800367a:	2b01      	cmp	r3, #1
 800367c:	d10d      	bne.n	800369a <gpt_lld_start+0x2a>
#endif
    }
#endif

#if STM32_GPT_USE_TIM4
    if (&GPTD4 == gptp) {
 800367e:	9b01      	ldr	r3, [sp, #4]
 8003680:	4a25      	ldr	r2, [pc, #148]	@ (8003718 <gpt_lld_start+0xa8>)
 8003682:	4293      	cmp	r3, r2
 8003684:	d109      	bne.n	800369a <gpt_lld_start+0x2a>
      rccEnableTIM4(true);
 8003686:	2101      	movs	r1, #1
 8003688:	2004      	movs	r0, #4
 800368a:	f7ff ffa1 	bl	80035d0 <rccEnableAPB1L.lto_priv.1>
      rccResetTIM4();
 800368e:	2004      	movs	r0, #4
 8003690:	f7ff ffce 	bl	8003630 <rccResetAPB1L>
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_GPT_TIM4_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM4CLK)
      gptp->clock = STM32_TIM4CLK;
#else
      gptp->clock = STM32_TIMCLK1;
 8003694:	9b01      	ldr	r3, [sp, #4]
 8003696:	4a21      	ldr	r2, [pc, #132]	@ (800371c <gpt_lld_start+0xac>)
 8003698:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 800369a:	9b01      	ldr	r3, [sp, #4]
 800369c:	689a      	ldr	r2, [r3, #8]
 800369e:	9b01      	ldr	r3, [sp, #4]
 80036a0:	685b      	ldr	r3, [r3, #4]
 80036a2:	681b      	ldr	r3, [r3, #0]
 80036a4:	fbb2 f3f3 	udiv	r3, r2, r3
 80036a8:	b29b      	uxth	r3, r3
 80036aa:	3b01      	subs	r3, #1
 80036ac:	f8ad 300e 	strh.w	r3, [sp, #14]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
 80036b0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80036b4:	3301      	adds	r3, #1
 80036b6:	461a      	mov	r2, r3
 80036b8:	9b01      	ldr	r3, [sp, #4]
 80036ba:	685b      	ldr	r3, [r3, #4]
 80036bc:	681b      	ldr	r3, [r3, #0]
 80036be:	fb03 f202 	mul.w	r2, r3, r2
 80036c2:	9b01      	ldr	r3, [sp, #4]
 80036c4:	689b      	ldr	r3, [r3, #8]
 80036c6:	429a      	cmp	r2, r3
 80036c8:	bf14      	ite	ne
 80036ca:	2301      	movne	r3, #1
 80036cc:	2300      	moveq	r3, #0
 80036ce:	b2db      	uxtb	r3, r3
 80036d0:	2b00      	cmp	r3, #0
 80036d2:	d002      	beq.n	80036da <gpt_lld_start+0x6a>
 80036d4:	4812      	ldr	r0, [pc, #72]	@ (8003720 <gpt_lld_start+0xb0>)
 80036d6:	f000 fa23 	bl	8003b20 <chSysHalt>
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0U;                         /* Initially stopped.       */
 80036da:	9b01      	ldr	r3, [sp, #4]
 80036dc:	68db      	ldr	r3, [r3, #12]
 80036de:	2200      	movs	r2, #0
 80036e0:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 80036e2:	9b01      	ldr	r3, [sp, #4]
 80036e4:	685a      	ldr	r2, [r3, #4]
 80036e6:	9b01      	ldr	r3, [sp, #4]
 80036e8:	68db      	ldr	r3, [r3, #12]
 80036ea:	6892      	ldr	r2, [r2, #8]
 80036ec:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 80036ee:	9b01      	ldr	r3, [sp, #4]
 80036f0:	68db      	ldr	r3, [r3, #12]
 80036f2:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 80036f6:	629a      	str	r2, [r3, #40]	@ 0x28
  gptp->tim->SR   = 0U;                         /* Clear pending IRQs.      */
 80036f8:	9b01      	ldr	r3, [sp, #4]
 80036fa:	68db      	ldr	r3, [r3, #12]
 80036fc:	2200      	movs	r2, #0
 80036fe:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 8003700:	9b01      	ldr	r3, [sp, #4]
 8003702:	685b      	ldr	r3, [r3, #4]
 8003704:	68da      	ldr	r2, [r3, #12]
 8003706:	9b01      	ldr	r3, [sp, #4]
 8003708:	68db      	ldr	r3, [r3, #12]
 800370a:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 800370e:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 8003710:	bf00      	nop
 8003712:	b005      	add	sp, #20
 8003714:	f85d fb04 	ldr.w	pc, [sp], #4
 8003718:	24000138 	.word	0x24000138
 800371c:	0bebc200 	.word	0x0bebc200
 8003720:	08006d38 	.word	0x08006d38
	...

08003730 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 8003730:	b082      	sub	sp, #8
 8003732:	9001      	str	r0, [sp, #4]
 8003734:	9100      	str	r1, [sp, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8003736:	9b01      	ldr	r3, [sp, #4]
 8003738:	68db      	ldr	r3, [r3, #12]
 800373a:	9a00      	ldr	r2, [sp, #0]
 800373c:	3a01      	subs	r2, #1
 800373e:	62da      	str	r2, [r3, #44]	@ 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 8003740:	9b01      	ldr	r3, [sp, #4]
 8003742:	68db      	ldr	r3, [r3, #12]
 8003744:	2201      	movs	r2, #1
 8003746:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0U;                          /* Reset counter.           */
 8003748:	9b01      	ldr	r3, [sp, #4]
 800374a:	68db      	ldr	r3, [r3, #12]
 800374c:	2200      	movs	r2, #0
 800374e:	625a      	str	r2, [r3, #36]	@ 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8003750:	9b01      	ldr	r3, [sp, #4]
 8003752:	68db      	ldr	r3, [r3, #12]
 8003754:	2200      	movs	r2, #0
 8003756:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8003758:	9b01      	ldr	r3, [sp, #4]
 800375a:	685b      	ldr	r3, [r3, #4]
 800375c:	685b      	ldr	r3, [r3, #4]
 800375e:	2b00      	cmp	r3, #0
 8003760:	d007      	beq.n	8003772 <gpt_lld_start_timer+0x42>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8003762:	9b01      	ldr	r3, [sp, #4]
 8003764:	68db      	ldr	r3, [r3, #12]
 8003766:	68da      	ldr	r2, [r3, #12]
 8003768:	9b01      	ldr	r3, [sp, #4]
 800376a:	68db      	ldr	r3, [r3, #12]
 800376c:	f042 0201 	orr.w	r2, r2, #1
 8003770:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8003772:	9b01      	ldr	r3, [sp, #4]
 8003774:	68db      	ldr	r3, [r3, #12]
 8003776:	2285      	movs	r2, #133	@ 0x85
 8003778:	601a      	str	r2, [r3, #0]
}
 800377a:	bf00      	nop
 800377c:	b002      	add	sp, #8
 800377e:	4770      	bx	lr

08003780 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 8003780:	b082      	sub	sp, #8
 8003782:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1 = 0U;                          /* Initially stopped.       */
 8003784:	9b01      	ldr	r3, [sp, #4]
 8003786:	68db      	ldr	r3, [r3, #12]
 8003788:	2200      	movs	r2, #0
 800378a:	601a      	str	r2, [r3, #0]
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 800378c:	9b01      	ldr	r3, [sp, #4]
 800378e:	68db      	ldr	r3, [r3, #12]
 8003790:	2200      	movs	r2, #0
 8003792:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8003794:	9b01      	ldr	r3, [sp, #4]
 8003796:	68db      	ldr	r3, [r3, #12]
 8003798:	68da      	ldr	r2, [r3, #12]
 800379a:	9b01      	ldr	r3, [sp, #4]
 800379c:	68db      	ldr	r3, [r3, #12]
 800379e:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 80037a2:	60da      	str	r2, [r3, #12]
}
 80037a4:	bf00      	nop
 80037a6:	b002      	add	sp, #8
 80037a8:	4770      	bx	lr
 80037aa:	bf00      	nop
 80037ac:	0000      	movs	r0, r0
	...

080037b0 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 80037b0:	b500      	push	{lr}
 80037b2:	b085      	sub	sp, #20
 80037b4:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 80037b6:	9b01      	ldr	r3, [sp, #4]
 80037b8:	68db      	ldr	r3, [r3, #12]
 80037ba:	691b      	ldr	r3, [r3, #16]
 80037bc:	9303      	str	r3, [sp, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 80037be:	9b01      	ldr	r3, [sp, #4]
 80037c0:	68db      	ldr	r3, [r3, #12]
 80037c2:	68db      	ldr	r3, [r3, #12]
 80037c4:	b2db      	uxtb	r3, r3
 80037c6:	9a03      	ldr	r2, [sp, #12]
 80037c8:	4013      	ands	r3, r2
 80037ca:	9303      	str	r3, [sp, #12]
  gptp->tim->SR = ~sr;
 80037cc:	9b01      	ldr	r3, [sp, #4]
 80037ce:	68db      	ldr	r3, [r3, #12]
 80037d0:	9a03      	ldr	r2, [sp, #12]
 80037d2:	43d2      	mvns	r2, r2
 80037d4:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 80037d6:	9b03      	ldr	r3, [sp, #12]
 80037d8:	f003 0301 	and.w	r3, r3, #1
 80037dc:	2b00      	cmp	r3, #0
 80037de:	d013      	beq.n	8003808 <gpt_lld_serve_interrupt+0x58>
    _gpt_isr_invoke_cb(gptp);
 80037e0:	9b01      	ldr	r3, [sp, #4]
 80037e2:	781b      	ldrb	r3, [r3, #0]
 80037e4:	2b04      	cmp	r3, #4
 80037e6:	d105      	bne.n	80037f4 <gpt_lld_serve_interrupt+0x44>
 80037e8:	9b01      	ldr	r3, [sp, #4]
 80037ea:	2202      	movs	r2, #2
 80037ec:	701a      	strb	r2, [r3, #0]
 80037ee:	9801      	ldr	r0, [sp, #4]
 80037f0:	f7ff ffc6 	bl	8003780 <gpt_lld_stop_timer>
 80037f4:	9b01      	ldr	r3, [sp, #4]
 80037f6:	685b      	ldr	r3, [r3, #4]
 80037f8:	685b      	ldr	r3, [r3, #4]
 80037fa:	2b00      	cmp	r3, #0
 80037fc:	d004      	beq.n	8003808 <gpt_lld_serve_interrupt+0x58>
 80037fe:	9b01      	ldr	r3, [sp, #4]
 8003800:	685b      	ldr	r3, [r3, #4]
 8003802:	685b      	ldr	r3, [r3, #4]
 8003804:	9801      	ldr	r0, [sp, #4]
 8003806:	4798      	blx	r3
  }
}
 8003808:	bf00      	nop
 800380a:	b005      	add	sp, #20
 800380c:	f85d fb04 	ldr.w	pc, [sp], #4

08003810 <__rccResetAHB4.lto_priv.2>:
__STATIC_INLINE void __rccResetAHB4(uint32_t mask) {
 8003810:	b082      	sub	sp, #8
 8003812:	9001      	str	r0, [sp, #4]
  RCC->AHB4RSTR |= mask;
 8003814:	4b0b      	ldr	r3, [pc, #44]	@ (8003844 <__rccResetAHB4.lto_priv.2+0x34>)
 8003816:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 800381a:	490a      	ldr	r1, [pc, #40]	@ (8003844 <__rccResetAHB4.lto_priv.2+0x34>)
 800381c:	9b01      	ldr	r3, [sp, #4]
 800381e:	4313      	orrs	r3, r2
 8003820:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  RCC->AHB4RSTR &= ~mask;
 8003824:	4b07      	ldr	r3, [pc, #28]	@ (8003844 <__rccResetAHB4.lto_priv.2+0x34>)
 8003826:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 800382a:	9b01      	ldr	r3, [sp, #4]
 800382c:	43db      	mvns	r3, r3
 800382e:	4905      	ldr	r1, [pc, #20]	@ (8003844 <__rccResetAHB4.lto_priv.2+0x34>)
 8003830:	4013      	ands	r3, r2
 8003832:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  (void)RCC->AHB4RSTR;
 8003836:	4b03      	ldr	r3, [pc, #12]	@ (8003844 <__rccResetAHB4.lto_priv.2+0x34>)
 8003838:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
}
 800383c:	bf00      	nop
 800383e:	b002      	add	sp, #8
 8003840:	4770      	bx	lr
 8003842:	bf00      	nop
 8003844:	58024400 	.word	0x58024400
	...

08003850 <rccEnableAHB4.lto_priv.3>:
__STATIC_INLINE void rccEnableAHB4(uint32_t mask, bool lp) {
 8003850:	b082      	sub	sp, #8
 8003852:	9001      	str	r0, [sp, #4]
 8003854:	460b      	mov	r3, r1
 8003856:	f88d 3003 	strb.w	r3, [sp, #3]
  RCC_C1->AHB4ENR |= mask;
 800385a:	4b12      	ldr	r3, [pc, #72]	@ (80038a4 <rccEnableAHB4.lto_priv.3+0x54>)
 800385c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8003860:	4910      	ldr	r1, [pc, #64]	@ (80038a4 <rccEnableAHB4.lto_priv.3+0x54>)
 8003862:	9b01      	ldr	r3, [sp, #4]
 8003864:	4313      	orrs	r3, r2
 8003866:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  if (lp) {
 800386a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800386e:	2b00      	cmp	r3, #0
 8003870:	d008      	beq.n	8003884 <rccEnableAHB4.lto_priv.3+0x34>
    RCC_C1->AHB4LPENR |= mask;
 8003872:	4b0c      	ldr	r3, [pc, #48]	@ (80038a4 <rccEnableAHB4.lto_priv.3+0x54>)
 8003874:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8003878:	490a      	ldr	r1, [pc, #40]	@ (80038a4 <rccEnableAHB4.lto_priv.3+0x54>)
 800387a:	9b01      	ldr	r3, [sp, #4]
 800387c:	4313      	orrs	r3, r2
 800387e:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
 8003882:	e008      	b.n	8003896 <rccEnableAHB4.lto_priv.3+0x46>
    RCC_C1->AHB4LPENR &= ~mask;
 8003884:	4b07      	ldr	r3, [pc, #28]	@ (80038a4 <rccEnableAHB4.lto_priv.3+0x54>)
 8003886:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 800388a:	9b01      	ldr	r3, [sp, #4]
 800388c:	43db      	mvns	r3, r3
 800388e:	4905      	ldr	r1, [pc, #20]	@ (80038a4 <rccEnableAHB4.lto_priv.3+0x54>)
 8003890:	4013      	ands	r3, r2
 8003892:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
  (void)RCC_C1->AHB4LPENR;
 8003896:	4b03      	ldr	r3, [pc, #12]	@ (80038a4 <rccEnableAHB4.lto_priv.3+0x54>)
 8003898:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
}
 800389c:	bf00      	nop
 800389e:	b002      	add	sp, #8
 80038a0:	4770      	bx	lr
 80038a2:	bf00      	nop
 80038a4:	58024400 	.word	0x58024400
	...

080038b0 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 80038b0:	b082      	sub	sp, #8
 80038b2:	9001      	str	r0, [sp, #4]
 80038b4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 80038b6:	9b00      	ldr	r3, [sp, #0]
 80038b8:	685a      	ldr	r2, [r3, #4]
 80038ba:	9b01      	ldr	r3, [sp, #4]
 80038bc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80038be:	9b00      	ldr	r3, [sp, #0]
 80038c0:	689a      	ldr	r2, [r3, #8]
 80038c2:	9b01      	ldr	r3, [sp, #4]
 80038c4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80038c6:	9b00      	ldr	r3, [sp, #0]
 80038c8:	68da      	ldr	r2, [r3, #12]
 80038ca:	9b01      	ldr	r3, [sp, #4]
 80038cc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80038ce:	9b00      	ldr	r3, [sp, #0]
 80038d0:	691a      	ldr	r2, [r3, #16]
 80038d2:	9b01      	ldr	r3, [sp, #4]
 80038d4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80038d6:	9b00      	ldr	r3, [sp, #0]
 80038d8:	695a      	ldr	r2, [r3, #20]
 80038da:	9b01      	ldr	r3, [sp, #4]
 80038dc:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80038de:	9b00      	ldr	r3, [sp, #0]
 80038e0:	699a      	ldr	r2, [r3, #24]
 80038e2:	9b01      	ldr	r3, [sp, #4]
 80038e4:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 80038e6:	9b00      	ldr	r3, [sp, #0]
 80038e8:	681a      	ldr	r2, [r3, #0]
 80038ea:	9b01      	ldr	r3, [sp, #4]
 80038ec:	601a      	str	r2, [r3, #0]
}
 80038ee:	bf00      	nop
 80038f0:	b002      	add	sp, #8
 80038f2:	4770      	bx	lr
	...

08003900 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8003900:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  __rccResetAHB4(STM32_GPIO_EN_MASK);
 8003902:	f240 70ff 	movw	r0, #2047	@ 0x7ff
 8003906:	f7ff ff83 	bl	8003810 <__rccResetAHB4.lto_priv.2>
  rccEnableAHB4(STM32_GPIO_EN_MASK, true);
 800390a:	2101      	movs	r1, #1
 800390c:	f240 70ff 	movw	r0, #2047	@ 0x7ff
 8003910:	f7ff ff9e 	bl	8003850 <rccEnableAHB4.lto_priv.3>

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 8003914:	4916      	ldr	r1, [pc, #88]	@ (8003970 <stm32_gpio_init+0x70>)
 8003916:	4817      	ldr	r0, [pc, #92]	@ (8003974 <stm32_gpio_init+0x74>)
 8003918:	f7ff ffca 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 800391c:	4916      	ldr	r1, [pc, #88]	@ (8003978 <stm32_gpio_init+0x78>)
 800391e:	4817      	ldr	r0, [pc, #92]	@ (800397c <stm32_gpio_init+0x7c>)
 8003920:	f7ff ffc6 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 8003924:	4916      	ldr	r1, [pc, #88]	@ (8003980 <stm32_gpio_init+0x80>)
 8003926:	4817      	ldr	r0, [pc, #92]	@ (8003984 <stm32_gpio_init+0x84>)
 8003928:	f7ff ffc2 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 800392c:	4916      	ldr	r1, [pc, #88]	@ (8003988 <stm32_gpio_init+0x88>)
 800392e:	4817      	ldr	r0, [pc, #92]	@ (800398c <stm32_gpio_init+0x8c>)
 8003930:	f7ff ffbe 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 8003934:	4916      	ldr	r1, [pc, #88]	@ (8003990 <stm32_gpio_init+0x90>)
 8003936:	4817      	ldr	r0, [pc, #92]	@ (8003994 <stm32_gpio_init+0x94>)
 8003938:	f7ff ffba 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 800393c:	4916      	ldr	r1, [pc, #88]	@ (8003998 <stm32_gpio_init+0x98>)
 800393e:	4817      	ldr	r0, [pc, #92]	@ (800399c <stm32_gpio_init+0x9c>)
 8003940:	f7ff ffb6 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 8003944:	4916      	ldr	r1, [pc, #88]	@ (80039a0 <stm32_gpio_init+0xa0>)
 8003946:	4817      	ldr	r0, [pc, #92]	@ (80039a4 <stm32_gpio_init+0xa4>)
 8003948:	f7ff ffb2 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 800394c:	4916      	ldr	r1, [pc, #88]	@ (80039a8 <stm32_gpio_init+0xa8>)
 800394e:	4817      	ldr	r0, [pc, #92]	@ (80039ac <stm32_gpio_init+0xac>)
 8003950:	f7ff ffae 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOI
  gpio_init(GPIOI, &gpio_default_config.PIData);
 8003954:	4916      	ldr	r1, [pc, #88]	@ (80039b0 <stm32_gpio_init+0xb0>)
 8003956:	4817      	ldr	r0, [pc, #92]	@ (80039b4 <stm32_gpio_init+0xb4>)
 8003958:	f7ff ffaa 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOJ
  gpio_init(GPIOJ, &gpio_default_config.PJData);
 800395c:	4916      	ldr	r1, [pc, #88]	@ (80039b8 <stm32_gpio_init+0xb8>)
 800395e:	4817      	ldr	r0, [pc, #92]	@ (80039bc <stm32_gpio_init+0xbc>)
 8003960:	f7ff ffa6 	bl	80038b0 <gpio_init>
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
 8003964:	4916      	ldr	r1, [pc, #88]	@ (80039c0 <stm32_gpio_init+0xc0>)
 8003966:	4817      	ldr	r0, [pc, #92]	@ (80039c4 <stm32_gpio_init+0xc4>)
 8003968:	f7ff ffa2 	bl	80038b0 <gpio_init>
#endif
}
 800396c:	bf00      	nop
 800396e:	bd08      	pop	{r3, pc}
 8003970:	08006d48 	.word	0x08006d48
 8003974:	58020000 	.word	0x58020000
 8003978:	08006d64 	.word	0x08006d64
 800397c:	58020400 	.word	0x58020400
 8003980:	08006d80 	.word	0x08006d80
 8003984:	58020800 	.word	0x58020800
 8003988:	08006d9c 	.word	0x08006d9c
 800398c:	58020c00 	.word	0x58020c00
 8003990:	08006db8 	.word	0x08006db8
 8003994:	58021000 	.word	0x58021000
 8003998:	08006dd4 	.word	0x08006dd4
 800399c:	58021400 	.word	0x58021400
 80039a0:	08006df0 	.word	0x08006df0
 80039a4:	58021800 	.word	0x58021800
 80039a8:	08006e0c 	.word	0x08006e0c
 80039ac:	58021c00 	.word	0x58021c00
 80039b0:	08006e28 	.word	0x08006e28
 80039b4:	58022000 	.word	0x58022000
 80039b8:	08006e44 	.word	0x08006e44
 80039bc:	58022400 	.word	0x58022400
 80039c0:	08006e60 	.word	0x08006e60
 80039c4:	58022800 	.word	0x58022800
	...

080039d0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80039d0:	b508      	push	{r3, lr}

  stm32_gpio_init();
 80039d2:	f7ff ff95 	bl	8003900 <stm32_gpio_init>
  stm32_clock_init();
 80039d6:	f7fd fe33 	bl	8001640 <stm32_clock_init>
}
 80039da:	bf00      	nop
 80039dc:	bd08      	pop	{r3, pc}
 80039de:	bf00      	nop

080039e0 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 80039e0:	bf00      	nop
 80039e2:	4770      	bx	lr
	...

080039f0 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 80039f0:	b500      	push	{lr}
 80039f2:	b08b      	sub	sp, #44	@ 0x2c
 80039f4:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 80039f6:	9b01      	ldr	r3, [sp, #4]
 80039f8:	2200      	movs	r2, #0
 80039fa:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 80039fc:	ab02      	add	r3, sp, #8
 80039fe:	4618      	mov	r0, r3
 8003a00:	f001 ff9e 	bl	8005940 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 8003a04:	2304      	movs	r3, #4
 8003a06:	9309      	str	r3, [sp, #36]	@ 0x24
  do {
    chTMStartMeasurementX(&tm);
 8003a08:	ab02      	add	r3, sp, #8
 8003a0a:	4618      	mov	r0, r3
 8003a0c:	f001 ffb8 	bl	8005980 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8003a10:	ab02      	add	r3, sp, #8
 8003a12:	4618      	mov	r0, r3
 8003a14:	f001 ffc4 	bl	80059a0 <chTMStopMeasurementX>
    i--;
 8003a18:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003a1a:	3b01      	subs	r3, #1
 8003a1c:	9309      	str	r3, [sp, #36]	@ 0x24
  } while (i > 0U);
 8003a1e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8003a20:	2b00      	cmp	r3, #0
 8003a22:	d1f1      	bne.n	8003a08 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
 8003a24:	9a02      	ldr	r2, [sp, #8]
 8003a26:	9b01      	ldr	r3, [sp, #4]
 8003a28:	601a      	str	r2, [r3, #0]
}
 8003a2a:	bf00      	nop
 8003a2c:	b00b      	add	sp, #44	@ 0x2c
 8003a2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a32:	bf00      	nop
	...

08003a40 <chSysUnlock.lto_priv.6>:
static inline void chSysUnlock(void) {
 8003a40:	b500      	push	{lr}
 8003a42:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8003a44:	f000 f91c 	bl	8003c80 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003a48:	4b12      	ldr	r3, [pc, #72]	@ (8003a94 <chSysUnlock.lto_priv.6+0x54>)
 8003a4a:	681b      	ldr	r3, [r3, #0]
 8003a4c:	4a11      	ldr	r2, [pc, #68]	@ (8003a94 <chSysUnlock.lto_priv.6+0x54>)
 8003a4e:	4293      	cmp	r3, r2
 8003a50:	bf14      	ite	ne
 8003a52:	2301      	movne	r3, #1
 8003a54:	2300      	moveq	r3, #0
 8003a56:	b2db      	uxtb	r3, r3
 8003a58:	2b00      	cmp	r3, #0
 8003a5a:	d00f      	beq.n	8003a7c <chSysUnlock.lto_priv.6+0x3c>
 8003a5c:	4b0d      	ldr	r3, [pc, #52]	@ (8003a94 <chSysUnlock.lto_priv.6+0x54>)
 8003a5e:	68db      	ldr	r3, [r3, #12]
 8003a60:	689a      	ldr	r2, [r3, #8]
 8003a62:	4b0c      	ldr	r3, [pc, #48]	@ (8003a94 <chSysUnlock.lto_priv.6+0x54>)
 8003a64:	681b      	ldr	r3, [r3, #0]
 8003a66:	689b      	ldr	r3, [r3, #8]
 8003a68:	429a      	cmp	r2, r3
 8003a6a:	bf34      	ite	cc
 8003a6c:	2301      	movcc	r3, #1
 8003a6e:	2300      	movcs	r3, #0
 8003a70:	b2db      	uxtb	r3, r3
 8003a72:	2b00      	cmp	r3, #0
 8003a74:	d002      	beq.n	8003a7c <chSysUnlock.lto_priv.6+0x3c>
 8003a76:	4808      	ldr	r0, [pc, #32]	@ (8003a98 <chSysUnlock.lto_priv.6+0x58>)
 8003a78:	f000 f852 	bl	8003b20 <chSysHalt>
 8003a7c:	2300      	movs	r3, #0
 8003a7e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003a80:	9b01      	ldr	r3, [sp, #4]
 8003a82:	f383 8811 	msr	BASEPRI, r3
}
 8003a86:	bf00      	nop
}
 8003a88:	bf00      	nop
}
 8003a8a:	bf00      	nop
 8003a8c:	b003      	add	sp, #12
 8003a8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a92:	bf00      	nop
 8003a94:	24000158 	.word	0x24000158
 8003a98:	08006f08 	.word	0x08006f08
 8003a9c:	00000000 	.word	0x00000000

08003aa0 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 8003aa0:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 8003aa2:	f002 faad 	bl	8006000 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8003aa6:	f002 fb1b 	bl	80060e0 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 8003aaa:	f002 fce1 	bl	8006470 <__factory_init>
#endif
}
 8003aae:	bf00      	nop
 8003ab0:	bd08      	pop	{r3, pc}
 8003ab2:	bf00      	nop
	...

08003ac0 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 8003ac0:	b500      	push	{lr}
 8003ac2:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8003ac4:	4b11      	ldr	r3, [pc, #68]	@ (8003b0c <chSysInit+0x4c>)
 8003ac6:	2201      	movs	r2, #1
 8003ac8:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 8003aca:	2300      	movs	r3, #0
 8003acc:	9301      	str	r3, [sp, #4]
 8003ace:	e008      	b.n	8003ae2 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
 8003ad0:	4a0e      	ldr	r2, [pc, #56]	@ (8003b0c <chSysInit+0x4c>)
 8003ad2:	9b01      	ldr	r3, [sp, #4]
 8003ad4:	009b      	lsls	r3, r3, #2
 8003ad6:	4413      	add	r3, r2
 8003ad8:	2200      	movs	r2, #0
 8003ada:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 8003adc:	9b01      	ldr	r3, [sp, #4]
 8003ade:	3301      	adds	r3, #1
 8003ae0:	9301      	str	r3, [sp, #4]
 8003ae2:	9b01      	ldr	r3, [sp, #4]
 8003ae4:	2b00      	cmp	r3, #0
 8003ae6:	d0f3      	beq.n	8003ad0 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 8003ae8:	4809      	ldr	r0, [pc, #36]	@ (8003b10 <chSysInit+0x50>)
 8003aea:	f7ff ff81 	bl	80039f0 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 8003aee:	f7ff ffd7 	bl	8003aa0 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 8003af2:	4908      	ldr	r1, [pc, #32]	@ (8003b14 <chSysInit+0x54>)
 8003af4:	4808      	ldr	r0, [pc, #32]	@ (8003b18 <chSysInit+0x58>)
 8003af6:	f001 fad3 	bl	80050a0 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 8003afa:	4b04      	ldr	r3, [pc, #16]	@ (8003b0c <chSysInit+0x4c>)
 8003afc:	2202      	movs	r2, #2
 8003afe:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 8003b00:	f7ff ff9e 	bl	8003a40 <chSysUnlock.lto_priv.6>
}
 8003b04:	bf00      	nop
 8003b06:	b003      	add	sp, #12
 8003b08:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b0c:	24000148 	.word	0x24000148
 8003b10:	24000150 	.word	0x24000150
 8003b14:	08006ef4 	.word	0x08006ef4
 8003b18:	24000158 	.word	0x24000158
 8003b1c:	00000000 	.word	0x00000000

08003b20 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8003b20:	b500      	push	{lr}
 8003b22:	b083      	sub	sp, #12
 8003b24:	9001      	str	r0, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8003b26:	b672      	cpsid	i
}
 8003b28:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 8003b2a:	bf00      	nop

  port_disable();

  /* Logging the event.*/
  __trace_halt(reason);
 8003b2c:	9801      	ldr	r0, [sp, #4]
 8003b2e:	f000 fb37 	bl	80041a0 <__trace_halt>

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 8003b32:	4a04      	ldr	r2, [pc, #16]	@ (8003b44 <chSysHalt+0x24>)
 8003b34:	9b01      	ldr	r3, [sp, #4]
 8003b36:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8003b3a:	4b03      	ldr	r3, [pc, #12]	@ (8003b48 <chSysHalt+0x28>)
 8003b3c:	2203      	movs	r2, #3
 8003b3e:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
     asm volatile ("nop");
 8003b40:	bf00      	nop
 8003b42:	e7fd      	b.n	8003b40 <chSysHalt+0x20>
 8003b44:	24000158 	.word	0x24000158
 8003b48:	24000148 	.word	0x24000148
 8003b4c:	00000000 	.word	0x00000000

08003b50 <chSysGetIdleThreadX>:
 *
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
 8003b50:	b500      	push	{lr}
 8003b52:	b083      	sub	sp, #12
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8003b54:	4b09      	ldr	r3, [pc, #36]	@ (8003b7c <chSysGetIdleThreadX+0x2c>)
 8003b56:	685b      	ldr	r3, [r3, #4]
 8003b58:	9301      	str	r3, [sp, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 8003b5a:	9b01      	ldr	r3, [sp, #4]
 8003b5c:	689b      	ldr	r3, [r3, #8]
 8003b5e:	2b01      	cmp	r3, #1
 8003b60:	bf14      	ite	ne
 8003b62:	2301      	movne	r3, #1
 8003b64:	2300      	moveq	r3, #0
 8003b66:	b2db      	uxtb	r3, r3
 8003b68:	2b00      	cmp	r3, #0
 8003b6a:	d002      	beq.n	8003b72 <chSysGetIdleThreadX+0x22>
 8003b6c:	4804      	ldr	r0, [pc, #16]	@ (8003b80 <chSysGetIdleThreadX+0x30>)
 8003b6e:	f7ff ffd7 	bl	8003b20 <chSysHalt>

  return tp;
 8003b72:	9b01      	ldr	r3, [sp, #4]
}
 8003b74:	4618      	mov	r0, r3
 8003b76:	b003      	add	sp, #12
 8003b78:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b7c:	24000158 	.word	0x24000158
 8003b80:	08006f14 	.word	0x08006f14
	...

08003b90 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8003b90:	b508      	push	{r3, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 8003b92:	f000 f965 	bl	8003e60 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8003b96:	f000 fe0b 	bl	80047b0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8003b9a:	bf00      	nop
 8003b9c:	bd08      	pop	{r3, pc}
 8003b9e:	bf00      	nop

08003ba0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 8003ba0:	b084      	sub	sp, #16
 8003ba2:	9003      	str	r0, [sp, #12]
 8003ba4:	9102      	str	r1, [sp, #8]
 8003ba6:	9201      	str	r2, [sp, #4]

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8003ba8:	9a03      	ldr	r2, [sp, #12]
 8003baa:	9b02      	ldr	r3, [sp, #8]
 8003bac:	1ad2      	subs	r2, r2, r3
                ((rtcnt_t)end - (rtcnt_t)start));
 8003bae:	9901      	ldr	r1, [sp, #4]
 8003bb0:	9b02      	ldr	r3, [sp, #8]
 8003bb2:	1acb      	subs	r3, r1, r3
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8003bb4:	429a      	cmp	r2, r3
 8003bb6:	bf34      	ite	cc
 8003bb8:	2301      	movcc	r3, #1
 8003bba:	2300      	movcs	r3, #0
 8003bbc:	b2db      	uxtb	r3, r3
}
 8003bbe:	4618      	mov	r0, r3
 8003bc0:	b004      	add	sp, #16
 8003bc2:	4770      	bx	lr
	...

08003bd0 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8003bd0:	b500      	push	{lr}
 8003bd2:	b085      	sub	sp, #20
 8003bd4:	9001      	str	r0, [sp, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8003bd6:	4b0b      	ldr	r3, [pc, #44]	@ (8003c04 <chSysPolledDelayX+0x34>)
 8003bd8:	685b      	ldr	r3, [r3, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8003bda:	9303      	str	r3, [sp, #12]
  rtcnt_t end  = start + cycles;
 8003bdc:	9a03      	ldr	r2, [sp, #12]
 8003bde:	9b01      	ldr	r3, [sp, #4]
 8003be0:	4413      	add	r3, r2
 8003be2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8003be4:	bf00      	nop
 8003be6:	4b07      	ldr	r3, [pc, #28]	@ (8003c04 <chSysPolledDelayX+0x34>)
 8003be8:	685b      	ldr	r3, [r3, #4]
 8003bea:	9a02      	ldr	r2, [sp, #8]
 8003bec:	9903      	ldr	r1, [sp, #12]
 8003bee:	4618      	mov	r0, r3
 8003bf0:	f7ff ffd6 	bl	8003ba0 <chSysIsCounterWithinX>
 8003bf4:	4603      	mov	r3, r0
 8003bf6:	2b00      	cmp	r3, #0
 8003bf8:	d1f5      	bne.n	8003be6 <chSysPolledDelayX+0x16>
  }
}
 8003bfa:	bf00      	nop
 8003bfc:	bf00      	nop
 8003bfe:	b005      	add	sp, #20
 8003c00:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c04:	e0001000 	.word	0xe0001000
	...

08003c10 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 8003c10:	b082      	sub	sp, #8
 8003c12:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8003c14:	4b04      	ldr	r3, [pc, #16]	@ (8003c28 <chRFCUCollectFaultsI+0x18>)
 8003c16:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8003c18:	9b01      	ldr	r3, [sp, #4]
 8003c1a:	4313      	orrs	r3, r2
 8003c1c:	4a02      	ldr	r2, [pc, #8]	@ (8003c28 <chRFCUCollectFaultsI+0x18>)
 8003c1e:	6353      	str	r3, [r2, #52]	@ 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8003c20:	bf00      	nop
 8003c22:	b002      	add	sp, #8
 8003c24:	4770      	bx	lr
 8003c26:	bf00      	nop
 8003c28:	24000158 	.word	0x24000158
 8003c2c:	00000000 	.word	0x00000000

08003c30 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 8003c30:	b500      	push	{lr}
 8003c32:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003c34:	4b10      	ldr	r3, [pc, #64]	@ (8003c78 <__dbg_check_lock+0x48>)
 8003c36:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8003c38:	9b01      	ldr	r3, [sp, #4]
 8003c3a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003c3e:	2b00      	cmp	r3, #0
 8003c40:	bf14      	ite	ne
 8003c42:	2301      	movne	r3, #1
 8003c44:	2300      	moveq	r3, #0
 8003c46:	b2db      	uxtb	r3, r3
 8003c48:	2b00      	cmp	r3, #0
 8003c4a:	d109      	bne.n	8003c60 <__dbg_check_lock+0x30>
 8003c4c:	9b01      	ldr	r3, [sp, #4]
 8003c4e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003c52:	2b00      	cmp	r3, #0
 8003c54:	bf14      	ite	ne
 8003c56:	2301      	movne	r3, #1
 8003c58:	2300      	moveq	r3, #0
 8003c5a:	b2db      	uxtb	r3, r3
 8003c5c:	2b00      	cmp	r3, #0
 8003c5e:	d002      	beq.n	8003c66 <__dbg_check_lock+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 8003c60:	4806      	ldr	r0, [pc, #24]	@ (8003c7c <__dbg_check_lock+0x4c>)
 8003c62:	f7ff ff5d 	bl	8003b20 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8003c66:	9b01      	ldr	r3, [sp, #4]
 8003c68:	2201      	movs	r2, #1
 8003c6a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 8003c6e:	bf00      	nop
 8003c70:	b003      	add	sp, #12
 8003c72:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c76:	bf00      	nop
 8003c78:	24000158 	.word	0x24000158
 8003c7c:	08006e80 	.word	0x08006e80

08003c80 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 8003c80:	b500      	push	{lr}
 8003c82:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003c84:	4b10      	ldr	r3, [pc, #64]	@ (8003cc8 <__dbg_check_unlock+0x48>)
 8003c86:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8003c88:	9b01      	ldr	r3, [sp, #4]
 8003c8a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003c8e:	2b00      	cmp	r3, #0
 8003c90:	bf14      	ite	ne
 8003c92:	2301      	movne	r3, #1
 8003c94:	2300      	moveq	r3, #0
 8003c96:	b2db      	uxtb	r3, r3
 8003c98:	2b00      	cmp	r3, #0
 8003c9a:	d109      	bne.n	8003cb0 <__dbg_check_unlock+0x30>
 8003c9c:	9b01      	ldr	r3, [sp, #4]
 8003c9e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003ca2:	2b00      	cmp	r3, #0
 8003ca4:	bfd4      	ite	le
 8003ca6:	2301      	movle	r3, #1
 8003ca8:	2300      	movgt	r3, #0
 8003caa:	b2db      	uxtb	r3, r3
 8003cac:	2b00      	cmp	r3, #0
 8003cae:	d002      	beq.n	8003cb6 <__dbg_check_unlock+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 8003cb0:	4806      	ldr	r0, [pc, #24]	@ (8003ccc <__dbg_check_unlock+0x4c>)
 8003cb2:	f7ff ff35 	bl	8003b20 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8003cb6:	9b01      	ldr	r3, [sp, #4]
 8003cb8:	2200      	movs	r2, #0
 8003cba:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 8003cbe:	bf00      	nop
 8003cc0:	b003      	add	sp, #12
 8003cc2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cc6:	bf00      	nop
 8003cc8:	24000158 	.word	0x24000158
 8003ccc:	08006e88 	.word	0x08006e88

08003cd0 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 8003cd0:	b500      	push	{lr}
 8003cd2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003cd4:	4b10      	ldr	r3, [pc, #64]	@ (8003d18 <__dbg_check_lock_from_isr+0x48>)
 8003cd6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8003cd8:	9b01      	ldr	r3, [sp, #4]
 8003cda:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003cde:	2b00      	cmp	r3, #0
 8003ce0:	bfd4      	ite	le
 8003ce2:	2301      	movle	r3, #1
 8003ce4:	2300      	movgt	r3, #0
 8003ce6:	b2db      	uxtb	r3, r3
 8003ce8:	2b00      	cmp	r3, #0
 8003cea:	d109      	bne.n	8003d00 <__dbg_check_lock_from_isr+0x30>
 8003cec:	9b01      	ldr	r3, [sp, #4]
 8003cee:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003cf2:	2b00      	cmp	r3, #0
 8003cf4:	bf14      	ite	ne
 8003cf6:	2301      	movne	r3, #1
 8003cf8:	2300      	moveq	r3, #0
 8003cfa:	b2db      	uxtb	r3, r3
 8003cfc:	2b00      	cmp	r3, #0
 8003cfe:	d002      	beq.n	8003d06 <__dbg_check_lock_from_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 8003d00:	4806      	ldr	r0, [pc, #24]	@ (8003d1c <__dbg_check_lock_from_isr+0x4c>)
 8003d02:	f7ff ff0d 	bl	8003b20 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8003d06:	9b01      	ldr	r3, [sp, #4]
 8003d08:	2201      	movs	r2, #1
 8003d0a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 8003d0e:	bf00      	nop
 8003d10:	b003      	add	sp, #12
 8003d12:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d16:	bf00      	nop
 8003d18:	24000158 	.word	0x24000158
 8003d1c:	08006e90 	.word	0x08006e90

08003d20 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 8003d20:	b500      	push	{lr}
 8003d22:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003d24:	4b10      	ldr	r3, [pc, #64]	@ (8003d68 <__dbg_check_unlock_from_isr+0x48>)
 8003d26:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8003d28:	9b01      	ldr	r3, [sp, #4]
 8003d2a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003d2e:	2b00      	cmp	r3, #0
 8003d30:	bfd4      	ite	le
 8003d32:	2301      	movle	r3, #1
 8003d34:	2300      	movgt	r3, #0
 8003d36:	b2db      	uxtb	r3, r3
 8003d38:	2b00      	cmp	r3, #0
 8003d3a:	d109      	bne.n	8003d50 <__dbg_check_unlock_from_isr+0x30>
 8003d3c:	9b01      	ldr	r3, [sp, #4]
 8003d3e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003d42:	2b00      	cmp	r3, #0
 8003d44:	bfd4      	ite	le
 8003d46:	2301      	movle	r3, #1
 8003d48:	2300      	movgt	r3, #0
 8003d4a:	b2db      	uxtb	r3, r3
 8003d4c:	2b00      	cmp	r3, #0
 8003d4e:	d002      	beq.n	8003d56 <__dbg_check_unlock_from_isr+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 8003d50:	4806      	ldr	r0, [pc, #24]	@ (8003d6c <__dbg_check_unlock_from_isr+0x4c>)
 8003d52:	f7ff fee5 	bl	8003b20 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8003d56:	9b01      	ldr	r3, [sp, #4]
 8003d58:	2200      	movs	r2, #0
 8003d5a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
}
 8003d5e:	bf00      	nop
 8003d60:	b003      	add	sp, #12
 8003d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d66:	bf00      	nop
 8003d68:	24000158 	.word	0x24000158
 8003d6c:	08006e98 	.word	0x08006e98

08003d70 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 8003d70:	b500      	push	{lr}
 8003d72:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8003d74:	4b18      	ldr	r3, [pc, #96]	@ (8003dd8 <__dbg_check_enter_isr+0x68>)
 8003d76:	9303      	str	r3, [sp, #12]
 8003d78:	2330      	movs	r3, #48	@ 0x30
 8003d7a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003d7c:	9b02      	ldr	r3, [sp, #8]
 8003d7e:	f383 8811 	msr	BASEPRI, r3
}
 8003d82:	bf00      	nop
}
 8003d84:	bf00      	nop
}
 8003d86:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8003d88:	9b03      	ldr	r3, [sp, #12]
 8003d8a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003d8e:	0fdb      	lsrs	r3, r3, #31
 8003d90:	b2db      	uxtb	r3, r3
 8003d92:	2b00      	cmp	r3, #0
 8003d94:	d109      	bne.n	8003daa <__dbg_check_enter_isr+0x3a>
 8003d96:	9b03      	ldr	r3, [sp, #12]
 8003d98:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003d9c:	2b00      	cmp	r3, #0
 8003d9e:	bf14      	ite	ne
 8003da0:	2301      	movne	r3, #1
 8003da2:	2300      	moveq	r3, #0
 8003da4:	b2db      	uxtb	r3, r3
 8003da6:	2b00      	cmp	r3, #0
 8003da8:	d002      	beq.n	8003db0 <__dbg_check_enter_isr+0x40>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 8003daa:	480c      	ldr	r0, [pc, #48]	@ (8003ddc <__dbg_check_enter_isr+0x6c>)
 8003dac:	f7ff feb8 	bl	8003b20 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 8003db0:	9b03      	ldr	r3, [sp, #12]
 8003db2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003db6:	1c5a      	adds	r2, r3, #1
 8003db8:	9b03      	ldr	r3, [sp, #12]
 8003dba:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8003dbe:	2300      	movs	r3, #0
 8003dc0:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003dc2:	9b01      	ldr	r3, [sp, #4]
 8003dc4:	f383 8811 	msr	BASEPRI, r3
}
 8003dc8:	bf00      	nop
}
 8003dca:	bf00      	nop
}
 8003dcc:	bf00      	nop
  port_unlock_from_isr();
}
 8003dce:	bf00      	nop
 8003dd0:	b005      	add	sp, #20
 8003dd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dd6:	bf00      	nop
 8003dd8:	24000158 	.word	0x24000158
 8003ddc:	08006ea0 	.word	0x08006ea0

08003de0 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 8003de0:	b500      	push	{lr}
 8003de2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8003de4:	4b19      	ldr	r3, [pc, #100]	@ (8003e4c <__dbg_check_leave_isr+0x6c>)
 8003de6:	9303      	str	r3, [sp, #12]
 8003de8:	2330      	movs	r3, #48	@ 0x30
 8003dea:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003dec:	9b02      	ldr	r3, [sp, #8]
 8003dee:	f383 8811 	msr	BASEPRI, r3
}
 8003df2:	bf00      	nop
}
 8003df4:	bf00      	nop
}
 8003df6:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8003df8:	9b03      	ldr	r3, [sp, #12]
 8003dfa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003dfe:	2b00      	cmp	r3, #0
 8003e00:	bfd4      	ite	le
 8003e02:	2301      	movle	r3, #1
 8003e04:	2300      	movgt	r3, #0
 8003e06:	b2db      	uxtb	r3, r3
 8003e08:	2b00      	cmp	r3, #0
 8003e0a:	d109      	bne.n	8003e20 <__dbg_check_leave_isr+0x40>
 8003e0c:	9b03      	ldr	r3, [sp, #12]
 8003e0e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003e12:	2b00      	cmp	r3, #0
 8003e14:	bf14      	ite	ne
 8003e16:	2301      	movne	r3, #1
 8003e18:	2300      	moveq	r3, #0
 8003e1a:	b2db      	uxtb	r3, r3
 8003e1c:	2b00      	cmp	r3, #0
 8003e1e:	d002      	beq.n	8003e26 <__dbg_check_leave_isr+0x46>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 8003e20:	480b      	ldr	r0, [pc, #44]	@ (8003e50 <__dbg_check_leave_isr+0x70>)
 8003e22:	f7ff fe7d 	bl	8003b20 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 8003e26:	9b03      	ldr	r3, [sp, #12]
 8003e28:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003e2c:	1e5a      	subs	r2, r3, #1
 8003e2e:	9b03      	ldr	r3, [sp, #12]
 8003e30:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 8003e34:	2300      	movs	r3, #0
 8003e36:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003e38:	9b01      	ldr	r3, [sp, #4]
 8003e3a:	f383 8811 	msr	BASEPRI, r3
}
 8003e3e:	bf00      	nop
}
 8003e40:	bf00      	nop
}
 8003e42:	bf00      	nop
  port_unlock_from_isr();
}
 8003e44:	bf00      	nop
 8003e46:	b005      	add	sp, #20
 8003e48:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e4c:	24000158 	.word	0x24000158
 8003e50:	08006ea8 	.word	0x08006ea8
	...

08003e60 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8003e60:	b500      	push	{lr}
 8003e62:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003e64:	4b0c      	ldr	r3, [pc, #48]	@ (8003e98 <chDbgCheckClassI+0x38>)
 8003e66:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8003e68:	9b01      	ldr	r3, [sp, #4]
 8003e6a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003e6e:	0fdb      	lsrs	r3, r3, #31
 8003e70:	b2db      	uxtb	r3, r3
 8003e72:	2b00      	cmp	r3, #0
 8003e74:	d109      	bne.n	8003e8a <chDbgCheckClassI+0x2a>
 8003e76:	9b01      	ldr	r3, [sp, #4]
 8003e78:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003e7c:	2b00      	cmp	r3, #0
 8003e7e:	bfd4      	ite	le
 8003e80:	2301      	movle	r3, #1
 8003e82:	2300      	movgt	r3, #0
 8003e84:	b2db      	uxtb	r3, r3
 8003e86:	2b00      	cmp	r3, #0
 8003e88:	d002      	beq.n	8003e90 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 8003e8a:	4804      	ldr	r0, [pc, #16]	@ (8003e9c <chDbgCheckClassI+0x3c>)
 8003e8c:	f7ff fe48 	bl	8003b20 <chSysHalt>
  }
}
 8003e90:	bf00      	nop
 8003e92:	b003      	add	sp, #12
 8003e94:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e98:	24000158 	.word	0x24000158
 8003e9c:	08006eb0 	.word	0x08006eb0

08003ea0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8003ea0:	b500      	push	{lr}
 8003ea2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8003ea4:	4b0e      	ldr	r3, [pc, #56]	@ (8003ee0 <chDbgCheckClassS+0x40>)
 8003ea6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8003ea8:	9b01      	ldr	r3, [sp, #4]
 8003eaa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003eae:	2b00      	cmp	r3, #0
 8003eb0:	bf14      	ite	ne
 8003eb2:	2301      	movne	r3, #1
 8003eb4:	2300      	moveq	r3, #0
 8003eb6:	b2db      	uxtb	r3, r3
 8003eb8:	2b00      	cmp	r3, #0
 8003eba:	d109      	bne.n	8003ed0 <chDbgCheckClassS+0x30>
 8003ebc:	9b01      	ldr	r3, [sp, #4]
 8003ebe:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003ec2:	2b00      	cmp	r3, #0
 8003ec4:	bfd4      	ite	le
 8003ec6:	2301      	movle	r3, #1
 8003ec8:	2300      	movgt	r3, #0
 8003eca:	b2db      	uxtb	r3, r3
 8003ecc:	2b00      	cmp	r3, #0
 8003ece:	d002      	beq.n	8003ed6 <chDbgCheckClassS+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 8003ed0:	4804      	ldr	r0, [pc, #16]	@ (8003ee4 <chDbgCheckClassS+0x44>)
 8003ed2:	f7ff fe25 	bl	8003b20 <chSysHalt>
  }
}
 8003ed6:	bf00      	nop
 8003ed8:	b003      	add	sp, #12
 8003eda:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ede:	bf00      	nop
 8003ee0:	24000158 	.word	0x24000158
 8003ee4:	08006eb8 	.word	0x08006eb8
	...

08003ef0 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8003ef0:	b508      	push	{r3, lr}

  return stGetCounter();
 8003ef2:	f7fc fbfd 	bl	80006f0 <stGetCounter>
 8003ef6:	4603      	mov	r3, r0
}
 8003ef8:	4618      	mov	r0, r3
 8003efa:	bd08      	pop	{r3, pc}
 8003efc:	0000      	movs	r0, r0
	...

08003f00 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8003f00:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8003f02:	f7ff fff5 	bl	8003ef0 <port_timer_get_time.lto_priv.0>
 8003f06:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003f08:	4618      	mov	r0, r3
 8003f0a:	bd08      	pop	{r3, pc}
 8003f0c:	0000      	movs	r0, r0
	...

08003f10 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {
 8003f10:	b510      	push	{r4, lr}
 8003f12:	b082      	sub	sp, #8
 8003f14:	9001      	str	r0, [sp, #4]

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8003f16:	9b01      	ldr	r3, [sp, #4]
 8003f18:	f8d3 4094 	ldr.w	r4, [r3, #148]	@ 0x94
 8003f1c:	f7ff fff0 	bl	8003f00 <chVTGetSystemTimeX.lto_priv.0>
 8003f20:	4603      	mov	r3, r0
 8003f22:	6063      	str	r3, [r4, #4]
  return DWT->CYCCNT;
 8003f24:	4b11      	ldr	r3, [pc, #68]	@ (8003f6c <trace_next+0x5c>)
 8003f26:	685b      	ldr	r3, [r3, #4]
#if PORT_SUPPORTS_RT == TRUE
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8003f28:	9a01      	ldr	r2, [sp, #4]
 8003f2a:	f8d2 2094 	ldr.w	r2, [r2, #148]	@ 0x94
 8003f2e:	f023 417f 	bic.w	r1, r3, #4278190080	@ 0xff000000
 8003f32:	6813      	ldr	r3, [r2, #0]
 8003f34:	f361 231f 	bfi	r3, r1, #8, #24
 8003f38:	6013      	str	r3, [r2, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8003f3a:	9b01      	ldr	r3, [sp, #4]
 8003f3c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8003f40:	f103 0210 	add.w	r2, r3, #16
 8003f44:	9b01      	ldr	r3, [sp, #4]
 8003f46:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
 8003f4a:	9b01      	ldr	r3, [sp, #4]
 8003f4c:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8003f50:	9b01      	ldr	r3, [sp, #4]
 8003f52:	f603 0398 	addw	r3, r3, #2200	@ 0x898
 8003f56:	429a      	cmp	r2, r3
 8003f58:	d305      	bcc.n	8003f66 <trace_next+0x56>
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8003f5a:	9b01      	ldr	r3, [sp, #4]
 8003f5c:	f103 0298 	add.w	r2, r3, #152	@ 0x98
 8003f60:	9b01      	ldr	r3, [sp, #4]
 8003f62:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  }
}
 8003f66:	bf00      	nop
 8003f68:	b002      	add	sp, #8
 8003f6a:	bd10      	pop	{r4, pc}
 8003f6c:	e0001000 	.word	0xe0001000

08003f70 <__trace_object_init>:
 *
 * @param[out] tbp      pointer to the @p trace_buffer_t structure
 *
 * @notapi
 */
void __trace_object_init(trace_buffer_t *tbp) {
 8003f70:	b084      	sub	sp, #16
 8003f72:	9001      	str	r0, [sp, #4]
  unsigned i;

  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8003f74:	9b01      	ldr	r3, [sp, #4]
 8003f76:	f64f 72e0 	movw	r2, #65504	@ 0xffe0
 8003f7a:	801a      	strh	r2, [r3, #0]
  tbp->size      = CH_DBG_TRACE_BUFFER_SIZE;
 8003f7c:	9b01      	ldr	r3, [sp, #4]
 8003f7e:	2280      	movs	r2, #128	@ 0x80
 8003f80:	805a      	strh	r2, [r3, #2]
  tbp->ptr       = &tbp->buffer[0];
 8003f82:	9b01      	ldr	r3, [sp, #4]
 8003f84:	f103 0208 	add.w	r2, r3, #8
 8003f88:	9b01      	ldr	r3, [sp, #4]
 8003f8a:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8003f8c:	2300      	movs	r3, #0
 8003f8e:	9303      	str	r3, [sp, #12]
 8003f90:	e00c      	b.n	8003fac <__trace_object_init+0x3c>
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8003f92:	9a01      	ldr	r2, [sp, #4]
 8003f94:	9b03      	ldr	r3, [sp, #12]
 8003f96:	011b      	lsls	r3, r3, #4
 8003f98:	4413      	add	r3, r2
 8003f9a:	f103 0208 	add.w	r2, r3, #8
 8003f9e:	7813      	ldrb	r3, [r2, #0]
 8003fa0:	f023 0307 	bic.w	r3, r3, #7
 8003fa4:	7013      	strb	r3, [r2, #0]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8003fa6:	9b03      	ldr	r3, [sp, #12]
 8003fa8:	3301      	adds	r3, #1
 8003faa:	9303      	str	r3, [sp, #12]
 8003fac:	9b03      	ldr	r3, [sp, #12]
 8003fae:	2b7f      	cmp	r3, #127	@ 0x7f
 8003fb0:	d9ef      	bls.n	8003f92 <__trace_object_init+0x22>
  }
}
 8003fb2:	bf00      	nop
 8003fb4:	bf00      	nop
 8003fb6:	b004      	add	sp, #16
 8003fb8:	4770      	bx	lr
 8003fba:	bf00      	nop
 8003fbc:	0000      	movs	r0, r0
	...

08003fc0 <__trace_ready>:
 * @param[in] tp        the thread that just become ready
 * @param[in] msg       the thread ready message
 *
 * @notapi
 */
void __trace_ready(thread_t *tp, msg_t msg) {
 8003fc0:	b500      	push	{lr}
 8003fc2:	b085      	sub	sp, #20
 8003fc4:	9001      	str	r0, [sp, #4]
 8003fc6:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8003fc8:	4b17      	ldr	r3, [pc, #92]	@ (8004028 <__trace_ready+0x68>)
 8003fca:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 8003fcc:	9b03      	ldr	r3, [sp, #12]
 8003fce:	f8b3 3090 	ldrh.w	r3, [r3, #144]	@ 0x90
 8003fd2:	f003 0301 	and.w	r3, r3, #1
 8003fd6:	2b00      	cmp	r3, #0
 8003fd8:	d122      	bne.n	8004020 <__trace_ready+0x60>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8003fda:	9b03      	ldr	r3, [sp, #12]
 8003fdc:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8003fe0:	7813      	ldrb	r3, [r2, #0]
 8003fe2:	2101      	movs	r1, #1
 8003fe4:	f361 0302 	bfi	r3, r1, #0, #3
 8003fe8:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)tp->state;
 8003fea:	9b01      	ldr	r3, [sp, #4]
 8003fec:	f893 1024 	ldrb.w	r1, [r3, #36]	@ 0x24
 8003ff0:	9b03      	ldr	r3, [sp, #12]
 8003ff2:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8003ff6:	460b      	mov	r3, r1
 8003ff8:	f003 031f 	and.w	r3, r3, #31
 8003ffc:	b2d9      	uxtb	r1, r3
 8003ffe:	7813      	ldrb	r3, [r2, #0]
 8004000:	f361 03c7 	bfi	r3, r1, #3, #5
 8004004:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.rdy.tp    = tp;
 8004006:	9b03      	ldr	r3, [sp, #12]
 8004008:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800400c:	9a01      	ldr	r2, [sp, #4]
 800400e:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8004010:	9b03      	ldr	r3, [sp, #12]
 8004012:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8004016:	9a00      	ldr	r2, [sp, #0]
 8004018:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 800401a:	9803      	ldr	r0, [sp, #12]
 800401c:	f7ff ff78 	bl	8003f10 <trace_next>
  }
}
 8004020:	bf00      	nop
 8004022:	b005      	add	sp, #20
 8004024:	f85d fb04 	ldr.w	pc, [sp], #4
 8004028:	24000158 	.word	0x24000158
 800402c:	00000000 	.word	0x00000000

08004030 <__trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void __trace_switch(thread_t *ntp, thread_t *otp) {
 8004030:	b500      	push	{lr}
 8004032:	b085      	sub	sp, #20
 8004034:	9001      	str	r0, [sp, #4]
 8004036:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8004038:	4b18      	ldr	r3, [pc, #96]	@ (800409c <__trace_switch+0x6c>)
 800403a:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800403c:	9b03      	ldr	r3, [sp, #12]
 800403e:	f8b3 3090 	ldrh.w	r3, [r3, #144]	@ 0x90
 8004042:	f003 0302 	and.w	r3, r3, #2
 8004046:	2b00      	cmp	r3, #0
 8004048:	d123      	bne.n	8004092 <__trace_switch+0x62>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800404a:	9b03      	ldr	r3, [sp, #12]
 800404c:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8004050:	7813      	ldrb	r3, [r2, #0]
 8004052:	2102      	movs	r1, #2
 8004054:	f361 0302 	bfi	r3, r1, #0, #3
 8004058:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)otp->state;
 800405a:	9b00      	ldr	r3, [sp, #0]
 800405c:	f893 1024 	ldrb.w	r1, [r3, #36]	@ 0x24
 8004060:	9b03      	ldr	r3, [sp, #12]
 8004062:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8004066:	460b      	mov	r3, r1
 8004068:	f003 031f 	and.w	r3, r3, #31
 800406c:	b2d9      	uxtb	r1, r3
 800406e:	7813      	ldrb	r3, [r2, #0]
 8004070:	f361 03c7 	bfi	r3, r1, #3, #5
 8004074:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
 8004076:	9b03      	ldr	r3, [sp, #12]
 8004078:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800407c:	9a01      	ldr	r2, [sp, #4]
 800407e:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8004080:	9b03      	ldr	r3, [sp, #12]
 8004082:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8004086:	9a00      	ldr	r2, [sp, #0]
 8004088:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 800408a:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 800408c:	9803      	ldr	r0, [sp, #12]
 800408e:	f7ff ff3f 	bl	8003f10 <trace_next>
  }
}
 8004092:	bf00      	nop
 8004094:	b005      	add	sp, #20
 8004096:	f85d fb04 	ldr.w	pc, [sp], #4
 800409a:	bf00      	nop
 800409c:	24000158 	.word	0x24000158

080040a0 <__trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_enter(const char *isr) {
 80040a0:	b500      	push	{lr}
 80040a2:	b087      	sub	sp, #28
 80040a4:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 80040a6:	4b1a      	ldr	r3, [pc, #104]	@ (8004110 <__trace_isr_enter+0x70>)
 80040a8:	9305      	str	r3, [sp, #20]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80040aa:	9b05      	ldr	r3, [sp, #20]
 80040ac:	f8b3 3090 	ldrh.w	r3, [r3, #144]	@ 0x90
 80040b0:	f003 0304 	and.w	r3, r3, #4
 80040b4:	2b00      	cmp	r3, #0
 80040b6:	d126      	bne.n	8004106 <__trace_isr_enter+0x66>
 80040b8:	2330      	movs	r3, #48	@ 0x30
 80040ba:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80040bc:	9b03      	ldr	r3, [sp, #12]
 80040be:	f383 8811 	msr	BASEPRI, r3
}
 80040c2:	bf00      	nop
}
 80040c4:	bf00      	nop
}
 80040c6:	bf00      	nop
    port_lock_from_isr();
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80040c8:	9b05      	ldr	r3, [sp, #20]
 80040ca:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 80040ce:	7813      	ldrb	r3, [r2, #0]
 80040d0:	2103      	movs	r1, #3
 80040d2:	f361 0302 	bfi	r3, r1, #0, #3
 80040d6:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = 0U;
 80040d8:	9b05      	ldr	r3, [sp, #20]
 80040da:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 80040de:	7813      	ldrb	r3, [r2, #0]
 80040e0:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 80040e4:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80040e6:	9b05      	ldr	r3, [sp, #20]
 80040e8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80040ec:	9a01      	ldr	r2, [sp, #4]
 80040ee:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80040f0:	9805      	ldr	r0, [sp, #20]
 80040f2:	f7ff ff0d 	bl	8003f10 <trace_next>
 80040f6:	2300      	movs	r3, #0
 80040f8:	9304      	str	r3, [sp, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80040fa:	9b04      	ldr	r3, [sp, #16]
 80040fc:	f383 8811 	msr	BASEPRI, r3
}
 8004100:	bf00      	nop
}
 8004102:	bf00      	nop
}
 8004104:	bf00      	nop
    port_unlock_from_isr();
  }
}
 8004106:	bf00      	nop
 8004108:	b007      	add	sp, #28
 800410a:	f85d fb04 	ldr.w	pc, [sp], #4
 800410e:	bf00      	nop
 8004110:	24000158 	.word	0x24000158
	...

08004120 <__trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_leave(const char *isr) {
 8004120:	b500      	push	{lr}
 8004122:	b087      	sub	sp, #28
 8004124:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 8004126:	4b1a      	ldr	r3, [pc, #104]	@ (8004190 <__trace_isr_leave+0x70>)
 8004128:	9305      	str	r3, [sp, #20]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800412a:	9b05      	ldr	r3, [sp, #20]
 800412c:	f8b3 3090 	ldrh.w	r3, [r3, #144]	@ 0x90
 8004130:	f003 0304 	and.w	r3, r3, #4
 8004134:	2b00      	cmp	r3, #0
 8004136:	d126      	bne.n	8004186 <__trace_isr_leave+0x66>
 8004138:	2330      	movs	r3, #48	@ 0x30
 800413a:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800413c:	9b03      	ldr	r3, [sp, #12]
 800413e:	f383 8811 	msr	BASEPRI, r3
}
 8004142:	bf00      	nop
}
 8004144:	bf00      	nop
}
 8004146:	bf00      	nop
    port_lock_from_isr();
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004148:	9b05      	ldr	r3, [sp, #20]
 800414a:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 800414e:	7813      	ldrb	r3, [r2, #0]
 8004150:	2104      	movs	r1, #4
 8004152:	f361 0302 	bfi	r3, r1, #0, #3
 8004156:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = 0U;
 8004158:	9b05      	ldr	r3, [sp, #20]
 800415a:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 800415e:	7813      	ldrb	r3, [r2, #0]
 8004160:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8004164:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004166:	9b05      	ldr	r3, [sp, #20]
 8004168:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800416c:	9a01      	ldr	r2, [sp, #4]
 800416e:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004170:	9805      	ldr	r0, [sp, #20]
 8004172:	f7ff fecd 	bl	8003f10 <trace_next>
 8004176:	2300      	movs	r3, #0
 8004178:	9304      	str	r3, [sp, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800417a:	9b04      	ldr	r3, [sp, #16]
 800417c:	f383 8811 	msr	BASEPRI, r3
}
 8004180:	bf00      	nop
}
 8004182:	bf00      	nop
}
 8004184:	bf00      	nop
    port_unlock_from_isr();
  }
}
 8004186:	bf00      	nop
 8004188:	b007      	add	sp, #28
 800418a:	f85d fb04 	ldr.w	pc, [sp], #4
 800418e:	bf00      	nop
 8004190:	24000158 	.word	0x24000158
	...

080041a0 <__trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void __trace_halt(const char *reason) {
 80041a0:	b500      	push	{lr}
 80041a2:	b085      	sub	sp, #20
 80041a4:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 80041a6:	4b12      	ldr	r3, [pc, #72]	@ (80041f0 <__trace_halt+0x50>)
 80041a8:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 80041aa:	9b03      	ldr	r3, [sp, #12]
 80041ac:	f8b3 3090 	ldrh.w	r3, [r3, #144]	@ 0x90
 80041b0:	f003 0308 	and.w	r3, r3, #8
 80041b4:	2b00      	cmp	r3, #0
 80041b6:	d116      	bne.n	80041e6 <__trace_halt+0x46>
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 80041b8:	9b03      	ldr	r3, [sp, #12]
 80041ba:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 80041be:	7813      	ldrb	r3, [r2, #0]
 80041c0:	2105      	movs	r1, #5
 80041c2:	f361 0302 	bfi	r3, r1, #0, #3
 80041c6:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state         = 0;
 80041c8:	9b03      	ldr	r3, [sp, #12]
 80041ca:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 80041ce:	7813      	ldrb	r3, [r2, #0]
 80041d0:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 80041d4:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.halt.reason = reason;
 80041d6:	9b03      	ldr	r3, [sp, #12]
 80041d8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80041dc:	9a01      	ldr	r2, [sp, #4]
 80041de:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80041e0:	9803      	ldr	r0, [sp, #12]
 80041e2:	f7ff fe95 	bl	8003f10 <trace_next>
  }
}
 80041e6:	bf00      	nop
 80041e8:	b005      	add	sp, #20
 80041ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80041ee:	bf00      	nop
 80041f0:	24000158 	.word	0x24000158
	...

08004200 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8004200:	b082      	sub	sp, #8
 8004202:	9001      	str	r0, [sp, #4]
 8004204:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8004206:	9a01      	ldr	r2, [sp, #4]
 8004208:	9b00      	ldr	r3, [sp, #0]
 800420a:	4413      	add	r3, r2
}
 800420c:	4618      	mov	r0, r3
 800420e:	b002      	add	sp, #8
 8004210:	4770      	bx	lr
 8004212:	bf00      	nop
	...

08004220 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8004220:	b082      	sub	sp, #8
 8004222:	9001      	str	r0, [sp, #4]
 8004224:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8004226:	9a00      	ldr	r2, [sp, #0]
 8004228:	9b01      	ldr	r3, [sp, #4]
 800422a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 800422c:	4618      	mov	r0, r3
 800422e:	b002      	add	sp, #8
 8004230:	4770      	bx	lr
 8004232:	bf00      	nop
	...

08004240 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8004240:	b082      	sub	sp, #8
 8004242:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8004244:	9b01      	ldr	r3, [sp, #4]
 8004246:	681b      	ldr	r3, [r3, #0]
 8004248:	9a01      	ldr	r2, [sp, #4]
 800424a:	429a      	cmp	r2, r3
 800424c:	bf0c      	ite	eq
 800424e:	2301      	moveq	r3, #1
 8004250:	2300      	movne	r3, #0
 8004252:	b2db      	uxtb	r3, r3
}
 8004254:	4618      	mov	r0, r3
 8004256:	b002      	add	sp, #8
 8004258:	4770      	bx	lr
 800425a:	bf00      	nop
 800425c:	0000      	movs	r0, r0
	...

08004260 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8004260:	b082      	sub	sp, #8
 8004262:	9001      	str	r0, [sp, #4]
 8004264:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8004266:	9b01      	ldr	r3, [sp, #4]
 8004268:	681b      	ldr	r3, [r3, #0]
 800426a:	9a00      	ldr	r2, [sp, #0]
 800426c:	429a      	cmp	r2, r3
 800426e:	bf0c      	ite	eq
 8004270:	2301      	moveq	r3, #1
 8004272:	2300      	movne	r3, #0
 8004274:	b2db      	uxtb	r3, r3
}
 8004276:	4618      	mov	r0, r3
 8004278:	b002      	add	sp, #8
 800427a:	4770      	bx	lr
 800427c:	0000      	movs	r0, r0
	...

08004280 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 8004280:	b084      	sub	sp, #16
 8004282:	9003      	str	r0, [sp, #12]
 8004284:	9102      	str	r1, [sp, #8]
 8004286:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8004288:	9b02      	ldr	r3, [sp, #8]
 800428a:	9a01      	ldr	r2, [sp, #4]
 800428c:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 800428e:	9b02      	ldr	r3, [sp, #8]
 8004290:	9a03      	ldr	r2, [sp, #12]
 8004292:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8004294:	9b02      	ldr	r3, [sp, #8]
 8004296:	685b      	ldr	r3, [r3, #4]
 8004298:	681a      	ldr	r2, [r3, #0]
 800429a:	9b02      	ldr	r3, [sp, #8]
 800429c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 800429e:	9b02      	ldr	r3, [sp, #8]
 80042a0:	681b      	ldr	r3, [r3, #0]
 80042a2:	9a02      	ldr	r2, [sp, #8]
 80042a4:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 80042a6:	9b03      	ldr	r3, [sp, #12]
 80042a8:	9a02      	ldr	r2, [sp, #8]
 80042aa:	601a      	str	r2, [r3, #0]
}
 80042ac:	bf00      	nop
 80042ae:	b004      	add	sp, #16
 80042b0:	4770      	bx	lr
 80042b2:	bf00      	nop
	...

080042c0 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 80042c0:	b084      	sub	sp, #16
 80042c2:	9003      	str	r0, [sp, #12]
 80042c4:	9102      	str	r1, [sp, #8]
 80042c6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 80042c8:	9b02      	ldr	r3, [sp, #8]
 80042ca:	9a01      	ldr	r2, [sp, #4]
 80042cc:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 80042ce:	9b02      	ldr	r3, [sp, #8]
 80042d0:	9a03      	ldr	r2, [sp, #12]
 80042d2:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 80042d4:	9b02      	ldr	r3, [sp, #8]
 80042d6:	681b      	ldr	r3, [r3, #0]
 80042d8:	685a      	ldr	r2, [r3, #4]
 80042da:	9b02      	ldr	r3, [sp, #8]
 80042dc:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 80042de:	9b02      	ldr	r3, [sp, #8]
 80042e0:	685b      	ldr	r3, [r3, #4]
 80042e2:	9a02      	ldr	r2, [sp, #8]
 80042e4:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 80042e6:	9b03      	ldr	r3, [sp, #12]
 80042e8:	9a02      	ldr	r2, [sp, #8]
 80042ea:	605a      	str	r2, [r3, #4]
}
 80042ec:	bf00      	nop
 80042ee:	b004      	add	sp, #16
 80042f0:	4770      	bx	lr
 80042f2:	bf00      	nop
	...

08004300 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8004300:	b500      	push	{lr}
 8004302:	b087      	sub	sp, #28
 8004304:	9003      	str	r0, [sp, #12]
 8004306:	9102      	str	r1, [sp, #8]
 8004308:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 800430a:	9b03      	ldr	r3, [sp, #12]
 800430c:	681b      	ldr	r3, [r3, #0]
 800430e:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8004310:	e013      	b.n	800433a <ch_dlist_insert+0x3a>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8004312:	9a05      	ldr	r2, [sp, #20]
 8004314:	9b02      	ldr	r3, [sp, #8]
 8004316:	429a      	cmp	r2, r3
 8004318:	bf0c      	ite	eq
 800431a:	2301      	moveq	r3, #1
 800431c:	2300      	movne	r3, #0
 800431e:	b2db      	uxtb	r3, r3
 8004320:	2b00      	cmp	r3, #0
 8004322:	d002      	beq.n	800432a <ch_dlist_insert+0x2a>
 8004324:	4813      	ldr	r0, [pc, #76]	@ (8004374 <ch_dlist_insert+0x74>)
 8004326:	f7ff fbfb 	bl	8003b20 <chSysHalt>

    delta -= dlp->delta;
 800432a:	9b05      	ldr	r3, [sp, #20]
 800432c:	689b      	ldr	r3, [r3, #8]
 800432e:	9a01      	ldr	r2, [sp, #4]
 8004330:	1ad3      	subs	r3, r2, r3
 8004332:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 8004334:	9b05      	ldr	r3, [sp, #20]
 8004336:	681b      	ldr	r3, [r3, #0]
 8004338:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 800433a:	9b05      	ldr	r3, [sp, #20]
 800433c:	689b      	ldr	r3, [r3, #8]
 800433e:	9a01      	ldr	r2, [sp, #4]
 8004340:	429a      	cmp	r2, r3
 8004342:	bf8c      	ite	hi
 8004344:	2301      	movhi	r3, #1
 8004346:	2300      	movls	r3, #0
 8004348:	b2db      	uxtb	r3, r3
 800434a:	2b00      	cmp	r3, #0
 800434c:	d1e1      	bne.n	8004312 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 800434e:	9a01      	ldr	r2, [sp, #4]
 8004350:	9902      	ldr	r1, [sp, #8]
 8004352:	9805      	ldr	r0, [sp, #20]
 8004354:	f7ff ffb4 	bl	80042c0 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8004358:	9b05      	ldr	r3, [sp, #20]
 800435a:	689a      	ldr	r2, [r3, #8]
 800435c:	9b01      	ldr	r3, [sp, #4]
 800435e:	1ad2      	subs	r2, r2, r3
 8004360:	9b05      	ldr	r3, [sp, #20]
 8004362:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8004364:	9b03      	ldr	r3, [sp, #12]
 8004366:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800436a:	609a      	str	r2, [r3, #8]
}
 800436c:	bf00      	nop
 800436e:	b007      	add	sp, #28
 8004370:	f85d fb04 	ldr.w	pc, [sp], #4
 8004374:	08006f28 	.word	0x08006f28
	...

08004380 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8004380:	b084      	sub	sp, #16
 8004382:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8004384:	9b01      	ldr	r3, [sp, #4]
 8004386:	681b      	ldr	r3, [r3, #0]
 8004388:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 800438a:	9b03      	ldr	r3, [sp, #12]
 800438c:	681a      	ldr	r2, [r3, #0]
 800438e:	9b01      	ldr	r3, [sp, #4]
 8004390:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8004392:	9b01      	ldr	r3, [sp, #4]
 8004394:	681b      	ldr	r3, [r3, #0]
 8004396:	9a01      	ldr	r2, [sp, #4]
 8004398:	605a      	str	r2, [r3, #4]

  return dlp;
 800439a:	9b03      	ldr	r3, [sp, #12]
}
 800439c:	4618      	mov	r0, r3
 800439e:	b004      	add	sp, #16
 80043a0:	4770      	bx	lr
 80043a2:	bf00      	nop
	...

080043b0 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 80043b0:	b082      	sub	sp, #8
 80043b2:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 80043b4:	9b01      	ldr	r3, [sp, #4]
 80043b6:	685b      	ldr	r3, [r3, #4]
 80043b8:	9a01      	ldr	r2, [sp, #4]
 80043ba:	6812      	ldr	r2, [r2, #0]
 80043bc:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 80043be:	9b01      	ldr	r3, [sp, #4]
 80043c0:	681b      	ldr	r3, [r3, #0]
 80043c2:	9a01      	ldr	r2, [sp, #4]
 80043c4:	6852      	ldr	r2, [r2, #4]
 80043c6:	605a      	str	r2, [r3, #4]

  return dlp;
 80043c8:	9b01      	ldr	r3, [sp, #4]
}
 80043ca:	4618      	mov	r0, r3
 80043cc:	b002      	add	sp, #8
 80043ce:	4770      	bx	lr

080043d0 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 80043d0:	b500      	push	{lr}
 80043d2:	b083      	sub	sp, #12
 80043d4:	9001      	str	r0, [sp, #4]
  stStartAlarm(time);
 80043d6:	9801      	ldr	r0, [sp, #4]
 80043d8:	f7fc f992 	bl	8000700 <stStartAlarm>
}
 80043dc:	bf00      	nop
 80043de:	b003      	add	sp, #12
 80043e0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080043f0 <port_timer_stop_alarm>:
static inline void port_timer_stop_alarm(void) {
 80043f0:	b508      	push	{r3, lr}
  stStopAlarm();
 80043f2:	f7fc f99d 	bl	8000730 <stStopAlarm>
}
 80043f6:	bf00      	nop
 80043f8:	bd08      	pop	{r3, pc}
 80043fa:	bf00      	nop
 80043fc:	0000      	movs	r0, r0
	...

08004400 <port_timer_set_alarm>:
static inline void port_timer_set_alarm(systime_t time) {
 8004400:	b500      	push	{lr}
 8004402:	b083      	sub	sp, #12
 8004404:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 8004406:	9801      	ldr	r0, [sp, #4]
 8004408:	f7fc f99a 	bl	8000740 <stSetAlarm>
}
 800440c:	bf00      	nop
 800440e:	b003      	add	sp, #12
 8004410:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004420 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 8004420:	b508      	push	{r3, lr}
  return stGetCounter();
 8004422:	f7fc f965 	bl	80006f0 <stGetCounter>
 8004426:	4603      	mov	r3, r0
}
 8004428:	4618      	mov	r0, r3
 800442a:	bd08      	pop	{r3, pc}
 800442c:	0000      	movs	r0, r0
	...

08004430 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 8004430:	b500      	push	{lr}
 8004432:	b083      	sub	sp, #12
 8004434:	2330      	movs	r3, #48	@ 0x30
 8004436:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004438:	9b01      	ldr	r3, [sp, #4]
 800443a:	f383 8811 	msr	BASEPRI, r3
}
 800443e:	bf00      	nop
}
 8004440:	bf00      	nop
}
 8004442:	bf00      	nop
  __dbg_check_lock_from_isr();
 8004444:	f7ff fc44 	bl	8003cd0 <__dbg_check_lock_from_isr>
}
 8004448:	bf00      	nop
 800444a:	b003      	add	sp, #12
 800444c:	f85d fb04 	ldr.w	pc, [sp], #4

08004450 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
 8004450:	b500      	push	{lr}
 8004452:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8004454:	f7ff fc64 	bl	8003d20 <__dbg_check_unlock_from_isr>
 8004458:	2300      	movs	r3, #0
 800445a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800445c:	9b01      	ldr	r3, [sp, #4]
 800445e:	f383 8811 	msr	BASEPRI, r3
}
 8004462:	bf00      	nop
}
 8004464:	bf00      	nop
}
 8004466:	bf00      	nop
}
 8004468:	bf00      	nop
 800446a:	b003      	add	sp, #12
 800446c:	f85d fb04 	ldr.w	pc, [sp], #4

08004470 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 8004470:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8004472:	f7ff ffd5 	bl	8004420 <port_timer_get_time.lto_priv.1>
 8004476:	4603      	mov	r3, r0
}
 8004478:	4618      	mov	r0, r3
 800447a:	bd08      	pop	{r3, pc}
 800447c:	0000      	movs	r0, r0
	...

08004480 <chVTIsArmedI.lto_priv.0>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8004480:	b500      	push	{lr}
 8004482:	b083      	sub	sp, #12
 8004484:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8004486:	f7ff fceb 	bl	8003e60 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 800448a:	9b01      	ldr	r3, [sp, #4]
 800448c:	681b      	ldr	r3, [r3, #0]
 800448e:	2b00      	cmp	r3, #0
 8004490:	bf14      	ite	ne
 8004492:	2301      	movne	r3, #1
 8004494:	2300      	moveq	r3, #0
 8004496:	b2db      	uxtb	r3, r3
}
 8004498:	4618      	mov	r0, r3
 800449a:	b003      	add	sp, #12
 800449c:	f85d fb04 	ldr.w	pc, [sp], #4

080044a0 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 80044a0:	b500      	push	{lr}
 80044a2:	b087      	sub	sp, #28
 80044a4:	9001      	str	r0, [sp, #4]
 80044a6:	9100      	str	r1, [sp, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80044a8:	2302      	movs	r3, #2
 80044aa:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 80044ac:	9a00      	ldr	r2, [sp, #0]
 80044ae:	9b05      	ldr	r3, [sp, #20]
 80044b0:	429a      	cmp	r2, r3
 80044b2:	d201      	bcs.n	80044b8 <vt_set_alarm+0x18>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 80044b4:	9b05      	ldr	r3, [sp, #20]
 80044b6:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 80044b8:	9900      	ldr	r1, [sp, #0]
 80044ba:	9801      	ldr	r0, [sp, #4]
 80044bc:	f7ff fea0 	bl	8004200 <chTimeAddX>
 80044c0:	4603      	mov	r3, r0
 80044c2:	4618      	mov	r0, r3
 80044c4:	f7ff ff9c 	bl	8004400 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 80044c8:	f7ff ffd2 	bl	8004470 <chVTGetSystemTimeX.lto_priv.1>
 80044cc:	9004      	str	r0, [sp, #16]
    nowdelta = chTimeDiffX(now, newnow);
 80044ce:	9904      	ldr	r1, [sp, #16]
 80044d0:	9801      	ldr	r0, [sp, #4]
 80044d2:	f7ff fea5 	bl	8004220 <chTimeDiffX.lto_priv.0>
 80044d6:	9003      	str	r0, [sp, #12]
    if (likely(nowdelta < delay)) {
 80044d8:	9a03      	ldr	r2, [sp, #12]
 80044da:	9b00      	ldr	r3, [sp, #0]
 80044dc:	429a      	cmp	r2, r3
 80044de:	bf34      	ite	cc
 80044e0:	2301      	movcc	r3, #1
 80044e2:	2300      	movcs	r3, #0
 80044e4:	b2db      	uxtb	r3, r3
 80044e6:	2b00      	cmp	r3, #0
 80044e8:	d107      	bne.n	80044fa <vt_set_alarm+0x5a>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 80044ea:	9b05      	ldr	r3, [sp, #20]
 80044ec:	3301      	adds	r3, #1
 80044ee:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 80044f0:	9b04      	ldr	r3, [sp, #16]
 80044f2:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 80044f4:	9b05      	ldr	r3, [sp, #20]
 80044f6:	9300      	str	r3, [sp, #0]
  while (true) {
 80044f8:	e7de      	b.n	80044b8 <vt_set_alarm+0x18>
      break;
 80044fa:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80044fc:	9b05      	ldr	r3, [sp, #20]
 80044fe:	2b02      	cmp	r3, #2
 8004500:	d902      	bls.n	8004508 <vt_set_alarm+0x68>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8004502:	2001      	movs	r0, #1
 8004504:	f7ff fb84 	bl	8003c10 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8004508:	bf00      	nop
 800450a:	b007      	add	sp, #28
 800450c:	f85d fb04 	ldr.w	pc, [sp], #4

08004510 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8004510:	b500      	push	{lr}
 8004512:	b087      	sub	sp, #28
 8004514:	9003      	str	r0, [sp, #12]
 8004516:	9102      	str	r1, [sp, #8]
 8004518:	9201      	str	r2, [sp, #4]
 800451a:	9300      	str	r3, [sp, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 800451c:	9b03      	ldr	r3, [sp, #12]
 800451e:	9a01      	ldr	r2, [sp, #4]
 8004520:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8004522:	9b03      	ldr	r3, [sp, #12]
 8004524:	9902      	ldr	r1, [sp, #8]
 8004526:	9a00      	ldr	r2, [sp, #0]
 8004528:	4618      	mov	r0, r3
 800452a:	f7ff fea9 	bl	8004280 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800452e:	2302      	movs	r3, #2
 8004530:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8004532:	9a00      	ldr	r2, [sp, #0]
 8004534:	9b05      	ldr	r3, [sp, #20]
 8004536:	429a      	cmp	r2, r3
 8004538:	d201      	bcs.n	800453e <vt_insert_first+0x2e>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 800453a:	9b05      	ldr	r3, [sp, #20]
 800453c:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 800453e:	9b03      	ldr	r3, [sp, #12]
 8004540:	68db      	ldr	r3, [r3, #12]
 8004542:	9900      	ldr	r1, [sp, #0]
 8004544:	4618      	mov	r0, r3
 8004546:	f7ff fe5b 	bl	8004200 <chTimeAddX>
 800454a:	4603      	mov	r3, r0
 800454c:	4618      	mov	r0, r3
 800454e:	f7ff ff3f 	bl	80043d0 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8004552:	f7ff ff8d 	bl	8004470 <chVTGetSystemTimeX.lto_priv.1>
 8004556:	9004      	str	r0, [sp, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8004558:	9904      	ldr	r1, [sp, #16]
 800455a:	9801      	ldr	r0, [sp, #4]
 800455c:	f7ff fe60 	bl	8004220 <chTimeDiffX.lto_priv.0>
 8004560:	4602      	mov	r2, r0
 8004562:	9b00      	ldr	r3, [sp, #0]
 8004564:	4293      	cmp	r3, r2
 8004566:	bf8c      	ite	hi
 8004568:	2301      	movhi	r3, #1
 800456a:	2300      	movls	r3, #0
 800456c:	b2db      	uxtb	r3, r3
 800456e:	2b00      	cmp	r3, #0
 8004570:	d10f      	bne.n	8004592 <vt_insert_first+0x82>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8004572:	9b05      	ldr	r3, [sp, #20]
 8004574:	3301      	adds	r3, #1
 8004576:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8004578:	9905      	ldr	r1, [sp, #20]
 800457a:	9801      	ldr	r0, [sp, #4]
 800457c:	f7ff fe40 	bl	8004200 <chTimeAddX>
 8004580:	4603      	mov	r3, r0
 8004582:	4618      	mov	r0, r3
 8004584:	f7ff ff3c 	bl	8004400 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8004588:	9b04      	ldr	r3, [sp, #16]
 800458a:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 800458c:	9b05      	ldr	r3, [sp, #20]
 800458e:	9300      	str	r3, [sp, #0]
  while (true) {
 8004590:	e7df      	b.n	8004552 <vt_insert_first+0x42>
      break;
 8004592:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8004594:	9b05      	ldr	r3, [sp, #20]
 8004596:	2b02      	cmp	r3, #2
 8004598:	d902      	bls.n	80045a0 <vt_insert_first+0x90>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 800459a:	2001      	movs	r0, #1
 800459c:	f7ff fb38 	bl	8003c10 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80045a0:	bf00      	nop
 80045a2:	b007      	add	sp, #28
 80045a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080045b0 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 80045b0:	b500      	push	{lr}
 80045b2:	b089      	sub	sp, #36	@ 0x24
 80045b4:	9003      	str	r0, [sp, #12]
 80045b6:	9102      	str	r1, [sp, #8]
 80045b8:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 80045ba:	f7ff ff59 	bl	8004470 <chVTGetSystemTimeX.lto_priv.1>
 80045be:	9006      	str	r0, [sp, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 80045c0:	9b03      	ldr	r3, [sp, #12]
 80045c2:	4618      	mov	r0, r3
 80045c4:	f7ff fe3c 	bl	8004240 <ch_dlist_isempty>
 80045c8:	4603      	mov	r3, r0
 80045ca:	2b00      	cmp	r3, #0
 80045cc:	d006      	beq.n	80045dc <vt_enqueue+0x2c>

      vt_insert_first(vtlp, vtp, now, delay);
 80045ce:	9b01      	ldr	r3, [sp, #4]
 80045d0:	9a06      	ldr	r2, [sp, #24]
 80045d2:	9902      	ldr	r1, [sp, #8]
 80045d4:	9803      	ldr	r0, [sp, #12]
 80045d6:	f7ff ff9b 	bl	8004510 <vt_insert_first>

      return;
 80045da:	e020      	b.n	800461e <vt_enqueue+0x6e>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80045dc:	9b03      	ldr	r3, [sp, #12]
 80045de:	68db      	ldr	r3, [r3, #12]
 80045e0:	9906      	ldr	r1, [sp, #24]
 80045e2:	4618      	mov	r0, r3
 80045e4:	f7ff fe1c 	bl	8004220 <chTimeDiffX.lto_priv.0>
 80045e8:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
 80045ea:	9a05      	ldr	r2, [sp, #20]
 80045ec:	9b01      	ldr	r3, [sp, #4]
 80045ee:	4413      	add	r3, r2
 80045f0:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 80045f2:	9a07      	ldr	r2, [sp, #28]
 80045f4:	9b05      	ldr	r3, [sp, #20]
 80045f6:	429a      	cmp	r2, r3
 80045f8:	d201      	bcs.n	80045fe <vt_enqueue+0x4e>
      delta = delay;
 80045fa:	9b01      	ldr	r3, [sp, #4]
 80045fc:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 80045fe:	9b03      	ldr	r3, [sp, #12]
 8004600:	681b      	ldr	r3, [r3, #0]
 8004602:	689b      	ldr	r3, [r3, #8]
 8004604:	9a07      	ldr	r2, [sp, #28]
 8004606:	429a      	cmp	r2, r3
 8004608:	d203      	bcs.n	8004612 <vt_enqueue+0x62>

      vt_set_alarm(now, delay);
 800460a:	9901      	ldr	r1, [sp, #4]
 800460c:	9806      	ldr	r0, [sp, #24]
 800460e:	f7ff ff47 	bl	80044a0 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8004612:	9b03      	ldr	r3, [sp, #12]
 8004614:	9902      	ldr	r1, [sp, #8]
 8004616:	9a07      	ldr	r2, [sp, #28]
 8004618:	4618      	mov	r0, r3
 800461a:	f7ff fe71 	bl	8004300 <ch_dlist_insert>
}
 800461e:	b009      	add	sp, #36	@ 0x24
 8004620:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004630 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8004630:	b500      	push	{lr}
 8004632:	b087      	sub	sp, #28
 8004634:	9003      	str	r0, [sp, #12]
 8004636:	9102      	str	r1, [sp, #8]
 8004638:	9201      	str	r2, [sp, #4]
 800463a:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 800463c:	4b1a      	ldr	r3, [pc, #104]	@ (80046a8 <chVTDoSetI+0x78>)
 800463e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8004640:	f7ff fc0e 	bl	8003e60 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8004644:	9b03      	ldr	r3, [sp, #12]
 8004646:	2b00      	cmp	r3, #0
 8004648:	bf0c      	ite	eq
 800464a:	2301      	moveq	r3, #1
 800464c:	2300      	movne	r3, #0
 800464e:	b2db      	uxtb	r3, r3
 8004650:	2b00      	cmp	r3, #0
 8004652:	d107      	bne.n	8004664 <chVTDoSetI+0x34>
 8004654:	9b01      	ldr	r3, [sp, #4]
 8004656:	2b00      	cmp	r3, #0
 8004658:	bf0c      	ite	eq
 800465a:	2301      	moveq	r3, #1
 800465c:	2300      	movne	r3, #0
 800465e:	b2db      	uxtb	r3, r3
 8004660:	2b00      	cmp	r3, #0
 8004662:	d001      	beq.n	8004668 <chVTDoSetI+0x38>
 8004664:	2301      	movs	r3, #1
 8004666:	e000      	b.n	800466a <chVTDoSetI+0x3a>
 8004668:	2300      	movs	r3, #0
 800466a:	2b00      	cmp	r3, #0
 800466c:	d107      	bne.n	800467e <chVTDoSetI+0x4e>
 800466e:	9b02      	ldr	r3, [sp, #8]
 8004670:	2b00      	cmp	r3, #0
 8004672:	bf0c      	ite	eq
 8004674:	2301      	moveq	r3, #1
 8004676:	2300      	movne	r3, #0
 8004678:	b2db      	uxtb	r3, r3
 800467a:	2b00      	cmp	r3, #0
 800467c:	d002      	beq.n	8004684 <chVTDoSetI+0x54>
 800467e:	480b      	ldr	r0, [pc, #44]	@ (80046ac <chVTDoSetI+0x7c>)
 8004680:	f7ff fa4e 	bl	8003b20 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8004684:	9b03      	ldr	r3, [sp, #12]
 8004686:	9a00      	ldr	r2, [sp, #0]
 8004688:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 800468a:	9b03      	ldr	r3, [sp, #12]
 800468c:	9a01      	ldr	r2, [sp, #4]
 800468e:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8004690:	9b03      	ldr	r3, [sp, #12]
 8004692:	2200      	movs	r2, #0
 8004694:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8004696:	9a02      	ldr	r2, [sp, #8]
 8004698:	9903      	ldr	r1, [sp, #12]
 800469a:	9805      	ldr	r0, [sp, #20]
 800469c:	f7ff ff88 	bl	80045b0 <vt_enqueue>
}
 80046a0:	bf00      	nop
 80046a2:	b007      	add	sp, #28
 80046a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80046a8:	24000168 	.word	0x24000168
 80046ac:	08006f38 	.word	0x08006f38

080046b0 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80046b0:	b500      	push	{lr}
 80046b2:	b087      	sub	sp, #28
 80046b4:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 80046b6:	4b3a      	ldr	r3, [pc, #232]	@ (80047a0 <chVTDoResetI+0xf0>)
 80046b8:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 80046ba:	f7ff fbd1 	bl	8003e60 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 80046be:	9b01      	ldr	r3, [sp, #4]
 80046c0:	2b00      	cmp	r3, #0
 80046c2:	bf0c      	ite	eq
 80046c4:	2301      	moveq	r3, #1
 80046c6:	2300      	movne	r3, #0
 80046c8:	b2db      	uxtb	r3, r3
 80046ca:	2b00      	cmp	r3, #0
 80046cc:	d002      	beq.n	80046d4 <chVTDoResetI+0x24>
 80046ce:	4835      	ldr	r0, [pc, #212]	@ (80047a4 <chVTDoResetI+0xf4>)
 80046d0:	f7ff fa26 	bl	8003b20 <chSysHalt>
  chDbgAssert(chVTIsArmedI(vtp), "timer not armed");
 80046d4:	9801      	ldr	r0, [sp, #4]
 80046d6:	f7ff fed3 	bl	8004480 <chVTIsArmedI.lto_priv.0>
 80046da:	4603      	mov	r3, r0
 80046dc:	f083 0301 	eor.w	r3, r3, #1
 80046e0:	b2db      	uxtb	r3, r3
 80046e2:	2b00      	cmp	r3, #0
 80046e4:	d002      	beq.n	80046ec <chVTDoResetI+0x3c>
 80046e6:	482f      	ldr	r0, [pc, #188]	@ (80047a4 <chVTDoResetI+0xf4>)
 80046e8:	f7ff fa1a 	bl	8003b20 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 80046ec:	9b05      	ldr	r3, [sp, #20]
 80046ee:	9a01      	ldr	r2, [sp, #4]
 80046f0:	4611      	mov	r1, r2
 80046f2:	4618      	mov	r0, r3
 80046f4:	f7ff fdb4 	bl	8004260 <ch_dlist_isfirst>
 80046f8:	4603      	mov	r3, r0
 80046fa:	f083 0301 	eor.w	r3, r3, #1
 80046fe:	b2db      	uxtb	r3, r3
 8004700:	2b00      	cmp	r3, #0
 8004702:	d014      	beq.n	800472e <chVTDoResetI+0x7e>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8004704:	9b01      	ldr	r3, [sp, #4]
 8004706:	4618      	mov	r0, r3
 8004708:	f7ff fe52 	bl	80043b0 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 800470c:	9b01      	ldr	r3, [sp, #4]
 800470e:	681b      	ldr	r3, [r3, #0]
 8004710:	6899      	ldr	r1, [r3, #8]
 8004712:	9b01      	ldr	r3, [sp, #4]
 8004714:	689a      	ldr	r2, [r3, #8]
 8004716:	9b01      	ldr	r3, [sp, #4]
 8004718:	681b      	ldr	r3, [r3, #0]
 800471a:	440a      	add	r2, r1
 800471c:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 800471e:	9b01      	ldr	r3, [sp, #4]
 8004720:	2200      	movs	r2, #0
 8004722:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8004724:	9b05      	ldr	r3, [sp, #20]
 8004726:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800472a:	609a      	str	r2, [r3, #8]

    return;
 800472c:	e035      	b.n	800479a <chVTDoResetI+0xea>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 800472e:	9b05      	ldr	r3, [sp, #20]
 8004730:	4618      	mov	r0, r3
 8004732:	f7ff fe25 	bl	8004380 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8004736:	9b01      	ldr	r3, [sp, #4]
 8004738:	2200      	movs	r2, #0
 800473a:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 800473c:	9b05      	ldr	r3, [sp, #20]
 800473e:	4618      	mov	r0, r3
 8004740:	f7ff fd7e 	bl	8004240 <ch_dlist_isempty>
 8004744:	4603      	mov	r3, r0
 8004746:	2b00      	cmp	r3, #0
 8004748:	d002      	beq.n	8004750 <chVTDoResetI+0xa0>

    port_timer_stop_alarm();
 800474a:	f7ff fe51 	bl	80043f0 <port_timer_stop_alarm>

    return;
 800474e:	e024      	b.n	800479a <chVTDoResetI+0xea>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8004750:	9b05      	ldr	r3, [sp, #20]
 8004752:	681b      	ldr	r3, [r3, #0]
 8004754:	6899      	ldr	r1, [r3, #8]
 8004756:	9b01      	ldr	r3, [sp, #4]
 8004758:	689a      	ldr	r2, [r3, #8]
 800475a:	9b05      	ldr	r3, [sp, #20]
 800475c:	681b      	ldr	r3, [r3, #0]
 800475e:	440a      	add	r2, r1
 8004760:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 8004762:	f7ff fe85 	bl	8004470 <chVTGetSystemTimeX.lto_priv.1>
 8004766:	9004      	str	r0, [sp, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8004768:	9b05      	ldr	r3, [sp, #20]
 800476a:	68db      	ldr	r3, [r3, #12]
 800476c:	9904      	ldr	r1, [sp, #16]
 800476e:	4618      	mov	r0, r3
 8004770:	f7ff fd56 	bl	8004220 <chTimeDiffX.lto_priv.0>
 8004774:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8004776:	9b05      	ldr	r3, [sp, #20]
 8004778:	681b      	ldr	r3, [r3, #0]
 800477a:	689b      	ldr	r3, [r3, #8]
 800477c:	9a03      	ldr	r2, [sp, #12]
 800477e:	429a      	cmp	r2, r3
 8004780:	d20a      	bcs.n	8004798 <chVTDoResetI+0xe8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8004782:	9b05      	ldr	r3, [sp, #20]
 8004784:	681b      	ldr	r3, [r3, #0]
 8004786:	689a      	ldr	r2, [r3, #8]
 8004788:	9b03      	ldr	r3, [sp, #12]
 800478a:	1ad3      	subs	r3, r2, r3
 800478c:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 800478e:	9902      	ldr	r1, [sp, #8]
 8004790:	9804      	ldr	r0, [sp, #16]
 8004792:	f7ff fe85 	bl	80044a0 <vt_set_alarm>
 8004796:	e000      	b.n	800479a <chVTDoResetI+0xea>
    return;
 8004798:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800479a:	b007      	add	sp, #28
 800479c:	f85d fb04 	ldr.w	pc, [sp], #4
 80047a0:	24000168 	.word	0x24000168
 80047a4:	08006f44 	.word	0x08006f44
	...

080047b0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 80047b0:	b500      	push	{lr}
 80047b2:	b089      	sub	sp, #36	@ 0x24
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 80047b4:	4b4f      	ldr	r3, [pc, #316]	@ (80048f4 <chVTDoTickI+0x144>)
 80047b6:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 80047b8:	f7ff fb52 	bl	8003e60 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 80047bc:	9b05      	ldr	r3, [sp, #20]
 80047be:	681b      	ldr	r3, [r3, #0]
 80047c0:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 80047c2:	f7ff fe55 	bl	8004470 <chVTGetSystemTimeX.lto_priv.1>
 80047c6:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80047c8:	9b05      	ldr	r3, [sp, #20]
 80047ca:	68db      	ldr	r3, [r3, #12]
 80047cc:	9903      	ldr	r1, [sp, #12]
 80047ce:	4618      	mov	r0, r3
 80047d0:	f7ff fd26 	bl	8004220 <chTimeDiffX.lto_priv.0>
 80047d4:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 80047d6:	9b04      	ldr	r3, [sp, #16]
 80047d8:	689b      	ldr	r3, [r3, #8]
 80047da:	9a02      	ldr	r2, [sp, #8]
 80047dc:	429a      	cmp	r2, r3
 80047de:	d369      	bcc.n	80048b4 <chVTDoTickI+0x104>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 80047e0:	9b05      	ldr	r3, [sp, #20]
 80047e2:	68da      	ldr	r2, [r3, #12]
 80047e4:	9b04      	ldr	r3, [sp, #16]
 80047e6:	689b      	ldr	r3, [r3, #8]
 80047e8:	4619      	mov	r1, r3
 80047ea:	4610      	mov	r0, r2
 80047ec:	f7ff fd08 	bl	8004200 <chTimeAddX>
 80047f0:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
 80047f2:	9b05      	ldr	r3, [sp, #20]
 80047f4:	9a01      	ldr	r2, [sp, #4]
 80047f6:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 80047f8:	9b04      	ldr	r3, [sp, #16]
 80047fa:	4618      	mov	r0, r3
 80047fc:	f7ff fdd8 	bl	80043b0 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8004800:	9b04      	ldr	r3, [sp, #16]
 8004802:	2200      	movs	r2, #0
 8004804:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8004806:	9b05      	ldr	r3, [sp, #20]
 8004808:	4618      	mov	r0, r3
 800480a:	f7ff fd19 	bl	8004240 <ch_dlist_isempty>
 800480e:	4603      	mov	r3, r0
 8004810:	2b00      	cmp	r3, #0
 8004812:	d001      	beq.n	8004818 <chVTDoTickI+0x68>
      port_timer_stop_alarm();
 8004814:	f7ff fdec 	bl	80043f0 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 8004818:	f7ff fe1a 	bl	8004450 <chSysUnlockFromISR.lto_priv.3>

    vtp->func(vtp, vtp->par);
 800481c:	9b04      	ldr	r3, [sp, #16]
 800481e:	68db      	ldr	r3, [r3, #12]
 8004820:	9a04      	ldr	r2, [sp, #16]
 8004822:	6912      	ldr	r2, [r2, #16]
 8004824:	4611      	mov	r1, r2
 8004826:	9804      	ldr	r0, [sp, #16]
 8004828:	4798      	blx	r3

    chSysLockFromISR();
 800482a:	f7ff fe01 	bl	8004430 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 800482e:	9b04      	ldr	r3, [sp, #16]
 8004830:	695b      	ldr	r3, [r3, #20]
 8004832:	2b00      	cmp	r3, #0
 8004834:	bf14      	ite	ne
 8004836:	2301      	movne	r3, #1
 8004838:	2300      	moveq	r3, #0
 800483a:	b2db      	uxtb	r3, r3
 800483c:	2b00      	cmp	r3, #0
 800483e:	d0bd      	beq.n	80047bc <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8004840:	f7ff fe16 	bl	8004470 <chVTGetSystemTimeX.lto_priv.1>
 8004844:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 8004846:	9903      	ldr	r1, [sp, #12]
 8004848:	9801      	ldr	r0, [sp, #4]
 800484a:	f7ff fce9 	bl	8004220 <chTimeDiffX.lto_priv.0>
 800484e:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8004850:	9b04      	ldr	r3, [sp, #16]
 8004852:	695b      	ldr	r3, [r3, #20]
 8004854:	9a02      	ldr	r2, [sp, #8]
 8004856:	429a      	cmp	r2, r3
 8004858:	d908      	bls.n	800486c <chVTDoTickI+0xbc>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
 800485a:	4827      	ldr	r0, [pc, #156]	@ (80048f8 <chVTDoTickI+0x148>)
 800485c:	f7ff f960 	bl	8003b20 <chSysHalt>
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8004860:	2002      	movs	r0, #2
 8004862:	f7ff f9d5 	bl	8003c10 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8004866:	2300      	movs	r3, #0
 8004868:	9306      	str	r3, [sp, #24]
 800486a:	e004      	b.n	8004876 <chVTDoTickI+0xc6>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 800486c:	9b04      	ldr	r3, [sp, #16]
 800486e:	695a      	ldr	r2, [r3, #20]
 8004870:	9b02      	ldr	r3, [sp, #8]
 8004872:	1ad3      	subs	r3, r2, r3
 8004874:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8004876:	9b05      	ldr	r3, [sp, #20]
 8004878:	4618      	mov	r0, r3
 800487a:	f7ff fce1 	bl	8004240 <ch_dlist_isempty>
 800487e:	4603      	mov	r3, r0
 8004880:	2b00      	cmp	r3, #0
 8004882:	d006      	beq.n	8004892 <chVTDoTickI+0xe2>

        vt_insert_first(vtlp, vtp, now, delay);
 8004884:	9b06      	ldr	r3, [sp, #24]
 8004886:	9a03      	ldr	r2, [sp, #12]
 8004888:	9904      	ldr	r1, [sp, #16]
 800488a:	9805      	ldr	r0, [sp, #20]
 800488c:	f7ff fe40 	bl	8004510 <vt_insert_first>

        return;
 8004890:	e02c      	b.n	80048ec <chVTDoTickI+0x13c>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8004892:	9a02      	ldr	r2, [sp, #8]
 8004894:	9b06      	ldr	r3, [sp, #24]
 8004896:	4413      	add	r3, r2
 8004898:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 800489a:	9a07      	ldr	r2, [sp, #28]
 800489c:	9b02      	ldr	r3, [sp, #8]
 800489e:	429a      	cmp	r2, r3
 80048a0:	d201      	bcs.n	80048a6 <chVTDoTickI+0xf6>
        delta = delay;
 80048a2:	9b06      	ldr	r3, [sp, #24]
 80048a4:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 80048a6:	9b05      	ldr	r3, [sp, #20]
 80048a8:	9904      	ldr	r1, [sp, #16]
 80048aa:	9a07      	ldr	r2, [sp, #28]
 80048ac:	4618      	mov	r0, r3
 80048ae:	f7ff fd27 	bl	8004300 <ch_dlist_insert>
  while (true) {
 80048b2:	e783      	b.n	80047bc <chVTDoTickI+0xc>
      break;
 80048b4:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 80048b6:	9b05      	ldr	r3, [sp, #20]
 80048b8:	4618      	mov	r0, r3
 80048ba:	f7ff fcc1 	bl	8004240 <ch_dlist_isempty>
 80048be:	4603      	mov	r3, r0
 80048c0:	2b00      	cmp	r3, #0
 80048c2:	d112      	bne.n	80048ea <chVTDoTickI+0x13a>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 80048c4:	9b05      	ldr	r3, [sp, #20]
 80048c6:	68da      	ldr	r2, [r3, #12]
 80048c8:	9b02      	ldr	r3, [sp, #8]
 80048ca:	441a      	add	r2, r3
 80048cc:	9b05      	ldr	r3, [sp, #20]
 80048ce:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 80048d0:	9b04      	ldr	r3, [sp, #16]
 80048d2:	689a      	ldr	r2, [r3, #8]
 80048d4:	9b02      	ldr	r3, [sp, #8]
 80048d6:	1ad2      	subs	r2, r2, r3
 80048d8:	9b04      	ldr	r3, [sp, #16]
 80048da:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 80048dc:	9b04      	ldr	r3, [sp, #16]
 80048de:	689b      	ldr	r3, [r3, #8]
 80048e0:	4619      	mov	r1, r3
 80048e2:	9803      	ldr	r0, [sp, #12]
 80048e4:	f7ff fddc 	bl	80044a0 <vt_set_alarm>
 80048e8:	e000      	b.n	80048ec <chVTDoTickI+0x13c>
    return;
 80048ea:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80048ec:	b009      	add	sp, #36	@ 0x24
 80048ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80048f2:	bf00      	nop
 80048f4:	24000168 	.word	0x24000168
 80048f8:	08006f54 	.word	0x08006f54
 80048fc:	00000000 	.word	0x00000000

08004900 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8004900:	b082      	sub	sp, #8
 8004902:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8004904:	9b01      	ldr	r3, [sp, #4]
 8004906:	685b      	ldr	r3, [r3, #4]
 8004908:	9a01      	ldr	r2, [sp, #4]
 800490a:	6812      	ldr	r2, [r2, #0]
 800490c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800490e:	9b01      	ldr	r3, [sp, #4]
 8004910:	681b      	ldr	r3, [r3, #0]
 8004912:	9a01      	ldr	r2, [sp, #4]
 8004914:	6852      	ldr	r2, [r2, #4]
 8004916:	605a      	str	r2, [r3, #4]
  return p;
 8004918:	9b01      	ldr	r3, [sp, #4]
}
 800491a:	4618      	mov	r0, r3
 800491c:	b002      	add	sp, #8
 800491e:	4770      	bx	lr

08004920 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 8004920:	b084      	sub	sp, #16
 8004922:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 8004924:	9b01      	ldr	r3, [sp, #4]
 8004926:	681b      	ldr	r3, [r3, #0]
 8004928:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 800492a:	9b03      	ldr	r3, [sp, #12]
 800492c:	681a      	ldr	r2, [r3, #0]
 800492e:	9b01      	ldr	r3, [sp, #4]
 8004930:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 8004932:	9b01      	ldr	r3, [sp, #4]
 8004934:	681b      	ldr	r3, [r3, #0]
 8004936:	9a01      	ldr	r2, [sp, #4]
 8004938:	605a      	str	r2, [r3, #4]
  return p;
 800493a:	9b03      	ldr	r3, [sp, #12]
}
 800493c:	4618      	mov	r0, r3
 800493e:	b004      	add	sp, #16
 8004940:	4770      	bx	lr
 8004942:	bf00      	nop
	...

08004950 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8004950:	b082      	sub	sp, #8
 8004952:	9001      	str	r0, [sp, #4]
 8004954:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8004956:	9b01      	ldr	r3, [sp, #4]
 8004958:	681b      	ldr	r3, [r3, #0]
 800495a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 800495c:	9b01      	ldr	r3, [sp, #4]
 800495e:	689a      	ldr	r2, [r3, #8]
 8004960:	9b00      	ldr	r3, [sp, #0]
 8004962:	689b      	ldr	r3, [r3, #8]
 8004964:	429a      	cmp	r2, r3
 8004966:	bf2c      	ite	cs
 8004968:	2301      	movcs	r3, #1
 800496a:	2300      	movcc	r3, #0
 800496c:	b2db      	uxtb	r3, r3
 800496e:	2b00      	cmp	r3, #0
 8004970:	d1f1      	bne.n	8004956 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8004972:	9b00      	ldr	r3, [sp, #0]
 8004974:	9a01      	ldr	r2, [sp, #4]
 8004976:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8004978:	9b01      	ldr	r3, [sp, #4]
 800497a:	685a      	ldr	r2, [r3, #4]
 800497c:	9b00      	ldr	r3, [sp, #0]
 800497e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8004980:	9b00      	ldr	r3, [sp, #0]
 8004982:	685b      	ldr	r3, [r3, #4]
 8004984:	9a00      	ldr	r2, [sp, #0]
 8004986:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8004988:	9b01      	ldr	r3, [sp, #4]
 800498a:	9a00      	ldr	r2, [sp, #0]
 800498c:	605a      	str	r2, [r3, #4]
  return p;
 800498e:	9b00      	ldr	r3, [sp, #0]
}
 8004990:	4618      	mov	r0, r3
 8004992:	b002      	add	sp, #8
 8004994:	4770      	bx	lr
 8004996:	bf00      	nop
	...

080049a0 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 80049a0:	b082      	sub	sp, #8
 80049a2:	9001      	str	r0, [sp, #4]
 80049a4:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 80049a6:	9b01      	ldr	r3, [sp, #4]
 80049a8:	681b      	ldr	r3, [r3, #0]
 80049aa:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 80049ac:	9b01      	ldr	r3, [sp, #4]
 80049ae:	689a      	ldr	r2, [r3, #8]
 80049b0:	9b00      	ldr	r3, [sp, #0]
 80049b2:	689b      	ldr	r3, [r3, #8]
 80049b4:	429a      	cmp	r2, r3
 80049b6:	bf8c      	ite	hi
 80049b8:	2301      	movhi	r3, #1
 80049ba:	2300      	movls	r3, #0
 80049bc:	b2db      	uxtb	r3, r3
 80049be:	2b00      	cmp	r3, #0
 80049c0:	d1f1      	bne.n	80049a6 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 80049c2:	9b00      	ldr	r3, [sp, #0]
 80049c4:	9a01      	ldr	r2, [sp, #4]
 80049c6:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 80049c8:	9b01      	ldr	r3, [sp, #4]
 80049ca:	685a      	ldr	r2, [r3, #4]
 80049cc:	9b00      	ldr	r3, [sp, #0]
 80049ce:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 80049d0:	9b00      	ldr	r3, [sp, #0]
 80049d2:	685b      	ldr	r3, [r3, #4]
 80049d4:	9a00      	ldr	r2, [sp, #0]
 80049d6:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 80049d8:	9b01      	ldr	r3, [sp, #4]
 80049da:	9a00      	ldr	r2, [sp, #0]
 80049dc:	605a      	str	r2, [r3, #4]
  return p;
 80049de:	9b00      	ldr	r3, [sp, #0]
}
 80049e0:	4618      	mov	r0, r3
 80049e2:	b002      	add	sp, #8
 80049e4:	4770      	bx	lr
 80049e6:	bf00      	nop
	...

080049f0 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 80049f0:	b500      	push	{lr}
 80049f2:	b083      	sub	sp, #12
 80049f4:	2330      	movs	r3, #48	@ 0x30
 80049f6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80049f8:	9b01      	ldr	r3, [sp, #4]
 80049fa:	f383 8811 	msr	BASEPRI, r3
}
 80049fe:	bf00      	nop
}
 8004a00:	bf00      	nop
}
 8004a02:	bf00      	nop
  __dbg_check_lock_from_isr();
 8004a04:	f7ff f964 	bl	8003cd0 <__dbg_check_lock_from_isr>
}
 8004a08:	bf00      	nop
 8004a0a:	b003      	add	sp, #12
 8004a0c:	f85d fb04 	ldr.w	pc, [sp], #4

08004a10 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 8004a10:	b500      	push	{lr}
 8004a12:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8004a14:	f7ff f984 	bl	8003d20 <__dbg_check_unlock_from_isr>
 8004a18:	2300      	movs	r3, #0
 8004a1a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004a1c:	9b01      	ldr	r3, [sp, #4]
 8004a1e:	f383 8811 	msr	BASEPRI, r3
}
 8004a22:	bf00      	nop
}
 8004a24:	bf00      	nop
}
 8004a26:	bf00      	nop
}
 8004a28:	bf00      	nop
 8004a2a:	b003      	add	sp, #12
 8004a2c:	f85d fb04 	ldr.w	pc, [sp], #4

08004a30 <chVTIsArmedI.lto_priv.1>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8004a30:	b500      	push	{lr}
 8004a32:	b083      	sub	sp, #12
 8004a34:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8004a36:	f7ff fa13 	bl	8003e60 <chDbgCheckClassI>
  return (bool)(vtp->dlist.next != NULL);
 8004a3a:	9b01      	ldr	r3, [sp, #4]
 8004a3c:	681b      	ldr	r3, [r3, #0]
 8004a3e:	2b00      	cmp	r3, #0
 8004a40:	bf14      	ite	ne
 8004a42:	2301      	movne	r3, #1
 8004a44:	2300      	moveq	r3, #0
 8004a46:	b2db      	uxtb	r3, r3
}
 8004a48:	4618      	mov	r0, r3
 8004a4a:	b003      	add	sp, #12
 8004a4c:	f85d fb04 	ldr.w	pc, [sp], #4

08004a50 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8004a50:	b500      	push	{lr}
 8004a52:	b083      	sub	sp, #12
 8004a54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8004a56:	f7ff fa03 	bl	8003e60 <chDbgCheckClassI>

  sp->cnt++;
 8004a5a:	9b01      	ldr	r3, [sp, #4]
 8004a5c:	689b      	ldr	r3, [r3, #8]
 8004a5e:	1c5a      	adds	r2, r3, #1
 8004a60:	9b01      	ldr	r3, [sp, #4]
 8004a62:	609a      	str	r2, [r3, #8]
}
 8004a64:	bf00      	nop
 8004a66:	b003      	add	sp, #12
 8004a68:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a6c:	0000      	movs	r0, r0
	...

08004a70 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8004a70:	b500      	push	{lr}
 8004a72:	b083      	sub	sp, #12
 8004a74:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8004a76:	9b01      	ldr	r3, [sp, #4]
 8004a78:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004a7c:	2b00      	cmp	r3, #0
 8004a7e:	bf0c      	ite	eq
 8004a80:	2301      	moveq	r3, #1
 8004a82:	2300      	movne	r3, #0
 8004a84:	b2db      	uxtb	r3, r3
 8004a86:	2b00      	cmp	r3, #0
 8004a88:	d109      	bne.n	8004a9e <__sch_ready_behind+0x2e>
 8004a8a:	9b01      	ldr	r3, [sp, #4]
 8004a8c:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004a90:	2b0f      	cmp	r3, #15
 8004a92:	bf0c      	ite	eq
 8004a94:	2301      	moveq	r3, #1
 8004a96:	2300      	movne	r3, #0
 8004a98:	b2db      	uxtb	r3, r3
 8004a9a:	2b00      	cmp	r3, #0
 8004a9c:	d002      	beq.n	8004aa4 <__sch_ready_behind+0x34>
 8004a9e:	480d      	ldr	r0, [pc, #52]	@ (8004ad4 <__sch_ready_behind+0x64>)
 8004aa0:	f7ff f83e 	bl	8003b20 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 8004aa4:	9b01      	ldr	r3, [sp, #4]
 8004aa6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004aa8:	4619      	mov	r1, r3
 8004aaa:	9801      	ldr	r0, [sp, #4]
 8004aac:	f7ff fa88 	bl	8003fc0 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8004ab0:	9b01      	ldr	r3, [sp, #4]
 8004ab2:	2200      	movs	r2, #0
 8004ab4:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8004ab8:	9b01      	ldr	r3, [sp, #4]
 8004aba:	699b      	ldr	r3, [r3, #24]
 8004abc:	461a      	mov	r2, r3
 8004abe:	9b01      	ldr	r3, [sp, #4]
 8004ac0:	4619      	mov	r1, r3
 8004ac2:	4610      	mov	r0, r2
 8004ac4:	f7ff ff44 	bl	8004950 <ch_pqueue_insert_behind>
 8004ac8:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
 8004aca:	4618      	mov	r0, r3
 8004acc:	b003      	add	sp, #12
 8004ace:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ad2:	bf00      	nop
 8004ad4:	08006f60 	.word	0x08006f60
	...

08004ae0 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8004ae0:	b500      	push	{lr}
 8004ae2:	b083      	sub	sp, #12
 8004ae4:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8004ae6:	9b01      	ldr	r3, [sp, #4]
 8004ae8:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004aec:	2b00      	cmp	r3, #0
 8004aee:	bf0c      	ite	eq
 8004af0:	2301      	moveq	r3, #1
 8004af2:	2300      	movne	r3, #0
 8004af4:	b2db      	uxtb	r3, r3
 8004af6:	2b00      	cmp	r3, #0
 8004af8:	d109      	bne.n	8004b0e <__sch_ready_ahead+0x2e>
 8004afa:	9b01      	ldr	r3, [sp, #4]
 8004afc:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004b00:	2b0f      	cmp	r3, #15
 8004b02:	bf0c      	ite	eq
 8004b04:	2301      	moveq	r3, #1
 8004b06:	2300      	movne	r3, #0
 8004b08:	b2db      	uxtb	r3, r3
 8004b0a:	2b00      	cmp	r3, #0
 8004b0c:	d002      	beq.n	8004b14 <__sch_ready_ahead+0x34>
 8004b0e:	480d      	ldr	r0, [pc, #52]	@ (8004b44 <__sch_ready_ahead+0x64>)
 8004b10:	f7ff f806 	bl	8003b20 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 8004b14:	9b01      	ldr	r3, [sp, #4]
 8004b16:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004b18:	4619      	mov	r1, r3
 8004b1a:	9801      	ldr	r0, [sp, #4]
 8004b1c:	f7ff fa50 	bl	8003fc0 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8004b20:	9b01      	ldr	r3, [sp, #4]
 8004b22:	2200      	movs	r2, #0
 8004b24:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8004b28:	9b01      	ldr	r3, [sp, #4]
 8004b2a:	699b      	ldr	r3, [r3, #24]
 8004b2c:	461a      	mov	r2, r3
 8004b2e:	9b01      	ldr	r3, [sp, #4]
 8004b30:	4619      	mov	r1, r3
 8004b32:	4610      	mov	r0, r2
 8004b34:	f7ff ff34 	bl	80049a0 <ch_pqueue_insert_ahead>
 8004b38:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
 8004b3a:	4618      	mov	r0, r3
 8004b3c:	b003      	add	sp, #12
 8004b3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b42:	bf00      	nop
 8004b44:	08006f74 	.word	0x08006f74
	...

08004b50 <__sch_reschedule_ahead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_ahead(void) {
 8004b50:	b500      	push	{lr}
 8004b52:	b087      	sub	sp, #28
  os_instance_t *oip = currcore;
 8004b54:	4b17      	ldr	r3, [pc, #92]	@ (8004bb4 <__sch_reschedule_ahead+0x64>)
 8004b56:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 8004b58:	9b05      	ldr	r3, [sp, #20]
 8004b5a:	68db      	ldr	r3, [r3, #12]
 8004b5c:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8004b5e:	9b05      	ldr	r3, [sp, #20]
 8004b60:	4618      	mov	r0, r3
 8004b62:	f7ff fedd 	bl	8004920 <ch_pqueue_remove_highest>
 8004b66:	9003      	str	r0, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 8004b68:	9b03      	ldr	r3, [sp, #12]
 8004b6a:	2201      	movs	r2, #1
 8004b6c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8004b70:	9b05      	ldr	r3, [sp, #20]
 8004b72:	9a03      	ldr	r2, [sp, #12]
 8004b74:	60da      	str	r2, [r3, #12]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = __sch_ready_ahead(otp);
 8004b76:	9804      	ldr	r0, [sp, #16]
 8004b78:	f7ff ffb2 	bl	8004ae0 <__sch_ready_ahead>
 8004b7c:	9004      	str	r0, [sp, #16]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8004b7e:	9904      	ldr	r1, [sp, #16]
 8004b80:	9803      	ldr	r0, [sp, #12]
 8004b82:	f7ff fa55 	bl	8004030 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004b86:	f3ef 8309 	mrs	r3, PSP
 8004b8a:	9301      	str	r3, [sp, #4]
  return(result);
 8004b8c:	9b01      	ldr	r3, [sp, #4]
 8004b8e:	9302      	str	r3, [sp, #8]
 8004b90:	9b02      	ldr	r3, [sp, #8]
 8004b92:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8004b96:	9b04      	ldr	r3, [sp, #16]
 8004b98:	6a1b      	ldr	r3, [r3, #32]
 8004b9a:	429a      	cmp	r2, r3
 8004b9c:	d202      	bcs.n	8004ba4 <__sch_reschedule_ahead+0x54>
 8004b9e:	4806      	ldr	r0, [pc, #24]	@ (8004bb8 <__sch_reschedule_ahead+0x68>)
 8004ba0:	f7fe ffbe 	bl	8003b20 <chSysHalt>
 8004ba4:	9904      	ldr	r1, [sp, #16]
 8004ba6:	9803      	ldr	r0, [sp, #12]
 8004ba8:	f7fb fc0a 	bl	80003c0 <__port_switch>
}
 8004bac:	bf00      	nop
 8004bae:	b007      	add	sp, #28
 8004bb0:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bb4:	24000158 	.word	0x24000158
 8004bb8:	08006ec0 	.word	0x08006ec0
 8004bbc:	00000000 	.word	0x00000000

08004bc0 <__sch_wakeup>:

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8004bc0:	b500      	push	{lr}
 8004bc2:	b085      	sub	sp, #20
 8004bc4:	9001      	str	r0, [sp, #4]
 8004bc6:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 8004bc8:	9b00      	ldr	r3, [sp, #0]
 8004bca:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 8004bcc:	f7ff ff10 	bl	80049f0 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
 8004bd0:	9b03      	ldr	r3, [sp, #12]
 8004bd2:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8004bd6:	2b0c      	cmp	r3, #12
 8004bd8:	d82e      	bhi.n	8004c38 <__sch_wakeup+0x78>
 8004bda:	a201      	add	r2, pc, #4	@ (adr r2, 8004be0 <__sch_wakeup+0x20>)
 8004bdc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004be0:	08004c15 	.word	0x08004c15
 8004be4:	08004c39 	.word	0x08004c39
 8004be8:	08004c39 	.word	0x08004c39
 8004bec:	08004c1b 	.word	0x08004c1b
 8004bf0:	08004c2f 	.word	0x08004c2f
 8004bf4:	08004c25 	.word	0x08004c25
 8004bf8:	08004c39 	.word	0x08004c39
 8004bfc:	08004c2f 	.word	0x08004c2f
 8004c00:	08004c39 	.word	0x08004c39
 8004c04:	08004c39 	.word	0x08004c39
 8004c08:	08004c39 	.word	0x08004c39
 8004c0c:	08004c39 	.word	0x08004c39
 8004c10:	08004c2f 	.word	0x08004c2f
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8004c14:	f7ff fefc 	bl	8004a10 <chSysUnlockFromISR.lto_priv.4>
    return;
 8004c18:	e019      	b.n	8004c4e <__sch_wakeup+0x8e>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8004c1a:	9b03      	ldr	r3, [sp, #12]
 8004c1c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004c1e:	2200      	movs	r2, #0
 8004c20:	601a      	str	r2, [r3, #0]
    break;
 8004c22:	e00a      	b.n	8004c3a <__sch_wakeup+0x7a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8004c24:	9b03      	ldr	r3, [sp, #12]
 8004c26:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004c28:	4618      	mov	r0, r3
 8004c2a:	f7ff ff11 	bl	8004a50 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 8004c2e:	9b03      	ldr	r3, [sp, #12]
 8004c30:	4618      	mov	r0, r3
 8004c32:	f7ff fe65 	bl	8004900 <ch_queue_dequeue.lto_priv.0>
    break;
 8004c36:	e000      	b.n	8004c3a <__sch_wakeup+0x7a>
  default:
    /* Any other state, nothing to do.*/
    break;
 8004c38:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 8004c3a:	9b03      	ldr	r3, [sp, #12]
 8004c3c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8004c40:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 8004c42:	9803      	ldr	r0, [sp, #12]
 8004c44:	f7ff ff14 	bl	8004a70 <__sch_ready_behind>
  chSysUnlockFromISR();
 8004c48:	f7ff fee2 	bl	8004a10 <chSysUnlockFromISR.lto_priv.4>

  return;
 8004c4c:	bf00      	nop
}
 8004c4e:	b005      	add	sp, #20
 8004c50:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004c60 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8004c60:	b500      	push	{lr}
 8004c62:	b083      	sub	sp, #12
 8004c64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8004c66:	f7ff f8fb 	bl	8003e60 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8004c6a:	9b01      	ldr	r3, [sp, #4]
 8004c6c:	2b00      	cmp	r3, #0
 8004c6e:	bf0c      	ite	eq
 8004c70:	2301      	moveq	r3, #1
 8004c72:	2300      	movne	r3, #0
 8004c74:	b2db      	uxtb	r3, r3
 8004c76:	2b00      	cmp	r3, #0
 8004c78:	d002      	beq.n	8004c80 <chSchReadyI+0x20>
 8004c7a:	4805      	ldr	r0, [pc, #20]	@ (8004c90 <chSchReadyI+0x30>)
 8004c7c:	f7fe ff50 	bl	8003b20 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 8004c80:	9801      	ldr	r0, [sp, #4]
 8004c82:	f7ff fef5 	bl	8004a70 <__sch_ready_behind>
 8004c86:	4603      	mov	r3, r0
}
 8004c88:	4618      	mov	r0, r3
 8004c8a:	b003      	add	sp, #12
 8004c8c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c90:	08006f88 	.word	0x08006f88
	...

08004ca0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8004ca0:	b500      	push	{lr}
 8004ca2:	b089      	sub	sp, #36	@ 0x24
 8004ca4:	4603      	mov	r3, r0
 8004ca6:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
 8004caa:	4b27      	ldr	r3, [pc, #156]	@ (8004d48 <chSchGoSleepS+0xa8>)
 8004cac:	9307      	str	r3, [sp, #28]
  thread_t *otp = __instance_get_currthread(oip);
 8004cae:	9b07      	ldr	r3, [sp, #28]
 8004cb0:	68db      	ldr	r3, [r3, #12]
 8004cb2:	9306      	str	r3, [sp, #24]
  thread_t *ntp;

  chDbgCheckClassS();
 8004cb4:	f7ff f8f4 	bl	8003ea0 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 8004cb8:	f7fe ff4a 	bl	8003b50 <chSysGetIdleThreadX>
 8004cbc:	4602      	mov	r2, r0
 8004cbe:	9b06      	ldr	r3, [sp, #24]
 8004cc0:	4293      	cmp	r3, r2
 8004cc2:	bf0c      	ite	eq
 8004cc4:	2301      	moveq	r3, #1
 8004cc6:	2300      	movne	r3, #0
 8004cc8:	b2db      	uxtb	r3, r3
 8004cca:	2b00      	cmp	r3, #0
 8004ccc:	d002      	beq.n	8004cd4 <chSchGoSleepS+0x34>
 8004cce:	481f      	ldr	r0, [pc, #124]	@ (8004d4c <chSchGoSleepS+0xac>)
 8004cd0:	f7fe ff26 	bl	8003b20 <chSysHalt>
  chDbgAssert(otp->owner == oip, "invalid core");
 8004cd4:	9b06      	ldr	r3, [sp, #24]
 8004cd6:	699b      	ldr	r3, [r3, #24]
 8004cd8:	9a07      	ldr	r2, [sp, #28]
 8004cda:	429a      	cmp	r2, r3
 8004cdc:	bf14      	ite	ne
 8004cde:	2301      	movne	r3, #1
 8004ce0:	2300      	moveq	r3, #0
 8004ce2:	b2db      	uxtb	r3, r3
 8004ce4:	2b00      	cmp	r3, #0
 8004ce6:	d002      	beq.n	8004cee <chSchGoSleepS+0x4e>
 8004ce8:	4818      	ldr	r0, [pc, #96]	@ (8004d4c <chSchGoSleepS+0xac>)
 8004cea:	f7fe ff19 	bl	8003b20 <chSysHalt>

  /* New state.*/
  otp->state = newstate;
 8004cee:	9b06      	ldr	r3, [sp, #24]
 8004cf0:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8004cf4:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8004cf8:	9b07      	ldr	r3, [sp, #28]
 8004cfa:	4618      	mov	r0, r3
 8004cfc:	f7ff fe10 	bl	8004920 <ch_pqueue_remove_highest>
 8004d00:	9005      	str	r0, [sp, #20]
  ntp->state = CH_STATE_CURRENT;
 8004d02:	9b05      	ldr	r3, [sp, #20]
 8004d04:	2201      	movs	r2, #1
 8004d06:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8004d0a:	9b07      	ldr	r3, [sp, #28]
 8004d0c:	9a05      	ldr	r2, [sp, #20]
 8004d0e:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8004d10:	9906      	ldr	r1, [sp, #24]
 8004d12:	9805      	ldr	r0, [sp, #20]
 8004d14:	f7ff f98c 	bl	8004030 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004d18:	f3ef 8309 	mrs	r3, PSP
 8004d1c:	9303      	str	r3, [sp, #12]
  return(result);
 8004d1e:	9b03      	ldr	r3, [sp, #12]
 8004d20:	9304      	str	r3, [sp, #16]
 8004d22:	9b04      	ldr	r3, [sp, #16]
 8004d24:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8004d28:	9b06      	ldr	r3, [sp, #24]
 8004d2a:	6a1b      	ldr	r3, [r3, #32]
 8004d2c:	429a      	cmp	r2, r3
 8004d2e:	d202      	bcs.n	8004d36 <chSchGoSleepS+0x96>
 8004d30:	4807      	ldr	r0, [pc, #28]	@ (8004d50 <chSchGoSleepS+0xb0>)
 8004d32:	f7fe fef5 	bl	8003b20 <chSysHalt>
 8004d36:	9906      	ldr	r1, [sp, #24]
 8004d38:	9805      	ldr	r0, [sp, #20]
 8004d3a:	f7fb fb41 	bl	80003c0 <__port_switch>
}
 8004d3e:	bf00      	nop
 8004d40:	b009      	add	sp, #36	@ 0x24
 8004d42:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d46:	bf00      	nop
 8004d48:	24000158 	.word	0x24000158
 8004d4c:	08006f94 	.word	0x08006f94
 8004d50:	08006ec0 	.word	0x08006ec0
	...

08004d60 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8004d60:	b500      	push	{lr}
 8004d62:	b08b      	sub	sp, #44	@ 0x2c
 8004d64:	4603      	mov	r3, r0
 8004d66:	9100      	str	r1, [sp, #0]
 8004d68:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 8004d6c:	4b15      	ldr	r3, [pc, #84]	@ (8004dc4 <chSchGoSleepTimeoutS+0x64>)
 8004d6e:	68db      	ldr	r3, [r3, #12]
 8004d70:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();
 8004d72:	f7ff f895 	bl	8003ea0 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 8004d76:	9b00      	ldr	r3, [sp, #0]
 8004d78:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8004d7c:	d016      	beq.n	8004dac <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 8004d7e:	a803      	add	r0, sp, #12
 8004d80:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8004d82:	4a11      	ldr	r2, [pc, #68]	@ (8004dc8 <chSchGoSleepTimeoutS+0x68>)
 8004d84:	9900      	ldr	r1, [sp, #0]
 8004d86:	f7ff fc53 	bl	8004630 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8004d8a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004d8e:	4618      	mov	r0, r3
 8004d90:	f7ff ff86 	bl	8004ca0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8004d94:	ab03      	add	r3, sp, #12
 8004d96:	4618      	mov	r0, r3
 8004d98:	f7ff fe4a 	bl	8004a30 <chVTIsArmedI.lto_priv.1>
 8004d9c:	4603      	mov	r3, r0
 8004d9e:	2b00      	cmp	r3, #0
 8004da0:	d009      	beq.n	8004db6 <chSchGoSleepTimeoutS+0x56>
      chVTDoResetI(&vt);
 8004da2:	ab03      	add	r3, sp, #12
 8004da4:	4618      	mov	r0, r3
 8004da6:	f7ff fc83 	bl	80046b0 <chVTDoResetI>
 8004daa:	e004      	b.n	8004db6 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8004dac:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004db0:	4618      	mov	r0, r3
 8004db2:	f7ff ff75 	bl	8004ca0 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 8004db6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8004db8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
}
 8004dba:	4618      	mov	r0, r3
 8004dbc:	b00b      	add	sp, #44	@ 0x2c
 8004dbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004dc2:	bf00      	nop
 8004dc4:	24000158 	.word	0x24000158
 8004dc8:	08004bc1 	.word	0x08004bc1
 8004dcc:	00000000 	.word	0x00000000

08004dd0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8004dd0:	b500      	push	{lr}
 8004dd2:	b087      	sub	sp, #28
 8004dd4:	9001      	str	r0, [sp, #4]
 8004dd6:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8004dd8:	4b2c      	ldr	r3, [pc, #176]	@ (8004e8c <chSchWakeupS+0xbc>)
 8004dda:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 8004ddc:	9b05      	ldr	r3, [sp, #20]
 8004dde:	68db      	ldr	r3, [r3, #12]
 8004de0:	9304      	str	r3, [sp, #16]

  chDbgCheckClassS();
 8004de2:	f7ff f85d 	bl	8003ea0 <chDbgCheckClassS>

  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8004de6:	9b05      	ldr	r3, [sp, #20]
 8004de8:	681a      	ldr	r2, [r3, #0]
 8004dea:	9b05      	ldr	r3, [sp, #20]
 8004dec:	429a      	cmp	r2, r3
 8004dee:	bf14      	ite	ne
 8004df0:	2301      	movne	r3, #1
 8004df2:	2300      	moveq	r3, #0
 8004df4:	b2db      	uxtb	r3, r3
 8004df6:	2b00      	cmp	r3, #0
 8004df8:	d00f      	beq.n	8004e1a <chSchWakeupS+0x4a>
 8004dfa:	9b05      	ldr	r3, [sp, #20]
 8004dfc:	68db      	ldr	r3, [r3, #12]
 8004dfe:	689a      	ldr	r2, [r3, #8]
 8004e00:	9b05      	ldr	r3, [sp, #20]
 8004e02:	681b      	ldr	r3, [r3, #0]
 8004e04:	689b      	ldr	r3, [r3, #8]
 8004e06:	429a      	cmp	r2, r3
 8004e08:	bf34      	ite	cc
 8004e0a:	2301      	movcc	r3, #1
 8004e0c:	2300      	movcs	r3, #0
 8004e0e:	b2db      	uxtb	r3, r3
 8004e10:	2b00      	cmp	r3, #0
 8004e12:	d002      	beq.n	8004e1a <chSchWakeupS+0x4a>
 8004e14:	481e      	ldr	r0, [pc, #120]	@ (8004e90 <chSchWakeupS+0xc0>)
 8004e16:	f7fe fe83 	bl	8003b20 <chSysHalt>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8004e1a:	9b01      	ldr	r3, [sp, #4]
 8004e1c:	9a00      	ldr	r2, [sp, #0]
 8004e1e:	629a      	str	r2, [r3, #40]	@ 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8004e20:	9b01      	ldr	r3, [sp, #4]
 8004e22:	689a      	ldr	r2, [r3, #8]
 8004e24:	9b04      	ldr	r3, [sp, #16]
 8004e26:	689b      	ldr	r3, [r3, #8]
 8004e28:	429a      	cmp	r2, r3
 8004e2a:	bf94      	ite	ls
 8004e2c:	2301      	movls	r3, #1
 8004e2e:	2300      	movhi	r3, #0
 8004e30:	b2db      	uxtb	r3, r3
 8004e32:	2b00      	cmp	r3, #0
 8004e34:	d003      	beq.n	8004e3e <chSchWakeupS+0x6e>
    (void) __sch_ready_behind(ntp);
 8004e36:	9801      	ldr	r0, [sp, #4]
 8004e38:	f7ff fe1a 	bl	8004a70 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8004e3c:	e021      	b.n	8004e82 <chSchWakeupS+0xb2>
    otp = __sch_ready_ahead(otp);
 8004e3e:	9804      	ldr	r0, [sp, #16]
 8004e40:	f7ff fe4e 	bl	8004ae0 <__sch_ready_ahead>
 8004e44:	9004      	str	r0, [sp, #16]
    ntp->state = CH_STATE_CURRENT;
 8004e46:	9b01      	ldr	r3, [sp, #4]
 8004e48:	2201      	movs	r2, #1
 8004e4a:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    __instance_set_currthread(oip, ntp);
 8004e4e:	9b05      	ldr	r3, [sp, #20]
 8004e50:	9a01      	ldr	r2, [sp, #4]
 8004e52:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 8004e54:	9904      	ldr	r1, [sp, #16]
 8004e56:	9801      	ldr	r0, [sp, #4]
 8004e58:	f7ff f8ea 	bl	8004030 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004e5c:	f3ef 8309 	mrs	r3, PSP
 8004e60:	9302      	str	r3, [sp, #8]
  return(result);
 8004e62:	9b02      	ldr	r3, [sp, #8]
 8004e64:	9303      	str	r3, [sp, #12]
 8004e66:	9b03      	ldr	r3, [sp, #12]
 8004e68:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8004e6c:	9b04      	ldr	r3, [sp, #16]
 8004e6e:	6a1b      	ldr	r3, [r3, #32]
 8004e70:	429a      	cmp	r2, r3
 8004e72:	d202      	bcs.n	8004e7a <chSchWakeupS+0xaa>
 8004e74:	4807      	ldr	r0, [pc, #28]	@ (8004e94 <chSchWakeupS+0xc4>)
 8004e76:	f7fe fe53 	bl	8003b20 <chSysHalt>
 8004e7a:	9904      	ldr	r1, [sp, #16]
 8004e7c:	9801      	ldr	r0, [sp, #4]
 8004e7e:	f7fb fa9f 	bl	80003c0 <__port_switch>
}
 8004e82:	bf00      	nop
 8004e84:	b007      	add	sp, #28
 8004e86:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e8a:	bf00      	nop
 8004e8c:	24000158 	.word	0x24000158
 8004e90:	08006fa4 	.word	0x08006fa4
 8004e94:	08006ec0 	.word	0x08006ec0
	...

08004ea0 <chSchRescheduleS>:
 * @note    Only local threads are considered, other cores are signaled
 *          and perform a reschedule locally.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8004ea0:	b500      	push	{lr}
 8004ea2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8004ea4:	4b0c      	ldr	r3, [pc, #48]	@ (8004ed8 <chSchRescheduleS+0x38>)
 8004ea6:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
 8004ea8:	9b01      	ldr	r3, [sp, #4]
 8004eaa:	68db      	ldr	r3, [r3, #12]
 8004eac:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();
 8004eae:	f7fe fff7 	bl	8003ea0 <chDbgCheckClassS>

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 8004eb2:	9b01      	ldr	r3, [sp, #4]
 8004eb4:	681b      	ldr	r3, [r3, #0]
 8004eb6:	689a      	ldr	r2, [r3, #8]
 8004eb8:	9b00      	ldr	r3, [sp, #0]
 8004eba:	689b      	ldr	r3, [r3, #8]
 8004ebc:	429a      	cmp	r2, r3
 8004ebe:	bf8c      	ite	hi
 8004ec0:	2301      	movhi	r3, #1
 8004ec2:	2300      	movls	r3, #0
 8004ec4:	b2db      	uxtb	r3, r3
 8004ec6:	2b00      	cmp	r3, #0
 8004ec8:	d001      	beq.n	8004ece <chSchRescheduleS+0x2e>
    __sch_reschedule_ahead();
 8004eca:	f7ff fe41 	bl	8004b50 <__sch_reschedule_ahead>
  }
}
 8004ece:	bf00      	nop
 8004ed0:	b003      	add	sp, #12
 8004ed2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ed6:	bf00      	nop
 8004ed8:	24000158 	.word	0x24000158
 8004edc:	00000000 	.word	0x00000000

08004ee0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8004ee0:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 8004ee2:	4b0b      	ldr	r3, [pc, #44]	@ (8004f10 <chSchIsPreemptionRequired+0x30>)
 8004ee4:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 8004ee6:	9b03      	ldr	r3, [sp, #12]
 8004ee8:	68db      	ldr	r3, [r3, #12]
 8004eea:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8004eec:	9b03      	ldr	r3, [sp, #12]
 8004eee:	681b      	ldr	r3, [r3, #0]
 8004ef0:	689b      	ldr	r3, [r3, #8]
 8004ef2:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8004ef4:	9b02      	ldr	r3, [sp, #8]
 8004ef6:	689b      	ldr	r3, [r3, #8]
 8004ef8:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8004efa:	9a01      	ldr	r2, [sp, #4]
 8004efc:	9b00      	ldr	r3, [sp, #0]
 8004efe:	429a      	cmp	r2, r3
 8004f00:	bf8c      	ite	hi
 8004f02:	2301      	movhi	r3, #1
 8004f04:	2300      	movls	r3, #0
 8004f06:	b2db      	uxtb	r3, r3
#endif
}
 8004f08:	4618      	mov	r0, r3
 8004f0a:	b004      	add	sp, #16
 8004f0c:	4770      	bx	lr
 8004f0e:	bf00      	nop
 8004f10:	24000158 	.word	0x24000158
	...

08004f20 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8004f20:	b500      	push	{lr}
 8004f22:	b087      	sub	sp, #28
  os_instance_t *oip = currcore;
 8004f24:	4b17      	ldr	r3, [pc, #92]	@ (8004f84 <chSchDoPreemption+0x64>)
 8004f26:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 8004f28:	9b05      	ldr	r3, [sp, #20]
 8004f2a:	68db      	ldr	r3, [r3, #12]
 8004f2c:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8004f2e:	9b05      	ldr	r3, [sp, #20]
 8004f30:	4618      	mov	r0, r3
 8004f32:	f7ff fcf5 	bl	8004920 <ch_pqueue_remove_highest>
 8004f36:	9003      	str	r0, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 8004f38:	9b03      	ldr	r3, [sp, #12]
 8004f3a:	2201      	movs	r2, #1
 8004f3c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  __instance_set_currthread(oip, ntp);
 8004f40:	9b05      	ldr	r3, [sp, #20]
 8004f42:	9a03      	ldr	r2, [sp, #12]
 8004f44:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 8004f46:	9804      	ldr	r0, [sp, #16]
 8004f48:	f7ff fdca 	bl	8004ae0 <__sch_ready_ahead>
 8004f4c:	9004      	str	r0, [sp, #16]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8004f4e:	9904      	ldr	r1, [sp, #16]
 8004f50:	9803      	ldr	r0, [sp, #12]
 8004f52:	f7ff f86d 	bl	8004030 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004f56:	f3ef 8309 	mrs	r3, PSP
 8004f5a:	9301      	str	r3, [sp, #4]
  return(result);
 8004f5c:	9b01      	ldr	r3, [sp, #4]
 8004f5e:	9302      	str	r3, [sp, #8]
 8004f60:	9b02      	ldr	r3, [sp, #8]
 8004f62:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8004f66:	9b04      	ldr	r3, [sp, #16]
 8004f68:	6a1b      	ldr	r3, [r3, #32]
 8004f6a:	429a      	cmp	r2, r3
 8004f6c:	d202      	bcs.n	8004f74 <chSchDoPreemption+0x54>
 8004f6e:	4806      	ldr	r0, [pc, #24]	@ (8004f88 <chSchDoPreemption+0x68>)
 8004f70:	f7fe fdd6 	bl	8003b20 <chSysHalt>
 8004f74:	9904      	ldr	r1, [sp, #16]
 8004f76:	9803      	ldr	r0, [sp, #12]
 8004f78:	f7fb fa22 	bl	80003c0 <__port_switch>
}
 8004f7c:	bf00      	nop
 8004f7e:	b007      	add	sp, #28
 8004f80:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f84:	24000158 	.word	0x24000158
 8004f88:	08006ec0 	.word	0x08006ec0
 8004f8c:	00000000 	.word	0x00000000

08004f90 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 8004f90:	b082      	sub	sp, #8
 8004f92:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 8004f94:	9b01      	ldr	r3, [sp, #4]
 8004f96:	2200      	movs	r2, #0
 8004f98:	601a      	str	r2, [r3, #0]
}
 8004f9a:	bf00      	nop
 8004f9c:	b002      	add	sp, #8
 8004f9e:	4770      	bx	lr

08004fa0 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 8004fa0:	b082      	sub	sp, #8
 8004fa2:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 8004fa4:	9b01      	ldr	r3, [sp, #4]
 8004fa6:	2200      	movs	r2, #0
 8004fa8:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 8004faa:	9b01      	ldr	r3, [sp, #4]
 8004fac:	2200      	movs	r2, #0
 8004fae:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 8004fb0:	9b01      	ldr	r3, [sp, #4]
 8004fb2:	2201      	movs	r2, #1
 8004fb4:	609a      	str	r2, [r3, #8]
#endif
}
 8004fb6:	bf00      	nop
 8004fb8:	b002      	add	sp, #8
 8004fba:	4770      	bx	lr
 8004fbc:	0000      	movs	r0, r0
	...

08004fc0 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004fc0:	b082      	sub	sp, #8
 8004fc2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004fc4:	9b01      	ldr	r3, [sp, #4]
 8004fc6:	9a01      	ldr	r2, [sp, #4]
 8004fc8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8004fca:	9b01      	ldr	r3, [sp, #4]
 8004fcc:	9a01      	ldr	r2, [sp, #4]
 8004fce:	605a      	str	r2, [r3, #4]
}
 8004fd0:	bf00      	nop
 8004fd2:	b002      	add	sp, #8
 8004fd4:	4770      	bx	lr
 8004fd6:	bf00      	nop
	...

08004fe0 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 8004fe0:	b082      	sub	sp, #8
 8004fe2:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 8004fe4:	9b01      	ldr	r3, [sp, #4]
 8004fe6:	9a01      	ldr	r2, [sp, #4]
 8004fe8:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 8004fea:	9b01      	ldr	r3, [sp, #4]
 8004fec:	9a01      	ldr	r2, [sp, #4]
 8004fee:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 8004ff0:	9b01      	ldr	r3, [sp, #4]
 8004ff2:	2200      	movs	r2, #0
 8004ff4:	609a      	str	r2, [r3, #8]
}
 8004ff6:	bf00      	nop
 8004ff8:	b002      	add	sp, #8
 8004ffa:	4770      	bx	lr
 8004ffc:	0000      	movs	r0, r0
	...

08005000 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 8005000:	b082      	sub	sp, #8
 8005002:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 8005004:	9b01      	ldr	r3, [sp, #4]
 8005006:	9a01      	ldr	r2, [sp, #4]
 8005008:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 800500a:	9b01      	ldr	r3, [sp, #4]
 800500c:	9a01      	ldr	r2, [sp, #4]
 800500e:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 8005010:	9b01      	ldr	r3, [sp, #4]
 8005012:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8005016:	609a      	str	r2, [r3, #8]
}
 8005018:	bf00      	nop
 800501a:	b002      	add	sp, #8
 800501c:	4770      	bx	lr
 800501e:	bf00      	nop

08005020 <port_timer_get_time.lto_priv.2>:
static inline systime_t port_timer_get_time(void) {
 8005020:	b508      	push	{r3, lr}
  return stGetCounter();
 8005022:	f7fb fb65 	bl	80006f0 <stGetCounter>
 8005026:	4603      	mov	r3, r0
}
 8005028:	4618      	mov	r0, r3
 800502a:	bd08      	pop	{r3, pc}
 800502c:	0000      	movs	r0, r0
	...

08005030 <chVTGetSystemTimeX.lto_priv.2>:
static inline systime_t chVTGetSystemTimeX(void) {
 8005030:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8005032:	f7ff fff5 	bl	8005020 <port_timer_get_time.lto_priv.2>
 8005036:	4603      	mov	r3, r0
}
 8005038:	4618      	mov	r0, r3
 800503a:	bd08      	pop	{r3, pc}
 800503c:	0000      	movs	r0, r0
	...

08005040 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 8005040:	b530      	push	{r4, r5, lr}
 8005042:	b083      	sub	sp, #12
 8005044:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 8005046:	9b01      	ldr	r3, [sp, #4]
 8005048:	4618      	mov	r0, r3
 800504a:	f7ff ffd9 	bl	8005000 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 800504e:	9b01      	ldr	r3, [sp, #4]
 8005050:	2200      	movs	r2, #0
 8005052:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8005054:	f7ff ffec 	bl	8005030 <chVTGetSystemTimeX.lto_priv.2>
 8005058:	4603      	mov	r3, r0
 800505a:	2200      	movs	r2, #0
 800505c:	461c      	mov	r4, r3
 800505e:	4615      	mov	r5, r2
 8005060:	9b01      	ldr	r3, [sp, #4]
 8005062:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 8005066:	bf00      	nop
 8005068:	b003      	add	sp, #12
 800506a:	bd30      	pop	{r4, r5, pc}
 800506c:	0000      	movs	r0, r0
	...

08005070 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8005070:	b500      	push	{lr}
 8005072:	b083      	sub	sp, #12
 8005074:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 8005076:	9b01      	ldr	r3, [sp, #4]
 8005078:	4618      	mov	r0, r3
 800507a:	f7ff ffa1 	bl	8004fc0 <ch_queue_init.lto_priv.2>
}
 800507e:	bf00      	nop
 8005080:	b003      	add	sp, #12
 8005082:	f85d fb04 	ldr.w	pc, [sp], #4
 8005086:	bf00      	nop
	...

08005090 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8005090:	b082      	sub	sp, #8
 8005092:	9001      	str	r0, [sp, #4]
}
 8005094:	bf00      	nop
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
    asm volatile ("nop");
 8005096:	bf00      	nop
    port_wait_for_interrupt();
 8005098:	bf00      	nop
 800509a:	e7fb      	b.n	8005094 <__idle_thread+0x4>
 800509c:	0000      	movs	r0, r0
	...

080050a0 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 80050a0:	b500      	push	{lr}
 80050a2:	b08b      	sub	sp, #44	@ 0x2c
 80050a4:	9001      	str	r0, [sp, #4]
 80050a6:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 80050a8:	2300      	movs	r3, #0
 80050aa:	9309      	str	r3, [sp, #36]	@ 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 80050ac:	4a35      	ldr	r2, [pc, #212]	@ (8005184 <chInstanceObjectInit+0xe4>)
 80050ae:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80050b0:	009b      	lsls	r3, r3, #2
 80050b2:	4413      	add	r3, r2
 80050b4:	685b      	ldr	r3, [r3, #4]
 80050b6:	2b00      	cmp	r3, #0
 80050b8:	bf14      	ite	ne
 80050ba:	2301      	movne	r3, #1
 80050bc:	2300      	moveq	r3, #0
 80050be:	b2db      	uxtb	r3, r3
 80050c0:	2b00      	cmp	r3, #0
 80050c2:	d002      	beq.n	80050ca <chInstanceObjectInit+0x2a>
 80050c4:	4830      	ldr	r0, [pc, #192]	@ (8005188 <chInstanceObjectInit+0xe8>)
 80050c6:	f7fe fd2b 	bl	8003b20 <chSysHalt>
  ch_system.instances[core_id] = oip;
 80050ca:	4a2e      	ldr	r2, [pc, #184]	@ (8005184 <chInstanceObjectInit+0xe4>)
 80050cc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80050ce:	009b      	lsls	r3, r3, #2
 80050d0:	4413      	add	r3, r2
 80050d2:	9a01      	ldr	r2, [sp, #4]
 80050d4:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 80050d6:	9b01      	ldr	r3, [sp, #4]
 80050d8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80050da:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 80050dc:	9b01      	ldr	r3, [sp, #4]
 80050de:	9a00      	ldr	r2, [sp, #0]
 80050e0:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 80050e2:	9801      	ldr	r0, [sp, #4]
 80050e4:	f001 fa64 	bl	80065b0 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 80050e8:	9b01      	ldr	r3, [sp, #4]
 80050ea:	4618      	mov	r0, r3
 80050ec:	f7ff ff78 	bl	8004fe0 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 80050f0:	9b01      	ldr	r3, [sp, #4]
 80050f2:	3328      	adds	r3, #40	@ 0x28
 80050f4:	4618      	mov	r0, r3
 80050f6:	f7ff ffbb 	bl	8005070 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 80050fa:	9b01      	ldr	r3, [sp, #4]
 80050fc:	3334      	adds	r3, #52	@ 0x34
 80050fe:	4618      	mov	r0, r3
 8005100:	f7ff ff46 	bl	8004f90 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8005104:	9b01      	ldr	r3, [sp, #4]
 8005106:	3310      	adds	r3, #16
 8005108:	4618      	mov	r0, r3
 800510a:	f7ff ff99 	bl	8005040 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 800510e:	9b01      	ldr	r3, [sp, #4]
 8005110:	3384      	adds	r3, #132	@ 0x84
 8005112:	4618      	mov	r0, r3
 8005114:	f7ff ff44 	bl	8004fa0 <__dbg_object_init>

#if CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED
  /* Trace buffer initialization.*/
  __trace_object_init(&oip->trace_buffer);
 8005118:	9b01      	ldr	r3, [sp, #4]
 800511a:	3390      	adds	r3, #144	@ 0x90
 800511c:	4618      	mov	r0, r3
 800511e:	f7fe ff27 	bl	8003f70 <__trace_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8005122:	9b01      	ldr	r3, [sp, #4]
 8005124:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 8005128:	2380      	movs	r3, #128	@ 0x80
 800512a:	4a18      	ldr	r2, [pc, #96]	@ (800518c <chInstanceObjectInit+0xec>)
 800512c:	9801      	ldr	r0, [sp, #4]
 800512e:	f000 f8ff 	bl	8005330 <__thd_object_init>
 8005132:	4602      	mov	r2, r0
 8005134:	9b01      	ldr	r3, [sp, #4]
 8005136:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 8005138:	9b01      	ldr	r3, [sp, #4]
 800513a:	68db      	ldr	r3, [r3, #12]
 800513c:	9a00      	ldr	r2, [sp, #0]
 800513e:	6852      	ldr	r2, [r2, #4]
 8005140:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8005142:	9b01      	ldr	r3, [sp, #4]
 8005144:	68db      	ldr	r3, [r3, #12]
 8005146:	2201      	movs	r2, #1
 8005148:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 800514c:	4b10      	ldr	r3, [pc, #64]	@ (8005190 <chInstanceObjectInit+0xf0>)
 800514e:	9303      	str	r3, [sp, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8005150:	9b00      	ldr	r3, [sp, #0]
 8005152:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 8005154:	9304      	str	r3, [sp, #16]
      .wend     = oicp->idlethread_end,
 8005156:	9b00      	ldr	r3, [sp, #0]
 8005158:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 800515a:	9305      	str	r3, [sp, #20]
 800515c:	2301      	movs	r3, #1
 800515e:	9306      	str	r3, [sp, #24]
 8005160:	4b0c      	ldr	r3, [pc, #48]	@ (8005194 <chInstanceObjectInit+0xf4>)
 8005162:	9307      	str	r3, [sp, #28]
 8005164:	2300      	movs	r3, #0
 8005166:	9308      	str	r3, [sp, #32]
      .funcp    = __idle_thread,
      .arg      = NULL
    };

#if CH_DBG_FILL_THREADS == TRUE
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 8005168:	9b04      	ldr	r3, [sp, #16]
                    (uint8_t *)idle_descriptor.wend);
 800516a:	9a05      	ldr	r2, [sp, #20]
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 800516c:	4611      	mov	r1, r2
 800516e:	4618      	mov	r0, r3
 8005170:	f000 f91e 	bl	80053b0 <__thd_stackfill>
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 8005174:	ab03      	add	r3, sp, #12
 8005176:	4618      	mov	r0, r3
 8005178:	f000 f9c2 	bl	8005500 <chThdCreateI>
  }
#endif
}
 800517c:	bf00      	nop
 800517e:	b00b      	add	sp, #44	@ 0x2c
 8005180:	f85d fb04 	ldr.w	pc, [sp], #4
 8005184:	24000148 	.word	0x24000148
 8005188:	08006fb4 	.word	0x08006fb4
 800518c:	08007064 	.word	0x08007064
 8005190:	08006ed0 	.word	0x08006ed0
 8005194:	08005091 	.word	0x08005091
	...

080051a0 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 80051a0:	b082      	sub	sp, #8
 80051a2:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 80051a4:	9b01      	ldr	r3, [sp, #4]
 80051a6:	9a01      	ldr	r2, [sp, #4]
 80051a8:	601a      	str	r2, [r3, #0]
}
 80051aa:	bf00      	nop
 80051ac:	b002      	add	sp, #8
 80051ae:	4770      	bx	lr

080051b0 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 80051b0:	b082      	sub	sp, #8
 80051b2:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 80051b4:	9b01      	ldr	r3, [sp, #4]
 80051b6:	681b      	ldr	r3, [r3, #0]
 80051b8:	9a01      	ldr	r2, [sp, #4]
 80051ba:	429a      	cmp	r2, r3
 80051bc:	bf14      	ite	ne
 80051be:	2301      	movne	r3, #1
 80051c0:	2300      	moveq	r3, #0
 80051c2:	b2db      	uxtb	r3, r3
}
 80051c4:	4618      	mov	r0, r3
 80051c6:	b002      	add	sp, #8
 80051c8:	4770      	bx	lr
 80051ca:	bf00      	nop
 80051cc:	0000      	movs	r0, r0
	...

080051d0 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 80051d0:	b084      	sub	sp, #16
 80051d2:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 80051d4:	9b01      	ldr	r3, [sp, #4]
 80051d6:	681b      	ldr	r3, [r3, #0]
 80051d8:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 80051da:	9b03      	ldr	r3, [sp, #12]
 80051dc:	681a      	ldr	r2, [r3, #0]
 80051de:	9b01      	ldr	r3, [sp, #4]
 80051e0:	601a      	str	r2, [r3, #0]
  return p;
 80051e2:	9b03      	ldr	r3, [sp, #12]
}
 80051e4:	4618      	mov	r0, r3
 80051e6:	b004      	add	sp, #16
 80051e8:	4770      	bx	lr
 80051ea:	bf00      	nop
 80051ec:	0000      	movs	r0, r0
	...

080051f0 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80051f0:	b082      	sub	sp, #8
 80051f2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80051f4:	9b01      	ldr	r3, [sp, #4]
 80051f6:	9a01      	ldr	r2, [sp, #4]
 80051f8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80051fa:	9b01      	ldr	r3, [sp, #4]
 80051fc:	9a01      	ldr	r2, [sp, #4]
 80051fe:	605a      	str	r2, [r3, #4]
}
 8005200:	bf00      	nop
 8005202:	b002      	add	sp, #8
 8005204:	4770      	bx	lr
 8005206:	bf00      	nop
	...

08005210 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8005210:	b082      	sub	sp, #8
 8005212:	9001      	str	r0, [sp, #4]
 8005214:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 8005216:	9b00      	ldr	r3, [sp, #0]
 8005218:	9a01      	ldr	r2, [sp, #4]
 800521a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 800521c:	9b01      	ldr	r3, [sp, #4]
 800521e:	685a      	ldr	r2, [r3, #4]
 8005220:	9b00      	ldr	r3, [sp, #0]
 8005222:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8005224:	9b00      	ldr	r3, [sp, #0]
 8005226:	685b      	ldr	r3, [r3, #4]
 8005228:	9a00      	ldr	r2, [sp, #0]
 800522a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 800522c:	9b01      	ldr	r3, [sp, #4]
 800522e:	9a00      	ldr	r2, [sp, #0]
 8005230:	605a      	str	r2, [r3, #4]
}
 8005232:	bf00      	nop
 8005234:	b002      	add	sp, #8
 8005236:	4770      	bx	lr
	...

08005240 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8005240:	b082      	sub	sp, #8
 8005242:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8005244:	9b01      	ldr	r3, [sp, #4]
 8005246:	685b      	ldr	r3, [r3, #4]
 8005248:	9a01      	ldr	r2, [sp, #4]
 800524a:	6812      	ldr	r2, [r2, #0]
 800524c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800524e:	9b01      	ldr	r3, [sp, #4]
 8005250:	681b      	ldr	r3, [r3, #0]
 8005252:	9a01      	ldr	r2, [sp, #4]
 8005254:	6852      	ldr	r2, [r2, #4]
 8005256:	605a      	str	r2, [r3, #4]
  return p;
 8005258:	9b01      	ldr	r3, [sp, #4]
}
 800525a:	4618      	mov	r0, r3
 800525c:	b002      	add	sp, #8
 800525e:	4770      	bx	lr

08005260 <chSysLock.lto_priv.8>:
static inline void chSysLock(void) {
 8005260:	b500      	push	{lr}
 8005262:	b083      	sub	sp, #12
 8005264:	2330      	movs	r3, #48	@ 0x30
 8005266:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005268:	9b01      	ldr	r3, [sp, #4]
 800526a:	f383 8811 	msr	BASEPRI, r3
}
 800526e:	bf00      	nop
}
 8005270:	bf00      	nop
  __dbg_check_lock();
 8005272:	f7fe fcdd 	bl	8003c30 <__dbg_check_lock>
}
 8005276:	bf00      	nop
 8005278:	b003      	add	sp, #12
 800527a:	f85d fb04 	ldr.w	pc, [sp], #4
 800527e:	bf00      	nop

08005280 <chSysUnlock.lto_priv.8>:
static inline void chSysUnlock(void) {
 8005280:	b500      	push	{lr}
 8005282:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8005284:	f7fe fcfc 	bl	8003c80 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8005288:	4b12      	ldr	r3, [pc, #72]	@ (80052d4 <chSysUnlock.lto_priv.8+0x54>)
 800528a:	681b      	ldr	r3, [r3, #0]
 800528c:	4a11      	ldr	r2, [pc, #68]	@ (80052d4 <chSysUnlock.lto_priv.8+0x54>)
 800528e:	4293      	cmp	r3, r2
 8005290:	bf14      	ite	ne
 8005292:	2301      	movne	r3, #1
 8005294:	2300      	moveq	r3, #0
 8005296:	b2db      	uxtb	r3, r3
 8005298:	2b00      	cmp	r3, #0
 800529a:	d00f      	beq.n	80052bc <chSysUnlock.lto_priv.8+0x3c>
 800529c:	4b0d      	ldr	r3, [pc, #52]	@ (80052d4 <chSysUnlock.lto_priv.8+0x54>)
 800529e:	68db      	ldr	r3, [r3, #12]
 80052a0:	689a      	ldr	r2, [r3, #8]
 80052a2:	4b0c      	ldr	r3, [pc, #48]	@ (80052d4 <chSysUnlock.lto_priv.8+0x54>)
 80052a4:	681b      	ldr	r3, [r3, #0]
 80052a6:	689b      	ldr	r3, [r3, #8]
 80052a8:	429a      	cmp	r2, r3
 80052aa:	bf34      	ite	cc
 80052ac:	2301      	movcc	r3, #1
 80052ae:	2300      	movcs	r3, #0
 80052b0:	b2db      	uxtb	r3, r3
 80052b2:	2b00      	cmp	r3, #0
 80052b4:	d002      	beq.n	80052bc <chSysUnlock.lto_priv.8+0x3c>
 80052b6:	4808      	ldr	r0, [pc, #32]	@ (80052d8 <chSysUnlock.lto_priv.8+0x58>)
 80052b8:	f7fe fc32 	bl	8003b20 <chSysHalt>
 80052bc:	2300      	movs	r3, #0
 80052be:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80052c0:	9b01      	ldr	r3, [sp, #4]
 80052c2:	f383 8811 	msr	BASEPRI, r3
}
 80052c6:	bf00      	nop
}
 80052c8:	bf00      	nop
}
 80052ca:	bf00      	nop
 80052cc:	b003      	add	sp, #12
 80052ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80052d2:	bf00      	nop
 80052d4:	24000158 	.word	0x24000158
 80052d8:	08006fe4 	.word	0x08006fe4
 80052dc:	00000000 	.word	0x00000000

080052e0 <chThdGetSelfX.lto_priv.0>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 80052e0:	4b01      	ldr	r3, [pc, #4]	@ (80052e8 <chThdGetSelfX.lto_priv.0+0x8>)
 80052e2:	68db      	ldr	r3, [r3, #12]
}
 80052e4:	4618      	mov	r0, r3
 80052e6:	4770      	bx	lr
 80052e8:	24000158 	.word	0x24000158
 80052ec:	00000000 	.word	0x00000000

080052f0 <chThdGetWorkingAreaX.lto_priv.0>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 80052f0:	b082      	sub	sp, #8
 80052f2:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 80052f4:	9b01      	ldr	r3, [sp, #4]
 80052f6:	6a1b      	ldr	r3, [r3, #32]
}
 80052f8:	4618      	mov	r0, r3
 80052fa:	b002      	add	sp, #8
 80052fc:	4770      	bx	lr
 80052fe:	bf00      	nop

08005300 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 8005300:	b500      	push	{lr}
 8005302:	b083      	sub	sp, #12
 8005304:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8005306:	9b01      	ldr	r3, [sp, #4]
 8005308:	2b00      	cmp	r3, #0
 800530a:	bf0c      	ite	eq
 800530c:	2301      	moveq	r3, #1
 800530e:	2300      	movne	r3, #0
 8005310:	b2db      	uxtb	r3, r3
 8005312:	2b00      	cmp	r3, #0
 8005314:	d002      	beq.n	800531c <chThdSleepS+0x1c>
 8005316:	4805      	ldr	r0, [pc, #20]	@ (800532c <chThdSleepS+0x2c>)
 8005318:	f7fe fc02 	bl	8003b20 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800531c:	9901      	ldr	r1, [sp, #4]
 800531e:	2008      	movs	r0, #8
 8005320:	f7ff fd1e 	bl	8004d60 <chSchGoSleepTimeoutS>
}
 8005324:	bf00      	nop
 8005326:	b003      	add	sp, #12
 8005328:	f85d fb04 	ldr.w	pc, [sp], #4
 800532c:	08007020 	.word	0x08007020

08005330 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8005330:	b500      	push	{lr}
 8005332:	b085      	sub	sp, #20
 8005334:	9003      	str	r0, [sp, #12]
 8005336:	9102      	str	r1, [sp, #8]
 8005338:	9201      	str	r2, [sp, #4]
 800533a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 800533c:	9b02      	ldr	r3, [sp, #8]
 800533e:	9a00      	ldr	r2, [sp, #0]
 8005340:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8005342:	9b02      	ldr	r3, [sp, #8]
 8005344:	2202      	movs	r2, #2
 8005346:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 800534a:	9b02      	ldr	r3, [sp, #8]
 800534c:	2200      	movs	r2, #0
 800534e:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  tp->owner             = oip;
 8005352:	9b02      	ldr	r3, [sp, #8]
 8005354:	9a03      	ldr	r2, [sp, #12]
 8005356:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8005358:	9b02      	ldr	r3, [sp, #8]
 800535a:	9a00      	ldr	r2, [sp, #0]
 800535c:	641a      	str	r2, [r3, #64]	@ 0x40
  tp->mtxlist           = NULL;
 800535e:	9b02      	ldr	r3, [sp, #8]
 8005360:	2200      	movs	r2, #0
 8005362:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8005364:	9b02      	ldr	r3, [sp, #8]
 8005366:	2200      	movs	r2, #0
 8005368:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 800536a:	9b02      	ldr	r3, [sp, #8]
 800536c:	2201      	movs	r2, #1
 800536e:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
  tp->name              = name;
 8005372:	9b02      	ldr	r3, [sp, #8]
 8005374:	9a01      	ldr	r2, [sp, #4]
 8005376:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 8005378:	9b03      	ldr	r3, [sp, #12]
 800537a:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 800537e:	9b02      	ldr	r3, [sp, #8]
 8005380:	3310      	adds	r3, #16
 8005382:	4619      	mov	r1, r3
 8005384:	4610      	mov	r0, r2
 8005386:	f7ff ff43 	bl	8005210 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 800538a:	9b02      	ldr	r3, [sp, #8]
 800538c:	332c      	adds	r3, #44	@ 0x2c
 800538e:	4618      	mov	r0, r3
 8005390:	f7ff ff06 	bl	80051a0 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8005394:	9b02      	ldr	r3, [sp, #8]
 8005396:	3330      	adds	r3, #48	@ 0x30
 8005398:	4618      	mov	r0, r3
 800539a:	f7ff ff29 	bl	80051f0 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 800539e:	9b02      	ldr	r3, [sp, #8]
}
 80053a0:	4618      	mov	r0, r3
 80053a2:	b005      	add	sp, #20
 80053a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080053b0 <__thd_stackfill>:
 * @param[in] startp    first address to fill
 * @param[in] endp      last address to fill +1
 *
 * @notapi
 */
void __thd_stackfill(uint8_t *startp, uint8_t *endp) {
 80053b0:	b082      	sub	sp, #8
 80053b2:	9001      	str	r0, [sp, #4]
 80053b4:	9100      	str	r1, [sp, #0]

  do {
    *startp++ = CH_DBG_STACK_FILL_VALUE;
 80053b6:	9b01      	ldr	r3, [sp, #4]
 80053b8:	1c5a      	adds	r2, r3, #1
 80053ba:	9201      	str	r2, [sp, #4]
 80053bc:	2255      	movs	r2, #85	@ 0x55
 80053be:	701a      	strb	r2, [r3, #0]
  } while (likely(startp < endp));
 80053c0:	9a01      	ldr	r2, [sp, #4]
 80053c2:	9b00      	ldr	r3, [sp, #0]
 80053c4:	429a      	cmp	r2, r3
 80053c6:	bf34      	ite	cc
 80053c8:	2301      	movcc	r3, #1
 80053ca:	2300      	movcs	r3, #0
 80053cc:	b2db      	uxtb	r3, r3
 80053ce:	2b00      	cmp	r3, #0
 80053d0:	d1f1      	bne.n	80053b6 <__thd_stackfill+0x6>
}
 80053d2:	bf00      	nop
 80053d4:	bf00      	nop
 80053d6:	b002      	add	sp, #8
 80053d8:	4770      	bx	lr
 80053da:	bf00      	nop
 80053dc:	0000      	movs	r0, r0
	...

080053e0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80053e0:	b500      	push	{lr}
 80053e2:	b085      	sub	sp, #20
 80053e4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 80053e6:	f7fe fd3b 	bl	8003e60 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 80053ea:	9b01      	ldr	r3, [sp, #4]
 80053ec:	2b00      	cmp	r3, #0
 80053ee:	bf0c      	ite	eq
 80053f0:	2301      	moveq	r3, #1
 80053f2:	2300      	movne	r3, #0
 80053f4:	b2db      	uxtb	r3, r3
 80053f6:	2b00      	cmp	r3, #0
 80053f8:	d002      	beq.n	8005400 <chThdCreateSuspendedI+0x20>
 80053fa:	483d      	ldr	r0, [pc, #244]	@ (80054f0 <chThdCreateSuspendedI+0x110>)
 80053fc:	f7fe fb90 	bl	8003b20 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8005400:	9b01      	ldr	r3, [sp, #4]
 8005402:	685b      	ldr	r3, [r3, #4]
 8005404:	f003 0307 	and.w	r3, r3, #7
 8005408:	2b00      	cmp	r3, #0
 800540a:	bf14      	ite	ne
 800540c:	2301      	movne	r3, #1
 800540e:	2300      	moveq	r3, #0
 8005410:	b2db      	uxtb	r3, r3
 8005412:	2b00      	cmp	r3, #0
 8005414:	d10a      	bne.n	800542c <chThdCreateSuspendedI+0x4c>
 8005416:	9b01      	ldr	r3, [sp, #4]
 8005418:	689b      	ldr	r3, [r3, #8]
 800541a:	f003 0307 	and.w	r3, r3, #7
 800541e:	2b00      	cmp	r3, #0
 8005420:	bf14      	ite	ne
 8005422:	2301      	movne	r3, #1
 8005424:	2300      	moveq	r3, #0
 8005426:	b2db      	uxtb	r3, r3
 8005428:	2b00      	cmp	r3, #0
 800542a:	d001      	beq.n	8005430 <chThdCreateSuspendedI+0x50>
 800542c:	2301      	movs	r3, #1
 800542e:	e000      	b.n	8005432 <chThdCreateSuspendedI+0x52>
 8005430:	2300      	movs	r3, #0
 8005432:	2b00      	cmp	r3, #0
 8005434:	d10a      	bne.n	800544c <chThdCreateSuspendedI+0x6c>
 8005436:	9b01      	ldr	r3, [sp, #4]
 8005438:	689a      	ldr	r2, [r3, #8]
 800543a:	9b01      	ldr	r3, [sp, #4]
 800543c:	685b      	ldr	r3, [r3, #4]
 800543e:	429a      	cmp	r2, r3
 8005440:	bf94      	ite	ls
 8005442:	2301      	movls	r3, #1
 8005444:	2300      	movhi	r3, #0
 8005446:	b2db      	uxtb	r3, r3
 8005448:	2b00      	cmp	r3, #0
 800544a:	d001      	beq.n	8005450 <chThdCreateSuspendedI+0x70>
 800544c:	2301      	movs	r3, #1
 800544e:	e000      	b.n	8005452 <chThdCreateSuspendedI+0x72>
 8005450:	2300      	movs	r3, #0
 8005452:	2b00      	cmp	r3, #0
 8005454:	d10c      	bne.n	8005470 <chThdCreateSuspendedI+0x90>
 8005456:	9b01      	ldr	r3, [sp, #4]
 8005458:	689b      	ldr	r3, [r3, #8]
 800545a:	461a      	mov	r2, r3
 800545c:	9b01      	ldr	r3, [sp, #4]
 800545e:	685b      	ldr	r3, [r3, #4]
 8005460:	1ad3      	subs	r3, r2, r3
 8005462:	2bef      	cmp	r3, #239	@ 0xef
 8005464:	bf94      	ite	ls
 8005466:	2301      	movls	r3, #1
 8005468:	2300      	movhi	r3, #0
 800546a:	b2db      	uxtb	r3, r3
 800546c:	2b00      	cmp	r3, #0
 800546e:	d002      	beq.n	8005476 <chThdCreateSuspendedI+0x96>
 8005470:	481f      	ldr	r0, [pc, #124]	@ (80054f0 <chThdCreateSuspendedI+0x110>)
 8005472:	f7fe fb55 	bl	8003b20 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8005476:	9b01      	ldr	r3, [sp, #4]
 8005478:	68db      	ldr	r3, [r3, #12]
 800547a:	2bff      	cmp	r3, #255	@ 0xff
 800547c:	bf8c      	ite	hi
 800547e:	2301      	movhi	r3, #1
 8005480:	2300      	movls	r3, #0
 8005482:	b2db      	uxtb	r3, r3
 8005484:	2b00      	cmp	r3, #0
 8005486:	d108      	bne.n	800549a <chThdCreateSuspendedI+0xba>
 8005488:	9b01      	ldr	r3, [sp, #4]
 800548a:	691b      	ldr	r3, [r3, #16]
 800548c:	2b00      	cmp	r3, #0
 800548e:	bf0c      	ite	eq
 8005490:	2301      	moveq	r3, #1
 8005492:	2300      	movne	r3, #0
 8005494:	b2db      	uxtb	r3, r3
 8005496:	2b00      	cmp	r3, #0
 8005498:	d002      	beq.n	80054a0 <chThdCreateSuspendedI+0xc0>
 800549a:	4815      	ldr	r0, [pc, #84]	@ (80054f0 <chThdCreateSuspendedI+0x110>)
 800549c:	f7fe fb40 	bl	8003b20 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 80054a0:	9b01      	ldr	r3, [sp, #4]
 80054a2:	689b      	ldr	r3, [r3, #8]
 80054a4:	3b48      	subs	r3, #72	@ 0x48
 80054a6:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80054a8:	9b01      	ldr	r3, [sp, #4]
 80054aa:	685a      	ldr	r2, [r3, #4]
 80054ac:	9b03      	ldr	r3, [sp, #12]
 80054ae:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80054b0:	9b03      	ldr	r3, [sp, #12]
 80054b2:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 80054b6:	9b03      	ldr	r3, [sp, #12]
 80054b8:	60da      	str	r2, [r3, #12]
 80054ba:	9b01      	ldr	r3, [sp, #4]
 80054bc:	691a      	ldr	r2, [r3, #16]
 80054be:	9b03      	ldr	r3, [sp, #12]
 80054c0:	68db      	ldr	r3, [r3, #12]
 80054c2:	601a      	str	r2, [r3, #0]
 80054c4:	9b01      	ldr	r3, [sp, #4]
 80054c6:	695a      	ldr	r2, [r3, #20]
 80054c8:	9b03      	ldr	r3, [sp, #12]
 80054ca:	68db      	ldr	r3, [r3, #12]
 80054cc:	605a      	str	r2, [r3, #4]
 80054ce:	9b03      	ldr	r3, [sp, #12]
 80054d0:	68db      	ldr	r3, [r3, #12]
 80054d2:	4a08      	ldr	r2, [pc, #32]	@ (80054f4 <chThdCreateSuspendedI+0x114>)
 80054d4:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 80054d6:	9b01      	ldr	r3, [sp, #4]
 80054d8:	681a      	ldr	r2, [r3, #0]
 80054da:	9b01      	ldr	r3, [sp, #4]
 80054dc:	68db      	ldr	r3, [r3, #12]
 80054de:	9903      	ldr	r1, [sp, #12]
 80054e0:	4805      	ldr	r0, [pc, #20]	@ (80054f8 <chThdCreateSuspendedI+0x118>)
 80054e2:	f7ff ff25 	bl	8005330 <__thd_object_init>
 80054e6:	4603      	mov	r3, r0
}
 80054e8:	4618      	mov	r0, r3
 80054ea:	b005      	add	sp, #20
 80054ec:	f85d fb04 	ldr.w	pc, [sp], #4
 80054f0:	08006fcc 	.word	0x08006fcc
 80054f4:	080003d1 	.word	0x080003d1
 80054f8:	24000158 	.word	0x24000158
 80054fc:	00000000 	.word	0x00000000

08005500 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8005500:	b500      	push	{lr}
 8005502:	b083      	sub	sp, #12
 8005504:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8005506:	9801      	ldr	r0, [sp, #4]
 8005508:	f7ff ff6a 	bl	80053e0 <chThdCreateSuspendedI>
 800550c:	4603      	mov	r3, r0
 800550e:	4618      	mov	r0, r3
 8005510:	f7ff fba6 	bl	8004c60 <chSchReadyI>
 8005514:	4603      	mov	r3, r0
}
 8005516:	4618      	mov	r0, r3
 8005518:	b003      	add	sp, #12
 800551a:	f85d fb04 	ldr.w	pc, [sp], #4
 800551e:	bf00      	nop

08005520 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8005520:	b500      	push	{lr}
 8005522:	b087      	sub	sp, #28
 8005524:	9003      	str	r0, [sp, #12]
 8005526:	9102      	str	r1, [sp, #8]
 8005528:	9201      	str	r2, [sp, #4]
 800552a:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 800552c:	9b03      	ldr	r3, [sp, #12]
 800552e:	2b00      	cmp	r3, #0
 8005530:	bf0c      	ite	eq
 8005532:	2301      	moveq	r3, #1
 8005534:	2300      	movne	r3, #0
 8005536:	b2db      	uxtb	r3, r3
 8005538:	2b00      	cmp	r3, #0
 800553a:	d109      	bne.n	8005550 <chThdCreateStatic+0x30>
 800553c:	9b03      	ldr	r3, [sp, #12]
 800553e:	f003 0307 	and.w	r3, r3, #7
 8005542:	2b00      	cmp	r3, #0
 8005544:	bf14      	ite	ne
 8005546:	2301      	movne	r3, #1
 8005548:	2300      	moveq	r3, #0
 800554a:	b2db      	uxtb	r3, r3
 800554c:	2b00      	cmp	r3, #0
 800554e:	d001      	beq.n	8005554 <chThdCreateStatic+0x34>
 8005550:	2301      	movs	r3, #1
 8005552:	e000      	b.n	8005556 <chThdCreateStatic+0x36>
 8005554:	2300      	movs	r3, #0
 8005556:	2b00      	cmp	r3, #0
 8005558:	d107      	bne.n	800556a <chThdCreateStatic+0x4a>
 800555a:	9b02      	ldr	r3, [sp, #8]
 800555c:	2bef      	cmp	r3, #239	@ 0xef
 800555e:	bf94      	ite	ls
 8005560:	2301      	movls	r3, #1
 8005562:	2300      	movhi	r3, #0
 8005564:	b2db      	uxtb	r3, r3
 8005566:	2b00      	cmp	r3, #0
 8005568:	d001      	beq.n	800556e <chThdCreateStatic+0x4e>
 800556a:	2301      	movs	r3, #1
 800556c:	e000      	b.n	8005570 <chThdCreateStatic+0x50>
 800556e:	2300      	movs	r3, #0
 8005570:	2b00      	cmp	r3, #0
 8005572:	d109      	bne.n	8005588 <chThdCreateStatic+0x68>
 8005574:	9b02      	ldr	r3, [sp, #8]
 8005576:	f003 0307 	and.w	r3, r3, #7
 800557a:	2b00      	cmp	r3, #0
 800557c:	bf14      	ite	ne
 800557e:	2301      	movne	r3, #1
 8005580:	2300      	moveq	r3, #0
 8005582:	b2db      	uxtb	r3, r3
 8005584:	2b00      	cmp	r3, #0
 8005586:	d001      	beq.n	800558c <chThdCreateStatic+0x6c>
 8005588:	2301      	movs	r3, #1
 800558a:	e000      	b.n	800558e <chThdCreateStatic+0x6e>
 800558c:	2300      	movs	r3, #0
 800558e:	2b00      	cmp	r3, #0
 8005590:	d107      	bne.n	80055a2 <chThdCreateStatic+0x82>
 8005592:	9b01      	ldr	r3, [sp, #4]
 8005594:	2bff      	cmp	r3, #255	@ 0xff
 8005596:	bf8c      	ite	hi
 8005598:	2301      	movhi	r3, #1
 800559a:	2300      	movls	r3, #0
 800559c:	b2db      	uxtb	r3, r3
 800559e:	2b00      	cmp	r3, #0
 80055a0:	d001      	beq.n	80055a6 <chThdCreateStatic+0x86>
 80055a2:	2301      	movs	r3, #1
 80055a4:	e000      	b.n	80055a8 <chThdCreateStatic+0x88>
 80055a6:	2300      	movs	r3, #0
 80055a8:	2b00      	cmp	r3, #0
 80055aa:	d107      	bne.n	80055bc <chThdCreateStatic+0x9c>
 80055ac:	9b00      	ldr	r3, [sp, #0]
 80055ae:	2b00      	cmp	r3, #0
 80055b0:	bf0c      	ite	eq
 80055b2:	2301      	moveq	r3, #1
 80055b4:	2300      	movne	r3, #0
 80055b6:	b2db      	uxtb	r3, r3
 80055b8:	2b00      	cmp	r3, #0
 80055ba:	d002      	beq.n	80055c2 <chThdCreateStatic+0xa2>
 80055bc:	4822      	ldr	r0, [pc, #136]	@ (8005648 <chThdCreateStatic+0x128>)
 80055be:	f7fe faaf 	bl	8003b20 <chSysHalt>
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 80055c2:	9803      	ldr	r0, [sp, #12]
 80055c4:	f000 faa4 	bl	8005b10 <chRegFindThreadByWorkingArea>
 80055c8:	4603      	mov	r3, r0
 80055ca:	2b00      	cmp	r3, #0
 80055cc:	bf14      	ite	ne
 80055ce:	2301      	movne	r3, #1
 80055d0:	2300      	moveq	r3, #0
 80055d2:	b2db      	uxtb	r3, r3
 80055d4:	2b00      	cmp	r3, #0
 80055d6:	d002      	beq.n	80055de <chThdCreateStatic+0xbe>
 80055d8:	481b      	ldr	r0, [pc, #108]	@ (8005648 <chThdCreateStatic+0x128>)
 80055da:	f7fe faa1 	bl	8003b20 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wsp, (uint8_t *)wsp + size);
 80055de:	9a03      	ldr	r2, [sp, #12]
 80055e0:	9b02      	ldr	r3, [sp, #8]
 80055e2:	4413      	add	r3, r2
 80055e4:	4619      	mov	r1, r3
 80055e6:	9803      	ldr	r0, [sp, #12]
 80055e8:	f7ff fee2 	bl	80053b0 <__thd_stackfill>
#endif

  chSysLock();
 80055ec:	f7ff fe38 	bl	8005260 <chSysLock.lto_priv.8>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 80055f0:	9b02      	ldr	r3, [sp, #8]
 80055f2:	3b48      	subs	r3, #72	@ 0x48
 80055f4:	9a03      	ldr	r2, [sp, #12]
 80055f6:	4413      	add	r3, r2
 80055f8:	9305      	str	r3, [sp, #20]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 80055fa:	9b05      	ldr	r3, [sp, #20]
 80055fc:	9a03      	ldr	r2, [sp, #12]
 80055fe:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005600:	9b05      	ldr	r3, [sp, #20]
 8005602:	f1a3 0224 	sub.w	r2, r3, #36	@ 0x24
 8005606:	9b05      	ldr	r3, [sp, #20]
 8005608:	60da      	str	r2, [r3, #12]
 800560a:	9b05      	ldr	r3, [sp, #20]
 800560c:	68db      	ldr	r3, [r3, #12]
 800560e:	9a00      	ldr	r2, [sp, #0]
 8005610:	601a      	str	r2, [r3, #0]
 8005612:	9b05      	ldr	r3, [sp, #20]
 8005614:	68db      	ldr	r3, [r3, #12]
 8005616:	9a08      	ldr	r2, [sp, #32]
 8005618:	605a      	str	r2, [r3, #4]
 800561a:	9b05      	ldr	r3, [sp, #20]
 800561c:	68db      	ldr	r3, [r3, #12]
 800561e:	4a0b      	ldr	r2, [pc, #44]	@ (800564c <chThdCreateStatic+0x12c>)
 8005620:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 8005622:	9b01      	ldr	r3, [sp, #4]
 8005624:	4a0a      	ldr	r2, [pc, #40]	@ (8005650 <chThdCreateStatic+0x130>)
 8005626:	9905      	ldr	r1, [sp, #20]
 8005628:	480a      	ldr	r0, [pc, #40]	@ (8005654 <chThdCreateStatic+0x134>)
 800562a:	f7ff fe81 	bl	8005330 <__thd_object_init>
 800562e:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8005630:	2100      	movs	r1, #0
 8005632:	9805      	ldr	r0, [sp, #20]
 8005634:	f7ff fbcc 	bl	8004dd0 <chSchWakeupS>
  chSysUnlock();
 8005638:	f7ff fe22 	bl	8005280 <chSysUnlock.lto_priv.8>

  return tp;
 800563c:	9b05      	ldr	r3, [sp, #20]
}
 800563e:	4618      	mov	r0, r3
 8005640:	b007      	add	sp, #28
 8005642:	f85d fb04 	ldr.w	pc, [sp], #4
 8005646:	bf00      	nop
 8005648:	08006ff0 	.word	0x08006ff0
 800564c:	080003d1 	.word	0x080003d1
 8005650:	08006ed8 	.word	0x08006ed8
 8005654:	24000158 	.word	0x24000158
	...

08005660 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8005660:	b510      	push	{r4, lr}
 8005662:	b082      	sub	sp, #8
 8005664:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005666:	f7ff fdfb 	bl	8005260 <chSysLock.lto_priv.8>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800566a:	9b01      	ldr	r3, [sp, #4]
 800566c:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8005670:	2b00      	cmp	r3, #0
 8005672:	bf0c      	ite	eq
 8005674:	2301      	moveq	r3, #1
 8005676:	2300      	movne	r3, #0
 8005678:	b2db      	uxtb	r3, r3
 800567a:	2b00      	cmp	r3, #0
 800567c:	d002      	beq.n	8005684 <chThdRelease+0x24>
 800567e:	481f      	ldr	r0, [pc, #124]	@ (80056fc <chThdRelease+0x9c>)
 8005680:	f7fe fa4e 	bl	8003b20 <chSysHalt>
  tp->refs--;
 8005684:	9b01      	ldr	r3, [sp, #4]
 8005686:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800568a:	3b01      	subs	r3, #1
 800568c:	b2da      	uxtb	r2, r3
 800568e:	9b01      	ldr	r3, [sp, #4]
 8005690:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8005694:	9b01      	ldr	r3, [sp, #4]
 8005696:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800569a:	2b00      	cmp	r3, #0
 800569c:	d129      	bne.n	80056f2 <chThdRelease+0x92>
 800569e:	9b01      	ldr	r3, [sp, #4]
 80056a0:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 80056a4:	2b0f      	cmp	r3, #15
 80056a6:	d124      	bne.n	80056f2 <chThdRelease+0x92>
    REG_REMOVE(tp);
 80056a8:	9b01      	ldr	r3, [sp, #4]
 80056aa:	3310      	adds	r3, #16
 80056ac:	4618      	mov	r0, r3
 80056ae:	f7ff fdc7 	bl	8005240 <ch_queue_dequeue.lto_priv.1>
    chSysUnlock();
 80056b2:	f7ff fde5 	bl	8005280 <chSysUnlock.lto_priv.8>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80056b6:	9b01      	ldr	r3, [sp, #4]
 80056b8:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 80056bc:	f003 0303 	and.w	r3, r3, #3
 80056c0:	2b01      	cmp	r3, #1
 80056c2:	d002      	beq.n	80056ca <chThdRelease+0x6a>
 80056c4:	2b02      	cmp	r3, #2
 80056c6:	d008      	beq.n	80056da <chThdRelease+0x7a>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
      /* Nothing else to do for static threads.*/
      break;
 80056c8:	e012      	b.n	80056f0 <chThdRelease+0x90>
      chHeapFree(chThdGetWorkingAreaX(tp));
 80056ca:	9801      	ldr	r0, [sp, #4]
 80056cc:	f7ff fe10 	bl	80052f0 <chThdGetWorkingAreaX.lto_priv.0>
 80056d0:	4603      	mov	r3, r0
 80056d2:	4618      	mov	r0, r3
 80056d4:	f000 fd1c 	bl	8006110 <chHeapFree>
      break;
 80056d8:	e00a      	b.n	80056f0 <chThdRelease+0x90>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 80056da:	9b01      	ldr	r3, [sp, #4]
 80056dc:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
 80056de:	9801      	ldr	r0, [sp, #4]
 80056e0:	f7ff fe06 	bl	80052f0 <chThdGetWorkingAreaX.lto_priv.0>
 80056e4:	4603      	mov	r3, r0
 80056e6:	4619      	mov	r1, r3
 80056e8:	4620      	mov	r0, r4
 80056ea:	f000 fe89 	bl	8006400 <chPoolFree>
      break;
 80056ee:	bf00      	nop
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
 80056f0:	e001      	b.n	80056f6 <chThdRelease+0x96>
  }
  chSysUnlock();
 80056f2:	f7ff fdc5 	bl	8005280 <chSysUnlock.lto_priv.8>
}
 80056f6:	b002      	add	sp, #8
 80056f8:	bd10      	pop	{r4, pc}
 80056fa:	bf00      	nop
 80056fc:	08007004 	.word	0x08007004

08005700 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8005700:	b500      	push	{lr}
 8005702:	b083      	sub	sp, #12
 8005704:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005706:	f7ff fdab 	bl	8005260 <chSysLock.lto_priv.8>
  chThdExitS(msg);
 800570a:	9801      	ldr	r0, [sp, #4]
 800570c:	f000 f808 	bl	8005720 <chThdExitS>
  /* The thread never returns here.*/
}
 8005710:	bf00      	nop
 8005712:	b003      	add	sp, #12
 8005714:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08005720 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8005720:	b500      	push	{lr}
 8005722:	b085      	sub	sp, #20
 8005724:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8005726:	f7ff fddb 	bl	80052e0 <chThdGetSelfX.lto_priv.0>
 800572a:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 800572c:	9b03      	ldr	r3, [sp, #12]
 800572e:	9a01      	ldr	r2, [sp, #4]
 8005730:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8005732:	e008      	b.n	8005746 <chThdExitS+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8005734:	9b03      	ldr	r3, [sp, #12]
 8005736:	332c      	adds	r3, #44	@ 0x2c
 8005738:	4618      	mov	r0, r3
 800573a:	f7ff fd49 	bl	80051d0 <ch_list_unlink>
 800573e:	4603      	mov	r3, r0
 8005740:	4618      	mov	r0, r3
 8005742:	f7ff fa8d 	bl	8004c60 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8005746:	9b03      	ldr	r3, [sp, #12]
 8005748:	332c      	adds	r3, #44	@ 0x2c
 800574a:	4618      	mov	r0, r3
 800574c:	f7ff fd30 	bl	80051b0 <ch_list_notempty>
 8005750:	4603      	mov	r3, r0
 8005752:	2b00      	cmp	r3, #0
 8005754:	d1ee      	bne.n	8005734 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8005756:	9b03      	ldr	r3, [sp, #12]
 8005758:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800575c:	2b00      	cmp	r3, #0
 800575e:	bf0c      	ite	eq
 8005760:	2301      	moveq	r3, #1
 8005762:	2300      	movne	r3, #0
 8005764:	b2db      	uxtb	r3, r3
 8005766:	2b00      	cmp	r3, #0
 8005768:	d010      	beq.n	800578c <chThdExitS+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 800576a:	9b03      	ldr	r3, [sp, #12]
 800576c:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8005770:	f003 0303 	and.w	r3, r3, #3
 8005774:	2b00      	cmp	r3, #0
 8005776:	bf0c      	ite	eq
 8005778:	2301      	moveq	r3, #1
 800577a:	2300      	movne	r3, #0
 800577c:	b2db      	uxtb	r3, r3
 800577e:	2b00      	cmp	r3, #0
 8005780:	d004      	beq.n	800578c <chThdExitS+0x6c>
      REG_REMOVE(currtp);
 8005782:	9b03      	ldr	r3, [sp, #12]
 8005784:	3310      	adds	r3, #16
 8005786:	4618      	mov	r0, r3
 8005788:	f7ff fd5a 	bl	8005240 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800578c:	200f      	movs	r0, #15
 800578e:	f7ff fa87 	bl	8004ca0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8005792:	4803      	ldr	r0, [pc, #12]	@ (80057a0 <chThdExitS+0x80>)
 8005794:	f7fe f9c4 	bl	8003b20 <chSysHalt>
}
 8005798:	bf00      	nop
 800579a:	b005      	add	sp, #20
 800579c:	f85d fb04 	ldr.w	pc, [sp], #4
 80057a0:	08007014 	.word	0x08007014
	...

080057b0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 80057b0:	b500      	push	{lr}
 80057b2:	b083      	sub	sp, #12
 80057b4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80057b6:	f7ff fd53 	bl	8005260 <chSysLock.lto_priv.8>
  chThdSleepS(time);
 80057ba:	9801      	ldr	r0, [sp, #4]
 80057bc:	f7ff fda0 	bl	8005300 <chThdSleepS>
  chSysUnlock();
 80057c0:	f7ff fd5e 	bl	8005280 <chSysUnlock.lto_priv.8>
}
 80057c4:	bf00      	nop
 80057c6:	b003      	add	sp, #12
 80057c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80057cc:	0000      	movs	r0, r0
	...

080057d0 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 80057d0:	b500      	push	{lr}
 80057d2:	b085      	sub	sp, #20
 80057d4:	9001      	str	r0, [sp, #4]
 80057d6:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 80057d8:	f7ff fd82 	bl	80052e0 <chThdGetSelfX.lto_priv.0>
 80057dc:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 80057de:	9b01      	ldr	r3, [sp, #4]
 80057e0:	681b      	ldr	r3, [r3, #0]
 80057e2:	2b00      	cmp	r3, #0
 80057e4:	bf14      	ite	ne
 80057e6:	2301      	movne	r3, #1
 80057e8:	2300      	moveq	r3, #0
 80057ea:	b2db      	uxtb	r3, r3
 80057ec:	2b00      	cmp	r3, #0
 80057ee:	d002      	beq.n	80057f6 <chThdSuspendTimeoutS+0x26>
 80057f0:	480e      	ldr	r0, [pc, #56]	@ (800582c <chThdSuspendTimeoutS+0x5c>)
 80057f2:	f7fe f995 	bl	8003b20 <chSysHalt>

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 80057f6:	9b00      	ldr	r3, [sp, #0]
 80057f8:	2b00      	cmp	r3, #0
 80057fa:	bf0c      	ite	eq
 80057fc:	2301      	moveq	r3, #1
 80057fe:	2300      	movne	r3, #0
 8005800:	b2db      	uxtb	r3, r3
 8005802:	2b00      	cmp	r3, #0
 8005804:	d002      	beq.n	800580c <chThdSuspendTimeoutS+0x3c>
    return MSG_TIMEOUT;
 8005806:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800580a:	e00a      	b.n	8005822 <chThdSuspendTimeoutS+0x52>
  }

  *trp = tp;
 800580c:	9b01      	ldr	r3, [sp, #4]
 800580e:	9a03      	ldr	r2, [sp, #12]
 8005810:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8005812:	9b03      	ldr	r3, [sp, #12]
 8005814:	9a01      	ldr	r2, [sp, #4]
 8005816:	629a      	str	r2, [r3, #40]	@ 0x28

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8005818:	9900      	ldr	r1, [sp, #0]
 800581a:	2003      	movs	r0, #3
 800581c:	f7ff faa0 	bl	8004d60 <chSchGoSleepTimeoutS>
 8005820:	4603      	mov	r3, r0
}
 8005822:	4618      	mov	r0, r3
 8005824:	b005      	add	sp, #20
 8005826:	f85d fb04 	ldr.w	pc, [sp], #4
 800582a:	bf00      	nop
 800582c:	0800702c 	.word	0x0800702c

08005830 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8005830:	b500      	push	{lr}
 8005832:	b085      	sub	sp, #20
 8005834:	9001      	str	r0, [sp, #4]
 8005836:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8005838:	9b01      	ldr	r3, [sp, #4]
 800583a:	681b      	ldr	r3, [r3, #0]
 800583c:	2b00      	cmp	r3, #0
 800583e:	d018      	beq.n	8005872 <chThdResumeI+0x42>
    thread_t *tp = *trp;
 8005840:	9b01      	ldr	r3, [sp, #4]
 8005842:	681b      	ldr	r3, [r3, #0]
 8005844:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8005846:	9b03      	ldr	r3, [sp, #12]
 8005848:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800584c:	2b03      	cmp	r3, #3
 800584e:	bf14      	ite	ne
 8005850:	2301      	movne	r3, #1
 8005852:	2300      	moveq	r3, #0
 8005854:	b2db      	uxtb	r3, r3
 8005856:	2b00      	cmp	r3, #0
 8005858:	d002      	beq.n	8005860 <chThdResumeI+0x30>
 800585a:	4808      	ldr	r0, [pc, #32]	@ (800587c <chThdResumeI+0x4c>)
 800585c:	f7fe f960 	bl	8003b20 <chSysHalt>

    *trp = NULL;
 8005860:	9b01      	ldr	r3, [sp, #4]
 8005862:	2200      	movs	r2, #0
 8005864:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8005866:	9b03      	ldr	r3, [sp, #12]
 8005868:	9a00      	ldr	r2, [sp, #0]
 800586a:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 800586c:	9803      	ldr	r0, [sp, #12]
 800586e:	f7ff f9f7 	bl	8004c60 <chSchReadyI>
  }
}
 8005872:	bf00      	nop
 8005874:	b005      	add	sp, #20
 8005876:	f85d fb04 	ldr.w	pc, [sp], #4
 800587a:	bf00      	nop
 800587c:	08007044 	.word	0x08007044

08005880 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8005880:	b500      	push	{lr}
 8005882:	b085      	sub	sp, #20
 8005884:	9001      	str	r0, [sp, #4]
 8005886:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8005888:	9b01      	ldr	r3, [sp, #4]
 800588a:	681b      	ldr	r3, [r3, #0]
 800588c:	2b00      	cmp	r3, #0
 800588e:	d016      	beq.n	80058be <chThdResumeS+0x3e>
    thread_t *tp = *trp;
 8005890:	9b01      	ldr	r3, [sp, #4]
 8005892:	681b      	ldr	r3, [r3, #0]
 8005894:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8005896:	9b03      	ldr	r3, [sp, #12]
 8005898:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800589c:	2b03      	cmp	r3, #3
 800589e:	bf14      	ite	ne
 80058a0:	2301      	movne	r3, #1
 80058a2:	2300      	moveq	r3, #0
 80058a4:	b2db      	uxtb	r3, r3
 80058a6:	2b00      	cmp	r3, #0
 80058a8:	d002      	beq.n	80058b0 <chThdResumeS+0x30>
 80058aa:	4807      	ldr	r0, [pc, #28]	@ (80058c8 <chThdResumeS+0x48>)
 80058ac:	f7fe f938 	bl	8003b20 <chSysHalt>

    *trp = NULL;
 80058b0:	9b01      	ldr	r3, [sp, #4]
 80058b2:	2200      	movs	r2, #0
 80058b4:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 80058b6:	9900      	ldr	r1, [sp, #0]
 80058b8:	9803      	ldr	r0, [sp, #12]
 80058ba:	f7ff fa89 	bl	8004dd0 <chSchWakeupS>
  }
}
 80058be:	bf00      	nop
 80058c0:	b005      	add	sp, #20
 80058c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80058c6:	bf00      	nop
 80058c8:	08007054 	.word	0x08007054
 80058cc:	00000000 	.word	0x00000000

080058d0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80058d0:	b4f0      	push	{r4, r5, r6, r7}
 80058d2:	b084      	sub	sp, #16
 80058d4:	9003      	str	r0, [sp, #12]
 80058d6:	9102      	str	r1, [sp, #8]
 80058d8:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80058da:	9b03      	ldr	r3, [sp, #12]
 80058dc:	68db      	ldr	r3, [r3, #12]
 80058de:	1c5a      	adds	r2, r3, #1
 80058e0:	9b03      	ldr	r3, [sp, #12]
 80058e2:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 80058e4:	9b03      	ldr	r3, [sp, #12]
 80058e6:	689b      	ldr	r3, [r3, #8]
 80058e8:	9a02      	ldr	r2, [sp, #8]
 80058ea:	1ad2      	subs	r2, r2, r3
 80058ec:	9b01      	ldr	r3, [sp, #4]
 80058ee:	1ad2      	subs	r2, r2, r3
 80058f0:	9b03      	ldr	r3, [sp, #12]
 80058f2:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80058f4:	9b03      	ldr	r3, [sp, #12]
 80058f6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80058fa:	9903      	ldr	r1, [sp, #12]
 80058fc:	6889      	ldr	r1, [r1, #8]
 80058fe:	2000      	movs	r0, #0
 8005900:	460c      	mov	r4, r1
 8005902:	4605      	mov	r5, r0
 8005904:	1916      	adds	r6, r2, r4
 8005906:	eb43 0705 	adc.w	r7, r3, r5
 800590a:	9b03      	ldr	r3, [sp, #12]
 800590c:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
 8005910:	9b03      	ldr	r3, [sp, #12]
 8005912:	689a      	ldr	r2, [r3, #8]
 8005914:	9b03      	ldr	r3, [sp, #12]
 8005916:	685b      	ldr	r3, [r3, #4]
 8005918:	429a      	cmp	r2, r3
 800591a:	d903      	bls.n	8005924 <tm_stop+0x54>
    tmp->worst = tmp->last;
 800591c:	9b03      	ldr	r3, [sp, #12]
 800591e:	689a      	ldr	r2, [r3, #8]
 8005920:	9b03      	ldr	r3, [sp, #12]
 8005922:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8005924:	9b03      	ldr	r3, [sp, #12]
 8005926:	689a      	ldr	r2, [r3, #8]
 8005928:	9b03      	ldr	r3, [sp, #12]
 800592a:	681b      	ldr	r3, [r3, #0]
 800592c:	429a      	cmp	r2, r3
 800592e:	d203      	bcs.n	8005938 <tm_stop+0x68>
    tmp->best = tmp->last;
 8005930:	9b03      	ldr	r3, [sp, #12]
 8005932:	689a      	ldr	r2, [r3, #8]
 8005934:	9b03      	ldr	r3, [sp, #12]
 8005936:	601a      	str	r2, [r3, #0]
  }
}
 8005938:	bf00      	nop
 800593a:	b004      	add	sp, #16
 800593c:	bcf0      	pop	{r4, r5, r6, r7}
 800593e:	4770      	bx	lr

08005940 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8005940:	b082      	sub	sp, #8
 8005942:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8005944:	9b01      	ldr	r3, [sp, #4]
 8005946:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800594a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 800594c:	9b01      	ldr	r3, [sp, #4]
 800594e:	2200      	movs	r2, #0
 8005950:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8005952:	9b01      	ldr	r3, [sp, #4]
 8005954:	2200      	movs	r2, #0
 8005956:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8005958:	9b01      	ldr	r3, [sp, #4]
 800595a:	2200      	movs	r2, #0
 800595c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 800595e:	9901      	ldr	r1, [sp, #4]
 8005960:	f04f 0200 	mov.w	r2, #0
 8005964:	f04f 0300 	mov.w	r3, #0
 8005968:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 800596c:	bf00      	nop
 800596e:	b002      	add	sp, #8
 8005970:	4770      	bx	lr
 8005972:	bf00      	nop
	...

08005980 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8005980:	b082      	sub	sp, #8
 8005982:	9001      	str	r0, [sp, #4]
  return DWT->CYCCNT;
 8005984:	4b03      	ldr	r3, [pc, #12]	@ (8005994 <chTMStartMeasurementX+0x14>)
 8005986:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8005988:	9b01      	ldr	r3, [sp, #4]
 800598a:	609a      	str	r2, [r3, #8]
}
 800598c:	bf00      	nop
 800598e:	b002      	add	sp, #8
 8005990:	4770      	bx	lr
 8005992:	bf00      	nop
 8005994:	e0001000 	.word	0xe0001000
	...

080059a0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80059a0:	b500      	push	{lr}
 80059a2:	b083      	sub	sp, #12
 80059a4:	9001      	str	r0, [sp, #4]
 80059a6:	4b06      	ldr	r3, [pc, #24]	@ (80059c0 <chTMStopMeasurementX+0x20>)
 80059a8:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 80059aa:	4a06      	ldr	r2, [pc, #24]	@ (80059c4 <chTMStopMeasurementX+0x24>)
 80059ac:	6892      	ldr	r2, [r2, #8]
 80059ae:	4619      	mov	r1, r3
 80059b0:	9801      	ldr	r0, [sp, #4]
 80059b2:	f7ff ff8d 	bl	80058d0 <tm_stop>
}
 80059b6:	bf00      	nop
 80059b8:	b003      	add	sp, #12
 80059ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80059be:	bf00      	nop
 80059c0:	e0001000 	.word	0xe0001000
 80059c4:	24000148 	.word	0x24000148
	...

080059d0 <chSysLock.lto_priv.9>:
static inline void chSysLock(void) {
 80059d0:	b500      	push	{lr}
 80059d2:	b083      	sub	sp, #12
 80059d4:	2330      	movs	r3, #48	@ 0x30
 80059d6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80059d8:	9b01      	ldr	r3, [sp, #4]
 80059da:	f383 8811 	msr	BASEPRI, r3
}
 80059de:	bf00      	nop
}
 80059e0:	bf00      	nop
  __dbg_check_lock();
 80059e2:	f7fe f925 	bl	8003c30 <__dbg_check_lock>
}
 80059e6:	bf00      	nop
 80059e8:	b003      	add	sp, #12
 80059ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80059ee:	bf00      	nop

080059f0 <chSysUnlock.lto_priv.9>:
static inline void chSysUnlock(void) {
 80059f0:	b500      	push	{lr}
 80059f2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 80059f4:	f7fe f944 	bl	8003c80 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80059f8:	4b12      	ldr	r3, [pc, #72]	@ (8005a44 <chSysUnlock.lto_priv.9+0x54>)
 80059fa:	681b      	ldr	r3, [r3, #0]
 80059fc:	4a11      	ldr	r2, [pc, #68]	@ (8005a44 <chSysUnlock.lto_priv.9+0x54>)
 80059fe:	4293      	cmp	r3, r2
 8005a00:	bf14      	ite	ne
 8005a02:	2301      	movne	r3, #1
 8005a04:	2300      	moveq	r3, #0
 8005a06:	b2db      	uxtb	r3, r3
 8005a08:	2b00      	cmp	r3, #0
 8005a0a:	d00f      	beq.n	8005a2c <chSysUnlock.lto_priv.9+0x3c>
 8005a0c:	4b0d      	ldr	r3, [pc, #52]	@ (8005a44 <chSysUnlock.lto_priv.9+0x54>)
 8005a0e:	68db      	ldr	r3, [r3, #12]
 8005a10:	689a      	ldr	r2, [r3, #8]
 8005a12:	4b0c      	ldr	r3, [pc, #48]	@ (8005a44 <chSysUnlock.lto_priv.9+0x54>)
 8005a14:	681b      	ldr	r3, [r3, #0]
 8005a16:	689b      	ldr	r3, [r3, #8]
 8005a18:	429a      	cmp	r2, r3
 8005a1a:	bf34      	ite	cc
 8005a1c:	2301      	movcc	r3, #1
 8005a1e:	2300      	movcs	r3, #0
 8005a20:	b2db      	uxtb	r3, r3
 8005a22:	2b00      	cmp	r3, #0
 8005a24:	d002      	beq.n	8005a2c <chSysUnlock.lto_priv.9+0x3c>
 8005a26:	4808      	ldr	r0, [pc, #32]	@ (8005a48 <chSysUnlock.lto_priv.9+0x58>)
 8005a28:	f7fe f87a 	bl	8003b20 <chSysHalt>
 8005a2c:	2300      	movs	r3, #0
 8005a2e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005a30:	9b01      	ldr	r3, [sp, #4]
 8005a32:	f383 8811 	msr	BASEPRI, r3
}
 8005a36:	bf00      	nop
}
 8005a38:	bf00      	nop
}
 8005a3a:	bf00      	nop
 8005a3c:	b003      	add	sp, #12
 8005a3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a42:	bf00      	nop
 8005a44:	24000158 	.word	0x24000158
 8005a48:	08007090 	.word	0x08007090
 8005a4c:	00000000 	.word	0x00000000

08005a50 <chThdGetWorkingAreaX.lto_priv.1>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8005a50:	b082      	sub	sp, #8
 8005a52:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8005a54:	9b01      	ldr	r3, [sp, #4]
 8005a56:	6a1b      	ldr	r3, [r3, #32]
}
 8005a58:	4618      	mov	r0, r3
 8005a5a:	b002      	add	sp, #8
 8005a5c:	4770      	bx	lr
 8005a5e:	bf00      	nop

08005a60 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8005a60:	b500      	push	{lr}
 8005a62:	b083      	sub	sp, #12
  thread_t *tp;
  uint8_t *p;

  chSysLock();
 8005a64:	f7ff ffb4 	bl	80059d0 <chSysLock.lto_priv.9>
  p = (uint8_t *)REG_HEADER(currcore)->next;
 8005a68:	4b0a      	ldr	r3, [pc, #40]	@ (8005a94 <chRegFirstThread+0x34>)
 8005a6a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005a6c:	9301      	str	r3, [sp, #4]
  /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8005a6e:	9b01      	ldr	r3, [sp, #4]
 8005a70:	3b10      	subs	r3, #16
 8005a72:	9300      	str	r3, [sp, #0]
  /*lint -restore*/
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8005a74:	9b00      	ldr	r3, [sp, #0]
 8005a76:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8005a7a:	3301      	adds	r3, #1
 8005a7c:	b2da      	uxtb	r2, r3
 8005a7e:	9b00      	ldr	r3, [sp, #0]
 8005a80:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
#endif
  chSysUnlock();
 8005a84:	f7ff ffb4 	bl	80059f0 <chSysUnlock.lto_priv.9>

  return tp;
 8005a88:	9b00      	ldr	r3, [sp, #0]
}
 8005a8a:	4618      	mov	r0, r3
 8005a8c:	b003      	add	sp, #12
 8005a8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a92:	bf00      	nop
 8005a94:	24000158 	.word	0x24000158
	...

08005aa0 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8005aa0:	b500      	push	{lr}
 8005aa2:	b087      	sub	sp, #28
 8005aa4:	9001      	str	r0, [sp, #4]
  thread_t *ntp;
  ch_queue_t *nqp;

  chSysLock();
 8005aa6:	f7ff ff93 	bl	80059d0 <chSysLock.lto_priv.9>

  /* Next element in the registry queue.*/
  nqp = tp->rqueue.next;
 8005aaa:	9b01      	ldr	r3, [sp, #4]
 8005aac:	691b      	ldr	r3, [r3, #16]
 8005aae:	9304      	str	r3, [sp, #16]
  if (nqp == REG_HEADER(currcore)) {
 8005ab0:	9b04      	ldr	r3, [sp, #16]
 8005ab2:	4a15      	ldr	r2, [pc, #84]	@ (8005b08 <chRegNextThread+0x68>)
 8005ab4:	4293      	cmp	r3, r2
 8005ab6:	d102      	bne.n	8005abe <chRegNextThread+0x1e>
    ntp = NULL;
 8005ab8:	2300      	movs	r3, #0
 8005aba:	9305      	str	r3, [sp, #20]
 8005abc:	e019      	b.n	8005af2 <chRegNextThread+0x52>
  }
  else {
    uint8_t *p = (uint8_t *)nqp;
 8005abe:	9b04      	ldr	r3, [sp, #16]
 8005ac0:	9303      	str	r3, [sp, #12]
    /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8005ac2:	9b03      	ldr	r3, [sp, #12]
 8005ac4:	3b10      	subs	r3, #16
 8005ac6:	9305      	str	r3, [sp, #20]
    /*lint -restore*/

#if CH_CFG_USE_DYNAMIC == TRUE
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8005ac8:	9b05      	ldr	r3, [sp, #20]
 8005aca:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8005ace:	2bff      	cmp	r3, #255	@ 0xff
 8005ad0:	bf0c      	ite	eq
 8005ad2:	2301      	moveq	r3, #1
 8005ad4:	2300      	movne	r3, #0
 8005ad6:	b2db      	uxtb	r3, r3
 8005ad8:	2b00      	cmp	r3, #0
 8005ada:	d002      	beq.n	8005ae2 <chRegNextThread+0x42>
 8005adc:	480b      	ldr	r0, [pc, #44]	@ (8005b0c <chRegNextThread+0x6c>)
 8005ade:	f7fe f81f 	bl	8003b20 <chSysHalt>

    ntp->refs++;
 8005ae2:	9b05      	ldr	r3, [sp, #20]
 8005ae4:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 8005ae8:	3301      	adds	r3, #1
 8005aea:	b2da      	uxtb	r2, r3
 8005aec:	9b05      	ldr	r3, [sp, #20]
 8005aee:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
#endif
  }
  chSysUnlock();
 8005af2:	f7ff ff7d 	bl	80059f0 <chSysUnlock.lto_priv.9>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8005af6:	9801      	ldr	r0, [sp, #4]
 8005af8:	f7ff fdb2 	bl	8005660 <chThdRelease>
#endif

  return ntp;
 8005afc:	9b05      	ldr	r3, [sp, #20]
}
 8005afe:	4618      	mov	r0, r3
 8005b00:	b007      	add	sp, #28
 8005b02:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b06:	bf00      	nop
 8005b08:	24000180 	.word	0x24000180
 8005b0c:	0800709c 	.word	0x0800709c

08005b10 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8005b10:	b500      	push	{lr}
 8005b12:	b085      	sub	sp, #20
 8005b14:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8005b16:	f7ff ffa3 	bl	8005a60 <chRegFirstThread>
 8005b1a:	9003      	str	r0, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8005b1c:	9803      	ldr	r0, [sp, #12]
 8005b1e:	f7ff ff97 	bl	8005a50 <chThdGetWorkingAreaX.lto_priv.1>
 8005b22:	4602      	mov	r2, r0
 8005b24:	9b01      	ldr	r3, [sp, #4]
 8005b26:	4293      	cmp	r3, r2
 8005b28:	d101      	bne.n	8005b2e <chRegFindThreadByWorkingArea+0x1e>
      return ctp;
 8005b2a:	9b03      	ldr	r3, [sp, #12]
 8005b2c:	e007      	b.n	8005b3e <chRegFindThreadByWorkingArea+0x2e>
    }
    ctp = chRegNextThread(ctp);
 8005b2e:	9803      	ldr	r0, [sp, #12]
 8005b30:	f7ff ffb6 	bl	8005aa0 <chRegNextThread>
 8005b34:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 8005b36:	9b03      	ldr	r3, [sp, #12]
 8005b38:	2b00      	cmp	r3, #0
 8005b3a:	d1ef      	bne.n	8005b1c <chRegFindThreadByWorkingArea+0xc>

  return NULL;
 8005b3c:	2300      	movs	r3, #0
}
 8005b3e:	4618      	mov	r0, r3
 8005b40:	b005      	add	sp, #20
 8005b42:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b46:	bf00      	nop
	...

08005b50 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8005b50:	b082      	sub	sp, #8
 8005b52:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8005b54:	9b01      	ldr	r3, [sp, #4]
 8005b56:	9a01      	ldr	r2, [sp, #4]
 8005b58:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8005b5a:	9b01      	ldr	r3, [sp, #4]
 8005b5c:	9a01      	ldr	r2, [sp, #4]
 8005b5e:	605a      	str	r2, [r3, #4]
}
 8005b60:	bf00      	nop
 8005b62:	b002      	add	sp, #8
 8005b64:	4770      	bx	lr
 8005b66:	bf00      	nop
	...

08005b70 <ch_queue_notempty.lto_priv.2>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 8005b70:	b082      	sub	sp, #8
 8005b72:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 8005b74:	9b01      	ldr	r3, [sp, #4]
 8005b76:	681b      	ldr	r3, [r3, #0]
 8005b78:	9a01      	ldr	r2, [sp, #4]
 8005b7a:	429a      	cmp	r2, r3
 8005b7c:	bf14      	ite	ne
 8005b7e:	2301      	movne	r3, #1
 8005b80:	2300      	moveq	r3, #0
 8005b82:	b2db      	uxtb	r3, r3
}
 8005b84:	4618      	mov	r0, r3
 8005b86:	b002      	add	sp, #8
 8005b88:	4770      	bx	lr
 8005b8a:	bf00      	nop
 8005b8c:	0000      	movs	r0, r0
	...

08005b90 <ch_queue_fifo_remove.lto_priv.2>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 8005b90:	b084      	sub	sp, #16
 8005b92:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 8005b94:	9b01      	ldr	r3, [sp, #4]
 8005b96:	681b      	ldr	r3, [r3, #0]
 8005b98:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 8005b9a:	9b03      	ldr	r3, [sp, #12]
 8005b9c:	681a      	ldr	r2, [r3, #0]
 8005b9e:	9b01      	ldr	r3, [sp, #4]
 8005ba0:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 8005ba2:	9b01      	ldr	r3, [sp, #4]
 8005ba4:	681b      	ldr	r3, [r3, #0]
 8005ba6:	9a01      	ldr	r2, [sp, #4]
 8005ba8:	605a      	str	r2, [r3, #4]
  return p;
 8005baa:	9b03      	ldr	r3, [sp, #12]
}
 8005bac:	4618      	mov	r0, r3
 8005bae:	b004      	add	sp, #16
 8005bb0:	4770      	bx	lr
 8005bb2:	bf00      	nop
	...

08005bc0 <ch_queue_dequeue.lto_priv.2>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8005bc0:	b082      	sub	sp, #8
 8005bc2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8005bc4:	9b01      	ldr	r3, [sp, #4]
 8005bc6:	685b      	ldr	r3, [r3, #4]
 8005bc8:	9a01      	ldr	r2, [sp, #4]
 8005bca:	6812      	ldr	r2, [r2, #0]
 8005bcc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8005bce:	9b01      	ldr	r3, [sp, #4]
 8005bd0:	681b      	ldr	r3, [r3, #0]
 8005bd2:	9a01      	ldr	r2, [sp, #4]
 8005bd4:	6852      	ldr	r2, [r2, #4]
 8005bd6:	605a      	str	r2, [r3, #4]
  return p;
 8005bd8:	9b01      	ldr	r3, [sp, #4]
}
 8005bda:	4618      	mov	r0, r3
 8005bdc:	b002      	add	sp, #8
 8005bde:	4770      	bx	lr

08005be0 <chSysLock.lto_priv.11>:
static inline void chSysLock(void) {
 8005be0:	b500      	push	{lr}
 8005be2:	b083      	sub	sp, #12
 8005be4:	2330      	movs	r3, #48	@ 0x30
 8005be6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005be8:	9b01      	ldr	r3, [sp, #4]
 8005bea:	f383 8811 	msr	BASEPRI, r3
}
 8005bee:	bf00      	nop
}
 8005bf0:	bf00      	nop
  __dbg_check_lock();
 8005bf2:	f7fe f81d 	bl	8003c30 <__dbg_check_lock>
}
 8005bf6:	bf00      	nop
 8005bf8:	b003      	add	sp, #12
 8005bfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8005bfe:	bf00      	nop

08005c00 <chSysUnlock.lto_priv.11>:
static inline void chSysUnlock(void) {
 8005c00:	b500      	push	{lr}
 8005c02:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8005c04:	f7fe f83c 	bl	8003c80 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8005c08:	4b12      	ldr	r3, [pc, #72]	@ (8005c54 <chSysUnlock.lto_priv.11+0x54>)
 8005c0a:	681b      	ldr	r3, [r3, #0]
 8005c0c:	4a11      	ldr	r2, [pc, #68]	@ (8005c54 <chSysUnlock.lto_priv.11+0x54>)
 8005c0e:	4293      	cmp	r3, r2
 8005c10:	bf14      	ite	ne
 8005c12:	2301      	movne	r3, #1
 8005c14:	2300      	moveq	r3, #0
 8005c16:	b2db      	uxtb	r3, r3
 8005c18:	2b00      	cmp	r3, #0
 8005c1a:	d00f      	beq.n	8005c3c <chSysUnlock.lto_priv.11+0x3c>
 8005c1c:	4b0d      	ldr	r3, [pc, #52]	@ (8005c54 <chSysUnlock.lto_priv.11+0x54>)
 8005c1e:	68db      	ldr	r3, [r3, #12]
 8005c20:	689a      	ldr	r2, [r3, #8]
 8005c22:	4b0c      	ldr	r3, [pc, #48]	@ (8005c54 <chSysUnlock.lto_priv.11+0x54>)
 8005c24:	681b      	ldr	r3, [r3, #0]
 8005c26:	689b      	ldr	r3, [r3, #8]
 8005c28:	429a      	cmp	r2, r3
 8005c2a:	bf34      	ite	cc
 8005c2c:	2301      	movcc	r3, #1
 8005c2e:	2300      	movcs	r3, #0
 8005c30:	b2db      	uxtb	r3, r3
 8005c32:	2b00      	cmp	r3, #0
 8005c34:	d002      	beq.n	8005c3c <chSysUnlock.lto_priv.11+0x3c>
 8005c36:	4808      	ldr	r0, [pc, #32]	@ (8005c58 <chSysUnlock.lto_priv.11+0x58>)
 8005c38:	f7fd ff72 	bl	8003b20 <chSysHalt>
 8005c3c:	2300      	movs	r3, #0
 8005c3e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005c40:	9b01      	ldr	r3, [sp, #4]
 8005c42:	f383 8811 	msr	BASEPRI, r3
}
 8005c46:	bf00      	nop
}
 8005c48:	bf00      	nop
}
 8005c4a:	bf00      	nop
 8005c4c:	b003      	add	sp, #12
 8005c4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c52:	bf00      	nop
 8005c54:	24000158 	.word	0x24000158
 8005c58:	080070bc 	.word	0x080070bc
 8005c5c:	00000000 	.word	0x00000000

08005c60 <ch_sch_prio_insert.lto_priv.0>:
/*===========================================================================*/

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 8005c60:	b084      	sub	sp, #16
 8005c62:	9001      	str	r0, [sp, #4]
 8005c64:	9100      	str	r1, [sp, #0]

  ch_queue_t *cp = qp;
 8005c66:	9b01      	ldr	r3, [sp, #4]
 8005c68:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->next;
 8005c6a:	9b03      	ldr	r3, [sp, #12]
 8005c6c:	681b      	ldr	r3, [r3, #0]
 8005c6e:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
 8005c70:	9a03      	ldr	r2, [sp, #12]
 8005c72:	9b01      	ldr	r3, [sp, #4]
 8005c74:	429a      	cmp	r2, r3
 8005c76:	d005      	beq.n	8005c84 <ch_sch_prio_insert.lto_priv.0+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8005c78:	9b03      	ldr	r3, [sp, #12]
 8005c7a:	689a      	ldr	r2, [r3, #8]
 8005c7c:	9b00      	ldr	r3, [sp, #0]
 8005c7e:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
 8005c80:	429a      	cmp	r2, r3
 8005c82:	d2f2      	bcs.n	8005c6a <ch_sch_prio_insert.lto_priv.0+0xa>
  tp->next       = cp;
 8005c84:	9b00      	ldr	r3, [sp, #0]
 8005c86:	9a03      	ldr	r2, [sp, #12]
 8005c88:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
 8005c8a:	9b03      	ldr	r3, [sp, #12]
 8005c8c:	685a      	ldr	r2, [r3, #4]
 8005c8e:	9b00      	ldr	r3, [sp, #0]
 8005c90:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
 8005c92:	9b00      	ldr	r3, [sp, #0]
 8005c94:	685b      	ldr	r3, [r3, #4]
 8005c96:	9a00      	ldr	r2, [sp, #0]
 8005c98:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
 8005c9a:	9b03      	ldr	r3, [sp, #12]
 8005c9c:	9a00      	ldr	r2, [sp, #0]
 8005c9e:	605a      	str	r2, [r3, #4]
}
 8005ca0:	bf00      	nop
 8005ca2:	b004      	add	sp, #16
 8005ca4:	4770      	bx	lr
 8005ca6:	bf00      	nop
	...

08005cb0 <chThdGetSelfX.lto_priv.2>:
  return __sch_get_currthread();
 8005cb0:	4b01      	ldr	r3, [pc, #4]	@ (8005cb8 <chThdGetSelfX.lto_priv.2+0x8>)
 8005cb2:	68db      	ldr	r3, [r3, #12]
}
 8005cb4:	4618      	mov	r0, r3
 8005cb6:	4770      	bx	lr
 8005cb8:	24000158 	.word	0x24000158
 8005cbc:	00000000 	.word	0x00000000

08005cc0 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8005cc0:	b500      	push	{lr}
 8005cc2:	b083      	sub	sp, #12
 8005cc4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8005cc6:	f7fe f8eb 	bl	8003ea0 <chDbgCheckClassS>

  return ch_queue_notempty(&mp->queue);
 8005cca:	9b01      	ldr	r3, [sp, #4]
 8005ccc:	4618      	mov	r0, r3
 8005cce:	f7ff ff4f 	bl	8005b70 <ch_queue_notempty.lto_priv.2>
 8005cd2:	4603      	mov	r3, r0
}
 8005cd4:	4618      	mov	r0, r3
 8005cd6:	b003      	add	sp, #12
 8005cd8:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cdc:	0000      	movs	r0, r0
	...

08005ce0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8005ce0:	b500      	push	{lr}
 8005ce2:	b083      	sub	sp, #12
 8005ce4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8005ce6:	9b01      	ldr	r3, [sp, #4]
 8005ce8:	2b00      	cmp	r3, #0
 8005cea:	bf0c      	ite	eq
 8005cec:	2301      	moveq	r3, #1
 8005cee:	2300      	movne	r3, #0
 8005cf0:	b2db      	uxtb	r3, r3
 8005cf2:	2b00      	cmp	r3, #0
 8005cf4:	d002      	beq.n	8005cfc <chMtxObjectInit+0x1c>
 8005cf6:	4807      	ldr	r0, [pc, #28]	@ (8005d14 <chMtxObjectInit+0x34>)
 8005cf8:	f7fd ff12 	bl	8003b20 <chSysHalt>

  ch_queue_init(&mp->queue);
 8005cfc:	9b01      	ldr	r3, [sp, #4]
 8005cfe:	4618      	mov	r0, r3
 8005d00:	f7ff ff26 	bl	8005b50 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 8005d04:	9b01      	ldr	r3, [sp, #4]
 8005d06:	2200      	movs	r2, #0
 8005d08:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8005d0a:	bf00      	nop
 8005d0c:	b003      	add	sp, #12
 8005d0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d12:	bf00      	nop
 8005d14:	080070ac 	.word	0x080070ac
	...

08005d20 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8005d20:	b500      	push	{lr}
 8005d22:	b083      	sub	sp, #12
 8005d24:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005d26:	f7ff ff5b 	bl	8005be0 <chSysLock.lto_priv.11>
  chMtxLockS(mp);
 8005d2a:	9801      	ldr	r0, [sp, #4]
 8005d2c:	f000 f808 	bl	8005d40 <chMtxLockS>
  chSysUnlock();
 8005d30:	f7ff ff66 	bl	8005c00 <chSysUnlock.lto_priv.11>
}
 8005d34:	bf00      	nop
 8005d36:	b003      	add	sp, #12
 8005d38:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d3c:	0000      	movs	r0, r0
	...

08005d40 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8005d40:	b510      	push	{r4, lr}
 8005d42:	b084      	sub	sp, #16
 8005d44:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8005d46:	f7ff ffb3 	bl	8005cb0 <chThdGetSelfX.lto_priv.2>
 8005d4a:	9002      	str	r0, [sp, #8]

  chDbgCheckClassS();
 8005d4c:	f7fe f8a8 	bl	8003ea0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8005d50:	9b01      	ldr	r3, [sp, #4]
 8005d52:	2b00      	cmp	r3, #0
 8005d54:	bf0c      	ite	eq
 8005d56:	2301      	moveq	r3, #1
 8005d58:	2300      	movne	r3, #0
 8005d5a:	b2db      	uxtb	r3, r3
 8005d5c:	2b00      	cmp	r3, #0
 8005d5e:	d002      	beq.n	8005d66 <chMtxLockS+0x26>
 8005d60:	4840      	ldr	r0, [pc, #256]	@ (8005e64 <chMtxLockS+0x124>)
 8005d62:	f7fd fedd 	bl	8003b20 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8005d66:	9b01      	ldr	r3, [sp, #4]
 8005d68:	689b      	ldr	r3, [r3, #8]
 8005d6a:	2b00      	cmp	r3, #0
 8005d6c:	d06c      	beq.n	8005e48 <chMtxLockS+0x108>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 8005d6e:	9b01      	ldr	r3, [sp, #4]
 8005d70:	689b      	ldr	r3, [r3, #8]
 8005d72:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8005d74:	e03b      	b.n	8005dee <chMtxLockS+0xae>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8005d76:	9b02      	ldr	r3, [sp, #8]
 8005d78:	689a      	ldr	r2, [r3, #8]
 8005d7a:	9b03      	ldr	r3, [sp, #12]
 8005d7c:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8005d7e:	9b03      	ldr	r3, [sp, #12]
 8005d80:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8005d84:	2b07      	cmp	r3, #7
 8005d86:	d016      	beq.n	8005db6 <chMtxLockS+0x76>
 8005d88:	2b07      	cmp	r3, #7
 8005d8a:	dc2e      	bgt.n	8005dea <chMtxLockS+0xaa>
 8005d8c:	2b00      	cmp	r3, #0
 8005d8e:	d01f      	beq.n	8005dd0 <chMtxLockS+0x90>
 8005d90:	2b06      	cmp	r3, #6
 8005d92:	d12a      	bne.n	8005dea <chMtxLockS+0xaa>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8005d94:	9b03      	ldr	r3, [sp, #12]
 8005d96:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005d98:	461c      	mov	r4, r3
 8005d9a:	9b03      	ldr	r3, [sp, #12]
 8005d9c:	4618      	mov	r0, r3
 8005d9e:	f7ff ff0f 	bl	8005bc0 <ch_queue_dequeue.lto_priv.2>
 8005da2:	4603      	mov	r3, r0
 8005da4:	4619      	mov	r1, r3
 8005da6:	4620      	mov	r0, r4
 8005da8:	f7ff ff5a 	bl	8005c60 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          tp = tp->u.wtmtxp->owner;
 8005dac:	9b03      	ldr	r3, [sp, #12]
 8005dae:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005db0:	689b      	ldr	r3, [r3, #8]
 8005db2:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8005db4:	e01b      	b.n	8005dee <chMtxLockS+0xae>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8005db6:	9b03      	ldr	r3, [sp, #12]
 8005db8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005dba:	461c      	mov	r4, r3
 8005dbc:	9b03      	ldr	r3, [sp, #12]
 8005dbe:	4618      	mov	r0, r3
 8005dc0:	f7ff fefe 	bl	8005bc0 <ch_queue_dequeue.lto_priv.2>
 8005dc4:	4603      	mov	r3, r0
 8005dc6:	4619      	mov	r1, r3
 8005dc8:	4620      	mov	r0, r4
 8005dca:	f7ff ff49 	bl	8005c60 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          break;
 8005dce:	e00d      	b.n	8005dec <chMtxLockS+0xac>
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8005dd0:	9b03      	ldr	r3, [sp, #12]
 8005dd2:	2201      	movs	r2, #1
 8005dd4:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 8005dd8:	9b03      	ldr	r3, [sp, #12]
 8005dda:	4618      	mov	r0, r3
 8005ddc:	f7ff fef0 	bl	8005bc0 <ch_queue_dequeue.lto_priv.2>
 8005de0:	4603      	mov	r3, r0
 8005de2:	4618      	mov	r0, r3
 8005de4:	f7fe ff3c 	bl	8004c60 <chSchReadyI>
          break;
 8005de8:	e000      	b.n	8005dec <chMtxLockS+0xac>
        default:
          /* Nothing to do for other states.*/
          break;
 8005dea:	bf00      	nop
        }
        break;
 8005dec:	e005      	b.n	8005dfa <chMtxLockS+0xba>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8005dee:	9b03      	ldr	r3, [sp, #12]
 8005df0:	689a      	ldr	r2, [r3, #8]
 8005df2:	9b02      	ldr	r3, [sp, #8]
 8005df4:	689b      	ldr	r3, [r3, #8]
 8005df6:	429a      	cmp	r2, r3
 8005df8:	d3bd      	bcc.n	8005d76 <chMtxLockS+0x36>
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
 8005dfa:	9b01      	ldr	r3, [sp, #4]
 8005dfc:	9a02      	ldr	r2, [sp, #8]
 8005dfe:	4611      	mov	r1, r2
 8005e00:	4618      	mov	r0, r3
 8005e02:	f7ff ff2d 	bl	8005c60 <ch_sch_prio_insert.lto_priv.0>
      currtp->u.wtmtxp = mp;
 8005e06:	9b02      	ldr	r3, [sp, #8]
 8005e08:	9a01      	ldr	r2, [sp, #4]
 8005e0a:	629a      	str	r2, [r3, #40]	@ 0x28
      chSchGoSleepS(CH_STATE_WTMTX);
 8005e0c:	2006      	movs	r0, #6
 8005e0e:	f7fe ff47 	bl	8004ca0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 8005e12:	9b01      	ldr	r3, [sp, #4]
 8005e14:	689b      	ldr	r3, [r3, #8]
 8005e16:	9a02      	ldr	r2, [sp, #8]
 8005e18:	429a      	cmp	r2, r3
 8005e1a:	bf14      	ite	ne
 8005e1c:	2301      	movne	r3, #1
 8005e1e:	2300      	moveq	r3, #0
 8005e20:	b2db      	uxtb	r3, r3
 8005e22:	2b00      	cmp	r3, #0
 8005e24:	d002      	beq.n	8005e2c <chMtxLockS+0xec>
 8005e26:	480f      	ldr	r0, [pc, #60]	@ (8005e64 <chMtxLockS+0x124>)
 8005e28:	f7fd fe7a 	bl	8003b20 <chSysHalt>
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 8005e2c:	9b02      	ldr	r3, [sp, #8]
 8005e2e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005e30:	9a01      	ldr	r2, [sp, #4]
 8005e32:	429a      	cmp	r2, r3
 8005e34:	bf14      	ite	ne
 8005e36:	2301      	movne	r3, #1
 8005e38:	2300      	moveq	r3, #0
 8005e3a:	b2db      	uxtb	r3, r3
 8005e3c:	2b00      	cmp	r3, #0
 8005e3e:	d00d      	beq.n	8005e5c <chMtxLockS+0x11c>
 8005e40:	4808      	ldr	r0, [pc, #32]	@ (8005e64 <chMtxLockS+0x124>)
 8005e42:	f7fd fe6d 	bl	8003b20 <chSysHalt>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 8005e46:	e009      	b.n	8005e5c <chMtxLockS+0x11c>
    mp->owner = currtp;
 8005e48:	9b01      	ldr	r3, [sp, #4]
 8005e4a:	9a02      	ldr	r2, [sp, #8]
 8005e4c:	609a      	str	r2, [r3, #8]
    mp->next = currtp->mtxlist;
 8005e4e:	9b02      	ldr	r3, [sp, #8]
 8005e50:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005e52:	9b01      	ldr	r3, [sp, #4]
 8005e54:	60da      	str	r2, [r3, #12]
    currtp->mtxlist = mp;
 8005e56:	9b02      	ldr	r3, [sp, #8]
 8005e58:	9a01      	ldr	r2, [sp, #4]
 8005e5a:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 8005e5c:	bf00      	nop
 8005e5e:	b004      	add	sp, #16
 8005e60:	bd10      	pop	{r4, pc}
 8005e62:	bf00      	nop
 8005e64:	080070c8 	.word	0x080070c8
	...

08005e70 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8005e70:	b500      	push	{lr}
 8005e72:	b087      	sub	sp, #28
 8005e74:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8005e76:	f7ff ff1b 	bl	8005cb0 <chThdGetSelfX.lto_priv.2>
 8005e7a:	9003      	str	r0, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8005e7c:	9b01      	ldr	r3, [sp, #4]
 8005e7e:	2b00      	cmp	r3, #0
 8005e80:	bf0c      	ite	eq
 8005e82:	2301      	moveq	r3, #1
 8005e84:	2300      	movne	r3, #0
 8005e86:	b2db      	uxtb	r3, r3
 8005e88:	2b00      	cmp	r3, #0
 8005e8a:	d002      	beq.n	8005e92 <chMtxUnlock+0x22>
 8005e8c:	4839      	ldr	r0, [pc, #228]	@ (8005f74 <chMtxUnlock+0x104>)
 8005e8e:	f7fd fe47 	bl	8003b20 <chSysHalt>

  chSysLock();
 8005e92:	f7ff fea5 	bl	8005be0 <chSysLock.lto_priv.11>

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8005e96:	9b03      	ldr	r3, [sp, #12]
 8005e98:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005e9a:	2b00      	cmp	r3, #0
 8005e9c:	bf0c      	ite	eq
 8005e9e:	2301      	moveq	r3, #1
 8005ea0:	2300      	movne	r3, #0
 8005ea2:	b2db      	uxtb	r3, r3
 8005ea4:	2b00      	cmp	r3, #0
 8005ea6:	d002      	beq.n	8005eae <chMtxUnlock+0x3e>
 8005ea8:	4832      	ldr	r0, [pc, #200]	@ (8005f74 <chMtxUnlock+0x104>)
 8005eaa:	f7fd fe39 	bl	8003b20 <chSysHalt>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 8005eae:	9b03      	ldr	r3, [sp, #12]
 8005eb0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005eb2:	689b      	ldr	r3, [r3, #8]
 8005eb4:	9a03      	ldr	r2, [sp, #12]
 8005eb6:	429a      	cmp	r2, r3
 8005eb8:	bf14      	ite	ne
 8005eba:	2301      	movne	r3, #1
 8005ebc:	2300      	moveq	r3, #0
 8005ebe:	b2db      	uxtb	r3, r3
 8005ec0:	2b00      	cmp	r3, #0
 8005ec2:	d002      	beq.n	8005eca <chMtxUnlock+0x5a>
 8005ec4:	482b      	ldr	r0, [pc, #172]	@ (8005f74 <chMtxUnlock+0x104>)
 8005ec6:	f7fd fe2b 	bl	8003b20 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 8005eca:	9b03      	ldr	r3, [sp, #12]
 8005ecc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005ece:	9a01      	ldr	r2, [sp, #4]
 8005ed0:	429a      	cmp	r2, r3
 8005ed2:	bf14      	ite	ne
 8005ed4:	2301      	movne	r3, #1
 8005ed6:	2300      	moveq	r3, #0
 8005ed8:	b2db      	uxtb	r3, r3
 8005eda:	2b00      	cmp	r3, #0
 8005edc:	d002      	beq.n	8005ee4 <chMtxUnlock+0x74>
 8005ede:	4825      	ldr	r0, [pc, #148]	@ (8005f74 <chMtxUnlock+0x104>)
 8005ee0:	f7fd fe1e 	bl	8003b20 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 8005ee4:	9b01      	ldr	r3, [sp, #4]
 8005ee6:	68da      	ldr	r2, [r3, #12]
 8005ee8:	9b03      	ldr	r3, [sp, #12]
 8005eea:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8005eec:	9801      	ldr	r0, [sp, #4]
 8005eee:	f7ff fee7 	bl	8005cc0 <chMtxQueueNotEmptyS>
 8005ef2:	4603      	mov	r3, r0
 8005ef4:	2b00      	cmp	r3, #0
 8005ef6:	d034      	beq.n	8005f62 <chMtxUnlock+0xf2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 8005ef8:	9b03      	ldr	r3, [sp, #12]
 8005efa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005efc:	9304      	str	r3, [sp, #16]
      lmp = currtp->mtxlist;
 8005efe:	9b03      	ldr	r3, [sp, #12]
 8005f00:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005f02:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8005f04:	e012      	b.n	8005f2c <chMtxUnlock+0xbc>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8005f06:	9805      	ldr	r0, [sp, #20]
 8005f08:	f7ff feda 	bl	8005cc0 <chMtxQueueNotEmptyS>
 8005f0c:	4603      	mov	r3, r0
 8005f0e:	2b00      	cmp	r3, #0
 8005f10:	d009      	beq.n	8005f26 <chMtxUnlock+0xb6>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 8005f12:	9b05      	ldr	r3, [sp, #20]
 8005f14:	681b      	ldr	r3, [r3, #0]
 8005f16:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8005f18:	9a04      	ldr	r2, [sp, #16]
 8005f1a:	429a      	cmp	r2, r3
 8005f1c:	d203      	bcs.n	8005f26 <chMtxUnlock+0xb6>
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
 8005f1e:	9b05      	ldr	r3, [sp, #20]
 8005f20:	681b      	ldr	r3, [r3, #0]
 8005f22:	689b      	ldr	r3, [r3, #8]
 8005f24:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 8005f26:	9b05      	ldr	r3, [sp, #20]
 8005f28:	68db      	ldr	r3, [r3, #12]
 8005f2a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8005f2c:	9b05      	ldr	r3, [sp, #20]
 8005f2e:	2b00      	cmp	r3, #0
 8005f30:	d1e9      	bne.n	8005f06 <chMtxUnlock+0x96>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 8005f32:	9b03      	ldr	r3, [sp, #12]
 8005f34:	9a04      	ldr	r2, [sp, #16]
 8005f36:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
 8005f38:	9b01      	ldr	r3, [sp, #4]
 8005f3a:	4618      	mov	r0, r3
 8005f3c:	f7ff fe28 	bl	8005b90 <ch_queue_fifo_remove.lto_priv.2>
 8005f40:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 8005f42:	9b01      	ldr	r3, [sp, #4]
 8005f44:	9a02      	ldr	r2, [sp, #8]
 8005f46:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8005f48:	9b02      	ldr	r3, [sp, #8]
 8005f4a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005f4c:	9b01      	ldr	r3, [sp, #4]
 8005f4e:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8005f50:	9b02      	ldr	r3, [sp, #8]
 8005f52:	9a01      	ldr	r2, [sp, #4]
 8005f54:	63da      	str	r2, [r3, #60]	@ 0x3c

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8005f56:	9802      	ldr	r0, [sp, #8]
 8005f58:	f7fe fe82 	bl	8004c60 <chSchReadyI>
      chSchRescheduleS();
 8005f5c:	f7fe ffa0 	bl	8004ea0 <chSchRescheduleS>
 8005f60:	e002      	b.n	8005f68 <chMtxUnlock+0xf8>
    }
    else {
      mp->owner = NULL;
 8005f62:	9b01      	ldr	r3, [sp, #4]
 8005f64:	2200      	movs	r2, #0
 8005f66:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8005f68:	f7ff fe4a 	bl	8005c00 <chSysUnlock.lto_priv.11>
}
 8005f6c:	bf00      	nop
 8005f6e:	b007      	add	sp, #28
 8005f70:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f74:	080070d4 	.word	0x080070d4
	...

08005f80 <chSysLock.lto_priv.17>:
static inline void chSysLock(void) {
 8005f80:	b500      	push	{lr}
 8005f82:	b083      	sub	sp, #12
 8005f84:	2330      	movs	r3, #48	@ 0x30
 8005f86:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005f88:	9b01      	ldr	r3, [sp, #4]
 8005f8a:	f383 8811 	msr	BASEPRI, r3
}
 8005f8e:	bf00      	nop
}
 8005f90:	bf00      	nop
  __dbg_check_lock();
 8005f92:	f7fd fe4d 	bl	8003c30 <__dbg_check_lock>
}
 8005f96:	bf00      	nop
 8005f98:	b003      	add	sp, #12
 8005f9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f9e:	bf00      	nop

08005fa0 <chSysUnlock.lto_priv.17>:
static inline void chSysUnlock(void) {
 8005fa0:	b500      	push	{lr}
 8005fa2:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8005fa4:	f7fd fe6c 	bl	8003c80 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8005fa8:	4b12      	ldr	r3, [pc, #72]	@ (8005ff4 <chSysUnlock.lto_priv.17+0x54>)
 8005faa:	681b      	ldr	r3, [r3, #0]
 8005fac:	4a11      	ldr	r2, [pc, #68]	@ (8005ff4 <chSysUnlock.lto_priv.17+0x54>)
 8005fae:	4293      	cmp	r3, r2
 8005fb0:	bf14      	ite	ne
 8005fb2:	2301      	movne	r3, #1
 8005fb4:	2300      	moveq	r3, #0
 8005fb6:	b2db      	uxtb	r3, r3
 8005fb8:	2b00      	cmp	r3, #0
 8005fba:	d00f      	beq.n	8005fdc <chSysUnlock.lto_priv.17+0x3c>
 8005fbc:	4b0d      	ldr	r3, [pc, #52]	@ (8005ff4 <chSysUnlock.lto_priv.17+0x54>)
 8005fbe:	68db      	ldr	r3, [r3, #12]
 8005fc0:	689a      	ldr	r2, [r3, #8]
 8005fc2:	4b0c      	ldr	r3, [pc, #48]	@ (8005ff4 <chSysUnlock.lto_priv.17+0x54>)
 8005fc4:	681b      	ldr	r3, [r3, #0]
 8005fc6:	689b      	ldr	r3, [r3, #8]
 8005fc8:	429a      	cmp	r2, r3
 8005fca:	bf34      	ite	cc
 8005fcc:	2301      	movcc	r3, #1
 8005fce:	2300      	movcs	r3, #0
 8005fd0:	b2db      	uxtb	r3, r3
 8005fd2:	2b00      	cmp	r3, #0
 8005fd4:	d002      	beq.n	8005fdc <chSysUnlock.lto_priv.17+0x3c>
 8005fd6:	4808      	ldr	r0, [pc, #32]	@ (8005ff8 <chSysUnlock.lto_priv.17+0x58>)
 8005fd8:	f7fd fda2 	bl	8003b20 <chSysHalt>
 8005fdc:	2300      	movs	r3, #0
 8005fde:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005fe0:	9b01      	ldr	r3, [sp, #4]
 8005fe2:	f383 8811 	msr	BASEPRI, r3
}
 8005fe6:	bf00      	nop
}
 8005fe8:	bf00      	nop
}
 8005fea:	bf00      	nop
 8005fec:	b003      	add	sp, #12
 8005fee:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ff2:	bf00      	nop
 8005ff4:	24000158 	.word	0x24000158
 8005ff8:	080070f4 	.word	0x080070f4
 8005ffc:	00000000 	.word	0x00000000

08006000 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8006000:	4b03      	ldr	r3, [pc, #12]	@ (8006010 <__core_init+0x10>)
 8006002:	4a04      	ldr	r2, [pc, #16]	@ (8006014 <__core_init+0x14>)
 8006004:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 8006006:	4b02      	ldr	r3, [pc, #8]	@ (8006010 <__core_init+0x10>)
 8006008:	4a03      	ldr	r2, [pc, #12]	@ (8006018 <__core_init+0x18>)
 800600a:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 800600c:	bf00      	nop
 800600e:	4770      	bx	lr
 8006010:	24000b20 	.word	0x24000b20
 8006014:	24000e40 	.word	0x24000e40
 8006018:	24080000 	.word	0x24080000
 800601c:	00000000 	.word	0x00000000

08006020 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8006020:	b500      	push	{lr}
 8006022:	b087      	sub	sp, #28
 8006024:	9003      	str	r0, [sp, #12]
 8006026:	9102      	str	r1, [sp, #8]
 8006028:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 800602a:	f7fd ff19 	bl	8003e60 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800602e:	9b02      	ldr	r3, [sp, #8]
 8006030:	2b00      	cmp	r3, #0
 8006032:	bf0c      	ite	eq
 8006034:	2301      	moveq	r3, #1
 8006036:	2300      	movne	r3, #0
 8006038:	b2db      	uxtb	r3, r3
 800603a:	2b00      	cmp	r3, #0
 800603c:	d10a      	bne.n	8006054 <chCoreAllocFromTopI+0x34>
 800603e:	9b02      	ldr	r3, [sp, #8]
 8006040:	1e5a      	subs	r2, r3, #1
 8006042:	9b02      	ldr	r3, [sp, #8]
 8006044:	4013      	ands	r3, r2
 8006046:	2b00      	cmp	r3, #0
 8006048:	bf14      	ite	ne
 800604a:	2301      	movne	r3, #1
 800604c:	2300      	moveq	r3, #0
 800604e:	b2db      	uxtb	r3, r3
 8006050:	2b00      	cmp	r3, #0
 8006052:	d002      	beq.n	800605a <chCoreAllocFromTopI+0x3a>
 8006054:	4812      	ldr	r0, [pc, #72]	@ (80060a0 <chCoreAllocFromTopI+0x80>)
 8006056:	f7fd fd63 	bl	8003b20 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 800605a:	4b12      	ldr	r3, [pc, #72]	@ (80060a4 <chCoreAllocFromTopI+0x84>)
 800605c:	685a      	ldr	r2, [r3, #4]
 800605e:	9b03      	ldr	r3, [sp, #12]
 8006060:	425b      	negs	r3, r3
 8006062:	4413      	add	r3, r2
 8006064:	461a      	mov	r2, r3
 8006066:	9b02      	ldr	r3, [sp, #8]
 8006068:	425b      	negs	r3, r3
 800606a:	4013      	ands	r3, r2
 800606c:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 800606e:	9b01      	ldr	r3, [sp, #4]
 8006070:	425b      	negs	r3, r3
 8006072:	9a05      	ldr	r2, [sp, #20]
 8006074:	4413      	add	r3, r2
 8006076:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8006078:	4b0a      	ldr	r3, [pc, #40]	@ (80060a4 <chCoreAllocFromTopI+0x84>)
 800607a:	681b      	ldr	r3, [r3, #0]
 800607c:	9a04      	ldr	r2, [sp, #16]
 800607e:	429a      	cmp	r2, r3
 8006080:	d304      	bcc.n	800608c <chCoreAllocFromTopI+0x6c>
 8006082:	4b08      	ldr	r3, [pc, #32]	@ (80060a4 <chCoreAllocFromTopI+0x84>)
 8006084:	685b      	ldr	r3, [r3, #4]
 8006086:	9a04      	ldr	r2, [sp, #16]
 8006088:	429a      	cmp	r2, r3
 800608a:	d901      	bls.n	8006090 <chCoreAllocFromTopI+0x70>
    return NULL;
 800608c:	2300      	movs	r3, #0
 800608e:	e003      	b.n	8006098 <chCoreAllocFromTopI+0x78>
  }

  ch_memcore.topmem = prev;
 8006090:	4a04      	ldr	r2, [pc, #16]	@ (80060a4 <chCoreAllocFromTopI+0x84>)
 8006092:	9b04      	ldr	r3, [sp, #16]
 8006094:	6053      	str	r3, [r2, #4]

  return p;
 8006096:	9b05      	ldr	r3, [sp, #20]
}
 8006098:	4618      	mov	r0, r3
 800609a:	b007      	add	sp, #28
 800609c:	f85d fb04 	ldr.w	pc, [sp], #4
 80060a0:	080070e0 	.word	0x080070e0
 80060a4:	24000b20 	.word	0x24000b20
	...

080060b0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 80060b0:	b500      	push	{lr}
 80060b2:	b087      	sub	sp, #28
 80060b4:	9003      	str	r0, [sp, #12]
 80060b6:	9102      	str	r1, [sp, #8]
 80060b8:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 80060ba:	f7ff ff61 	bl	8005f80 <chSysLock.lto_priv.17>
  p = chCoreAllocFromTopI(size, align, offset);
 80060be:	9a01      	ldr	r2, [sp, #4]
 80060c0:	9902      	ldr	r1, [sp, #8]
 80060c2:	9803      	ldr	r0, [sp, #12]
 80060c4:	f7ff ffac 	bl	8006020 <chCoreAllocFromTopI>
 80060c8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 80060ca:	f7ff ff69 	bl	8005fa0 <chSysUnlock.lto_priv.17>

  return p;
 80060ce:	9b05      	ldr	r3, [sp, #20]
}
 80060d0:	4618      	mov	r0, r3
 80060d2:	b007      	add	sp, #28
 80060d4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080060e0 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 80060e0:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80060e2:	4b07      	ldr	r3, [pc, #28]	@ (8006100 <__heap_init+0x20>)
 80060e4:	4a07      	ldr	r2, [pc, #28]	@ (8006104 <__heap_init+0x24>)
 80060e6:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 80060e8:	4b05      	ldr	r3, [pc, #20]	@ (8006100 <__heap_init+0x20>)
 80060ea:	2200      	movs	r2, #0
 80060ec:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 80060ee:	4b04      	ldr	r3, [pc, #16]	@ (8006100 <__heap_init+0x20>)
 80060f0:	2200      	movs	r2, #0
 80060f2:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80060f4:	4804      	ldr	r0, [pc, #16]	@ (8006108 <__heap_init+0x28>)
 80060f6:	f7ff fdf3 	bl	8005ce0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 80060fa:	bf00      	nop
 80060fc:	bd08      	pop	{r3, pc}
 80060fe:	bf00      	nop
 8006100:	24000b28 	.word	0x24000b28
 8006104:	080060b1 	.word	0x080060b1
 8006108:	24000b34 	.word	0x24000b34
 800610c:	00000000 	.word	0x00000000

08006110 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8006110:	b500      	push	{lr}
 8006112:	b087      	sub	sp, #28
 8006114:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8006116:	9b01      	ldr	r3, [sp, #4]
 8006118:	2b00      	cmp	r3, #0
 800611a:	bf0c      	ite	eq
 800611c:	2301      	moveq	r3, #1
 800611e:	2300      	movne	r3, #0
 8006120:	b2db      	uxtb	r3, r3
 8006122:	2b00      	cmp	r3, #0
 8006124:	d109      	bne.n	800613a <chHeapFree+0x2a>
 8006126:	9b01      	ldr	r3, [sp, #4]
 8006128:	f003 0307 	and.w	r3, r3, #7
 800612c:	2b00      	cmp	r3, #0
 800612e:	bf14      	ite	ne
 8006130:	2301      	movne	r3, #1
 8006132:	2300      	moveq	r3, #0
 8006134:	b2db      	uxtb	r3, r3
 8006136:	2b00      	cmp	r3, #0
 8006138:	d002      	beq.n	8006140 <chHeapFree+0x30>
 800613a:	4843      	ldr	r0, [pc, #268]	@ (8006248 <chHeapFree+0x138>)
 800613c:	f7fd fcf0 	bl	8003b20 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8006140:	9b01      	ldr	r3, [sp, #4]
 8006142:	3b08      	subs	r3, #8
 8006144:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8006146:	9b04      	ldr	r3, [sp, #16]
 8006148:	681b      	ldr	r3, [r3, #0]
 800614a:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 800614c:	9b03      	ldr	r3, [sp, #12]
 800614e:	3304      	adds	r3, #4
 8006150:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8006152:	9b04      	ldr	r3, [sp, #16]
 8006154:	685b      	ldr	r3, [r3, #4]
 8006156:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8006158:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800615a:	9b04      	ldr	r3, [sp, #16]
 800615c:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800615e:	9b03      	ldr	r3, [sp, #12]
 8006160:	330c      	adds	r3, #12
 8006162:	4618      	mov	r0, r3
 8006164:	f7ff fddc 	bl	8005d20 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8006168:	9a04      	ldr	r2, [sp, #16]
 800616a:	9b05      	ldr	r3, [sp, #20]
 800616c:	429a      	cmp	r2, r3
 800616e:	bf2c      	ite	cs
 8006170:	2301      	movcs	r3, #1
 8006172:	2300      	movcc	r3, #0
 8006174:	b2db      	uxtb	r3, r3
 8006176:	2b00      	cmp	r3, #0
 8006178:	d010      	beq.n	800619c <chHeapFree+0x8c>
 800617a:	9b05      	ldr	r3, [sp, #20]
 800617c:	685b      	ldr	r3, [r3, #4]
 800617e:	3301      	adds	r3, #1
 8006180:	00db      	lsls	r3, r3, #3
 8006182:	9a05      	ldr	r2, [sp, #20]
 8006184:	4413      	add	r3, r2
 8006186:	9a04      	ldr	r2, [sp, #16]
 8006188:	429a      	cmp	r2, r3
 800618a:	bf34      	ite	cc
 800618c:	2301      	movcc	r3, #1
 800618e:	2300      	movcs	r3, #0
 8006190:	b2db      	uxtb	r3, r3
 8006192:	2b00      	cmp	r3, #0
 8006194:	d002      	beq.n	800619c <chHeapFree+0x8c>
 8006196:	482c      	ldr	r0, [pc, #176]	@ (8006248 <chHeapFree+0x138>)
 8006198:	f7fd fcc2 	bl	8003b20 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 800619c:	9b03      	ldr	r3, [sp, #12]
 800619e:	3304      	adds	r3, #4
 80061a0:	9a05      	ldr	r2, [sp, #20]
 80061a2:	429a      	cmp	r2, r3
 80061a4:	d003      	beq.n	80061ae <chHeapFree+0x9e>
 80061a6:	9a04      	ldr	r2, [sp, #16]
 80061a8:	9b05      	ldr	r3, [sp, #20]
 80061aa:	429a      	cmp	r2, r3
 80061ac:	d93d      	bls.n	800622a <chHeapFree+0x11a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80061ae:	9b05      	ldr	r3, [sp, #20]
 80061b0:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 80061b2:	2b00      	cmp	r3, #0
 80061b4:	d004      	beq.n	80061c0 <chHeapFree+0xb0>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80061b6:	9b05      	ldr	r3, [sp, #20]
 80061b8:	681b      	ldr	r3, [r3, #0]
 80061ba:	9a04      	ldr	r2, [sp, #16]
 80061bc:	429a      	cmp	r2, r3
 80061be:	d234      	bcs.n	800622a <chHeapFree+0x11a>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80061c0:	9b05      	ldr	r3, [sp, #20]
 80061c2:	681a      	ldr	r2, [r3, #0]
 80061c4:	9b04      	ldr	r3, [sp, #16]
 80061c6:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 80061c8:	9b05      	ldr	r3, [sp, #20]
 80061ca:	9a04      	ldr	r2, [sp, #16]
 80061cc:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80061ce:	9b04      	ldr	r3, [sp, #16]
 80061d0:	685b      	ldr	r3, [r3, #4]
 80061d2:	3301      	adds	r3, #1
 80061d4:	00db      	lsls	r3, r3, #3
 80061d6:	9a04      	ldr	r2, [sp, #16]
 80061d8:	441a      	add	r2, r3
 80061da:	9b04      	ldr	r3, [sp, #16]
 80061dc:	681b      	ldr	r3, [r3, #0]
 80061de:	429a      	cmp	r2, r3
 80061e0:	d10d      	bne.n	80061fe <chHeapFree+0xee>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80061e2:	9b04      	ldr	r3, [sp, #16]
 80061e4:	685a      	ldr	r2, [r3, #4]
 80061e6:	9b04      	ldr	r3, [sp, #16]
 80061e8:	681b      	ldr	r3, [r3, #0]
 80061ea:	685b      	ldr	r3, [r3, #4]
 80061ec:	4413      	add	r3, r2
 80061ee:	1c5a      	adds	r2, r3, #1
 80061f0:	9b04      	ldr	r3, [sp, #16]
 80061f2:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80061f4:	9b04      	ldr	r3, [sp, #16]
 80061f6:	681b      	ldr	r3, [r3, #0]
 80061f8:	681a      	ldr	r2, [r3, #0]
 80061fa:	9b04      	ldr	r3, [sp, #16]
 80061fc:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 80061fe:	9b05      	ldr	r3, [sp, #20]
 8006200:	685b      	ldr	r3, [r3, #4]
 8006202:	3301      	adds	r3, #1
 8006204:	00db      	lsls	r3, r3, #3
 8006206:	9a05      	ldr	r2, [sp, #20]
 8006208:	4413      	add	r3, r2
 800620a:	9a04      	ldr	r2, [sp, #16]
 800620c:	429a      	cmp	r2, r3
 800620e:	d110      	bne.n	8006232 <chHeapFree+0x122>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8006210:	9b05      	ldr	r3, [sp, #20]
 8006212:	685a      	ldr	r2, [r3, #4]
 8006214:	9b04      	ldr	r3, [sp, #16]
 8006216:	685b      	ldr	r3, [r3, #4]
 8006218:	4413      	add	r3, r2
 800621a:	1c5a      	adds	r2, r3, #1
 800621c:	9b05      	ldr	r3, [sp, #20]
 800621e:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8006220:	9b04      	ldr	r3, [sp, #16]
 8006222:	681a      	ldr	r2, [r3, #0]
 8006224:	9b05      	ldr	r3, [sp, #20]
 8006226:	601a      	str	r2, [r3, #0]
      }
      break;
 8006228:	e003      	b.n	8006232 <chHeapFree+0x122>
    }
    qp = H_NEXT(qp);
 800622a:	9b05      	ldr	r3, [sp, #20]
 800622c:	681b      	ldr	r3, [r3, #0]
 800622e:	9305      	str	r3, [sp, #20]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8006230:	e79a      	b.n	8006168 <chHeapFree+0x58>
      break;
 8006232:	bf00      	nop
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8006234:	9b03      	ldr	r3, [sp, #12]
 8006236:	330c      	adds	r3, #12
 8006238:	4618      	mov	r0, r3
 800623a:	f7ff fe19 	bl	8005e70 <chMtxUnlock>

  return;
 800623e:	bf00      	nop
}
 8006240:	b007      	add	sp, #28
 8006242:	f85d fb04 	ldr.w	pc, [sp], #4
 8006246:	bf00      	nop
 8006248:	08007100 	.word	0x08007100
 800624c:	00000000 	.word	0x00000000

08006250 <chSysLock.lto_priv.18>:
static inline void chSysLock(void) {
 8006250:	b500      	push	{lr}
 8006252:	b083      	sub	sp, #12
 8006254:	2330      	movs	r3, #48	@ 0x30
 8006256:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006258:	9b01      	ldr	r3, [sp, #4]
 800625a:	f383 8811 	msr	BASEPRI, r3
}
 800625e:	bf00      	nop
}
 8006260:	bf00      	nop
  __dbg_check_lock();
 8006262:	f7fd fce5 	bl	8003c30 <__dbg_check_lock>
}
 8006266:	bf00      	nop
 8006268:	b003      	add	sp, #12
 800626a:	f85d fb04 	ldr.w	pc, [sp], #4
 800626e:	bf00      	nop

08006270 <chSysUnlock.lto_priv.18>:
static inline void chSysUnlock(void) {
 8006270:	b500      	push	{lr}
 8006272:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8006274:	f7fd fd04 	bl	8003c80 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8006278:	4b12      	ldr	r3, [pc, #72]	@ (80062c4 <chSysUnlock.lto_priv.18+0x54>)
 800627a:	681b      	ldr	r3, [r3, #0]
 800627c:	4a11      	ldr	r2, [pc, #68]	@ (80062c4 <chSysUnlock.lto_priv.18+0x54>)
 800627e:	4293      	cmp	r3, r2
 8006280:	bf14      	ite	ne
 8006282:	2301      	movne	r3, #1
 8006284:	2300      	moveq	r3, #0
 8006286:	b2db      	uxtb	r3, r3
 8006288:	2b00      	cmp	r3, #0
 800628a:	d00f      	beq.n	80062ac <chSysUnlock.lto_priv.18+0x3c>
 800628c:	4b0d      	ldr	r3, [pc, #52]	@ (80062c4 <chSysUnlock.lto_priv.18+0x54>)
 800628e:	68db      	ldr	r3, [r3, #12]
 8006290:	689a      	ldr	r2, [r3, #8]
 8006292:	4b0c      	ldr	r3, [pc, #48]	@ (80062c4 <chSysUnlock.lto_priv.18+0x54>)
 8006294:	681b      	ldr	r3, [r3, #0]
 8006296:	689b      	ldr	r3, [r3, #8]
 8006298:	429a      	cmp	r2, r3
 800629a:	bf34      	ite	cc
 800629c:	2301      	movcc	r3, #1
 800629e:	2300      	movcs	r3, #0
 80062a0:	b2db      	uxtb	r3, r3
 80062a2:	2b00      	cmp	r3, #0
 80062a4:	d002      	beq.n	80062ac <chSysUnlock.lto_priv.18+0x3c>
 80062a6:	4808      	ldr	r0, [pc, #32]	@ (80062c8 <chSysUnlock.lto_priv.18+0x58>)
 80062a8:	f7fd fc3a 	bl	8003b20 <chSysHalt>
 80062ac:	2300      	movs	r3, #0
 80062ae:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80062b0:	9b01      	ldr	r3, [sp, #4]
 80062b2:	f383 8811 	msr	BASEPRI, r3
}
 80062b6:	bf00      	nop
}
 80062b8:	bf00      	nop
}
 80062ba:	bf00      	nop
 80062bc:	b003      	add	sp, #12
 80062be:	f85d fb04 	ldr.w	pc, [sp], #4
 80062c2:	bf00      	nop
 80062c4:	24000158 	.word	0x24000158
 80062c8:	08007124 	.word	0x08007124
 80062cc:	00000000 	.word	0x00000000

080062d0 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 80062d0:	b500      	push	{lr}
 80062d2:	b085      	sub	sp, #20
 80062d4:	9003      	str	r0, [sp, #12]
 80062d6:	9102      	str	r1, [sp, #8]
 80062d8:	9201      	str	r2, [sp, #4]
 80062da:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 80062dc:	9b03      	ldr	r3, [sp, #12]
 80062de:	2b00      	cmp	r3, #0
 80062e0:	bf0c      	ite	eq
 80062e2:	2301      	moveq	r3, #1
 80062e4:	2300      	movne	r3, #0
 80062e6:	b2db      	uxtb	r3, r3
 80062e8:	2b00      	cmp	r3, #0
 80062ea:	d107      	bne.n	80062fc <chPoolObjectInitAligned+0x2c>
 80062ec:	9b02      	ldr	r3, [sp, #8]
 80062ee:	2b03      	cmp	r3, #3
 80062f0:	bf94      	ite	ls
 80062f2:	2301      	movls	r3, #1
 80062f4:	2300      	movhi	r3, #0
 80062f6:	b2db      	uxtb	r3, r3
 80062f8:	2b00      	cmp	r3, #0
 80062fa:	d001      	beq.n	8006300 <chPoolObjectInitAligned+0x30>
 80062fc:	2301      	movs	r3, #1
 80062fe:	e000      	b.n	8006302 <chPoolObjectInitAligned+0x32>
 8006300:	2300      	movs	r3, #0
 8006302:	2b00      	cmp	r3, #0
 8006304:	d107      	bne.n	8006316 <chPoolObjectInitAligned+0x46>
 8006306:	9b01      	ldr	r3, [sp, #4]
 8006308:	2b03      	cmp	r3, #3
 800630a:	bf94      	ite	ls
 800630c:	2301      	movls	r3, #1
 800630e:	2300      	movhi	r3, #0
 8006310:	b2db      	uxtb	r3, r3
 8006312:	2b00      	cmp	r3, #0
 8006314:	d001      	beq.n	800631a <chPoolObjectInitAligned+0x4a>
 8006316:	2301      	movs	r3, #1
 8006318:	e000      	b.n	800631c <chPoolObjectInitAligned+0x4c>
 800631a:	2300      	movs	r3, #0
 800631c:	2b00      	cmp	r3, #0
 800631e:	d117      	bne.n	8006350 <chPoolObjectInitAligned+0x80>
 8006320:	9b01      	ldr	r3, [sp, #4]
 8006322:	2b00      	cmp	r3, #0
 8006324:	bf0c      	ite	eq
 8006326:	2301      	moveq	r3, #1
 8006328:	2300      	movne	r3, #0
 800632a:	b2db      	uxtb	r3, r3
 800632c:	2b00      	cmp	r3, #0
 800632e:	d10a      	bne.n	8006346 <chPoolObjectInitAligned+0x76>
 8006330:	9b01      	ldr	r3, [sp, #4]
 8006332:	1e5a      	subs	r2, r3, #1
 8006334:	9b01      	ldr	r3, [sp, #4]
 8006336:	4013      	ands	r3, r2
 8006338:	2b00      	cmp	r3, #0
 800633a:	bf14      	ite	ne
 800633c:	2301      	movne	r3, #1
 800633e:	2300      	moveq	r3, #0
 8006340:	b2db      	uxtb	r3, r3
 8006342:	2b00      	cmp	r3, #0
 8006344:	d001      	beq.n	800634a <chPoolObjectInitAligned+0x7a>
 8006346:	2301      	movs	r3, #1
 8006348:	e000      	b.n	800634c <chPoolObjectInitAligned+0x7c>
 800634a:	2300      	movs	r3, #0
 800634c:	2b00      	cmp	r3, #0
 800634e:	d002      	beq.n	8006356 <chPoolObjectInitAligned+0x86>
 8006350:	4809      	ldr	r0, [pc, #36]	@ (8006378 <chPoolObjectInitAligned+0xa8>)
 8006352:	f7fd fbe5 	bl	8003b20 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8006356:	9b03      	ldr	r3, [sp, #12]
 8006358:	2200      	movs	r2, #0
 800635a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 800635c:	9b03      	ldr	r3, [sp, #12]
 800635e:	9a02      	ldr	r2, [sp, #8]
 8006360:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8006362:	9b03      	ldr	r3, [sp, #12]
 8006364:	9a01      	ldr	r2, [sp, #4]
 8006366:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8006368:	9b03      	ldr	r3, [sp, #12]
 800636a:	9a00      	ldr	r2, [sp, #0]
 800636c:	60da      	str	r2, [r3, #12]
}
 800636e:	bf00      	nop
 8006370:	b005      	add	sp, #20
 8006372:	f85d fb04 	ldr.w	pc, [sp], #4
 8006376:	bf00      	nop
 8006378:	0800710c 	.word	0x0800710c
 800637c:	00000000 	.word	0x00000000

08006380 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8006380:	b500      	push	{lr}
 8006382:	b085      	sub	sp, #20
 8006384:	9001      	str	r0, [sp, #4]
 8006386:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8006388:	9b00      	ldr	r3, [sp, #0]
 800638a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 800638c:	f7fd fd68 	bl	8003e60 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8006390:	9b01      	ldr	r3, [sp, #4]
 8006392:	2b00      	cmp	r3, #0
 8006394:	bf0c      	ite	eq
 8006396:	2301      	moveq	r3, #1
 8006398:	2300      	movne	r3, #0
 800639a:	b2db      	uxtb	r3, r3
 800639c:	2b00      	cmp	r3, #0
 800639e:	d107      	bne.n	80063b0 <chPoolFreeI+0x30>
 80063a0:	9b00      	ldr	r3, [sp, #0]
 80063a2:	2b00      	cmp	r3, #0
 80063a4:	bf0c      	ite	eq
 80063a6:	2301      	moveq	r3, #1
 80063a8:	2300      	movne	r3, #0
 80063aa:	b2db      	uxtb	r3, r3
 80063ac:	2b00      	cmp	r3, #0
 80063ae:	d001      	beq.n	80063b4 <chPoolFreeI+0x34>
 80063b0:	2301      	movs	r3, #1
 80063b2:	e000      	b.n	80063b6 <chPoolFreeI+0x36>
 80063b4:	2300      	movs	r3, #0
 80063b6:	2b00      	cmp	r3, #0
 80063b8:	d10b      	bne.n	80063d2 <chPoolFreeI+0x52>
 80063ba:	9b01      	ldr	r3, [sp, #4]
 80063bc:	689b      	ldr	r3, [r3, #8]
 80063be:	1e5a      	subs	r2, r3, #1
 80063c0:	9b00      	ldr	r3, [sp, #0]
 80063c2:	4013      	ands	r3, r2
 80063c4:	2b00      	cmp	r3, #0
 80063c6:	bf14      	ite	ne
 80063c8:	2301      	movne	r3, #1
 80063ca:	2300      	moveq	r3, #0
 80063cc:	b2db      	uxtb	r3, r3
 80063ce:	2b00      	cmp	r3, #0
 80063d0:	d002      	beq.n	80063d8 <chPoolFreeI+0x58>
 80063d2:	4807      	ldr	r0, [pc, #28]	@ (80063f0 <chPoolFreeI+0x70>)
 80063d4:	f7fd fba4 	bl	8003b20 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80063d8:	9b01      	ldr	r3, [sp, #4]
 80063da:	681a      	ldr	r2, [r3, #0]
 80063dc:	9b03      	ldr	r3, [sp, #12]
 80063de:	601a      	str	r2, [r3, #0]
  mp->next = php;
 80063e0:	9b01      	ldr	r3, [sp, #4]
 80063e2:	9a03      	ldr	r2, [sp, #12]
 80063e4:	601a      	str	r2, [r3, #0]
}
 80063e6:	bf00      	nop
 80063e8:	b005      	add	sp, #20
 80063ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80063ee:	bf00      	nop
 80063f0:	08007130 	.word	0x08007130
	...

08006400 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8006400:	b500      	push	{lr}
 8006402:	b083      	sub	sp, #12
 8006404:	9001      	str	r0, [sp, #4]
 8006406:	9100      	str	r1, [sp, #0]

  chSysLock();
 8006408:	f7ff ff22 	bl	8006250 <chSysLock.lto_priv.18>
  chPoolFreeI(mp, objp);
 800640c:	9900      	ldr	r1, [sp, #0]
 800640e:	9801      	ldr	r0, [sp, #4]
 8006410:	f7ff ffb6 	bl	8006380 <chPoolFreeI>
  chSysUnlock();
 8006414:	f7ff ff2c 	bl	8006270 <chSysUnlock.lto_priv.18>
}
 8006418:	bf00      	nop
 800641a:	b003      	add	sp, #12
 800641c:	f85d fb04 	ldr.w	pc, [sp], #4

08006420 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8006420:	b500      	push	{lr}
 8006422:	b083      	sub	sp, #12
 8006424:	9001      	str	r0, [sp, #4]
 8006426:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8006428:	2200      	movs	r2, #0
 800642a:	9900      	ldr	r1, [sp, #0]
 800642c:	9801      	ldr	r0, [sp, #4]
 800642e:	f7ff fdf7 	bl	8006020 <chCoreAllocFromTopI>
 8006432:	4603      	mov	r3, r0
}
 8006434:	4618      	mov	r0, r3
 8006436:	b003      	add	sp, #12
 8006438:	f85d fb04 	ldr.w	pc, [sp], #4
 800643c:	0000      	movs	r0, r0
	...

08006440 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8006440:	b500      	push	{lr}
 8006442:	b085      	sub	sp, #20
 8006444:	9003      	str	r0, [sp, #12]
 8006446:	9102      	str	r1, [sp, #8]
 8006448:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 800644a:	9b01      	ldr	r3, [sp, #4]
 800644c:	2204      	movs	r2, #4
 800644e:	9902      	ldr	r1, [sp, #8]
 8006450:	9803      	ldr	r0, [sp, #12]
 8006452:	f7ff ff3d 	bl	80062d0 <chPoolObjectInitAligned>
}
 8006456:	bf00      	nop
 8006458:	b005      	add	sp, #20
 800645a:	f85d fb04 	ldr.w	pc, [sp], #4
 800645e:	bf00      	nop

08006460 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8006460:	b082      	sub	sp, #8
 8006462:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8006464:	9b01      	ldr	r3, [sp, #4]
 8006466:	9a01      	ldr	r2, [sp, #4]
 8006468:	601a      	str	r2, [r3, #0]
}
 800646a:	bf00      	nop
 800646c:	b002      	add	sp, #8
 800646e:	4770      	bx	lr

08006470 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8006470:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8006472:	4810      	ldr	r0, [pc, #64]	@ (80064b4 <__factory_init+0x44>)
 8006474:	f7ff fc34 	bl	8005ce0 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8006478:	480f      	ldr	r0, [pc, #60]	@ (80064b8 <__factory_init+0x48>)
 800647a:	f7ff fff1 	bl	8006460 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 800647e:	4a0f      	ldr	r2, [pc, #60]	@ (80064bc <__factory_init+0x4c>)
 8006480:	2114      	movs	r1, #20
 8006482:	480f      	ldr	r0, [pc, #60]	@ (80064c0 <__factory_init+0x50>)
 8006484:	f7ff ffdc 	bl	8006440 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8006488:	480e      	ldr	r0, [pc, #56]	@ (80064c4 <__factory_init+0x54>)
 800648a:	f7ff ffe9 	bl	8006460 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 800648e:	480e      	ldr	r0, [pc, #56]	@ (80064c8 <__factory_init+0x58>)
 8006490:	f7ff ffe6 	bl	8006460 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8006494:	4a09      	ldr	r2, [pc, #36]	@ (80064bc <__factory_init+0x4c>)
 8006496:	211c      	movs	r1, #28
 8006498:	480c      	ldr	r0, [pc, #48]	@ (80064cc <__factory_init+0x5c>)
 800649a:	f7ff ffd1 	bl	8006440 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 800649e:	480c      	ldr	r0, [pc, #48]	@ (80064d0 <__factory_init+0x60>)
 80064a0:	f7ff ffde 	bl	8006460 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 80064a4:	480b      	ldr	r0, [pc, #44]	@ (80064d4 <__factory_init+0x64>)
 80064a6:	f7ff ffdb 	bl	8006460 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 80064aa:	480b      	ldr	r0, [pc, #44]	@ (80064d8 <__factory_init+0x68>)
 80064ac:	f7ff ffd8 	bl	8006460 <dyn_list_init>
#endif
}
 80064b0:	bf00      	nop
 80064b2:	bd08      	pop	{r3, pc}
 80064b4:	24000b44 	.word	0x24000b44
 80064b8:	24000b54 	.word	0x24000b54
 80064bc:	08006421 	.word	0x08006421
 80064c0:	24000b58 	.word	0x24000b58
 80064c4:	24000b68 	.word	0x24000b68
 80064c8:	24000b6c 	.word	0x24000b6c
 80064cc:	24000b70 	.word	0x24000b70
 80064d0:	24000b80 	.word	0x24000b80
 80064d4:	24000b84 	.word	0x24000b84
 80064d8:	24000b88 	.word	0x24000b88
 80064dc:	00000000 	.word	0x00000000

080064e0 <__NVIC_SetPriorityGrouping>:
{
 80064e0:	b084      	sub	sp, #16
 80064e2:	9001      	str	r0, [sp, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80064e4:	9b01      	ldr	r3, [sp, #4]
 80064e6:	f003 0307 	and.w	r3, r3, #7
 80064ea:	9303      	str	r3, [sp, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80064ec:	4b0a      	ldr	r3, [pc, #40]	@ (8006518 <__NVIC_SetPriorityGrouping+0x38>)
 80064ee:	68db      	ldr	r3, [r3, #12]
 80064f0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80064f2:	9a02      	ldr	r2, [sp, #8]
 80064f4:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 80064f8:	4013      	ands	r3, r2
 80064fa:	9302      	str	r3, [sp, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80064fc:	9b03      	ldr	r3, [sp, #12]
 80064fe:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8006500:	9b02      	ldr	r3, [sp, #8]
 8006502:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 8006504:	4b05      	ldr	r3, [pc, #20]	@ (800651c <__NVIC_SetPriorityGrouping+0x3c>)
 8006506:	4313      	orrs	r3, r2
 8006508:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 800650a:	4a03      	ldr	r2, [pc, #12]	@ (8006518 <__NVIC_SetPriorityGrouping+0x38>)
 800650c:	9b02      	ldr	r3, [sp, #8]
 800650e:	60d3      	str	r3, [r2, #12]
}
 8006510:	bf00      	nop
 8006512:	b004      	add	sp, #16
 8006514:	4770      	bx	lr
 8006516:	bf00      	nop
 8006518:	e000ed00 	.word	0xe000ed00
 800651c:	05fa0000 	.word	0x05fa0000

08006520 <__NVIC_SetPriority>:
{
 8006520:	b082      	sub	sp, #8
 8006522:	4603      	mov	r3, r0
 8006524:	9100      	str	r1, [sp, #0]
 8006526:	f8ad 3006 	strh.w	r3, [sp, #6]
  if ((int32_t)(IRQn) >= 0)
 800652a:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800652e:	2b00      	cmp	r3, #0
 8006530:	db0a      	blt.n	8006548 <__NVIC_SetPriority+0x28>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006532:	9b00      	ldr	r3, [sp, #0]
 8006534:	b2da      	uxtb	r2, r3
 8006536:	490c      	ldr	r1, [pc, #48]	@ (8006568 <__NVIC_SetPriority+0x48>)
 8006538:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800653c:	0112      	lsls	r2, r2, #4
 800653e:	b2d2      	uxtb	r2, r2
 8006540:	440b      	add	r3, r1
 8006542:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 8006546:	e00b      	b.n	8006560 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006548:	9b00      	ldr	r3, [sp, #0]
 800654a:	b2da      	uxtb	r2, r3
 800654c:	4907      	ldr	r1, [pc, #28]	@ (800656c <__NVIC_SetPriority+0x4c>)
 800654e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8006552:	f003 030f 	and.w	r3, r3, #15
 8006556:	3b04      	subs	r3, #4
 8006558:	0112      	lsls	r2, r2, #4
 800655a:	b2d2      	uxtb	r2, r2
 800655c:	440b      	add	r3, r1
 800655e:	761a      	strb	r2, [r3, #24]
}
 8006560:	bf00      	nop
 8006562:	b002      	add	sp, #8
 8006564:	4770      	bx	lr
 8006566:	bf00      	nop
 8006568:	e000e100 	.word	0xe000e100
 800656c:	e000ed00 	.word	0xe000ed00

08006570 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8006570:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8006572:	f3ef 8309 	mrs	r3, PSP
 8006576:	9300      	str	r3, [sp, #0]
  return(result);
 8006578:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 800657a:	9303      	str	r3, [sp, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 800657c:	9b03      	ldr	r3, [sp, #12]
 800657e:	3320      	adds	r3, #32
 8006580:	9303      	str	r3, [sp, #12]
 8006582:	9b03      	ldr	r3, [sp, #12]
 8006584:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8006586:	9b01      	ldr	r3, [sp, #4]
 8006588:	f383 8809 	msr	PSP, r3
}
 800658c:	bf00      	nop
 800658e:	2300      	movs	r3, #0
 8006590:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006592:	9b02      	ldr	r3, [sp, #8]
 8006594:	f383 8811 	msr	BASEPRI, r3
}
 8006598:	bf00      	nop
 800659a:	bf00      	nop
}
 800659c:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 800659e:	bf00      	nop
 80065a0:	b004      	add	sp, #16
 80065a2:	4770      	bx	lr
	...

080065b0 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 80065b0:	b500      	push	{lr}
 80065b2:	b085      	sub	sp, #20
 80065b4:	9001      	str	r0, [sp, #4]
 80065b6:	2330      	movs	r3, #48	@ 0x30
 80065b8:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80065ba:	9b03      	ldr	r3, [sp, #12]
 80065bc:	f383 8811 	msr	BASEPRI, r3
}
 80065c0:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 80065c2:	b662      	cpsie	i
}
 80065c4:	bf00      	nop
}
 80065c6:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 80065c8:	2003      	movs	r0, #3
 80065ca:	f7ff ff89 	bl	80064e0 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80065ce:	4b0f      	ldr	r3, [pc, #60]	@ (800660c <port_init+0x5c>)
 80065d0:	68db      	ldr	r3, [r3, #12]
 80065d2:	4a0e      	ldr	r2, [pc, #56]	@ (800660c <port_init+0x5c>)
 80065d4:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 80065d8:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
 80065da:	4b0d      	ldr	r3, [pc, #52]	@ (8006610 <port_init+0x60>)
 80065dc:	4a0d      	ldr	r2, [pc, #52]	@ (8006614 <port_init+0x64>)
 80065de:	f8c3 2fb0 	str.w	r2, [r3, #4016]	@ 0xfb0
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80065e2:	4b0b      	ldr	r3, [pc, #44]	@ (8006610 <port_init+0x60>)
 80065e4:	681b      	ldr	r3, [r3, #0]
 80065e6:	4a0a      	ldr	r2, [pc, #40]	@ (8006610 <port_init+0x60>)
 80065e8:	f043 0301 	orr.w	r3, r3, #1
 80065ec:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 80065ee:	2102      	movs	r1, #2
 80065f0:	f06f 0004 	mvn.w	r0, #4
 80065f4:	f7ff ff94 	bl	8006520 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 80065f8:	2103      	movs	r1, #3
 80065fa:	f06f 0001 	mvn.w	r0, #1
 80065fe:	f7ff ff8f 	bl	8006520 <__NVIC_SetPriority>

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 8006602:	bf00      	nop
 8006604:	b005      	add	sp, #20
 8006606:	f85d fb04 	ldr.w	pc, [sp], #4
 800660a:	bf00      	nop
 800660c:	e000edf0 	.word	0xe000edf0
 8006610:	e0001000 	.word	0xe0001000
 8006614:	c5acce55 	.word	0xc5acce55
	...

08006620 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 8006620:	b500      	push	{lr}
 8006622:	b087      	sub	sp, #28
 8006624:	2330      	movs	r3, #48	@ 0x30
 8006626:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006628:	9b03      	ldr	r3, [sp, #12]
 800662a:	f383 8811 	msr	BASEPRI, r3
}
 800662e:	bf00      	nop
}
 8006630:	bf00      	nop
}
 8006632:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8006634:	4b18      	ldr	r3, [pc, #96]	@ (8006698 <__port_irq_epilogue+0x78>)
 8006636:	685b      	ldr	r3, [r3, #4]
 8006638:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800663c:	2b00      	cmp	r3, #0
 800663e:	d020      	beq.n	8006682 <__port_irq_epilogue+0x62>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8006640:	f3ef 8309 	mrs	r3, PSP
 8006644:	9301      	str	r3, [sp, #4]
  return(result);
 8006646:	9b01      	ldr	r3, [sp, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 8006648:	9305      	str	r3, [sp, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 800664a:	9b05      	ldr	r3, [sp, #20]
 800664c:	3b20      	subs	r3, #32
 800664e:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 8006650:	9b05      	ldr	r3, [sp, #20]
 8006652:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8006654:	9b04      	ldr	r3, [sp, #16]
 8006656:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 800665a:	61da      	str	r2, [r3, #28]
 800665c:	9b05      	ldr	r3, [sp, #20]
 800665e:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8006660:	9b02      	ldr	r3, [sp, #8]
 8006662:	f383 8809 	msr	PSP, r3
}
 8006666:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8006668:	f7fe fc3a 	bl	8004ee0 <chSchIsPreemptionRequired>
 800666c:	4603      	mov	r3, r0
 800666e:	2b00      	cmp	r3, #0
 8006670:	d003      	beq.n	800667a <__port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8006672:	4a0a      	ldr	r2, [pc, #40]	@ (800669c <__port_irq_epilogue+0x7c>)
 8006674:	9b04      	ldr	r3, [sp, #16]
 8006676:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8006678:	e00b      	b.n	8006692 <__port_irq_epilogue+0x72>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 800667a:	4a09      	ldr	r2, [pc, #36]	@ (80066a0 <__port_irq_epilogue+0x80>)
 800667c:	9b04      	ldr	r3, [sp, #16]
 800667e:	619a      	str	r2, [r3, #24]
    return;
 8006680:	e007      	b.n	8006692 <__port_irq_epilogue+0x72>
 8006682:	2300      	movs	r3, #0
 8006684:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006686:	9b00      	ldr	r3, [sp, #0]
 8006688:	f383 8811 	msr	BASEPRI, r3
}
 800668c:	bf00      	nop
}
 800668e:	bf00      	nop
}
 8006690:	bf00      	nop
  }
  port_unlock_from_isr();
}
 8006692:	b007      	add	sp, #28
 8006694:	f85d fb04 	ldr.w	pc, [sp], #4
 8006698:	e000ed00 	.word	0xe000ed00
 800669c:	080003e7 	.word	0x080003e7
 80066a0:	080003f2 	.word	0x080003f2
	...

080066b0 <portab_setup>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

void portab_setup(void) {
 80066b0:	b508      	push	{r3, lr}

  /* ADC inputs.*/
  palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG);
 80066b2:	2203      	movs	r2, #3
 80066b4:	2101      	movs	r1, #1
 80066b6:	4805      	ldr	r0, [pc, #20]	@ (80066cc <portab_setup+0x1c>)
 80066b8:	f7fc fdea 	bl	8003290 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 1, PAL_MODE_INPUT_ANALOG);
 80066bc:	2203      	movs	r2, #3
 80066be:	2102      	movs	r1, #2
 80066c0:	4803      	ldr	r0, [pc, #12]	@ (80066d0 <portab_setup+0x20>)
 80066c2:	f7fc fde5 	bl	8003290 <_pal_lld_setgroupmode>
}
 80066c6:	bf00      	nop
 80066c8:	bd08      	pop	{r3, pc}
 80066ca:	bf00      	nop
 80066cc:	58020000 	.word	0x58020000
 80066d0:	58020400 	.word	0x58020400
	...

080066e0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80066e0:	b082      	sub	sp, #8
 80066e2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 80066e4:	4b03      	ldr	r3, [pc, #12]	@ (80066f4 <chRegSetThreadName+0x14>)
 80066e6:	68db      	ldr	r3, [r3, #12]
 80066e8:	9a01      	ldr	r2, [sp, #4]
 80066ea:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 80066ec:	bf00      	nop
 80066ee:	b002      	add	sp, #8
 80066f0:	4770      	bx	lr
 80066f2:	bf00      	nop
 80066f4:	24000158 	.word	0x24000158
	...

08006700 <adccallback>:

/*
 * ADC streaming callback.
 */
size_t n= 0, nx = 0, ny = 0;
void adccallback(ADCDriver *adcp) {
 8006700:	b082      	sub	sp, #8
 8006702:	9001      	str	r0, [sp, #4]

  /* Updating counters.*/
  n++;
 8006704:	4b14      	ldr	r3, [pc, #80]	@ (8006758 <adccallback+0x58>)
 8006706:	681b      	ldr	r3, [r3, #0]
 8006708:	3301      	adds	r3, #1
 800670a:	4a13      	ldr	r2, [pc, #76]	@ (8006758 <adccallback+0x58>)
 800670c:	6013      	str	r3, [r2, #0]
  if (adcIsBufferComplete(adcp)) {
 800670e:	9b01      	ldr	r3, [sp, #4]
 8006710:	781b      	ldrb	r3, [r3, #0]
 8006712:	2b04      	cmp	r3, #4
 8006714:	d105      	bne.n	8006722 <adccallback+0x22>
    nx += 1;
 8006716:	4b11      	ldr	r3, [pc, #68]	@ (800675c <adccallback+0x5c>)
 8006718:	681b      	ldr	r3, [r3, #0]
 800671a:	3301      	adds	r3, #1
 800671c:	4a0f      	ldr	r2, [pc, #60]	@ (800675c <adccallback+0x5c>)
 800671e:	6013      	str	r3, [r2, #0]
 8006720:	e004      	b.n	800672c <adccallback+0x2c>
  }
  else {
    ny += 1;
 8006722:	4b0f      	ldr	r3, [pc, #60]	@ (8006760 <adccallback+0x60>)
 8006724:	681b      	ldr	r3, [r3, #0]
 8006726:	3301      	adds	r3, #1
 8006728:	4a0d      	ldr	r2, [pc, #52]	@ (8006760 <adccallback+0x60>)
 800672a:	6013      	str	r3, [r2, #0]
  }

  if ((n % 200) == 0U) {
 800672c:	4b0a      	ldr	r3, [pc, #40]	@ (8006758 <adccallback+0x58>)
 800672e:	681a      	ldr	r2, [r3, #0]
 8006730:	4b0c      	ldr	r3, [pc, #48]	@ (8006764 <adccallback+0x64>)
 8006732:	fba3 1302 	umull	r1, r3, r3, r2
 8006736:	099b      	lsrs	r3, r3, #6
 8006738:	21c8      	movs	r1, #200	@ 0xc8
 800673a:	fb01 f303 	mul.w	r3, r1, r3
 800673e:	1ad3      	subs	r3, r2, r3
 8006740:	2b00      	cmp	r3, #0
 8006742:	d105      	bne.n	8006750 <adccallback+0x50>
#if defined(PORTAB_LINE_LED2)
    palToggleLine(PORTAB_LINE_LED2);
 8006744:	4b08      	ldr	r3, [pc, #32]	@ (8006768 <adccallback+0x68>)
 8006746:	695b      	ldr	r3, [r3, #20]
 8006748:	4a07      	ldr	r2, [pc, #28]	@ (8006768 <adccallback+0x68>)
 800674a:	f083 0380 	eor.w	r3, r3, #128	@ 0x80
 800674e:	6153      	str	r3, [r2, #20]
#endif
  }
}
 8006750:	bf00      	nop
 8006752:	b002      	add	sp, #8
 8006754:	4770      	bx	lr
 8006756:	bf00      	nop
 8006758:	24000cc0 	.word	0x24000cc0
 800675c:	24000cc4 	.word	0x24000cc4
 8006760:	24000cc8 	.word	0x24000cc8
 8006764:	51eb851f 	.word	0x51eb851f
 8006768:	58020400 	.word	0x58020400
 800676c:	00000000 	.word	0x00000000

08006770 <adcerrorcallback>:

/*
 * ADC errors callback, should never happen.
 */
void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8006770:	b500      	push	{lr}
 8006772:	b083      	sub	sp, #12
 8006774:	9001      	str	r0, [sp, #4]
 8006776:	9100      	str	r1, [sp, #0]

  (void)adcp;
  (void)err;

  chSysHalt("it happened");
 8006778:	4803      	ldr	r0, [pc, #12]	@ (8006788 <adcerrorcallback+0x18>)
 800677a:	f7fd f9d1 	bl	8003b20 <chSysHalt>
}
 800677e:	bf00      	nop
 8006780:	b003      	add	sp, #12
 8006782:	f85d fb04 	ldr.w	pc, [sp], #4
 8006786:	bf00      	nop
 8006788:	08006ee0 	.word	0x08006ee0
 800678c:	00000000 	.word	0x00000000

08006790 <Thread1>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED attached to TP1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8006790:	b500      	push	{lr}
 8006792:	b083      	sub	sp, #12
 8006794:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 8006796:	4809      	ldr	r0, [pc, #36]	@ (80067bc <Thread1+0x2c>)
 8006798:	f7ff ffa2 	bl	80066e0 <chRegSetThreadName>
  while (true) {
    palSetLine(PORTAB_LINE_LED1);
 800679c:	4b08      	ldr	r3, [pc, #32]	@ (80067c0 <Thread1+0x30>)
 800679e:	2201      	movs	r2, #1
 80067a0:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 80067a2:	f241 3088 	movw	r0, #5000	@ 0x1388
 80067a6:	f7ff f803 	bl	80057b0 <chThdSleep>
    palClearLine(PORTAB_LINE_LED1);
 80067aa:	4b05      	ldr	r3, [pc, #20]	@ (80067c0 <Thread1+0x30>)
 80067ac:	2201      	movs	r2, #1
 80067ae:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 80067b0:	f241 3088 	movw	r0, #5000	@ 0x1388
 80067b4:	f7fe fffc 	bl	80057b0 <chThdSleep>
    palSetLine(PORTAB_LINE_LED1);
 80067b8:	bf00      	nop
 80067ba:	e7ef      	b.n	800679c <Thread1+0xc>
 80067bc:	08006eec 	.word	0x08006eec
 80067c0:	58020400 	.word	0x58020400
	...

080067d0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80067d0:	b500      	push	{lr}
 80067d2:	b085      	sub	sp, #20
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80067d4:	f7f9 ff24 	bl	8000620 <halInit>
  chSysInit();
 80067d8:	f7fd f972 	bl	8003ac0 <chSysInit>

  /* Board-dependent GPIO setup code.*/
  portab_setup();
 80067dc:	f7ff ff68 	bl	80066b0 <portab_setup>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 80067e0:	2300      	movs	r3, #0
 80067e2:	9300      	str	r3, [sp, #0]
 80067e4:	4b28      	ldr	r3, [pc, #160]	@ (8006888 <main+0xb8>)
 80067e6:	2280      	movs	r2, #128	@ 0x80
 80067e8:	f44f 71b8 	mov.w	r1, #368	@ 0x170
 80067ec:	4827      	ldr	r0, [pc, #156]	@ (800688c <main+0xbc>)
 80067ee:	f7fe fe97 	bl	8005520 <chThdCreateStatic>

  /*
   * Starting PORTAB_ADC1 driver and the temperature sensor.
   */
  adcStart(&PORTAB_ADC1, &portab_adccfg1);
 80067f2:	4927      	ldr	r1, [pc, #156]	@ (8006890 <main+0xc0>)
 80067f4:	4827      	ldr	r0, [pc, #156]	@ (8006894 <main+0xc4>)
 80067f6:	f7fa f86b 	bl	80008d0 <adcStart>
  adcSTM32EnableVREF(&PORTAB_ADC1);
 80067fa:	4826      	ldr	r0, [pc, #152]	@ (8006894 <main+0xc4>)
 80067fc:	f7fb fe70 	bl	80024e0 <adcSTM32EnableVREF>
  adcSTM32EnableTS(&PORTAB_ADC1);
 8006800:	4824      	ldr	r0, [pc, #144]	@ (8006894 <main+0xc4>)
 8006802:	f7fb fe7d 	bl	8002500 <adcSTM32EnableTS>

  /* Performing a one-shot conversion on two channels.*/
  adcConvert(&PORTAB_ADC1, &portab_adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
 8006806:	2302      	movs	r3, #2
 8006808:	4a23      	ldr	r2, [pc, #140]	@ (8006898 <main+0xc8>)
 800680a:	4924      	ldr	r1, [pc, #144]	@ (800689c <main+0xcc>)
 800680c:	4821      	ldr	r0, [pc, #132]	@ (8006894 <main+0xc4>)
 800680e:	f7fa f977 	bl	8000b00 <adcConvert>
  cacheBufferInvalidate(samples1, sizeof (samples1) / sizeof (adcsample_t));
 8006812:	4b21      	ldr	r3, [pc, #132]	@ (8006898 <main+0xc8>)
 8006814:	9303      	str	r3, [sp, #12]
 8006816:	9b03      	ldr	r3, [sp, #12]
 8006818:	3310      	adds	r3, #16
 800681a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("dsb 0xF":::"memory");
 800681c:	f3bf 8f4f 	dsb	sy
}
 8006820:	bf00      	nop
 8006822:	e006      	b.n	8006832 <main+0x62>
 8006824:	4a1e      	ldr	r2, [pc, #120]	@ (80068a0 <main+0xd0>)
 8006826:	9b03      	ldr	r3, [sp, #12]
 8006828:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c
 800682c:	9b03      	ldr	r3, [sp, #12]
 800682e:	3320      	adds	r3, #32
 8006830:	9303      	str	r3, [sp, #12]
 8006832:	9a03      	ldr	r2, [sp, #12]
 8006834:	9b02      	ldr	r3, [sp, #8]
 8006836:	429a      	cmp	r2, r3
 8006838:	d3f4      	bcc.n	8006824 <main+0x54>
  __ASM volatile ("dsb 0xF":::"memory");
 800683a:	f3bf 8f4f 	dsb	sy
}
 800683e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8006840:	f3bf 8f6f 	isb	sy
}
 8006844:	bf00      	nop

  /*
   * Starting PORTAB_GPT1 driver, it is used for triggering the ADC.
   */
  gptStart(&PORTAB_GPT1, &portab_gptcfg1);
 8006846:	4917      	ldr	r1, [pc, #92]	@ (80068a4 <main+0xd4>)
 8006848:	4817      	ldr	r0, [pc, #92]	@ (80068a8 <main+0xd8>)
 800684a:	f7fa f9f1 	bl	8000c30 <gptStart>

  /*
   * Starting an ADC continuous conversion triggered with a period of
   * 1/10000 second.
   */
  adcStartConversion(&PORTAB_ADC1, &portab_adcgrpcfg2,
 800684e:	2340      	movs	r3, #64	@ 0x40
 8006850:	4a16      	ldr	r2, [pc, #88]	@ (80068ac <main+0xdc>)
 8006852:	4917      	ldr	r1, [pc, #92]	@ (80068b0 <main+0xe0>)
 8006854:	480f      	ldr	r0, [pc, #60]	@ (8006894 <main+0xc4>)
 8006856:	f7fa f87b 	bl	8000950 <adcStartConversion>
                     samples2, ADC_GRP2_BUF_DEPTH);
  gptStartContinuous(&PORTAB_GPT1, 100U);
 800685a:	2164      	movs	r1, #100	@ 0x64
 800685c:	4812      	ldr	r0, [pc, #72]	@ (80068a8 <main+0xd8>)
 800685e:	f7fa fa37 	bl	8000cd0 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the
   * conversion is stopped.
   */
  while (true) {
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8006862:	4b14      	ldr	r3, [pc, #80]	@ (80068b4 <main+0xe4>)
 8006864:	691b      	ldr	r3, [r3, #16]
 8006866:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800686a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800686e:	d105      	bne.n	800687c <main+0xac>
      gptStopTimer(&PORTAB_GPT1);
 8006870:	480d      	ldr	r0, [pc, #52]	@ (80068a8 <main+0xd8>)
 8006872:	f7fa fa6d 	bl	8000d50 <gptStopTimer>
      adcStopConversion(&PORTAB_ADC1);
 8006876:	4807      	ldr	r0, [pc, #28]	@ (8006894 <main+0xc4>)
 8006878:	f7fa f8fa 	bl	8000a70 <adcStopConversion>
    }
    chThdSleepMilliseconds(500);
 800687c:	f241 3088 	movw	r0, #5000	@ 0x1388
 8006880:	f7fe ff96 	bl	80057b0 <chThdSleep>
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8006884:	e7ed      	b.n	8006862 <main+0x92>
 8006886:	bf00      	nop
 8006888:	08006791 	.word	0x08006791
 800688c:	24000cd0 	.word	0x24000cd0
 8006890:	0800714c 	.word	0x0800714c
 8006894:	24000000 	.word	0x24000000
 8006898:	24000ba0 	.word	0x24000ba0
 800689c:	08007154 	.word	0x08007154
 80068a0:	e000ed00 	.word	0xe000ed00
 80068a4:	0800713c 	.word	0x0800713c
 80068a8:	24000138 	.word	0x24000138
 80068ac:	24000bc0 	.word	0x24000bc0
 80068b0:	080071ac 	.word	0x080071ac
 80068b4:	58020800 	.word	0x58020800
