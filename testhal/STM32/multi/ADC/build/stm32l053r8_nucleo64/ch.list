
build/stm32l053r8_nucleo64/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000191 	.word	0x08000191
 8000008:	08004b21 	.word	0x08004b21
 800000c:	08000193 	.word	0x08000193
 8000010:	08000193 	.word	0x08000193
 8000014:	08000193 	.word	0x08000193
 8000018:	08000193 	.word	0x08000193
 800001c:	08000193 	.word	0x08000193
 8000020:	08000193 	.word	0x08000193
 8000024:	08000193 	.word	0x08000193
 8000028:	08000193 	.word	0x08000193
 800002c:	08000193 	.word	0x08000193
 8000030:	08000193 	.word	0x08000193
 8000034:	08000193 	.word	0x08000193
 8000038:	08000193 	.word	0x08000193
 800003c:	08000193 	.word	0x08000193
 8000040:	08000193 	.word	0x08000193
 8000044:	08000193 	.word	0x08000193
 8000048:	08000193 	.word	0x08000193
 800004c:	08000193 	.word	0x08000193
 8000050:	08000193 	.word	0x08000193
 8000054:	08000193 	.word	0x08000193
 8000058:	08000193 	.word	0x08000193
 800005c:	08000193 	.word	0x08000193
 8000060:	08000193 	.word	0x08000193
 8000064:	08001751 	.word	0x08001751
 8000068:	08000b71 	.word	0x08000b71
 800006c:	08000bc1 	.word	0x08000bc1
 8000070:	08001381 	.word	0x08001381
 8000074:	08000193 	.word	0x08000193
 8000078:	08000193 	.word	0x08000193
 800007c:	08000193 	.word	0x08000193
 8000080:	08000193 	.word	0x08000193
 8000084:	08000cd1 	.word	0x08000cd1
 8000088:	08000193 	.word	0x08000193
 800008c:	08000193 	.word	0x08000193
 8000090:	08000d31 	.word	0x08000d31
 8000094:	08000193 	.word	0x08000193
 8000098:	08000193 	.word	0x08000193
 800009c:	08000193 	.word	0x08000193
 80000a0:	08000193 	.word	0x08000193
 80000a4:	08000193 	.word	0x08000193
 80000a8:	08000193 	.word	0x08000193
 80000ac:	08000193 	.word	0x08000193
 80000b0:	08000193 	.word	0x08000193
 80000b4:	08000193 	.word	0x08000193
 80000b8:	08000193 	.word	0x08000193
 80000bc:	08000193 	.word	0x08000193

Disassembly of section .text:

080000c0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80000c0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80000c2:	4824      	ldr	r0, [pc, #144]	@ (8000154 <endfiniloop+0x6>)
                msr     MSP, r0
 80000c4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80000c8:	4823      	ldr	r0, [pc, #140]	@ (8000158 <endfiniloop+0xa>)
                msr     PSP, r0
 80000ca:	f380 8809 	msr	PSP, r0

                /* CPU mode initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 80000ce:	2002      	movs	r0, #2
                msr     CONTROL, r0
 80000d0:	f380 8814 	msr	CONTROL, r0
                isb
 80000d4:	f3bf 8f6f 	isb	sy
                str     r0, [r1]
#endif

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80000d8:	f000 f8d2 	bl	8000280 <__cpu_init>
#endif

                /* Early initialization..*/
                bl      __early_init
 80000dc:	f001 ff40 	bl	8001f60 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80000e0:	481e      	ldr	r0, [pc, #120]	@ (800015c <endfiniloop+0xe>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80000e2:	491f      	ldr	r1, [pc, #124]	@ (8000160 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 80000e4:	4a1b      	ldr	r2, [pc, #108]	@ (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
msloop:
                cmp     r1, r2
 80000e6:	4291      	cmp	r1, r2
                bge     endmsloop
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
                str     r0, [r1]
 80000ea:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000ec:	3104      	adds	r1, #4
                b       msloop
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80000f0:	491c      	ldr	r1, [pc, #112]	@ (8000164 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 80000f2:	4a19      	ldr	r2, [pc, #100]	@ (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
psloop:
                cmp     r1, r2
 80000f4:	4291      	cmp	r1, r2
                bge     endpsloop
 80000f6:	da02      	bge.n	80000fe <endpsloop>
                str     r0, [r1]
 80000f8:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000fa:	3104      	adds	r1, #4
                b       psloop
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 80000fe:	491a      	ldr	r1, [pc, #104]	@ (8000168 <endfiniloop+0x1a>)
                ldr     r2, =__data_base__
 8000100:	4a1a      	ldr	r2, [pc, #104]	@ (800016c <endfiniloop+0x1e>)
                ldr     r3, =__data_end__
 8000102:	4b1b      	ldr	r3, [pc, #108]	@ (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
dloop:
                cmp     r2, r3
 8000104:	429a      	cmp	r2, r3
                bge     enddloop
 8000106:	da04      	bge.n	8000112 <enddloop>
                ldr     r0, [r1]
 8000108:	6808      	ldr	r0, [r1, #0]
                str     r0, [r2]
 800010a:	6010      	str	r0, [r2, #0]
                adds    r1, #4
 800010c:	3104      	adds	r1, #4
                adds    r2, #4
 800010e:	3204      	adds	r2, #4
                b       dloop
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 8000112:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000114:	4917      	ldr	r1, [pc, #92]	@ (8000174 <endfiniloop+0x26>)
                ldr     r2, =__bss_end__
 8000116:	4a18      	ldr	r2, [pc, #96]	@ (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
bloop:
                cmp     r1, r2
 8000118:	4291      	cmp	r1, r2
                bge     endbloop
 800011a:	da02      	bge.n	8000122 <endbloop>
                str     r0, [r1]
 800011c:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 800011e:	3104      	adds	r1, #4
                b       bloop
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
endbloop:
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000122:	f000 f8c5 	bl	80002b0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000126:	f000 f8b3 	bl	8000290 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 800012a:	4c14      	ldr	r4, [pc, #80]	@ (800017c <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end__
 800012c:	4d14      	ldr	r5, [pc, #80]	@ (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
initloop:
                cmp     r4, r5
 800012e:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000130:	da03      	bge.n	800013a <endinitloop>
                ldr     r1, [r4]
 8000132:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000134:	4788      	blx	r1
                adds    r4, #4
 8000136:	3404      	adds	r4, #4
                b       initloop
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800013a:	f004 fdc1 	bl	8004cc0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800013e:	4c11      	ldr	r4, [pc, #68]	@ (8000184 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end__
 8000140:	4d11      	ldr	r5, [pc, #68]	@ (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
finiloop:
                cmp     r4, r5
 8000142:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000144:	da03      	bge.n	800014e <endfiniloop>
                ldr     r1, [r4]
 8000146:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000148:	4788      	blx	r1
                adds    r4, #4
 800014a:	3404      	adds	r4, #4
                b       finiloop
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800014e:	490f      	ldr	r1, [pc, #60]	@ (800018c <endfiniloop+0x3e>)
                bx      r1
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 8000154:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000158:	20000600 	.word	0x20000600
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800015c:	55555555 	.word	0x55555555
                ldr     r1, =__main_stack_base__
 8000160:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000164:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000168:	08005390 	.word	0x08005390
                ldr     r2, =__data_base__
 800016c:	20000600 	.word	0x20000600
                ldr     r3, =__data_end__
 8000170:	20000600 	.word	0x20000600
                ldr     r1, =__bss_base__
 8000174:	20000600 	.word	0x20000600
                ldr     r2, =__bss_end__
 8000178:	200013d8 	.word	0x200013d8
                ldr     r4, =__init_array_base__
 800017c:	080000c0 	.word	0x080000c0
                ldr     r5, =__init_array_end__
 8000180:	080000c0 	.word	0x080000c0
                ldr     r4, =__fini_array_base__
 8000184:	080000c0 	.word	0x080000c0
                ldr     r5, =__fini_array_end__
 8000188:	080000c0 	.word	0x080000c0
                ldr     r1, =__default_exit
 800018c:	080002a1 	.word	0x080002a1

08000190 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000190:	e796      	b.n	80000c0 <_crt0_entry>

08000192 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000192:	f000 f800 	bl	8000196 <_unhandled_exception>

08000196 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000196:	e7fe      	b.n	8000196 <_unhandled_exception>

08000198 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, lr}
 8000198:	b5f0      	push	{r4, r5, r6, r7, lr}
                mov     r4, r8
 800019a:	4644      	mov	r4, r8
                mov     r5, r9
 800019c:	464d      	mov	r5, r9
                mov     r6, r10
 800019e:	4656      	mov	r6, sl
                mov     r7, r11
 80001a0:	465f      	mov	r7, fp
                push    {r4, r5, r6, r7}
 80001a2:	b4f0      	push	{r4, r5, r6, r7}
                
                mov     r3, sp
 80001a4:	466b      	mov	r3, sp
                str     r3, [r1, #CONTEXT_OFFSET]
 80001a6:	60cb      	str	r3, [r1, #12]
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80001a8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80001aa:	469d      	mov	sp, r3
                
                pop     {r4, r5, r6, r7}
 80001ac:	bcf0      	pop	{r4, r5, r6, r7}
                mov     r8, r4
 80001ae:	46a0      	mov	r8, r4
                mov     r9, r5
 80001b0:	46a9      	mov	r9, r5
                mov     r10, r6
 80001b2:	46b2      	mov	sl, r6
                mov     r11, r7
 80001b4:	46bb      	mov	fp, r7
                pop     {r4, r5, r6, r7, pc}
 80001b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b8 <__port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_thread_start
__port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80001b8:	f001 fff2 	bl	80021a0 <__dbg_check_unlock>
#endif
#if CH_DBG_STATISTICS
                bl      __stats_stop_measure_crit_thd
#endif
                cpsie   i
 80001bc:	b662      	cpsie	i
                mov     r0, r5
 80001be:	1c28      	adds	r0, r5, #0
                blx     r4
 80001c0:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80001c2:	2000      	movs	r0, #0
                bl      chThdExit
 80001c4:	f003 fdbc 	bl	8003d40 <chThdExit>

080001c8 <.zombies>:
.zombies:       b       .zombies
 80001c8:	e7fe      	b.n	80001c8 <.zombies>

080001ca <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 80001ca:	f001 ffc1 	bl	8002150 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 80001ce:	f003 f9af 	bl	8003530 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80001d2:	f001 ffe5 	bl	80021a0 <__dbg_check_unlock>

080001d6 <__port_exit_from_isr>:
#if CH_DBG_STATISTICS
                bl      __stats_stop_measure_crit_thd
#endif
                .globl  __port_exit_from_isr
__port_exit_from_isr:
                ldr     r2, .L2
 80001d6:	4a02      	ldr	r2, [pc, #8]	@ (80001e0 <__port_exit_from_isr+0xa>)
                ldr     r3, .L3
 80001d8:	4b02      	ldr	r3, [pc, #8]	@ (80001e4 <__port_exit_from_isr+0xe>)
                str     r3, [r2, #0]
 80001da:	6013      	str	r3, [r2, #0]
#if CORTEX_ALTERNATE_SWITCH
                cpsie   i
#endif
.L1:            b       .L1
 80001dc:	e7fe      	b.n	80001dc <__port_exit_from_isr+0x6>
 80001de:	46c0      	nop			@ (mov r8, r8)
 80001e0:	e000ed04 	.word	0xe000ed04
 80001e4:	80000000 	.word	0x80000000

080001e8 <__udivsi3>:
 80001e8:	2900      	cmp	r1, #0
 80001ea:	d034      	beq.n	8000256 <.udivsi3_skip_div0_test+0x6a>

080001ec <.udivsi3_skip_div0_test>:
 80001ec:	2301      	movs	r3, #1
 80001ee:	2200      	movs	r2, #0
 80001f0:	b410      	push	{r4}
 80001f2:	4288      	cmp	r0, r1
 80001f4:	d32c      	bcc.n	8000250 <.udivsi3_skip_div0_test+0x64>
 80001f6:	2401      	movs	r4, #1
 80001f8:	0724      	lsls	r4, r4, #28
 80001fa:	42a1      	cmp	r1, r4
 80001fc:	d204      	bcs.n	8000208 <.udivsi3_skip_div0_test+0x1c>
 80001fe:	4281      	cmp	r1, r0
 8000200:	d202      	bcs.n	8000208 <.udivsi3_skip_div0_test+0x1c>
 8000202:	0109      	lsls	r1, r1, #4
 8000204:	011b      	lsls	r3, r3, #4
 8000206:	e7f8      	b.n	80001fa <.udivsi3_skip_div0_test+0xe>
 8000208:	00e4      	lsls	r4, r4, #3
 800020a:	42a1      	cmp	r1, r4
 800020c:	d204      	bcs.n	8000218 <.udivsi3_skip_div0_test+0x2c>
 800020e:	4281      	cmp	r1, r0
 8000210:	d202      	bcs.n	8000218 <.udivsi3_skip_div0_test+0x2c>
 8000212:	0049      	lsls	r1, r1, #1
 8000214:	005b      	lsls	r3, r3, #1
 8000216:	e7f8      	b.n	800020a <.udivsi3_skip_div0_test+0x1e>
 8000218:	4288      	cmp	r0, r1
 800021a:	d301      	bcc.n	8000220 <.udivsi3_skip_div0_test+0x34>
 800021c:	1a40      	subs	r0, r0, r1
 800021e:	431a      	orrs	r2, r3
 8000220:	084c      	lsrs	r4, r1, #1
 8000222:	42a0      	cmp	r0, r4
 8000224:	d302      	bcc.n	800022c <.udivsi3_skip_div0_test+0x40>
 8000226:	1b00      	subs	r0, r0, r4
 8000228:	085c      	lsrs	r4, r3, #1
 800022a:	4322      	orrs	r2, r4
 800022c:	088c      	lsrs	r4, r1, #2
 800022e:	42a0      	cmp	r0, r4
 8000230:	d302      	bcc.n	8000238 <.udivsi3_skip_div0_test+0x4c>
 8000232:	1b00      	subs	r0, r0, r4
 8000234:	089c      	lsrs	r4, r3, #2
 8000236:	4322      	orrs	r2, r4
 8000238:	08cc      	lsrs	r4, r1, #3
 800023a:	42a0      	cmp	r0, r4
 800023c:	d302      	bcc.n	8000244 <.udivsi3_skip_div0_test+0x58>
 800023e:	1b00      	subs	r0, r0, r4
 8000240:	08dc      	lsrs	r4, r3, #3
 8000242:	4322      	orrs	r2, r4
 8000244:	2800      	cmp	r0, #0
 8000246:	d003      	beq.n	8000250 <.udivsi3_skip_div0_test+0x64>
 8000248:	091b      	lsrs	r3, r3, #4
 800024a:	d001      	beq.n	8000250 <.udivsi3_skip_div0_test+0x64>
 800024c:	0909      	lsrs	r1, r1, #4
 800024e:	e7e3      	b.n	8000218 <.udivsi3_skip_div0_test+0x2c>
 8000250:	0010      	movs	r0, r2
 8000252:	bc10      	pop	{r4}
 8000254:	4770      	bx	lr
 8000256:	b501      	push	{r0, lr}
 8000258:	2000      	movs	r0, #0
 800025a:	f000 f80b 	bl	8000274 <__aeabi_idiv0>
 800025e:	bd02      	pop	{r1, pc}

08000260 <__aeabi_uidivmod>:
 8000260:	2900      	cmp	r1, #0
 8000262:	d0f8      	beq.n	8000256 <.udivsi3_skip_div0_test+0x6a>
 8000264:	b503      	push	{r0, r1, lr}
 8000266:	f7ff ffc1 	bl	80001ec <.udivsi3_skip_div0_test>
 800026a:	bc0e      	pop	{r1, r2, r3}
 800026c:	4342      	muls	r2, r0
 800026e:	1a89      	subs	r1, r1, r2
 8000270:	4718      	bx	r3
 8000272:	46c0      	nop			@ (mov r8, r8)

08000274 <__aeabi_idiv0>:
 8000274:	4770      	bx	lr
 8000276:	46c0      	nop			@ (mov r8, r8)
	...

08000280 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000280:	46c0      	nop			@ (mov r8, r8)
 8000282:	4770      	bx	lr
	...

08000290 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000290:	46c0      	nop			@ (mov r8, r8)
 8000292:	4770      	bx	lr
	...

080002a0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
     asm volatile ("nop");
 80002a0:	46c0      	nop			@ (mov r8, r8)
 80002a2:	e7fd      	b.n	80002a0 <__default_exit>
	...

080002b0 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80002b0:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80002b2:	4b17      	ldr	r3, [pc, #92]	@ (8000310 <__init_ram_areas+0x60>)
 80002b4:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 80002b6:	9b03      	ldr	r3, [sp, #12]
 80002b8:	681b      	ldr	r3, [r3, #0]
 80002ba:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 80002bc:	9b03      	ldr	r3, [sp, #12]
 80002be:	685b      	ldr	r3, [r3, #4]
 80002c0:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80002c2:	e009      	b.n	80002d8 <__init_ram_areas+0x28>
      *p = *tp;
 80002c4:	9b02      	ldr	r3, [sp, #8]
 80002c6:	681a      	ldr	r2, [r3, #0]
 80002c8:	9b01      	ldr	r3, [sp, #4]
 80002ca:	601a      	str	r2, [r3, #0]
      p++;
 80002cc:	9b01      	ldr	r3, [sp, #4]
 80002ce:	3304      	adds	r3, #4
 80002d0:	9301      	str	r3, [sp, #4]
      tp++;
 80002d2:	9b02      	ldr	r3, [sp, #8]
 80002d4:	3304      	adds	r3, #4
 80002d6:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 80002d8:	9b03      	ldr	r3, [sp, #12]
 80002da:	689b      	ldr	r3, [r3, #8]
 80002dc:	9a01      	ldr	r2, [sp, #4]
 80002de:	429a      	cmp	r2, r3
 80002e0:	d3f0      	bcc.n	80002c4 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80002e2:	e005      	b.n	80002f0 <__init_ram_areas+0x40>
      *p = 0;
 80002e4:	9b01      	ldr	r3, [sp, #4]
 80002e6:	2200      	movs	r2, #0
 80002e8:	601a      	str	r2, [r3, #0]
      p++;
 80002ea:	9b01      	ldr	r3, [sp, #4]
 80002ec:	3304      	adds	r3, #4
 80002ee:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 80002f0:	9b03      	ldr	r3, [sp, #12]
 80002f2:	68db      	ldr	r3, [r3, #12]
 80002f4:	9a01      	ldr	r2, [sp, #4]
 80002f6:	429a      	cmp	r2, r3
 80002f8:	d3f4      	bcc.n	80002e4 <__init_ram_areas+0x34>
    }
    rap++;
 80002fa:	9b03      	ldr	r3, [sp, #12]
 80002fc:	3310      	adds	r3, #16
 80002fe:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000300:	9a03      	ldr	r2, [sp, #12]
 8000302:	4b04      	ldr	r3, [pc, #16]	@ (8000314 <__init_ram_areas+0x64>)
 8000304:	429a      	cmp	r2, r3
 8000306:	d3d6      	bcc.n	80002b6 <__init_ram_areas+0x6>
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8000308:	46c0      	nop			@ (mov r8, r8)
 800030a:	46c0      	nop			@ (mov r8, r8)
 800030c:	b004      	add	sp, #16
 800030e:	4770      	bx	lr
 8000310:	08004d80 	.word	0x08004d80
 8000314:	08004e00 	.word	0x08004e00
	...

08000320 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000320:	46c0      	nop			@ (mov r8, r8)
 8000322:	4770      	bx	lr
	...

08000330 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000330:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000332:	f7ff fff5 	bl	8000320 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000336:	f000 fd8b 	bl	8000e50 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 800033a:	f001 fb29 	bl	8001990 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800033e:	f000 f937 	bl	80005b0 <adcInit>
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 8000342:	f000 fadd 	bl	8000900 <gptInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000346:	f001 fe13 	bl	8001f70 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800034a:	f000 f851 	bl	80003f0 <stInit>
#endif
}
 800034e:	46c0      	nop			@ (mov r8, r8)
 8000350:	bd10      	pop	{r4, pc}
 8000352:	46c0      	nop			@ (mov r8, r8)
	...

08000360 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000360:	4b02      	ldr	r3, [pc, #8]	@ (800036c <st_lld_get_counter+0xc>)
 8000362:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000364:	b29b      	uxth	r3, r3
}
 8000366:	0018      	movs	r0, r3
 8000368:	4770      	bx	lr
 800036a:	46c0      	nop			@ (mov r8, r8)
 800036c:	40010800 	.word	0x40010800

08000370 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 8000370:	b082      	sub	sp, #8
 8000372:	0002      	movs	r2, r0
 8000374:	466b      	mov	r3, sp
 8000376:	3306      	adds	r3, #6
 8000378:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800037a:	4b07      	ldr	r3, [pc, #28]	@ (8000398 <st_lld_start_alarm+0x28>)
 800037c:	466a      	mov	r2, sp
 800037e:	3206      	adds	r2, #6
 8000380:	8812      	ldrh	r2, [r2, #0]
 8000382:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 8000384:	4b04      	ldr	r3, [pc, #16]	@ (8000398 <st_lld_start_alarm+0x28>)
 8000386:	2200      	movs	r2, #0
 8000388:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800038a:	4b03      	ldr	r3, [pc, #12]	@ (8000398 <st_lld_start_alarm+0x28>)
 800038c:	2202      	movs	r2, #2
 800038e:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 8000390:	46c0      	nop			@ (mov r8, r8)
 8000392:	b002      	add	sp, #8
 8000394:	4770      	bx	lr
 8000396:	46c0      	nop			@ (mov r8, r8)
 8000398:	40010800 	.word	0x40010800
 800039c:	00000000 	.word	0x00000000

080003a0 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 80003a0:	4b02      	ldr	r3, [pc, #8]	@ (80003ac <st_lld_stop_alarm+0xc>)
 80003a2:	2200      	movs	r2, #0
 80003a4:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 80003a6:	46c0      	nop			@ (mov r8, r8)
 80003a8:	4770      	bx	lr
 80003aa:	46c0      	nop			@ (mov r8, r8)
 80003ac:	40010800 	.word	0x40010800

080003b0 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 80003b0:	b082      	sub	sp, #8
 80003b2:	0002      	movs	r2, r0
 80003b4:	466b      	mov	r3, sp
 80003b6:	3306      	adds	r3, #6
 80003b8:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003ba:	4b04      	ldr	r3, [pc, #16]	@ (80003cc <st_lld_set_alarm+0x1c>)
 80003bc:	466a      	mov	r2, sp
 80003be:	3206      	adds	r2, #6
 80003c0:	8812      	ldrh	r2, [r2, #0]
 80003c2:	635a      	str	r2, [r3, #52]	@ 0x34
}
 80003c4:	46c0      	nop			@ (mov r8, r8)
 80003c6:	b002      	add	sp, #8
 80003c8:	4770      	bx	lr
 80003ca:	46c0      	nop			@ (mov r8, r8)
 80003cc:	40010800 	.word	0x40010800

080003d0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80003d0:	4b04      	ldr	r3, [pc, #16]	@ (80003e4 <st_lld_is_alarm_active+0x14>)
 80003d2:	68db      	ldr	r3, [r3, #12]
 80003d4:	2202      	movs	r2, #2
 80003d6:	4013      	ands	r3, r2
 80003d8:	1e5a      	subs	r2, r3, #1
 80003da:	4193      	sbcs	r3, r2
 80003dc:	b2db      	uxtb	r3, r3
}
 80003de:	0018      	movs	r0, r3
 80003e0:	4770      	bx	lr
 80003e2:	46c0      	nop			@ (mov r8, r8)
 80003e4:	40010800 	.word	0x40010800
	...

080003f0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80003f0:	b510      	push	{r4, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 80003f2:	f001 fbd5 	bl	8001ba0 <st_lld_init>
}
 80003f6:	46c0      	nop			@ (mov r8, r8)
 80003f8:	bd10      	pop	{r4, pc}
 80003fa:	46c0      	nop			@ (mov r8, r8)
 80003fc:	0000      	movs	r0, r0
	...

08000400 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 8000400:	b510      	push	{r4, lr}

  return st_lld_get_counter();
 8000402:	f7ff ffad 	bl	8000360 <st_lld_get_counter>
 8000406:	0003      	movs	r3, r0
}
 8000408:	0018      	movs	r0, r3
 800040a:	bd10      	pop	{r4, pc}
 800040c:	0000      	movs	r0, r0
	...

08000410 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000410:	b500      	push	{lr}
 8000412:	b083      	sub	sp, #12
 8000414:	0002      	movs	r2, r0
 8000416:	466b      	mov	r3, sp
 8000418:	3306      	adds	r3, #6
 800041a:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800041c:	f000 f840 	bl	80004a0 <stIsAlarmActive>
 8000420:	1e03      	subs	r3, r0, #0
 8000422:	d003      	beq.n	800042c <stStartAlarm+0x1c>
 8000424:	4b06      	ldr	r3, [pc, #24]	@ (8000440 <stStartAlarm+0x30>)
 8000426:	0018      	movs	r0, r3
 8000428:	f001 fe22 	bl	8002070 <chSysHalt>

  st_lld_start_alarm(abstime);
 800042c:	466b      	mov	r3, sp
 800042e:	3306      	adds	r3, #6
 8000430:	881b      	ldrh	r3, [r3, #0]
 8000432:	0018      	movs	r0, r3
 8000434:	f7ff ff9c 	bl	8000370 <st_lld_start_alarm>
}
 8000438:	46c0      	nop			@ (mov r8, r8)
 800043a:	b003      	add	sp, #12
 800043c:	bd00      	pop	{pc}
 800043e:	46c0      	nop			@ (mov r8, r8)
 8000440:	08004e00 	.word	0x08004e00
	...

08000450 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000450:	b510      	push	{r4, lr}

  st_lld_stop_alarm();
 8000452:	f7ff ffa5 	bl	80003a0 <st_lld_stop_alarm>
}
 8000456:	46c0      	nop			@ (mov r8, r8)
 8000458:	bd10      	pop	{r4, pc}
 800045a:	46c0      	nop			@ (mov r8, r8)
 800045c:	0000      	movs	r0, r0
	...

08000460 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000460:	b500      	push	{lr}
 8000462:	b083      	sub	sp, #12
 8000464:	0002      	movs	r2, r0
 8000466:	466b      	mov	r3, sp
 8000468:	3306      	adds	r3, #6
 800046a:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800046c:	f000 f818 	bl	80004a0 <stIsAlarmActive>
 8000470:	0003      	movs	r3, r0
 8000472:	001a      	movs	r2, r3
 8000474:	2301      	movs	r3, #1
 8000476:	4053      	eors	r3, r2
 8000478:	b2db      	uxtb	r3, r3
 800047a:	2b00      	cmp	r3, #0
 800047c:	d003      	beq.n	8000486 <stSetAlarm+0x26>
 800047e:	4b06      	ldr	r3, [pc, #24]	@ (8000498 <stSetAlarm+0x38>)
 8000480:	0018      	movs	r0, r3
 8000482:	f001 fdf5 	bl	8002070 <chSysHalt>

  st_lld_set_alarm(abstime);
 8000486:	466b      	mov	r3, sp
 8000488:	3306      	adds	r3, #6
 800048a:	881b      	ldrh	r3, [r3, #0]
 800048c:	0018      	movs	r0, r3
 800048e:	f7ff ff8f 	bl	80003b0 <st_lld_set_alarm>
}
 8000492:	46c0      	nop			@ (mov r8, r8)
 8000494:	b003      	add	sp, #12
 8000496:	bd00      	pop	{pc}
 8000498:	08004e10 	.word	0x08004e10
 800049c:	00000000 	.word	0x00000000

080004a0 <stIsAlarmActive>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @api
 */
bool stIsAlarmActive(void) {
 80004a0:	b510      	push	{r4, lr}

  return st_lld_is_alarm_active();
 80004a2:	f7ff ff95 	bl	80003d0 <st_lld_is_alarm_active>
 80004a6:	0003      	movs	r3, r0
}
 80004a8:	0018      	movs	r0, r3
 80004aa:	bd10      	pop	{r4, pc}
 80004ac:	0000      	movs	r0, r0
	...

080004b0 <port_lock.lto_priv.2>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004b0:	b672      	cpsid	i
}
 80004b2:	46c0      	nop			@ (mov r8, r8)
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80004b4:	46c0      	nop			@ (mov r8, r8)
 80004b6:	4770      	bx	lr
	...

080004c0 <port_unlock.lto_priv.2>:
  __ASM volatile ("cpsie i" : : : "memory");
 80004c0:	b662      	cpsie	i
}
 80004c2:	46c0      	nop			@ (mov r8, r8)
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80004c4:	46c0      	nop			@ (mov r8, r8)
 80004c6:	4770      	bx	lr
	...

080004d0 <chSysLock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 80004d0:	b510      	push	{r4, lr}

  port_lock();
 80004d2:	f7ff ffed 	bl	80004b0 <port_lock.lto_priv.2>
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 80004d6:	f001 fe3b 	bl	8002150 <__dbg_check_lock>
}
 80004da:	46c0      	nop			@ (mov r8, r8)
 80004dc:	bd10      	pop	{r4, pc}
 80004de:	46c0      	nop			@ (mov r8, r8)

080004e0 <chSysUnlock.lto_priv.2>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80004e0:	b510      	push	{r4, lr}

  __dbg_check_unlock();
 80004e2:	f001 fe5d 	bl	80021a0 <__dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80004e6:	4b0e      	ldr	r3, [pc, #56]	@ (8000520 <chSysUnlock.lto_priv.2+0x40>)
 80004e8:	681a      	ldr	r2, [r3, #0]
 80004ea:	4b0d      	ldr	r3, [pc, #52]	@ (8000520 <chSysUnlock.lto_priv.2+0x40>)
 80004ec:	1ad3      	subs	r3, r2, r3
 80004ee:	1e5a      	subs	r2, r3, #1
 80004f0:	4193      	sbcs	r3, r2
 80004f2:	b2db      	uxtb	r3, r3
 80004f4:	2b00      	cmp	r3, #0
 80004f6:	d00f      	beq.n	8000518 <chSysUnlock.lto_priv.2+0x38>
 80004f8:	4b09      	ldr	r3, [pc, #36]	@ (8000520 <chSysUnlock.lto_priv.2+0x40>)
 80004fa:	68db      	ldr	r3, [r3, #12]
 80004fc:	689a      	ldr	r2, [r3, #8]
 80004fe:	4b08      	ldr	r3, [pc, #32]	@ (8000520 <chSysUnlock.lto_priv.2+0x40>)
 8000500:	681b      	ldr	r3, [r3, #0]
 8000502:	689b      	ldr	r3, [r3, #8]
 8000504:	429a      	cmp	r2, r3
 8000506:	419b      	sbcs	r3, r3
 8000508:	425b      	negs	r3, r3
 800050a:	b2db      	uxtb	r3, r3
 800050c:	2b00      	cmp	r3, #0
 800050e:	d003      	beq.n	8000518 <chSysUnlock.lto_priv.2+0x38>
 8000510:	4b04      	ldr	r3, [pc, #16]	@ (8000524 <chSysUnlock.lto_priv.2+0x44>)
 8000512:	0018      	movs	r0, r3
 8000514:	f001 fdac 	bl	8002070 <chSysHalt>
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
 8000518:	f7ff ffd2 	bl	80004c0 <port_unlock.lto_priv.2>
}
 800051c:	46c0      	nop			@ (mov r8, r8)
 800051e:	bd10      	pop	{r4, pc}
 8000520:	20000690 	.word	0x20000690
 8000524:	08004e28 	.word	0x08004e28
	...

08000530 <osalSysLock.lto_priv.2>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000530:	b510      	push	{r4, lr}

  chSysLock();
 8000532:	f7ff ffcd 	bl	80004d0 <chSysLock.lto_priv.2>
}
 8000536:	46c0      	nop			@ (mov r8, r8)
 8000538:	bd10      	pop	{r4, pc}
 800053a:	46c0      	nop			@ (mov r8, r8)
 800053c:	0000      	movs	r0, r0
	...

08000540 <osalSysUnlock.lto_priv.2>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8000540:	b510      	push	{r4, lr}

  chSysUnlock();
 8000542:	f7ff ffcd 	bl	80004e0 <chSysUnlock.lto_priv.2>
}
 8000546:	46c0      	nop			@ (mov r8, r8)
 8000548:	bd10      	pop	{r4, pc}
 800054a:	46c0      	nop			@ (mov r8, r8)
 800054c:	0000      	movs	r0, r0
	...

08000550 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8000550:	b500      	push	{lr}
 8000552:	b083      	sub	sp, #12
 8000554:	9001      	str	r0, [sp, #4]

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8000556:	2301      	movs	r3, #1
 8000558:	425a      	negs	r2, r3
 800055a:	9b01      	ldr	r3, [sp, #4]
 800055c:	0011      	movs	r1, r2
 800055e:	0018      	movs	r0, r3
 8000560:	f003 fc4e 	bl	8003e00 <chThdSuspendTimeoutS>
 8000564:	0003      	movs	r3, r0
}
 8000566:	0018      	movs	r0, r3
 8000568:	b003      	add	sp, #12
 800056a:	bd00      	pop	{pc}
 800056c:	0000      	movs	r0, r0
	...

08000570 <osalThreadResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 8000570:	b500      	push	{lr}
 8000572:	b083      	sub	sp, #12
 8000574:	9001      	str	r0, [sp, #4]
 8000576:	9100      	str	r1, [sp, #0]

  chThdResumeS(trp, msg);
 8000578:	9a00      	ldr	r2, [sp, #0]
 800057a:	9b01      	ldr	r3, [sp, #4]
 800057c:	0011      	movs	r1, r2
 800057e:	0018      	movs	r0, r3
 8000580:	f003 fc96 	bl	8003eb0 <chThdResumeS>
}
 8000584:	46c0      	nop			@ (mov r8, r8)
 8000586:	b003      	add	sp, #12
 8000588:	bd00      	pop	{pc}
 800058a:	46c0      	nop			@ (mov r8, r8)
 800058c:	0000      	movs	r0, r0
	...

08000590 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8000590:	b500      	push	{lr}
 8000592:	b083      	sub	sp, #12
 8000594:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8000596:	9b01      	ldr	r3, [sp, #4]
 8000598:	0018      	movs	r0, r3
 800059a:	f003 fe39 	bl	8004210 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800059e:	46c0      	nop			@ (mov r8, r8)
 80005a0:	b003      	add	sp, #12
 80005a2:	bd00      	pop	{pc}
	...

080005b0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 80005b0:	b510      	push	{r4, lr}

  adc_lld_init();
 80005b2:	f000 ff05 	bl	80013c0 <adc_lld_init>
}
 80005b6:	46c0      	nop			@ (mov r8, r8)
 80005b8:	bd10      	pop	{r4, pc}
 80005ba:	46c0      	nop			@ (mov r8, r8)
 80005bc:	0000      	movs	r0, r0
	...

080005c0 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 80005c0:	b500      	push	{lr}
 80005c2:	b083      	sub	sp, #12
 80005c4:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 80005c6:	9b01      	ldr	r3, [sp, #4]
 80005c8:	2201      	movs	r2, #1
 80005ca:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 80005cc:	9b01      	ldr	r3, [sp, #4]
 80005ce:	2200      	movs	r2, #0
 80005d0:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 80005d2:	9b01      	ldr	r3, [sp, #4]
 80005d4:	2200      	movs	r2, #0
 80005d6:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 80005d8:	9b01      	ldr	r3, [sp, #4]
 80005da:	2200      	movs	r2, #0
 80005dc:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 80005de:	9b01      	ldr	r3, [sp, #4]
 80005e0:	2200      	movs	r2, #0
 80005e2:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 80005e4:	9b01      	ldr	r3, [sp, #4]
 80005e6:	2200      	movs	r2, #0
 80005e8:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 80005ea:	9b01      	ldr	r3, [sp, #4]
 80005ec:	3318      	adds	r3, #24
 80005ee:	0018      	movs	r0, r3
 80005f0:	f7ff ffce 	bl	8000590 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 80005f4:	46c0      	nop			@ (mov r8, r8)
 80005f6:	b003      	add	sp, #12
 80005f8:	bd00      	pop	{pc}
 80005fa:	46c0      	nop			@ (mov r8, r8)
 80005fc:	0000      	movs	r0, r0
	...

08000600 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8000600:	b500      	push	{lr}
 8000602:	b085      	sub	sp, #20
 8000604:	9001      	str	r0, [sp, #4]
 8000606:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck(adcp != NULL);
 8000608:	9b01      	ldr	r3, [sp, #4]
 800060a:	425a      	negs	r2, r3
 800060c:	4153      	adcs	r3, r2
 800060e:	b2db      	uxtb	r3, r3
 8000610:	2b00      	cmp	r3, #0
 8000612:	d003      	beq.n	800061c <adcStart+0x1c>
 8000614:	4b19      	ldr	r3, [pc, #100]	@ (800067c <adcStart+0x7c>)
 8000616:	0018      	movs	r0, r3
 8000618:	f001 fd2a 	bl	8002070 <chSysHalt>

  osalSysLock();
 800061c:	f7ff ff88 	bl	8000530 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 8000620:	9b01      	ldr	r3, [sp, #4]
 8000622:	781b      	ldrb	r3, [r3, #0]
 8000624:	3b01      	subs	r3, #1
 8000626:	1e5a      	subs	r2, r3, #1
 8000628:	4193      	sbcs	r3, r2
 800062a:	b2db      	uxtb	r3, r3
 800062c:	2b00      	cmp	r3, #0
 800062e:	d00b      	beq.n	8000648 <adcStart+0x48>
 8000630:	9b01      	ldr	r3, [sp, #4]
 8000632:	781b      	ldrb	r3, [r3, #0]
 8000634:	3b02      	subs	r3, #2
 8000636:	1e5a      	subs	r2, r3, #1
 8000638:	4193      	sbcs	r3, r2
 800063a:	b2db      	uxtb	r3, r3
 800063c:	2b00      	cmp	r3, #0
 800063e:	d003      	beq.n	8000648 <adcStart+0x48>
 8000640:	4b0e      	ldr	r3, [pc, #56]	@ (800067c <adcStart+0x7c>)
 8000642:	0018      	movs	r0, r3
 8000644:	f001 fd14 	bl	8002070 <chSysHalt>
                "invalid state");
  adcp->config = config;
 8000648:	9b01      	ldr	r3, [sp, #4]
 800064a:	9a00      	ldr	r2, [sp, #0]
 800064c:	605a      	str	r2, [r3, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
#else
  adc_lld_start(adcp);
 800064e:	9b01      	ldr	r3, [sp, #4]
 8000650:	0018      	movs	r0, r3
 8000652:	f000 fed5 	bl	8001400 <adc_lld_start>
  msg = HAL_RET_SUCCESS;
 8000656:	2300      	movs	r3, #0
 8000658:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 800065a:	9b03      	ldr	r3, [sp, #12]
 800065c:	2b00      	cmp	r3, #0
 800065e:	d103      	bne.n	8000668 <adcStart+0x68>
    adcp->state = ADC_READY;
 8000660:	9b01      	ldr	r3, [sp, #4]
 8000662:	2202      	movs	r2, #2
 8000664:	701a      	strb	r2, [r3, #0]
 8000666:	e002      	b.n	800066e <adcStart+0x6e>
  }
  else {
    adcp->state = ADC_STOP;
 8000668:	9b01      	ldr	r3, [sp, #4]
 800066a:	2201      	movs	r2, #1
 800066c:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 800066e:	f7ff ff67 	bl	8000540 <osalSysUnlock.lto_priv.2>

  return msg;
 8000672:	9b03      	ldr	r3, [sp, #12]
}
 8000674:	0018      	movs	r0, r3
 8000676:	b005      	add	sp, #20
 8000678:	bd00      	pop	{pc}
 800067a:	46c0      	nop			@ (mov r8, r8)
 800067c:	08004e1c 	.word	0x08004e1c

08000680 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 8000680:	b500      	push	{lr}
 8000682:	b085      	sub	sp, #20
 8000684:	9003      	str	r0, [sp, #12]
 8000686:	9102      	str	r1, [sp, #8]
 8000688:	9201      	str	r2, [sp, #4]
 800068a:	9300      	str	r3, [sp, #0]

  osalSysLock();
 800068c:	f7ff ff50 	bl	8000530 <osalSysLock.lto_priv.2>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000690:	9b00      	ldr	r3, [sp, #0]
 8000692:	9a01      	ldr	r2, [sp, #4]
 8000694:	9902      	ldr	r1, [sp, #8]
 8000696:	9803      	ldr	r0, [sp, #12]
 8000698:	f000 f80a 	bl	80006b0 <adcStartConversionI>
  osalSysUnlock();
 800069c:	f7ff ff50 	bl	8000540 <osalSysUnlock.lto_priv.2>
}
 80006a0:	46c0      	nop			@ (mov r8, r8)
 80006a2:	b005      	add	sp, #20
 80006a4:	bd00      	pop	{pc}
 80006a6:	46c0      	nop			@ (mov r8, r8)
	...

080006b0 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
 80006b0:	b500      	push	{lr}
 80006b2:	b085      	sub	sp, #20
 80006b4:	9003      	str	r0, [sp, #12]
 80006b6:	9102      	str	r1, [sp, #8]
 80006b8:	9201      	str	r2, [sp, #4]
 80006ba:	9300      	str	r3, [sp, #0]

  osalDbgCheckClassI();
 80006bc:	f001 fe48 	bl	8002350 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
 80006c0:	9b03      	ldr	r3, [sp, #12]
 80006c2:	425a      	negs	r2, r3
 80006c4:	4153      	adcs	r3, r2
 80006c6:	b2db      	uxtb	r3, r3
 80006c8:	2b00      	cmp	r3, #0
 80006ca:	d105      	bne.n	80006d8 <adcStartConversionI+0x28>
 80006cc:	9b02      	ldr	r3, [sp, #8]
 80006ce:	425a      	negs	r2, r3
 80006d0:	4153      	adcs	r3, r2
 80006d2:	b2db      	uxtb	r3, r3
 80006d4:	2b00      	cmp	r3, #0
 80006d6:	d001      	beq.n	80006dc <adcStartConversionI+0x2c>
 80006d8:	2301      	movs	r3, #1
 80006da:	e000      	b.n	80006de <adcStartConversionI+0x2e>
 80006dc:	2300      	movs	r3, #0
 80006de:	2b00      	cmp	r3, #0
 80006e0:	d105      	bne.n	80006ee <adcStartConversionI+0x3e>
 80006e2:	9b01      	ldr	r3, [sp, #4]
 80006e4:	425a      	negs	r2, r3
 80006e6:	4153      	adcs	r3, r2
 80006e8:	b2db      	uxtb	r3, r3
 80006ea:	2b00      	cmp	r3, #0
 80006ec:	d001      	beq.n	80006f2 <adcStartConversionI+0x42>
 80006ee:	2301      	movs	r3, #1
 80006f0:	e000      	b.n	80006f4 <adcStartConversionI+0x44>
 80006f2:	2300      	movs	r3, #0
 80006f4:	2b00      	cmp	r3, #0
 80006f6:	d105      	bne.n	8000704 <adcStartConversionI+0x54>
 80006f8:	9b00      	ldr	r3, [sp, #0]
 80006fa:	425a      	negs	r2, r3
 80006fc:	4153      	adcs	r3, r2
 80006fe:	b2db      	uxtb	r3, r3
 8000700:	2b00      	cmp	r3, #0
 8000702:	d001      	beq.n	8000708 <adcStartConversionI+0x58>
 8000704:	2301      	movs	r3, #1
 8000706:	e000      	b.n	800070a <adcStartConversionI+0x5a>
 8000708:	2300      	movs	r3, #0
 800070a:	2b00      	cmp	r3, #0
 800070c:	d10f      	bne.n	800072e <adcStartConversionI+0x7e>
 800070e:	9b00      	ldr	r3, [sp, #0]
 8000710:	3b01      	subs	r3, #1
 8000712:	1e5a      	subs	r2, r3, #1
 8000714:	4193      	sbcs	r3, r2
 8000716:	b2db      	uxtb	r3, r3
 8000718:	2b00      	cmp	r3, #0
 800071a:	d005      	beq.n	8000728 <adcStartConversionI+0x78>
 800071c:	9b00      	ldr	r3, [sp, #0]
 800071e:	2201      	movs	r2, #1
 8000720:	4013      	ands	r3, r2
 8000722:	d001      	beq.n	8000728 <adcStartConversionI+0x78>
 8000724:	2301      	movs	r3, #1
 8000726:	e000      	b.n	800072a <adcStartConversionI+0x7a>
 8000728:	2300      	movs	r3, #0
 800072a:	2b00      	cmp	r3, #0
 800072c:	d003      	beq.n	8000736 <adcStartConversionI+0x86>
 800072e:	4b15      	ldr	r3, [pc, #84]	@ (8000784 <adcStartConversionI+0xd4>)
 8000730:	0018      	movs	r0, r3
 8000732:	f001 fc9d 	bl	8002070 <chSysHalt>
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
 8000736:	9b03      	ldr	r3, [sp, #12]
 8000738:	781b      	ldrb	r3, [r3, #0]
 800073a:	3b02      	subs	r3, #2
 800073c:	1e5a      	subs	r2, r3, #1
 800073e:	4193      	sbcs	r3, r2
 8000740:	b2db      	uxtb	r3, r3
 8000742:	2b00      	cmp	r3, #0
 8000744:	d00b      	beq.n	800075e <adcStartConversionI+0xae>
 8000746:	9b03      	ldr	r3, [sp, #12]
 8000748:	781b      	ldrb	r3, [r3, #0]
 800074a:	3b05      	subs	r3, #5
 800074c:	1e5a      	subs	r2, r3, #1
 800074e:	4193      	sbcs	r3, r2
 8000750:	b2db      	uxtb	r3, r3
 8000752:	2b00      	cmp	r3, #0
 8000754:	d003      	beq.n	800075e <adcStartConversionI+0xae>
 8000756:	4b0b      	ldr	r3, [pc, #44]	@ (8000784 <adcStartConversionI+0xd4>)
 8000758:	0018      	movs	r0, r3
 800075a:	f001 fc89 	bl	8002070 <chSysHalt>
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 800075e:	9b03      	ldr	r3, [sp, #12]
 8000760:	9a01      	ldr	r2, [sp, #4]
 8000762:	609a      	str	r2, [r3, #8]
  adcp->depth    = depth;
 8000764:	9b03      	ldr	r3, [sp, #12]
 8000766:	9a00      	ldr	r2, [sp, #0]
 8000768:	60da      	str	r2, [r3, #12]
  adcp->grpp     = grpp;
 800076a:	9b03      	ldr	r3, [sp, #12]
 800076c:	9a02      	ldr	r2, [sp, #8]
 800076e:	611a      	str	r2, [r3, #16]
  adcp->state    = ADC_ACTIVE;
 8000770:	9b03      	ldr	r3, [sp, #12]
 8000772:	2203      	movs	r2, #3
 8000774:	701a      	strb	r2, [r3, #0]
  adc_lld_start_conversion(adcp);
 8000776:	9b03      	ldr	r3, [sp, #12]
 8000778:	0018      	movs	r0, r3
 800077a:	f000 fea9 	bl	80014d0 <adc_lld_start_conversion>
}
 800077e:	46c0      	nop			@ (mov r8, r8)
 8000780:	b005      	add	sp, #20
 8000782:	bd00      	pop	{pc}
 8000784:	08004e34 	.word	0x08004e34
	...

08000790 <adcStopConversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStopConversion(ADCDriver *adcp) {
 8000790:	b500      	push	{lr}
 8000792:	b083      	sub	sp, #12
 8000794:	9001      	str	r0, [sp, #4]

  osalDbgCheck(adcp != NULL);
 8000796:	9b01      	ldr	r3, [sp, #4]
 8000798:	425a      	negs	r2, r3
 800079a:	4153      	adcs	r3, r2
 800079c:	b2db      	uxtb	r3, r3
 800079e:	2b00      	cmp	r3, #0
 80007a0:	d003      	beq.n	80007aa <adcStopConversion+0x1a>
 80007a2:	4b1a      	ldr	r3, [pc, #104]	@ (800080c <adcStopConversion+0x7c>)
 80007a4:	0018      	movs	r0, r3
 80007a6:	f001 fc63 	bl	8002070 <chSysHalt>

  osalSysLock();
 80007aa:	f7ff fec1 	bl	8000530 <osalSysLock.lto_priv.2>
  osalDbgAssert((adcp->state == ADC_READY) || (adcp->state == ADC_ACTIVE),
 80007ae:	9b01      	ldr	r3, [sp, #4]
 80007b0:	781b      	ldrb	r3, [r3, #0]
 80007b2:	3b02      	subs	r3, #2
 80007b4:	1e5a      	subs	r2, r3, #1
 80007b6:	4193      	sbcs	r3, r2
 80007b8:	b2db      	uxtb	r3, r3
 80007ba:	2b00      	cmp	r3, #0
 80007bc:	d00b      	beq.n	80007d6 <adcStopConversion+0x46>
 80007be:	9b01      	ldr	r3, [sp, #4]
 80007c0:	781b      	ldrb	r3, [r3, #0]
 80007c2:	3b03      	subs	r3, #3
 80007c4:	1e5a      	subs	r2, r3, #1
 80007c6:	4193      	sbcs	r3, r2
 80007c8:	b2db      	uxtb	r3, r3
 80007ca:	2b00      	cmp	r3, #0
 80007cc:	d003      	beq.n	80007d6 <adcStopConversion+0x46>
 80007ce:	4b0f      	ldr	r3, [pc, #60]	@ (800080c <adcStopConversion+0x7c>)
 80007d0:	0018      	movs	r0, r3
 80007d2:	f001 fc4d 	bl	8002070 <chSysHalt>
                "invalid state");
  if (adcp->state != ADC_READY) {
 80007d6:	9b01      	ldr	r3, [sp, #4]
 80007d8:	781b      	ldrb	r3, [r3, #0]
 80007da:	2b02      	cmp	r3, #2
 80007dc:	d011      	beq.n	8000802 <adcStopConversion+0x72>
    adc_lld_stop_conversion(adcp);
 80007de:	9b01      	ldr	r3, [sp, #4]
 80007e0:	0018      	movs	r0, r3
 80007e2:	f000 ff15 	bl	8001610 <adc_lld_stop_conversion>
    adcp->grpp  = NULL;
 80007e6:	9b01      	ldr	r3, [sp, #4]
 80007e8:	2200      	movs	r2, #0
 80007ea:	611a      	str	r2, [r3, #16]
    adcp->state = ADC_READY;
 80007ec:	9b01      	ldr	r3, [sp, #4]
 80007ee:	2202      	movs	r2, #2
 80007f0:	701a      	strb	r2, [r3, #0]
    _adc_reset_s(adcp);
 80007f2:	9b01      	ldr	r3, [sp, #4]
 80007f4:	3314      	adds	r3, #20
 80007f6:	2202      	movs	r2, #2
 80007f8:	4252      	negs	r2, r2
 80007fa:	0011      	movs	r1, r2
 80007fc:	0018      	movs	r0, r3
 80007fe:	f7ff feb7 	bl	8000570 <osalThreadResumeS>
  }
  osalSysUnlock();
 8000802:	f7ff fe9d 	bl	8000540 <osalSysUnlock.lto_priv.2>
}
 8000806:	46c0      	nop			@ (mov r8, r8)
 8000808:	b003      	add	sp, #12
 800080a:	bd00      	pop	{pc}
 800080c:	08004e48 	.word	0x08004e48

08000810 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8000810:	b500      	push	{lr}
 8000812:	b087      	sub	sp, #28
 8000814:	9003      	str	r0, [sp, #12]
 8000816:	9102      	str	r1, [sp, #8]
 8000818:	9201      	str	r2, [sp, #4]
 800081a:	9300      	str	r3, [sp, #0]
  msg_t msg;

  osalSysLock();
 800081c:	f7ff fe88 	bl	8000530 <osalSysLock.lto_priv.2>
  osalDbgAssert(adcp->thread == NULL, "already waiting");
 8000820:	9b03      	ldr	r3, [sp, #12]
 8000822:	695b      	ldr	r3, [r3, #20]
 8000824:	1e5a      	subs	r2, r3, #1
 8000826:	4193      	sbcs	r3, r2
 8000828:	b2db      	uxtb	r3, r3
 800082a:	2b00      	cmp	r3, #0
 800082c:	d003      	beq.n	8000836 <adcConvert+0x26>
 800082e:	4b0b      	ldr	r3, [pc, #44]	@ (800085c <adcConvert+0x4c>)
 8000830:	0018      	movs	r0, r3
 8000832:	f001 fc1d 	bl	8002070 <chSysHalt>
  adcStartConversionI(adcp, grpp, samples, depth);
 8000836:	9b00      	ldr	r3, [sp, #0]
 8000838:	9a01      	ldr	r2, [sp, #4]
 800083a:	9902      	ldr	r1, [sp, #8]
 800083c:	9803      	ldr	r0, [sp, #12]
 800083e:	f7ff ff37 	bl	80006b0 <adcStartConversionI>
  msg = osalThreadSuspendS(&adcp->thread);
 8000842:	9b03      	ldr	r3, [sp, #12]
 8000844:	3314      	adds	r3, #20
 8000846:	0018      	movs	r0, r3
 8000848:	f7ff fe82 	bl	8000550 <osalThreadSuspendS>
 800084c:	0003      	movs	r3, r0
 800084e:	9305      	str	r3, [sp, #20]
  osalSysUnlock();
 8000850:	f7ff fe76 	bl	8000540 <osalSysUnlock.lto_priv.2>
  return msg;
 8000854:	9b05      	ldr	r3, [sp, #20]
}
 8000856:	0018      	movs	r0, r3
 8000858:	b007      	add	sp, #28
 800085a:	bd00      	pop	{pc}
 800085c:	08004e5c 	.word	0x08004e5c

08000860 <port_lock.lto_priv.3>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000860:	b672      	cpsid	i
}
 8000862:	46c0      	nop			@ (mov r8, r8)
}
 8000864:	46c0      	nop			@ (mov r8, r8)
 8000866:	4770      	bx	lr
	...

08000870 <port_unlock.lto_priv.3>:
  __ASM volatile ("cpsie i" : : : "memory");
 8000870:	b662      	cpsie	i
}
 8000872:	46c0      	nop			@ (mov r8, r8)
}
 8000874:	46c0      	nop			@ (mov r8, r8)
 8000876:	4770      	bx	lr
	...

08000880 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
 8000880:	b510      	push	{r4, lr}
  port_lock();
 8000882:	f7ff ffed 	bl	8000860 <port_lock.lto_priv.3>
  __dbg_check_lock();
 8000886:	f001 fc63 	bl	8002150 <__dbg_check_lock>
}
 800088a:	46c0      	nop			@ (mov r8, r8)
 800088c:	bd10      	pop	{r4, pc}
 800088e:	46c0      	nop			@ (mov r8, r8)

08000890 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
 8000890:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8000892:	f001 fc85 	bl	80021a0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000896:	4b0e      	ldr	r3, [pc, #56]	@ (80008d0 <chSysUnlock.lto_priv.3+0x40>)
 8000898:	681a      	ldr	r2, [r3, #0]
 800089a:	4b0d      	ldr	r3, [pc, #52]	@ (80008d0 <chSysUnlock.lto_priv.3+0x40>)
 800089c:	1ad3      	subs	r3, r2, r3
 800089e:	1e5a      	subs	r2, r3, #1
 80008a0:	4193      	sbcs	r3, r2
 80008a2:	b2db      	uxtb	r3, r3
 80008a4:	2b00      	cmp	r3, #0
 80008a6:	d00f      	beq.n	80008c8 <chSysUnlock.lto_priv.3+0x38>
 80008a8:	4b09      	ldr	r3, [pc, #36]	@ (80008d0 <chSysUnlock.lto_priv.3+0x40>)
 80008aa:	68db      	ldr	r3, [r3, #12]
 80008ac:	689a      	ldr	r2, [r3, #8]
 80008ae:	4b08      	ldr	r3, [pc, #32]	@ (80008d0 <chSysUnlock.lto_priv.3+0x40>)
 80008b0:	681b      	ldr	r3, [r3, #0]
 80008b2:	689b      	ldr	r3, [r3, #8]
 80008b4:	429a      	cmp	r2, r3
 80008b6:	419b      	sbcs	r3, r3
 80008b8:	425b      	negs	r3, r3
 80008ba:	b2db      	uxtb	r3, r3
 80008bc:	2b00      	cmp	r3, #0
 80008be:	d003      	beq.n	80008c8 <chSysUnlock.lto_priv.3+0x38>
 80008c0:	4b04      	ldr	r3, [pc, #16]	@ (80008d4 <chSysUnlock.lto_priv.3+0x44>)
 80008c2:	0018      	movs	r0, r3
 80008c4:	f001 fbd4 	bl	8002070 <chSysHalt>
  port_unlock();
 80008c8:	f7ff ffd2 	bl	8000870 <port_unlock.lto_priv.3>
}
 80008cc:	46c0      	nop			@ (mov r8, r8)
 80008ce:	bd10      	pop	{r4, pc}
 80008d0:	20000690 	.word	0x20000690
 80008d4:	08004e74 	.word	0x08004e74
	...

080008e0 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
 80008e0:	b510      	push	{r4, lr}
  chSysLock();
 80008e2:	f7ff ffcd 	bl	8000880 <chSysLock.lto_priv.3>
}
 80008e6:	46c0      	nop			@ (mov r8, r8)
 80008e8:	bd10      	pop	{r4, pc}
 80008ea:	46c0      	nop			@ (mov r8, r8)
 80008ec:	0000      	movs	r0, r0
	...

080008f0 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
 80008f0:	b510      	push	{r4, lr}
  chSysUnlock();
 80008f2:	f7ff ffcd 	bl	8000890 <chSysUnlock.lto_priv.3>
}
 80008f6:	46c0      	nop			@ (mov r8, r8)
 80008f8:	bd10      	pop	{r4, pc}
 80008fa:	46c0      	nop			@ (mov r8, r8)
 80008fc:	0000      	movs	r0, r0
	...

08000900 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8000900:	b510      	push	{r4, lr}

  gpt_lld_init();
 8000902:	f001 f9ad 	bl	8001c60 <gpt_lld_init>
}
 8000906:	46c0      	nop			@ (mov r8, r8)
 8000908:	bd10      	pop	{r4, pc}
 800090a:	46c0      	nop			@ (mov r8, r8)
 800090c:	0000      	movs	r0, r0
	...

08000910 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8000910:	b082      	sub	sp, #8
 8000912:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 8000914:	9b01      	ldr	r3, [sp, #4]
 8000916:	2201      	movs	r2, #1
 8000918:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 800091a:	9b01      	ldr	r3, [sp, #4]
 800091c:	2200      	movs	r2, #0
 800091e:	605a      	str	r2, [r3, #4]
}
 8000920:	46c0      	nop			@ (mov r8, r8)
 8000922:	b002      	add	sp, #8
 8000924:	4770      	bx	lr
 8000926:	46c0      	nop			@ (mov r8, r8)
	...

08000930 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8000930:	b500      	push	{lr}
 8000932:	b085      	sub	sp, #20
 8000934:	9001      	str	r0, [sp, #4]
 8000936:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 8000938:	9b01      	ldr	r3, [sp, #4]
 800093a:	425a      	negs	r2, r3
 800093c:	4153      	adcs	r3, r2
 800093e:	b2db      	uxtb	r3, r3
 8000940:	2b00      	cmp	r3, #0
 8000942:	d105      	bne.n	8000950 <gptStart+0x20>
 8000944:	9b00      	ldr	r3, [sp, #0]
 8000946:	425a      	negs	r2, r3
 8000948:	4153      	adcs	r3, r2
 800094a:	b2db      	uxtb	r3, r3
 800094c:	2b00      	cmp	r3, #0
 800094e:	d003      	beq.n	8000958 <gptStart+0x28>
 8000950:	4b19      	ldr	r3, [pc, #100]	@ (80009b8 <gptStart+0x88>)
 8000952:	0018      	movs	r0, r3
 8000954:	f001 fb8c 	bl	8002070 <chSysHalt>

  osalSysLock();
 8000958:	f7ff ffc2 	bl	80008e0 <osalSysLock.lto_priv.3>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
 800095c:	9b01      	ldr	r3, [sp, #4]
 800095e:	781b      	ldrb	r3, [r3, #0]
 8000960:	3b01      	subs	r3, #1
 8000962:	1e5a      	subs	r2, r3, #1
 8000964:	4193      	sbcs	r3, r2
 8000966:	b2db      	uxtb	r3, r3
 8000968:	2b00      	cmp	r3, #0
 800096a:	d00b      	beq.n	8000984 <gptStart+0x54>
 800096c:	9b01      	ldr	r3, [sp, #4]
 800096e:	781b      	ldrb	r3, [r3, #0]
 8000970:	3b02      	subs	r3, #2
 8000972:	1e5a      	subs	r2, r3, #1
 8000974:	4193      	sbcs	r3, r2
 8000976:	b2db      	uxtb	r3, r3
 8000978:	2b00      	cmp	r3, #0
 800097a:	d003      	beq.n	8000984 <gptStart+0x54>
 800097c:	4b0e      	ldr	r3, [pc, #56]	@ (80009b8 <gptStart+0x88>)
 800097e:	0018      	movs	r0, r3
 8000980:	f001 fb76 	bl	8002070 <chSysHalt>
              "invalid state");

  gptp->config = config;
 8000984:	9b01      	ldr	r3, [sp, #4]
 8000986:	9a00      	ldr	r2, [sp, #0]
 8000988:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 800098a:	9b01      	ldr	r3, [sp, #4]
 800098c:	0018      	movs	r0, r3
 800098e:	f001 f977 	bl	8001c80 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 8000992:	2300      	movs	r3, #0
 8000994:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 8000996:	9b03      	ldr	r3, [sp, #12]
 8000998:	2b00      	cmp	r3, #0
 800099a:	d103      	bne.n	80009a4 <gptStart+0x74>
    gptp->state = GPT_READY;
 800099c:	9b01      	ldr	r3, [sp, #4]
 800099e:	2202      	movs	r2, #2
 80009a0:	701a      	strb	r2, [r3, #0]
 80009a2:	e002      	b.n	80009aa <gptStart+0x7a>
  }
  else {
    gptp->state = GPT_STOP;
 80009a4:	9b01      	ldr	r3, [sp, #4]
 80009a6:	2201      	movs	r2, #1
 80009a8:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 80009aa:	f7ff ffa1 	bl	80008f0 <osalSysUnlock.lto_priv.3>

  return msg;
 80009ae:	9b03      	ldr	r3, [sp, #12]
}
 80009b0:	0018      	movs	r0, r3
 80009b2:	b005      	add	sp, #20
 80009b4:	bd00      	pop	{pc}
 80009b6:	46c0      	nop			@ (mov r8, r8)
 80009b8:	08004e68 	.word	0x08004e68
 80009bc:	00000000 	.word	0x00000000

080009c0 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 80009c0:	b500      	push	{lr}
 80009c2:	b083      	sub	sp, #12
 80009c4:	9001      	str	r0, [sp, #4]
 80009c6:	9100      	str	r1, [sp, #0]

  osalSysLock();
 80009c8:	f7ff ff8a 	bl	80008e0 <osalSysLock.lto_priv.3>
  gptStartContinuousI(gptp, interval);
 80009cc:	9a00      	ldr	r2, [sp, #0]
 80009ce:	9b01      	ldr	r3, [sp, #4]
 80009d0:	0011      	movs	r1, r2
 80009d2:	0018      	movs	r0, r3
 80009d4:	f000 f80c 	bl	80009f0 <gptStartContinuousI>
  osalSysUnlock();
 80009d8:	f7ff ff8a 	bl	80008f0 <osalSysUnlock.lto_priv.3>
}
 80009dc:	46c0      	nop			@ (mov r8, r8)
 80009de:	b003      	add	sp, #12
 80009e0:	bd00      	pop	{pc}
 80009e2:	46c0      	nop			@ (mov r8, r8)
	...

080009f0 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 80009f0:	b500      	push	{lr}
 80009f2:	b083      	sub	sp, #12
 80009f4:	9001      	str	r0, [sp, #4]
 80009f6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 80009f8:	f001 fcaa 	bl	8002350 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 80009fc:	9b01      	ldr	r3, [sp, #4]
 80009fe:	425a      	negs	r2, r3
 8000a00:	4153      	adcs	r3, r2
 8000a02:	b2db      	uxtb	r3, r3
 8000a04:	2b00      	cmp	r3, #0
 8000a06:	d003      	beq.n	8000a10 <gptStartContinuousI+0x20>
 8000a08:	4b0d      	ldr	r3, [pc, #52]	@ (8000a40 <gptStartContinuousI+0x50>)
 8000a0a:	0018      	movs	r0, r3
 8000a0c:	f001 fb30 	bl	8002070 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
 8000a10:	9b01      	ldr	r3, [sp, #4]
 8000a12:	781b      	ldrb	r3, [r3, #0]
 8000a14:	3b02      	subs	r3, #2
 8000a16:	1e5a      	subs	r2, r3, #1
 8000a18:	4193      	sbcs	r3, r2
 8000a1a:	b2db      	uxtb	r3, r3
 8000a1c:	2b00      	cmp	r3, #0
 8000a1e:	d003      	beq.n	8000a28 <gptStartContinuousI+0x38>
 8000a20:	4b07      	ldr	r3, [pc, #28]	@ (8000a40 <gptStartContinuousI+0x50>)
 8000a22:	0018      	movs	r0, r3
 8000a24:	f001 fb24 	bl	8002070 <chSysHalt>
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000a28:	9b01      	ldr	r3, [sp, #4]
 8000a2a:	2203      	movs	r2, #3
 8000a2c:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 8000a2e:	9a00      	ldr	r2, [sp, #0]
 8000a30:	9b01      	ldr	r3, [sp, #4]
 8000a32:	0011      	movs	r1, r2
 8000a34:	0018      	movs	r0, r3
 8000a36:	f001 f99b 	bl	8001d70 <gpt_lld_start_timer>
}
 8000a3a:	46c0      	nop			@ (mov r8, r8)
 8000a3c:	b003      	add	sp, #12
 8000a3e:	bd00      	pop	{pc}
 8000a40:	08004e80 	.word	0x08004e80
	...

08000a50 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000a50:	b500      	push	{lr}
 8000a52:	b083      	sub	sp, #12
 8000a54:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8000a56:	f7ff ff43 	bl	80008e0 <osalSysLock.lto_priv.3>
  gptStopTimerI(gptp);
 8000a5a:	9b01      	ldr	r3, [sp, #4]
 8000a5c:	0018      	movs	r0, r3
 8000a5e:	f000 f807 	bl	8000a70 <gptStopTimerI>
  osalSysUnlock();
 8000a62:	f7ff ff45 	bl	80008f0 <osalSysUnlock.lto_priv.3>
}
 8000a66:	46c0      	nop			@ (mov r8, r8)
 8000a68:	b003      	add	sp, #12
 8000a6a:	bd00      	pop	{pc}
 8000a6c:	0000      	movs	r0, r0
	...

08000a70 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000a70:	b500      	push	{lr}
 8000a72:	b083      	sub	sp, #12
 8000a74:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8000a76:	f001 fc6b 	bl	8002350 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000a7a:	9b01      	ldr	r3, [sp, #4]
 8000a7c:	425a      	negs	r2, r3
 8000a7e:	4153      	adcs	r3, r2
 8000a80:	b2db      	uxtb	r3, r3
 8000a82:	2b00      	cmp	r3, #0
 8000a84:	d003      	beq.n	8000a8e <gptStopTimerI+0x1e>
 8000a86:	4b17      	ldr	r3, [pc, #92]	@ (8000ae4 <gptStopTimerI+0x74>)
 8000a88:	0018      	movs	r0, r3
 8000a8a:	f001 faf1 	bl	8002070 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
 8000a8e:	9b01      	ldr	r3, [sp, #4]
 8000a90:	781b      	ldrb	r3, [r3, #0]
 8000a92:	3b02      	subs	r3, #2
 8000a94:	1e5a      	subs	r2, r3, #1
 8000a96:	4193      	sbcs	r3, r2
 8000a98:	b2db      	uxtb	r3, r3
 8000a9a:	2b00      	cmp	r3, #0
 8000a9c:	d009      	beq.n	8000ab2 <gptStopTimerI+0x42>
 8000a9e:	9b01      	ldr	r3, [sp, #4]
 8000aa0:	781b      	ldrb	r3, [r3, #0]
 8000aa2:	3b03      	subs	r3, #3
 8000aa4:	1e5a      	subs	r2, r3, #1
 8000aa6:	4193      	sbcs	r3, r2
 8000aa8:	b2db      	uxtb	r3, r3
 8000aaa:	2b00      	cmp	r3, #0
 8000aac:	d001      	beq.n	8000ab2 <gptStopTimerI+0x42>
 8000aae:	2301      	movs	r3, #1
 8000ab0:	e000      	b.n	8000ab4 <gptStopTimerI+0x44>
 8000ab2:	2300      	movs	r3, #0
 8000ab4:	2b00      	cmp	r3, #0
 8000ab6:	d00b      	beq.n	8000ad0 <gptStopTimerI+0x60>
 8000ab8:	9b01      	ldr	r3, [sp, #4]
 8000aba:	781b      	ldrb	r3, [r3, #0]
 8000abc:	3b04      	subs	r3, #4
 8000abe:	1e5a      	subs	r2, r3, #1
 8000ac0:	4193      	sbcs	r3, r2
 8000ac2:	b2db      	uxtb	r3, r3
 8000ac4:	2b00      	cmp	r3, #0
 8000ac6:	d003      	beq.n	8000ad0 <gptStopTimerI+0x60>
 8000ac8:	4b06      	ldr	r3, [pc, #24]	@ (8000ae4 <gptStopTimerI+0x74>)
 8000aca:	0018      	movs	r0, r3
 8000acc:	f001 fad0 	bl	8002070 <chSysHalt>
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000ad0:	9b01      	ldr	r3, [sp, #4]
 8000ad2:	2202      	movs	r2, #2
 8000ad4:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000ad6:	9b01      	ldr	r3, [sp, #4]
 8000ad8:	0018      	movs	r0, r3
 8000ada:	f001 f971 	bl	8001dc0 <gpt_lld_stop_timer>
}
 8000ade:	46c0      	nop			@ (mov r8, r8)
 8000ae0:	b003      	add	sp, #12
 8000ae2:	bd00      	pop	{pc}
 8000ae4:	08004e94 	.word	0x08004e94
	...

08000af0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000af0:	b082      	sub	sp, #8
 8000af2:	9001      	str	r0, [sp, #4]
 8000af4:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000af6:	4a1c      	ldr	r2, [pc, #112]	@ (8000b68 <nvicEnableVector+0x78>)
 8000af8:	9b01      	ldr	r3, [sp, #4]
 8000afa:	089b      	lsrs	r3, r3, #2
 8000afc:	33c0      	adds	r3, #192	@ 0xc0
 8000afe:	009b      	lsls	r3, r3, #2
 8000b00:	589b      	ldr	r3, [r3, r2]
 8000b02:	9a01      	ldr	r2, [sp, #4]
 8000b04:	2103      	movs	r1, #3
 8000b06:	400a      	ands	r2, r1
 8000b08:	00d2      	lsls	r2, r2, #3
 8000b0a:	21ff      	movs	r1, #255	@ 0xff
 8000b0c:	4091      	lsls	r1, r2
 8000b0e:	000a      	movs	r2, r1
 8000b10:	43d2      	mvns	r2, r2
 8000b12:	401a      	ands	r2, r3
 8000b14:	0011      	movs	r1, r2
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 8000b16:	9b00      	ldr	r3, [sp, #0]
 8000b18:	019a      	lsls	r2, r3, #6
 8000b1a:	9b01      	ldr	r3, [sp, #4]
 8000b1c:	2003      	movs	r0, #3
 8000b1e:	4003      	ands	r3, r0
 8000b20:	00db      	lsls	r3, r3, #3
 8000b22:	409a      	lsls	r2, r3
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000b24:	4810      	ldr	r0, [pc, #64]	@ (8000b68 <nvicEnableVector+0x78>)
 8000b26:	9b01      	ldr	r3, [sp, #4]
 8000b28:	089b      	lsrs	r3, r3, #2
 8000b2a:	430a      	orrs	r2, r1
 8000b2c:	33c0      	adds	r3, #192	@ 0xc0
 8000b2e:	009b      	lsls	r3, r3, #2
 8000b30:	501a      	str	r2, [r3, r0]
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000b32:	9b01      	ldr	r3, [sp, #4]
 8000b34:	221f      	movs	r2, #31
 8000b36:	401a      	ands	r2, r3
 8000b38:	490b      	ldr	r1, [pc, #44]	@ (8000b68 <nvicEnableVector+0x78>)
 8000b3a:	9b01      	ldr	r3, [sp, #4]
 8000b3c:	095b      	lsrs	r3, r3, #5
 8000b3e:	2001      	movs	r0, #1
 8000b40:	4090      	lsls	r0, r2
 8000b42:	0002      	movs	r2, r0
 8000b44:	3360      	adds	r3, #96	@ 0x60
 8000b46:	009b      	lsls	r3, r3, #2
 8000b48:	505a      	str	r2, [r3, r1]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000b4a:	9b01      	ldr	r3, [sp, #4]
 8000b4c:	221f      	movs	r2, #31
 8000b4e:	401a      	ands	r2, r3
 8000b50:	4905      	ldr	r1, [pc, #20]	@ (8000b68 <nvicEnableVector+0x78>)
 8000b52:	9b01      	ldr	r3, [sp, #4]
 8000b54:	095b      	lsrs	r3, r3, #5
 8000b56:	2001      	movs	r0, #1
 8000b58:	4090      	lsls	r0, r2
 8000b5a:	0002      	movs	r2, r0
 8000b5c:	009b      	lsls	r3, r3, #2
 8000b5e:	505a      	str	r2, [r3, r1]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000b60:	46c0      	nop			@ (mov r8, r8)
 8000b62:	b002      	add	sp, #8
 8000b64:	4770      	bx	lr
 8000b66:	46c0      	nop			@ (mov r8, r8)
 8000b68:	e000e100 	.word	0xe000e100
 8000b6c:	00000000 	.word	0x00000000

08000b70 <Vector68>:
/**
 * @brief   DMA1 streams 2 and 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH23_HANDLER) {
 8000b70:	b500      	push	{lr}
 8000b72:	b083      	sub	sp, #12
 8000b74:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000b76:	9301      	str	r3, [sp, #4]
 8000b78:	4b0d      	ldr	r3, [pc, #52]	@ (8000bb0 <Vector68+0x40>)
 8000b7a:	0018      	movs	r0, r3
 8000b7c:	f001 fd30 	bl	80025e0 <__trace_isr_enter>
 8000b80:	f001 fb86 	bl	8002290 <__dbg_check_enter_isr>

  /* Check on channel 2.*/
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000b84:	4b0b      	ldr	r3, [pc, #44]	@ (8000bb4 <Vector68+0x44>)
 8000b86:	0018      	movs	r0, r3
 8000b88:	f000 feca 	bl	8001920 <dmaServeInterrupt>

  /* Check on channel 3.*/
  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000b8c:	4b0a      	ldr	r3, [pc, #40]	@ (8000bb8 <Vector68+0x48>)
 8000b8e:	0018      	movs	r0, r3
 8000b90:	f000 fec6 	bl	8001920 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 8000b94:	f001 fbac 	bl	80022f0 <__dbg_check_leave_isr>
 8000b98:	4b05      	ldr	r3, [pc, #20]	@ (8000bb0 <Vector68+0x40>)
 8000b9a:	0018      	movs	r0, r3
 8000b9c:	f001 fd50 	bl	8002640 <__trace_isr_leave>
 8000ba0:	9b01      	ldr	r3, [sp, #4]
 8000ba2:	0018      	movs	r0, r3
 8000ba4:	f003 ffe4 	bl	8004b70 <__port_irq_epilogue>
}
 8000ba8:	46c0      	nop			@ (mov r8, r8)
 8000baa:	b003      	add	sp, #12
 8000bac:	bd00      	pop	{pc}
 8000bae:	46c0      	nop			@ (mov r8, r8)
 8000bb0:	08004ea4 	.word	0x08004ea4
 8000bb4:	08004f14 	.word	0x08004f14
 8000bb8:	08004f28 	.word	0x08004f28
 8000bbc:	00000000 	.word	0x00000000

08000bc0 <Vector6C>:
/**
 * @brief   DMA1 streams 4, 5, 6 and 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4567_HANDLER) {
 8000bc0:	b500      	push	{lr}
 8000bc2:	b083      	sub	sp, #12
 8000bc4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000bc6:	9301      	str	r3, [sp, #4]
 8000bc8:	4b11      	ldr	r3, [pc, #68]	@ (8000c10 <Vector6C+0x50>)
 8000bca:	0018      	movs	r0, r3
 8000bcc:	f001 fd08 	bl	80025e0 <__trace_isr_enter>
 8000bd0:	f001 fb5e 	bl	8002290 <__dbg_check_enter_isr>

  /* Check on channel 4.*/
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8000bd4:	4b0f      	ldr	r3, [pc, #60]	@ (8000c14 <Vector6C+0x54>)
 8000bd6:	0018      	movs	r0, r3
 8000bd8:	f000 fea2 	bl	8001920 <dmaServeInterrupt>

#if STM32_DMA1_NUM_CHANNELS >= 5
  /* Check on channel 5.*/
  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8000bdc:	4b0e      	ldr	r3, [pc, #56]	@ (8000c18 <Vector6C+0x58>)
 8000bde:	0018      	movs	r0, r3
 8000be0:	f000 fe9e 	bl	8001920 <dmaServeInterrupt>
#endif

#if STM32_DMA1_NUM_CHANNELS >= 6
  /* Check on channel 6.*/
  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8000be4:	4b0d      	ldr	r3, [pc, #52]	@ (8000c1c <Vector6C+0x5c>)
 8000be6:	0018      	movs	r0, r3
 8000be8:	f000 fe9a 	bl	8001920 <dmaServeInterrupt>
#endif

#if STM32_DMA1_NUM_CHANNELS >= 7
  /* Check on channel 7.*/
  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8000bec:	4b0c      	ldr	r3, [pc, #48]	@ (8000c20 <Vector6C+0x60>)
 8000bee:	0018      	movs	r0, r3
 8000bf0:	f000 fe96 	bl	8001920 <dmaServeInterrupt>
#endif

  OSAL_IRQ_EPILOGUE();
 8000bf4:	f001 fb7c 	bl	80022f0 <__dbg_check_leave_isr>
 8000bf8:	4b05      	ldr	r3, [pc, #20]	@ (8000c10 <Vector6C+0x50>)
 8000bfa:	0018      	movs	r0, r3
 8000bfc:	f001 fd20 	bl	8002640 <__trace_isr_leave>
 8000c00:	9b01      	ldr	r3, [sp, #4]
 8000c02:	0018      	movs	r0, r3
 8000c04:	f003 ffb4 	bl	8004b70 <__port_irq_epilogue>
}
 8000c08:	46c0      	nop			@ (mov r8, r8)
 8000c0a:	b003      	add	sp, #12
 8000c0c:	bd00      	pop	{pc}
 8000c0e:	46c0      	nop			@ (mov r8, r8)
 8000c10:	08004eb0 	.word	0x08004eb0
 8000c14:	08004f3c 	.word	0x08004f3c
 8000c18:	08004f50 	.word	0x08004f50
 8000c1c:	08004f64 	.word	0x08004f64
 8000c20:	08004f78 	.word	0x08004f78
	...

08000c30 <exti0_1_irq_init>:

static inline void exti0_1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_1_NUMBER, STM32_IRQ_EXTI0_1_PRIORITY);
#endif
}
 8000c30:	46c0      	nop			@ (mov r8, r8)
 8000c32:	4770      	bx	lr
	...

08000c40 <exti2_3_irq_init>:

static inline void exti2_3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_3_NUMBER, STM32_IRQ_EXTI2_3_PRIORITY);
#endif
}
 8000c40:	46c0      	nop			@ (mov r8, r8)
 8000c42:	4770      	bx	lr
	...

08000c50 <exti4_15_irq_init>:

static inline void exti4_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_15_NUMBER, STM32_IRQ_EXTI4_15_PRIORITY);
#endif
}
 8000c50:	46c0      	nop			@ (mov r8, r8)
 8000c52:	4770      	bx	lr
	...

08000c60 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000c60:	46c0      	nop			@ (mov r8, r8)
 8000c62:	4770      	bx	lr
	...

08000c70 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000c70:	46c0      	nop			@ (mov r8, r8)
 8000c72:	4770      	bx	lr
	...

08000c80 <usart4_usart5_irq_init>:

static inline void usart4_usart5_irq_init(void) {
#if defined(STM32_UART4_IS_USED) || defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_USART4_5_NUMBER, STM32_IRQ_USART4_5_PRIORITY);
#endif
}
 8000c80:	46c0      	nop			@ (mov r8, r8)
 8000c82:	4770      	bx	lr
	...

08000c90 <lpuart1_irq_init>:

static inline void lpuart1_irq_init(void) {
#if defined(STM32_LPUART1_IS_USED)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_IRQ_LPUART1_PRIORITY);
#endif
}
 8000c90:	46c0      	nop			@ (mov r8, r8)
 8000c92:	4770      	bx	lr
	...

08000ca0 <tim2_irq_init>:

static inline void tim2_irq_init(void) {
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
#endif
}
 8000ca0:	46c0      	nop			@ (mov r8, r8)
 8000ca2:	4770      	bx	lr
	...

08000cb0 <tim3_irq_init>:

static inline void tim3_irq_init(void) {
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
 8000cb0:	46c0      	nop			@ (mov r8, r8)
 8000cb2:	4770      	bx	lr
	...

08000cc0 <tim6_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim6_irq_init(void) {
 8000cc0:	b510      	push	{r4, lr}
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
 8000cc2:	2101      	movs	r1, #1
 8000cc4:	2011      	movs	r0, #17
 8000cc6:	f7ff ff13 	bl	8000af0 <nvicEnableVector>
#endif
}
 8000cca:	46c0      	nop			@ (mov r8, r8)
 8000ccc:	bd10      	pop	{r4, pc}
 8000cce:	46c0      	nop			@ (mov r8, r8)

08000cd0 <Vector84>:
/**
 * @brief   TIM6 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM6_HANDLER) {
 8000cd0:	b500      	push	{lr}
 8000cd2:	b083      	sub	sp, #12
 8000cd4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000cd6:	9301      	str	r3, [sp, #4]
 8000cd8:	4b0b      	ldr	r3, [pc, #44]	@ (8000d08 <Vector84+0x38>)
 8000cda:	0018      	movs	r0, r3
 8000cdc:	f001 fc80 	bl	80025e0 <__trace_isr_enter>
 8000ce0:	f001 fad6 	bl	8002290 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM6
  gpt_lld_serve_interrupt(&GPTD6);
 8000ce4:	4b09      	ldr	r3, [pc, #36]	@ (8000d0c <Vector84+0x3c>)
 8000ce6:	0018      	movs	r0, r3
 8000ce8:	f001 f882 	bl	8001df0 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM6
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000cec:	f001 fb00 	bl	80022f0 <__dbg_check_leave_isr>
 8000cf0:	4b05      	ldr	r3, [pc, #20]	@ (8000d08 <Vector84+0x38>)
 8000cf2:	0018      	movs	r0, r3
 8000cf4:	f001 fca4 	bl	8002640 <__trace_isr_leave>
 8000cf8:	9b01      	ldr	r3, [sp, #4]
 8000cfa:	0018      	movs	r0, r3
 8000cfc:	f003 ff38 	bl	8004b70 <__port_irq_epilogue>
}
 8000d00:	46c0      	nop			@ (mov r8, r8)
 8000d02:	b003      	add	sp, #12
 8000d04:	bd00      	pop	{pc}
 8000d06:	46c0      	nop			@ (mov r8, r8)
 8000d08:	08004ebc 	.word	0x08004ebc
 8000d0c:	20000674 	.word	0x20000674

08000d10 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 8000d10:	46c0      	nop			@ (mov r8, r8)
 8000d12:	4770      	bx	lr
	...

08000d20 <tim21_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim21_irq_init(void) {
 8000d20:	b510      	push	{r4, lr}
#if defined(STM32_TIM21_IS_USED)
  nvicEnableVector(STM32_TIM21_NUMBER, STM32_IRQ_TIM21_PRIORITY);
 8000d22:	2101      	movs	r1, #1
 8000d24:	2014      	movs	r0, #20
 8000d26:	f7ff fee3 	bl	8000af0 <nvicEnableVector>
#endif
}
 8000d2a:	46c0      	nop			@ (mov r8, r8)
 8000d2c:	bd10      	pop	{r4, pc}
 8000d2e:	46c0      	nop			@ (mov r8, r8)

08000d30 <Vector90>:
/**
 * @brief   TIM21 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM21_HANDLER) {
 8000d30:	b500      	push	{lr}
 8000d32:	b083      	sub	sp, #12
 8000d34:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000d36:	9301      	str	r3, [sp, #4]
 8000d38:	4b0a      	ldr	r3, [pc, #40]	@ (8000d64 <Vector90+0x34>)
 8000d3a:	0018      	movs	r0, r3
 8000d3c:	f001 fc50 	bl	80025e0 <__trace_isr_enter>
 8000d40:	f001 faa6 	bl	8002290 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD21);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM21
  st_lld_serve_interrupt();
 8000d44:	f000 ff64 	bl	8001c10 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000d48:	f001 fad2 	bl	80022f0 <__dbg_check_leave_isr>
 8000d4c:	4b05      	ldr	r3, [pc, #20]	@ (8000d64 <Vector90+0x34>)
 8000d4e:	0018      	movs	r0, r3
 8000d50:	f001 fc76 	bl	8002640 <__trace_isr_leave>
 8000d54:	9b01      	ldr	r3, [sp, #4]
 8000d56:	0018      	movs	r0, r3
 8000d58:	f003 ff0a 	bl	8004b70 <__port_irq_epilogue>
}
 8000d5c:	46c0      	nop			@ (mov r8, r8)
 8000d5e:	b003      	add	sp, #12
 8000d60:	bd00      	pop	{pc}
 8000d62:	46c0      	nop			@ (mov r8, r8)
 8000d64:	08004ec8 	.word	0x08004ec8
	...

08000d70 <tim22_irq_init>:

static inline void tim22_irq_init(void) {
#if defined(STM32_TIM22_IS_USED)
  nvicEnableVector(STM32_TIM22_NUMBER, STM32_IRQ_TIM22_PRIORITY);
#endif
}
 8000d70:	46c0      	nop			@ (mov r8, r8)
 8000d72:	4770      	bx	lr
	...

08000d80 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000d80:	b510      	push	{r4, lr}

  exti0_1_irq_init();
 8000d82:	f7ff ff55 	bl	8000c30 <exti0_1_irq_init>
  exti2_3_irq_init();
 8000d86:	f7ff ff5b 	bl	8000c40 <exti2_3_irq_init>
  exti4_15_irq_init();
 8000d8a:	f7ff ff61 	bl	8000c50 <exti4_15_irq_init>

  tim2_irq_init();
 8000d8e:	f7ff ff87 	bl	8000ca0 <tim2_irq_init>
  tim3_irq_init();
 8000d92:	f7ff ff8d 	bl	8000cb0 <tim3_irq_init>
  tim6_irq_init();
 8000d96:	f7ff ff93 	bl	8000cc0 <tim6_irq_init>
  tim7_irq_init();
 8000d9a:	f7ff ffb9 	bl	8000d10 <tim7_irq_init>
  tim21_irq_init();
 8000d9e:	f7ff ffbf 	bl	8000d20 <tim21_irq_init>
  tim22_irq_init();
 8000da2:	f7ff ffe5 	bl	8000d70 <tim22_irq_init>

  usart1_irq_init();
 8000da6:	f7ff ff5b 	bl	8000c60 <usart1_irq_init>
  usart2_irq_init();
 8000daa:	f7ff ff61 	bl	8000c70 <usart2_irq_init>
  usart4_usart5_irq_init();
 8000dae:	f7ff ff67 	bl	8000c80 <usart4_usart5_irq_init>
  lpuart1_irq_init();
 8000db2:	f7ff ff6d 	bl	8000c90 <lpuart1_irq_init>
}
 8000db6:	46c0      	nop			@ (mov r8, r8)
 8000db8:	bd10      	pop	{r4, pc}
 8000dba:	46c0      	nop			@ (mov r8, r8)
 8000dbc:	0000      	movs	r0, r0
	...

08000dc0 <hal_lld_backup_domain_init>:
 * @brief   Initializes the backup domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000dc0:	4b20      	ldr	r3, [pc, #128]	@ (8000e44 <hal_lld_backup_domain_init+0x84>)
 8000dc2:	681a      	ldr	r2, [r3, #0]
 8000dc4:	4b1f      	ldr	r3, [pc, #124]	@ (8000e44 <hal_lld_backup_domain_init+0x84>)
 8000dc6:	2180      	movs	r1, #128	@ 0x80
 8000dc8:	0049      	lsls	r1, r1, #1
 8000dca:	430a      	orrs	r2, r1
 8000dcc:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->CSR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8000dce:	4b1e      	ldr	r3, [pc, #120]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000dd0:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000dd2:	23c0      	movs	r3, #192	@ 0xc0
 8000dd4:	029b      	lsls	r3, r3, #10
 8000dd6:	401a      	ands	r2, r3
 8000dd8:	2380      	movs	r3, #128	@ 0x80
 8000dda:	025b      	lsls	r3, r3, #9
 8000ddc:	429a      	cmp	r2, r3
 8000dde:	d00c      	beq.n	8000dfa <hal_lld_backup_domain_init+0x3a>
    /* Backup domain reset.*/
    RCC->CSR |= RCC_CSR_RTCRST;
 8000de0:	4b19      	ldr	r3, [pc, #100]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000de2:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000de4:	4b18      	ldr	r3, [pc, #96]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000de6:	2180      	movs	r1, #128	@ 0x80
 8000de8:	0309      	lsls	r1, r1, #12
 8000dea:	430a      	orrs	r2, r1
 8000dec:	651a      	str	r2, [r3, #80]	@ 0x50
    RCC->CSR &= ~RCC_CSR_RTCRST;
 8000dee:	4b16      	ldr	r3, [pc, #88]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000df0:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000df2:	4b15      	ldr	r3, [pc, #84]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000df4:	4915      	ldr	r1, [pc, #84]	@ (8000e4c <hal_lld_backup_domain_init+0x8c>)
 8000df6:	400a      	ands	r2, r1
 8000df8:	651a      	str	r2, [r3, #80]	@ 0x50
  }

  /* If enabled then the LSE is started.*/
#if STM32_LSE_ENABLED
  RCC->CSR |= RCC_CSR_LSEON;
 8000dfa:	4b13      	ldr	r3, [pc, #76]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000dfc:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000dfe:	4b12      	ldr	r3, [pc, #72]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000e00:	2180      	movs	r1, #128	@ 0x80
 8000e02:	0049      	lsls	r1, r1, #1
 8000e04:	430a      	orrs	r2, r1
 8000e06:	651a      	str	r2, [r3, #80]	@ 0x50
  while ((RCC->CSR & RCC_CSR_LSERDY) == 0)
 8000e08:	46c0      	nop			@ (mov r8, r8)
 8000e0a:	4b0f      	ldr	r3, [pc, #60]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000e0c:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000e0e:	2380      	movs	r3, #128	@ 0x80
 8000e10:	009b      	lsls	r3, r3, #2
 8000e12:	4013      	ands	r3, r2
 8000e14:	d0f9      	beq.n	8000e0a <hal_lld_backup_domain_init+0x4a>
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->CSR & RCC_CSR_RTCEN) == 0) {
 8000e16:	4b0c      	ldr	r3, [pc, #48]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000e18:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000e1a:	2380      	movs	r3, #128	@ 0x80
 8000e1c:	02db      	lsls	r3, r3, #11
 8000e1e:	4013      	ands	r3, r2
 8000e20:	d10d      	bne.n	8000e3e <hal_lld_backup_domain_init+0x7e>
    /* Selects clock source.*/
    RCC->CSR |= STM32_RTCSEL;
 8000e22:	4b09      	ldr	r3, [pc, #36]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000e24:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000e26:	4b08      	ldr	r3, [pc, #32]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000e28:	2180      	movs	r1, #128	@ 0x80
 8000e2a:	0249      	lsls	r1, r1, #9
 8000e2c:	430a      	orrs	r2, r1
 8000e2e:	651a      	str	r2, [r3, #80]	@ 0x50

    /* RTC clock enabled.*/
    RCC->CSR |= RCC_CSR_RTCEN;
 8000e30:	4b05      	ldr	r3, [pc, #20]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000e32:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000e34:	4b04      	ldr	r3, [pc, #16]	@ (8000e48 <hal_lld_backup_domain_init+0x88>)
 8000e36:	2180      	movs	r1, #128	@ 0x80
 8000e38:	02c9      	lsls	r1, r1, #11
 8000e3a:	430a      	orrs	r2, r1
 8000e3c:	651a      	str	r2, [r3, #80]	@ 0x50
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 8000e3e:	46c0      	nop			@ (mov r8, r8)
 8000e40:	4770      	bx	lr
 8000e42:	46c0      	nop			@ (mov r8, r8)
 8000e44:	40007000 	.word	0x40007000
 8000e48:	40021000 	.word	0x40021000
 8000e4c:	fff7ffff 	.word	0xfff7ffff

08000e50 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8000e50:	b510      	push	{r4, lr}

  /* Reset of all peripherals except those on IOP.*/
  rccResetAHB(~RCC_AHBRSTR_MIFRST);
 8000e52:	4b22      	ldr	r3, [pc, #136]	@ (8000edc <hal_lld_init+0x8c>)
 8000e54:	6a1a      	ldr	r2, [r3, #32]
 8000e56:	4b21      	ldr	r3, [pc, #132]	@ (8000edc <hal_lld_init+0x8c>)
 8000e58:	4921      	ldr	r1, [pc, #132]	@ (8000ee0 <hal_lld_init+0x90>)
 8000e5a:	430a      	orrs	r2, r1
 8000e5c:	621a      	str	r2, [r3, #32]
 8000e5e:	4b1f      	ldr	r3, [pc, #124]	@ (8000edc <hal_lld_init+0x8c>)
 8000e60:	6a19      	ldr	r1, [r3, #32]
 8000e62:	4b1e      	ldr	r3, [pc, #120]	@ (8000edc <hal_lld_init+0x8c>)
 8000e64:	2280      	movs	r2, #128	@ 0x80
 8000e66:	0052      	lsls	r2, r2, #1
 8000e68:	400a      	ands	r2, r1
 8000e6a:	621a      	str	r2, [r3, #32]
 8000e6c:	4b1b      	ldr	r3, [pc, #108]	@ (8000edc <hal_lld_init+0x8c>)
 8000e6e:	6a1b      	ldr	r3, [r3, #32]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8000e70:	4b1a      	ldr	r3, [pc, #104]	@ (8000edc <hal_lld_init+0x8c>)
 8000e72:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8000e74:	4b19      	ldr	r3, [pc, #100]	@ (8000edc <hal_lld_init+0x8c>)
 8000e76:	491b      	ldr	r1, [pc, #108]	@ (8000ee4 <hal_lld_init+0x94>)
 8000e78:	430a      	orrs	r2, r1
 8000e7a:	629a      	str	r2, [r3, #40]	@ 0x28
 8000e7c:	4b17      	ldr	r3, [pc, #92]	@ (8000edc <hal_lld_init+0x8c>)
 8000e7e:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8000e80:	4b16      	ldr	r3, [pc, #88]	@ (8000edc <hal_lld_init+0x8c>)
 8000e82:	2280      	movs	r2, #128	@ 0x80
 8000e84:	0552      	lsls	r2, r2, #21
 8000e86:	400a      	ands	r2, r1
 8000e88:	629a      	str	r2, [r3, #40]	@ 0x28
 8000e8a:	4b14      	ldr	r3, [pc, #80]	@ (8000edc <hal_lld_init+0x8c>)
 8000e8c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  rccResetAPB2(~RCC_APB2RSTR_SYSCFGRST);
 8000e8e:	4b13      	ldr	r3, [pc, #76]	@ (8000edc <hal_lld_init+0x8c>)
 8000e90:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000e92:	4b12      	ldr	r3, [pc, #72]	@ (8000edc <hal_lld_init+0x8c>)
 8000e94:	2102      	movs	r1, #2
 8000e96:	4249      	negs	r1, r1
 8000e98:	430a      	orrs	r2, r1
 8000e9a:	625a      	str	r2, [r3, #36]	@ 0x24
 8000e9c:	4b0f      	ldr	r3, [pc, #60]	@ (8000edc <hal_lld_init+0x8c>)
 8000e9e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000ea0:	4b0e      	ldr	r3, [pc, #56]	@ (8000edc <hal_lld_init+0x8c>)
 8000ea2:	2101      	movs	r1, #1
 8000ea4:	400a      	ands	r2, r1
 8000ea6:	625a      	str	r2, [r3, #36]	@ 0x24
 8000ea8:	4b0c      	ldr	r3, [pc, #48]	@ (8000edc <hal_lld_init+0x8c>)
 8000eaa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8000eac:	4b0b      	ldr	r3, [pc, #44]	@ (8000edc <hal_lld_init+0x8c>)
 8000eae:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8000eb0:	4b0a      	ldr	r3, [pc, #40]	@ (8000edc <hal_lld_init+0x8c>)
 8000eb2:	2180      	movs	r1, #128	@ 0x80
 8000eb4:	0549      	lsls	r1, r1, #21
 8000eb6:	430a      	orrs	r2, r1
 8000eb8:	639a      	str	r2, [r3, #56]	@ 0x38
 8000eba:	4b08      	ldr	r3, [pc, #32]	@ (8000edc <hal_lld_init+0x8c>)
 8000ebc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8000ebe:	4b07      	ldr	r3, [pc, #28]	@ (8000edc <hal_lld_init+0x8c>)
 8000ec0:	2180      	movs	r1, #128	@ 0x80
 8000ec2:	0549      	lsls	r1, r1, #21
 8000ec4:	430a      	orrs	r2, r1
 8000ec6:	649a      	str	r2, [r3, #72]	@ 0x48
 8000ec8:	4b04      	ldr	r3, [pc, #16]	@ (8000edc <hal_lld_init+0x8c>)
 8000eca:	6c9b      	ldr	r3, [r3, #72]	@ 0x48

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8000ecc:	f7ff ff78 	bl	8000dc0 <hal_lld_backup_domain_init>

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8000ed0:	f000 fc5e 	bl	8001790 <dmaInit>
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 8000ed4:	f7ff ff54 	bl	8000d80 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8000ed8:	46c0      	nop			@ (mov r8, r8)
 8000eda:	bd10      	pop	{r4, pc}
 8000edc:	40021000 	.word	0x40021000
 8000ee0:	fffffeff 	.word	0xfffffeff
 8000ee4:	efffffff 	.word	0xefffffff
	...

08000ef0 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000ef0:	4b6f      	ldr	r3, [pc, #444]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000ef2:	2280      	movs	r2, #128	@ 0x80
 8000ef4:	0552      	lsls	r2, r2, #21
 8000ef6:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Core voltage setup.*/
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 8000ef8:	46c0      	nop			@ (mov r8, r8)
 8000efa:	4b6e      	ldr	r3, [pc, #440]	@ (80010b4 <stm32_clock_init+0x1c4>)
 8000efc:	685b      	ldr	r3, [r3, #4]
 8000efe:	2210      	movs	r2, #16
 8000f00:	4013      	ands	r3, r2
 8000f02:	d1fa      	bne.n	8000efa <stm32_clock_init+0xa>
    ;                           /* Waits until regulator is stable.         */
  PWR->CR = STM32_VOS;
 8000f04:	4b6b      	ldr	r3, [pc, #428]	@ (80010b4 <stm32_clock_init+0x1c4>)
 8000f06:	2280      	movs	r2, #128	@ 0x80
 8000f08:	0112      	lsls	r2, r2, #4
 8000f0a:	601a      	str	r2, [r3, #0]
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 8000f0c:	46c0      	nop			@ (mov r8, r8)
 8000f0e:	4b69      	ldr	r3, [pc, #420]	@ (80010b4 <stm32_clock_init+0x1c4>)
 8000f10:	685b      	ldr	r3, [r3, #4]
 8000f12:	2210      	movs	r2, #16
 8000f14:	4013      	ands	r3, r2
 8000f16:	d1fa      	bne.n	8000f0e <stm32_clock_init+0x1e>
    ;                           /* Waits until regulator is stable.         */

  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fallback clock when PLL the fails.
     Trim fields are not altered from reset values.*/
  RCC->CFGR  = 0;
 8000f18:	4b65      	ldr	r3, [pc, #404]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f1a:	2200      	movs	r2, #0
 8000f1c:	60da      	str	r2, [r3, #12]
  RCC->ICSCR = (RCC->ICSCR & ~STM32_MSIRANGE_MASK) | STM32_MSIRANGE;
 8000f1e:	4b64      	ldr	r3, [pc, #400]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f20:	685b      	ldr	r3, [r3, #4]
 8000f22:	4a65      	ldr	r2, [pc, #404]	@ (80010b8 <stm32_clock_init+0x1c8>)
 8000f24:	401a      	ands	r2, r3
 8000f26:	4b62      	ldr	r3, [pc, #392]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f28:	21a0      	movs	r1, #160	@ 0xa0
 8000f2a:	0209      	lsls	r1, r1, #8
 8000f2c:	430a      	orrs	r2, r1
 8000f2e:	605a      	str	r2, [r3, #4]
  RCC->CR    = RCC_CR_MSION;
 8000f30:	4b5f      	ldr	r3, [pc, #380]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f32:	2280      	movs	r2, #128	@ 0x80
 8000f34:	0052      	lsls	r2, r2, #1
 8000f36:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8000f38:	46c0      	nop			@ (mov r8, r8)
 8000f3a:	4b5d      	ldr	r3, [pc, #372]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f3c:	681a      	ldr	r2, [r3, #0]
 8000f3e:	2380      	movs	r3, #128	@ 0x80
 8000f40:	009b      	lsls	r3, r3, #2
 8000f42:	4013      	ands	r3, r2
 8000f44:	d0f9      	beq.n	8000f3a <stm32_clock_init+0x4a>
    ;                           /* Waits until MSI is stable.               */

#if STM32_HSI16_ENABLED
  /* HSI activation.*/
  RCC->CR |= RCC_CR_HSION;
 8000f46:	4b5a      	ldr	r3, [pc, #360]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f48:	681a      	ldr	r2, [r3, #0]
 8000f4a:	4b59      	ldr	r3, [pc, #356]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f4c:	2101      	movs	r1, #1
 8000f4e:	430a      	orrs	r2, r1
 8000f50:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0)
 8000f52:	46c0      	nop			@ (mov r8, r8)
 8000f54:	4b56      	ldr	r3, [pc, #344]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f56:	681b      	ldr	r3, [r3, #0]
 8000f58:	2204      	movs	r2, #4
 8000f5a:	4013      	ands	r3, r2
 8000f5c:	d0fa      	beq.n	8000f54 <stm32_clock_init+0x64>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_LSE_ENABLED
  /* LSE activation, have to unlock the register.*/
  if ((RCC->CSR & RCC_CSR_LSEON) == 0) {
 8000f5e:	4b54      	ldr	r3, [pc, #336]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f60:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000f62:	2380      	movs	r3, #128	@ 0x80
 8000f64:	005b      	lsls	r3, r3, #1
 8000f66:	4013      	ands	r3, r2
 8000f68:	d11a      	bne.n	8000fa0 <stm32_clock_init+0xb0>
    PWR->CR |= PWR_CR_DBP;
 8000f6a:	4b52      	ldr	r3, [pc, #328]	@ (80010b4 <stm32_clock_init+0x1c4>)
 8000f6c:	681a      	ldr	r2, [r3, #0]
 8000f6e:	4b51      	ldr	r3, [pc, #324]	@ (80010b4 <stm32_clock_init+0x1c4>)
 8000f70:	2180      	movs	r1, #128	@ 0x80
 8000f72:	0049      	lsls	r1, r1, #1
 8000f74:	430a      	orrs	r2, r1
 8000f76:	601a      	str	r2, [r3, #0]
#if defined(STM32_LSE_BYPASS)
    /* LSE Bypass.*/
    RCC->CSR |= STM32_LSEDRV | RCC_CSR_LSEBYP;
#else
    /* No LSE Bypass.*/
    RCC->CSR |= STM32_LSEDRV;
 8000f78:	4b4d      	ldr	r3, [pc, #308]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f7a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000f7c:	4b4c      	ldr	r3, [pc, #304]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f7e:	21c0      	movs	r1, #192	@ 0xc0
 8000f80:	0149      	lsls	r1, r1, #5
 8000f82:	430a      	orrs	r2, r1
 8000f84:	651a      	str	r2, [r3, #80]	@ 0x50
#endif
    RCC->CSR |= RCC_CSR_LSEON;
 8000f86:	4b4a      	ldr	r3, [pc, #296]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f88:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000f8a:	4b49      	ldr	r3, [pc, #292]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000f8c:	2180      	movs	r1, #128	@ 0x80
 8000f8e:	0049      	lsls	r1, r1, #1
 8000f90:	430a      	orrs	r2, r1
 8000f92:	651a      	str	r2, [r3, #80]	@ 0x50
    PWR->CR &= ~PWR_CR_DBP;
 8000f94:	4b47      	ldr	r3, [pc, #284]	@ (80010b4 <stm32_clock_init+0x1c4>)
 8000f96:	681a      	ldr	r2, [r3, #0]
 8000f98:	4b46      	ldr	r3, [pc, #280]	@ (80010b4 <stm32_clock_init+0x1c4>)
 8000f9a:	4948      	ldr	r1, [pc, #288]	@ (80010bc <stm32_clock_init+0x1cc>)
 8000f9c:	400a      	ands	r2, r1
 8000f9e:	601a      	str	r2, [r3, #0]
  }
  while ((RCC->CSR & RCC_CSR_LSERDY) == 0)
 8000fa0:	46c0      	nop			@ (mov r8, r8)
 8000fa2:	4b43      	ldr	r3, [pc, #268]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fa4:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8000fa6:	2380      	movs	r3, #128	@ 0x80
 8000fa8:	009b      	lsls	r3, r3, #2
 8000faa:	4013      	ands	r3, r2
 8000fac:	d0f9      	beq.n	8000fa2 <stm32_clock_init+0xb2>
    ;                           /* Waits until LSE is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLDIV | STM32_PLLMUL | STM32_PLLSRC;
 8000fae:	4b40      	ldr	r3, [pc, #256]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fb0:	68da      	ldr	r2, [r3, #12]
 8000fb2:	4b3f      	ldr	r3, [pc, #252]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fb4:	2188      	movs	r1, #136	@ 0x88
 8000fb6:	03c9      	lsls	r1, r1, #15
 8000fb8:	430a      	orrs	r2, r1
 8000fba:	60da      	str	r2, [r3, #12]
  RCC->CR   |= RCC_CR_PLLON;
 8000fbc:	4b3c      	ldr	r3, [pc, #240]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fbe:	681a      	ldr	r2, [r3, #0]
 8000fc0:	4b3b      	ldr	r3, [pc, #236]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fc2:	2180      	movs	r1, #128	@ 0x80
 8000fc4:	0449      	lsls	r1, r1, #17
 8000fc6:	430a      	orrs	r2, r1
 8000fc8:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000fca:	46c0      	nop			@ (mov r8, r8)
 8000fcc:	4b38      	ldr	r3, [pc, #224]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fce:	681a      	ldr	r2, [r3, #0]
 8000fd0:	2380      	movs	r3, #128	@ 0x80
 8000fd2:	049b      	lsls	r3, r3, #18
 8000fd4:	4013      	ands	r3, r2
 8000fd6:	d0f9      	beq.n	8000fcc <stm32_clock_init+0xdc>
    ;                           /* Waits until PLL is stable.               */
#endif

#if STM32_ACTIVATE_HSI48
  /* Enabling SYSCFG clock. */
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8000fd8:	4b35      	ldr	r3, [pc, #212]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fda:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8000fdc:	4b34      	ldr	r3, [pc, #208]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fde:	2101      	movs	r1, #1
 8000fe0:	430a      	orrs	r2, r1
 8000fe2:	635a      	str	r2, [r3, #52]	@ 0x34
 8000fe4:	4b32      	ldr	r3, [pc, #200]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fe6:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8000fe8:	4b31      	ldr	r3, [pc, #196]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000fea:	2101      	movs	r1, #1
 8000fec:	430a      	orrs	r2, r1
 8000fee:	645a      	str	r2, [r3, #68]	@ 0x44
 8000ff0:	4b2f      	ldr	r3, [pc, #188]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8000ff2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  /* Configuring SYSCFG to enable VREFINT and HSI48 VREFINT buffer. */
  SYSCFG->CFGR3 = STM32_VREFINT_EN | SYSCFG_CFGR3_ENREF_HSI48;
 8000ff4:	4b32      	ldr	r3, [pc, #200]	@ (80010c0 <stm32_clock_init+0x1d0>)
 8000ff6:	4a33      	ldr	r2, [pc, #204]	@ (80010c4 <stm32_clock_init+0x1d4>)
 8000ff8:	621a      	str	r2, [r3, #32]

  while (!(SYSCFG->CFGR3 & SYSCFG_CFGR3_VREFINT_RDYF))
 8000ffa:	46c0      	nop			@ (mov r8, r8)
 8000ffc:	4b30      	ldr	r3, [pc, #192]	@ (80010c0 <stm32_clock_init+0x1d0>)
 8000ffe:	6a1a      	ldr	r2, [r3, #32]
 8001000:	2380      	movs	r3, #128	@ 0x80
 8001002:	05db      	lsls	r3, r3, #23
 8001004:	4013      	ands	r3, r2
 8001006:	d0f9      	beq.n	8000ffc <stm32_clock_init+0x10c>
    ;                             /* Waits until VREFINT is stable.         */
  /* Disabling SYSCFG clock. */
  rccDisableAPB2(RCC_APB2ENR_SYSCFGEN);
 8001008:	4b29      	ldr	r3, [pc, #164]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800100a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800100c:	4b28      	ldr	r3, [pc, #160]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800100e:	2101      	movs	r1, #1
 8001010:	438a      	bics	r2, r1
 8001012:	635a      	str	r2, [r3, #52]	@ 0x34
 8001014:	4b26      	ldr	r3, [pc, #152]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001016:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8001018:	4b25      	ldr	r3, [pc, #148]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800101a:	2101      	movs	r1, #1
 800101c:	438a      	bics	r2, r1
 800101e:	645a      	str	r2, [r3, #68]	@ 0x44
 8001020:	4b23      	ldr	r3, [pc, #140]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001022:	6c5b      	ldr	r3, [r3, #68]	@ 0x44

  /* Enabling HSI48. */
  RCC->CRRCR |= RCC_CRRCR_HSI48ON;
 8001024:	4b22      	ldr	r3, [pc, #136]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001026:	689a      	ldr	r2, [r3, #8]
 8001028:	4b21      	ldr	r3, [pc, #132]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800102a:	2101      	movs	r1, #1
 800102c:	430a      	orrs	r2, r1
 800102e:	609a      	str	r2, [r3, #8]
  while (!(RCC->CRRCR & RCC_CRRCR_HSI48RDY))
 8001030:	46c0      	nop			@ (mov r8, r8)
 8001032:	4b1f      	ldr	r3, [pc, #124]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001034:	689b      	ldr	r3, [r3, #8]
 8001036:	2202      	movs	r2, #2
 8001038:	4013      	ands	r3, r2
 800103a:	d0fa      	beq.n	8001032 <stm32_clock_init+0x142>
    ;                             /* Waits until HSI48 is stable.           */
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
 800103c:	4a1c      	ldr	r2, [pc, #112]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800103e:	4b1c      	ldr	r3, [pc, #112]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001040:	6812      	ldr	r2, [r2, #0]
 8001042:	601a      	str	r2, [r3, #0]
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
 8001044:	4a1a      	ldr	r2, [pc, #104]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001046:	4b1a      	ldr	r3, [pc, #104]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001048:	68d2      	ldr	r2, [r2, #12]
 800104a:	60da      	str	r2, [r3, #12]
               STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;
 800104c:	4b18      	ldr	r3, [pc, #96]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800104e:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8001050:	4b17      	ldr	r3, [pc, #92]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001052:	2180      	movs	r1, #128	@ 0x80
 8001054:	0249      	lsls	r1, r1, #9
 8001056:	430a      	orrs	r2, r1
 8001058:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS)
  FLASH->ACR = STM32_FLASHBITS;
 800105a:	4b1b      	ldr	r3, [pc, #108]	@ (80010c8 <stm32_clock_init+0x1d8>)
 800105c:	2243      	movs	r2, #67	@ 0x43
 800105e:	601a      	str	r2, [r3, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8001060:	46c0      	nop			@ (mov r8, r8)
 8001062:	4b19      	ldr	r3, [pc, #100]	@ (80010c8 <stm32_clock_init+0x1d8>)
 8001064:	681b      	ldr	r3, [r3, #0]
 8001066:	2201      	movs	r2, #1
 8001068:	4013      	ands	r3, r2
 800106a:	2b01      	cmp	r3, #1
 800106c:	d1f9      	bne.n	8001062 <stm32_clock_init+0x172>
  }
#endif

  /* Switching to the configured clock source if it is different from MSI.  */
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800106e:	4b10      	ldr	r3, [pc, #64]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001070:	68da      	ldr	r2, [r3, #12]
 8001072:	4b0f      	ldr	r3, [pc, #60]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001074:	2103      	movs	r1, #3
 8001076:	430a      	orrs	r2, r1
 8001078:	60da      	str	r2, [r3, #12]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800107a:	46c0      	nop			@ (mov r8, r8)
 800107c:	4b0c      	ldr	r3, [pc, #48]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800107e:	68db      	ldr	r3, [r3, #12]
 8001080:	220c      	movs	r2, #12
 8001082:	4013      	ands	r3, r2
 8001084:	2b0c      	cmp	r3, #12
 8001086:	d1f9      	bne.n	800107c <stm32_clock_init+0x18c>
    ;
#endif

  /* Peripherals clock sources setup.*/
  RCC->CCIPR = STM32_HSI48SEL   | STM32_LPTIM1SEL | STM32_I2C1SEL   |
 8001088:	4b09      	ldr	r3, [pc, #36]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800108a:	2280      	movs	r2, #128	@ 0x80
 800108c:	04d2      	lsls	r2, r2, #19
 800108e:	64da      	str	r2, [r3, #76]	@ 0x4c
               STM32_LPUART1SEL | STM32_USART2SEL | STM32_USART1SEL;

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8001090:	4b07      	ldr	r3, [pc, #28]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001092:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8001094:	4b06      	ldr	r3, [pc, #24]	@ (80010b0 <stm32_clock_init+0x1c0>)
 8001096:	2101      	movs	r1, #1
 8001098:	430a      	orrs	r2, r1
 800109a:	635a      	str	r2, [r3, #52]	@ 0x34
 800109c:	4b04      	ldr	r3, [pc, #16]	@ (80010b0 <stm32_clock_init+0x1c0>)
 800109e:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80010a0:	4b03      	ldr	r3, [pc, #12]	@ (80010b0 <stm32_clock_init+0x1c0>)
 80010a2:	2101      	movs	r1, #1
 80010a4:	430a      	orrs	r2, r1
 80010a6:	645a      	str	r2, [r3, #68]	@ 0x44
 80010a8:	4b01      	ldr	r3, [pc, #4]	@ (80010b0 <stm32_clock_init+0x1c0>)
 80010aa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
#endif /* STM32_NO_INIT */
}
 80010ac:	46c0      	nop			@ (mov r8, r8)
 80010ae:	4770      	bx	lr
 80010b0:	40021000 	.word	0x40021000
 80010b4:	40007000 	.word	0x40007000
 80010b8:	ffff1fff 	.word	0xffff1fff
 80010bc:	fffffeff 	.word	0xfffffeff
 80010c0:	40010000 	.word	0x40010000
 80010c4:	00002001 	.word	0x00002001
 80010c8:	40022000 	.word	0x40022000
 80010cc:	00000000 	.word	0x00000000

080010d0 <port_lock.lto_priv.4>:
  __ASM volatile ("cpsid i" : : : "memory");
 80010d0:	b672      	cpsid	i
}
 80010d2:	46c0      	nop			@ (mov r8, r8)
}
 80010d4:	46c0      	nop			@ (mov r8, r8)
 80010d6:	4770      	bx	lr
	...

080010e0 <port_unlock.lto_priv.4>:
  __ASM volatile ("cpsie i" : : : "memory");
 80010e0:	b662      	cpsie	i
}
 80010e2:	46c0      	nop			@ (mov r8, r8)
}
 80010e4:	46c0      	nop			@ (mov r8, r8)
 80010e6:	4770      	bx	lr
	...

080010f0 <port_lock_from_isr.lto_priv.0>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80010f0:	b510      	push	{r4, lr}

  port_lock();
 80010f2:	f7ff ffed 	bl	80010d0 <port_lock.lto_priv.4>
}
 80010f6:	46c0      	nop			@ (mov r8, r8)
 80010f8:	bd10      	pop	{r4, pc}
 80010fa:	46c0      	nop			@ (mov r8, r8)
 80010fc:	0000      	movs	r0, r0
	...

08001100 <port_unlock_from_isr.lto_priv.0>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001100:	b510      	push	{r4, lr}

  port_unlock();
 8001102:	f7ff ffed 	bl	80010e0 <port_unlock.lto_priv.4>
}
 8001106:	46c0      	nop			@ (mov r8, r8)
 8001108:	bd10      	pop	{r4, pc}
 800110a:	46c0      	nop			@ (mov r8, r8)
 800110c:	0000      	movs	r0, r0
	...

08001110 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001110:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8001112:	f7ff ffed 	bl	80010f0 <port_lock_from_isr.lto_priv.0>
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 8001116:	f001 f86b 	bl	80021f0 <__dbg_check_lock_from_isr>
}
 800111a:	46c0      	nop			@ (mov r8, r8)
 800111c:	bd10      	pop	{r4, pc}
 800111e:	46c0      	nop			@ (mov r8, r8)

08001120 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001120:	b510      	push	{r4, lr}

  __dbg_check_unlock_from_isr();
 8001122:	f001 f88d 	bl	8002240 <__dbg_check_unlock_from_isr>
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001126:	f7ff ffeb 	bl	8001100 <port_unlock_from_isr.lto_priv.0>
}
 800112a:	46c0      	nop			@ (mov r8, r8)
 800112c:	bd10      	pop	{r4, pc}
 800112e:	46c0      	nop			@ (mov r8, r8)

08001130 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 8001130:	b510      	push	{r4, lr}
  chSysLockFromISR();
 8001132:	f7ff ffed 	bl	8001110 <chSysLockFromISR.lto_priv.0>
}
 8001136:	46c0      	nop			@ (mov r8, r8)
 8001138:	bd10      	pop	{r4, pc}
 800113a:	46c0      	nop			@ (mov r8, r8)
 800113c:	0000      	movs	r0, r0
	...

08001140 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 8001140:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 8001142:	f7ff ffed 	bl	8001120 <chSysUnlockFromISR.lto_priv.0>
}
 8001146:	46c0      	nop			@ (mov r8, r8)
 8001148:	bd10      	pop	{r4, pc}
 800114a:	46c0      	nop			@ (mov r8, r8)
 800114c:	0000      	movs	r0, r0
	...

08001150 <osalThreadResumeI.lto_priv.1>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8001150:	b500      	push	{lr}
 8001152:	b083      	sub	sp, #12
 8001154:	9001      	str	r0, [sp, #4]
 8001156:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8001158:	9a00      	ldr	r2, [sp, #0]
 800115a:	9b01      	ldr	r3, [sp, #4]
 800115c:	0011      	movs	r1, r2
 800115e:	0018      	movs	r0, r3
 8001160:	f002 fe7e 	bl	8003e60 <chThdResumeI>
}
 8001164:	46c0      	nop			@ (mov r8, r8)
 8001166:	b003      	add	sp, #12
 8001168:	bd00      	pop	{pc}
 800116a:	46c0      	nop			@ (mov r8, r8)
 800116c:	0000      	movs	r0, r0
	...

08001170 <adc_lld_vreg_on>:
/**
 * @brief   ADC voltage regulator enable.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
NOINLINE static void adc_lld_vreg_on(ADC_TypeDef *adc) {
 8001170:	b500      	push	{lr}
 8001172:	b085      	sub	sp, #20
 8001174:	9001      	str	r0, [sp, #4]

  osalDbgAssert(adc->CR == 0, "invalid register state");
 8001176:	9b01      	ldr	r3, [sp, #4]
 8001178:	689b      	ldr	r3, [r3, #8]
 800117a:	1e5a      	subs	r2, r3, #1
 800117c:	4193      	sbcs	r3, r2
 800117e:	b2db      	uxtb	r3, r3
 8001180:	2b00      	cmp	r3, #0
 8001182:	d003      	beq.n	800118c <adc_lld_vreg_on+0x1c>
 8001184:	4b0a      	ldr	r3, [pc, #40]	@ (80011b0 <adc_lld_vreg_on+0x40>)
 8001186:	0018      	movs	r0, r3
 8001188:	f000 ff72 	bl	8002070 <chSysHalt>

#if defined(ADC_CR_ADVREGEN)
  adc->CR = ADC_CR_ADVREGEN;
 800118c:	9b01      	ldr	r3, [sp, #4]
 800118e:	2280      	movs	r2, #128	@ 0x80
 8001190:	0552      	lsls	r2, r2, #21
 8001192:	609a      	str	r2, [r3, #8]
  volatile uint32_t loop = (STM32_HCLK >> 20) << 4;
 8001194:	23f0      	movs	r3, #240	@ 0xf0
 8001196:	005b      	lsls	r3, r3, #1
 8001198:	9303      	str	r3, [sp, #12]
  do {
    loop--;
 800119a:	9b03      	ldr	r3, [sp, #12]
 800119c:	3b01      	subs	r3, #1
 800119e:	9303      	str	r3, [sp, #12]
  } while (loop > 0);
 80011a0:	9b03      	ldr	r3, [sp, #12]
 80011a2:	2b00      	cmp	r3, #0
 80011a4:	d1f9      	bne.n	800119a <adc_lld_vreg_on+0x2a>
#else
#endif
}
 80011a6:	46c0      	nop			@ (mov r8, r8)
 80011a8:	46c0      	nop			@ (mov r8, r8)
 80011aa:	b005      	add	sp, #20
 80011ac:	bd00      	pop	{pc}
 80011ae:	46c0      	nop			@ (mov r8, r8)
 80011b0:	08004ed4 	.word	0x08004ed4
	...

080011c0 <adc_lld_calibrate>:
/**
 * @brief   Calibrates an ADC unit.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_calibrate(ADC_TypeDef *adc) {
 80011c0:	b082      	sub	sp, #8
 80011c2:	9001      	str	r0, [sp, #4]

  adc->CR |= ADC_CR_ADCAL;
 80011c4:	9b01      	ldr	r3, [sp, #4]
 80011c6:	689b      	ldr	r3, [r3, #8]
 80011c8:	2280      	movs	r2, #128	@ 0x80
 80011ca:	0612      	lsls	r2, r2, #24
 80011cc:	431a      	orrs	r2, r3
 80011ce:	9b01      	ldr	r3, [sp, #4]
 80011d0:	609a      	str	r2, [r3, #8]
  while (adc->CR & ADC_CR_ADCAL) {
 80011d2:	46c0      	nop			@ (mov r8, r8)
 80011d4:	9b01      	ldr	r3, [sp, #4]
 80011d6:	689b      	ldr	r3, [r3, #8]
 80011d8:	2b00      	cmp	r3, #0
 80011da:	dbfb      	blt.n	80011d4 <adc_lld_calibrate+0x14>
    /* Waiting for calibration end.*/
  }
}
 80011dc:	46c0      	nop			@ (mov r8, r8)
 80011de:	46c0      	nop			@ (mov r8, r8)
 80011e0:	b002      	add	sp, #8
 80011e2:	4770      	bx	lr
	...

080011f0 <adc_lld_stop_adc>:
/**
 * @brief   Stops an ongoing conversion, if any.
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {
 80011f0:	b082      	sub	sp, #8
 80011f2:	9001      	str	r0, [sp, #4]

  if (adc->CR & ADC_CR_ADSTART) {
 80011f4:	9b01      	ldr	r3, [sp, #4]
 80011f6:	689b      	ldr	r3, [r3, #8]
 80011f8:	2204      	movs	r2, #4
 80011fa:	4013      	ands	r3, r2
 80011fc:	d00e      	beq.n	800121c <adc_lld_stop_adc+0x2c>
    adc->CR |= ADC_CR_ADSTP;
 80011fe:	9b01      	ldr	r3, [sp, #4]
 8001200:	689b      	ldr	r3, [r3, #8]
 8001202:	2210      	movs	r2, #16
 8001204:	431a      	orrs	r2, r3
 8001206:	9b01      	ldr	r3, [sp, #4]
 8001208:	609a      	str	r2, [r3, #8]
    while (adc->CR & ADC_CR_ADSTP)
 800120a:	46c0      	nop			@ (mov r8, r8)
 800120c:	9b01      	ldr	r3, [sp, #4]
 800120e:	689b      	ldr	r3, [r3, #8]
 8001210:	2210      	movs	r2, #16
 8001212:	4013      	ands	r3, r2
 8001214:	d1fa      	bne.n	800120c <adc_lld_stop_adc+0x1c>
      ;
    adc->IER = 0;
 8001216:	9b01      	ldr	r3, [sp, #4]
 8001218:	2200      	movs	r2, #0
 800121a:	605a      	str	r2, [r3, #4]
  }

  /* Disabling the ADC.*/
  adc->CR |= ADC_CR_ADDIS;
 800121c:	9b01      	ldr	r3, [sp, #4]
 800121e:	689b      	ldr	r3, [r3, #8]
 8001220:	2202      	movs	r2, #2
 8001222:	431a      	orrs	r2, r3
 8001224:	9b01      	ldr	r3, [sp, #4]
 8001226:	609a      	str	r2, [r3, #8]
  while ((adc->CR & ADC_CR_ADEN) != 0U) {
 8001228:	46c0      	nop			@ (mov r8, r8)
 800122a:	9b01      	ldr	r3, [sp, #4]
 800122c:	689b      	ldr	r3, [r3, #8]
 800122e:	2201      	movs	r2, #1
 8001230:	4013      	ands	r3, r2
 8001232:	d1fa      	bne.n	800122a <adc_lld_stop_adc+0x3a>
    /* Waiting for ADC to be disabled.*/
  }
}
 8001234:	46c0      	nop			@ (mov r8, r8)
 8001236:	46c0      	nop			@ (mov r8, r8)
 8001238:	b002      	add	sp, #8
 800123a:	4770      	bx	lr
 800123c:	0000      	movs	r0, r0
	...

08001240 <adc_lld_serve_rx_interrupt>:
 * @brief   ADC DMA service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001240:	b500      	push	{lr}
 8001242:	b083      	sub	sp, #12
 8001244:	9001      	str	r0, [sp, #4]
 8001246:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001248:	9b00      	ldr	r3, [sp, #0]
 800124a:	2208      	movs	r2, #8
 800124c:	4013      	ands	r3, r2
 800124e:	d030      	beq.n	80012b2 <adc_lld_serve_rx_interrupt+0x72>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8001250:	9b01      	ldr	r3, [sp, #4]
 8001252:	0018      	movs	r0, r3
 8001254:	f000 f9dc 	bl	8001610 <adc_lld_stop_conversion>
 8001258:	9b01      	ldr	r3, [sp, #4]
 800125a:	691b      	ldr	r3, [r3, #16]
 800125c:	689b      	ldr	r3, [r3, #8]
 800125e:	2b00      	cmp	r3, #0
 8001260:	d014      	beq.n	800128c <adc_lld_serve_rx_interrupt+0x4c>
 8001262:	9b01      	ldr	r3, [sp, #4]
 8001264:	2205      	movs	r2, #5
 8001266:	701a      	strb	r2, [r3, #0]
 8001268:	9b01      	ldr	r3, [sp, #4]
 800126a:	691b      	ldr	r3, [r3, #16]
 800126c:	689b      	ldr	r3, [r3, #8]
 800126e:	9a01      	ldr	r2, [sp, #4]
 8001270:	2101      	movs	r1, #1
 8001272:	0010      	movs	r0, r2
 8001274:	4798      	blx	r3
 8001276:	9b01      	ldr	r3, [sp, #4]
 8001278:	781b      	ldrb	r3, [r3, #0]
 800127a:	2b05      	cmp	r3, #5
 800127c:	d10c      	bne.n	8001298 <adc_lld_serve_rx_interrupt+0x58>
 800127e:	9b01      	ldr	r3, [sp, #4]
 8001280:	2202      	movs	r2, #2
 8001282:	701a      	strb	r2, [r3, #0]
 8001284:	9b01      	ldr	r3, [sp, #4]
 8001286:	2200      	movs	r2, #0
 8001288:	611a      	str	r2, [r3, #16]
 800128a:	e005      	b.n	8001298 <adc_lld_serve_rx_interrupt+0x58>
 800128c:	9b01      	ldr	r3, [sp, #4]
 800128e:	2202      	movs	r2, #2
 8001290:	701a      	strb	r2, [r3, #0]
 8001292:	9b01      	ldr	r3, [sp, #4]
 8001294:	2200      	movs	r2, #0
 8001296:	611a      	str	r2, [r3, #16]
 8001298:	f7ff ff4a 	bl	8001130 <osalSysLockFromISR.lto_priv.0>
 800129c:	9b01      	ldr	r3, [sp, #4]
 800129e:	3314      	adds	r3, #20
 80012a0:	2201      	movs	r2, #1
 80012a2:	4252      	negs	r2, r2
 80012a4:	0011      	movs	r1, r2
 80012a6:	0018      	movs	r0, r3
 80012a8:	f7ff ff52 	bl	8001150 <osalThreadResumeI.lto_priv.1>
 80012ac:	f7ff ff48 	bl	8001140 <osalSysUnlockFromISR.lto_priv.0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 80012b0:	e05f      	b.n	8001372 <adc_lld_serve_rx_interrupt+0x132>
    if (adcp->grpp != NULL) {
 80012b2:	9b01      	ldr	r3, [sp, #4]
 80012b4:	691b      	ldr	r3, [r3, #16]
 80012b6:	2b00      	cmp	r3, #0
 80012b8:	d05b      	beq.n	8001372 <adc_lld_serve_rx_interrupt+0x132>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80012ba:	9b00      	ldr	r3, [sp, #0]
 80012bc:	2202      	movs	r2, #2
 80012be:	4013      	ands	r3, r2
 80012c0:	d048      	beq.n	8001354 <adc_lld_serve_rx_interrupt+0x114>
        _adc_isr_full_code(adcp);
 80012c2:	9b01      	ldr	r3, [sp, #4]
 80012c4:	691b      	ldr	r3, [r3, #16]
 80012c6:	781b      	ldrb	r3, [r3, #0]
 80012c8:	2b00      	cmp	r3, #0
 80012ca:	d015      	beq.n	80012f8 <adc_lld_serve_rx_interrupt+0xb8>
 80012cc:	9b01      	ldr	r3, [sp, #4]
 80012ce:	691b      	ldr	r3, [r3, #16]
 80012d0:	685b      	ldr	r3, [r3, #4]
 80012d2:	2b00      	cmp	r3, #0
 80012d4:	d04d      	beq.n	8001372 <adc_lld_serve_rx_interrupt+0x132>
 80012d6:	9b01      	ldr	r3, [sp, #4]
 80012d8:	2204      	movs	r2, #4
 80012da:	701a      	strb	r2, [r3, #0]
 80012dc:	9b01      	ldr	r3, [sp, #4]
 80012de:	691b      	ldr	r3, [r3, #16]
 80012e0:	685b      	ldr	r3, [r3, #4]
 80012e2:	9a01      	ldr	r2, [sp, #4]
 80012e4:	0010      	movs	r0, r2
 80012e6:	4798      	blx	r3
 80012e8:	9b01      	ldr	r3, [sp, #4]
 80012ea:	781b      	ldrb	r3, [r3, #0]
 80012ec:	2b04      	cmp	r3, #4
 80012ee:	d140      	bne.n	8001372 <adc_lld_serve_rx_interrupt+0x132>
 80012f0:	9b01      	ldr	r3, [sp, #4]
 80012f2:	2203      	movs	r2, #3
 80012f4:	701a      	strb	r2, [r3, #0]
}
 80012f6:	e03c      	b.n	8001372 <adc_lld_serve_rx_interrupt+0x132>
        _adc_isr_full_code(adcp);
 80012f8:	9b01      	ldr	r3, [sp, #4]
 80012fa:	0018      	movs	r0, r3
 80012fc:	f000 f988 	bl	8001610 <adc_lld_stop_conversion>
 8001300:	9b01      	ldr	r3, [sp, #4]
 8001302:	691b      	ldr	r3, [r3, #16]
 8001304:	685b      	ldr	r3, [r3, #4]
 8001306:	2b00      	cmp	r3, #0
 8001308:	d013      	beq.n	8001332 <adc_lld_serve_rx_interrupt+0xf2>
 800130a:	9b01      	ldr	r3, [sp, #4]
 800130c:	2204      	movs	r2, #4
 800130e:	701a      	strb	r2, [r3, #0]
 8001310:	9b01      	ldr	r3, [sp, #4]
 8001312:	691b      	ldr	r3, [r3, #16]
 8001314:	685b      	ldr	r3, [r3, #4]
 8001316:	9a01      	ldr	r2, [sp, #4]
 8001318:	0010      	movs	r0, r2
 800131a:	4798      	blx	r3
 800131c:	9b01      	ldr	r3, [sp, #4]
 800131e:	781b      	ldrb	r3, [r3, #0]
 8001320:	2b04      	cmp	r3, #4
 8001322:	d10c      	bne.n	800133e <adc_lld_serve_rx_interrupt+0xfe>
 8001324:	9b01      	ldr	r3, [sp, #4]
 8001326:	2202      	movs	r2, #2
 8001328:	701a      	strb	r2, [r3, #0]
 800132a:	9b01      	ldr	r3, [sp, #4]
 800132c:	2200      	movs	r2, #0
 800132e:	611a      	str	r2, [r3, #16]
 8001330:	e005      	b.n	800133e <adc_lld_serve_rx_interrupt+0xfe>
 8001332:	9b01      	ldr	r3, [sp, #4]
 8001334:	2202      	movs	r2, #2
 8001336:	701a      	strb	r2, [r3, #0]
 8001338:	9b01      	ldr	r3, [sp, #4]
 800133a:	2200      	movs	r2, #0
 800133c:	611a      	str	r2, [r3, #16]
 800133e:	f7ff fef7 	bl	8001130 <osalSysLockFromISR.lto_priv.0>
 8001342:	9b01      	ldr	r3, [sp, #4]
 8001344:	3314      	adds	r3, #20
 8001346:	2100      	movs	r1, #0
 8001348:	0018      	movs	r0, r3
 800134a:	f7ff ff01 	bl	8001150 <osalThreadResumeI.lto_priv.1>
 800134e:	f7ff fef7 	bl	8001140 <osalSysUnlockFromISR.lto_priv.0>
}
 8001352:	e00e      	b.n	8001372 <adc_lld_serve_rx_interrupt+0x132>
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8001354:	9b00      	ldr	r3, [sp, #0]
 8001356:	2204      	movs	r2, #4
 8001358:	4013      	ands	r3, r2
 800135a:	d00a      	beq.n	8001372 <adc_lld_serve_rx_interrupt+0x132>
        _adc_isr_half_code(adcp);
 800135c:	9b01      	ldr	r3, [sp, #4]
 800135e:	691b      	ldr	r3, [r3, #16]
 8001360:	685b      	ldr	r3, [r3, #4]
 8001362:	2b00      	cmp	r3, #0
 8001364:	d005      	beq.n	8001372 <adc_lld_serve_rx_interrupt+0x132>
 8001366:	9b01      	ldr	r3, [sp, #4]
 8001368:	691b      	ldr	r3, [r3, #16]
 800136a:	685b      	ldr	r3, [r3, #4]
 800136c:	9a01      	ldr	r2, [sp, #4]
 800136e:	0010      	movs	r0, r2
 8001370:	4798      	blx	r3
}
 8001372:	46c0      	nop			@ (mov r8, r8)
 8001374:	b003      	add	sp, #12
 8001376:	bd00      	pop	{pc}
	...

08001380 <Vector70>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8001380:	b500      	push	{lr}
 8001382:	b083      	sub	sp, #12
 8001384:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8001386:	9301      	str	r3, [sp, #4]
 8001388:	4b0b      	ldr	r3, [pc, #44]	@ (80013b8 <Vector70+0x38>)
 800138a:	0018      	movs	r0, r3
 800138c:	f001 f928 	bl	80025e0 <__trace_isr_enter>
 8001390:	f000 ff7e 	bl	8002290 <__dbg_check_enter_isr>

  adc_lld_serve_interrupt(&ADCD1);
 8001394:	4b09      	ldr	r3, [pc, #36]	@ (80013bc <Vector70+0x3c>)
 8001396:	0018      	movs	r0, r3
 8001398:	f000 f95a 	bl	8001650 <adc_lld_serve_interrupt>

#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif

  OSAL_IRQ_EPILOGUE();
 800139c:	f000 ffa8 	bl	80022f0 <__dbg_check_leave_isr>
 80013a0:	4b05      	ldr	r3, [pc, #20]	@ (80013b8 <Vector70+0x38>)
 80013a2:	0018      	movs	r0, r3
 80013a4:	f001 f94c 	bl	8002640 <__trace_isr_leave>
 80013a8:	9b01      	ldr	r3, [sp, #4]
 80013aa:	0018      	movs	r0, r3
 80013ac:	f003 fbe0 	bl	8004b70 <__port_irq_epilogue>
}
 80013b0:	46c0      	nop			@ (mov r8, r8)
 80013b2:	b003      	add	sp, #12
 80013b4:	bd00      	pop	{pc}
 80013b6:	46c0      	nop			@ (mov r8, r8)
 80013b8:	08004ee4 	.word	0x08004ee4
 80013bc:	20000600 	.word	0x20000600

080013c0 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 80013c0:	b510      	push	{r4, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 80013c2:	4b09      	ldr	r3, [pc, #36]	@ (80013e8 <adc_lld_init+0x28>)
 80013c4:	0018      	movs	r0, r3
 80013c6:	f7ff f8fb 	bl	80005c0 <adcObjectInit>
  ADCD1.adc     = ADC1;
 80013ca:	4b07      	ldr	r3, [pc, #28]	@ (80013e8 <adc_lld_init+0x28>)
 80013cc:	4a07      	ldr	r2, [pc, #28]	@ (80013ec <adc_lld_init+0x2c>)
 80013ce:	629a      	str	r2, [r3, #40]	@ 0x28
  ADCD1.dmastp  = NULL;
 80013d0:	4b05      	ldr	r3, [pc, #20]	@ (80013e8 <adc_lld_init+0x28>)
 80013d2:	2200      	movs	r2, #0
 80013d4:	62da      	str	r2, [r3, #44]	@ 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 80013d6:	4b04      	ldr	r3, [pc, #16]	@ (80013e8 <adc_lld_init+0x28>)
 80013d8:	4a05      	ldr	r2, [pc, #20]	@ (80013f0 <adc_lld_init+0x30>)
 80013da:	631a      	str	r2, [r3, #48]	@ 0x30
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;

  /* The vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(12, STM32_ADC_ADC1_IRQ_PRIORITY);
 80013dc:	2102      	movs	r1, #2
 80013de:	200c      	movs	r0, #12
 80013e0:	f7ff fb86 	bl	8000af0 <nvicEnableVector>
#endif
}
 80013e4:	46c0      	nop			@ (mov r8, r8)
 80013e6:	bd10      	pop	{r4, pc}
 80013e8:	20000600 	.word	0x20000600
 80013ec:	40012400 	.word	0x40012400
 80013f0:	0000258a 	.word	0x0000258a
	...

08001400 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8001400:	b500      	push	{lr}
 8001402:	b083      	sub	sp, #12
 8001404:	9001      	str	r0, [sp, #4]

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8001406:	9b01      	ldr	r3, [sp, #4]
 8001408:	781b      	ldrb	r3, [r3, #0]
 800140a:	2b01      	cmp	r3, #1
 800140c:	d14c      	bne.n	80014a8 <adc_lld_start+0xa8>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800140e:	9a01      	ldr	r2, [sp, #4]
 8001410:	4b27      	ldr	r3, [pc, #156]	@ (80014b0 <adc_lld_start+0xb0>)
 8001412:	429a      	cmp	r2, r3
 8001414:	d13f      	bne.n	8001496 <adc_lld_start+0x96>
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 8001416:	9b01      	ldr	r3, [sp, #4]
 8001418:	4a26      	ldr	r2, [pc, #152]	@ (80014b4 <adc_lld_start+0xb4>)
 800141a:	2102      	movs	r1, #2
 800141c:	2000      	movs	r0, #0
 800141e:	f000 f9e7 	bl	80017f0 <dmaStreamAllocI>
 8001422:	0002      	movs	r2, r0
 8001424:	9b01      	ldr	r3, [sp, #4]
 8001426:	62da      	str	r2, [r3, #44]	@ 0x2c
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8001428:	9b01      	ldr	r3, [sp, #4]
 800142a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800142c:	425a      	negs	r2, r3
 800142e:	4153      	adcs	r3, r2
 8001430:	b2db      	uxtb	r3, r3
 8001432:	2b00      	cmp	r3, #0
 8001434:	d003      	beq.n	800143e <adc_lld_start+0x3e>
 8001436:	4b20      	ldr	r3, [pc, #128]	@ (80014b8 <adc_lld_start+0xb8>)
 8001438:	0018      	movs	r0, r3
 800143a:	f000 fe19 	bl	8002070 <chSysHalt>
      rccResetADC1();
 800143e:	4b1f      	ldr	r3, [pc, #124]	@ (80014bc <adc_lld_start+0xbc>)
 8001440:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8001442:	4b1e      	ldr	r3, [pc, #120]	@ (80014bc <adc_lld_start+0xbc>)
 8001444:	2180      	movs	r1, #128	@ 0x80
 8001446:	0089      	lsls	r1, r1, #2
 8001448:	430a      	orrs	r2, r1
 800144a:	625a      	str	r2, [r3, #36]	@ 0x24
 800144c:	4b1b      	ldr	r3, [pc, #108]	@ (80014bc <adc_lld_start+0xbc>)
 800144e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8001450:	4b1a      	ldr	r3, [pc, #104]	@ (80014bc <adc_lld_start+0xbc>)
 8001452:	491b      	ldr	r1, [pc, #108]	@ (80014c0 <adc_lld_start+0xc0>)
 8001454:	400a      	ands	r2, r1
 8001456:	625a      	str	r2, [r3, #36]	@ 0x24
 8001458:	4b18      	ldr	r3, [pc, #96]	@ (80014bc <adc_lld_start+0xbc>)
 800145a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
      rccEnableADC1(true);
 800145c:	4b17      	ldr	r3, [pc, #92]	@ (80014bc <adc_lld_start+0xbc>)
 800145e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8001460:	4b16      	ldr	r3, [pc, #88]	@ (80014bc <adc_lld_start+0xbc>)
 8001462:	2180      	movs	r1, #128	@ 0x80
 8001464:	0089      	lsls	r1, r1, #2
 8001466:	430a      	orrs	r2, r1
 8001468:	635a      	str	r2, [r3, #52]	@ 0x34
 800146a:	4b14      	ldr	r3, [pc, #80]	@ (80014bc <adc_lld_start+0xbc>)
 800146c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800146e:	4b13      	ldr	r3, [pc, #76]	@ (80014bc <adc_lld_start+0xbc>)
 8001470:	2180      	movs	r1, #128	@ 0x80
 8001472:	0089      	lsls	r1, r1, #2
 8001474:	430a      	orrs	r2, r1
 8001476:	645a      	str	r2, [r3, #68]	@ 0x44
 8001478:	4b10      	ldr	r3, [pc, #64]	@ (80014bc <adc_lld_start+0xbc>)
 800147a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44

      /* DMA setup.*/
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800147c:	9b01      	ldr	r3, [sp, #4]
 800147e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001480:	685b      	ldr	r3, [r3, #4]
 8001482:	4a10      	ldr	r2, [pc, #64]	@ (80014c4 <adc_lld_start+0xc4>)
 8001484:	609a      	str	r2, [r3, #8]
      dmaSetRequestSource(adcp->dmastp, STM32_DMAMUX1_ADC1);
#endif

      /* Clock settings.*/
#if STM32_ADC_SUPPORTS_PRESCALER
      ADC->CCR = STM32_ADC_PRESC << 18;
 8001486:	4b10      	ldr	r3, [pc, #64]	@ (80014c8 <adc_lld_start+0xc8>)
 8001488:	2280      	movs	r2, #128	@ 0x80
 800148a:	02d2      	lsls	r2, r2, #11
 800148c:	601a      	str	r2, [r3, #0]
#else
      ADC->CCR = 0;
#endif
      adcp->adc->CFGR2 = STM32_ADC_ADC1_CFGR2;
 800148e:	9b01      	ldr	r3, [sp, #4]
 8001490:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001492:	2200      	movs	r2, #0
 8001494:	611a      	str	r2, [r3, #16]
    }
#endif /* STM32_ADC_USE_ADC1 */

    /* Regulator enabled and stabilized before calibration.*/
    adc_lld_vreg_on(ADC1);
 8001496:	4b0d      	ldr	r3, [pc, #52]	@ (80014cc <adc_lld_start+0xcc>)
 8001498:	0018      	movs	r0, r3
 800149a:	f7ff fe69 	bl	8001170 <adc_lld_vreg_on>

    /* Calibrating ADC.*/
    adc_lld_calibrate(adcp->adc);
 800149e:	9b01      	ldr	r3, [sp, #4]
 80014a0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014a2:	0018      	movs	r0, r3
 80014a4:	f7ff fe8c 	bl	80011c0 <adc_lld_calibrate>
  }
}
 80014a8:	46c0      	nop			@ (mov r8, r8)
 80014aa:	b003      	add	sp, #12
 80014ac:	bd00      	pop	{pc}
 80014ae:	46c0      	nop			@ (mov r8, r8)
 80014b0:	20000600 	.word	0x20000600
 80014b4:	08001241 	.word	0x08001241
 80014b8:	08004ef0 	.word	0x08004ef0
 80014bc:	40021000 	.word	0x40021000
 80014c0:	fffffdff 	.word	0xfffffdff
 80014c4:	40012440 	.word	0x40012440
 80014c8:	40012708 	.word	0x40012708
 80014cc:	40012400 	.word	0x40012400

080014d0 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 80014d0:	b086      	sub	sp, #24
 80014d2:	9001      	str	r0, [sp, #4]
  uint32_t mode, cfgr1;
  const ADCConversionGroup *grpp = adcp->grpp;
 80014d4:	9b01      	ldr	r3, [sp, #4]
 80014d6:	691b      	ldr	r3, [r3, #16]
 80014d8:	9303      	str	r3, [sp, #12]

  /* Write back ISR bits to clear register.*/
  adcp->adc->ISR = adcp->adc->ISR;
 80014da:	9b01      	ldr	r3, [sp, #4]
 80014dc:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80014de:	9b01      	ldr	r3, [sp, #4]
 80014e0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80014e2:	6812      	ldr	r2, [r2, #0]
 80014e4:	601a      	str	r2, [r3, #0]

  /* Get group1 configuration. Transfer the clock mode for group2.*/
  cfgr1  = grpp->cfgr1 | ADC_CFGR1_DMAEN;
 80014e6:	9b03      	ldr	r3, [sp, #12]
 80014e8:	68db      	ldr	r3, [r3, #12]
 80014ea:	2201      	movs	r2, #1
 80014ec:	4313      	orrs	r3, r2
 80014ee:	9304      	str	r3, [sp, #16]

  /* DMA setup.*/
  mode  = adcp->dmamode;
 80014f0:	9b01      	ldr	r3, [sp, #4]
 80014f2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80014f4:	9305      	str	r3, [sp, #20]
  if (grpp->circular) {
 80014f6:	9b03      	ldr	r3, [sp, #12]
 80014f8:	781b      	ldrb	r3, [r3, #0]
 80014fa:	2b00      	cmp	r3, #0
 80014fc:	d00f      	beq.n	800151e <adc_lld_start_conversion+0x4e>
    mode  |= STM32_DMA_CR_CIRC;
 80014fe:	9b05      	ldr	r3, [sp, #20]
 8001500:	2220      	movs	r2, #32
 8001502:	4313      	orrs	r3, r2
 8001504:	9305      	str	r3, [sp, #20]
    cfgr1 |= ADC_CFGR1_DMACFG;
 8001506:	9b04      	ldr	r3, [sp, #16]
 8001508:	2202      	movs	r2, #2
 800150a:	4313      	orrs	r3, r2
 800150c:	9304      	str	r3, [sp, #16]
    if (adcp->depth > 1) {
 800150e:	9b01      	ldr	r3, [sp, #4]
 8001510:	68db      	ldr	r3, [r3, #12]
 8001512:	2b01      	cmp	r3, #1
 8001514:	d903      	bls.n	800151e <adc_lld_start_conversion+0x4e>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
 8001516:	9b05      	ldr	r3, [sp, #20]
 8001518:	2204      	movs	r2, #4
 800151a:	4313      	orrs	r3, r2
 800151c:	9305      	str	r3, [sp, #20]
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800151e:	9b01      	ldr	r3, [sp, #4]
 8001520:	689a      	ldr	r2, [r3, #8]
 8001522:	9b01      	ldr	r3, [sp, #4]
 8001524:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001526:	685b      	ldr	r3, [r3, #4]
 8001528:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800152a:	9b03      	ldr	r3, [sp, #12]
 800152c:	885b      	ldrh	r3, [r3, #2]
 800152e:	0019      	movs	r1, r3
 8001530:	9b01      	ldr	r3, [sp, #4]
 8001532:	68da      	ldr	r2, [r3, #12]
 8001534:	9b01      	ldr	r3, [sp, #4]
 8001536:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001538:	685b      	ldr	r3, [r3, #4]
 800153a:	434a      	muls	r2, r1
 800153c:	605a      	str	r2, [r3, #4]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
 800153e:	9b01      	ldr	r3, [sp, #4]
 8001540:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001542:	68db      	ldr	r3, [r3, #12]
 8001544:	681b      	ldr	r3, [r3, #0]
 8001546:	9302      	str	r3, [sp, #8]
 8001548:	9b01      	ldr	r3, [sp, #4]
 800154a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800154c:	7c1b      	ldrb	r3, [r3, #16]
 800154e:	001a      	movs	r2, r3
 8001550:	230f      	movs	r3, #15
 8001552:	4093      	lsls	r3, r2
 8001554:	43da      	mvns	r2, r3
 8001556:	9b02      	ldr	r3, [sp, #8]
 8001558:	4013      	ands	r3, r2
 800155a:	9302      	str	r3, [sp, #8]
 800155c:	9b05      	ldr	r3, [sp, #20]
 800155e:	0c1a      	lsrs	r2, r3, #16
 8001560:	9b01      	ldr	r3, [sp, #4]
 8001562:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001564:	7c1b      	ldrb	r3, [r3, #16]
 8001566:	409a      	lsls	r2, r3
 8001568:	0013      	movs	r3, r2
 800156a:	9a02      	ldr	r2, [sp, #8]
 800156c:	4313      	orrs	r3, r2
 800156e:	9302      	str	r3, [sp, #8]
 8001570:	9b01      	ldr	r3, [sp, #4]
 8001572:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001574:	68db      	ldr	r3, [r3, #12]
 8001576:	9a02      	ldr	r2, [sp, #8]
 8001578:	601a      	str	r2, [r3, #0]
 800157a:	9b01      	ldr	r3, [sp, #4]
 800157c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800157e:	685b      	ldr	r3, [r3, #4]
 8001580:	9a05      	ldr	r2, [sp, #20]
 8001582:	601a      	str	r2, [r3, #0]

  /* Apply ADC configuration.*/
  adcp->adc->CFGR1  = cfgr1;
 8001584:	9b01      	ldr	r3, [sp, #4]
 8001586:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001588:	9a04      	ldr	r2, [sp, #16]
 800158a:	60da      	str	r2, [r3, #12]
  adcp->adc->CHSELR = grpp->chselr;
 800158c:	9b01      	ldr	r3, [sp, #4]
 800158e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001590:	9a03      	ldr	r2, [sp, #12]
 8001592:	6992      	ldr	r2, [r2, #24]
 8001594:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Set the sample rate(s).*/
  adcp->adc->SMPR   = grpp->smpr;
 8001596:	9b01      	ldr	r3, [sp, #4]
 8001598:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800159a:	9a03      	ldr	r2, [sp, #12]
 800159c:	6952      	ldr	r2, [r2, #20]
 800159e:	615a      	str	r2, [r3, #20]

  /* Enable ADC interrupts if callback specified.*/
   if (grpp->error_cb != NULL) {
 80015a0:	9b03      	ldr	r3, [sp, #12]
 80015a2:	689b      	ldr	r3, [r3, #8]
 80015a4:	2b00      	cmp	r3, #0
 80015a6:	d00e      	beq.n	80015c6 <adc_lld_start_conversion+0xf6>
     adcp->adc->ISR = adcp->adc->ISR;
 80015a8:	9b01      	ldr	r3, [sp, #4]
 80015aa:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80015ac:	9b01      	ldr	r3, [sp, #4]
 80015ae:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015b0:	6812      	ldr	r2, [r2, #0]
 80015b2:	601a      	str	r2, [r3, #0]
     adcp->adc->IER = ADC_IER_OVRIE | ADC_IER_AWD1IE;
 80015b4:	9b01      	ldr	r3, [sp, #4]
 80015b6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015b8:	2290      	movs	r2, #144	@ 0x90
 80015ba:	605a      	str	r2, [r3, #4]
     adcp->adc->TR1 = grpp->tr;
 80015bc:	9b01      	ldr	r3, [sp, #4]
 80015be:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015c0:	9a03      	ldr	r2, [sp, #12]
 80015c2:	6912      	ldr	r2, [r2, #16]
 80015c4:	621a      	str	r2, [r3, #32]
   }

  /* Enable the ADC. Note: Setting ADEN must be deferred as the ADC will
     reset RES[1:0] resolution bits if CFGR1 is modified with ADEN set.
     See the errata sheet.*/
  adcp->adc->CR  |= ADC_CR_ADEN;
 80015c6:	9b01      	ldr	r3, [sp, #4]
 80015c8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015ca:	689a      	ldr	r2, [r3, #8]
 80015cc:	9b01      	ldr	r3, [sp, #4]
 80015ce:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015d0:	2101      	movs	r1, #1
 80015d2:	430a      	orrs	r2, r1
 80015d4:	609a      	str	r2, [r3, #8]
  while ((adcp->adc->ISR & ADC_ISR_ADRDY) == 0U) {
 80015d6:	46c0      	nop			@ (mov r8, r8)
 80015d8:	9b01      	ldr	r3, [sp, #4]
 80015da:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015dc:	681b      	ldr	r3, [r3, #0]
 80015de:	2201      	movs	r2, #1
 80015e0:	4013      	ands	r3, r2
 80015e2:	d0f9      	beq.n	80015d8 <adc_lld_start_conversion+0x108>
    /* Wait for the ADC to become ready.*/
  }

  /* Enable DMA controller stream.*/
  dmaStreamEnable(adcp->dmastp);
 80015e4:	9b01      	ldr	r3, [sp, #4]
 80015e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80015e8:	685b      	ldr	r3, [r3, #4]
 80015ea:	681a      	ldr	r2, [r3, #0]
 80015ec:	9b01      	ldr	r3, [sp, #4]
 80015ee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80015f0:	685b      	ldr	r3, [r3, #4]
 80015f2:	2101      	movs	r1, #1
 80015f4:	430a      	orrs	r2, r1
 80015f6:	601a      	str	r2, [r3, #0]

  /* ADC conversion start.*/
  adcp->adc->CR |= ADC_CR_ADSTART;
 80015f8:	9b01      	ldr	r3, [sp, #4]
 80015fa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80015fc:	689a      	ldr	r2, [r3, #8]
 80015fe:	9b01      	ldr	r3, [sp, #4]
 8001600:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001602:	2104      	movs	r1, #4
 8001604:	430a      	orrs	r2, r1
 8001606:	609a      	str	r2, [r3, #8]
}
 8001608:	46c0      	nop			@ (mov r8, r8)
 800160a:	b006      	add	sp, #24
 800160c:	4770      	bx	lr
 800160e:	46c0      	nop			@ (mov r8, r8)

08001610 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8001610:	b500      	push	{lr}
 8001612:	b083      	sub	sp, #12
 8001614:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
 8001616:	9b01      	ldr	r3, [sp, #4]
 8001618:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800161a:	685b      	ldr	r3, [r3, #4]
 800161c:	681a      	ldr	r2, [r3, #0]
 800161e:	9b01      	ldr	r3, [sp, #4]
 8001620:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001622:	685b      	ldr	r3, [r3, #4]
 8001624:	210f      	movs	r1, #15
 8001626:	438a      	bics	r2, r1
 8001628:	601a      	str	r2, [r3, #0]
 800162a:	9b01      	ldr	r3, [sp, #4]
 800162c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800162e:	7c1b      	ldrb	r3, [r3, #16]
 8001630:	001a      	movs	r2, r3
 8001632:	230e      	movs	r3, #14
 8001634:	4093      	lsls	r3, r2
 8001636:	001a      	movs	r2, r3
 8001638:	9b01      	ldr	r3, [sp, #4]
 800163a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800163c:	681b      	ldr	r3, [r3, #0]
 800163e:	605a      	str	r2, [r3, #4]
  adc_lld_stop_adc(adcp->adc);
 8001640:	9b01      	ldr	r3, [sp, #4]
 8001642:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001644:	0018      	movs	r0, r3
 8001646:	f7ff fdd3 	bl	80011f0 <adc_lld_stop_adc>
}
 800164a:	46c0      	nop			@ (mov r8, r8)
 800164c:	b003      	add	sp, #12
 800164e:	bd00      	pop	{pc}

08001650 <adc_lld_serve_interrupt>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_serve_interrupt(ADCDriver *adcp) {
 8001650:	b500      	push	{lr}
 8001652:	b085      	sub	sp, #20
 8001654:	9001      	str	r0, [sp, #4]
  uint32_t isr;

  isr = adcp->adc->ISR;
 8001656:	9b01      	ldr	r3, [sp, #4]
 8001658:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800165a:	681b      	ldr	r3, [r3, #0]
 800165c:	9302      	str	r3, [sp, #8]
  adcp->adc->ISR = isr;
 800165e:	9b01      	ldr	r3, [sp, #4]
 8001660:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001662:	9a02      	ldr	r2, [sp, #8]
 8001664:	601a      	str	r2, [r3, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8001666:	9b01      	ldr	r3, [sp, #4]
 8001668:	691b      	ldr	r3, [r3, #16]
 800166a:	2b00      	cmp	r3, #0
 800166c:	d04a      	beq.n	8001704 <adc_lld_serve_interrupt+0xb4>
    adcerror_t emask = 0U;
 800166e:	2300      	movs	r3, #0
 8001670:	9303      	str	r3, [sp, #12]

   /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 8001672:	9b02      	ldr	r3, [sp, #8]
 8001674:	2210      	movs	r2, #16
 8001676:	4013      	ands	r3, r2
 8001678:	d009      	beq.n	800168e <adc_lld_serve_interrupt+0x3e>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
 800167a:	9b01      	ldr	r3, [sp, #4]
 800167c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800167e:	685b      	ldr	r3, [r3, #4]
 8001680:	685b      	ldr	r3, [r3, #4]
    if ((isr & ADC_ISR_OVR) &&
 8001682:	2b00      	cmp	r3, #0
 8001684:	d003      	beq.n	800168e <adc_lld_serve_interrupt+0x3e>
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
 8001686:	9b03      	ldr	r3, [sp, #12]
 8001688:	2202      	movs	r2, #2
 800168a:	4313      	orrs	r3, r2
 800168c:	9303      	str	r3, [sp, #12]
    }
    if (isr & ADC_ISR_AWD1) {
 800168e:	9b02      	ldr	r3, [sp, #8]
 8001690:	2280      	movs	r2, #128	@ 0x80
 8001692:	4013      	ands	r3, r2
 8001694:	d003      	beq.n	800169e <adc_lld_serve_interrupt+0x4e>
      /* Analog watchdog error.*/
      emask |= ADC_ERR_AWD1;
 8001696:	9b03      	ldr	r3, [sp, #12]
 8001698:	2204      	movs	r2, #4
 800169a:	4313      	orrs	r3, r2
 800169c:	9303      	str	r3, [sp, #12]
    }
    if (emask != 0U) {
 800169e:	9b03      	ldr	r3, [sp, #12]
 80016a0:	2b00      	cmp	r3, #0
 80016a2:	d02f      	beq.n	8001704 <adc_lld_serve_interrupt+0xb4>
      _adc_isr_error_code(adcp, emask);
 80016a4:	9b01      	ldr	r3, [sp, #4]
 80016a6:	0018      	movs	r0, r3
 80016a8:	f7ff ffb2 	bl	8001610 <adc_lld_stop_conversion>
 80016ac:	9b01      	ldr	r3, [sp, #4]
 80016ae:	691b      	ldr	r3, [r3, #16]
 80016b0:	689b      	ldr	r3, [r3, #8]
 80016b2:	2b00      	cmp	r3, #0
 80016b4:	d014      	beq.n	80016e0 <adc_lld_serve_interrupt+0x90>
 80016b6:	9b01      	ldr	r3, [sp, #4]
 80016b8:	2205      	movs	r2, #5
 80016ba:	701a      	strb	r2, [r3, #0]
 80016bc:	9b01      	ldr	r3, [sp, #4]
 80016be:	691b      	ldr	r3, [r3, #16]
 80016c0:	689b      	ldr	r3, [r3, #8]
 80016c2:	9903      	ldr	r1, [sp, #12]
 80016c4:	9a01      	ldr	r2, [sp, #4]
 80016c6:	0010      	movs	r0, r2
 80016c8:	4798      	blx	r3
 80016ca:	9b01      	ldr	r3, [sp, #4]
 80016cc:	781b      	ldrb	r3, [r3, #0]
 80016ce:	2b05      	cmp	r3, #5
 80016d0:	d10c      	bne.n	80016ec <adc_lld_serve_interrupt+0x9c>
 80016d2:	9b01      	ldr	r3, [sp, #4]
 80016d4:	2202      	movs	r2, #2
 80016d6:	701a      	strb	r2, [r3, #0]
 80016d8:	9b01      	ldr	r3, [sp, #4]
 80016da:	2200      	movs	r2, #0
 80016dc:	611a      	str	r2, [r3, #16]
 80016de:	e005      	b.n	80016ec <adc_lld_serve_interrupt+0x9c>
 80016e0:	9b01      	ldr	r3, [sp, #4]
 80016e2:	2202      	movs	r2, #2
 80016e4:	701a      	strb	r2, [r3, #0]
 80016e6:	9b01      	ldr	r3, [sp, #4]
 80016e8:	2200      	movs	r2, #0
 80016ea:	611a      	str	r2, [r3, #16]
 80016ec:	f7ff fd20 	bl	8001130 <osalSysLockFromISR.lto_priv.0>
 80016f0:	9b01      	ldr	r3, [sp, #4]
 80016f2:	3314      	adds	r3, #20
 80016f4:	2201      	movs	r2, #1
 80016f6:	4252      	negs	r2, r2
 80016f8:	0011      	movs	r1, r2
 80016fa:	0018      	movs	r0, r3
 80016fc:	f7ff fd28 	bl	8001150 <osalThreadResumeI.lto_priv.1>
 8001700:	f7ff fd1e 	bl	8001140 <osalSysUnlockFromISR.lto_priv.0>
    }
  }
}
 8001704:	46c0      	nop			@ (mov r8, r8)
 8001706:	b005      	add	sp, #20
 8001708:	bd00      	pop	{pc}
 800170a:	46c0      	nop			@ (mov r8, r8)
 800170c:	0000      	movs	r0, r0
	...

08001710 <adcSTM32EnableVREF>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableVREF(ADCDriver *adcp) {
 8001710:	b082      	sub	sp, #8
 8001712:	9001      	str	r0, [sp, #4]

  (void)adcp;

  ADC->CCR |= ADC_CCR_VREFEN;
 8001714:	4b04      	ldr	r3, [pc, #16]	@ (8001728 <adcSTM32EnableVREF+0x18>)
 8001716:	681a      	ldr	r2, [r3, #0]
 8001718:	4b03      	ldr	r3, [pc, #12]	@ (8001728 <adcSTM32EnableVREF+0x18>)
 800171a:	2180      	movs	r1, #128	@ 0x80
 800171c:	03c9      	lsls	r1, r1, #15
 800171e:	430a      	orrs	r2, r1
 8001720:	601a      	str	r2, [r3, #0]
}
 8001722:	46c0      	nop			@ (mov r8, r8)
 8001724:	b002      	add	sp, #8
 8001726:	4770      	bx	lr
 8001728:	40012708 	.word	0x40012708
 800172c:	00000000 	.word	0x00000000

08001730 <adcSTM32EnableTS>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adcSTM32EnableTS(ADCDriver *adcp) {
 8001730:	b082      	sub	sp, #8
 8001732:	9001      	str	r0, [sp, #4]

  (void)adcp;

  ADC->CCR |= ADC_CCR_TSEN;
 8001734:	4b04      	ldr	r3, [pc, #16]	@ (8001748 <adcSTM32EnableTS+0x18>)
 8001736:	681a      	ldr	r2, [r3, #0]
 8001738:	4b03      	ldr	r3, [pc, #12]	@ (8001748 <adcSTM32EnableTS+0x18>)
 800173a:	2180      	movs	r1, #128	@ 0x80
 800173c:	0409      	lsls	r1, r1, #16
 800173e:	430a      	orrs	r2, r1
 8001740:	601a      	str	r2, [r3, #0]
}
 8001742:	46c0      	nop			@ (mov r8, r8)
 8001744:	b002      	add	sp, #8
 8001746:	4770      	bx	lr
 8001748:	40012708 	.word	0x40012708
 800174c:	00000000 	.word	0x00000000

08001750 <Vector64>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001750:	b500      	push	{lr}
 8001752:	b083      	sub	sp, #12
 8001754:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8001756:	9301      	str	r3, [sp, #4]
 8001758:	4b0b      	ldr	r3, [pc, #44]	@ (8001788 <Vector64+0x38>)
 800175a:	0018      	movs	r0, r3
 800175c:	f000 ff40 	bl	80025e0 <__trace_isr_enter>
 8001760:	f000 fd96 	bl	8002290 <__dbg_check_enter_isr>

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8001764:	4b09      	ldr	r3, [pc, #36]	@ (800178c <Vector64+0x3c>)
 8001766:	0018      	movs	r0, r3
 8001768:	f000 f8da 	bl	8001920 <dmaServeInterrupt>

  OSAL_IRQ_EPILOGUE();
 800176c:	f000 fdc0 	bl	80022f0 <__dbg_check_leave_isr>
 8001770:	4b05      	ldr	r3, [pc, #20]	@ (8001788 <Vector64+0x38>)
 8001772:	0018      	movs	r0, r3
 8001774:	f000 ff64 	bl	8002640 <__trace_isr_leave>
 8001778:	9b01      	ldr	r3, [sp, #4]
 800177a:	0018      	movs	r0, r3
 800177c:	f003 f9f8 	bl	8004b70 <__port_irq_epilogue>
}
 8001780:	46c0      	nop			@ (mov r8, r8)
 8001782:	b003      	add	sp, #12
 8001784:	bd00      	pop	{pc}
 8001786:	46c0      	nop			@ (mov r8, r8)
 8001788:	08004f8c 	.word	0x08004f8c
 800178c:	08004f00 	.word	0x08004f00

08001790 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8001790:	b082      	sub	sp, #8
  int i;

  dma.allocated_mask = 0U;
 8001792:	4b13      	ldr	r3, [pc, #76]	@ (80017e0 <dmaInit+0x50>)
 8001794:	2200      	movs	r2, #0
 8001796:	601a      	str	r2, [r3, #0]
  dma.isr_mask       = 0U;
 8001798:	4b11      	ldr	r3, [pc, #68]	@ (80017e0 <dmaInit+0x50>)
 800179a:	2200      	movs	r2, #0
 800179c:	605a      	str	r2, [r3, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800179e:	2300      	movs	r3, #0
 80017a0:	9301      	str	r3, [sp, #4]
 80017a2:	e013      	b.n	80017cc <dmaInit+0x3c>
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80017a4:	490f      	ldr	r1, [pc, #60]	@ (80017e4 <dmaInit+0x54>)
 80017a6:	9a01      	ldr	r2, [sp, #4]
 80017a8:	0013      	movs	r3, r2
 80017aa:	009b      	lsls	r3, r3, #2
 80017ac:	189b      	adds	r3, r3, r2
 80017ae:	009b      	lsls	r3, r3, #2
 80017b0:	18cb      	adds	r3, r1, r3
 80017b2:	3304      	adds	r3, #4
 80017b4:	681b      	ldr	r3, [r3, #0]
 80017b6:	2200      	movs	r2, #0
 80017b8:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 80017ba:	4b09      	ldr	r3, [pc, #36]	@ (80017e0 <dmaInit+0x50>)
 80017bc:	9a01      	ldr	r2, [sp, #4]
 80017be:	3201      	adds	r2, #1
 80017c0:	00d2      	lsls	r2, r2, #3
 80017c2:	2100      	movs	r1, #0
 80017c4:	50d1      	str	r1, [r2, r3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80017c6:	9b01      	ldr	r3, [sp, #4]
 80017c8:	3301      	adds	r3, #1
 80017ca:	9301      	str	r3, [sp, #4]
 80017cc:	9b01      	ldr	r3, [sp, #4]
 80017ce:	2b06      	cmp	r3, #6
 80017d0:	dde8      	ble.n	80017a4 <dmaInit+0x14>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 80017d2:	4b05      	ldr	r3, [pc, #20]	@ (80017e8 <dmaInit+0x58>)
 80017d4:	2201      	movs	r2, #1
 80017d6:	4252      	negs	r2, r2
 80017d8:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
#endif
}
 80017da:	46c0      	nop			@ (mov r8, r8)
 80017dc:	b002      	add	sp, #8
 80017de:	4770      	bx	lr
 80017e0:	20000634 	.word	0x20000634
 80017e4:	08004f00 	.word	0x08004f00
 80017e8:	40020000 	.word	0x40020000
 80017ec:	00000000 	.word	0x00000000

080017f0 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 80017f0:	b500      	push	{lr}
 80017f2:	b08b      	sub	sp, #44	@ 0x2c
 80017f4:	9003      	str	r0, [sp, #12]
 80017f6:	9102      	str	r1, [sp, #8]
 80017f8:	9201      	str	r2, [sp, #4]
 80017fa:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 80017fc:	f000 fda8 	bl	8002350 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 8001800:	9b03      	ldr	r3, [sp, #12]
 8001802:	2b06      	cmp	r3, #6
 8001804:	d806      	bhi.n	8001814 <dmaStreamAllocI+0x24>
    startid = id;
 8001806:	9b03      	ldr	r3, [sp, #12]
 8001808:	9308      	str	r3, [sp, #32]
    endid   = id;
 800180a:	9b03      	ldr	r3, [sp, #12]
 800180c:	9307      	str	r3, [sp, #28]
  else {
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
 800180e:	9b08      	ldr	r3, [sp, #32]
 8001810:	9309      	str	r3, [sp, #36]	@ 0x24
 8001812:	e06e      	b.n	80018f2 <dmaStreamAllocI+0x102>
    osalDbgCheck(false);
 8001814:	4b3b      	ldr	r3, [pc, #236]	@ (8001904 <dmaStreamAllocI+0x114>)
 8001816:	0018      	movs	r0, r3
 8001818:	f000 fc2a 	bl	8002070 <chSysHalt>
    return NULL;
 800181c:	2300      	movs	r3, #0
 800181e:	e06d      	b.n	80018fc <dmaStreamAllocI+0x10c>
    uint32_t mask = (1U << i);
 8001820:	2201      	movs	r2, #1
 8001822:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001824:	409a      	lsls	r2, r3
 8001826:	0013      	movs	r3, r2
 8001828:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 800182a:	4b37      	ldr	r3, [pc, #220]	@ (8001908 <dmaStreamAllocI+0x118>)
 800182c:	681b      	ldr	r3, [r3, #0]
 800182e:	9a06      	ldr	r2, [sp, #24]
 8001830:	4013      	ands	r3, r2
 8001832:	d15b      	bne.n	80018ec <dmaStreamAllocI+0xfc>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8001834:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001836:	0013      	movs	r3, r2
 8001838:	009b      	lsls	r3, r3, #2
 800183a:	189b      	adds	r3, r3, r2
 800183c:	009b      	lsls	r3, r3, #2
 800183e:	4a33      	ldr	r2, [pc, #204]	@ (800190c <dmaStreamAllocI+0x11c>)
 8001840:	189b      	adds	r3, r3, r2
 8001842:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8001844:	4b30      	ldr	r3, [pc, #192]	@ (8001908 <dmaStreamAllocI+0x118>)
 8001846:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8001848:	3201      	adds	r2, #1
 800184a:	00d2      	lsls	r2, r2, #3
 800184c:	9901      	ldr	r1, [sp, #4]
 800184e:	50d1      	str	r1, [r2, r3]
      dma.streams[i].param = param;
 8001850:	4a2d      	ldr	r2, [pc, #180]	@ (8001908 <dmaStreamAllocI+0x118>)
 8001852:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001854:	3301      	adds	r3, #1
 8001856:	00db      	lsls	r3, r3, #3
 8001858:	18d3      	adds	r3, r2, r3
 800185a:	3304      	adds	r3, #4
 800185c:	9a00      	ldr	r2, [sp, #0]
 800185e:	601a      	str	r2, [r3, #0]
      dma.allocated_mask  |= mask;
 8001860:	4b29      	ldr	r3, [pc, #164]	@ (8001908 <dmaStreamAllocI+0x118>)
 8001862:	681a      	ldr	r2, [r3, #0]
 8001864:	9b06      	ldr	r3, [sp, #24]
 8001866:	431a      	orrs	r2, r3
 8001868:	4b27      	ldr	r3, [pc, #156]	@ (8001908 <dmaStreamAllocI+0x118>)
 800186a:	601a      	str	r2, [r3, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 800186c:	9b06      	ldr	r3, [sp, #24]
 800186e:	227f      	movs	r2, #127	@ 0x7f
 8001870:	4013      	ands	r3, r2
 8001872:	d00d      	beq.n	8001890 <dmaStreamAllocI+0xa0>
        rccEnableDMA1(true);
 8001874:	4b26      	ldr	r3, [pc, #152]	@ (8001910 <dmaStreamAllocI+0x120>)
 8001876:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001878:	4b25      	ldr	r3, [pc, #148]	@ (8001910 <dmaStreamAllocI+0x120>)
 800187a:	2101      	movs	r1, #1
 800187c:	430a      	orrs	r2, r1
 800187e:	631a      	str	r2, [r3, #48]	@ 0x30
 8001880:	4b23      	ldr	r3, [pc, #140]	@ (8001910 <dmaStreamAllocI+0x120>)
 8001882:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8001884:	4b22      	ldr	r3, [pc, #136]	@ (8001910 <dmaStreamAllocI+0x120>)
 8001886:	2101      	movs	r1, #1
 8001888:	430a      	orrs	r2, r1
 800188a:	641a      	str	r2, [r3, #64]	@ 0x40
 800188c:	4b20      	ldr	r3, [pc, #128]	@ (8001910 <dmaStreamAllocI+0x120>)
 800188e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 8001890:	9b01      	ldr	r3, [sp, #4]
 8001892:	2b00      	cmp	r3, #0
 8001894:	d013      	beq.n	80018be <dmaStreamAllocI+0xce>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8001896:	4b1c      	ldr	r3, [pc, #112]	@ (8001908 <dmaStreamAllocI+0x118>)
 8001898:	685a      	ldr	r2, [r3, #4]
 800189a:	9b05      	ldr	r3, [sp, #20]
 800189c:	689b      	ldr	r3, [r3, #8]
 800189e:	4013      	ands	r3, r2
 80018a0:	d107      	bne.n	80018b2 <dmaStreamAllocI+0xc2>
          nvicEnableVector(dmastp->vector, priority);
 80018a2:	9b05      	ldr	r3, [sp, #20]
 80018a4:	7c9b      	ldrb	r3, [r3, #18]
 80018a6:	001a      	movs	r2, r3
 80018a8:	9b02      	ldr	r3, [sp, #8]
 80018aa:	0019      	movs	r1, r3
 80018ac:	0010      	movs	r0, r2
 80018ae:	f7ff f91f 	bl	8000af0 <nvicEnableVector>
        }
        dma.isr_mask |= mask;
 80018b2:	4b15      	ldr	r3, [pc, #84]	@ (8001908 <dmaStreamAllocI+0x118>)
 80018b4:	685a      	ldr	r2, [r3, #4]
 80018b6:	9b06      	ldr	r3, [sp, #24]
 80018b8:	431a      	orrs	r2, r3
 80018ba:	4b13      	ldr	r3, [pc, #76]	@ (8001908 <dmaStreamAllocI+0x118>)
 80018bc:	605a      	str	r2, [r3, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 80018be:	9b05      	ldr	r3, [sp, #20]
 80018c0:	685b      	ldr	r3, [r3, #4]
 80018c2:	681a      	ldr	r2, [r3, #0]
 80018c4:	9b05      	ldr	r3, [sp, #20]
 80018c6:	685b      	ldr	r3, [r3, #4]
 80018c8:	210f      	movs	r1, #15
 80018ca:	438a      	bics	r2, r1
 80018cc:	601a      	str	r2, [r3, #0]
 80018ce:	9b05      	ldr	r3, [sp, #20]
 80018d0:	7c1b      	ldrb	r3, [r3, #16]
 80018d2:	001a      	movs	r2, r3
 80018d4:	230e      	movs	r3, #14
 80018d6:	4093      	lsls	r3, r2
 80018d8:	001a      	movs	r2, r3
 80018da:	9b05      	ldr	r3, [sp, #20]
 80018dc:	681b      	ldr	r3, [r3, #0]
 80018de:	605a      	str	r2, [r3, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80018e0:	9b05      	ldr	r3, [sp, #20]
 80018e2:	685b      	ldr	r3, [r3, #4]
 80018e4:	2200      	movs	r2, #0
 80018e6:	601a      	str	r2, [r3, #0]

      return dmastp;
 80018e8:	9b05      	ldr	r3, [sp, #20]
 80018ea:	e007      	b.n	80018fc <dmaStreamAllocI+0x10c>
  for (i = startid; i <= endid; i++) {
 80018ec:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80018ee:	3301      	adds	r3, #1
 80018f0:	9309      	str	r3, [sp, #36]	@ 0x24
 80018f2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80018f4:	9b07      	ldr	r3, [sp, #28]
 80018f6:	429a      	cmp	r2, r3
 80018f8:	d992      	bls.n	8001820 <dmaStreamAllocI+0x30>
    }
  }

  return NULL;
 80018fa:	2300      	movs	r3, #0
}
 80018fc:	0018      	movs	r0, r3
 80018fe:	b00b      	add	sp, #44	@ 0x2c
 8001900:	bd00      	pop	{pc}
 8001902:	46c0      	nop			@ (mov r8, r8)
 8001904:	08004f98 	.word	0x08004f98
 8001908:	20000634 	.word	0x20000634
 800190c:	08004f00 	.word	0x08004f00
 8001910:	40021000 	.word	0x40021000
	...

08001920 <dmaServeInterrupt>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
 8001920:	b500      	push	{lr}
 8001922:	b085      	sub	sp, #20
 8001924:	9001      	str	r0, [sp, #4]
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;
 8001926:	9b01      	ldr	r3, [sp, #4]
 8001928:	7c5b      	ldrb	r3, [r3, #17]
 800192a:	9303      	str	r3, [sp, #12]

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 800192c:	9b01      	ldr	r3, [sp, #4]
 800192e:	681b      	ldr	r3, [r3, #0]
 8001930:	681b      	ldr	r3, [r3, #0]
 8001932:	9a01      	ldr	r2, [sp, #4]
 8001934:	7c12      	ldrb	r2, [r2, #16]
 8001936:	40d3      	lsrs	r3, r2
 8001938:	220e      	movs	r2, #14
 800193a:	4013      	ands	r3, r2
 800193c:	9302      	str	r3, [sp, #8]
  if (flags & dmastp->channel->CCR) {
 800193e:	9b01      	ldr	r3, [sp, #4]
 8001940:	685b      	ldr	r3, [r3, #4]
 8001942:	681b      	ldr	r3, [r3, #0]
 8001944:	9a02      	ldr	r2, [sp, #8]
 8001946:	4013      	ands	r3, r2
 8001948:	d01d      	beq.n	8001986 <dmaServeInterrupt+0x66>
    dmastp->dma->IFCR = flags << dmastp->shift;
 800194a:	9b01      	ldr	r3, [sp, #4]
 800194c:	7c1b      	ldrb	r3, [r3, #16]
 800194e:	0019      	movs	r1, r3
 8001950:	9b01      	ldr	r3, [sp, #4]
 8001952:	681b      	ldr	r3, [r3, #0]
 8001954:	9a02      	ldr	r2, [sp, #8]
 8001956:	408a      	lsls	r2, r1
 8001958:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 800195a:	4b0c      	ldr	r3, [pc, #48]	@ (800198c <dmaServeInterrupt+0x6c>)
 800195c:	9a03      	ldr	r2, [sp, #12]
 800195e:	3201      	adds	r2, #1
 8001960:	00d2      	lsls	r2, r2, #3
 8001962:	58d3      	ldr	r3, [r2, r3]
 8001964:	2b00      	cmp	r3, #0
 8001966:	d00e      	beq.n	8001986 <dmaServeInterrupt+0x66>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8001968:	4b08      	ldr	r3, [pc, #32]	@ (800198c <dmaServeInterrupt+0x6c>)
 800196a:	9a03      	ldr	r2, [sp, #12]
 800196c:	3201      	adds	r2, #1
 800196e:	00d2      	lsls	r2, r2, #3
 8001970:	58d2      	ldr	r2, [r2, r3]
 8001972:	4906      	ldr	r1, [pc, #24]	@ (800198c <dmaServeInterrupt+0x6c>)
 8001974:	9b03      	ldr	r3, [sp, #12]
 8001976:	3301      	adds	r3, #1
 8001978:	00db      	lsls	r3, r3, #3
 800197a:	18cb      	adds	r3, r1, r3
 800197c:	3304      	adds	r3, #4
 800197e:	681b      	ldr	r3, [r3, #0]
 8001980:	9902      	ldr	r1, [sp, #8]
 8001982:	0018      	movs	r0, r3
 8001984:	4790      	blx	r2
    }
  }
}
 8001986:	46c0      	nop			@ (mov r8, r8)
 8001988:	b005      	add	sp, #20
 800198a:	bd00      	pop	{pc}
 800198c:	20000634 	.word	0x20000634

08001990 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8001990:	46c0      	nop			@ (mov r8, r8)
 8001992:	4770      	bx	lr
	...

080019a0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80019a0:	b08e      	sub	sp, #56	@ 0x38
 80019a2:	9003      	str	r0, [sp, #12]
 80019a4:	9102      	str	r1, [sp, #8]
 80019a6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80019a8:	9b01      	ldr	r3, [sp, #4]
 80019aa:	2203      	movs	r2, #3
 80019ac:	4013      	ands	r3, r2
 80019ae:	930d      	str	r3, [sp, #52]	@ 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80019b0:	9b01      	ldr	r3, [sp, #4]
 80019b2:	089b      	lsrs	r3, r3, #2
 80019b4:	2201      	movs	r2, #1
 80019b6:	4013      	ands	r3, r2
 80019b8:	930c      	str	r3, [sp, #48]	@ 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80019ba:	9b01      	ldr	r3, [sp, #4]
 80019bc:	08db      	lsrs	r3, r3, #3
 80019be:	2203      	movs	r2, #3
 80019c0:	4013      	ands	r3, r2
 80019c2:	930b      	str	r3, [sp, #44]	@ 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80019c4:	9b01      	ldr	r3, [sp, #4]
 80019c6:	095b      	lsrs	r3, r3, #5
 80019c8:	2203      	movs	r2, #3
 80019ca:	4013      	ands	r3, r2
 80019cc:	930a      	str	r3, [sp, #40]	@ 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80019ce:	9b01      	ldr	r3, [sp, #4]
 80019d0:	09db      	lsrs	r3, r3, #7
 80019d2:	220f      	movs	r2, #15
 80019d4:	4013      	ands	r3, r2
 80019d6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 80019d8:	2300      	movs	r3, #0
 80019da:	9309      	str	r3, [sp, #36]	@ 0x24
  while (true) {
    if ((mask & 1) != 0) {
 80019dc:	9b02      	ldr	r3, [sp, #8]
 80019de:	2201      	movs	r2, #1
 80019e0:	4013      	ands	r3, r2
 80019e2:	d100      	bne.n	80019e6 <_pal_lld_setgroupmode+0x46>
 80019e4:	e079      	b.n	8001ada <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80019e6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80019e8:	2207      	movs	r2, #7
 80019ea:	4013      	ands	r3, r2
 80019ec:	009b      	lsls	r3, r3, #2
 80019ee:	9a08      	ldr	r2, [sp, #32]
 80019f0:	409a      	lsls	r2, r3
 80019f2:	0013      	movs	r3, r2
 80019f4:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 80019f6:	2201      	movs	r2, #1
 80019f8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80019fa:	409a      	lsls	r2, r3
 80019fc:	0013      	movs	r3, r2
 80019fe:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8001a00:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001a02:	005b      	lsls	r3, r3, #1
 8001a04:	2203      	movs	r2, #3
 8001a06:	409a      	lsls	r2, r3
 8001a08:	0013      	movs	r3, r2
 8001a0a:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8001a0c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001a0e:	2207      	movs	r2, #7
 8001a10:	4013      	ands	r3, r2
 8001a12:	009b      	lsls	r3, r3, #2
 8001a14:	220f      	movs	r2, #15
 8001a16:	409a      	lsls	r2, r3
 8001a18:	0013      	movs	r3, r2
 8001a1a:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001a1c:	9b03      	ldr	r3, [sp, #12]
 8001a1e:	685b      	ldr	r3, [r3, #4]
 8001a20:	9a06      	ldr	r2, [sp, #24]
 8001a22:	43d2      	mvns	r2, r2
 8001a24:	401a      	ands	r2, r3
 8001a26:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8001a28:	431a      	orrs	r2, r3
 8001a2a:	9b03      	ldr	r3, [sp, #12]
 8001a2c:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001a2e:	9b03      	ldr	r3, [sp, #12]
 8001a30:	689b      	ldr	r3, [r3, #8]
 8001a32:	9a05      	ldr	r2, [sp, #20]
 8001a34:	43d2      	mvns	r2, r2
 8001a36:	401a      	ands	r2, r3
 8001a38:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8001a3a:	431a      	orrs	r2, r3
 8001a3c:	9b03      	ldr	r3, [sp, #12]
 8001a3e:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001a40:	9b03      	ldr	r3, [sp, #12]
 8001a42:	68db      	ldr	r3, [r3, #12]
 8001a44:	9a05      	ldr	r2, [sp, #20]
 8001a46:	43d2      	mvns	r2, r2
 8001a48:	401a      	ands	r2, r3
 8001a4a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8001a4c:	431a      	orrs	r2, r3
 8001a4e:	9b03      	ldr	r3, [sp, #12]
 8001a50:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001a52:	9b01      	ldr	r3, [sp, #4]
 8001a54:	2203      	movs	r2, #3
 8001a56:	4013      	ands	r3, r2
 8001a58:	2b02      	cmp	r3, #2
 8001a5a:	d11f      	bne.n	8001a9c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8001a5c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001a5e:	2b07      	cmp	r3, #7
 8001a60:	d809      	bhi.n	8001a76 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001a62:	9b03      	ldr	r3, [sp, #12]
 8001a64:	6a1b      	ldr	r3, [r3, #32]
 8001a66:	9a04      	ldr	r2, [sp, #16]
 8001a68:	43d2      	mvns	r2, r2
 8001a6a:	401a      	ands	r2, r3
 8001a6c:	9b07      	ldr	r3, [sp, #28]
 8001a6e:	431a      	orrs	r2, r3
 8001a70:	9b03      	ldr	r3, [sp, #12]
 8001a72:	621a      	str	r2, [r3, #32]
 8001a74:	e008      	b.n	8001a88 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001a76:	9b03      	ldr	r3, [sp, #12]
 8001a78:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001a7a:	9a04      	ldr	r2, [sp, #16]
 8001a7c:	43d2      	mvns	r2, r2
 8001a7e:	401a      	ands	r2, r3
 8001a80:	9b07      	ldr	r3, [sp, #28]
 8001a82:	431a      	orrs	r2, r3
 8001a84:	9b03      	ldr	r3, [sp, #12]
 8001a86:	625a      	str	r2, [r3, #36]	@ 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8001a88:	9b03      	ldr	r3, [sp, #12]
 8001a8a:	681b      	ldr	r3, [r3, #0]
 8001a8c:	9a05      	ldr	r2, [sp, #20]
 8001a8e:	43d2      	mvns	r2, r2
 8001a90:	401a      	ands	r2, r3
 8001a92:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8001a94:	431a      	orrs	r2, r3
 8001a96:	9b03      	ldr	r3, [sp, #12]
 8001a98:	601a      	str	r2, [r3, #0]
 8001a9a:	e01e      	b.n	8001ada <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8001a9c:	9b03      	ldr	r3, [sp, #12]
 8001a9e:	681b      	ldr	r3, [r3, #0]
 8001aa0:	9a05      	ldr	r2, [sp, #20]
 8001aa2:	43d2      	mvns	r2, r2
 8001aa4:	401a      	ands	r2, r3
 8001aa6:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8001aa8:	431a      	orrs	r2, r3
 8001aaa:	9b03      	ldr	r3, [sp, #12]
 8001aac:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8001aae:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001ab0:	2b07      	cmp	r3, #7
 8001ab2:	d809      	bhi.n	8001ac8 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001ab4:	9b03      	ldr	r3, [sp, #12]
 8001ab6:	6a1b      	ldr	r3, [r3, #32]
 8001ab8:	9a04      	ldr	r2, [sp, #16]
 8001aba:	43d2      	mvns	r2, r2
 8001abc:	401a      	ands	r2, r3
 8001abe:	9b07      	ldr	r3, [sp, #28]
 8001ac0:	431a      	orrs	r2, r3
 8001ac2:	9b03      	ldr	r3, [sp, #12]
 8001ac4:	621a      	str	r2, [r3, #32]
 8001ac6:	e008      	b.n	8001ada <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001ac8:	9b03      	ldr	r3, [sp, #12]
 8001aca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001acc:	9a04      	ldr	r2, [sp, #16]
 8001ace:	43d2      	mvns	r2, r2
 8001ad0:	401a      	ands	r2, r3
 8001ad2:	9b07      	ldr	r3, [sp, #28]
 8001ad4:	431a      	orrs	r2, r3
 8001ad6:	9b03      	ldr	r3, [sp, #12]
 8001ad8:	625a      	str	r2, [r3, #36]	@ 0x24
      }
    }
    mask >>= 1;
 8001ada:	9b02      	ldr	r3, [sp, #8]
 8001adc:	085b      	lsrs	r3, r3, #1
 8001ade:	9302      	str	r3, [sp, #8]
    if (!mask)
 8001ae0:	9b02      	ldr	r3, [sp, #8]
 8001ae2:	2b00      	cmp	r3, #0
 8001ae4:	d00f      	beq.n	8001b06 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 8001ae6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8001ae8:	005b      	lsls	r3, r3, #1
 8001aea:	930c      	str	r3, [sp, #48]	@ 0x30
    ospeedr <<= 2;
 8001aec:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8001aee:	009b      	lsls	r3, r3, #2
 8001af0:	930b      	str	r3, [sp, #44]	@ 0x2c
    pupdr <<= 2;
 8001af2:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8001af4:	009b      	lsls	r3, r3, #2
 8001af6:	930a      	str	r3, [sp, #40]	@ 0x28
    moder <<= 2;
 8001af8:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8001afa:	009b      	lsls	r3, r3, #2
 8001afc:	930d      	str	r3, [sp, #52]	@ 0x34
    bit++;
 8001afe:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8001b00:	3301      	adds	r3, #1
 8001b02:	9309      	str	r3, [sp, #36]	@ 0x24
    if ((mask & 1) != 0) {
 8001b04:	e76a      	b.n	80019dc <_pal_lld_setgroupmode+0x3c>
      return;
 8001b06:	46c0      	nop			@ (mov r8, r8)
  }
}
 8001b08:	b00e      	add	sp, #56	@ 0x38
 8001b0a:	4770      	bx	lr
 8001b0c:	0000      	movs	r0, r0
	...

08001b10 <port_lock.lto_priv.6>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001b10:	b672      	cpsid	i
}
 8001b12:	46c0      	nop			@ (mov r8, r8)
}
 8001b14:	46c0      	nop			@ (mov r8, r8)
 8001b16:	4770      	bx	lr
	...

08001b20 <port_unlock.lto_priv.6>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001b20:	b662      	cpsie	i
}
 8001b22:	46c0      	nop			@ (mov r8, r8)
}
 8001b24:	46c0      	nop			@ (mov r8, r8)
 8001b26:	4770      	bx	lr
	...

08001b30 <port_lock_from_isr.lto_priv.1>:
static inline void port_lock_from_isr(void) {
 8001b30:	b510      	push	{r4, lr}
  port_lock();
 8001b32:	f7ff ffed 	bl	8001b10 <port_lock.lto_priv.6>
}
 8001b36:	46c0      	nop			@ (mov r8, r8)
 8001b38:	bd10      	pop	{r4, pc}
 8001b3a:	46c0      	nop			@ (mov r8, r8)
 8001b3c:	0000      	movs	r0, r0
	...

08001b40 <port_unlock_from_isr.lto_priv.1>:
static inline void port_unlock_from_isr(void) {
 8001b40:	b510      	push	{r4, lr}
  port_unlock();
 8001b42:	f7ff ffed 	bl	8001b20 <port_unlock.lto_priv.6>
}
 8001b46:	46c0      	nop			@ (mov r8, r8)
 8001b48:	bd10      	pop	{r4, pc}
 8001b4a:	46c0      	nop			@ (mov r8, r8)
 8001b4c:	0000      	movs	r0, r0
	...

08001b50 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 8001b50:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8001b52:	f7ff ffed 	bl	8001b30 <port_lock_from_isr.lto_priv.1>
  __dbg_check_lock_from_isr();
 8001b56:	f000 fb4b 	bl	80021f0 <__dbg_check_lock_from_isr>
}
 8001b5a:	46c0      	nop			@ (mov r8, r8)
 8001b5c:	bd10      	pop	{r4, pc}
 8001b5e:	46c0      	nop			@ (mov r8, r8)

08001b60 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8001b60:	b510      	push	{r4, lr}
  __dbg_check_unlock_from_isr();
 8001b62:	f000 fb6d 	bl	8002240 <__dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8001b66:	f7ff ffeb 	bl	8001b40 <port_unlock_from_isr.lto_priv.1>
}
 8001b6a:	46c0      	nop			@ (mov r8, r8)
 8001b6c:	bd10      	pop	{r4, pc}
 8001b6e:	46c0      	nop			@ (mov r8, r8)

08001b70 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 8001b70:	b510      	push	{r4, lr}
  chSysLockFromISR();
 8001b72:	f7ff ffed 	bl	8001b50 <chSysLockFromISR.lto_priv.1>
}
 8001b76:	46c0      	nop			@ (mov r8, r8)
 8001b78:	bd10      	pop	{r4, pc}
 8001b7a:	46c0      	nop			@ (mov r8, r8)
 8001b7c:	0000      	movs	r0, r0
	...

08001b80 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 8001b80:	b510      	push	{r4, lr}
  chSysUnlockFromISR();
 8001b82:	f7ff ffed 	bl	8001b60 <chSysUnlockFromISR.lto_priv.1>
}
 8001b86:	46c0      	nop			@ (mov r8, r8)
 8001b88:	bd10      	pop	{r4, pc}
 8001b8a:	46c0      	nop			@ (mov r8, r8)
 8001b8c:	0000      	movs	r0, r0
	...

08001b90 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 8001b90:	b510      	push	{r4, lr}
  chSysTimerHandlerI();
 8001b92:	f000 faa5 	bl	80020e0 <chSysTimerHandlerI>
}
 8001b96:	46c0      	nop			@ (mov r8, r8)
 8001b98:	bd10      	pop	{r4, pc}
 8001b9a:	46c0      	nop			@ (mov r8, r8)
 8001b9c:	0000      	movs	r0, r0
	...

08001ba0 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001ba0:	4b16      	ldr	r3, [pc, #88]	@ (8001bfc <st_lld_init+0x5c>)
 8001ba2:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8001ba4:	4b15      	ldr	r3, [pc, #84]	@ (8001bfc <st_lld_init+0x5c>)
 8001ba6:	2104      	movs	r1, #4
 8001ba8:	430a      	orrs	r2, r1
 8001baa:	635a      	str	r2, [r3, #52]	@ 0x34
 8001bac:	4b13      	ldr	r3, [pc, #76]	@ (8001bfc <st_lld_init+0x5c>)
 8001bae:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8001bb0:	4b12      	ldr	r3, [pc, #72]	@ (8001bfc <st_lld_init+0x5c>)
 8001bb2:	2104      	movs	r1, #4
 8001bb4:	430a      	orrs	r2, r1
 8001bb6:	645a      	str	r2, [r3, #68]	@ 0x44
 8001bb8:	4b10      	ldr	r3, [pc, #64]	@ (8001bfc <st_lld_init+0x5c>)
 8001bba:	6c5b      	ldr	r3, [r3, #68]	@ 0x44

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001bbc:	4b10      	ldr	r3, [pc, #64]	@ (8001c00 <st_lld_init+0x60>)
 8001bbe:	68da      	ldr	r2, [r3, #12]
 8001bc0:	4b0f      	ldr	r3, [pc, #60]	@ (8001c00 <st_lld_init+0x60>)
 8001bc2:	2104      	movs	r1, #4
 8001bc4:	430a      	orrs	r2, r1
 8001bc6:	60da      	str	r2, [r3, #12]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001bc8:	4b0e      	ldr	r3, [pc, #56]	@ (8001c04 <st_lld_init+0x64>)
 8001bca:	4a0f      	ldr	r2, [pc, #60]	@ (8001c08 <st_lld_init+0x68>)
 8001bcc:	629a      	str	r2, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001bce:	4b0d      	ldr	r3, [pc, #52]	@ (8001c04 <st_lld_init+0x64>)
 8001bd0:	4a0e      	ldr	r2, [pc, #56]	@ (8001c0c <st_lld_init+0x6c>)
 8001bd2:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001bd4:	4b0b      	ldr	r3, [pc, #44]	@ (8001c04 <st_lld_init+0x64>)
 8001bd6:	2200      	movs	r2, #0
 8001bd8:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001bda:	4b0a      	ldr	r3, [pc, #40]	@ (8001c04 <st_lld_init+0x64>)
 8001bdc:	2200      	movs	r2, #0
 8001bde:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 8001be0:	4b08      	ldr	r3, [pc, #32]	@ (8001c04 <st_lld_init+0x64>)
 8001be2:	2200      	movs	r2, #0
 8001be4:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001be6:	4b07      	ldr	r3, [pc, #28]	@ (8001c04 <st_lld_init+0x64>)
 8001be8:	2200      	movs	r2, #0
 8001bea:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001bec:	4b05      	ldr	r3, [pc, #20]	@ (8001c04 <st_lld_init+0x64>)
 8001bee:	2201      	movs	r2, #1
 8001bf0:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001bf2:	4b04      	ldr	r3, [pc, #16]	@ (8001c04 <st_lld_init+0x64>)
 8001bf4:	2201      	movs	r2, #1
 8001bf6:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001bf8:	46c0      	nop			@ (mov r8, r8)
 8001bfa:	4770      	bx	lr
 8001bfc:	40021000 	.word	0x40021000
 8001c00:	40015800 	.word	0x40015800
 8001c04:	40010800 	.word	0x40010800
 8001c08:	00007cff 	.word	0x00007cff
 8001c0c:	0000ffff 	.word	0x0000ffff

08001c10 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8001c10:	b500      	push	{lr}
 8001c12:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8001c14:	4b0e      	ldr	r3, [pc, #56]	@ (8001c50 <st_lld_serve_interrupt+0x40>)
 8001c16:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 8001c18:	9b01      	ldr	r3, [sp, #4]
 8001c1a:	691b      	ldr	r3, [r3, #16]
 8001c1c:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001c1e:	9b01      	ldr	r3, [sp, #4]
 8001c20:	68db      	ldr	r3, [r3, #12]
 8001c22:	22ff      	movs	r2, #255	@ 0xff
 8001c24:	401a      	ands	r2, r3
 8001c26:	9b00      	ldr	r3, [sp, #0]
 8001c28:	4013      	ands	r3, r2
 8001c2a:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 8001c2c:	9b00      	ldr	r3, [sp, #0]
 8001c2e:	43da      	mvns	r2, r3
 8001c30:	9b01      	ldr	r3, [sp, #4]
 8001c32:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8001c34:	9b00      	ldr	r3, [sp, #0]
 8001c36:	2202      	movs	r2, #2
 8001c38:	4013      	ands	r3, r2
 8001c3a:	d005      	beq.n	8001c48 <st_lld_serve_interrupt+0x38>
#endif
  {
    osalSysLockFromISR();
 8001c3c:	f7ff ff98 	bl	8001b70 <osalSysLockFromISR.lto_priv.1>
    osalOsTimerHandlerI();
 8001c40:	f7ff ffa6 	bl	8001b90 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8001c44:	f7ff ff9c 	bl	8001b80 <osalSysUnlockFromISR.lto_priv.1>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 8001c48:	46c0      	nop			@ (mov r8, r8)
 8001c4a:	b003      	add	sp, #12
 8001c4c:	bd00      	pop	{pc}
 8001c4e:	46c0      	nop			@ (mov r8, r8)
 8001c50:	40010800 	.word	0x40010800
	...

08001c60 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8001c60:	b510      	push	{r4, lr}
  gptObjectInit(&GPTD5);
#endif

#if STM32_GPT_USE_TIM6
  /* Driver initialization.*/
  GPTD6.tim = STM32_TIM6;
 8001c62:	4b04      	ldr	r3, [pc, #16]	@ (8001c74 <gpt_lld_init+0x14>)
 8001c64:	4a04      	ldr	r2, [pc, #16]	@ (8001c78 <gpt_lld_init+0x18>)
 8001c66:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD6);
 8001c68:	4b02      	ldr	r3, [pc, #8]	@ (8001c74 <gpt_lld_init+0x14>)
 8001c6a:	0018      	movs	r0, r3
 8001c6c:	f7fe fe50 	bl	8000910 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 8001c70:	46c0      	nop			@ (mov r8, r8)
 8001c72:	bd10      	pop	{r4, pc}
 8001c74:	20000674 	.word	0x20000674
 8001c78:	40001000 	.word	0x40001000
 8001c7c:	00000000 	.word	0x00000000

08001c80 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 8001c80:	b500      	push	{lr}
 8001c82:	b085      	sub	sp, #20
 8001c84:	9001      	str	r0, [sp, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 8001c86:	9b01      	ldr	r3, [sp, #4]
 8001c88:	781b      	ldrb	r3, [r3, #0]
 8001c8a:	2b01      	cmp	r3, #1
 8001c8c:	d122      	bne.n	8001cd4 <gpt_lld_start+0x54>
#endif
    }
#endif

#if STM32_GPT_USE_TIM6
    if (&GPTD6 == gptp) {
 8001c8e:	9a01      	ldr	r2, [sp, #4]
 8001c90:	4b32      	ldr	r3, [pc, #200]	@ (8001d5c <gpt_lld_start+0xdc>)
 8001c92:	429a      	cmp	r2, r3
 8001c94:	d11e      	bne.n	8001cd4 <gpt_lld_start+0x54>
      rccEnableTIM6(true);
 8001c96:	4b32      	ldr	r3, [pc, #200]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001c98:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8001c9a:	4b31      	ldr	r3, [pc, #196]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001c9c:	2110      	movs	r1, #16
 8001c9e:	430a      	orrs	r2, r1
 8001ca0:	639a      	str	r2, [r3, #56]	@ 0x38
 8001ca2:	4b2f      	ldr	r3, [pc, #188]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001ca4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8001ca6:	4b2e      	ldr	r3, [pc, #184]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001ca8:	2110      	movs	r1, #16
 8001caa:	430a      	orrs	r2, r1
 8001cac:	649a      	str	r2, [r3, #72]	@ 0x48
 8001cae:	4b2c      	ldr	r3, [pc, #176]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001cb0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
      rccResetTIM6();
 8001cb2:	4b2b      	ldr	r3, [pc, #172]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001cb4:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001cb6:	4b2a      	ldr	r3, [pc, #168]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001cb8:	2110      	movs	r1, #16
 8001cba:	430a      	orrs	r2, r1
 8001cbc:	629a      	str	r2, [r3, #40]	@ 0x28
 8001cbe:	4b28      	ldr	r3, [pc, #160]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001cc0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001cc2:	4b27      	ldr	r3, [pc, #156]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001cc4:	2110      	movs	r1, #16
 8001cc6:	438a      	bics	r2, r1
 8001cc8:	629a      	str	r2, [r3, #40]	@ 0x28
 8001cca:	4b25      	ldr	r3, [pc, #148]	@ (8001d60 <gpt_lld_start+0xe0>)
 8001ccc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
      nvicEnableVector(STM32_TIM6_NUMBER, STM32_GPT_TIM6_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM6CLK)
      gptp->clock = STM32_TIM6CLK;
#else
      gptp->clock = STM32_TIMCLK1;
 8001cce:	9b01      	ldr	r3, [sp, #4]
 8001cd0:	4a24      	ldr	r2, [pc, #144]	@ (8001d64 <gpt_lld_start+0xe4>)
 8001cd2:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8001cd4:	9b01      	ldr	r3, [sp, #4]
 8001cd6:	689a      	ldr	r2, [r3, #8]
 8001cd8:	9b01      	ldr	r3, [sp, #4]
 8001cda:	685b      	ldr	r3, [r3, #4]
 8001cdc:	681b      	ldr	r3, [r3, #0]
 8001cde:	0019      	movs	r1, r3
 8001ce0:	0010      	movs	r0, r2
 8001ce2:	f7fe fa81 	bl	80001e8 <__udivsi3>
 8001ce6:	0003      	movs	r3, r0
 8001ce8:	b29a      	uxth	r2, r3
 8001cea:	230e      	movs	r3, #14
 8001cec:	446b      	add	r3, sp
 8001cee:	3a01      	subs	r2, #1
 8001cf0:	801a      	strh	r2, [r3, #0]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
 8001cf2:	230e      	movs	r3, #14
 8001cf4:	446b      	add	r3, sp
 8001cf6:	881b      	ldrh	r3, [r3, #0]
 8001cf8:	3301      	adds	r3, #1
 8001cfa:	001a      	movs	r2, r3
 8001cfc:	9b01      	ldr	r3, [sp, #4]
 8001cfe:	685b      	ldr	r3, [r3, #4]
 8001d00:	681b      	ldr	r3, [r3, #0]
 8001d02:	435a      	muls	r2, r3
 8001d04:	9b01      	ldr	r3, [sp, #4]
 8001d06:	689b      	ldr	r3, [r3, #8]
 8001d08:	1ad3      	subs	r3, r2, r3
 8001d0a:	1e5a      	subs	r2, r3, #1
 8001d0c:	4193      	sbcs	r3, r2
 8001d0e:	b2db      	uxtb	r3, r3
 8001d10:	2b00      	cmp	r3, #0
 8001d12:	d003      	beq.n	8001d1c <gpt_lld_start+0x9c>
 8001d14:	4b14      	ldr	r3, [pc, #80]	@ (8001d68 <gpt_lld_start+0xe8>)
 8001d16:	0018      	movs	r0, r3
 8001d18:	f000 f9aa 	bl	8002070 <chSysHalt>
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0U;                         /* Initially stopped.       */
 8001d1c:	9b01      	ldr	r3, [sp, #4]
 8001d1e:	68db      	ldr	r3, [r3, #12]
 8001d20:	2200      	movs	r2, #0
 8001d22:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 8001d24:	9b01      	ldr	r3, [sp, #4]
 8001d26:	685a      	ldr	r2, [r3, #4]
 8001d28:	9b01      	ldr	r3, [sp, #4]
 8001d2a:	68db      	ldr	r3, [r3, #12]
 8001d2c:	6892      	ldr	r2, [r2, #8]
 8001d2e:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8001d30:	9b01      	ldr	r3, [sp, #4]
 8001d32:	68db      	ldr	r3, [r3, #12]
 8001d34:	220e      	movs	r2, #14
 8001d36:	446a      	add	r2, sp
 8001d38:	8812      	ldrh	r2, [r2, #0]
 8001d3a:	629a      	str	r2, [r3, #40]	@ 0x28
  gptp->tim->SR   = 0U;                         /* Clear pending IRQs.      */
 8001d3c:	9b01      	ldr	r3, [sp, #4]
 8001d3e:	68db      	ldr	r3, [r3, #12]
 8001d40:	2200      	movs	r2, #0
 8001d42:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 8001d44:	9b01      	ldr	r3, [sp, #4]
 8001d46:	685b      	ldr	r3, [r3, #4]
 8001d48:	68da      	ldr	r2, [r3, #12]
 8001d4a:	9b01      	ldr	r3, [sp, #4]
 8001d4c:	68db      	ldr	r3, [r3, #12]
 8001d4e:	21ff      	movs	r1, #255	@ 0xff
 8001d50:	438a      	bics	r2, r1
 8001d52:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 8001d54:	46c0      	nop			@ (mov r8, r8)
 8001d56:	b005      	add	sp, #20
 8001d58:	bd00      	pop	{pc}
 8001d5a:	46c0      	nop			@ (mov r8, r8)
 8001d5c:	20000674 	.word	0x20000674
 8001d60:	40021000 	.word	0x40021000
 8001d64:	01e84800 	.word	0x01e84800
 8001d68:	08004fa8 	.word	0x08004fa8
 8001d6c:	00000000 	.word	0x00000000

08001d70 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 8001d70:	b082      	sub	sp, #8
 8001d72:	9001      	str	r0, [sp, #4]
 8001d74:	9100      	str	r1, [sp, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 8001d76:	9b01      	ldr	r3, [sp, #4]
 8001d78:	68db      	ldr	r3, [r3, #12]
 8001d7a:	9a00      	ldr	r2, [sp, #0]
 8001d7c:	3a01      	subs	r2, #1
 8001d7e:	62da      	str	r2, [r3, #44]	@ 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 8001d80:	9b01      	ldr	r3, [sp, #4]
 8001d82:	68db      	ldr	r3, [r3, #12]
 8001d84:	2201      	movs	r2, #1
 8001d86:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0U;                          /* Reset counter.           */
 8001d88:	9b01      	ldr	r3, [sp, #4]
 8001d8a:	68db      	ldr	r3, [r3, #12]
 8001d8c:	2200      	movs	r2, #0
 8001d8e:	625a      	str	r2, [r3, #36]	@ 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8001d90:	9b01      	ldr	r3, [sp, #4]
 8001d92:	68db      	ldr	r3, [r3, #12]
 8001d94:	2200      	movs	r2, #0
 8001d96:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8001d98:	9b01      	ldr	r3, [sp, #4]
 8001d9a:	685b      	ldr	r3, [r3, #4]
 8001d9c:	685b      	ldr	r3, [r3, #4]
 8001d9e:	2b00      	cmp	r3, #0
 8001da0:	d007      	beq.n	8001db2 <gpt_lld_start_timer+0x42>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8001da2:	9b01      	ldr	r3, [sp, #4]
 8001da4:	68db      	ldr	r3, [r3, #12]
 8001da6:	68da      	ldr	r2, [r3, #12]
 8001da8:	9b01      	ldr	r3, [sp, #4]
 8001daa:	68db      	ldr	r3, [r3, #12]
 8001dac:	2101      	movs	r1, #1
 8001dae:	430a      	orrs	r2, r1
 8001db0:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8001db2:	9b01      	ldr	r3, [sp, #4]
 8001db4:	68db      	ldr	r3, [r3, #12]
 8001db6:	2285      	movs	r2, #133	@ 0x85
 8001db8:	601a      	str	r2, [r3, #0]
}
 8001dba:	46c0      	nop			@ (mov r8, r8)
 8001dbc:	b002      	add	sp, #8
 8001dbe:	4770      	bx	lr

08001dc0 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 8001dc0:	b082      	sub	sp, #8
 8001dc2:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1 = 0U;                          /* Initially stopped.       */
 8001dc4:	9b01      	ldr	r3, [sp, #4]
 8001dc6:	68db      	ldr	r3, [r3, #12]
 8001dc8:	2200      	movs	r2, #0
 8001dca:	601a      	str	r2, [r3, #0]
  gptp->tim->SR  = 0U;                          /* Clear pending IRQs.      */
 8001dcc:	9b01      	ldr	r3, [sp, #4]
 8001dce:	68db      	ldr	r3, [r3, #12]
 8001dd0:	2200      	movs	r2, #0
 8001dd2:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	68db      	ldr	r3, [r3, #12]
 8001dd8:	68da      	ldr	r2, [r3, #12]
 8001dda:	9b01      	ldr	r3, [sp, #4]
 8001ddc:	68db      	ldr	r3, [r3, #12]
 8001dde:	21ff      	movs	r1, #255	@ 0xff
 8001de0:	438a      	bics	r2, r1
 8001de2:	60da      	str	r2, [r3, #12]
}
 8001de4:	46c0      	nop			@ (mov r8, r8)
 8001de6:	b002      	add	sp, #8
 8001de8:	4770      	bx	lr
 8001dea:	46c0      	nop			@ (mov r8, r8)
 8001dec:	0000      	movs	r0, r0
	...

08001df0 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 8001df0:	b500      	push	{lr}
 8001df2:	b085      	sub	sp, #20
 8001df4:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 8001df6:	9b01      	ldr	r3, [sp, #4]
 8001df8:	68db      	ldr	r3, [r3, #12]
 8001dfa:	691b      	ldr	r3, [r3, #16]
 8001dfc:	9303      	str	r3, [sp, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001dfe:	9b01      	ldr	r3, [sp, #4]
 8001e00:	68db      	ldr	r3, [r3, #12]
 8001e02:	68db      	ldr	r3, [r3, #12]
 8001e04:	22ff      	movs	r2, #255	@ 0xff
 8001e06:	401a      	ands	r2, r3
 8001e08:	9b03      	ldr	r3, [sp, #12]
 8001e0a:	4013      	ands	r3, r2
 8001e0c:	9303      	str	r3, [sp, #12]
  gptp->tim->SR = ~sr;
 8001e0e:	9b01      	ldr	r3, [sp, #4]
 8001e10:	68db      	ldr	r3, [r3, #12]
 8001e12:	9a03      	ldr	r2, [sp, #12]
 8001e14:	43d2      	mvns	r2, r2
 8001e16:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8001e18:	9b03      	ldr	r3, [sp, #12]
 8001e1a:	2201      	movs	r2, #1
 8001e1c:	4013      	ands	r3, r2
 8001e1e:	d015      	beq.n	8001e4c <gpt_lld_serve_interrupt+0x5c>
    _gpt_isr_invoke_cb(gptp);
 8001e20:	9b01      	ldr	r3, [sp, #4]
 8001e22:	781b      	ldrb	r3, [r3, #0]
 8001e24:	2b04      	cmp	r3, #4
 8001e26:	d106      	bne.n	8001e36 <gpt_lld_serve_interrupt+0x46>
 8001e28:	9b01      	ldr	r3, [sp, #4]
 8001e2a:	2202      	movs	r2, #2
 8001e2c:	701a      	strb	r2, [r3, #0]
 8001e2e:	9b01      	ldr	r3, [sp, #4]
 8001e30:	0018      	movs	r0, r3
 8001e32:	f7ff ffc5 	bl	8001dc0 <gpt_lld_stop_timer>
 8001e36:	9b01      	ldr	r3, [sp, #4]
 8001e38:	685b      	ldr	r3, [r3, #4]
 8001e3a:	685b      	ldr	r3, [r3, #4]
 8001e3c:	2b00      	cmp	r3, #0
 8001e3e:	d005      	beq.n	8001e4c <gpt_lld_serve_interrupt+0x5c>
 8001e40:	9b01      	ldr	r3, [sp, #4]
 8001e42:	685b      	ldr	r3, [r3, #4]
 8001e44:	685b      	ldr	r3, [r3, #4]
 8001e46:	9a01      	ldr	r2, [sp, #4]
 8001e48:	0010      	movs	r0, r2
 8001e4a:	4798      	blx	r3
  }
}
 8001e4c:	46c0      	nop			@ (mov r8, r8)
 8001e4e:	b005      	add	sp, #20
 8001e50:	bd00      	pop	{pc}
 8001e52:	46c0      	nop			@ (mov r8, r8)
	...

08001e60 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8001e60:	b082      	sub	sp, #8
 8001e62:	9001      	str	r0, [sp, #4]
 8001e64:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8001e66:	9b00      	ldr	r3, [sp, #0]
 8001e68:	685a      	ldr	r2, [r3, #4]
 8001e6a:	9b01      	ldr	r3, [sp, #4]
 8001e6c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e6e:	9b00      	ldr	r3, [sp, #0]
 8001e70:	689a      	ldr	r2, [r3, #8]
 8001e72:	9b01      	ldr	r3, [sp, #4]
 8001e74:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e76:	9b00      	ldr	r3, [sp, #0]
 8001e78:	68da      	ldr	r2, [r3, #12]
 8001e7a:	9b01      	ldr	r3, [sp, #4]
 8001e7c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8001e7e:	9b00      	ldr	r3, [sp, #0]
 8001e80:	691a      	ldr	r2, [r3, #16]
 8001e82:	9b01      	ldr	r3, [sp, #4]
 8001e84:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001e86:	9b00      	ldr	r3, [sp, #0]
 8001e88:	695a      	ldr	r2, [r3, #20]
 8001e8a:	9b01      	ldr	r3, [sp, #4]
 8001e8c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8001e8e:	9b00      	ldr	r3, [sp, #0]
 8001e90:	699a      	ldr	r2, [r3, #24]
 8001e92:	9b01      	ldr	r3, [sp, #4]
 8001e94:	625a      	str	r2, [r3, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8001e96:	9b00      	ldr	r3, [sp, #0]
 8001e98:	681a      	ldr	r2, [r3, #0]
 8001e9a:	9b01      	ldr	r3, [sp, #4]
 8001e9c:	601a      	str	r2, [r3, #0]
}
 8001e9e:	46c0      	nop			@ (mov r8, r8)
 8001ea0:	b002      	add	sp, #8
 8001ea2:	4770      	bx	lr
	...

08001eb0 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8001eb0:	b510      	push	{r4, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetIOP(STM32_GPIO_EN_MASK);
 8001eb2:	4b1e      	ldr	r3, [pc, #120]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001eb4:	69da      	ldr	r2, [r3, #28]
 8001eb6:	4b1d      	ldr	r3, [pc, #116]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001eb8:	218f      	movs	r1, #143	@ 0x8f
 8001eba:	430a      	orrs	r2, r1
 8001ebc:	61da      	str	r2, [r3, #28]
 8001ebe:	4b1b      	ldr	r3, [pc, #108]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001ec0:	69da      	ldr	r2, [r3, #28]
 8001ec2:	4b1a      	ldr	r3, [pc, #104]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001ec4:	218f      	movs	r1, #143	@ 0x8f
 8001ec6:	438a      	bics	r2, r1
 8001ec8:	61da      	str	r2, [r3, #28]
 8001eca:	4b18      	ldr	r3, [pc, #96]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001ecc:	69db      	ldr	r3, [r3, #28]
  rccEnableIOP(STM32_GPIO_EN_MASK, true);
 8001ece:	4b17      	ldr	r3, [pc, #92]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001ed0:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8001ed2:	4b16      	ldr	r3, [pc, #88]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001ed4:	218f      	movs	r1, #143	@ 0x8f
 8001ed6:	430a      	orrs	r2, r1
 8001ed8:	62da      	str	r2, [r3, #44]	@ 0x2c
 8001eda:	4b14      	ldr	r3, [pc, #80]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001edc:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8001ede:	4b13      	ldr	r3, [pc, #76]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001ee0:	218f      	movs	r1, #143	@ 0x8f
 8001ee2:	430a      	orrs	r2, r1
 8001ee4:	63da      	str	r2, [r3, #60]	@ 0x3c
 8001ee6:	4b11      	ldr	r3, [pc, #68]	@ (8001f2c <stm32_gpio_init+0x7c>)
 8001ee8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 8001eea:	4a11      	ldr	r2, [pc, #68]	@ (8001f30 <stm32_gpio_init+0x80>)
 8001eec:	23a0      	movs	r3, #160	@ 0xa0
 8001eee:	05db      	lsls	r3, r3, #23
 8001ef0:	0011      	movs	r1, r2
 8001ef2:	0018      	movs	r0, r3
 8001ef4:	f7ff ffb4 	bl	8001e60 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8001ef8:	4b0e      	ldr	r3, [pc, #56]	@ (8001f34 <stm32_gpio_init+0x84>)
 8001efa:	4a0f      	ldr	r2, [pc, #60]	@ (8001f38 <stm32_gpio_init+0x88>)
 8001efc:	0019      	movs	r1, r3
 8001efe:	0010      	movs	r0, r2
 8001f00:	f7ff ffae 	bl	8001e60 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 8001f04:	4b0d      	ldr	r3, [pc, #52]	@ (8001f3c <stm32_gpio_init+0x8c>)
 8001f06:	4a0e      	ldr	r2, [pc, #56]	@ (8001f40 <stm32_gpio_init+0x90>)
 8001f08:	0019      	movs	r1, r3
 8001f0a:	0010      	movs	r0, r2
 8001f0c:	f7ff ffa8 	bl	8001e60 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8001f10:	4b0c      	ldr	r3, [pc, #48]	@ (8001f44 <stm32_gpio_init+0x94>)
 8001f12:	4a0d      	ldr	r2, [pc, #52]	@ (8001f48 <stm32_gpio_init+0x98>)
 8001f14:	0019      	movs	r1, r3
 8001f16:	0010      	movs	r0, r2
 8001f18:	f7ff ffa2 	bl	8001e60 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8001f1c:	4b0b      	ldr	r3, [pc, #44]	@ (8001f4c <stm32_gpio_init+0x9c>)
 8001f1e:	4a0c      	ldr	r2, [pc, #48]	@ (8001f50 <stm32_gpio_init+0xa0>)
 8001f20:	0019      	movs	r1, r3
 8001f22:	0010      	movs	r0, r2
 8001f24:	f7ff ff9c 	bl	8001e60 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8001f28:	46c0      	nop			@ (mov r8, r8)
 8001f2a:	bd10      	pop	{r4, pc}
 8001f2c:	40021000 	.word	0x40021000
 8001f30:	08004fb8 	.word	0x08004fb8
 8001f34:	08004fd4 	.word	0x08004fd4
 8001f38:	50000400 	.word	0x50000400
 8001f3c:	08004ff0 	.word	0x08004ff0
 8001f40:	50000800 	.word	0x50000800
 8001f44:	0800500c 	.word	0x0800500c
 8001f48:	50000c00 	.word	0x50000c00
 8001f4c:	08005028 	.word	0x08005028
 8001f50:	50001c00 	.word	0x50001c00
	...

08001f60 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8001f60:	b510      	push	{r4, lr}

  stm32_gpio_init();
 8001f62:	f7ff ffa5 	bl	8001eb0 <stm32_gpio_init>
  stm32_clock_init();
 8001f66:	f7fe ffc3 	bl	8000ef0 <stm32_clock_init>
}
 8001f6a:	46c0      	nop			@ (mov r8, r8)
 8001f6c:	bd10      	pop	{r4, pc}
 8001f6e:	46c0      	nop			@ (mov r8, r8)

08001f70 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 8001f70:	46c0      	nop			@ (mov r8, r8)
 8001f72:	4770      	bx	lr
	...

08001f80 <port_unlock.lto_priv.7>:
  __ASM volatile ("cpsie i" : : : "memory");
 8001f80:	b662      	cpsie	i
}
 8001f82:	46c0      	nop			@ (mov r8, r8)
}
 8001f84:	46c0      	nop			@ (mov r8, r8)
 8001f86:	4770      	bx	lr
	...

08001f90 <port_disable>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001f90:	b672      	cpsid	i
}
 8001f92:	46c0      	nop			@ (mov r8, r8)
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8001f94:	46c0      	nop			@ (mov r8, r8)
 8001f96:	4770      	bx	lr
	...

08001fa0 <chSysUnlock.lto_priv.5>:
static inline void chSysUnlock(void) {
 8001fa0:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8001fa2:	f000 f8fd 	bl	80021a0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8001fa6:	4b0e      	ldr	r3, [pc, #56]	@ (8001fe0 <chSysUnlock.lto_priv.5+0x40>)
 8001fa8:	681a      	ldr	r2, [r3, #0]
 8001faa:	4b0d      	ldr	r3, [pc, #52]	@ (8001fe0 <chSysUnlock.lto_priv.5+0x40>)
 8001fac:	1ad3      	subs	r3, r2, r3
 8001fae:	1e5a      	subs	r2, r3, #1
 8001fb0:	4193      	sbcs	r3, r2
 8001fb2:	b2db      	uxtb	r3, r3
 8001fb4:	2b00      	cmp	r3, #0
 8001fb6:	d00f      	beq.n	8001fd8 <chSysUnlock.lto_priv.5+0x38>
 8001fb8:	4b09      	ldr	r3, [pc, #36]	@ (8001fe0 <chSysUnlock.lto_priv.5+0x40>)
 8001fba:	68db      	ldr	r3, [r3, #12]
 8001fbc:	689a      	ldr	r2, [r3, #8]
 8001fbe:	4b08      	ldr	r3, [pc, #32]	@ (8001fe0 <chSysUnlock.lto_priv.5+0x40>)
 8001fc0:	681b      	ldr	r3, [r3, #0]
 8001fc2:	689b      	ldr	r3, [r3, #8]
 8001fc4:	429a      	cmp	r2, r3
 8001fc6:	419b      	sbcs	r3, r3
 8001fc8:	425b      	negs	r3, r3
 8001fca:	b2db      	uxtb	r3, r3
 8001fcc:	2b00      	cmp	r3, #0
 8001fce:	d003      	beq.n	8001fd8 <chSysUnlock.lto_priv.5+0x38>
 8001fd0:	4b04      	ldr	r3, [pc, #16]	@ (8001fe4 <chSysUnlock.lto_priv.5+0x44>)
 8001fd2:	0018      	movs	r0, r3
 8001fd4:	f000 f84c 	bl	8002070 <chSysHalt>
  port_unlock();
 8001fd8:	f7ff ffd2 	bl	8001f80 <port_unlock.lto_priv.7>
}
 8001fdc:	46c0      	nop			@ (mov r8, r8)
 8001fde:	bd10      	pop	{r4, pc}
 8001fe0:	20000690 	.word	0x20000690
 8001fe4:	080050d0 	.word	0x080050d0
	...

08001ff0 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 8001ff0:	b510      	push	{r4, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 8001ff2:	f002 fa9d 	bl	8004530 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8001ff6:	f002 fb03 	bl	8004600 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 8001ffa:	f002 fcb9 	bl	8004970 <__factory_init>
#endif
}
 8001ffe:	46c0      	nop			@ (mov r8, r8)
 8002000:	bd10      	pop	{r4, pc}
 8002002:	46c0      	nop			@ (mov r8, r8)
	...

08002010 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 8002010:	b500      	push	{lr}
 8002012:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8002014:	4b11      	ldr	r3, [pc, #68]	@ (800205c <chSysInit+0x4c>)
 8002016:	2201      	movs	r2, #1
 8002018:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 800201a:	2300      	movs	r3, #0
 800201c:	9301      	str	r3, [sp, #4]
 800201e:	e009      	b.n	8002034 <chSysInit+0x24>
    ch_system.instances[i] = NULL;
 8002020:	4a0e      	ldr	r2, [pc, #56]	@ (800205c <chSysInit+0x4c>)
 8002022:	9b01      	ldr	r3, [sp, #4]
 8002024:	009b      	lsls	r3, r3, #2
 8002026:	18d3      	adds	r3, r2, r3
 8002028:	3304      	adds	r3, #4
 800202a:	2200      	movs	r2, #0
 800202c:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 800202e:	9b01      	ldr	r3, [sp, #4]
 8002030:	3301      	adds	r3, #1
 8002032:	9301      	str	r3, [sp, #4]
 8002034:	9b01      	ldr	r3, [sp, #4]
 8002036:	2b00      	cmp	r3, #0
 8002038:	d0f2      	beq.n	8002020 <chSysInit+0x10>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 800203a:	f7ff ffd9 	bl	8001ff0 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 800203e:	4a08      	ldr	r2, [pc, #32]	@ (8002060 <chSysInit+0x50>)
 8002040:	4b08      	ldr	r3, [pc, #32]	@ (8002064 <chSysInit+0x54>)
 8002042:	0011      	movs	r1, r2
 8002044:	0018      	movs	r0, r3
 8002046:	f001 fb43 	bl	80036d0 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 800204a:	4b04      	ldr	r3, [pc, #16]	@ (800205c <chSysInit+0x4c>)
 800204c:	2202      	movs	r2, #2
 800204e:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 8002050:	f7ff ffa6 	bl	8001fa0 <chSysUnlock.lto_priv.5>
}
 8002054:	46c0      	nop			@ (mov r8, r8)
 8002056:	b003      	add	sp, #12
 8002058:	bd00      	pop	{pc}
 800205a:	46c0      	nop			@ (mov r8, r8)
 800205c:	20000684 	.word	0x20000684
 8002060:	080050bc 	.word	0x080050bc
 8002064:	20000690 	.word	0x20000690
	...

08002070 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002070:	b500      	push	{lr}
 8002072:	b083      	sub	sp, #12
 8002074:	9001      	str	r0, [sp, #4]

  port_disable();
 8002076:	f7ff ff8b 	bl	8001f90 <port_disable>

  /* Logging the event.*/
  __trace_halt(reason);
 800207a:	9b01      	ldr	r3, [sp, #4]
 800207c:	0018      	movs	r0, r3
 800207e:	f000 fb0f 	bl	80026a0 <__trace_halt>

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 8002082:	4b04      	ldr	r3, [pc, #16]	@ (8002094 <chSysHalt+0x24>)
 8002084:	2184      	movs	r1, #132	@ 0x84
 8002086:	9a01      	ldr	r2, [sp, #4]
 8002088:	505a      	str	r2, [r3, r1]
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 800208a:	4b03      	ldr	r3, [pc, #12]	@ (8002098 <chSysHalt+0x28>)
 800208c:	2203      	movs	r2, #3
 800208e:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
     asm volatile ("nop");
 8002090:	46c0      	nop			@ (mov r8, r8)
 8002092:	e7fd      	b.n	8002090 <chSysHalt+0x20>
 8002094:	20000690 	.word	0x20000690
 8002098:	20000684 	.word	0x20000684
 800209c:	00000000 	.word	0x00000000

080020a0 <chSysGetIdleThreadX>:
 *
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
 80020a0:	b500      	push	{lr}
 80020a2:	b083      	sub	sp, #12
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 80020a4:	4b09      	ldr	r3, [pc, #36]	@ (80020cc <chSysGetIdleThreadX+0x2c>)
 80020a6:	685b      	ldr	r3, [r3, #4]
 80020a8:	9301      	str	r3, [sp, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 80020aa:	9b01      	ldr	r3, [sp, #4]
 80020ac:	689b      	ldr	r3, [r3, #8]
 80020ae:	3b01      	subs	r3, #1
 80020b0:	1e5a      	subs	r2, r3, #1
 80020b2:	4193      	sbcs	r3, r2
 80020b4:	b2db      	uxtb	r3, r3
 80020b6:	2b00      	cmp	r3, #0
 80020b8:	d003      	beq.n	80020c2 <chSysGetIdleThreadX+0x22>
 80020ba:	4b05      	ldr	r3, [pc, #20]	@ (80020d0 <chSysGetIdleThreadX+0x30>)
 80020bc:	0018      	movs	r0, r3
 80020be:	f7ff ffd7 	bl	8002070 <chSysHalt>

  return tp;
 80020c2:	9b01      	ldr	r3, [sp, #4]
}
 80020c4:	0018      	movs	r0, r3
 80020c6:	b003      	add	sp, #12
 80020c8:	bd00      	pop	{pc}
 80020ca:	46c0      	nop			@ (mov r8, r8)
 80020cc:	20000690 	.word	0x20000690
 80020d0:	080050dc 	.word	0x080050dc
	...

080020e0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80020e0:	b510      	push	{r4, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 80020e2:	f000 f935 	bl	8002350 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 80020e6:	f000 fe5b 	bl	8002da0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 80020ea:	46c0      	nop			@ (mov r8, r8)
 80020ec:	bd10      	pop	{r4, pc}
 80020ee:	46c0      	nop			@ (mov r8, r8)

080020f0 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 80020f0:	b082      	sub	sp, #8
 80020f2:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 80020f4:	4b04      	ldr	r3, [pc, #16]	@ (8002108 <chRFCUCollectFaultsI+0x18>)
 80020f6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80020f8:	9b01      	ldr	r3, [sp, #4]
 80020fa:	431a      	orrs	r2, r3
 80020fc:	4b02      	ldr	r3, [pc, #8]	@ (8002108 <chRFCUCollectFaultsI+0x18>)
 80020fe:	635a      	str	r2, [r3, #52]	@ 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8002100:	46c0      	nop			@ (mov r8, r8)
 8002102:	b002      	add	sp, #8
 8002104:	4770      	bx	lr
 8002106:	46c0      	nop			@ (mov r8, r8)
 8002108:	20000690 	.word	0x20000690
 800210c:	00000000 	.word	0x00000000

08002110 <port_lock.lto_priv.8>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002110:	b672      	cpsid	i
}
 8002112:	46c0      	nop			@ (mov r8, r8)
}
 8002114:	46c0      	nop			@ (mov r8, r8)
 8002116:	4770      	bx	lr
	...

08002120 <port_unlock.lto_priv.8>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002120:	b662      	cpsie	i
}
 8002122:	46c0      	nop			@ (mov r8, r8)
}
 8002124:	46c0      	nop			@ (mov r8, r8)
 8002126:	4770      	bx	lr
	...

08002130 <port_lock_from_isr.lto_priv.3>:
static inline void port_lock_from_isr(void) {
 8002130:	b510      	push	{r4, lr}
  port_lock();
 8002132:	f7ff ffed 	bl	8002110 <port_lock.lto_priv.8>
}
 8002136:	46c0      	nop			@ (mov r8, r8)
 8002138:	bd10      	pop	{r4, pc}
 800213a:	46c0      	nop			@ (mov r8, r8)
 800213c:	0000      	movs	r0, r0
	...

08002140 <port_unlock_from_isr.lto_priv.3>:
static inline void port_unlock_from_isr(void) {
 8002140:	b510      	push	{r4, lr}
  port_unlock();
 8002142:	f7ff ffed 	bl	8002120 <port_unlock.lto_priv.8>
}
 8002146:	46c0      	nop			@ (mov r8, r8)
 8002148:	bd10      	pop	{r4, pc}
 800214a:	46c0      	nop			@ (mov r8, r8)
 800214c:	0000      	movs	r0, r0
	...

08002150 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 8002150:	b500      	push	{lr}
 8002152:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002154:	4b0e      	ldr	r3, [pc, #56]	@ (8002190 <__dbg_check_lock+0x40>)
 8002156:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002158:	9b01      	ldr	r3, [sp, #4]
 800215a:	2288      	movs	r2, #136	@ 0x88
 800215c:	589b      	ldr	r3, [r3, r2]
 800215e:	1e5a      	subs	r2, r3, #1
 8002160:	4193      	sbcs	r3, r2
 8002162:	b2db      	uxtb	r3, r3
 8002164:	2b00      	cmp	r3, #0
 8002166:	d107      	bne.n	8002178 <__dbg_check_lock+0x28>
 8002168:	9b01      	ldr	r3, [sp, #4]
 800216a:	228c      	movs	r2, #140	@ 0x8c
 800216c:	589b      	ldr	r3, [r3, r2]
 800216e:	1e5a      	subs	r2, r3, #1
 8002170:	4193      	sbcs	r3, r2
 8002172:	b2db      	uxtb	r3, r3
 8002174:	2b00      	cmp	r3, #0
 8002176:	d003      	beq.n	8002180 <__dbg_check_lock+0x30>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 8002178:	4b06      	ldr	r3, [pc, #24]	@ (8002194 <__dbg_check_lock+0x44>)
 800217a:	0018      	movs	r0, r3
 800217c:	f7ff ff78 	bl	8002070 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002180:	9b01      	ldr	r3, [sp, #4]
 8002182:	228c      	movs	r2, #140	@ 0x8c
 8002184:	2101      	movs	r1, #1
 8002186:	5099      	str	r1, [r3, r2]
}
 8002188:	46c0      	nop			@ (mov r8, r8)
 800218a:	b003      	add	sp, #12
 800218c:	bd00      	pop	{pc}
 800218e:	46c0      	nop			@ (mov r8, r8)
 8002190:	20000690 	.word	0x20000690
 8002194:	08005048 	.word	0x08005048
	...

080021a0 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 80021a0:	b500      	push	{lr}
 80021a2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80021a4:	4b0e      	ldr	r3, [pc, #56]	@ (80021e0 <__dbg_check_unlock+0x40>)
 80021a6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80021a8:	9b01      	ldr	r3, [sp, #4]
 80021aa:	2288      	movs	r2, #136	@ 0x88
 80021ac:	589b      	ldr	r3, [r3, r2]
 80021ae:	1e5a      	subs	r2, r3, #1
 80021b0:	4193      	sbcs	r3, r2
 80021b2:	b2db      	uxtb	r3, r3
 80021b4:	2b00      	cmp	r3, #0
 80021b6:	d108      	bne.n	80021ca <__dbg_check_unlock+0x2a>
 80021b8:	9b01      	ldr	r3, [sp, #4]
 80021ba:	228c      	movs	r2, #140	@ 0x8c
 80021bc:	589b      	ldr	r3, [r3, r2]
 80021be:	1e5a      	subs	r2, r3, #1
 80021c0:	4313      	orrs	r3, r2
 80021c2:	0fdb      	lsrs	r3, r3, #31
 80021c4:	b2db      	uxtb	r3, r3
 80021c6:	2b00      	cmp	r3, #0
 80021c8:	d003      	beq.n	80021d2 <__dbg_check_unlock+0x32>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 80021ca:	4b06      	ldr	r3, [pc, #24]	@ (80021e4 <__dbg_check_unlock+0x44>)
 80021cc:	0018      	movs	r0, r3
 80021ce:	f7ff ff4f 	bl	8002070 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 80021d2:	9b01      	ldr	r3, [sp, #4]
 80021d4:	228c      	movs	r2, #140	@ 0x8c
 80021d6:	2100      	movs	r1, #0
 80021d8:	5099      	str	r1, [r3, r2]
}
 80021da:	46c0      	nop			@ (mov r8, r8)
 80021dc:	b003      	add	sp, #12
 80021de:	bd00      	pop	{pc}
 80021e0:	20000690 	.word	0x20000690
 80021e4:	08005050 	.word	0x08005050
	...

080021f0 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 80021f0:	b500      	push	{lr}
 80021f2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80021f4:	4b0e      	ldr	r3, [pc, #56]	@ (8002230 <__dbg_check_lock_from_isr+0x40>)
 80021f6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	2288      	movs	r2, #136	@ 0x88
 80021fc:	589b      	ldr	r3, [r3, r2]
 80021fe:	1e5a      	subs	r2, r3, #1
 8002200:	4313      	orrs	r3, r2
 8002202:	0fdb      	lsrs	r3, r3, #31
 8002204:	b2db      	uxtb	r3, r3
 8002206:	2b00      	cmp	r3, #0
 8002208:	d107      	bne.n	800221a <__dbg_check_lock_from_isr+0x2a>
 800220a:	9b01      	ldr	r3, [sp, #4]
 800220c:	228c      	movs	r2, #140	@ 0x8c
 800220e:	589b      	ldr	r3, [r3, r2]
 8002210:	1e5a      	subs	r2, r3, #1
 8002212:	4193      	sbcs	r3, r2
 8002214:	b2db      	uxtb	r3, r3
 8002216:	2b00      	cmp	r3, #0
 8002218:	d003      	beq.n	8002222 <__dbg_check_lock_from_isr+0x32>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 800221a:	4b06      	ldr	r3, [pc, #24]	@ (8002234 <__dbg_check_lock_from_isr+0x44>)
 800221c:	0018      	movs	r0, r3
 800221e:	f7ff ff27 	bl	8002070 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002222:	9b01      	ldr	r3, [sp, #4]
 8002224:	228c      	movs	r2, #140	@ 0x8c
 8002226:	2101      	movs	r1, #1
 8002228:	5099      	str	r1, [r3, r2]
}
 800222a:	46c0      	nop			@ (mov r8, r8)
 800222c:	b003      	add	sp, #12
 800222e:	bd00      	pop	{pc}
 8002230:	20000690 	.word	0x20000690
 8002234:	08005058 	.word	0x08005058
	...

08002240 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 8002240:	b500      	push	{lr}
 8002242:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002244:	4b0f      	ldr	r3, [pc, #60]	@ (8002284 <__dbg_check_unlock_from_isr+0x44>)
 8002246:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002248:	9b01      	ldr	r3, [sp, #4]
 800224a:	2288      	movs	r2, #136	@ 0x88
 800224c:	589b      	ldr	r3, [r3, r2]
 800224e:	1e5a      	subs	r2, r3, #1
 8002250:	4313      	orrs	r3, r2
 8002252:	0fdb      	lsrs	r3, r3, #31
 8002254:	b2db      	uxtb	r3, r3
 8002256:	2b00      	cmp	r3, #0
 8002258:	d108      	bne.n	800226c <__dbg_check_unlock_from_isr+0x2c>
 800225a:	9b01      	ldr	r3, [sp, #4]
 800225c:	228c      	movs	r2, #140	@ 0x8c
 800225e:	589b      	ldr	r3, [r3, r2]
 8002260:	1e5a      	subs	r2, r3, #1
 8002262:	4313      	orrs	r3, r2
 8002264:	0fdb      	lsrs	r3, r3, #31
 8002266:	b2db      	uxtb	r3, r3
 8002268:	2b00      	cmp	r3, #0
 800226a:	d003      	beq.n	8002274 <__dbg_check_unlock_from_isr+0x34>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 800226c:	4b06      	ldr	r3, [pc, #24]	@ (8002288 <__dbg_check_unlock_from_isr+0x48>)
 800226e:	0018      	movs	r0, r3
 8002270:	f7ff fefe 	bl	8002070 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002274:	9b01      	ldr	r3, [sp, #4]
 8002276:	228c      	movs	r2, #140	@ 0x8c
 8002278:	2100      	movs	r1, #0
 800227a:	5099      	str	r1, [r3, r2]
}
 800227c:	46c0      	nop			@ (mov r8, r8)
 800227e:	b003      	add	sp, #12
 8002280:	bd00      	pop	{pc}
 8002282:	46c0      	nop			@ (mov r8, r8)
 8002284:	20000690 	.word	0x20000690
 8002288:	08005060 	.word	0x08005060
 800228c:	00000000 	.word	0x00000000

08002290 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 8002290:	b500      	push	{lr}
 8002292:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002294:	4b11      	ldr	r3, [pc, #68]	@ (80022dc <__dbg_check_enter_isr+0x4c>)
 8002296:	9301      	str	r3, [sp, #4]

  port_lock_from_isr();
 8002298:	f7ff ff4a 	bl	8002130 <port_lock_from_isr.lto_priv.3>
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 800229c:	9b01      	ldr	r3, [sp, #4]
 800229e:	2288      	movs	r2, #136	@ 0x88
 80022a0:	589b      	ldr	r3, [r3, r2]
 80022a2:	0fdb      	lsrs	r3, r3, #31
 80022a4:	b2db      	uxtb	r3, r3
 80022a6:	2b00      	cmp	r3, #0
 80022a8:	d107      	bne.n	80022ba <__dbg_check_enter_isr+0x2a>
 80022aa:	9b01      	ldr	r3, [sp, #4]
 80022ac:	228c      	movs	r2, #140	@ 0x8c
 80022ae:	589b      	ldr	r3, [r3, r2]
 80022b0:	1e5a      	subs	r2, r3, #1
 80022b2:	4193      	sbcs	r3, r2
 80022b4:	b2db      	uxtb	r3, r3
 80022b6:	2b00      	cmp	r3, #0
 80022b8:	d003      	beq.n	80022c2 <__dbg_check_enter_isr+0x32>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 80022ba:	4b09      	ldr	r3, [pc, #36]	@ (80022e0 <__dbg_check_enter_isr+0x50>)
 80022bc:	0018      	movs	r0, r3
 80022be:	f7ff fed7 	bl	8002070 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 80022c2:	9b01      	ldr	r3, [sp, #4]
 80022c4:	2288      	movs	r2, #136	@ 0x88
 80022c6:	589b      	ldr	r3, [r3, r2]
 80022c8:	1c5a      	adds	r2, r3, #1
 80022ca:	9b01      	ldr	r3, [sp, #4]
 80022cc:	2188      	movs	r1, #136	@ 0x88
 80022ce:	505a      	str	r2, [r3, r1]
  port_unlock_from_isr();
 80022d0:	f7ff ff36 	bl	8002140 <port_unlock_from_isr.lto_priv.3>
}
 80022d4:	46c0      	nop			@ (mov r8, r8)
 80022d6:	b003      	add	sp, #12
 80022d8:	bd00      	pop	{pc}
 80022da:	46c0      	nop			@ (mov r8, r8)
 80022dc:	20000690 	.word	0x20000690
 80022e0:	08005068 	.word	0x08005068
	...

080022f0 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 80022f0:	b500      	push	{lr}
 80022f2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80022f4:	4b12      	ldr	r3, [pc, #72]	@ (8002340 <__dbg_check_leave_isr+0x50>)
 80022f6:	9301      	str	r3, [sp, #4]

  port_lock_from_isr();
 80022f8:	f7ff ff1a 	bl	8002130 <port_lock_from_isr.lto_priv.3>
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80022fc:	9b01      	ldr	r3, [sp, #4]
 80022fe:	2288      	movs	r2, #136	@ 0x88
 8002300:	589b      	ldr	r3, [r3, r2]
 8002302:	1e5a      	subs	r2, r3, #1
 8002304:	4313      	orrs	r3, r2
 8002306:	0fdb      	lsrs	r3, r3, #31
 8002308:	b2db      	uxtb	r3, r3
 800230a:	2b00      	cmp	r3, #0
 800230c:	d107      	bne.n	800231e <__dbg_check_leave_isr+0x2e>
 800230e:	9b01      	ldr	r3, [sp, #4]
 8002310:	228c      	movs	r2, #140	@ 0x8c
 8002312:	589b      	ldr	r3, [r3, r2]
 8002314:	1e5a      	subs	r2, r3, #1
 8002316:	4193      	sbcs	r3, r2
 8002318:	b2db      	uxtb	r3, r3
 800231a:	2b00      	cmp	r3, #0
 800231c:	d003      	beq.n	8002326 <__dbg_check_leave_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 800231e:	4b09      	ldr	r3, [pc, #36]	@ (8002344 <__dbg_check_leave_isr+0x54>)
 8002320:	0018      	movs	r0, r3
 8002322:	f7ff fea5 	bl	8002070 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 8002326:	9b01      	ldr	r3, [sp, #4]
 8002328:	2288      	movs	r2, #136	@ 0x88
 800232a:	589b      	ldr	r3, [r3, r2]
 800232c:	1e5a      	subs	r2, r3, #1
 800232e:	9b01      	ldr	r3, [sp, #4]
 8002330:	2188      	movs	r1, #136	@ 0x88
 8002332:	505a      	str	r2, [r3, r1]
  port_unlock_from_isr();
 8002334:	f7ff ff04 	bl	8002140 <port_unlock_from_isr.lto_priv.3>
}
 8002338:	46c0      	nop			@ (mov r8, r8)
 800233a:	b003      	add	sp, #12
 800233c:	bd00      	pop	{pc}
 800233e:	46c0      	nop			@ (mov r8, r8)
 8002340:	20000690 	.word	0x20000690
 8002344:	08005070 	.word	0x08005070
	...

08002350 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002350:	b500      	push	{lr}
 8002352:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002354:	4b0c      	ldr	r3, [pc, #48]	@ (8002388 <chDbgCheckClassI+0x38>)
 8002356:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002358:	9b01      	ldr	r3, [sp, #4]
 800235a:	2288      	movs	r2, #136	@ 0x88
 800235c:	589b      	ldr	r3, [r3, r2]
 800235e:	0fdb      	lsrs	r3, r3, #31
 8002360:	b2db      	uxtb	r3, r3
 8002362:	2b00      	cmp	r3, #0
 8002364:	d108      	bne.n	8002378 <chDbgCheckClassI+0x28>
 8002366:	9b01      	ldr	r3, [sp, #4]
 8002368:	228c      	movs	r2, #140	@ 0x8c
 800236a:	589b      	ldr	r3, [r3, r2]
 800236c:	1e5a      	subs	r2, r3, #1
 800236e:	4313      	orrs	r3, r2
 8002370:	0fdb      	lsrs	r3, r3, #31
 8002372:	b2db      	uxtb	r3, r3
 8002374:	2b00      	cmp	r3, #0
 8002376:	d003      	beq.n	8002380 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 8002378:	4b04      	ldr	r3, [pc, #16]	@ (800238c <chDbgCheckClassI+0x3c>)
 800237a:	0018      	movs	r0, r3
 800237c:	f7ff fe78 	bl	8002070 <chSysHalt>
  }
}
 8002380:	46c0      	nop			@ (mov r8, r8)
 8002382:	b003      	add	sp, #12
 8002384:	bd00      	pop	{pc}
 8002386:	46c0      	nop			@ (mov r8, r8)
 8002388:	20000690 	.word	0x20000690
 800238c:	08005078 	.word	0x08005078

08002390 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002390:	b500      	push	{lr}
 8002392:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002394:	4b0c      	ldr	r3, [pc, #48]	@ (80023c8 <chDbgCheckClassS+0x38>)
 8002396:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002398:	9b01      	ldr	r3, [sp, #4]
 800239a:	2288      	movs	r2, #136	@ 0x88
 800239c:	589b      	ldr	r3, [r3, r2]
 800239e:	1e5a      	subs	r2, r3, #1
 80023a0:	4193      	sbcs	r3, r2
 80023a2:	b2db      	uxtb	r3, r3
 80023a4:	2b00      	cmp	r3, #0
 80023a6:	d108      	bne.n	80023ba <chDbgCheckClassS+0x2a>
 80023a8:	9b01      	ldr	r3, [sp, #4]
 80023aa:	228c      	movs	r2, #140	@ 0x8c
 80023ac:	589b      	ldr	r3, [r3, r2]
 80023ae:	1e5a      	subs	r2, r3, #1
 80023b0:	4313      	orrs	r3, r2
 80023b2:	0fdb      	lsrs	r3, r3, #31
 80023b4:	b2db      	uxtb	r3, r3
 80023b6:	2b00      	cmp	r3, #0
 80023b8:	d003      	beq.n	80023c2 <chDbgCheckClassS+0x32>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 80023ba:	4b04      	ldr	r3, [pc, #16]	@ (80023cc <chDbgCheckClassS+0x3c>)
 80023bc:	0018      	movs	r0, r3
 80023be:	f7ff fe57 	bl	8002070 <chSysHalt>
  }
}
 80023c2:	46c0      	nop			@ (mov r8, r8)
 80023c4:	b003      	add	sp, #12
 80023c6:	bd00      	pop	{pc}
 80023c8:	20000690 	.word	0x20000690
 80023cc:	08005080 	.word	0x08005080

080023d0 <port_lock.lto_priv.9>:
  __ASM volatile ("cpsid i" : : : "memory");
 80023d0:	b672      	cpsid	i
}
 80023d2:	46c0      	nop			@ (mov r8, r8)
}
 80023d4:	46c0      	nop			@ (mov r8, r8)
 80023d6:	4770      	bx	lr
	...

080023e0 <port_unlock.lto_priv.9>:
  __ASM volatile ("cpsie i" : : : "memory");
 80023e0:	b662      	cpsie	i
}
 80023e2:	46c0      	nop			@ (mov r8, r8)
}
 80023e4:	46c0      	nop			@ (mov r8, r8)
 80023e6:	4770      	bx	lr
	...

080023f0 <port_lock_from_isr.lto_priv.4>:
static inline void port_lock_from_isr(void) {
 80023f0:	b510      	push	{r4, lr}
  port_lock();
 80023f2:	f7ff ffed 	bl	80023d0 <port_lock.lto_priv.9>
}
 80023f6:	46c0      	nop			@ (mov r8, r8)
 80023f8:	bd10      	pop	{r4, pc}
 80023fa:	46c0      	nop			@ (mov r8, r8)
 80023fc:	0000      	movs	r0, r0
	...

08002400 <port_unlock_from_isr.lto_priv.4>:
static inline void port_unlock_from_isr(void) {
 8002400:	b510      	push	{r4, lr}
  port_unlock();
 8002402:	f7ff ffed 	bl	80023e0 <port_unlock.lto_priv.9>
}
 8002406:	46c0      	nop			@ (mov r8, r8)
 8002408:	bd10      	pop	{r4, pc}
 800240a:	46c0      	nop			@ (mov r8, r8)
 800240c:	0000      	movs	r0, r0
	...

08002410 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002410:	b510      	push	{r4, lr}

  return stGetCounter();
 8002412:	f7fd fff5 	bl	8000400 <stGetCounter>
 8002416:	0003      	movs	r3, r0
}
 8002418:	0018      	movs	r0, r3
 800241a:	bd10      	pop	{r4, pc}
 800241c:	0000      	movs	r0, r0
	...

08002420 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002420:	b510      	push	{r4, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002422:	f7ff fff5 	bl	8002410 <port_timer_get_time.lto_priv.0>
 8002426:	0003      	movs	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002428:	0018      	movs	r0, r3
 800242a:	bd10      	pop	{r4, pc}
 800242c:	0000      	movs	r0, r0
	...

08002430 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {
 8002430:	b510      	push	{r4, lr}
 8002432:	b082      	sub	sp, #8
 8002434:	9001      	str	r0, [sp, #4]

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002436:	9b01      	ldr	r3, [sp, #4]
 8002438:	2294      	movs	r2, #148	@ 0x94
 800243a:	589c      	ldr	r4, [r3, r2]
 800243c:	f7ff fff0 	bl	8002420 <chVTGetSystemTimeX.lto_priv.0>
 8002440:	0003      	movs	r3, r0
 8002442:	80a3      	strh	r3, [r4, #4]
#if PORT_SUPPORTS_RT == TRUE
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
#else
  oip->trace_buffer.ptr->rtstamp = (rtcnt_t)0;
 8002444:	9b01      	ldr	r3, [sp, #4]
 8002446:	2294      	movs	r2, #148	@ 0x94
 8002448:	589b      	ldr	r3, [r3, r2]
 800244a:	681a      	ldr	r2, [r3, #0]
 800244c:	21ff      	movs	r1, #255	@ 0xff
 800244e:	400a      	ands	r2, r1
 8002450:	601a      	str	r2, [r3, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8002452:	9b01      	ldr	r3, [sp, #4]
 8002454:	2294      	movs	r2, #148	@ 0x94
 8002456:	589b      	ldr	r3, [r3, r2]
 8002458:	3310      	adds	r3, #16
 800245a:	001a      	movs	r2, r3
 800245c:	9b01      	ldr	r3, [sp, #4]
 800245e:	2194      	movs	r1, #148	@ 0x94
 8002460:	505a      	str	r2, [r3, r1]
 8002462:	9b01      	ldr	r3, [sp, #4]
 8002464:	2294      	movs	r2, #148	@ 0x94
 8002466:	589a      	ldr	r2, [r3, r2]
 8002468:	9b01      	ldr	r3, [sp, #4]
 800246a:	4907      	ldr	r1, [pc, #28]	@ (8002488 <trace_next+0x58>)
 800246c:	468c      	mov	ip, r1
 800246e:	4463      	add	r3, ip
 8002470:	429a      	cmp	r2, r3
 8002472:	d305      	bcc.n	8002480 <trace_next+0x50>
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8002474:	9b01      	ldr	r3, [sp, #4]
 8002476:	3398      	adds	r3, #152	@ 0x98
 8002478:	001a      	movs	r2, r3
 800247a:	9b01      	ldr	r3, [sp, #4]
 800247c:	2194      	movs	r1, #148	@ 0x94
 800247e:	505a      	str	r2, [r3, r1]
  }
}
 8002480:	46c0      	nop			@ (mov r8, r8)
 8002482:	b002      	add	sp, #8
 8002484:	bd10      	pop	{r4, pc}
 8002486:	46c0      	nop			@ (mov r8, r8)
 8002488:	00000898 	.word	0x00000898
 800248c:	00000000 	.word	0x00000000

08002490 <__trace_object_init>:
 *
 * @param[out] tbp      pointer to the @p trace_buffer_t structure
 *
 * @notapi
 */
void __trace_object_init(trace_buffer_t *tbp) {
 8002490:	b084      	sub	sp, #16
 8002492:	9001      	str	r0, [sp, #4]
  unsigned i;

  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8002494:	9b01      	ldr	r3, [sp, #4]
 8002496:	2220      	movs	r2, #32
 8002498:	4252      	negs	r2, r2
 800249a:	801a      	strh	r2, [r3, #0]
  tbp->size      = CH_DBG_TRACE_BUFFER_SIZE;
 800249c:	9b01      	ldr	r3, [sp, #4]
 800249e:	2280      	movs	r2, #128	@ 0x80
 80024a0:	805a      	strh	r2, [r3, #2]
  tbp->ptr       = &tbp->buffer[0];
 80024a2:	9b01      	ldr	r3, [sp, #4]
 80024a4:	3308      	adds	r3, #8
 80024a6:	001a      	movs	r2, r3
 80024a8:	9b01      	ldr	r3, [sp, #4]
 80024aa:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 80024ac:	2300      	movs	r3, #0
 80024ae:	9303      	str	r3, [sp, #12]
 80024b0:	e00c      	b.n	80024cc <__trace_object_init+0x3c>
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 80024b2:	9a01      	ldr	r2, [sp, #4]
 80024b4:	9b03      	ldr	r3, [sp, #12]
 80024b6:	2108      	movs	r1, #8
 80024b8:	011b      	lsls	r3, r3, #4
 80024ba:	18d3      	adds	r3, r2, r3
 80024bc:	185b      	adds	r3, r3, r1
 80024be:	781a      	ldrb	r2, [r3, #0]
 80024c0:	2107      	movs	r1, #7
 80024c2:	438a      	bics	r2, r1
 80024c4:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 80024c6:	9b03      	ldr	r3, [sp, #12]
 80024c8:	3301      	adds	r3, #1
 80024ca:	9303      	str	r3, [sp, #12]
 80024cc:	9b03      	ldr	r3, [sp, #12]
 80024ce:	2b7f      	cmp	r3, #127	@ 0x7f
 80024d0:	d9ef      	bls.n	80024b2 <__trace_object_init+0x22>
  }
}
 80024d2:	46c0      	nop			@ (mov r8, r8)
 80024d4:	46c0      	nop			@ (mov r8, r8)
 80024d6:	b004      	add	sp, #16
 80024d8:	4770      	bx	lr
 80024da:	46c0      	nop			@ (mov r8, r8)
 80024dc:	0000      	movs	r0, r0
	...

080024e0 <__trace_ready>:
 * @param[in] tp        the thread that just become ready
 * @param[in] msg       the thread ready message
 *
 * @notapi
 */
void __trace_ready(thread_t *tp, msg_t msg) {
 80024e0:	b500      	push	{lr}
 80024e2:	b085      	sub	sp, #20
 80024e4:	9001      	str	r0, [sp, #4]
 80024e6:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 80024e8:	4b1a      	ldr	r3, [pc, #104]	@ (8002554 <__trace_ready+0x74>)
 80024ea:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 80024ec:	9b03      	ldr	r3, [sp, #12]
 80024ee:	2290      	movs	r2, #144	@ 0x90
 80024f0:	5a9b      	ldrh	r3, [r3, r2]
 80024f2:	001a      	movs	r2, r3
 80024f4:	2301      	movs	r3, #1
 80024f6:	4013      	ands	r3, r2
 80024f8:	d128      	bne.n	800254c <__trace_ready+0x6c>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 80024fa:	9b03      	ldr	r3, [sp, #12]
 80024fc:	2294      	movs	r2, #148	@ 0x94
 80024fe:	589b      	ldr	r3, [r3, r2]
 8002500:	781a      	ldrb	r2, [r3, #0]
 8002502:	2107      	movs	r1, #7
 8002504:	438a      	bics	r2, r1
 8002506:	1c11      	adds	r1, r2, #0
 8002508:	2201      	movs	r2, #1
 800250a:	430a      	orrs	r2, r1
 800250c:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)tp->state;
 800250e:	9b01      	ldr	r3, [sp, #4]
 8002510:	2224      	movs	r2, #36	@ 0x24
 8002512:	5c99      	ldrb	r1, [r3, r2]
 8002514:	9b03      	ldr	r3, [sp, #12]
 8002516:	2294      	movs	r2, #148	@ 0x94
 8002518:	589b      	ldr	r3, [r3, r2]
 800251a:	221f      	movs	r2, #31
 800251c:	400a      	ands	r2, r1
 800251e:	b2d2      	uxtb	r2, r2
 8002520:	00d0      	lsls	r0, r2, #3
 8002522:	781a      	ldrb	r2, [r3, #0]
 8002524:	2107      	movs	r1, #7
 8002526:	400a      	ands	r2, r1
 8002528:	1c11      	adds	r1, r2, #0
 800252a:	1c02      	adds	r2, r0, #0
 800252c:	430a      	orrs	r2, r1
 800252e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.rdy.tp    = tp;
 8002530:	9b03      	ldr	r3, [sp, #12]
 8002532:	2294      	movs	r2, #148	@ 0x94
 8002534:	589b      	ldr	r3, [r3, r2]
 8002536:	9a01      	ldr	r2, [sp, #4]
 8002538:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 800253a:	9b03      	ldr	r3, [sp, #12]
 800253c:	2294      	movs	r2, #148	@ 0x94
 800253e:	589b      	ldr	r3, [r3, r2]
 8002540:	9a00      	ldr	r2, [sp, #0]
 8002542:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 8002544:	9b03      	ldr	r3, [sp, #12]
 8002546:	0018      	movs	r0, r3
 8002548:	f7ff ff72 	bl	8002430 <trace_next>
  }
}
 800254c:	46c0      	nop			@ (mov r8, r8)
 800254e:	b005      	add	sp, #20
 8002550:	bd00      	pop	{pc}
 8002552:	46c0      	nop			@ (mov r8, r8)
 8002554:	20000690 	.word	0x20000690
	...

08002560 <__trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void __trace_switch(thread_t *ntp, thread_t *otp) {
 8002560:	b500      	push	{lr}
 8002562:	b085      	sub	sp, #20
 8002564:	9001      	str	r0, [sp, #4]
 8002566:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8002568:	4b1a      	ldr	r3, [pc, #104]	@ (80025d4 <__trace_switch+0x74>)
 800256a:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800256c:	9b03      	ldr	r3, [sp, #12]
 800256e:	2290      	movs	r2, #144	@ 0x90
 8002570:	5a9b      	ldrh	r3, [r3, r2]
 8002572:	001a      	movs	r2, r3
 8002574:	2302      	movs	r3, #2
 8002576:	4013      	ands	r3, r2
 8002578:	d129      	bne.n	80025ce <__trace_switch+0x6e>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800257a:	9b03      	ldr	r3, [sp, #12]
 800257c:	2294      	movs	r2, #148	@ 0x94
 800257e:	589b      	ldr	r3, [r3, r2]
 8002580:	781a      	ldrb	r2, [r3, #0]
 8002582:	2107      	movs	r1, #7
 8002584:	438a      	bics	r2, r1
 8002586:	1c11      	adds	r1, r2, #0
 8002588:	2202      	movs	r2, #2
 800258a:	430a      	orrs	r2, r1
 800258c:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)otp->state;
 800258e:	9b00      	ldr	r3, [sp, #0]
 8002590:	2224      	movs	r2, #36	@ 0x24
 8002592:	5c99      	ldrb	r1, [r3, r2]
 8002594:	9b03      	ldr	r3, [sp, #12]
 8002596:	2294      	movs	r2, #148	@ 0x94
 8002598:	589b      	ldr	r3, [r3, r2]
 800259a:	221f      	movs	r2, #31
 800259c:	400a      	ands	r2, r1
 800259e:	b2d2      	uxtb	r2, r2
 80025a0:	00d0      	lsls	r0, r2, #3
 80025a2:	781a      	ldrb	r2, [r3, #0]
 80025a4:	2107      	movs	r1, #7
 80025a6:	400a      	ands	r2, r1
 80025a8:	1c11      	adds	r1, r2, #0
 80025aa:	1c02      	adds	r2, r0, #0
 80025ac:	430a      	orrs	r2, r1
 80025ae:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
 80025b0:	9b03      	ldr	r3, [sp, #12]
 80025b2:	2294      	movs	r2, #148	@ 0x94
 80025b4:	589b      	ldr	r3, [r3, r2]
 80025b6:	9a01      	ldr	r2, [sp, #4]
 80025b8:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80025ba:	9b03      	ldr	r3, [sp, #12]
 80025bc:	2294      	movs	r2, #148	@ 0x94
 80025be:	589b      	ldr	r3, [r3, r2]
 80025c0:	9a00      	ldr	r2, [sp, #0]
 80025c2:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 80025c4:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 80025c6:	9b03      	ldr	r3, [sp, #12]
 80025c8:	0018      	movs	r0, r3
 80025ca:	f7ff ff31 	bl	8002430 <trace_next>
  }
}
 80025ce:	46c0      	nop			@ (mov r8, r8)
 80025d0:	b005      	add	sp, #20
 80025d2:	bd00      	pop	{pc}
 80025d4:	20000690 	.word	0x20000690
	...

080025e0 <__trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_enter(const char *isr) {
 80025e0:	b500      	push	{lr}
 80025e2:	b085      	sub	sp, #20
 80025e4:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 80025e6:	4b15      	ldr	r3, [pc, #84]	@ (800263c <__trace_isr_enter+0x5c>)
 80025e8:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80025ea:	9b03      	ldr	r3, [sp, #12]
 80025ec:	2290      	movs	r2, #144	@ 0x90
 80025ee:	5a9b      	ldrh	r3, [r3, r2]
 80025f0:	001a      	movs	r2, r3
 80025f2:	2304      	movs	r3, #4
 80025f4:	4013      	ands	r3, r2
 80025f6:	d11d      	bne.n	8002634 <__trace_isr_enter+0x54>
    port_lock_from_isr();
 80025f8:	f7ff fefa 	bl	80023f0 <port_lock_from_isr.lto_priv.4>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80025fc:	9b03      	ldr	r3, [sp, #12]
 80025fe:	2294      	movs	r2, #148	@ 0x94
 8002600:	589b      	ldr	r3, [r3, r2]
 8002602:	781a      	ldrb	r2, [r3, #0]
 8002604:	2107      	movs	r1, #7
 8002606:	438a      	bics	r2, r1
 8002608:	1c11      	adds	r1, r2, #0
 800260a:	2203      	movs	r2, #3
 800260c:	430a      	orrs	r2, r1
 800260e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state       = 0U;
 8002610:	9b03      	ldr	r3, [sp, #12]
 8002612:	2294      	movs	r2, #148	@ 0x94
 8002614:	589b      	ldr	r3, [r3, r2]
 8002616:	781a      	ldrb	r2, [r3, #0]
 8002618:	2107      	movs	r1, #7
 800261a:	400a      	ands	r2, r1
 800261c:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800261e:	9b03      	ldr	r3, [sp, #12]
 8002620:	2294      	movs	r2, #148	@ 0x94
 8002622:	589b      	ldr	r3, [r3, r2]
 8002624:	9a01      	ldr	r2, [sp, #4]
 8002626:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002628:	9b03      	ldr	r3, [sp, #12]
 800262a:	0018      	movs	r0, r3
 800262c:	f7ff ff00 	bl	8002430 <trace_next>
    port_unlock_from_isr();
 8002630:	f7ff fee6 	bl	8002400 <port_unlock_from_isr.lto_priv.4>
  }
}
 8002634:	46c0      	nop			@ (mov r8, r8)
 8002636:	b005      	add	sp, #20
 8002638:	bd00      	pop	{pc}
 800263a:	46c0      	nop			@ (mov r8, r8)
 800263c:	20000690 	.word	0x20000690

08002640 <__trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_leave(const char *isr) {
 8002640:	b500      	push	{lr}
 8002642:	b085      	sub	sp, #20
 8002644:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 8002646:	4b15      	ldr	r3, [pc, #84]	@ (800269c <__trace_isr_leave+0x5c>)
 8002648:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800264a:	9b03      	ldr	r3, [sp, #12]
 800264c:	2290      	movs	r2, #144	@ 0x90
 800264e:	5a9b      	ldrh	r3, [r3, r2]
 8002650:	001a      	movs	r2, r3
 8002652:	2304      	movs	r3, #4
 8002654:	4013      	ands	r3, r2
 8002656:	d11d      	bne.n	8002694 <__trace_isr_leave+0x54>
    port_lock_from_isr();
 8002658:	f7ff feca 	bl	80023f0 <port_lock_from_isr.lto_priv.4>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800265c:	9b03      	ldr	r3, [sp, #12]
 800265e:	2294      	movs	r2, #148	@ 0x94
 8002660:	589b      	ldr	r3, [r3, r2]
 8002662:	781a      	ldrb	r2, [r3, #0]
 8002664:	2107      	movs	r1, #7
 8002666:	438a      	bics	r2, r1
 8002668:	1c11      	adds	r1, r2, #0
 800266a:	2204      	movs	r2, #4
 800266c:	430a      	orrs	r2, r1
 800266e:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state       = 0U;
 8002670:	9b03      	ldr	r3, [sp, #12]
 8002672:	2294      	movs	r2, #148	@ 0x94
 8002674:	589b      	ldr	r3, [r3, r2]
 8002676:	781a      	ldrb	r2, [r3, #0]
 8002678:	2107      	movs	r1, #7
 800267a:	400a      	ands	r2, r1
 800267c:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800267e:	9b03      	ldr	r3, [sp, #12]
 8002680:	2294      	movs	r2, #148	@ 0x94
 8002682:	589b      	ldr	r3, [r3, r2]
 8002684:	9a01      	ldr	r2, [sp, #4]
 8002686:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002688:	9b03      	ldr	r3, [sp, #12]
 800268a:	0018      	movs	r0, r3
 800268c:	f7ff fed0 	bl	8002430 <trace_next>
    port_unlock_from_isr();
 8002690:	f7ff feb6 	bl	8002400 <port_unlock_from_isr.lto_priv.4>
  }
}
 8002694:	46c0      	nop			@ (mov r8, r8)
 8002696:	b005      	add	sp, #20
 8002698:	bd00      	pop	{pc}
 800269a:	46c0      	nop			@ (mov r8, r8)
 800269c:	20000690 	.word	0x20000690

080026a0 <__trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void __trace_halt(const char *reason) {
 80026a0:	b500      	push	{lr}
 80026a2:	b085      	sub	sp, #20
 80026a4:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 80026a6:	4b13      	ldr	r3, [pc, #76]	@ (80026f4 <__trace_halt+0x54>)
 80026a8:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 80026aa:	9b03      	ldr	r3, [sp, #12]
 80026ac:	2290      	movs	r2, #144	@ 0x90
 80026ae:	5a9b      	ldrh	r3, [r3, r2]
 80026b0:	001a      	movs	r2, r3
 80026b2:	2308      	movs	r3, #8
 80026b4:	4013      	ands	r3, r2
 80026b6:	d119      	bne.n	80026ec <__trace_halt+0x4c>
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 80026b8:	9b03      	ldr	r3, [sp, #12]
 80026ba:	2294      	movs	r2, #148	@ 0x94
 80026bc:	589b      	ldr	r3, [r3, r2]
 80026be:	781a      	ldrb	r2, [r3, #0]
 80026c0:	2107      	movs	r1, #7
 80026c2:	438a      	bics	r2, r1
 80026c4:	1c11      	adds	r1, r2, #0
 80026c6:	2205      	movs	r2, #5
 80026c8:	430a      	orrs	r2, r1
 80026ca:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->state         = 0;
 80026cc:	9b03      	ldr	r3, [sp, #12]
 80026ce:	2294      	movs	r2, #148	@ 0x94
 80026d0:	589b      	ldr	r3, [r3, r2]
 80026d2:	781a      	ldrb	r2, [r3, #0]
 80026d4:	2107      	movs	r1, #7
 80026d6:	400a      	ands	r2, r1
 80026d8:	701a      	strb	r2, [r3, #0]
    oip->trace_buffer.ptr->u.halt.reason = reason;
 80026da:	9b03      	ldr	r3, [sp, #12]
 80026dc:	2294      	movs	r2, #148	@ 0x94
 80026de:	589b      	ldr	r3, [r3, r2]
 80026e0:	9a01      	ldr	r2, [sp, #4]
 80026e2:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80026e4:	9b03      	ldr	r3, [sp, #12]
 80026e6:	0018      	movs	r0, r3
 80026e8:	f7ff fea2 	bl	8002430 <trace_next>
  }
}
 80026ec:	46c0      	nop			@ (mov r8, r8)
 80026ee:	b005      	add	sp, #20
 80026f0:	bd00      	pop	{pc}
 80026f2:	46c0      	nop			@ (mov r8, r8)
 80026f4:	20000690 	.word	0x20000690
	...

08002700 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8002700:	b500      	push	{lr}
 8002702:	b083      	sub	sp, #12
 8002704:	0002      	movs	r2, r0
 8002706:	9100      	str	r1, [sp, #0]
 8002708:	466b      	mov	r3, sp
 800270a:	3306      	adds	r3, #6
 800270c:	801a      	strh	r2, [r3, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 800270e:	9900      	ldr	r1, [sp, #0]
 8002710:	2380      	movs	r3, #128	@ 0x80
 8002712:	025a      	lsls	r2, r3, #9
 8002714:	2300      	movs	r3, #0
 8002716:	4291      	cmp	r1, r2
 8002718:	415b      	adcs	r3, r3
 800271a:	b2db      	uxtb	r3, r3
 800271c:	2b00      	cmp	r3, #0
 800271e:	d003      	beq.n	8002728 <chTimeAddX+0x28>
 8002720:	4b06      	ldr	r3, [pc, #24]	@ (800273c <chTimeAddX+0x3c>)
 8002722:	0018      	movs	r0, r3
 8002724:	f7ff fca4 	bl	8002070 <chSysHalt>
#endif

  return systime + (systime_t)interval;
 8002728:	9b00      	ldr	r3, [sp, #0]
 800272a:	b29a      	uxth	r2, r3
 800272c:	466b      	mov	r3, sp
 800272e:	3306      	adds	r3, #6
 8002730:	881b      	ldrh	r3, [r3, #0]
 8002732:	18d3      	adds	r3, r2, r3
 8002734:	b29b      	uxth	r3, r3
}
 8002736:	0018      	movs	r0, r3
 8002738:	b003      	add	sp, #12
 800273a:	bd00      	pop	{pc}
 800273c:	080050f0 	.word	0x080050f0

08002740 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8002740:	b082      	sub	sp, #8
 8002742:	0002      	movs	r2, r0
 8002744:	466b      	mov	r3, sp
 8002746:	3306      	adds	r3, #6
 8002748:	801a      	strh	r2, [r3, #0]
 800274a:	ab01      	add	r3, sp, #4
 800274c:	1c0a      	adds	r2, r1, #0
 800274e:	801a      	strh	r2, [r3, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002750:	aa01      	add	r2, sp, #4
 8002752:	466b      	mov	r3, sp
 8002754:	3306      	adds	r3, #6
 8002756:	8812      	ldrh	r2, [r2, #0]
 8002758:	881b      	ldrh	r3, [r3, #0]
 800275a:	1ad3      	subs	r3, r2, r3
 800275c:	b29b      	uxth	r3, r3
  /*lint -restore*/
}
 800275e:	0018      	movs	r0, r3
 8002760:	b002      	add	sp, #8
 8002762:	4770      	bx	lr
	...

08002770 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8002770:	b082      	sub	sp, #8
 8002772:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8002774:	9b01      	ldr	r3, [sp, #4]
 8002776:	681b      	ldr	r3, [r3, #0]
 8002778:	9a01      	ldr	r2, [sp, #4]
 800277a:	1ad3      	subs	r3, r2, r3
 800277c:	425a      	negs	r2, r3
 800277e:	4153      	adcs	r3, r2
 8002780:	b2db      	uxtb	r3, r3
}
 8002782:	0018      	movs	r0, r3
 8002784:	b002      	add	sp, #8
 8002786:	4770      	bx	lr
	...

08002790 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8002790:	b082      	sub	sp, #8
 8002792:	9001      	str	r0, [sp, #4]
 8002794:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8002796:	9b01      	ldr	r3, [sp, #4]
 8002798:	681b      	ldr	r3, [r3, #0]
 800279a:	9a00      	ldr	r2, [sp, #0]
 800279c:	1ad3      	subs	r3, r2, r3
 800279e:	425a      	negs	r2, r3
 80027a0:	4153      	adcs	r3, r2
 80027a2:	b2db      	uxtb	r3, r3
}
 80027a4:	0018      	movs	r0, r3
 80027a6:	b002      	add	sp, #8
 80027a8:	4770      	bx	lr
 80027aa:	46c0      	nop			@ (mov r8, r8)
 80027ac:	0000      	movs	r0, r0
	...

080027b0 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 80027b0:	b084      	sub	sp, #16
 80027b2:	9003      	str	r0, [sp, #12]
 80027b4:	9102      	str	r1, [sp, #8]
 80027b6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 80027b8:	9b02      	ldr	r3, [sp, #8]
 80027ba:	9a01      	ldr	r2, [sp, #4]
 80027bc:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 80027be:	9b02      	ldr	r3, [sp, #8]
 80027c0:	9a03      	ldr	r2, [sp, #12]
 80027c2:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 80027c4:	9b02      	ldr	r3, [sp, #8]
 80027c6:	685b      	ldr	r3, [r3, #4]
 80027c8:	681a      	ldr	r2, [r3, #0]
 80027ca:	9b02      	ldr	r3, [sp, #8]
 80027cc:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 80027ce:	9b02      	ldr	r3, [sp, #8]
 80027d0:	681b      	ldr	r3, [r3, #0]
 80027d2:	9a02      	ldr	r2, [sp, #8]
 80027d4:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 80027d6:	9b03      	ldr	r3, [sp, #12]
 80027d8:	9a02      	ldr	r2, [sp, #8]
 80027da:	601a      	str	r2, [r3, #0]
}
 80027dc:	46c0      	nop			@ (mov r8, r8)
 80027de:	b004      	add	sp, #16
 80027e0:	4770      	bx	lr
 80027e2:	46c0      	nop			@ (mov r8, r8)
	...

080027f0 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 80027f0:	b084      	sub	sp, #16
 80027f2:	9003      	str	r0, [sp, #12]
 80027f4:	9102      	str	r1, [sp, #8]
 80027f6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 80027f8:	9b02      	ldr	r3, [sp, #8]
 80027fa:	9a01      	ldr	r2, [sp, #4]
 80027fc:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 80027fe:	9b02      	ldr	r3, [sp, #8]
 8002800:	9a03      	ldr	r2, [sp, #12]
 8002802:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8002804:	9b02      	ldr	r3, [sp, #8]
 8002806:	681b      	ldr	r3, [r3, #0]
 8002808:	685a      	ldr	r2, [r3, #4]
 800280a:	9b02      	ldr	r3, [sp, #8]
 800280c:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 800280e:	9b02      	ldr	r3, [sp, #8]
 8002810:	685b      	ldr	r3, [r3, #4]
 8002812:	9a02      	ldr	r2, [sp, #8]
 8002814:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 8002816:	9b03      	ldr	r3, [sp, #12]
 8002818:	9a02      	ldr	r2, [sp, #8]
 800281a:	605a      	str	r2, [r3, #4]
}
 800281c:	46c0      	nop			@ (mov r8, r8)
 800281e:	b004      	add	sp, #16
 8002820:	4770      	bx	lr
 8002822:	46c0      	nop			@ (mov r8, r8)
	...

08002830 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8002830:	b500      	push	{lr}
 8002832:	b087      	sub	sp, #28
 8002834:	9003      	str	r0, [sp, #12]
 8002836:	9102      	str	r1, [sp, #8]
 8002838:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 800283a:	9b03      	ldr	r3, [sp, #12]
 800283c:	681b      	ldr	r3, [r3, #0]
 800283e:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002840:	e013      	b.n	800286a <ch_dlist_insert+0x3a>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8002842:	9a05      	ldr	r2, [sp, #20]
 8002844:	9b02      	ldr	r3, [sp, #8]
 8002846:	1ad3      	subs	r3, r2, r3
 8002848:	425a      	negs	r2, r3
 800284a:	4153      	adcs	r3, r2
 800284c:	b2db      	uxtb	r3, r3
 800284e:	2b00      	cmp	r3, #0
 8002850:	d003      	beq.n	800285a <ch_dlist_insert+0x2a>
 8002852:	4b14      	ldr	r3, [pc, #80]	@ (80028a4 <ch_dlist_insert+0x74>)
 8002854:	0018      	movs	r0, r3
 8002856:	f7ff fc0b 	bl	8002070 <chSysHalt>

    delta -= dlp->delta;
 800285a:	9b05      	ldr	r3, [sp, #20]
 800285c:	689b      	ldr	r3, [r3, #8]
 800285e:	9a01      	ldr	r2, [sp, #4]
 8002860:	1ad3      	subs	r3, r2, r3
 8002862:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 8002864:	9b05      	ldr	r3, [sp, #20]
 8002866:	681b      	ldr	r3, [r3, #0]
 8002868:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 800286a:	9b05      	ldr	r3, [sp, #20]
 800286c:	689a      	ldr	r2, [r3, #8]
 800286e:	9b01      	ldr	r3, [sp, #4]
 8002870:	429a      	cmp	r2, r3
 8002872:	419b      	sbcs	r3, r3
 8002874:	425b      	negs	r3, r3
 8002876:	b2db      	uxtb	r3, r3
 8002878:	2b00      	cmp	r3, #0
 800287a:	d1e2      	bne.n	8002842 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 800287c:	9a01      	ldr	r2, [sp, #4]
 800287e:	9902      	ldr	r1, [sp, #8]
 8002880:	9b05      	ldr	r3, [sp, #20]
 8002882:	0018      	movs	r0, r3
 8002884:	f7ff ffb4 	bl	80027f0 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8002888:	9b05      	ldr	r3, [sp, #20]
 800288a:	689a      	ldr	r2, [r3, #8]
 800288c:	9b01      	ldr	r3, [sp, #4]
 800288e:	1ad2      	subs	r2, r2, r3
 8002890:	9b05      	ldr	r3, [sp, #20]
 8002892:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8002894:	9b03      	ldr	r3, [sp, #12]
 8002896:	2201      	movs	r2, #1
 8002898:	4252      	negs	r2, r2
 800289a:	609a      	str	r2, [r3, #8]
}
 800289c:	46c0      	nop			@ (mov r8, r8)
 800289e:	b007      	add	sp, #28
 80028a0:	bd00      	pop	{pc}
 80028a2:	46c0      	nop			@ (mov r8, r8)
 80028a4:	080050fc 	.word	0x080050fc
	...

080028b0 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 80028b0:	b084      	sub	sp, #16
 80028b2:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 80028b4:	9b01      	ldr	r3, [sp, #4]
 80028b6:	681b      	ldr	r3, [r3, #0]
 80028b8:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 80028ba:	9b03      	ldr	r3, [sp, #12]
 80028bc:	681a      	ldr	r2, [r3, #0]
 80028be:	9b01      	ldr	r3, [sp, #4]
 80028c0:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 80028c2:	9b01      	ldr	r3, [sp, #4]
 80028c4:	681b      	ldr	r3, [r3, #0]
 80028c6:	9a01      	ldr	r2, [sp, #4]
 80028c8:	605a      	str	r2, [r3, #4]

  return dlp;
 80028ca:	9b03      	ldr	r3, [sp, #12]
}
 80028cc:	0018      	movs	r0, r3
 80028ce:	b004      	add	sp, #16
 80028d0:	4770      	bx	lr
 80028d2:	46c0      	nop			@ (mov r8, r8)
	...

080028e0 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 80028e0:	b082      	sub	sp, #8
 80028e2:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 80028e4:	9b01      	ldr	r3, [sp, #4]
 80028e6:	685b      	ldr	r3, [r3, #4]
 80028e8:	9a01      	ldr	r2, [sp, #4]
 80028ea:	6812      	ldr	r2, [r2, #0]
 80028ec:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 80028ee:	9b01      	ldr	r3, [sp, #4]
 80028f0:	681b      	ldr	r3, [r3, #0]
 80028f2:	9a01      	ldr	r2, [sp, #4]
 80028f4:	6852      	ldr	r2, [r2, #4]
 80028f6:	605a      	str	r2, [r3, #4]

  return dlp;
 80028f8:	9b01      	ldr	r3, [sp, #4]
}
 80028fa:	0018      	movs	r0, r3
 80028fc:	b002      	add	sp, #8
 80028fe:	4770      	bx	lr

08002900 <port_lock.lto_priv.10>:
  __ASM volatile ("cpsid i" : : : "memory");
 8002900:	b672      	cpsid	i
}
 8002902:	46c0      	nop			@ (mov r8, r8)
}
 8002904:	46c0      	nop			@ (mov r8, r8)
 8002906:	4770      	bx	lr
	...

08002910 <port_unlock.lto_priv.10>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002910:	b662      	cpsie	i
}
 8002912:	46c0      	nop			@ (mov r8, r8)
}
 8002914:	46c0      	nop			@ (mov r8, r8)
 8002916:	4770      	bx	lr
	...

08002920 <port_lock_from_isr.lto_priv.5>:
static inline void port_lock_from_isr(void) {
 8002920:	b510      	push	{r4, lr}
  port_lock();
 8002922:	f7ff ffed 	bl	8002900 <port_lock.lto_priv.10>
}
 8002926:	46c0      	nop			@ (mov r8, r8)
 8002928:	bd10      	pop	{r4, pc}
 800292a:	46c0      	nop			@ (mov r8, r8)
 800292c:	0000      	movs	r0, r0
	...

08002930 <port_unlock_from_isr.lto_priv.5>:
static inline void port_unlock_from_isr(void) {
 8002930:	b510      	push	{r4, lr}
  port_unlock();
 8002932:	f7ff ffed 	bl	8002910 <port_unlock.lto_priv.10>
}
 8002936:	46c0      	nop			@ (mov r8, r8)
 8002938:	bd10      	pop	{r4, pc}
 800293a:	46c0      	nop			@ (mov r8, r8)
 800293c:	0000      	movs	r0, r0
	...

08002940 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 8002940:	b500      	push	{lr}
 8002942:	b083      	sub	sp, #12
 8002944:	0002      	movs	r2, r0
 8002946:	466b      	mov	r3, sp
 8002948:	3306      	adds	r3, #6
 800294a:	801a      	strh	r2, [r3, #0]
  stStartAlarm(time);
 800294c:	466b      	mov	r3, sp
 800294e:	3306      	adds	r3, #6
 8002950:	881b      	ldrh	r3, [r3, #0]
 8002952:	0018      	movs	r0, r3
 8002954:	f7fd fd5c 	bl	8000410 <stStartAlarm>
}
 8002958:	46c0      	nop			@ (mov r8, r8)
 800295a:	b003      	add	sp, #12
 800295c:	bd00      	pop	{pc}
 800295e:	46c0      	nop			@ (mov r8, r8)

08002960 <port_timer_stop_alarm>:
static inline void port_timer_stop_alarm(void) {
 8002960:	b510      	push	{r4, lr}
  stStopAlarm();
 8002962:	f7fd fd75 	bl	8000450 <stStopAlarm>
}
 8002966:	46c0      	nop			@ (mov r8, r8)
 8002968:	bd10      	pop	{r4, pc}
 800296a:	46c0      	nop			@ (mov r8, r8)
 800296c:	0000      	movs	r0, r0
	...

08002970 <port_timer_set_alarm>:
static inline void port_timer_set_alarm(systime_t time) {
 8002970:	b500      	push	{lr}
 8002972:	b083      	sub	sp, #12
 8002974:	0002      	movs	r2, r0
 8002976:	466b      	mov	r3, sp
 8002978:	3306      	adds	r3, #6
 800297a:	801a      	strh	r2, [r3, #0]
  stSetAlarm(time);
 800297c:	466b      	mov	r3, sp
 800297e:	3306      	adds	r3, #6
 8002980:	881b      	ldrh	r3, [r3, #0]
 8002982:	0018      	movs	r0, r3
 8002984:	f7fd fd6c 	bl	8000460 <stSetAlarm>
}
 8002988:	46c0      	nop			@ (mov r8, r8)
 800298a:	b003      	add	sp, #12
 800298c:	bd00      	pop	{pc}
 800298e:	46c0      	nop			@ (mov r8, r8)

08002990 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 8002990:	b510      	push	{r4, lr}
  return stGetCounter();
 8002992:	f7fd fd35 	bl	8000400 <stGetCounter>
 8002996:	0003      	movs	r3, r0
}
 8002998:	0018      	movs	r0, r3
 800299a:	bd10      	pop	{r4, pc}
 800299c:	0000      	movs	r0, r0
	...

080029a0 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 80029a0:	b510      	push	{r4, lr}
  port_lock_from_isr();
 80029a2:	f7ff ffbd 	bl	8002920 <port_lock_from_isr.lto_priv.5>
  __dbg_check_lock_from_isr();
 80029a6:	f7ff fc23 	bl	80021f0 <__dbg_check_lock_from_isr>
}
 80029aa:	46c0      	nop			@ (mov r8, r8)
 80029ac:	bd10      	pop	{r4, pc}
 80029ae:	46c0      	nop			@ (mov r8, r8)

080029b0 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
 80029b0:	b510      	push	{r4, lr}
  __dbg_check_unlock_from_isr();
 80029b2:	f7ff fc45 	bl	8002240 <__dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 80029b6:	f7ff ffbb 	bl	8002930 <port_unlock_from_isr.lto_priv.5>
}
 80029ba:	46c0      	nop			@ (mov r8, r8)
 80029bc:	bd10      	pop	{r4, pc}
 80029be:	46c0      	nop			@ (mov r8, r8)

080029c0 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 80029c0:	b510      	push	{r4, lr}
  return port_timer_get_time();
 80029c2:	f7ff ffe5 	bl	8002990 <port_timer_get_time.lto_priv.1>
 80029c6:	0003      	movs	r3, r0
}
 80029c8:	0018      	movs	r0, r3
 80029ca:	bd10      	pop	{r4, pc}
 80029cc:	0000      	movs	r0, r0
	...

080029d0 <chVTIsArmedI.lto_priv.0>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 80029d0:	b500      	push	{lr}
 80029d2:	b083      	sub	sp, #12
 80029d4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80029d6:	f7ff fcbb 	bl	8002350 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 80029da:	9b01      	ldr	r3, [sp, #4]
 80029dc:	681b      	ldr	r3, [r3, #0]
 80029de:	1e5a      	subs	r2, r3, #1
 80029e0:	4193      	sbcs	r3, r2
 80029e2:	b2db      	uxtb	r3, r3
}
 80029e4:	0018      	movs	r0, r3
 80029e6:	b003      	add	sp, #12
 80029e8:	bd00      	pop	{pc}
 80029ea:	46c0      	nop			@ (mov r8, r8)
 80029ec:	0000      	movs	r0, r0
	...

080029f0 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 80029f0:	b510      	push	{r4, lr}
 80029f2:	b086      	sub	sp, #24
 80029f4:	0002      	movs	r2, r0
 80029f6:	9100      	str	r1, [sp, #0]
 80029f8:	466b      	mov	r3, sp
 80029fa:	3306      	adds	r3, #6
 80029fc:	801a      	strh	r2, [r3, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80029fe:	2302      	movs	r3, #2
 8002a00:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 8002a02:	9a00      	ldr	r2, [sp, #0]
 8002a04:	9b05      	ldr	r3, [sp, #20]
 8002a06:	429a      	cmp	r2, r3
 8002a08:	d202      	bcs.n	8002a10 <vt_set_alarm+0x20>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002a0a:	9b05      	ldr	r3, [sp, #20]
 8002a0c:	9300      	str	r3, [sp, #0]
 8002a0e:	e007      	b.n	8002a20 <vt_set_alarm+0x30>
  }
#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
  else if (delay > VT_MAX_DELAY) {
 8002a10:	9a00      	ldr	r2, [sp, #0]
 8002a12:	23ff      	movs	r3, #255	@ 0xff
 8002a14:	021b      	lsls	r3, r3, #8
 8002a16:	429a      	cmp	r2, r3
 8002a18:	d902      	bls.n	8002a20 <vt_set_alarm+0x30>
    /* The delta could be too large for the physical timer to handle
       this can happen when: sizeof (systime_t) < sizeof (sysinterval_t).*/
    delay = VT_MAX_DELAY;
 8002a1a:	23ff      	movs	r3, #255	@ 0xff
 8002a1c:	021b      	lsls	r3, r3, #8
 8002a1e:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 8002a20:	9a00      	ldr	r2, [sp, #0]
 8002a22:	466b      	mov	r3, sp
 8002a24:	3306      	adds	r3, #6
 8002a26:	881b      	ldrh	r3, [r3, #0]
 8002a28:	0011      	movs	r1, r2
 8002a2a:	0018      	movs	r0, r3
 8002a2c:	f7ff fe68 	bl	8002700 <chTimeAddX>
 8002a30:	0003      	movs	r3, r0
 8002a32:	0018      	movs	r0, r3
 8002a34:	f7ff ff9c 	bl	8002970 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002a38:	2412      	movs	r4, #18
 8002a3a:	446c      	add	r4, sp
 8002a3c:	f7ff ffc0 	bl	80029c0 <chVTGetSystemTimeX.lto_priv.1>
 8002a40:	0003      	movs	r3, r0
 8002a42:	8023      	strh	r3, [r4, #0]
    nowdelta = chTimeDiffX(now, newnow);
 8002a44:	2312      	movs	r3, #18
 8002a46:	446b      	add	r3, sp
 8002a48:	881a      	ldrh	r2, [r3, #0]
 8002a4a:	466b      	mov	r3, sp
 8002a4c:	3306      	adds	r3, #6
 8002a4e:	881b      	ldrh	r3, [r3, #0]
 8002a50:	0011      	movs	r1, r2
 8002a52:	0018      	movs	r0, r3
 8002a54:	f7ff fe74 	bl	8002740 <chTimeDiffX.lto_priv.0>
 8002a58:	0003      	movs	r3, r0
 8002a5a:	9303      	str	r3, [sp, #12]
    if (likely(nowdelta < delay)) {
 8002a5c:	9a03      	ldr	r2, [sp, #12]
 8002a5e:	9b00      	ldr	r3, [sp, #0]
 8002a60:	429a      	cmp	r2, r3
 8002a62:	419b      	sbcs	r3, r3
 8002a64:	425b      	negs	r3, r3
 8002a66:	b2db      	uxtb	r3, r3
 8002a68:	2b00      	cmp	r3, #0
 8002a6a:	d10b      	bne.n	8002a84 <vt_set_alarm+0x94>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002a6c:	9b05      	ldr	r3, [sp, #20]
 8002a6e:	3301      	adds	r3, #1
 8002a70:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002a72:	466b      	mov	r3, sp
 8002a74:	3306      	adds	r3, #6
 8002a76:	2212      	movs	r2, #18
 8002a78:	446a      	add	r2, sp
 8002a7a:	8812      	ldrh	r2, [r2, #0]
 8002a7c:	801a      	strh	r2, [r3, #0]
    delay = currdelta;
 8002a7e:	9b05      	ldr	r3, [sp, #20]
 8002a80:	9300      	str	r3, [sp, #0]
  while (true) {
 8002a82:	e7cd      	b.n	8002a20 <vt_set_alarm+0x30>
      break;
 8002a84:	46c0      	nop			@ (mov r8, r8)
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002a86:	9b05      	ldr	r3, [sp, #20]
 8002a88:	2b02      	cmp	r3, #2
 8002a8a:	d902      	bls.n	8002a92 <vt_set_alarm+0xa2>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002a8c:	2001      	movs	r0, #1
 8002a8e:	f7ff fb2f 	bl	80020f0 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002a92:	46c0      	nop			@ (mov r8, r8)
 8002a94:	b006      	add	sp, #24
 8002a96:	bd10      	pop	{r4, pc}
	...

08002aa0 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8002aa0:	b510      	push	{r4, lr}
 8002aa2:	b086      	sub	sp, #24
 8002aa4:	9003      	str	r0, [sp, #12]
 8002aa6:	9102      	str	r1, [sp, #8]
 8002aa8:	9300      	str	r3, [sp, #0]
 8002aaa:	466b      	mov	r3, sp
 8002aac:	3306      	adds	r3, #6
 8002aae:	801a      	strh	r2, [r3, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8002ab0:	9b03      	ldr	r3, [sp, #12]
 8002ab2:	466a      	mov	r2, sp
 8002ab4:	3206      	adds	r2, #6
 8002ab6:	8812      	ldrh	r2, [r2, #0]
 8002ab8:	819a      	strh	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8002aba:	9b03      	ldr	r3, [sp, #12]
 8002abc:	9902      	ldr	r1, [sp, #8]
 8002abe:	9a00      	ldr	r2, [sp, #0]
 8002ac0:	0018      	movs	r0, r3
 8002ac2:	f7ff fe75 	bl	80027b0 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002ac6:	2302      	movs	r3, #2
 8002ac8:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8002aca:	9a00      	ldr	r2, [sp, #0]
 8002acc:	9b05      	ldr	r3, [sp, #20]
 8002ace:	429a      	cmp	r2, r3
 8002ad0:	d202      	bcs.n	8002ad8 <vt_insert_first+0x38>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002ad2:	9b05      	ldr	r3, [sp, #20]
 8002ad4:	9300      	str	r3, [sp, #0]
 8002ad6:	e007      	b.n	8002ae8 <vt_insert_first+0x48>
  }
#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
  else if (delay > VT_MAX_DELAY) {
 8002ad8:	9a00      	ldr	r2, [sp, #0]
 8002ada:	23ff      	movs	r3, #255	@ 0xff
 8002adc:	021b      	lsls	r3, r3, #8
 8002ade:	429a      	cmp	r2, r3
 8002ae0:	d902      	bls.n	8002ae8 <vt_insert_first+0x48>
    /* The delta could be too large for the physical timer to handle
       this can happen when: sizeof (systime_t) < sizeof (sysinterval_t).*/
    delay = VT_MAX_DELAY;
 8002ae2:	23ff      	movs	r3, #255	@ 0xff
 8002ae4:	021b      	lsls	r3, r3, #8
 8002ae6:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 8002ae8:	9b03      	ldr	r3, [sp, #12]
 8002aea:	899b      	ldrh	r3, [r3, #12]
 8002aec:	9a00      	ldr	r2, [sp, #0]
 8002aee:	0011      	movs	r1, r2
 8002af0:	0018      	movs	r0, r3
 8002af2:	f7ff fe05 	bl	8002700 <chTimeAddX>
 8002af6:	0003      	movs	r3, r0
 8002af8:	0018      	movs	r0, r3
 8002afa:	f7ff ff21 	bl	8002940 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002afe:	2412      	movs	r4, #18
 8002b00:	446c      	add	r4, sp
 8002b02:	f7ff ff5d 	bl	80029c0 <chVTGetSystemTimeX.lto_priv.1>
 8002b06:	0003      	movs	r3, r0
 8002b08:	8023      	strh	r3, [r4, #0]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8002b0a:	2312      	movs	r3, #18
 8002b0c:	446b      	add	r3, sp
 8002b0e:	881a      	ldrh	r2, [r3, #0]
 8002b10:	466b      	mov	r3, sp
 8002b12:	3306      	adds	r3, #6
 8002b14:	881b      	ldrh	r3, [r3, #0]
 8002b16:	0011      	movs	r1, r2
 8002b18:	0018      	movs	r0, r3
 8002b1a:	f7ff fe11 	bl	8002740 <chTimeDiffX.lto_priv.0>
 8002b1e:	0002      	movs	r2, r0
 8002b20:	9b00      	ldr	r3, [sp, #0]
 8002b22:	429a      	cmp	r2, r3
 8002b24:	419b      	sbcs	r3, r3
 8002b26:	425b      	negs	r3, r3
 8002b28:	b2db      	uxtb	r3, r3
 8002b2a:	2b00      	cmp	r3, #0
 8002b2c:	d117      	bne.n	8002b5e <vt_insert_first+0xbe>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002b2e:	9b05      	ldr	r3, [sp, #20]
 8002b30:	3301      	adds	r3, #1
 8002b32:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8002b34:	9a05      	ldr	r2, [sp, #20]
 8002b36:	466b      	mov	r3, sp
 8002b38:	3306      	adds	r3, #6
 8002b3a:	881b      	ldrh	r3, [r3, #0]
 8002b3c:	0011      	movs	r1, r2
 8002b3e:	0018      	movs	r0, r3
 8002b40:	f7ff fdde 	bl	8002700 <chTimeAddX>
 8002b44:	0003      	movs	r3, r0
 8002b46:	0018      	movs	r0, r3
 8002b48:	f7ff ff12 	bl	8002970 <port_timer_set_alarm>

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002b4c:	466b      	mov	r3, sp
 8002b4e:	3306      	adds	r3, #6
 8002b50:	2212      	movs	r2, #18
 8002b52:	446a      	add	r2, sp
 8002b54:	8812      	ldrh	r2, [r2, #0]
 8002b56:	801a      	strh	r2, [r3, #0]
    delay = currdelta;
 8002b58:	9b05      	ldr	r3, [sp, #20]
 8002b5a:	9300      	str	r3, [sp, #0]
  while (true) {
 8002b5c:	e7cf      	b.n	8002afe <vt_insert_first+0x5e>
      break;
 8002b5e:	46c0      	nop			@ (mov r8, r8)
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002b60:	9b05      	ldr	r3, [sp, #20]
 8002b62:	2b02      	cmp	r3, #2
 8002b64:	d902      	bls.n	8002b6c <vt_insert_first+0xcc>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002b66:	2001      	movs	r0, #1
 8002b68:	f7ff fac2 	bl	80020f0 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002b6c:	46c0      	nop			@ (mov r8, r8)
 8002b6e:	b006      	add	sp, #24
 8002b70:	bd10      	pop	{r4, pc}
 8002b72:	46c0      	nop			@ (mov r8, r8)
	...

08002b80 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 8002b80:	b510      	push	{r4, lr}
 8002b82:	b088      	sub	sp, #32
 8002b84:	9003      	str	r0, [sp, #12]
 8002b86:	9102      	str	r1, [sp, #8]
 8002b88:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 8002b8a:	241a      	movs	r4, #26
 8002b8c:	446c      	add	r4, sp
 8002b8e:	f7ff ff17 	bl	80029c0 <chVTGetSystemTimeX.lto_priv.1>
 8002b92:	0003      	movs	r3, r0
 8002b94:	8023      	strh	r3, [r4, #0]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002b96:	9b03      	ldr	r3, [sp, #12]
 8002b98:	0018      	movs	r0, r3
 8002b9a:	f7ff fde9 	bl	8002770 <ch_dlist_isempty>
 8002b9e:	1e03      	subs	r3, r0, #0
 8002ba0:	d009      	beq.n	8002bb6 <vt_enqueue+0x36>

      vt_insert_first(vtlp, vtp, now, delay);
 8002ba2:	9c01      	ldr	r4, [sp, #4]
 8002ba4:	231a      	movs	r3, #26
 8002ba6:	446b      	add	r3, sp
 8002ba8:	881a      	ldrh	r2, [r3, #0]
 8002baa:	9902      	ldr	r1, [sp, #8]
 8002bac:	9803      	ldr	r0, [sp, #12]
 8002bae:	0023      	movs	r3, r4
 8002bb0:	f7ff ff76 	bl	8002aa0 <vt_insert_first>

      return;
 8002bb4:	e028      	b.n	8002c08 <vt_enqueue+0x88>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002bb6:	9b03      	ldr	r3, [sp, #12]
 8002bb8:	899a      	ldrh	r2, [r3, #12]
 8002bba:	231a      	movs	r3, #26
 8002bbc:	446b      	add	r3, sp
 8002bbe:	881b      	ldrh	r3, [r3, #0]
 8002bc0:	0019      	movs	r1, r3
 8002bc2:	0010      	movs	r0, r2
 8002bc4:	f7ff fdbc 	bl	8002740 <chTimeDiffX.lto_priv.0>
 8002bc8:	0003      	movs	r3, r0
 8002bca:	9305      	str	r3, [sp, #20]
    delta    = nowdelta + delay;
 8002bcc:	9a05      	ldr	r2, [sp, #20]
 8002bce:	9b01      	ldr	r3, [sp, #4]
 8002bd0:	18d3      	adds	r3, r2, r3
 8002bd2:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 8002bd4:	9a07      	ldr	r2, [sp, #28]
 8002bd6:	9b05      	ldr	r3, [sp, #20]
 8002bd8:	429a      	cmp	r2, r3
 8002bda:	d201      	bcs.n	8002be0 <vt_enqueue+0x60>
      delta = delay;
 8002bdc:	9b01      	ldr	r3, [sp, #4]
 8002bde:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8002be0:	9b03      	ldr	r3, [sp, #12]
 8002be2:	681b      	ldr	r3, [r3, #0]
 8002be4:	689b      	ldr	r3, [r3, #8]
 8002be6:	9a07      	ldr	r2, [sp, #28]
 8002be8:	429a      	cmp	r2, r3
 8002bea:	d207      	bcs.n	8002bfc <vt_enqueue+0x7c>

      vt_set_alarm(now, delay);
 8002bec:	9a01      	ldr	r2, [sp, #4]
 8002bee:	231a      	movs	r3, #26
 8002bf0:	446b      	add	r3, sp
 8002bf2:	881b      	ldrh	r3, [r3, #0]
 8002bf4:	0011      	movs	r1, r2
 8002bf6:	0018      	movs	r0, r3
 8002bf8:	f7ff fefa 	bl	80029f0 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8002bfc:	9b03      	ldr	r3, [sp, #12]
 8002bfe:	9902      	ldr	r1, [sp, #8]
 8002c00:	9a07      	ldr	r2, [sp, #28]
 8002c02:	0018      	movs	r0, r3
 8002c04:	f7ff fe14 	bl	8002830 <ch_dlist_insert>
}
 8002c08:	b008      	add	sp, #32
 8002c0a:	bd10      	pop	{r4, pc}
 8002c0c:	0000      	movs	r0, r0
	...

08002c10 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8002c10:	b500      	push	{lr}
 8002c12:	b087      	sub	sp, #28
 8002c14:	9003      	str	r0, [sp, #12]
 8002c16:	9102      	str	r1, [sp, #8]
 8002c18:	9201      	str	r2, [sp, #4]
 8002c1a:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002c1c:	4b18      	ldr	r3, [pc, #96]	@ (8002c80 <chVTDoSetI+0x70>)
 8002c1e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002c20:	f7ff fb96 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002c24:	9b03      	ldr	r3, [sp, #12]
 8002c26:	425a      	negs	r2, r3
 8002c28:	4153      	adcs	r3, r2
 8002c2a:	b2db      	uxtb	r3, r3
 8002c2c:	2b00      	cmp	r3, #0
 8002c2e:	d105      	bne.n	8002c3c <chVTDoSetI+0x2c>
 8002c30:	9b01      	ldr	r3, [sp, #4]
 8002c32:	425a      	negs	r2, r3
 8002c34:	4153      	adcs	r3, r2
 8002c36:	b2db      	uxtb	r3, r3
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	d001      	beq.n	8002c40 <chVTDoSetI+0x30>
 8002c3c:	2301      	movs	r3, #1
 8002c3e:	e000      	b.n	8002c42 <chVTDoSetI+0x32>
 8002c40:	2300      	movs	r3, #0
 8002c42:	2b00      	cmp	r3, #0
 8002c44:	d105      	bne.n	8002c52 <chVTDoSetI+0x42>
 8002c46:	9b02      	ldr	r3, [sp, #8]
 8002c48:	425a      	negs	r2, r3
 8002c4a:	4153      	adcs	r3, r2
 8002c4c:	b2db      	uxtb	r3, r3
 8002c4e:	2b00      	cmp	r3, #0
 8002c50:	d003      	beq.n	8002c5a <chVTDoSetI+0x4a>
 8002c52:	4b0c      	ldr	r3, [pc, #48]	@ (8002c84 <chVTDoSetI+0x74>)
 8002c54:	0018      	movs	r0, r3
 8002c56:	f7ff fa0b 	bl	8002070 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8002c5a:	9b03      	ldr	r3, [sp, #12]
 8002c5c:	9a00      	ldr	r2, [sp, #0]
 8002c5e:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 8002c60:	9b03      	ldr	r3, [sp, #12]
 8002c62:	9a01      	ldr	r2, [sp, #4]
 8002c64:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8002c66:	9b03      	ldr	r3, [sp, #12]
 8002c68:	2200      	movs	r2, #0
 8002c6a:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8002c6c:	9a02      	ldr	r2, [sp, #8]
 8002c6e:	9903      	ldr	r1, [sp, #12]
 8002c70:	9b05      	ldr	r3, [sp, #20]
 8002c72:	0018      	movs	r0, r3
 8002c74:	f7ff ff84 	bl	8002b80 <vt_enqueue>
}
 8002c78:	46c0      	nop			@ (mov r8, r8)
 8002c7a:	b007      	add	sp, #28
 8002c7c:	bd00      	pop	{pc}
 8002c7e:	46c0      	nop			@ (mov r8, r8)
 8002c80:	200006a0 	.word	0x200006a0
 8002c84:	0800510c 	.word	0x0800510c
	...

08002c90 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8002c90:	b510      	push	{r4, lr}
 8002c92:	b086      	sub	sp, #24
 8002c94:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002c96:	4b40      	ldr	r3, [pc, #256]	@ (8002d98 <chVTDoResetI+0x108>)
 8002c98:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002c9a:	f7ff fb59 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8002c9e:	9b01      	ldr	r3, [sp, #4]
 8002ca0:	425a      	negs	r2, r3
 8002ca2:	4153      	adcs	r3, r2
 8002ca4:	b2db      	uxtb	r3, r3
 8002ca6:	2b00      	cmp	r3, #0
 8002ca8:	d003      	beq.n	8002cb2 <chVTDoResetI+0x22>
 8002caa:	4b3c      	ldr	r3, [pc, #240]	@ (8002d9c <chVTDoResetI+0x10c>)
 8002cac:	0018      	movs	r0, r3
 8002cae:	f7ff f9df 	bl	8002070 <chSysHalt>
  chDbgAssert(chVTIsArmedI(vtp), "timer not armed");
 8002cb2:	9b01      	ldr	r3, [sp, #4]
 8002cb4:	0018      	movs	r0, r3
 8002cb6:	f7ff fe8b 	bl	80029d0 <chVTIsArmedI.lto_priv.0>
 8002cba:	0003      	movs	r3, r0
 8002cbc:	001a      	movs	r2, r3
 8002cbe:	2301      	movs	r3, #1
 8002cc0:	4053      	eors	r3, r2
 8002cc2:	b2db      	uxtb	r3, r3
 8002cc4:	2b00      	cmp	r3, #0
 8002cc6:	d003      	beq.n	8002cd0 <chVTDoResetI+0x40>
 8002cc8:	4b34      	ldr	r3, [pc, #208]	@ (8002d9c <chVTDoResetI+0x10c>)
 8002cca:	0018      	movs	r0, r3
 8002ccc:	f7ff f9d0 	bl	8002070 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8002cd0:	9b05      	ldr	r3, [sp, #20]
 8002cd2:	9a01      	ldr	r2, [sp, #4]
 8002cd4:	0011      	movs	r1, r2
 8002cd6:	0018      	movs	r0, r3
 8002cd8:	f7ff fd5a 	bl	8002790 <ch_dlist_isfirst>
 8002cdc:	0003      	movs	r3, r0
 8002cde:	001a      	movs	r2, r3
 8002ce0:	2301      	movs	r3, #1
 8002ce2:	4053      	eors	r3, r2
 8002ce4:	b2db      	uxtb	r3, r3
 8002ce6:	2b00      	cmp	r3, #0
 8002ce8:	d014      	beq.n	8002d14 <chVTDoResetI+0x84>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8002cea:	9b01      	ldr	r3, [sp, #4]
 8002cec:	0018      	movs	r0, r3
 8002cee:	f7ff fdf7 	bl	80028e0 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8002cf2:	9b01      	ldr	r3, [sp, #4]
 8002cf4:	681b      	ldr	r3, [r3, #0]
 8002cf6:	6899      	ldr	r1, [r3, #8]
 8002cf8:	9b01      	ldr	r3, [sp, #4]
 8002cfa:	689a      	ldr	r2, [r3, #8]
 8002cfc:	9b01      	ldr	r3, [sp, #4]
 8002cfe:	681b      	ldr	r3, [r3, #0]
 8002d00:	188a      	adds	r2, r1, r2
 8002d02:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8002d04:	9b01      	ldr	r3, [sp, #4]
 8002d06:	2200      	movs	r2, #0
 8002d08:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8002d0a:	9b05      	ldr	r3, [sp, #20]
 8002d0c:	2201      	movs	r2, #1
 8002d0e:	4252      	negs	r2, r2
 8002d10:	609a      	str	r2, [r3, #8]

    return;
 8002d12:	e03f      	b.n	8002d94 <chVTDoResetI+0x104>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8002d14:	9b05      	ldr	r3, [sp, #20]
 8002d16:	0018      	movs	r0, r3
 8002d18:	f7ff fdca 	bl	80028b0 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8002d1c:	9b01      	ldr	r3, [sp, #4]
 8002d1e:	2200      	movs	r2, #0
 8002d20:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002d22:	9b05      	ldr	r3, [sp, #20]
 8002d24:	0018      	movs	r0, r3
 8002d26:	f7ff fd23 	bl	8002770 <ch_dlist_isempty>
 8002d2a:	1e03      	subs	r3, r0, #0
 8002d2c:	d002      	beq.n	8002d34 <chVTDoResetI+0xa4>

    port_timer_stop_alarm();
 8002d2e:	f7ff fe17 	bl	8002960 <port_timer_stop_alarm>

    return;
 8002d32:	e02f      	b.n	8002d94 <chVTDoResetI+0x104>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8002d34:	9b05      	ldr	r3, [sp, #20]
 8002d36:	681b      	ldr	r3, [r3, #0]
 8002d38:	6899      	ldr	r1, [r3, #8]
 8002d3a:	9b01      	ldr	r3, [sp, #4]
 8002d3c:	689a      	ldr	r2, [r3, #8]
 8002d3e:	9b05      	ldr	r3, [sp, #20]
 8002d40:	681b      	ldr	r3, [r3, #0]
 8002d42:	188a      	adds	r2, r1, r2
 8002d44:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 8002d46:	2412      	movs	r4, #18
 8002d48:	446c      	add	r4, sp
 8002d4a:	f7ff fe39 	bl	80029c0 <chVTGetSystemTimeX.lto_priv.1>
 8002d4e:	0003      	movs	r3, r0
 8002d50:	8023      	strh	r3, [r4, #0]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002d52:	9b05      	ldr	r3, [sp, #20]
 8002d54:	899a      	ldrh	r2, [r3, #12]
 8002d56:	2312      	movs	r3, #18
 8002d58:	446b      	add	r3, sp
 8002d5a:	881b      	ldrh	r3, [r3, #0]
 8002d5c:	0019      	movs	r1, r3
 8002d5e:	0010      	movs	r0, r2
 8002d60:	f7ff fcee 	bl	8002740 <chTimeDiffX.lto_priv.0>
 8002d64:	0003      	movs	r3, r0
 8002d66:	9303      	str	r3, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8002d68:	9b05      	ldr	r3, [sp, #20]
 8002d6a:	681b      	ldr	r3, [r3, #0]
 8002d6c:	689b      	ldr	r3, [r3, #8]
 8002d6e:	9a03      	ldr	r2, [sp, #12]
 8002d70:	429a      	cmp	r2, r3
 8002d72:	d20e      	bcs.n	8002d92 <chVTDoResetI+0x102>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8002d74:	9b05      	ldr	r3, [sp, #20]
 8002d76:	681b      	ldr	r3, [r3, #0]
 8002d78:	689a      	ldr	r2, [r3, #8]
 8002d7a:	9b03      	ldr	r3, [sp, #12]
 8002d7c:	1ad3      	subs	r3, r2, r3
 8002d7e:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 8002d80:	9a02      	ldr	r2, [sp, #8]
 8002d82:	2312      	movs	r3, #18
 8002d84:	446b      	add	r3, sp
 8002d86:	881b      	ldrh	r3, [r3, #0]
 8002d88:	0011      	movs	r1, r2
 8002d8a:	0018      	movs	r0, r3
 8002d8c:	f7ff fe30 	bl	80029f0 <vt_set_alarm>
 8002d90:	e000      	b.n	8002d94 <chVTDoResetI+0x104>
    return;
 8002d92:	46c0      	nop			@ (mov r8, r8)
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002d94:	b006      	add	sp, #24
 8002d96:	bd10      	pop	{r4, pc}
 8002d98:	200006a0 	.word	0x200006a0
 8002d9c:	08005118 	.word	0x08005118

08002da0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8002da0:	b510      	push	{r4, lr}
 8002da2:	b088      	sub	sp, #32
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002da4:	4b5c      	ldr	r3, [pc, #368]	@ (8002f18 <chVTDoTickI+0x178>)
 8002da6:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002da8:	f7ff fad2 	bl	8002350 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8002dac:	9b05      	ldr	r3, [sp, #20]
 8002dae:	681b      	ldr	r3, [r3, #0]
 8002db0:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 8002db2:	240e      	movs	r4, #14
 8002db4:	446c      	add	r4, sp
 8002db6:	f7ff fe03 	bl	80029c0 <chVTGetSystemTimeX.lto_priv.1>
 8002dba:	0003      	movs	r3, r0
 8002dbc:	8023      	strh	r3, [r4, #0]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002dbe:	9b05      	ldr	r3, [sp, #20]
 8002dc0:	899a      	ldrh	r2, [r3, #12]
 8002dc2:	230e      	movs	r3, #14
 8002dc4:	446b      	add	r3, sp
 8002dc6:	881b      	ldrh	r3, [r3, #0]
 8002dc8:	0019      	movs	r1, r3
 8002dca:	0010      	movs	r0, r2
 8002dcc:	f7ff fcb8 	bl	8002740 <chTimeDiffX.lto_priv.0>
 8002dd0:	0003      	movs	r3, r0
 8002dd2:	9302      	str	r3, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 8002dd4:	9b04      	ldr	r3, [sp, #16]
 8002dd6:	689b      	ldr	r3, [r3, #8]
 8002dd8:	9a02      	ldr	r2, [sp, #8]
 8002dda:	429a      	cmp	r2, r3
 8002ddc:	d200      	bcs.n	8002de0 <chVTDoTickI+0x40>
 8002dde:	e078      	b.n	8002ed2 <chVTDoTickI+0x132>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 8002de0:	9b05      	ldr	r3, [sp, #20]
 8002de2:	899a      	ldrh	r2, [r3, #12]
 8002de4:	9b04      	ldr	r3, [sp, #16]
 8002de6:	689b      	ldr	r3, [r3, #8]
 8002de8:	4669      	mov	r1, sp
 8002dea:	1d8c      	adds	r4, r1, #6
 8002dec:	0019      	movs	r1, r3
 8002dee:	0010      	movs	r0, r2
 8002df0:	f7ff fc86 	bl	8002700 <chTimeAddX>
 8002df4:	0003      	movs	r3, r0
 8002df6:	8023      	strh	r3, [r4, #0]
    vtlp->lasttime = lasttime;
 8002df8:	9b05      	ldr	r3, [sp, #20]
 8002dfa:	466a      	mov	r2, sp
 8002dfc:	3206      	adds	r2, #6
 8002dfe:	8812      	ldrh	r2, [r2, #0]
 8002e00:	819a      	strh	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8002e02:	9b04      	ldr	r3, [sp, #16]
 8002e04:	0018      	movs	r0, r3
 8002e06:	f7ff fd6b 	bl	80028e0 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8002e0a:	9b04      	ldr	r3, [sp, #16]
 8002e0c:	2200      	movs	r2, #0
 8002e0e:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002e10:	9b05      	ldr	r3, [sp, #20]
 8002e12:	0018      	movs	r0, r3
 8002e14:	f7ff fcac 	bl	8002770 <ch_dlist_isempty>
 8002e18:	1e03      	subs	r3, r0, #0
 8002e1a:	d001      	beq.n	8002e20 <chVTDoTickI+0x80>
      port_timer_stop_alarm();
 8002e1c:	f7ff fda0 	bl	8002960 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 8002e20:	f7ff fdc6 	bl	80029b0 <chSysUnlockFromISR.lto_priv.3>

    vtp->func(vtp, vtp->par);
 8002e24:	9b04      	ldr	r3, [sp, #16]
 8002e26:	68da      	ldr	r2, [r3, #12]
 8002e28:	9b04      	ldr	r3, [sp, #16]
 8002e2a:	6919      	ldr	r1, [r3, #16]
 8002e2c:	9b04      	ldr	r3, [sp, #16]
 8002e2e:	0018      	movs	r0, r3
 8002e30:	4790      	blx	r2

    chSysLockFromISR();
 8002e32:	f7ff fdb5 	bl	80029a0 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8002e36:	9b04      	ldr	r3, [sp, #16]
 8002e38:	695b      	ldr	r3, [r3, #20]
 8002e3a:	1e5a      	subs	r2, r3, #1
 8002e3c:	4193      	sbcs	r3, r2
 8002e3e:	b2db      	uxtb	r3, r3
 8002e40:	2b00      	cmp	r3, #0
 8002e42:	d0b3      	beq.n	8002dac <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8002e44:	240e      	movs	r4, #14
 8002e46:	446c      	add	r4, sp
 8002e48:	f7ff fdba 	bl	80029c0 <chVTGetSystemTimeX.lto_priv.1>
 8002e4c:	0003      	movs	r3, r0
 8002e4e:	8023      	strh	r3, [r4, #0]
      nowdelta = chTimeDiffX(lasttime, now);
 8002e50:	230e      	movs	r3, #14
 8002e52:	446b      	add	r3, sp
 8002e54:	881a      	ldrh	r2, [r3, #0]
 8002e56:	466b      	mov	r3, sp
 8002e58:	3306      	adds	r3, #6
 8002e5a:	881b      	ldrh	r3, [r3, #0]
 8002e5c:	0011      	movs	r1, r2
 8002e5e:	0018      	movs	r0, r3
 8002e60:	f7ff fc6e 	bl	8002740 <chTimeDiffX.lto_priv.0>
 8002e64:	0003      	movs	r3, r0
 8002e66:	9302      	str	r3, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8002e68:	9b04      	ldr	r3, [sp, #16]
 8002e6a:	695b      	ldr	r3, [r3, #20]
 8002e6c:	9a02      	ldr	r2, [sp, #8]
 8002e6e:	429a      	cmp	r2, r3
 8002e70:	d909      	bls.n	8002e86 <chVTDoTickI+0xe6>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
 8002e72:	4b2a      	ldr	r3, [pc, #168]	@ (8002f1c <chVTDoTickI+0x17c>)
 8002e74:	0018      	movs	r0, r3
 8002e76:	f7ff f8fb 	bl	8002070 <chSysHalt>
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8002e7a:	2002      	movs	r0, #2
 8002e7c:	f7ff f938 	bl	80020f0 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8002e80:	2300      	movs	r3, #0
 8002e82:	9306      	str	r3, [sp, #24]
 8002e84:	e004      	b.n	8002e90 <chVTDoTickI+0xf0>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 8002e86:	9b04      	ldr	r3, [sp, #16]
 8002e88:	695a      	ldr	r2, [r3, #20]
 8002e8a:	9b02      	ldr	r3, [sp, #8]
 8002e8c:	1ad3      	subs	r3, r2, r3
 8002e8e:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8002e90:	9b05      	ldr	r3, [sp, #20]
 8002e92:	0018      	movs	r0, r3
 8002e94:	f7ff fc6c 	bl	8002770 <ch_dlist_isempty>
 8002e98:	1e03      	subs	r3, r0, #0
 8002e9a:	d009      	beq.n	8002eb0 <chVTDoTickI+0x110>

        vt_insert_first(vtlp, vtp, now, delay);
 8002e9c:	9c06      	ldr	r4, [sp, #24]
 8002e9e:	230e      	movs	r3, #14
 8002ea0:	446b      	add	r3, sp
 8002ea2:	881a      	ldrh	r2, [r3, #0]
 8002ea4:	9904      	ldr	r1, [sp, #16]
 8002ea6:	9805      	ldr	r0, [sp, #20]
 8002ea8:	0023      	movs	r3, r4
 8002eaa:	f7ff fdf9 	bl	8002aa0 <vt_insert_first>

        return;
 8002eae:	e030      	b.n	8002f12 <chVTDoTickI+0x172>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8002eb0:	9a02      	ldr	r2, [sp, #8]
 8002eb2:	9b06      	ldr	r3, [sp, #24]
 8002eb4:	18d3      	adds	r3, r2, r3
 8002eb6:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 8002eb8:	9a07      	ldr	r2, [sp, #28]
 8002eba:	9b02      	ldr	r3, [sp, #8]
 8002ebc:	429a      	cmp	r2, r3
 8002ebe:	d201      	bcs.n	8002ec4 <chVTDoTickI+0x124>
        delta = delay;
 8002ec0:	9b06      	ldr	r3, [sp, #24]
 8002ec2:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8002ec4:	9b05      	ldr	r3, [sp, #20]
 8002ec6:	9904      	ldr	r1, [sp, #16]
 8002ec8:	9a07      	ldr	r2, [sp, #28]
 8002eca:	0018      	movs	r0, r3
 8002ecc:	f7ff fcb0 	bl	8002830 <ch_dlist_insert>
  while (true) {
 8002ed0:	e76c      	b.n	8002dac <chVTDoTickI+0xc>
      break;
 8002ed2:	46c0      	nop			@ (mov r8, r8)
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002ed4:	9b05      	ldr	r3, [sp, #20]
 8002ed6:	0018      	movs	r0, r3
 8002ed8:	f7ff fc4a 	bl	8002770 <ch_dlist_isempty>
 8002edc:	1e03      	subs	r3, r0, #0
 8002ede:	d117      	bne.n	8002f10 <chVTDoTickI+0x170>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 8002ee0:	9b05      	ldr	r3, [sp, #20]
 8002ee2:	899a      	ldrh	r2, [r3, #12]
 8002ee4:	9b02      	ldr	r3, [sp, #8]
 8002ee6:	b29b      	uxth	r3, r3
 8002ee8:	18d3      	adds	r3, r2, r3
 8002eea:	b29a      	uxth	r2, r3
 8002eec:	9b05      	ldr	r3, [sp, #20]
 8002eee:	819a      	strh	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 8002ef0:	9b04      	ldr	r3, [sp, #16]
 8002ef2:	689a      	ldr	r2, [r3, #8]
 8002ef4:	9b02      	ldr	r3, [sp, #8]
 8002ef6:	1ad2      	subs	r2, r2, r3
 8002ef8:	9b04      	ldr	r3, [sp, #16]
 8002efa:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 8002efc:	9b04      	ldr	r3, [sp, #16]
 8002efe:	689a      	ldr	r2, [r3, #8]
 8002f00:	230e      	movs	r3, #14
 8002f02:	446b      	add	r3, sp
 8002f04:	881b      	ldrh	r3, [r3, #0]
 8002f06:	0011      	movs	r1, r2
 8002f08:	0018      	movs	r0, r3
 8002f0a:	f7ff fd71 	bl	80029f0 <vt_set_alarm>
 8002f0e:	e000      	b.n	8002f12 <chVTDoTickI+0x172>
    return;
 8002f10:	46c0      	nop			@ (mov r8, r8)
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002f12:	b008      	add	sp, #32
 8002f14:	bd10      	pop	{r4, pc}
 8002f16:	46c0      	nop			@ (mov r8, r8)
 8002f18:	200006a0 	.word	0x200006a0
 8002f1c:	08005128 	.word	0x08005128

08002f20 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8002f20:	b082      	sub	sp, #8
 8002f22:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8002f24:	9b01      	ldr	r3, [sp, #4]
 8002f26:	685b      	ldr	r3, [r3, #4]
 8002f28:	9a01      	ldr	r2, [sp, #4]
 8002f2a:	6812      	ldr	r2, [r2, #0]
 8002f2c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8002f2e:	9b01      	ldr	r3, [sp, #4]
 8002f30:	681b      	ldr	r3, [r3, #0]
 8002f32:	9a01      	ldr	r2, [sp, #4]
 8002f34:	6852      	ldr	r2, [r2, #4]
 8002f36:	605a      	str	r2, [r3, #4]
  return p;
 8002f38:	9b01      	ldr	r3, [sp, #4]
}
 8002f3a:	0018      	movs	r0, r3
 8002f3c:	b002      	add	sp, #8
 8002f3e:	4770      	bx	lr

08002f40 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 8002f40:	b084      	sub	sp, #16
 8002f42:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 8002f44:	9b01      	ldr	r3, [sp, #4]
 8002f46:	681b      	ldr	r3, [r3, #0]
 8002f48:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 8002f4a:	9b03      	ldr	r3, [sp, #12]
 8002f4c:	681a      	ldr	r2, [r3, #0]
 8002f4e:	9b01      	ldr	r3, [sp, #4]
 8002f50:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 8002f52:	9b01      	ldr	r3, [sp, #4]
 8002f54:	681b      	ldr	r3, [r3, #0]
 8002f56:	9a01      	ldr	r2, [sp, #4]
 8002f58:	605a      	str	r2, [r3, #4]
  return p;
 8002f5a:	9b03      	ldr	r3, [sp, #12]
}
 8002f5c:	0018      	movs	r0, r3
 8002f5e:	b004      	add	sp, #16
 8002f60:	4770      	bx	lr
 8002f62:	46c0      	nop			@ (mov r8, r8)
	...

08002f70 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8002f70:	b082      	sub	sp, #8
 8002f72:	9001      	str	r0, [sp, #4]
 8002f74:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8002f76:	9b01      	ldr	r3, [sp, #4]
 8002f78:	681b      	ldr	r3, [r3, #0]
 8002f7a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 8002f7c:	9b01      	ldr	r3, [sp, #4]
 8002f7e:	6899      	ldr	r1, [r3, #8]
 8002f80:	9b00      	ldr	r3, [sp, #0]
 8002f82:	689a      	ldr	r2, [r3, #8]
 8002f84:	2300      	movs	r3, #0
 8002f86:	4291      	cmp	r1, r2
 8002f88:	415b      	adcs	r3, r3
 8002f8a:	b2db      	uxtb	r3, r3
 8002f8c:	2b00      	cmp	r3, #0
 8002f8e:	d1f2      	bne.n	8002f76 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8002f90:	9b00      	ldr	r3, [sp, #0]
 8002f92:	9a01      	ldr	r2, [sp, #4]
 8002f94:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8002f96:	9b01      	ldr	r3, [sp, #4]
 8002f98:	685a      	ldr	r2, [r3, #4]
 8002f9a:	9b00      	ldr	r3, [sp, #0]
 8002f9c:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8002f9e:	9b00      	ldr	r3, [sp, #0]
 8002fa0:	685b      	ldr	r3, [r3, #4]
 8002fa2:	9a00      	ldr	r2, [sp, #0]
 8002fa4:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8002fa6:	9b01      	ldr	r3, [sp, #4]
 8002fa8:	9a00      	ldr	r2, [sp, #0]
 8002faa:	605a      	str	r2, [r3, #4]
  return p;
 8002fac:	9b00      	ldr	r3, [sp, #0]
}
 8002fae:	0018      	movs	r0, r3
 8002fb0:	b002      	add	sp, #8
 8002fb2:	4770      	bx	lr
	...

08002fc0 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8002fc0:	b082      	sub	sp, #8
 8002fc2:	9001      	str	r0, [sp, #4]
 8002fc4:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8002fc6:	9b01      	ldr	r3, [sp, #4]
 8002fc8:	681b      	ldr	r3, [r3, #0]
 8002fca:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 8002fcc:	9b01      	ldr	r3, [sp, #4]
 8002fce:	689a      	ldr	r2, [r3, #8]
 8002fd0:	9b00      	ldr	r3, [sp, #0]
 8002fd2:	689b      	ldr	r3, [r3, #8]
 8002fd4:	4293      	cmp	r3, r2
 8002fd6:	419b      	sbcs	r3, r3
 8002fd8:	425b      	negs	r3, r3
 8002fda:	b2db      	uxtb	r3, r3
 8002fdc:	2b00      	cmp	r3, #0
 8002fde:	d1f2      	bne.n	8002fc6 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 8002fe0:	9b00      	ldr	r3, [sp, #0]
 8002fe2:	9a01      	ldr	r2, [sp, #4]
 8002fe4:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8002fe6:	9b01      	ldr	r3, [sp, #4]
 8002fe8:	685a      	ldr	r2, [r3, #4]
 8002fea:	9b00      	ldr	r3, [sp, #0]
 8002fec:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8002fee:	9b00      	ldr	r3, [sp, #0]
 8002ff0:	685b      	ldr	r3, [r3, #4]
 8002ff2:	9a00      	ldr	r2, [sp, #0]
 8002ff4:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8002ff6:	9b01      	ldr	r3, [sp, #4]
 8002ff8:	9a00      	ldr	r2, [sp, #0]
 8002ffa:	605a      	str	r2, [r3, #4]
  return p;
 8002ffc:	9b00      	ldr	r3, [sp, #0]
}
 8002ffe:	0018      	movs	r0, r3
 8003000:	b002      	add	sp, #8
 8003002:	4770      	bx	lr
	...

08003010 <port_lock.lto_priv.11>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003010:	b672      	cpsid	i
}
 8003012:	46c0      	nop			@ (mov r8, r8)
}
 8003014:	46c0      	nop			@ (mov r8, r8)
 8003016:	4770      	bx	lr
	...

08003020 <port_unlock.lto_priv.11>:
  __ASM volatile ("cpsie i" : : : "memory");
 8003020:	b662      	cpsie	i
}
 8003022:	46c0      	nop			@ (mov r8, r8)
}
 8003024:	46c0      	nop			@ (mov r8, r8)
 8003026:	4770      	bx	lr
	...

08003030 <port_lock_from_isr.lto_priv.6>:
static inline void port_lock_from_isr(void) {
 8003030:	b510      	push	{r4, lr}
  port_lock();
 8003032:	f7ff ffed 	bl	8003010 <port_lock.lto_priv.11>
}
 8003036:	46c0      	nop			@ (mov r8, r8)
 8003038:	bd10      	pop	{r4, pc}
 800303a:	46c0      	nop			@ (mov r8, r8)
 800303c:	0000      	movs	r0, r0
	...

08003040 <port_unlock_from_isr.lto_priv.6>:
static inline void port_unlock_from_isr(void) {
 8003040:	b510      	push	{r4, lr}
  port_unlock();
 8003042:	f7ff ffed 	bl	8003020 <port_unlock.lto_priv.11>
}
 8003046:	46c0      	nop			@ (mov r8, r8)
 8003048:	bd10      	pop	{r4, pc}
 800304a:	46c0      	nop			@ (mov r8, r8)
 800304c:	0000      	movs	r0, r0
	...

08003050 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 8003050:	b510      	push	{r4, lr}
  port_lock_from_isr();
 8003052:	f7ff ffed 	bl	8003030 <port_lock_from_isr.lto_priv.6>
  __dbg_check_lock_from_isr();
 8003056:	f7ff f8cb 	bl	80021f0 <__dbg_check_lock_from_isr>
}
 800305a:	46c0      	nop			@ (mov r8, r8)
 800305c:	bd10      	pop	{r4, pc}
 800305e:	46c0      	nop			@ (mov r8, r8)

08003060 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 8003060:	b510      	push	{r4, lr}
  __dbg_check_unlock_from_isr();
 8003062:	f7ff f8ed 	bl	8002240 <__dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8003066:	f7ff ffeb 	bl	8003040 <port_unlock_from_isr.lto_priv.6>
}
 800306a:	46c0      	nop			@ (mov r8, r8)
 800306c:	bd10      	pop	{r4, pc}
 800306e:	46c0      	nop			@ (mov r8, r8)

08003070 <chVTIsArmedI.lto_priv.1>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8003070:	b500      	push	{lr}
 8003072:	b083      	sub	sp, #12
 8003074:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8003076:	f7ff f96b 	bl	8002350 <chDbgCheckClassI>
  return (bool)(vtp->dlist.next != NULL);
 800307a:	9b01      	ldr	r3, [sp, #4]
 800307c:	681b      	ldr	r3, [r3, #0]
 800307e:	1e5a      	subs	r2, r3, #1
 8003080:	4193      	sbcs	r3, r2
 8003082:	b2db      	uxtb	r3, r3
}
 8003084:	0018      	movs	r0, r3
 8003086:	b003      	add	sp, #12
 8003088:	bd00      	pop	{pc}
 800308a:	46c0      	nop			@ (mov r8, r8)
 800308c:	0000      	movs	r0, r0
	...

08003090 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8003090:	b500      	push	{lr}
 8003092:	b083      	sub	sp, #12
 8003094:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003096:	f7ff f95b 	bl	8002350 <chDbgCheckClassI>

  sp->cnt++;
 800309a:	9b01      	ldr	r3, [sp, #4]
 800309c:	689b      	ldr	r3, [r3, #8]
 800309e:	1c5a      	adds	r2, r3, #1
 80030a0:	9b01      	ldr	r3, [sp, #4]
 80030a2:	609a      	str	r2, [r3, #8]
}
 80030a4:	46c0      	nop			@ (mov r8, r8)
 80030a6:	b003      	add	sp, #12
 80030a8:	bd00      	pop	{pc}
 80030aa:	46c0      	nop			@ (mov r8, r8)
 80030ac:	0000      	movs	r0, r0
	...

080030b0 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 80030b0:	b500      	push	{lr}
 80030b2:	b083      	sub	sp, #12
 80030b4:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 80030b6:	9b01      	ldr	r3, [sp, #4]
 80030b8:	2224      	movs	r2, #36	@ 0x24
 80030ba:	5c9b      	ldrb	r3, [r3, r2]
 80030bc:	425a      	negs	r2, r3
 80030be:	4153      	adcs	r3, r2
 80030c0:	b2db      	uxtb	r3, r3
 80030c2:	2b00      	cmp	r3, #0
 80030c4:	d108      	bne.n	80030d8 <__sch_ready_behind+0x28>
 80030c6:	9b01      	ldr	r3, [sp, #4]
 80030c8:	2224      	movs	r2, #36	@ 0x24
 80030ca:	5c9b      	ldrb	r3, [r3, r2]
 80030cc:	3b0f      	subs	r3, #15
 80030ce:	425a      	negs	r2, r3
 80030d0:	4153      	adcs	r3, r2
 80030d2:	b2db      	uxtb	r3, r3
 80030d4:	2b00      	cmp	r3, #0
 80030d6:	d003      	beq.n	80030e0 <__sch_ready_behind+0x30>
 80030d8:	4b0d      	ldr	r3, [pc, #52]	@ (8003110 <__sch_ready_behind+0x60>)
 80030da:	0018      	movs	r0, r3
 80030dc:	f7fe ffc8 	bl	8002070 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 80030e0:	9b01      	ldr	r3, [sp, #4]
 80030e2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80030e4:	9b01      	ldr	r3, [sp, #4]
 80030e6:	0011      	movs	r1, r2
 80030e8:	0018      	movs	r0, r3
 80030ea:	f7ff f9f9 	bl	80024e0 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80030ee:	9b01      	ldr	r3, [sp, #4]
 80030f0:	2224      	movs	r2, #36	@ 0x24
 80030f2:	2100      	movs	r1, #0
 80030f4:	5499      	strb	r1, [r3, r2]

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80030f6:	9b01      	ldr	r3, [sp, #4]
 80030f8:	699b      	ldr	r3, [r3, #24]
 80030fa:	001a      	movs	r2, r3
 80030fc:	9b01      	ldr	r3, [sp, #4]
 80030fe:	0019      	movs	r1, r3
 8003100:	0010      	movs	r0, r2
 8003102:	f7ff ff35 	bl	8002f70 <ch_pqueue_insert_behind>
 8003106:	0003      	movs	r3, r0
                                           &tp->hdr.pqueue));
}
 8003108:	0018      	movs	r0, r3
 800310a:	b003      	add	sp, #12
 800310c:	bd00      	pop	{pc}
 800310e:	46c0      	nop			@ (mov r8, r8)
 8003110:	08005168 	.word	0x08005168
	...

08003120 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8003120:	b500      	push	{lr}
 8003122:	b083      	sub	sp, #12
 8003124:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003126:	9b01      	ldr	r3, [sp, #4]
 8003128:	2224      	movs	r2, #36	@ 0x24
 800312a:	5c9b      	ldrb	r3, [r3, r2]
 800312c:	425a      	negs	r2, r3
 800312e:	4153      	adcs	r3, r2
 8003130:	b2db      	uxtb	r3, r3
 8003132:	2b00      	cmp	r3, #0
 8003134:	d108      	bne.n	8003148 <__sch_ready_ahead+0x28>
 8003136:	9b01      	ldr	r3, [sp, #4]
 8003138:	2224      	movs	r2, #36	@ 0x24
 800313a:	5c9b      	ldrb	r3, [r3, r2]
 800313c:	3b0f      	subs	r3, #15
 800313e:	425a      	negs	r2, r3
 8003140:	4153      	adcs	r3, r2
 8003142:	b2db      	uxtb	r3, r3
 8003144:	2b00      	cmp	r3, #0
 8003146:	d003      	beq.n	8003150 <__sch_ready_ahead+0x30>
 8003148:	4b0d      	ldr	r3, [pc, #52]	@ (8003180 <__sch_ready_ahead+0x60>)
 800314a:	0018      	movs	r0, r3
 800314c:	f7fe ff90 	bl	8002070 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 8003150:	9b01      	ldr	r3, [sp, #4]
 8003152:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8003154:	9b01      	ldr	r3, [sp, #4]
 8003156:	0011      	movs	r1, r2
 8003158:	0018      	movs	r0, r3
 800315a:	f7ff f9c1 	bl	80024e0 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 800315e:	9b01      	ldr	r3, [sp, #4]
 8003160:	2224      	movs	r2, #36	@ 0x24
 8003162:	2100      	movs	r1, #0
 8003164:	5499      	strb	r1, [r3, r2]

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8003166:	9b01      	ldr	r3, [sp, #4]
 8003168:	699b      	ldr	r3, [r3, #24]
 800316a:	001a      	movs	r2, r3
 800316c:	9b01      	ldr	r3, [sp, #4]
 800316e:	0019      	movs	r1, r3
 8003170:	0010      	movs	r0, r2
 8003172:	f7ff ff25 	bl	8002fc0 <ch_pqueue_insert_ahead>
 8003176:	0003      	movs	r3, r0
                                          &tp->hdr.pqueue));
}
 8003178:	0018      	movs	r0, r3
 800317a:	b003      	add	sp, #12
 800317c:	bd00      	pop	{pc}
 800317e:	46c0      	nop			@ (mov r8, r8)
 8003180:	0800517c 	.word	0x0800517c
	...

08003190 <__sch_reschedule_ahead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @notapi
 */
static void __sch_reschedule_ahead(void) {
 8003190:	b500      	push	{lr}
 8003192:	b087      	sub	sp, #28
  os_instance_t *oip = currcore;
 8003194:	4b1b      	ldr	r3, [pc, #108]	@ (8003204 <__sch_reschedule_ahead+0x74>)
 8003196:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 8003198:	9b05      	ldr	r3, [sp, #20]
 800319a:	68db      	ldr	r3, [r3, #12]
 800319c:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800319e:	9b05      	ldr	r3, [sp, #20]
 80031a0:	0018      	movs	r0, r3
 80031a2:	f7ff fecd 	bl	8002f40 <ch_pqueue_remove_highest>
 80031a6:	0003      	movs	r3, r0
 80031a8:	9303      	str	r3, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 80031aa:	9b03      	ldr	r3, [sp, #12]
 80031ac:	2224      	movs	r2, #36	@ 0x24
 80031ae:	2101      	movs	r1, #1
 80031b0:	5499      	strb	r1, [r3, r2]
  __instance_set_currthread(oip, ntp);
 80031b2:	9b05      	ldr	r3, [sp, #20]
 80031b4:	9a03      	ldr	r2, [sp, #12]
 80031b6:	60da      	str	r2, [r3, #12]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = __sch_ready_ahead(otp);
 80031b8:	9b04      	ldr	r3, [sp, #16]
 80031ba:	0018      	movs	r0, r3
 80031bc:	f7ff ffb0 	bl	8003120 <__sch_ready_ahead>
 80031c0:	0003      	movs	r3, r0
 80031c2:	9304      	str	r3, [sp, #16]

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80031c4:	9a04      	ldr	r2, [sp, #16]
 80031c6:	9b03      	ldr	r3, [sp, #12]
 80031c8:	0011      	movs	r1, r2
 80031ca:	0018      	movs	r0, r3
 80031cc:	f7ff f9c8 	bl	8002560 <__trace_switch>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80031d0:	f3ef 8309 	mrs	r3, PSP
 80031d4:	9301      	str	r3, [sp, #4]
  return(result);
 80031d6:	9b01      	ldr	r3, [sp, #4]
 80031d8:	9302      	str	r3, [sp, #8]
 80031da:	9b02      	ldr	r3, [sp, #8]
 80031dc:	3b24      	subs	r3, #36	@ 0x24
 80031de:	001a      	movs	r2, r3
 80031e0:	9b04      	ldr	r3, [sp, #16]
 80031e2:	6a1b      	ldr	r3, [r3, #32]
 80031e4:	429a      	cmp	r2, r3
 80031e6:	d203      	bcs.n	80031f0 <__sch_reschedule_ahead+0x60>
 80031e8:	4b07      	ldr	r3, [pc, #28]	@ (8003208 <__sch_reschedule_ahead+0x78>)
 80031ea:	0018      	movs	r0, r3
 80031ec:	f7fe ff40 	bl	8002070 <chSysHalt>
 80031f0:	9a04      	ldr	r2, [sp, #16]
 80031f2:	9b03      	ldr	r3, [sp, #12]
 80031f4:	0011      	movs	r1, r2
 80031f6:	0018      	movs	r0, r3
 80031f8:	f7fc ffce 	bl	8000198 <__port_switch>
}
 80031fc:	46c0      	nop			@ (mov r8, r8)
 80031fe:	b007      	add	sp, #28
 8003200:	bd00      	pop	{pc}
 8003202:	46c0      	nop			@ (mov r8, r8)
 8003204:	20000690 	.word	0x20000690
 8003208:	08005088 	.word	0x08005088
 800320c:	00000000 	.word	0x00000000

08003210 <__sch_wakeup>:

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8003210:	b500      	push	{lr}
 8003212:	b085      	sub	sp, #20
 8003214:	9001      	str	r0, [sp, #4]
 8003216:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 8003218:	9b00      	ldr	r3, [sp, #0]
 800321a:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 800321c:	f7ff ff18 	bl	8003050 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
 8003220:	9b03      	ldr	r3, [sp, #12]
 8003222:	2224      	movs	r2, #36	@ 0x24
 8003224:	5c9b      	ldrb	r3, [r3, r2]
 8003226:	2b0c      	cmp	r3, #12
 8003228:	d816      	bhi.n	8003258 <__sch_wakeup+0x48>
 800322a:	009a      	lsls	r2, r3, #2
 800322c:	4b11      	ldr	r3, [pc, #68]	@ (8003274 <__sch_wakeup+0x64>)
 800322e:	18d3      	adds	r3, r2, r3
 8003230:	681b      	ldr	r3, [r3, #0]
 8003232:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8003234:	f7ff ff14 	bl	8003060 <chSysUnlockFromISR.lto_priv.4>
    return;
 8003238:	e01a      	b.n	8003270 <__sch_wakeup+0x60>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800323a:	9b03      	ldr	r3, [sp, #12]
 800323c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800323e:	2200      	movs	r2, #0
 8003240:	601a      	str	r2, [r3, #0]
    break;
 8003242:	e00a      	b.n	800325a <__sch_wakeup+0x4a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8003244:	9b03      	ldr	r3, [sp, #12]
 8003246:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003248:	0018      	movs	r0, r3
 800324a:	f7ff ff21 	bl	8003090 <chSemFastSignalI.lto_priv.0>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 800324e:	9b03      	ldr	r3, [sp, #12]
 8003250:	0018      	movs	r0, r3
 8003252:	f7ff fe65 	bl	8002f20 <ch_queue_dequeue.lto_priv.0>
    break;
 8003256:	e000      	b.n	800325a <__sch_wakeup+0x4a>
  default:
    /* Any other state, nothing to do.*/
    break;
 8003258:	46c0      	nop			@ (mov r8, r8)
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 800325a:	9b03      	ldr	r3, [sp, #12]
 800325c:	2201      	movs	r2, #1
 800325e:	4252      	negs	r2, r2
 8003260:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 8003262:	9b03      	ldr	r3, [sp, #12]
 8003264:	0018      	movs	r0, r3
 8003266:	f7ff ff23 	bl	80030b0 <__sch_ready_behind>
  chSysUnlockFromISR();
 800326a:	f7ff fef9 	bl	8003060 <chSysUnlockFromISR.lto_priv.4>

  return;
 800326e:	46c0      	nop			@ (mov r8, r8)
}
 8003270:	b005      	add	sp, #20
 8003272:	bd00      	pop	{pc}
 8003274:	08005134 	.word	0x08005134
	...

08003280 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003280:	b500      	push	{lr}
 8003282:	b083      	sub	sp, #12
 8003284:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003286:	f7ff f863 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800328a:	9b01      	ldr	r3, [sp, #4]
 800328c:	425a      	negs	r2, r3
 800328e:	4153      	adcs	r3, r2
 8003290:	b2db      	uxtb	r3, r3
 8003292:	2b00      	cmp	r3, #0
 8003294:	d003      	beq.n	800329e <chSchReadyI+0x1e>
 8003296:	4b06      	ldr	r3, [pc, #24]	@ (80032b0 <chSchReadyI+0x30>)
 8003298:	0018      	movs	r0, r3
 800329a:	f7fe fee9 	bl	8002070 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 800329e:	9b01      	ldr	r3, [sp, #4]
 80032a0:	0018      	movs	r0, r3
 80032a2:	f7ff ff05 	bl	80030b0 <__sch_ready_behind>
 80032a6:	0003      	movs	r3, r0
}
 80032a8:	0018      	movs	r0, r3
 80032aa:	b003      	add	sp, #12
 80032ac:	bd00      	pop	{pc}
 80032ae:	46c0      	nop			@ (mov r8, r8)
 80032b0:	08005190 	.word	0x08005190
	...

080032c0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80032c0:	b500      	push	{lr}
 80032c2:	b089      	sub	sp, #36	@ 0x24
 80032c4:	0002      	movs	r2, r0
 80032c6:	466b      	mov	r3, sp
 80032c8:	3307      	adds	r3, #7
 80032ca:	701a      	strb	r2, [r3, #0]
  os_instance_t *oip = currcore;
 80032cc:	4b29      	ldr	r3, [pc, #164]	@ (8003374 <chSchGoSleepS+0xb4>)
 80032ce:	9307      	str	r3, [sp, #28]
  thread_t *otp = __instance_get_currthread(oip);
 80032d0:	9b07      	ldr	r3, [sp, #28]
 80032d2:	68db      	ldr	r3, [r3, #12]
 80032d4:	9306      	str	r3, [sp, #24]
  thread_t *ntp;

  chDbgCheckClassS();
 80032d6:	f7ff f85b 	bl	8002390 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 80032da:	f7fe fee1 	bl	80020a0 <chSysGetIdleThreadX>
 80032de:	0002      	movs	r2, r0
 80032e0:	9b06      	ldr	r3, [sp, #24]
 80032e2:	1a9b      	subs	r3, r3, r2
 80032e4:	425a      	negs	r2, r3
 80032e6:	4153      	adcs	r3, r2
 80032e8:	b2db      	uxtb	r3, r3
 80032ea:	2b00      	cmp	r3, #0
 80032ec:	d003      	beq.n	80032f6 <chSchGoSleepS+0x36>
 80032ee:	4b22      	ldr	r3, [pc, #136]	@ (8003378 <chSchGoSleepS+0xb8>)
 80032f0:	0018      	movs	r0, r3
 80032f2:	f7fe febd 	bl	8002070 <chSysHalt>
  chDbgAssert(otp->owner == oip, "invalid core");
 80032f6:	9b06      	ldr	r3, [sp, #24]
 80032f8:	699b      	ldr	r3, [r3, #24]
 80032fa:	9a07      	ldr	r2, [sp, #28]
 80032fc:	1ad3      	subs	r3, r2, r3
 80032fe:	1e5a      	subs	r2, r3, #1
 8003300:	4193      	sbcs	r3, r2
 8003302:	b2db      	uxtb	r3, r3
 8003304:	2b00      	cmp	r3, #0
 8003306:	d003      	beq.n	8003310 <chSchGoSleepS+0x50>
 8003308:	4b1b      	ldr	r3, [pc, #108]	@ (8003378 <chSchGoSleepS+0xb8>)
 800330a:	0018      	movs	r0, r3
 800330c:	f7fe feb0 	bl	8002070 <chSysHalt>

  /* New state.*/
  otp->state = newstate;
 8003310:	9b06      	ldr	r3, [sp, #24]
 8003312:	466a      	mov	r2, sp
 8003314:	3207      	adds	r2, #7
 8003316:	2124      	movs	r1, #36	@ 0x24
 8003318:	7812      	ldrb	r2, [r2, #0]
 800331a:	545a      	strb	r2, [r3, r1]
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800331c:	9b07      	ldr	r3, [sp, #28]
 800331e:	0018      	movs	r0, r3
 8003320:	f7ff fe0e 	bl	8002f40 <ch_pqueue_remove_highest>
 8003324:	0003      	movs	r3, r0
 8003326:	9305      	str	r3, [sp, #20]
  ntp->state = CH_STATE_CURRENT;
 8003328:	9b05      	ldr	r3, [sp, #20]
 800332a:	2224      	movs	r2, #36	@ 0x24
 800332c:	2101      	movs	r1, #1
 800332e:	5499      	strb	r1, [r3, r2]
  __instance_set_currthread(oip, ntp);
 8003330:	9b07      	ldr	r3, [sp, #28]
 8003332:	9a05      	ldr	r2, [sp, #20]
 8003334:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8003336:	9a06      	ldr	r2, [sp, #24]
 8003338:	9b05      	ldr	r3, [sp, #20]
 800333a:	0011      	movs	r1, r2
 800333c:	0018      	movs	r0, r3
 800333e:	f7ff f90f 	bl	8002560 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003342:	f3ef 8309 	mrs	r3, PSP
 8003346:	9303      	str	r3, [sp, #12]
  return(result);
 8003348:	9b03      	ldr	r3, [sp, #12]
 800334a:	9304      	str	r3, [sp, #16]
 800334c:	9b04      	ldr	r3, [sp, #16]
 800334e:	3b24      	subs	r3, #36	@ 0x24
 8003350:	001a      	movs	r2, r3
 8003352:	9b06      	ldr	r3, [sp, #24]
 8003354:	6a1b      	ldr	r3, [r3, #32]
 8003356:	429a      	cmp	r2, r3
 8003358:	d203      	bcs.n	8003362 <chSchGoSleepS+0xa2>
 800335a:	4b08      	ldr	r3, [pc, #32]	@ (800337c <chSchGoSleepS+0xbc>)
 800335c:	0018      	movs	r0, r3
 800335e:	f7fe fe87 	bl	8002070 <chSysHalt>
 8003362:	9a06      	ldr	r2, [sp, #24]
 8003364:	9b05      	ldr	r3, [sp, #20]
 8003366:	0011      	movs	r1, r2
 8003368:	0018      	movs	r0, r3
 800336a:	f7fc ff15 	bl	8000198 <__port_switch>
}
 800336e:	46c0      	nop			@ (mov r8, r8)
 8003370:	b009      	add	sp, #36	@ 0x24
 8003372:	bd00      	pop	{pc}
 8003374:	20000690 	.word	0x20000690
 8003378:	0800519c 	.word	0x0800519c
 800337c:	08005088 	.word	0x08005088

08003380 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8003380:	b500      	push	{lr}
 8003382:	b08b      	sub	sp, #44	@ 0x2c
 8003384:	0002      	movs	r2, r0
 8003386:	9100      	str	r1, [sp, #0]
 8003388:	466b      	mov	r3, sp
 800338a:	3307      	adds	r3, #7
 800338c:	701a      	strb	r2, [r3, #0]
  thread_t *tp = __instance_get_currthread(currcore);
 800338e:	4b15      	ldr	r3, [pc, #84]	@ (80033e4 <chSchGoSleepTimeoutS+0x64>)
 8003390:	68db      	ldr	r3, [r3, #12]
 8003392:	9309      	str	r3, [sp, #36]	@ 0x24

  chDbgCheckClassS();
 8003394:	f7fe fffc 	bl	8002390 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 8003398:	9b00      	ldr	r3, [sp, #0]
 800339a:	3301      	adds	r3, #1
 800339c:	d016      	beq.n	80033cc <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 800339e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80033a0:	4a11      	ldr	r2, [pc, #68]	@ (80033e8 <chSchGoSleepTimeoutS+0x68>)
 80033a2:	9900      	ldr	r1, [sp, #0]
 80033a4:	a803      	add	r0, sp, #12
 80033a6:	f7ff fc33 	bl	8002c10 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80033aa:	466b      	mov	r3, sp
 80033ac:	3307      	adds	r3, #7
 80033ae:	781b      	ldrb	r3, [r3, #0]
 80033b0:	0018      	movs	r0, r3
 80033b2:	f7ff ff85 	bl	80032c0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80033b6:	ab03      	add	r3, sp, #12
 80033b8:	0018      	movs	r0, r3
 80033ba:	f7ff fe59 	bl	8003070 <chVTIsArmedI.lto_priv.1>
 80033be:	1e03      	subs	r3, r0, #0
 80033c0:	d00a      	beq.n	80033d8 <chSchGoSleepTimeoutS+0x58>
      chVTDoResetI(&vt);
 80033c2:	ab03      	add	r3, sp, #12
 80033c4:	0018      	movs	r0, r3
 80033c6:	f7ff fc63 	bl	8002c90 <chVTDoResetI>
 80033ca:	e005      	b.n	80033d8 <chSchGoSleepTimeoutS+0x58>
    }
  }
  else {
    chSchGoSleepS(newstate);
 80033cc:	466b      	mov	r3, sp
 80033ce:	3307      	adds	r3, #7
 80033d0:	781b      	ldrb	r3, [r3, #0]
 80033d2:	0018      	movs	r0, r3
 80033d4:	f7ff ff74 	bl	80032c0 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 80033d8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80033da:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
}
 80033dc:	0018      	movs	r0, r3
 80033de:	b00b      	add	sp, #44	@ 0x2c
 80033e0:	bd00      	pop	{pc}
 80033e2:	46c0      	nop			@ (mov r8, r8)
 80033e4:	20000690 	.word	0x20000690
 80033e8:	08003211 	.word	0x08003211
 80033ec:	00000000 	.word	0x00000000

080033f0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80033f0:	b500      	push	{lr}
 80033f2:	b087      	sub	sp, #28
 80033f4:	9001      	str	r0, [sp, #4]
 80033f6:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 80033f8:	4b2e      	ldr	r3, [pc, #184]	@ (80034b4 <chSchWakeupS+0xc4>)
 80033fa:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 80033fc:	9b05      	ldr	r3, [sp, #20]
 80033fe:	68db      	ldr	r3, [r3, #12]
 8003400:	9304      	str	r3, [sp, #16]

  chDbgCheckClassS();
 8003402:	f7fe ffc5 	bl	8002390 <chDbgCheckClassS>

  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8003406:	9b05      	ldr	r3, [sp, #20]
 8003408:	681a      	ldr	r2, [r3, #0]
 800340a:	9b05      	ldr	r3, [sp, #20]
 800340c:	1ad3      	subs	r3, r2, r3
 800340e:	1e5a      	subs	r2, r3, #1
 8003410:	4193      	sbcs	r3, r2
 8003412:	b2db      	uxtb	r3, r3
 8003414:	2b00      	cmp	r3, #0
 8003416:	d00f      	beq.n	8003438 <chSchWakeupS+0x48>
 8003418:	9b05      	ldr	r3, [sp, #20]
 800341a:	68db      	ldr	r3, [r3, #12]
 800341c:	689a      	ldr	r2, [r3, #8]
 800341e:	9b05      	ldr	r3, [sp, #20]
 8003420:	681b      	ldr	r3, [r3, #0]
 8003422:	689b      	ldr	r3, [r3, #8]
 8003424:	429a      	cmp	r2, r3
 8003426:	419b      	sbcs	r3, r3
 8003428:	425b      	negs	r3, r3
 800342a:	b2db      	uxtb	r3, r3
 800342c:	2b00      	cmp	r3, #0
 800342e:	d003      	beq.n	8003438 <chSchWakeupS+0x48>
 8003430:	4b21      	ldr	r3, [pc, #132]	@ (80034b8 <chSchWakeupS+0xc8>)
 8003432:	0018      	movs	r0, r3
 8003434:	f7fe fe1c 	bl	8002070 <chSysHalt>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8003438:	9b01      	ldr	r3, [sp, #4]
 800343a:	9a00      	ldr	r2, [sp, #0]
 800343c:	629a      	str	r2, [r3, #40]	@ 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 800343e:	9b01      	ldr	r3, [sp, #4]
 8003440:	689a      	ldr	r2, [r3, #8]
 8003442:	9b04      	ldr	r3, [sp, #16]
 8003444:	6899      	ldr	r1, [r3, #8]
 8003446:	2300      	movs	r3, #0
 8003448:	4291      	cmp	r1, r2
 800344a:	415b      	adcs	r3, r3
 800344c:	b2db      	uxtb	r3, r3
 800344e:	2b00      	cmp	r3, #0
 8003450:	d004      	beq.n	800345c <chSchWakeupS+0x6c>
    (void) __sch_ready_behind(ntp);
 8003452:	9b01      	ldr	r3, [sp, #4]
 8003454:	0018      	movs	r0, r3
 8003456:	f7ff fe2b 	bl	80030b0 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 800345a:	e028      	b.n	80034ae <chSchWakeupS+0xbe>
    otp = __sch_ready_ahead(otp);
 800345c:	9b04      	ldr	r3, [sp, #16]
 800345e:	0018      	movs	r0, r3
 8003460:	f7ff fe5e 	bl	8003120 <__sch_ready_ahead>
 8003464:	0003      	movs	r3, r0
 8003466:	9304      	str	r3, [sp, #16]
    ntp->state = CH_STATE_CURRENT;
 8003468:	9b01      	ldr	r3, [sp, #4]
 800346a:	2224      	movs	r2, #36	@ 0x24
 800346c:	2101      	movs	r1, #1
 800346e:	5499      	strb	r1, [r3, r2]
    __instance_set_currthread(oip, ntp);
 8003470:	9b05      	ldr	r3, [sp, #20]
 8003472:	9a01      	ldr	r2, [sp, #4]
 8003474:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 8003476:	9a04      	ldr	r2, [sp, #16]
 8003478:	9b01      	ldr	r3, [sp, #4]
 800347a:	0011      	movs	r1, r2
 800347c:	0018      	movs	r0, r3
 800347e:	f7ff f86f 	bl	8002560 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003482:	f3ef 8309 	mrs	r3, PSP
 8003486:	9302      	str	r3, [sp, #8]
  return(result);
 8003488:	9b02      	ldr	r3, [sp, #8]
 800348a:	9303      	str	r3, [sp, #12]
 800348c:	9b03      	ldr	r3, [sp, #12]
 800348e:	3b24      	subs	r3, #36	@ 0x24
 8003490:	001a      	movs	r2, r3
 8003492:	9b04      	ldr	r3, [sp, #16]
 8003494:	6a1b      	ldr	r3, [r3, #32]
 8003496:	429a      	cmp	r2, r3
 8003498:	d203      	bcs.n	80034a2 <chSchWakeupS+0xb2>
 800349a:	4b08      	ldr	r3, [pc, #32]	@ (80034bc <chSchWakeupS+0xcc>)
 800349c:	0018      	movs	r0, r3
 800349e:	f7fe fde7 	bl	8002070 <chSysHalt>
 80034a2:	9a04      	ldr	r2, [sp, #16]
 80034a4:	9b01      	ldr	r3, [sp, #4]
 80034a6:	0011      	movs	r1, r2
 80034a8:	0018      	movs	r0, r3
 80034aa:	f7fc fe75 	bl	8000198 <__port_switch>
}
 80034ae:	46c0      	nop			@ (mov r8, r8)
 80034b0:	b007      	add	sp, #28
 80034b2:	bd00      	pop	{pc}
 80034b4:	20000690 	.word	0x20000690
 80034b8:	080051ac 	.word	0x080051ac
 80034bc:	08005088 	.word	0x08005088

080034c0 <chSchRescheduleS>:
 * @note    Only local threads are considered, other cores are signaled
 *          and perform a reschedule locally.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 80034c0:	b500      	push	{lr}
 80034c2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80034c4:	4b0b      	ldr	r3, [pc, #44]	@ (80034f4 <chSchRescheduleS+0x34>)
 80034c6:	9301      	str	r3, [sp, #4]
  thread_t *tp = __instance_get_currthread(oip);
 80034c8:	9b01      	ldr	r3, [sp, #4]
 80034ca:	68db      	ldr	r3, [r3, #12]
 80034cc:	9300      	str	r3, [sp, #0]

  chDbgCheckClassS();
 80034ce:	f7fe ff5f 	bl	8002390 <chDbgCheckClassS>

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 80034d2:	9b01      	ldr	r3, [sp, #4]
 80034d4:	681b      	ldr	r3, [r3, #0]
 80034d6:	689a      	ldr	r2, [r3, #8]
 80034d8:	9b00      	ldr	r3, [sp, #0]
 80034da:	689b      	ldr	r3, [r3, #8]
 80034dc:	4293      	cmp	r3, r2
 80034de:	419b      	sbcs	r3, r3
 80034e0:	425b      	negs	r3, r3
 80034e2:	b2db      	uxtb	r3, r3
 80034e4:	2b00      	cmp	r3, #0
 80034e6:	d001      	beq.n	80034ec <chSchRescheduleS+0x2c>
    __sch_reschedule_ahead();
 80034e8:	f7ff fe52 	bl	8003190 <__sch_reschedule_ahead>
  }
}
 80034ec:	46c0      	nop			@ (mov r8, r8)
 80034ee:	b003      	add	sp, #12
 80034f0:	bd00      	pop	{pc}
 80034f2:	46c0      	nop			@ (mov r8, r8)
 80034f4:	20000690 	.word	0x20000690
	...

08003500 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8003500:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 8003502:	4b0a      	ldr	r3, [pc, #40]	@ (800352c <chSchIsPreemptionRequired+0x2c>)
 8003504:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 8003506:	9b03      	ldr	r3, [sp, #12]
 8003508:	68db      	ldr	r3, [r3, #12]
 800350a:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 800350c:	9b03      	ldr	r3, [sp, #12]
 800350e:	681b      	ldr	r3, [r3, #0]
 8003510:	689b      	ldr	r3, [r3, #8]
 8003512:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8003514:	9b02      	ldr	r3, [sp, #8]
 8003516:	689b      	ldr	r3, [r3, #8]
 8003518:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800351a:	9b01      	ldr	r3, [sp, #4]
 800351c:	9a00      	ldr	r2, [sp, #0]
 800351e:	429a      	cmp	r2, r3
 8003520:	419b      	sbcs	r3, r3
 8003522:	425b      	negs	r3, r3
 8003524:	b2db      	uxtb	r3, r3
#endif
}
 8003526:	0018      	movs	r0, r3
 8003528:	b004      	add	sp, #16
 800352a:	4770      	bx	lr
 800352c:	20000690 	.word	0x20000690

08003530 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8003530:	b500      	push	{lr}
 8003532:	b087      	sub	sp, #28
  os_instance_t *oip = currcore;
 8003534:	4b1b      	ldr	r3, [pc, #108]	@ (80035a4 <chSchDoPreemption+0x74>)
 8003536:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 8003538:	9b05      	ldr	r3, [sp, #20]
 800353a:	68db      	ldr	r3, [r3, #12]
 800353c:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800353e:	9b05      	ldr	r3, [sp, #20]
 8003540:	0018      	movs	r0, r3
 8003542:	f7ff fcfd 	bl	8002f40 <ch_pqueue_remove_highest>
 8003546:	0003      	movs	r3, r0
 8003548:	9303      	str	r3, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 800354a:	9b03      	ldr	r3, [sp, #12]
 800354c:	2224      	movs	r2, #36	@ 0x24
 800354e:	2101      	movs	r1, #1
 8003550:	5499      	strb	r1, [r3, r2]
  __instance_set_currthread(oip, ntp);
 8003552:	9b05      	ldr	r3, [sp, #20]
 8003554:	9a03      	ldr	r2, [sp, #12]
 8003556:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 8003558:	9b04      	ldr	r3, [sp, #16]
 800355a:	0018      	movs	r0, r3
 800355c:	f7ff fde0 	bl	8003120 <__sch_ready_ahead>
 8003560:	0003      	movs	r3, r0
 8003562:	9304      	str	r3, [sp, #16]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8003564:	9a04      	ldr	r2, [sp, #16]
 8003566:	9b03      	ldr	r3, [sp, #12]
 8003568:	0011      	movs	r1, r2
 800356a:	0018      	movs	r0, r3
 800356c:	f7fe fff8 	bl	8002560 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003570:	f3ef 8309 	mrs	r3, PSP
 8003574:	9301      	str	r3, [sp, #4]
  return(result);
 8003576:	9b01      	ldr	r3, [sp, #4]
 8003578:	9302      	str	r3, [sp, #8]
 800357a:	9b02      	ldr	r3, [sp, #8]
 800357c:	3b24      	subs	r3, #36	@ 0x24
 800357e:	001a      	movs	r2, r3
 8003580:	9b04      	ldr	r3, [sp, #16]
 8003582:	6a1b      	ldr	r3, [r3, #32]
 8003584:	429a      	cmp	r2, r3
 8003586:	d203      	bcs.n	8003590 <chSchDoPreemption+0x60>
 8003588:	4b07      	ldr	r3, [pc, #28]	@ (80035a8 <chSchDoPreemption+0x78>)
 800358a:	0018      	movs	r0, r3
 800358c:	f7fe fd70 	bl	8002070 <chSysHalt>
 8003590:	9a04      	ldr	r2, [sp, #16]
 8003592:	9b03      	ldr	r3, [sp, #12]
 8003594:	0011      	movs	r1, r2
 8003596:	0018      	movs	r0, r3
 8003598:	f7fc fdfe 	bl	8000198 <__port_switch>
}
 800359c:	46c0      	nop			@ (mov r8, r8)
 800359e:	b007      	add	sp, #28
 80035a0:	bd00      	pop	{pc}
 80035a2:	46c0      	nop			@ (mov r8, r8)
 80035a4:	20000690 	.word	0x20000690
 80035a8:	08005088 	.word	0x08005088
 80035ac:	00000000 	.word	0x00000000

080035b0 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 80035b0:	b082      	sub	sp, #8
 80035b2:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 80035b4:	9b01      	ldr	r3, [sp, #4]
 80035b6:	2200      	movs	r2, #0
 80035b8:	601a      	str	r2, [r3, #0]
}
 80035ba:	46c0      	nop			@ (mov r8, r8)
 80035bc:	b002      	add	sp, #8
 80035be:	4770      	bx	lr

080035c0 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 80035c0:	b082      	sub	sp, #8
 80035c2:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 80035c4:	9b01      	ldr	r3, [sp, #4]
 80035c6:	2200      	movs	r2, #0
 80035c8:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 80035ca:	9b01      	ldr	r3, [sp, #4]
 80035cc:	2200      	movs	r2, #0
 80035ce:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 80035d0:	9b01      	ldr	r3, [sp, #4]
 80035d2:	2201      	movs	r2, #1
 80035d4:	609a      	str	r2, [r3, #8]
#endif
}
 80035d6:	46c0      	nop			@ (mov r8, r8)
 80035d8:	b002      	add	sp, #8
 80035da:	4770      	bx	lr
 80035dc:	0000      	movs	r0, r0
	...

080035e0 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80035e0:	b082      	sub	sp, #8
 80035e2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80035e4:	9b01      	ldr	r3, [sp, #4]
 80035e6:	9a01      	ldr	r2, [sp, #4]
 80035e8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80035ea:	9b01      	ldr	r3, [sp, #4]
 80035ec:	9a01      	ldr	r2, [sp, #4]
 80035ee:	605a      	str	r2, [r3, #4]
}
 80035f0:	46c0      	nop			@ (mov r8, r8)
 80035f2:	b002      	add	sp, #8
 80035f4:	4770      	bx	lr
 80035f6:	46c0      	nop			@ (mov r8, r8)
	...

08003600 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 8003600:	b082      	sub	sp, #8
 8003602:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 8003604:	9b01      	ldr	r3, [sp, #4]
 8003606:	9a01      	ldr	r2, [sp, #4]
 8003608:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 800360a:	9b01      	ldr	r3, [sp, #4]
 800360c:	9a01      	ldr	r2, [sp, #4]
 800360e:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 8003610:	9b01      	ldr	r3, [sp, #4]
 8003612:	2200      	movs	r2, #0
 8003614:	609a      	str	r2, [r3, #8]
}
 8003616:	46c0      	nop			@ (mov r8, r8)
 8003618:	b002      	add	sp, #8
 800361a:	4770      	bx	lr
 800361c:	0000      	movs	r0, r0
	...

08003620 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 8003620:	b082      	sub	sp, #8
 8003622:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 8003624:	9b01      	ldr	r3, [sp, #4]
 8003626:	9a01      	ldr	r2, [sp, #4]
 8003628:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 800362a:	9b01      	ldr	r3, [sp, #4]
 800362c:	9a01      	ldr	r2, [sp, #4]
 800362e:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 8003630:	9b01      	ldr	r3, [sp, #4]
 8003632:	2201      	movs	r2, #1
 8003634:	4252      	negs	r2, r2
 8003636:	609a      	str	r2, [r3, #8]
}
 8003638:	46c0      	nop			@ (mov r8, r8)
 800363a:	b002      	add	sp, #8
 800363c:	4770      	bx	lr
 800363e:	46c0      	nop			@ (mov r8, r8)

08003640 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8003640:	46c0      	nop			@ (mov r8, r8)
 8003642:	4770      	bx	lr
	...

08003650 <port_timer_get_time.lto_priv.2>:
static inline systime_t port_timer_get_time(void) {
 8003650:	b510      	push	{r4, lr}
  return stGetCounter();
 8003652:	f7fc fed5 	bl	8000400 <stGetCounter>
 8003656:	0003      	movs	r3, r0
}
 8003658:	0018      	movs	r0, r3
 800365a:	bd10      	pop	{r4, pc}
 800365c:	0000      	movs	r0, r0
	...

08003660 <chVTGetSystemTimeX.lto_priv.2>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003660:	b510      	push	{r4, lr}
  return port_timer_get_time();
 8003662:	f7ff fff5 	bl	8003650 <port_timer_get_time.lto_priv.2>
 8003666:	0003      	movs	r3, r0
}
 8003668:	0018      	movs	r0, r3
 800366a:	bd10      	pop	{r4, pc}
 800366c:	0000      	movs	r0, r0
	...

08003670 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 8003670:	b530      	push	{r4, r5, lr}
 8003672:	b083      	sub	sp, #12
 8003674:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 8003676:	9b01      	ldr	r3, [sp, #4]
 8003678:	0018      	movs	r0, r3
 800367a:	f7ff ffd1 	bl	8003620 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 800367e:	9b01      	ldr	r3, [sp, #4]
 8003680:	2200      	movs	r2, #0
 8003682:	819a      	strh	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003684:	f7ff ffec 	bl	8003660 <chVTGetSystemTimeX.lto_priv.2>
 8003688:	0003      	movs	r3, r0
 800368a:	001c      	movs	r4, r3
 800368c:	2300      	movs	r3, #0
 800368e:	001d      	movs	r5, r3
 8003690:	9b01      	ldr	r3, [sp, #4]
 8003692:	611c      	str	r4, [r3, #16]
 8003694:	615d      	str	r5, [r3, #20]
#endif
}
 8003696:	46c0      	nop			@ (mov r8, r8)
 8003698:	b003      	add	sp, #12
 800369a:	bd30      	pop	{r4, r5, pc}
 800369c:	0000      	movs	r0, r0
	...

080036a0 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 80036a0:	b500      	push	{lr}
 80036a2:	b083      	sub	sp, #12
 80036a4:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 80036a6:	9b01      	ldr	r3, [sp, #4]
 80036a8:	0018      	movs	r0, r3
 80036aa:	f7ff ff99 	bl	80035e0 <ch_queue_init.lto_priv.2>
}
 80036ae:	46c0      	nop			@ (mov r8, r8)
 80036b0:	b003      	add	sp, #12
 80036b2:	bd00      	pop	{pc}
	...

080036c0 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 80036c0:	b500      	push	{lr}
 80036c2:	b083      	sub	sp, #12
 80036c4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 80036c6:	f7ff ffbb 	bl	8003640 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
    asm volatile ("nop");
 80036ca:	46c0      	nop			@ (mov r8, r8)
    port_wait_for_interrupt();
 80036cc:	46c0      	nop			@ (mov r8, r8)
 80036ce:	e7fa      	b.n	80036c6 <__idle_thread+0x6>

080036d0 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 80036d0:	b500      	push	{lr}
 80036d2:	b08b      	sub	sp, #44	@ 0x2c
 80036d4:	9001      	str	r0, [sp, #4]
 80036d6:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 80036d8:	2300      	movs	r3, #0
 80036da:	9309      	str	r3, [sp, #36]	@ 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 80036dc:	4a3a      	ldr	r2, [pc, #232]	@ (80037c8 <chInstanceObjectInit+0xf8>)
 80036de:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80036e0:	009b      	lsls	r3, r3, #2
 80036e2:	18d3      	adds	r3, r2, r3
 80036e4:	3304      	adds	r3, #4
 80036e6:	681b      	ldr	r3, [r3, #0]
 80036e8:	1e5a      	subs	r2, r3, #1
 80036ea:	4193      	sbcs	r3, r2
 80036ec:	b2db      	uxtb	r3, r3
 80036ee:	2b00      	cmp	r3, #0
 80036f0:	d003      	beq.n	80036fa <chInstanceObjectInit+0x2a>
 80036f2:	4b36      	ldr	r3, [pc, #216]	@ (80037cc <chInstanceObjectInit+0xfc>)
 80036f4:	0018      	movs	r0, r3
 80036f6:	f7fe fcbb 	bl	8002070 <chSysHalt>
  ch_system.instances[core_id] = oip;
 80036fa:	4a33      	ldr	r2, [pc, #204]	@ (80037c8 <chInstanceObjectInit+0xf8>)
 80036fc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80036fe:	009b      	lsls	r3, r3, #2
 8003700:	18d3      	adds	r3, r2, r3
 8003702:	3304      	adds	r3, #4
 8003704:	9a01      	ldr	r2, [sp, #4]
 8003706:	601a      	str	r2, [r3, #0]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 8003708:	9b01      	ldr	r3, [sp, #4]
 800370a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800370c:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 800370e:	9b01      	ldr	r3, [sp, #4]
 8003710:	9a00      	ldr	r2, [sp, #0]
 8003712:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 8003714:	9b01      	ldr	r3, [sp, #4]
 8003716:	0018      	movs	r0, r3
 8003718:	f001 fa1a 	bl	8004b50 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 800371c:	9b01      	ldr	r3, [sp, #4]
 800371e:	0018      	movs	r0, r3
 8003720:	f7ff ff6e 	bl	8003600 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 8003724:	9b01      	ldr	r3, [sp, #4]
 8003726:	3328      	adds	r3, #40	@ 0x28
 8003728:	0018      	movs	r0, r3
 800372a:	f7ff ffb9 	bl	80036a0 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 800372e:	9b01      	ldr	r3, [sp, #4]
 8003730:	3334      	adds	r3, #52	@ 0x34
 8003732:	0018      	movs	r0, r3
 8003734:	f7ff ff3c 	bl	80035b0 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8003738:	9b01      	ldr	r3, [sp, #4]
 800373a:	3310      	adds	r3, #16
 800373c:	0018      	movs	r0, r3
 800373e:	f7ff ff97 	bl	8003670 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 8003742:	9b01      	ldr	r3, [sp, #4]
 8003744:	3384      	adds	r3, #132	@ 0x84
 8003746:	0018      	movs	r0, r3
 8003748:	f7ff ff3a 	bl	80035c0 <__dbg_object_init>

#if CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED
  /* Trace buffer initialization.*/
  __trace_object_init(&oip->trace_buffer);
 800374c:	9b01      	ldr	r3, [sp, #4]
 800374e:	3390      	adds	r3, #144	@ 0x90
 8003750:	0018      	movs	r0, r3
 8003752:	f7fe fe9d 	bl	8002490 <__trace_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8003756:	9b01      	ldr	r3, [sp, #4]
 8003758:	333c      	adds	r3, #60	@ 0x3c
 800375a:	0019      	movs	r1, r3
 800375c:	4a1c      	ldr	r2, [pc, #112]	@ (80037d0 <chInstanceObjectInit+0x100>)
 800375e:	9801      	ldr	r0, [sp, #4]
 8003760:	2380      	movs	r3, #128	@ 0x80
 8003762:	f000 f905 	bl	8003970 <__thd_object_init>
 8003766:	0002      	movs	r2, r0
 8003768:	9b01      	ldr	r3, [sp, #4]
 800376a:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 800376c:	9b01      	ldr	r3, [sp, #4]
 800376e:	68db      	ldr	r3, [r3, #12]
 8003770:	9a00      	ldr	r2, [sp, #0]
 8003772:	6852      	ldr	r2, [r2, #4]
 8003774:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8003776:	9b01      	ldr	r3, [sp, #4]
 8003778:	68db      	ldr	r3, [r3, #12]
 800377a:	2224      	movs	r2, #36	@ 0x24
 800377c:	2101      	movs	r1, #1
 800377e:	5499      	strb	r1, [r3, r2]
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 8003780:	ab03      	add	r3, sp, #12
 8003782:	4a14      	ldr	r2, [pc, #80]	@ (80037d4 <chInstanceObjectInit+0x104>)
 8003784:	601a      	str	r2, [r3, #0]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8003786:	9b00      	ldr	r3, [sp, #0]
 8003788:	68da      	ldr	r2, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 800378a:	ab03      	add	r3, sp, #12
 800378c:	605a      	str	r2, [r3, #4]
      .wend     = oicp->idlethread_end,
 800378e:	9b00      	ldr	r3, [sp, #0]
 8003790:	691a      	ldr	r2, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 8003792:	ab03      	add	r3, sp, #12
 8003794:	609a      	str	r2, [r3, #8]
 8003796:	ab03      	add	r3, sp, #12
 8003798:	2201      	movs	r2, #1
 800379a:	60da      	str	r2, [r3, #12]
 800379c:	ab03      	add	r3, sp, #12
 800379e:	4a0e      	ldr	r2, [pc, #56]	@ (80037d8 <chInstanceObjectInit+0x108>)
 80037a0:	611a      	str	r2, [r3, #16]
 80037a2:	ab03      	add	r3, sp, #12
 80037a4:	2200      	movs	r2, #0
 80037a6:	615a      	str	r2, [r3, #20]
      .funcp    = __idle_thread,
      .arg      = NULL
    };

#if CH_DBG_FILL_THREADS == TRUE
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 80037a8:	ab03      	add	r3, sp, #12
 80037aa:	685a      	ldr	r2, [r3, #4]
                    (uint8_t *)idle_descriptor.wend);
 80037ac:	ab03      	add	r3, sp, #12
 80037ae:	689b      	ldr	r3, [r3, #8]
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 80037b0:	0019      	movs	r1, r3
 80037b2:	0010      	movs	r0, r2
 80037b4:	f000 f91c 	bl	80039f0 <__thd_stackfill>
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 80037b8:	ab03      	add	r3, sp, #12
 80037ba:	0018      	movs	r0, r3
 80037bc:	f000 f9c0 	bl	8003b40 <chThdCreateI>
  }
#endif
}
 80037c0:	46c0      	nop			@ (mov r8, r8)
 80037c2:	b00b      	add	sp, #44	@ 0x2c
 80037c4:	bd00      	pop	{pc}
 80037c6:	46c0      	nop			@ (mov r8, r8)
 80037c8:	20000684 	.word	0x20000684
 80037cc:	080051bc 	.word	0x080051bc
 80037d0:	0800526c 	.word	0x0800526c
 80037d4:	08005098 	.word	0x08005098
 80037d8:	080036c1 	.word	0x080036c1
 80037dc:	00000000 	.word	0x00000000

080037e0 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 80037e0:	b082      	sub	sp, #8
 80037e2:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 80037e4:	9b01      	ldr	r3, [sp, #4]
 80037e6:	9a01      	ldr	r2, [sp, #4]
 80037e8:	601a      	str	r2, [r3, #0]
}
 80037ea:	46c0      	nop			@ (mov r8, r8)
 80037ec:	b002      	add	sp, #8
 80037ee:	4770      	bx	lr

080037f0 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 80037f0:	b082      	sub	sp, #8
 80037f2:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 80037f4:	9b01      	ldr	r3, [sp, #4]
 80037f6:	681b      	ldr	r3, [r3, #0]
 80037f8:	9a01      	ldr	r2, [sp, #4]
 80037fa:	1ad3      	subs	r3, r2, r3
 80037fc:	1e5a      	subs	r2, r3, #1
 80037fe:	4193      	sbcs	r3, r2
 8003800:	b2db      	uxtb	r3, r3
}
 8003802:	0018      	movs	r0, r3
 8003804:	b002      	add	sp, #8
 8003806:	4770      	bx	lr
	...

08003810 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 8003810:	b084      	sub	sp, #16
 8003812:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 8003814:	9b01      	ldr	r3, [sp, #4]
 8003816:	681b      	ldr	r3, [r3, #0]
 8003818:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 800381a:	9b03      	ldr	r3, [sp, #12]
 800381c:	681a      	ldr	r2, [r3, #0]
 800381e:	9b01      	ldr	r3, [sp, #4]
 8003820:	601a      	str	r2, [r3, #0]
  return p;
 8003822:	9b03      	ldr	r3, [sp, #12]
}
 8003824:	0018      	movs	r0, r3
 8003826:	b004      	add	sp, #16
 8003828:	4770      	bx	lr
 800382a:	46c0      	nop			@ (mov r8, r8)
 800382c:	0000      	movs	r0, r0
	...

08003830 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003830:	b082      	sub	sp, #8
 8003832:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8003834:	9b01      	ldr	r3, [sp, #4]
 8003836:	9a01      	ldr	r2, [sp, #4]
 8003838:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800383a:	9b01      	ldr	r3, [sp, #4]
 800383c:	9a01      	ldr	r2, [sp, #4]
 800383e:	605a      	str	r2, [r3, #4]
}
 8003840:	46c0      	nop			@ (mov r8, r8)
 8003842:	b002      	add	sp, #8
 8003844:	4770      	bx	lr
 8003846:	46c0      	nop			@ (mov r8, r8)
	...

08003850 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8003850:	b082      	sub	sp, #8
 8003852:	9001      	str	r0, [sp, #4]
 8003854:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 8003856:	9b00      	ldr	r3, [sp, #0]
 8003858:	9a01      	ldr	r2, [sp, #4]
 800385a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 800385c:	9b01      	ldr	r3, [sp, #4]
 800385e:	685a      	ldr	r2, [r3, #4]
 8003860:	9b00      	ldr	r3, [sp, #0]
 8003862:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003864:	9b00      	ldr	r3, [sp, #0]
 8003866:	685b      	ldr	r3, [r3, #4]
 8003868:	9a00      	ldr	r2, [sp, #0]
 800386a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 800386c:	9b01      	ldr	r3, [sp, #4]
 800386e:	9a00      	ldr	r2, [sp, #0]
 8003870:	605a      	str	r2, [r3, #4]
}
 8003872:	46c0      	nop			@ (mov r8, r8)
 8003874:	b002      	add	sp, #8
 8003876:	4770      	bx	lr
	...

08003880 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003880:	b082      	sub	sp, #8
 8003882:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003884:	9b01      	ldr	r3, [sp, #4]
 8003886:	685b      	ldr	r3, [r3, #4]
 8003888:	9a01      	ldr	r2, [sp, #4]
 800388a:	6812      	ldr	r2, [r2, #0]
 800388c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800388e:	9b01      	ldr	r3, [sp, #4]
 8003890:	681b      	ldr	r3, [r3, #0]
 8003892:	9a01      	ldr	r2, [sp, #4]
 8003894:	6852      	ldr	r2, [r2, #4]
 8003896:	605a      	str	r2, [r3, #4]
  return p;
 8003898:	9b01      	ldr	r3, [sp, #4]
}
 800389a:	0018      	movs	r0, r3
 800389c:	b002      	add	sp, #8
 800389e:	4770      	bx	lr

080038a0 <port_lock.lto_priv.12>:
  __ASM volatile ("cpsid i" : : : "memory");
 80038a0:	b672      	cpsid	i
}
 80038a2:	46c0      	nop			@ (mov r8, r8)
}
 80038a4:	46c0      	nop			@ (mov r8, r8)
 80038a6:	4770      	bx	lr
	...

080038b0 <port_unlock.lto_priv.12>:
  __ASM volatile ("cpsie i" : : : "memory");
 80038b0:	b662      	cpsie	i
}
 80038b2:	46c0      	nop			@ (mov r8, r8)
}
 80038b4:	46c0      	nop			@ (mov r8, r8)
 80038b6:	4770      	bx	lr
	...

080038c0 <chSysLock.lto_priv.7>:
static inline void chSysLock(void) {
 80038c0:	b510      	push	{r4, lr}
  port_lock();
 80038c2:	f7ff ffed 	bl	80038a0 <port_lock.lto_priv.12>
  __dbg_check_lock();
 80038c6:	f7fe fc43 	bl	8002150 <__dbg_check_lock>
}
 80038ca:	46c0      	nop			@ (mov r8, r8)
 80038cc:	bd10      	pop	{r4, pc}
 80038ce:	46c0      	nop			@ (mov r8, r8)

080038d0 <chSysUnlock.lto_priv.7>:
static inline void chSysUnlock(void) {
 80038d0:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 80038d2:	f7fe fc65 	bl	80021a0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80038d6:	4b0e      	ldr	r3, [pc, #56]	@ (8003910 <chSysUnlock.lto_priv.7+0x40>)
 80038d8:	681a      	ldr	r2, [r3, #0]
 80038da:	4b0d      	ldr	r3, [pc, #52]	@ (8003910 <chSysUnlock.lto_priv.7+0x40>)
 80038dc:	1ad3      	subs	r3, r2, r3
 80038de:	1e5a      	subs	r2, r3, #1
 80038e0:	4193      	sbcs	r3, r2
 80038e2:	b2db      	uxtb	r3, r3
 80038e4:	2b00      	cmp	r3, #0
 80038e6:	d00f      	beq.n	8003908 <chSysUnlock.lto_priv.7+0x38>
 80038e8:	4b09      	ldr	r3, [pc, #36]	@ (8003910 <chSysUnlock.lto_priv.7+0x40>)
 80038ea:	68db      	ldr	r3, [r3, #12]
 80038ec:	689a      	ldr	r2, [r3, #8]
 80038ee:	4b08      	ldr	r3, [pc, #32]	@ (8003910 <chSysUnlock.lto_priv.7+0x40>)
 80038f0:	681b      	ldr	r3, [r3, #0]
 80038f2:	689b      	ldr	r3, [r3, #8]
 80038f4:	429a      	cmp	r2, r3
 80038f6:	419b      	sbcs	r3, r3
 80038f8:	425b      	negs	r3, r3
 80038fa:	b2db      	uxtb	r3, r3
 80038fc:	2b00      	cmp	r3, #0
 80038fe:	d003      	beq.n	8003908 <chSysUnlock.lto_priv.7+0x38>
 8003900:	4b04      	ldr	r3, [pc, #16]	@ (8003914 <chSysUnlock.lto_priv.7+0x44>)
 8003902:	0018      	movs	r0, r3
 8003904:	f7fe fbb4 	bl	8002070 <chSysHalt>
  port_unlock();
 8003908:	f7ff ffd2 	bl	80038b0 <port_unlock.lto_priv.12>
}
 800390c:	46c0      	nop			@ (mov r8, r8)
 800390e:	bd10      	pop	{r4, pc}
 8003910:	20000690 	.word	0x20000690
 8003914:	080051ec 	.word	0x080051ec
	...

08003920 <chThdGetSelfX.lto_priv.0>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8003920:	4b01      	ldr	r3, [pc, #4]	@ (8003928 <chThdGetSelfX.lto_priv.0+0x8>)
 8003922:	68db      	ldr	r3, [r3, #12]
}
 8003924:	0018      	movs	r0, r3
 8003926:	4770      	bx	lr
 8003928:	20000690 	.word	0x20000690
 800392c:	00000000 	.word	0x00000000

08003930 <chThdGetWorkingAreaX.lto_priv.0>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8003930:	b082      	sub	sp, #8
 8003932:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 8003934:	9b01      	ldr	r3, [sp, #4]
 8003936:	6a1b      	ldr	r3, [r3, #32]
}
 8003938:	0018      	movs	r0, r3
 800393a:	b002      	add	sp, #8
 800393c:	4770      	bx	lr
 800393e:	46c0      	nop			@ (mov r8, r8)

08003940 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 8003940:	b500      	push	{lr}
 8003942:	b083      	sub	sp, #12
 8003944:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8003946:	9b01      	ldr	r3, [sp, #4]
 8003948:	425a      	negs	r2, r3
 800394a:	4153      	adcs	r3, r2
 800394c:	b2db      	uxtb	r3, r3
 800394e:	2b00      	cmp	r3, #0
 8003950:	d003      	beq.n	800395a <chThdSleepS+0x1a>
 8003952:	4b06      	ldr	r3, [pc, #24]	@ (800396c <chThdSleepS+0x2c>)
 8003954:	0018      	movs	r0, r3
 8003956:	f7fe fb8b 	bl	8002070 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800395a:	9b01      	ldr	r3, [sp, #4]
 800395c:	0019      	movs	r1, r3
 800395e:	2008      	movs	r0, #8
 8003960:	f7ff fd0e 	bl	8003380 <chSchGoSleepTimeoutS>
}
 8003964:	46c0      	nop			@ (mov r8, r8)
 8003966:	b003      	add	sp, #12
 8003968:	bd00      	pop	{pc}
 800396a:	46c0      	nop			@ (mov r8, r8)
 800396c:	08005228 	.word	0x08005228

08003970 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8003970:	b500      	push	{lr}
 8003972:	b085      	sub	sp, #20
 8003974:	9003      	str	r0, [sp, #12]
 8003976:	9102      	str	r1, [sp, #8]
 8003978:	9201      	str	r2, [sp, #4]
 800397a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 800397c:	9b02      	ldr	r3, [sp, #8]
 800397e:	9a00      	ldr	r2, [sp, #0]
 8003980:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8003982:	9b02      	ldr	r3, [sp, #8]
 8003984:	2224      	movs	r2, #36	@ 0x24
 8003986:	2102      	movs	r1, #2
 8003988:	5499      	strb	r1, [r3, r2]
  tp->flags             = CH_FLAG_MODE_STATIC;
 800398a:	9b02      	ldr	r3, [sp, #8]
 800398c:	2225      	movs	r2, #37	@ 0x25
 800398e:	2100      	movs	r1, #0
 8003990:	5499      	strb	r1, [r3, r2]
  tp->owner             = oip;
 8003992:	9b02      	ldr	r3, [sp, #8]
 8003994:	9a03      	ldr	r2, [sp, #12]
 8003996:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8003998:	9b02      	ldr	r3, [sp, #8]
 800399a:	9a00      	ldr	r2, [sp, #0]
 800399c:	641a      	str	r2, [r3, #64]	@ 0x40
  tp->mtxlist           = NULL;
 800399e:	9b02      	ldr	r3, [sp, #8]
 80039a0:	2200      	movs	r2, #0
 80039a2:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 80039a4:	9b02      	ldr	r3, [sp, #8]
 80039a6:	2200      	movs	r2, #0
 80039a8:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 80039aa:	9b02      	ldr	r3, [sp, #8]
 80039ac:	2226      	movs	r2, #38	@ 0x26
 80039ae:	2101      	movs	r1, #1
 80039b0:	5499      	strb	r1, [r3, r2]
  tp->name              = name;
 80039b2:	9b02      	ldr	r3, [sp, #8]
 80039b4:	9a01      	ldr	r2, [sp, #4]
 80039b6:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 80039b8:	9b03      	ldr	r3, [sp, #12]
 80039ba:	3328      	adds	r3, #40	@ 0x28
 80039bc:	001a      	movs	r2, r3
 80039be:	9b02      	ldr	r3, [sp, #8]
 80039c0:	3310      	adds	r3, #16
 80039c2:	0019      	movs	r1, r3
 80039c4:	0010      	movs	r0, r2
 80039c6:	f7ff ff43 	bl	8003850 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 80039ca:	9b02      	ldr	r3, [sp, #8]
 80039cc:	332c      	adds	r3, #44	@ 0x2c
 80039ce:	0018      	movs	r0, r3
 80039d0:	f7ff ff06 	bl	80037e0 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 80039d4:	9b02      	ldr	r3, [sp, #8]
 80039d6:	3330      	adds	r3, #48	@ 0x30
 80039d8:	0018      	movs	r0, r3
 80039da:	f7ff ff29 	bl	8003830 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 80039de:	9b02      	ldr	r3, [sp, #8]
}
 80039e0:	0018      	movs	r0, r3
 80039e2:	b005      	add	sp, #20
 80039e4:	bd00      	pop	{pc}
 80039e6:	46c0      	nop			@ (mov r8, r8)
	...

080039f0 <__thd_stackfill>:
 * @param[in] startp    first address to fill
 * @param[in] endp      last address to fill +1
 *
 * @notapi
 */
void __thd_stackfill(uint8_t *startp, uint8_t *endp) {
 80039f0:	b082      	sub	sp, #8
 80039f2:	9001      	str	r0, [sp, #4]
 80039f4:	9100      	str	r1, [sp, #0]

  do {
    *startp++ = CH_DBG_STACK_FILL_VALUE;
 80039f6:	9b01      	ldr	r3, [sp, #4]
 80039f8:	1c5a      	adds	r2, r3, #1
 80039fa:	9201      	str	r2, [sp, #4]
 80039fc:	2255      	movs	r2, #85	@ 0x55
 80039fe:	701a      	strb	r2, [r3, #0]
  } while (likely(startp < endp));
 8003a00:	9a01      	ldr	r2, [sp, #4]
 8003a02:	9b00      	ldr	r3, [sp, #0]
 8003a04:	429a      	cmp	r2, r3
 8003a06:	419b      	sbcs	r3, r3
 8003a08:	425b      	negs	r3, r3
 8003a0a:	b2db      	uxtb	r3, r3
 8003a0c:	2b00      	cmp	r3, #0
 8003a0e:	d1f2      	bne.n	80039f6 <__thd_stackfill+0x6>
}
 8003a10:	46c0      	nop			@ (mov r8, r8)
 8003a12:	46c0      	nop			@ (mov r8, r8)
 8003a14:	b002      	add	sp, #8
 8003a16:	4770      	bx	lr
	...

08003a20 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8003a20:	b500      	push	{lr}
 8003a22:	b085      	sub	sp, #20
 8003a24:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8003a26:	f7fe fc93 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8003a2a:	9b01      	ldr	r3, [sp, #4]
 8003a2c:	425a      	negs	r2, r3
 8003a2e:	4153      	adcs	r3, r2
 8003a30:	b2db      	uxtb	r3, r3
 8003a32:	2b00      	cmp	r3, #0
 8003a34:	d003      	beq.n	8003a3e <chThdCreateSuspendedI+0x1e>
 8003a36:	4b3c      	ldr	r3, [pc, #240]	@ (8003b28 <chThdCreateSuspendedI+0x108>)
 8003a38:	0018      	movs	r0, r3
 8003a3a:	f7fe fb19 	bl	8002070 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8003a3e:	9b01      	ldr	r3, [sp, #4]
 8003a40:	685b      	ldr	r3, [r3, #4]
 8003a42:	001a      	movs	r2, r3
 8003a44:	2307      	movs	r3, #7
 8003a46:	4013      	ands	r3, r2
 8003a48:	1e5a      	subs	r2, r3, #1
 8003a4a:	4193      	sbcs	r3, r2
 8003a4c:	b2db      	uxtb	r3, r3
 8003a4e:	2b00      	cmp	r3, #0
 8003a50:	d109      	bne.n	8003a66 <chThdCreateSuspendedI+0x46>
 8003a52:	9b01      	ldr	r3, [sp, #4]
 8003a54:	689b      	ldr	r3, [r3, #8]
 8003a56:	001a      	movs	r2, r3
 8003a58:	2307      	movs	r3, #7
 8003a5a:	4013      	ands	r3, r2
 8003a5c:	1e5a      	subs	r2, r3, #1
 8003a5e:	4193      	sbcs	r3, r2
 8003a60:	b2db      	uxtb	r3, r3
 8003a62:	2b00      	cmp	r3, #0
 8003a64:	d001      	beq.n	8003a6a <chThdCreateSuspendedI+0x4a>
 8003a66:	2301      	movs	r3, #1
 8003a68:	e000      	b.n	8003a6c <chThdCreateSuspendedI+0x4c>
 8003a6a:	2300      	movs	r3, #0
 8003a6c:	2b00      	cmp	r3, #0
 8003a6e:	d109      	bne.n	8003a84 <chThdCreateSuspendedI+0x64>
 8003a70:	9b01      	ldr	r3, [sp, #4]
 8003a72:	689a      	ldr	r2, [r3, #8]
 8003a74:	9b01      	ldr	r3, [sp, #4]
 8003a76:	6859      	ldr	r1, [r3, #4]
 8003a78:	2300      	movs	r3, #0
 8003a7a:	4291      	cmp	r1, r2
 8003a7c:	415b      	adcs	r3, r3
 8003a7e:	b2db      	uxtb	r3, r3
 8003a80:	2b00      	cmp	r3, #0
 8003a82:	d001      	beq.n	8003a88 <chThdCreateSuspendedI+0x68>
 8003a84:	2301      	movs	r3, #1
 8003a86:	e000      	b.n	8003a8a <chThdCreateSuspendedI+0x6a>
 8003a88:	2300      	movs	r3, #0
 8003a8a:	2b00      	cmp	r3, #0
 8003a8c:	d10c      	bne.n	8003aa8 <chThdCreateSuspendedI+0x88>
 8003a8e:	9b01      	ldr	r3, [sp, #4]
 8003a90:	689b      	ldr	r3, [r3, #8]
 8003a92:	001a      	movs	r2, r3
 8003a94:	9b01      	ldr	r3, [sp, #4]
 8003a96:	685b      	ldr	r3, [r3, #4]
 8003a98:	1ad2      	subs	r2, r2, r3
 8003a9a:	21cf      	movs	r1, #207	@ 0xcf
 8003a9c:	2300      	movs	r3, #0
 8003a9e:	4291      	cmp	r1, r2
 8003aa0:	415b      	adcs	r3, r3
 8003aa2:	b2db      	uxtb	r3, r3
 8003aa4:	2b00      	cmp	r3, #0
 8003aa6:	d003      	beq.n	8003ab0 <chThdCreateSuspendedI+0x90>
 8003aa8:	4b1f      	ldr	r3, [pc, #124]	@ (8003b28 <chThdCreateSuspendedI+0x108>)
 8003aaa:	0018      	movs	r0, r3
 8003aac:	f7fe fae0 	bl	8002070 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8003ab0:	9b01      	ldr	r3, [sp, #4]
 8003ab2:	68db      	ldr	r3, [r3, #12]
 8003ab4:	22ff      	movs	r2, #255	@ 0xff
 8003ab6:	429a      	cmp	r2, r3
 8003ab8:	419b      	sbcs	r3, r3
 8003aba:	425b      	negs	r3, r3
 8003abc:	b2db      	uxtb	r3, r3
 8003abe:	2b00      	cmp	r3, #0
 8003ac0:	d106      	bne.n	8003ad0 <chThdCreateSuspendedI+0xb0>
 8003ac2:	9b01      	ldr	r3, [sp, #4]
 8003ac4:	691b      	ldr	r3, [r3, #16]
 8003ac6:	425a      	negs	r2, r3
 8003ac8:	4153      	adcs	r3, r2
 8003aca:	b2db      	uxtb	r3, r3
 8003acc:	2b00      	cmp	r3, #0
 8003ace:	d003      	beq.n	8003ad8 <chThdCreateSuspendedI+0xb8>
 8003ad0:	4b15      	ldr	r3, [pc, #84]	@ (8003b28 <chThdCreateSuspendedI+0x108>)
 8003ad2:	0018      	movs	r0, r3
 8003ad4:	f7fe facc 	bl	8002070 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 8003ad8:	9b01      	ldr	r3, [sp, #4]
 8003ada:	689b      	ldr	r3, [r3, #8]
 8003adc:	3b48      	subs	r3, #72	@ 0x48
 8003ade:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8003ae0:	9b01      	ldr	r3, [sp, #4]
 8003ae2:	685a      	ldr	r2, [r3, #4]
 8003ae4:	9b03      	ldr	r3, [sp, #12]
 8003ae6:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003ae8:	9b03      	ldr	r3, [sp, #12]
 8003aea:	3b24      	subs	r3, #36	@ 0x24
 8003aec:	001a      	movs	r2, r3
 8003aee:	9b03      	ldr	r3, [sp, #12]
 8003af0:	60da      	str	r2, [r3, #12]
 8003af2:	9b01      	ldr	r3, [sp, #4]
 8003af4:	691a      	ldr	r2, [r3, #16]
 8003af6:	9b03      	ldr	r3, [sp, #12]
 8003af8:	68db      	ldr	r3, [r3, #12]
 8003afa:	611a      	str	r2, [r3, #16]
 8003afc:	9b01      	ldr	r3, [sp, #4]
 8003afe:	695a      	ldr	r2, [r3, #20]
 8003b00:	9b03      	ldr	r3, [sp, #12]
 8003b02:	68db      	ldr	r3, [r3, #12]
 8003b04:	615a      	str	r2, [r3, #20]
 8003b06:	9b03      	ldr	r3, [sp, #12]
 8003b08:	68db      	ldr	r3, [r3, #12]
 8003b0a:	4a08      	ldr	r2, [pc, #32]	@ (8003b2c <chThdCreateSuspendedI+0x10c>)
 8003b0c:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8003b0e:	9b01      	ldr	r3, [sp, #4]
 8003b10:	681a      	ldr	r2, [r3, #0]
 8003b12:	9b01      	ldr	r3, [sp, #4]
 8003b14:	68db      	ldr	r3, [r3, #12]
 8003b16:	9903      	ldr	r1, [sp, #12]
 8003b18:	4805      	ldr	r0, [pc, #20]	@ (8003b30 <chThdCreateSuspendedI+0x110>)
 8003b1a:	f7ff ff29 	bl	8003970 <__thd_object_init>
 8003b1e:	0003      	movs	r3, r0
}
 8003b20:	0018      	movs	r0, r3
 8003b22:	b005      	add	sp, #20
 8003b24:	bd00      	pop	{pc}
 8003b26:	46c0      	nop			@ (mov r8, r8)
 8003b28:	080051d4 	.word	0x080051d4
 8003b2c:	080001b9 	.word	0x080001b9
 8003b30:	20000690 	.word	0x20000690
	...

08003b40 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8003b40:	b500      	push	{lr}
 8003b42:	b083      	sub	sp, #12
 8003b44:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8003b46:	9b01      	ldr	r3, [sp, #4]
 8003b48:	0018      	movs	r0, r3
 8003b4a:	f7ff ff69 	bl	8003a20 <chThdCreateSuspendedI>
 8003b4e:	0003      	movs	r3, r0
 8003b50:	0018      	movs	r0, r3
 8003b52:	f7ff fb95 	bl	8003280 <chSchReadyI>
 8003b56:	0003      	movs	r3, r0
}
 8003b58:	0018      	movs	r0, r3
 8003b5a:	b003      	add	sp, #12
 8003b5c:	bd00      	pop	{pc}
 8003b5e:	46c0      	nop			@ (mov r8, r8)

08003b60 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003b60:	b500      	push	{lr}
 8003b62:	b087      	sub	sp, #28
 8003b64:	9003      	str	r0, [sp, #12]
 8003b66:	9102      	str	r1, [sp, #8]
 8003b68:	9201      	str	r2, [sp, #4]
 8003b6a:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 8003b6c:	9b03      	ldr	r3, [sp, #12]
 8003b6e:	425a      	negs	r2, r3
 8003b70:	4153      	adcs	r3, r2
 8003b72:	b2db      	uxtb	r3, r3
 8003b74:	2b00      	cmp	r3, #0
 8003b76:	d107      	bne.n	8003b88 <chThdCreateStatic+0x28>
 8003b78:	9b03      	ldr	r3, [sp, #12]
 8003b7a:	2207      	movs	r2, #7
 8003b7c:	4013      	ands	r3, r2
 8003b7e:	1e5a      	subs	r2, r3, #1
 8003b80:	4193      	sbcs	r3, r2
 8003b82:	b2db      	uxtb	r3, r3
 8003b84:	2b00      	cmp	r3, #0
 8003b86:	d001      	beq.n	8003b8c <chThdCreateStatic+0x2c>
 8003b88:	2301      	movs	r3, #1
 8003b8a:	e000      	b.n	8003b8e <chThdCreateStatic+0x2e>
 8003b8c:	2300      	movs	r3, #0
 8003b8e:	2b00      	cmp	r3, #0
 8003b90:	d107      	bne.n	8003ba2 <chThdCreateStatic+0x42>
 8003b92:	9a02      	ldr	r2, [sp, #8]
 8003b94:	21cf      	movs	r1, #207	@ 0xcf
 8003b96:	2300      	movs	r3, #0
 8003b98:	4291      	cmp	r1, r2
 8003b9a:	415b      	adcs	r3, r3
 8003b9c:	b2db      	uxtb	r3, r3
 8003b9e:	2b00      	cmp	r3, #0
 8003ba0:	d001      	beq.n	8003ba6 <chThdCreateStatic+0x46>
 8003ba2:	2301      	movs	r3, #1
 8003ba4:	e000      	b.n	8003ba8 <chThdCreateStatic+0x48>
 8003ba6:	2300      	movs	r3, #0
 8003ba8:	2b00      	cmp	r3, #0
 8003baa:	d107      	bne.n	8003bbc <chThdCreateStatic+0x5c>
 8003bac:	9b02      	ldr	r3, [sp, #8]
 8003bae:	2207      	movs	r2, #7
 8003bb0:	4013      	ands	r3, r2
 8003bb2:	1e5a      	subs	r2, r3, #1
 8003bb4:	4193      	sbcs	r3, r2
 8003bb6:	b2db      	uxtb	r3, r3
 8003bb8:	2b00      	cmp	r3, #0
 8003bba:	d001      	beq.n	8003bc0 <chThdCreateStatic+0x60>
 8003bbc:	2301      	movs	r3, #1
 8003bbe:	e000      	b.n	8003bc2 <chThdCreateStatic+0x62>
 8003bc0:	2300      	movs	r3, #0
 8003bc2:	2b00      	cmp	r3, #0
 8003bc4:	d107      	bne.n	8003bd6 <chThdCreateStatic+0x76>
 8003bc6:	9b01      	ldr	r3, [sp, #4]
 8003bc8:	22ff      	movs	r2, #255	@ 0xff
 8003bca:	429a      	cmp	r2, r3
 8003bcc:	419b      	sbcs	r3, r3
 8003bce:	425b      	negs	r3, r3
 8003bd0:	b2db      	uxtb	r3, r3
 8003bd2:	2b00      	cmp	r3, #0
 8003bd4:	d001      	beq.n	8003bda <chThdCreateStatic+0x7a>
 8003bd6:	2301      	movs	r3, #1
 8003bd8:	e000      	b.n	8003bdc <chThdCreateStatic+0x7c>
 8003bda:	2300      	movs	r3, #0
 8003bdc:	2b00      	cmp	r3, #0
 8003bde:	d105      	bne.n	8003bec <chThdCreateStatic+0x8c>
 8003be0:	9b00      	ldr	r3, [sp, #0]
 8003be2:	425a      	negs	r2, r3
 8003be4:	4153      	adcs	r3, r2
 8003be6:	b2db      	uxtb	r3, r3
 8003be8:	2b00      	cmp	r3, #0
 8003bea:	d003      	beq.n	8003bf4 <chThdCreateStatic+0x94>
 8003bec:	4b23      	ldr	r3, [pc, #140]	@ (8003c7c <chThdCreateStatic+0x11c>)
 8003bee:	0018      	movs	r0, r3
 8003bf0:	f7fe fa3e 	bl	8002070 <chSysHalt>
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8003bf4:	9b03      	ldr	r3, [sp, #12]
 8003bf6:	0018      	movs	r0, r3
 8003bf8:	f000 fa22 	bl	8004040 <chRegFindThreadByWorkingArea>
 8003bfc:	0003      	movs	r3, r0
 8003bfe:	1e5a      	subs	r2, r3, #1
 8003c00:	4193      	sbcs	r3, r2
 8003c02:	b2db      	uxtb	r3, r3
 8003c04:	2b00      	cmp	r3, #0
 8003c06:	d003      	beq.n	8003c10 <chThdCreateStatic+0xb0>
 8003c08:	4b1c      	ldr	r3, [pc, #112]	@ (8003c7c <chThdCreateStatic+0x11c>)
 8003c0a:	0018      	movs	r0, r3
 8003c0c:	f7fe fa30 	bl	8002070 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wsp, (uint8_t *)wsp + size);
 8003c10:	9a03      	ldr	r2, [sp, #12]
 8003c12:	9b02      	ldr	r3, [sp, #8]
 8003c14:	18d2      	adds	r2, r2, r3
 8003c16:	9b03      	ldr	r3, [sp, #12]
 8003c18:	0011      	movs	r1, r2
 8003c1a:	0018      	movs	r0, r3
 8003c1c:	f7ff fee8 	bl	80039f0 <__thd_stackfill>
#endif

  chSysLock();
 8003c20:	f7ff fe4e 	bl	80038c0 <chSysLock.lto_priv.7>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 8003c24:	9b02      	ldr	r3, [sp, #8]
 8003c26:	3b48      	subs	r3, #72	@ 0x48
 8003c28:	9a03      	ldr	r2, [sp, #12]
 8003c2a:	18d3      	adds	r3, r2, r3
 8003c2c:	9305      	str	r3, [sp, #20]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8003c2e:	9b05      	ldr	r3, [sp, #20]
 8003c30:	9a03      	ldr	r2, [sp, #12]
 8003c32:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003c34:	9b05      	ldr	r3, [sp, #20]
 8003c36:	3b24      	subs	r3, #36	@ 0x24
 8003c38:	001a      	movs	r2, r3
 8003c3a:	9b05      	ldr	r3, [sp, #20]
 8003c3c:	60da      	str	r2, [r3, #12]
 8003c3e:	9b05      	ldr	r3, [sp, #20]
 8003c40:	68db      	ldr	r3, [r3, #12]
 8003c42:	9a00      	ldr	r2, [sp, #0]
 8003c44:	611a      	str	r2, [r3, #16]
 8003c46:	9b05      	ldr	r3, [sp, #20]
 8003c48:	68db      	ldr	r3, [r3, #12]
 8003c4a:	9a08      	ldr	r2, [sp, #32]
 8003c4c:	615a      	str	r2, [r3, #20]
 8003c4e:	9b05      	ldr	r3, [sp, #20]
 8003c50:	68db      	ldr	r3, [r3, #12]
 8003c52:	4a0b      	ldr	r2, [pc, #44]	@ (8003c80 <chThdCreateStatic+0x120>)
 8003c54:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 8003c56:	9b01      	ldr	r3, [sp, #4]
 8003c58:	4a0a      	ldr	r2, [pc, #40]	@ (8003c84 <chThdCreateStatic+0x124>)
 8003c5a:	9905      	ldr	r1, [sp, #20]
 8003c5c:	480a      	ldr	r0, [pc, #40]	@ (8003c88 <chThdCreateStatic+0x128>)
 8003c5e:	f7ff fe87 	bl	8003970 <__thd_object_init>
 8003c62:	0003      	movs	r3, r0
 8003c64:	9305      	str	r3, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8003c66:	9b05      	ldr	r3, [sp, #20]
 8003c68:	2100      	movs	r1, #0
 8003c6a:	0018      	movs	r0, r3
 8003c6c:	f7ff fbc0 	bl	80033f0 <chSchWakeupS>
  chSysUnlock();
 8003c70:	f7ff fe2e 	bl	80038d0 <chSysUnlock.lto_priv.7>

  return tp;
 8003c74:	9b05      	ldr	r3, [sp, #20]
}
 8003c76:	0018      	movs	r0, r3
 8003c78:	b007      	add	sp, #28
 8003c7a:	bd00      	pop	{pc}
 8003c7c:	080051f8 	.word	0x080051f8
 8003c80:	080001b9 	.word	0x080001b9
 8003c84:	080050a0 	.word	0x080050a0
 8003c88:	20000690 	.word	0x20000690
 8003c8c:	00000000 	.word	0x00000000

08003c90 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8003c90:	b510      	push	{r4, lr}
 8003c92:	b082      	sub	sp, #8
 8003c94:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003c96:	f7ff fe13 	bl	80038c0 <chSysLock.lto_priv.7>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8003c9a:	9b01      	ldr	r3, [sp, #4]
 8003c9c:	2226      	movs	r2, #38	@ 0x26
 8003c9e:	5c9b      	ldrb	r3, [r3, r2]
 8003ca0:	425a      	negs	r2, r3
 8003ca2:	4153      	adcs	r3, r2
 8003ca4:	b2db      	uxtb	r3, r3
 8003ca6:	2b00      	cmp	r3, #0
 8003ca8:	d003      	beq.n	8003cb2 <chThdRelease+0x22>
 8003caa:	4b21      	ldr	r3, [pc, #132]	@ (8003d30 <chThdRelease+0xa0>)
 8003cac:	0018      	movs	r0, r3
 8003cae:	f7fe f9df 	bl	8002070 <chSysHalt>
  tp->refs--;
 8003cb2:	9b01      	ldr	r3, [sp, #4]
 8003cb4:	2226      	movs	r2, #38	@ 0x26
 8003cb6:	5c9b      	ldrb	r3, [r3, r2]
 8003cb8:	3b01      	subs	r3, #1
 8003cba:	b2d9      	uxtb	r1, r3
 8003cbc:	9b01      	ldr	r3, [sp, #4]
 8003cbe:	2226      	movs	r2, #38	@ 0x26
 8003cc0:	5499      	strb	r1, [r3, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8003cc2:	9b01      	ldr	r3, [sp, #4]
 8003cc4:	2226      	movs	r2, #38	@ 0x26
 8003cc6:	5c9b      	ldrb	r3, [r3, r2]
 8003cc8:	2b00      	cmp	r3, #0
 8003cca:	d12c      	bne.n	8003d26 <chThdRelease+0x96>
 8003ccc:	9b01      	ldr	r3, [sp, #4]
 8003cce:	2224      	movs	r2, #36	@ 0x24
 8003cd0:	5c9b      	ldrb	r3, [r3, r2]
 8003cd2:	2b0f      	cmp	r3, #15
 8003cd4:	d127      	bne.n	8003d26 <chThdRelease+0x96>
    REG_REMOVE(tp);
 8003cd6:	9b01      	ldr	r3, [sp, #4]
 8003cd8:	3310      	adds	r3, #16
 8003cda:	0018      	movs	r0, r3
 8003cdc:	f7ff fdd0 	bl	8003880 <ch_queue_dequeue.lto_priv.1>
    chSysUnlock();
 8003ce0:	f7ff fdf6 	bl	80038d0 <chSysUnlock.lto_priv.7>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8003ce4:	9b01      	ldr	r3, [sp, #4]
 8003ce6:	2225      	movs	r2, #37	@ 0x25
 8003ce8:	5c9b      	ldrb	r3, [r3, r2]
 8003cea:	001a      	movs	r2, r3
 8003cec:	2303      	movs	r3, #3
 8003cee:	4013      	ands	r3, r2
 8003cf0:	2b01      	cmp	r3, #1
 8003cf2:	d002      	beq.n	8003cfa <chThdRelease+0x6a>
 8003cf4:	2b02      	cmp	r3, #2
 8003cf6:	d009      	beq.n	8003d0c <chThdRelease+0x7c>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
      /* Nothing else to do for static threads.*/
      break;
 8003cf8:	e014      	b.n	8003d24 <chThdRelease+0x94>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8003cfa:	9b01      	ldr	r3, [sp, #4]
 8003cfc:	0018      	movs	r0, r3
 8003cfe:	f7ff fe17 	bl	8003930 <chThdGetWorkingAreaX.lto_priv.0>
 8003d02:	0003      	movs	r3, r0
 8003d04:	0018      	movs	r0, r3
 8003d06:	f000 fc93 	bl	8004630 <chHeapFree>
      break;
 8003d0a:	e00b      	b.n	8003d24 <chThdRelease+0x94>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8003d0c:	9b01      	ldr	r3, [sp, #4]
 8003d0e:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
 8003d10:	9b01      	ldr	r3, [sp, #4]
 8003d12:	0018      	movs	r0, r3
 8003d14:	f7ff fe0c 	bl	8003930 <chThdGetWorkingAreaX.lto_priv.0>
 8003d18:	0003      	movs	r3, r0
 8003d1a:	0019      	movs	r1, r3
 8003d1c:	0020      	movs	r0, r4
 8003d1e:	f000 fde7 	bl	80048f0 <chPoolFree>
      break;
 8003d22:	46c0      	nop			@ (mov r8, r8)
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
 8003d24:	e001      	b.n	8003d2a <chThdRelease+0x9a>
  }
  chSysUnlock();
 8003d26:	f7ff fdd3 	bl	80038d0 <chSysUnlock.lto_priv.7>
}
 8003d2a:	b002      	add	sp, #8
 8003d2c:	bd10      	pop	{r4, pc}
 8003d2e:	46c0      	nop			@ (mov r8, r8)
 8003d30:	0800520c 	.word	0x0800520c
	...

08003d40 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8003d40:	b500      	push	{lr}
 8003d42:	b083      	sub	sp, #12
 8003d44:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003d46:	f7ff fdbb 	bl	80038c0 <chSysLock.lto_priv.7>
  chThdExitS(msg);
 8003d4a:	9b01      	ldr	r3, [sp, #4]
 8003d4c:	0018      	movs	r0, r3
 8003d4e:	f000 f807 	bl	8003d60 <chThdExitS>
  /* The thread never returns here.*/
}
 8003d52:	46c0      	nop			@ (mov r8, r8)
 8003d54:	b003      	add	sp, #12
 8003d56:	bd00      	pop	{pc}
	...

08003d60 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8003d60:	b500      	push	{lr}
 8003d62:	b085      	sub	sp, #20
 8003d64:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8003d66:	f7ff fddb 	bl	8003920 <chThdGetSelfX.lto_priv.0>
 8003d6a:	0003      	movs	r3, r0
 8003d6c:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 8003d6e:	9b03      	ldr	r3, [sp, #12]
 8003d70:	9a01      	ldr	r2, [sp, #4]
 8003d72:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003d74:	e008      	b.n	8003d88 <chThdExitS+0x28>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8003d76:	9b03      	ldr	r3, [sp, #12]
 8003d78:	332c      	adds	r3, #44	@ 0x2c
 8003d7a:	0018      	movs	r0, r3
 8003d7c:	f7ff fd48 	bl	8003810 <ch_list_unlink>
 8003d80:	0003      	movs	r3, r0
 8003d82:	0018      	movs	r0, r3
 8003d84:	f7ff fa7c 	bl	8003280 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003d88:	9b03      	ldr	r3, [sp, #12]
 8003d8a:	332c      	adds	r3, #44	@ 0x2c
 8003d8c:	0018      	movs	r0, r3
 8003d8e:	f7ff fd2f 	bl	80037f0 <ch_list_notempty>
 8003d92:	1e03      	subs	r3, r0, #0
 8003d94:	d1ef      	bne.n	8003d76 <chThdExitS+0x16>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8003d96:	9b03      	ldr	r3, [sp, #12]
 8003d98:	2226      	movs	r2, #38	@ 0x26
 8003d9a:	5c9b      	ldrb	r3, [r3, r2]
 8003d9c:	425a      	negs	r2, r3
 8003d9e:	4153      	adcs	r3, r2
 8003da0:	b2db      	uxtb	r3, r3
 8003da2:	2b00      	cmp	r3, #0
 8003da4:	d00f      	beq.n	8003dc6 <chThdExitS+0x66>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8003da6:	9b03      	ldr	r3, [sp, #12]
 8003da8:	2225      	movs	r2, #37	@ 0x25
 8003daa:	5c9b      	ldrb	r3, [r3, r2]
 8003dac:	001a      	movs	r2, r3
 8003dae:	2303      	movs	r3, #3
 8003db0:	4013      	ands	r3, r2
 8003db2:	425a      	negs	r2, r3
 8003db4:	4153      	adcs	r3, r2
 8003db6:	b2db      	uxtb	r3, r3
 8003db8:	2b00      	cmp	r3, #0
 8003dba:	d004      	beq.n	8003dc6 <chThdExitS+0x66>
      REG_REMOVE(currtp);
 8003dbc:	9b03      	ldr	r3, [sp, #12]
 8003dbe:	3310      	adds	r3, #16
 8003dc0:	0018      	movs	r0, r3
 8003dc2:	f7ff fd5d 	bl	8003880 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003dc6:	200f      	movs	r0, #15
 8003dc8:	f7ff fa7a 	bl	80032c0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8003dcc:	4b03      	ldr	r3, [pc, #12]	@ (8003ddc <chThdExitS+0x7c>)
 8003dce:	0018      	movs	r0, r3
 8003dd0:	f7fe f94e 	bl	8002070 <chSysHalt>
}
 8003dd4:	46c0      	nop			@ (mov r8, r8)
 8003dd6:	b005      	add	sp, #20
 8003dd8:	bd00      	pop	{pc}
 8003dda:	46c0      	nop			@ (mov r8, r8)
 8003ddc:	0800521c 	.word	0x0800521c

08003de0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8003de0:	b500      	push	{lr}
 8003de2:	b083      	sub	sp, #12
 8003de4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003de6:	f7ff fd6b 	bl	80038c0 <chSysLock.lto_priv.7>
  chThdSleepS(time);
 8003dea:	9b01      	ldr	r3, [sp, #4]
 8003dec:	0018      	movs	r0, r3
 8003dee:	f7ff fda7 	bl	8003940 <chThdSleepS>
  chSysUnlock();
 8003df2:	f7ff fd6d 	bl	80038d0 <chSysUnlock.lto_priv.7>
}
 8003df6:	46c0      	nop			@ (mov r8, r8)
 8003df8:	b003      	add	sp, #12
 8003dfa:	bd00      	pop	{pc}
 8003dfc:	0000      	movs	r0, r0
	...

08003e00 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8003e00:	b500      	push	{lr}
 8003e02:	b085      	sub	sp, #20
 8003e04:	9001      	str	r0, [sp, #4]
 8003e06:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8003e08:	f7ff fd8a 	bl	8003920 <chThdGetSelfX.lto_priv.0>
 8003e0c:	0003      	movs	r3, r0
 8003e0e:	9303      	str	r3, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 8003e10:	9b01      	ldr	r3, [sp, #4]
 8003e12:	681b      	ldr	r3, [r3, #0]
 8003e14:	1e5a      	subs	r2, r3, #1
 8003e16:	4193      	sbcs	r3, r2
 8003e18:	b2db      	uxtb	r3, r3
 8003e1a:	2b00      	cmp	r3, #0
 8003e1c:	d003      	beq.n	8003e26 <chThdSuspendTimeoutS+0x26>
 8003e1e:	4b0e      	ldr	r3, [pc, #56]	@ (8003e58 <chThdSuspendTimeoutS+0x58>)
 8003e20:	0018      	movs	r0, r3
 8003e22:	f7fe f925 	bl	8002070 <chSysHalt>

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8003e26:	9b00      	ldr	r3, [sp, #0]
 8003e28:	425a      	negs	r2, r3
 8003e2a:	4153      	adcs	r3, r2
 8003e2c:	b2db      	uxtb	r3, r3
 8003e2e:	2b00      	cmp	r3, #0
 8003e30:	d002      	beq.n	8003e38 <chThdSuspendTimeoutS+0x38>
    return MSG_TIMEOUT;
 8003e32:	2301      	movs	r3, #1
 8003e34:	425b      	negs	r3, r3
 8003e36:	e00b      	b.n	8003e50 <chThdSuspendTimeoutS+0x50>
  }

  *trp = tp;
 8003e38:	9b01      	ldr	r3, [sp, #4]
 8003e3a:	9a03      	ldr	r2, [sp, #12]
 8003e3c:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8003e3e:	9b03      	ldr	r3, [sp, #12]
 8003e40:	9a01      	ldr	r2, [sp, #4]
 8003e42:	629a      	str	r2, [r3, #40]	@ 0x28

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003e44:	9b00      	ldr	r3, [sp, #0]
 8003e46:	0019      	movs	r1, r3
 8003e48:	2003      	movs	r0, #3
 8003e4a:	f7ff fa99 	bl	8003380 <chSchGoSleepTimeoutS>
 8003e4e:	0003      	movs	r3, r0
}
 8003e50:	0018      	movs	r0, r3
 8003e52:	b005      	add	sp, #20
 8003e54:	bd00      	pop	{pc}
 8003e56:	46c0      	nop			@ (mov r8, r8)
 8003e58:	08005234 	.word	0x08005234
 8003e5c:	00000000 	.word	0x00000000

08003e60 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8003e60:	b500      	push	{lr}
 8003e62:	b085      	sub	sp, #20
 8003e64:	9001      	str	r0, [sp, #4]
 8003e66:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8003e68:	9b01      	ldr	r3, [sp, #4]
 8003e6a:	681b      	ldr	r3, [r3, #0]
 8003e6c:	2b00      	cmp	r3, #0
 8003e6e:	d019      	beq.n	8003ea4 <chThdResumeI+0x44>
    thread_t *tp = *trp;
 8003e70:	9b01      	ldr	r3, [sp, #4]
 8003e72:	681b      	ldr	r3, [r3, #0]
 8003e74:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8003e76:	9b03      	ldr	r3, [sp, #12]
 8003e78:	2224      	movs	r2, #36	@ 0x24
 8003e7a:	5c9b      	ldrb	r3, [r3, r2]
 8003e7c:	3b03      	subs	r3, #3
 8003e7e:	1e5a      	subs	r2, r3, #1
 8003e80:	4193      	sbcs	r3, r2
 8003e82:	b2db      	uxtb	r3, r3
 8003e84:	2b00      	cmp	r3, #0
 8003e86:	d003      	beq.n	8003e90 <chThdResumeI+0x30>
 8003e88:	4b08      	ldr	r3, [pc, #32]	@ (8003eac <chThdResumeI+0x4c>)
 8003e8a:	0018      	movs	r0, r3
 8003e8c:	f7fe f8f0 	bl	8002070 <chSysHalt>

    *trp = NULL;
 8003e90:	9b01      	ldr	r3, [sp, #4]
 8003e92:	2200      	movs	r2, #0
 8003e94:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8003e96:	9b03      	ldr	r3, [sp, #12]
 8003e98:	9a00      	ldr	r2, [sp, #0]
 8003e9a:	629a      	str	r2, [r3, #40]	@ 0x28
    (void) chSchReadyI(tp);
 8003e9c:	9b03      	ldr	r3, [sp, #12]
 8003e9e:	0018      	movs	r0, r3
 8003ea0:	f7ff f9ee 	bl	8003280 <chSchReadyI>
  }
}
 8003ea4:	46c0      	nop			@ (mov r8, r8)
 8003ea6:	b005      	add	sp, #20
 8003ea8:	bd00      	pop	{pc}
 8003eaa:	46c0      	nop			@ (mov r8, r8)
 8003eac:	0800524c 	.word	0x0800524c

08003eb0 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8003eb0:	b500      	push	{lr}
 8003eb2:	b085      	sub	sp, #20
 8003eb4:	9001      	str	r0, [sp, #4]
 8003eb6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8003eb8:	9b01      	ldr	r3, [sp, #4]
 8003eba:	681b      	ldr	r3, [r3, #0]
 8003ebc:	2b00      	cmp	r3, #0
 8003ebe:	d018      	beq.n	8003ef2 <chThdResumeS+0x42>
    thread_t *tp = *trp;
 8003ec0:	9b01      	ldr	r3, [sp, #4]
 8003ec2:	681b      	ldr	r3, [r3, #0]
 8003ec4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8003ec6:	9b03      	ldr	r3, [sp, #12]
 8003ec8:	2224      	movs	r2, #36	@ 0x24
 8003eca:	5c9b      	ldrb	r3, [r3, r2]
 8003ecc:	3b03      	subs	r3, #3
 8003ece:	1e5a      	subs	r2, r3, #1
 8003ed0:	4193      	sbcs	r3, r2
 8003ed2:	b2db      	uxtb	r3, r3
 8003ed4:	2b00      	cmp	r3, #0
 8003ed6:	d003      	beq.n	8003ee0 <chThdResumeS+0x30>
 8003ed8:	4b07      	ldr	r3, [pc, #28]	@ (8003ef8 <chThdResumeS+0x48>)
 8003eda:	0018      	movs	r0, r3
 8003edc:	f7fe f8c8 	bl	8002070 <chSysHalt>

    *trp = NULL;
 8003ee0:	9b01      	ldr	r3, [sp, #4]
 8003ee2:	2200      	movs	r2, #0
 8003ee4:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 8003ee6:	9a00      	ldr	r2, [sp, #0]
 8003ee8:	9b03      	ldr	r3, [sp, #12]
 8003eea:	0011      	movs	r1, r2
 8003eec:	0018      	movs	r0, r3
 8003eee:	f7ff fa7f 	bl	80033f0 <chSchWakeupS>
  }
}
 8003ef2:	46c0      	nop			@ (mov r8, r8)
 8003ef4:	b005      	add	sp, #20
 8003ef6:	bd00      	pop	{pc}
 8003ef8:	0800525c 	.word	0x0800525c
 8003efc:	00000000 	.word	0x00000000

08003f00 <port_lock.lto_priv.13>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003f00:	b672      	cpsid	i
}
 8003f02:	46c0      	nop			@ (mov r8, r8)
}
 8003f04:	46c0      	nop			@ (mov r8, r8)
 8003f06:	4770      	bx	lr
	...

08003f10 <port_unlock.lto_priv.13>:
  __ASM volatile ("cpsie i" : : : "memory");
 8003f10:	b662      	cpsie	i
}
 8003f12:	46c0      	nop			@ (mov r8, r8)
}
 8003f14:	46c0      	nop			@ (mov r8, r8)
 8003f16:	4770      	bx	lr
	...

08003f20 <chSysLock.lto_priv.8>:
static inline void chSysLock(void) {
 8003f20:	b510      	push	{r4, lr}
  port_lock();
 8003f22:	f7ff ffed 	bl	8003f00 <port_lock.lto_priv.13>
  __dbg_check_lock();
 8003f26:	f7fe f913 	bl	8002150 <__dbg_check_lock>
}
 8003f2a:	46c0      	nop			@ (mov r8, r8)
 8003f2c:	bd10      	pop	{r4, pc}
 8003f2e:	46c0      	nop			@ (mov r8, r8)

08003f30 <chSysUnlock.lto_priv.8>:
static inline void chSysUnlock(void) {
 8003f30:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8003f32:	f7fe f935 	bl	80021a0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003f36:	4b0e      	ldr	r3, [pc, #56]	@ (8003f70 <chSysUnlock.lto_priv.8+0x40>)
 8003f38:	681a      	ldr	r2, [r3, #0]
 8003f3a:	4b0d      	ldr	r3, [pc, #52]	@ (8003f70 <chSysUnlock.lto_priv.8+0x40>)
 8003f3c:	1ad3      	subs	r3, r2, r3
 8003f3e:	1e5a      	subs	r2, r3, #1
 8003f40:	4193      	sbcs	r3, r2
 8003f42:	b2db      	uxtb	r3, r3
 8003f44:	2b00      	cmp	r3, #0
 8003f46:	d00f      	beq.n	8003f68 <chSysUnlock.lto_priv.8+0x38>
 8003f48:	4b09      	ldr	r3, [pc, #36]	@ (8003f70 <chSysUnlock.lto_priv.8+0x40>)
 8003f4a:	68db      	ldr	r3, [r3, #12]
 8003f4c:	689a      	ldr	r2, [r3, #8]
 8003f4e:	4b08      	ldr	r3, [pc, #32]	@ (8003f70 <chSysUnlock.lto_priv.8+0x40>)
 8003f50:	681b      	ldr	r3, [r3, #0]
 8003f52:	689b      	ldr	r3, [r3, #8]
 8003f54:	429a      	cmp	r2, r3
 8003f56:	419b      	sbcs	r3, r3
 8003f58:	425b      	negs	r3, r3
 8003f5a:	b2db      	uxtb	r3, r3
 8003f5c:	2b00      	cmp	r3, #0
 8003f5e:	d003      	beq.n	8003f68 <chSysUnlock.lto_priv.8+0x38>
 8003f60:	4b04      	ldr	r3, [pc, #16]	@ (8003f74 <chSysUnlock.lto_priv.8+0x44>)
 8003f62:	0018      	movs	r0, r3
 8003f64:	f7fe f884 	bl	8002070 <chSysHalt>
  port_unlock();
 8003f68:	f7ff ffd2 	bl	8003f10 <port_unlock.lto_priv.13>
}
 8003f6c:	46c0      	nop			@ (mov r8, r8)
 8003f6e:	bd10      	pop	{r4, pc}
 8003f70:	20000690 	.word	0x20000690
 8003f74:	08005298 	.word	0x08005298
	...

08003f80 <chThdGetWorkingAreaX.lto_priv.1>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8003f80:	b082      	sub	sp, #8
 8003f82:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8003f84:	9b01      	ldr	r3, [sp, #4]
 8003f86:	6a1b      	ldr	r3, [r3, #32]
}
 8003f88:	0018      	movs	r0, r3
 8003f8a:	b002      	add	sp, #8
 8003f8c:	4770      	bx	lr
 8003f8e:	46c0      	nop			@ (mov r8, r8)

08003f90 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8003f90:	b500      	push	{lr}
 8003f92:	b083      	sub	sp, #12
  thread_t *tp;
  uint8_t *p;

  chSysLock();
 8003f94:	f7ff ffc4 	bl	8003f20 <chSysLock.lto_priv.8>
  p = (uint8_t *)REG_HEADER(currcore)->next;
 8003f98:	4b09      	ldr	r3, [pc, #36]	@ (8003fc0 <chRegFirstThread+0x30>)
 8003f9a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003f9c:	9301      	str	r3, [sp, #4]
  /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8003f9e:	9b01      	ldr	r3, [sp, #4]
 8003fa0:	3b10      	subs	r3, #16
 8003fa2:	9300      	str	r3, [sp, #0]
  /*lint -restore*/
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8003fa4:	9b00      	ldr	r3, [sp, #0]
 8003fa6:	2226      	movs	r2, #38	@ 0x26
 8003fa8:	5c9b      	ldrb	r3, [r3, r2]
 8003faa:	3301      	adds	r3, #1
 8003fac:	b2d9      	uxtb	r1, r3
 8003fae:	9b00      	ldr	r3, [sp, #0]
 8003fb0:	2226      	movs	r2, #38	@ 0x26
 8003fb2:	5499      	strb	r1, [r3, r2]
#endif
  chSysUnlock();
 8003fb4:	f7ff ffbc 	bl	8003f30 <chSysUnlock.lto_priv.8>

  return tp;
 8003fb8:	9b00      	ldr	r3, [sp, #0]
}
 8003fba:	0018      	movs	r0, r3
 8003fbc:	b003      	add	sp, #12
 8003fbe:	bd00      	pop	{pc}
 8003fc0:	20000690 	.word	0x20000690
	...

08003fd0 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8003fd0:	b500      	push	{lr}
 8003fd2:	b087      	sub	sp, #28
 8003fd4:	9001      	str	r0, [sp, #4]
  thread_t *ntp;
  ch_queue_t *nqp;

  chSysLock();
 8003fd6:	f7ff ffa3 	bl	8003f20 <chSysLock.lto_priv.8>

  /* Next element in the registry queue.*/
  nqp = tp->rqueue.next;
 8003fda:	9b01      	ldr	r3, [sp, #4]
 8003fdc:	691b      	ldr	r3, [r3, #16]
 8003fde:	9304      	str	r3, [sp, #16]
  if (nqp == REG_HEADER(currcore)) {
 8003fe0:	9a04      	ldr	r2, [sp, #16]
 8003fe2:	4b15      	ldr	r3, [pc, #84]	@ (8004038 <chRegNextThread+0x68>)
 8003fe4:	429a      	cmp	r2, r3
 8003fe6:	d102      	bne.n	8003fee <chRegNextThread+0x1e>
    ntp = NULL;
 8003fe8:	2300      	movs	r3, #0
 8003fea:	9305      	str	r3, [sp, #20]
 8003fec:	e019      	b.n	8004022 <chRegNextThread+0x52>
  }
  else {
    uint8_t *p = (uint8_t *)nqp;
 8003fee:	9b04      	ldr	r3, [sp, #16]
 8003ff0:	9303      	str	r3, [sp, #12]
    /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8003ff2:	9b03      	ldr	r3, [sp, #12]
 8003ff4:	3b10      	subs	r3, #16
 8003ff6:	9305      	str	r3, [sp, #20]
    /*lint -restore*/

#if CH_CFG_USE_DYNAMIC == TRUE
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8003ff8:	9b05      	ldr	r3, [sp, #20]
 8003ffa:	2226      	movs	r2, #38	@ 0x26
 8003ffc:	5c9b      	ldrb	r3, [r3, r2]
 8003ffe:	3bff      	subs	r3, #255	@ 0xff
 8004000:	425a      	negs	r2, r3
 8004002:	4153      	adcs	r3, r2
 8004004:	b2db      	uxtb	r3, r3
 8004006:	2b00      	cmp	r3, #0
 8004008:	d003      	beq.n	8004012 <chRegNextThread+0x42>
 800400a:	4b0c      	ldr	r3, [pc, #48]	@ (800403c <chRegNextThread+0x6c>)
 800400c:	0018      	movs	r0, r3
 800400e:	f7fe f82f 	bl	8002070 <chSysHalt>

    ntp->refs++;
 8004012:	9b05      	ldr	r3, [sp, #20]
 8004014:	2226      	movs	r2, #38	@ 0x26
 8004016:	5c9b      	ldrb	r3, [r3, r2]
 8004018:	3301      	adds	r3, #1
 800401a:	b2d9      	uxtb	r1, r3
 800401c:	9b05      	ldr	r3, [sp, #20]
 800401e:	2226      	movs	r2, #38	@ 0x26
 8004020:	5499      	strb	r1, [r3, r2]
#endif
  }
  chSysUnlock();
 8004022:	f7ff ff85 	bl	8003f30 <chSysUnlock.lto_priv.8>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8004026:	9b01      	ldr	r3, [sp, #4]
 8004028:	0018      	movs	r0, r3
 800402a:	f7ff fe31 	bl	8003c90 <chThdRelease>
#endif

  return ntp;
 800402e:	9b05      	ldr	r3, [sp, #20]
}
 8004030:	0018      	movs	r0, r3
 8004032:	b007      	add	sp, #28
 8004034:	bd00      	pop	{pc}
 8004036:	46c0      	nop			@ (mov r8, r8)
 8004038:	200006b8 	.word	0x200006b8
 800403c:	080052a4 	.word	0x080052a4

08004040 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8004040:	b500      	push	{lr}
 8004042:	b085      	sub	sp, #20
 8004044:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8004046:	f7ff ffa3 	bl	8003f90 <chRegFirstThread>
 800404a:	0003      	movs	r3, r0
 800404c:	9303      	str	r3, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800404e:	9b03      	ldr	r3, [sp, #12]
 8004050:	0018      	movs	r0, r3
 8004052:	f7ff ff95 	bl	8003f80 <chThdGetWorkingAreaX.lto_priv.1>
 8004056:	0002      	movs	r2, r0
 8004058:	9b01      	ldr	r3, [sp, #4]
 800405a:	4293      	cmp	r3, r2
 800405c:	d101      	bne.n	8004062 <chRegFindThreadByWorkingArea+0x22>
      return ctp;
 800405e:	9b03      	ldr	r3, [sp, #12]
 8004060:	e009      	b.n	8004076 <chRegFindThreadByWorkingArea+0x36>
    }
    ctp = chRegNextThread(ctp);
 8004062:	9b03      	ldr	r3, [sp, #12]
 8004064:	0018      	movs	r0, r3
 8004066:	f7ff ffb3 	bl	8003fd0 <chRegNextThread>
 800406a:	0003      	movs	r3, r0
 800406c:	9303      	str	r3, [sp, #12]
  } while (ctp != NULL);
 800406e:	9b03      	ldr	r3, [sp, #12]
 8004070:	2b00      	cmp	r3, #0
 8004072:	d1ec      	bne.n	800404e <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 8004074:	2300      	movs	r3, #0
}
 8004076:	0018      	movs	r0, r3
 8004078:	b005      	add	sp, #20
 800407a:	bd00      	pop	{pc}
 800407c:	0000      	movs	r0, r0
	...

08004080 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004080:	b082      	sub	sp, #8
 8004082:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004084:	9b01      	ldr	r3, [sp, #4]
 8004086:	9a01      	ldr	r2, [sp, #4]
 8004088:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800408a:	9b01      	ldr	r3, [sp, #4]
 800408c:	9a01      	ldr	r2, [sp, #4]
 800408e:	605a      	str	r2, [r3, #4]
}
 8004090:	46c0      	nop			@ (mov r8, r8)
 8004092:	b002      	add	sp, #8
 8004094:	4770      	bx	lr
 8004096:	46c0      	nop			@ (mov r8, r8)
	...

080040a0 <ch_queue_notempty.lto_priv.2>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 80040a0:	b082      	sub	sp, #8
 80040a2:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 80040a4:	9b01      	ldr	r3, [sp, #4]
 80040a6:	681b      	ldr	r3, [r3, #0]
 80040a8:	9a01      	ldr	r2, [sp, #4]
 80040aa:	1ad3      	subs	r3, r2, r3
 80040ac:	1e5a      	subs	r2, r3, #1
 80040ae:	4193      	sbcs	r3, r2
 80040b0:	b2db      	uxtb	r3, r3
}
 80040b2:	0018      	movs	r0, r3
 80040b4:	b002      	add	sp, #8
 80040b6:	4770      	bx	lr
	...

080040c0 <ch_queue_fifo_remove.lto_priv.2>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 80040c0:	b084      	sub	sp, #16
 80040c2:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 80040c4:	9b01      	ldr	r3, [sp, #4]
 80040c6:	681b      	ldr	r3, [r3, #0]
 80040c8:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 80040ca:	9b03      	ldr	r3, [sp, #12]
 80040cc:	681a      	ldr	r2, [r3, #0]
 80040ce:	9b01      	ldr	r3, [sp, #4]
 80040d0:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 80040d2:	9b01      	ldr	r3, [sp, #4]
 80040d4:	681b      	ldr	r3, [r3, #0]
 80040d6:	9a01      	ldr	r2, [sp, #4]
 80040d8:	605a      	str	r2, [r3, #4]
  return p;
 80040da:	9b03      	ldr	r3, [sp, #12]
}
 80040dc:	0018      	movs	r0, r3
 80040de:	b004      	add	sp, #16
 80040e0:	4770      	bx	lr
 80040e2:	46c0      	nop			@ (mov r8, r8)
	...

080040f0 <ch_queue_dequeue.lto_priv.2>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80040f0:	b082      	sub	sp, #8
 80040f2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80040f4:	9b01      	ldr	r3, [sp, #4]
 80040f6:	685b      	ldr	r3, [r3, #4]
 80040f8:	9a01      	ldr	r2, [sp, #4]
 80040fa:	6812      	ldr	r2, [r2, #0]
 80040fc:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80040fe:	9b01      	ldr	r3, [sp, #4]
 8004100:	681b      	ldr	r3, [r3, #0]
 8004102:	9a01      	ldr	r2, [sp, #4]
 8004104:	6852      	ldr	r2, [r2, #4]
 8004106:	605a      	str	r2, [r3, #4]
  return p;
 8004108:	9b01      	ldr	r3, [sp, #4]
}
 800410a:	0018      	movs	r0, r3
 800410c:	b002      	add	sp, #8
 800410e:	4770      	bx	lr

08004110 <port_lock.lto_priv.15>:
  __ASM volatile ("cpsid i" : : : "memory");
 8004110:	b672      	cpsid	i
}
 8004112:	46c0      	nop			@ (mov r8, r8)
}
 8004114:	46c0      	nop			@ (mov r8, r8)
 8004116:	4770      	bx	lr
	...

08004120 <port_unlock.lto_priv.15>:
  __ASM volatile ("cpsie i" : : : "memory");
 8004120:	b662      	cpsie	i
}
 8004122:	46c0      	nop			@ (mov r8, r8)
}
 8004124:	46c0      	nop			@ (mov r8, r8)
 8004126:	4770      	bx	lr
	...

08004130 <chSysLock.lto_priv.10>:
static inline void chSysLock(void) {
 8004130:	b510      	push	{r4, lr}
  port_lock();
 8004132:	f7ff ffed 	bl	8004110 <port_lock.lto_priv.15>
  __dbg_check_lock();
 8004136:	f7fe f80b 	bl	8002150 <__dbg_check_lock>
}
 800413a:	46c0      	nop			@ (mov r8, r8)
 800413c:	bd10      	pop	{r4, pc}
 800413e:	46c0      	nop			@ (mov r8, r8)

08004140 <chSysUnlock.lto_priv.10>:
static inline void chSysUnlock(void) {
 8004140:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8004142:	f7fe f82d 	bl	80021a0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004146:	4b0e      	ldr	r3, [pc, #56]	@ (8004180 <chSysUnlock.lto_priv.10+0x40>)
 8004148:	681a      	ldr	r2, [r3, #0]
 800414a:	4b0d      	ldr	r3, [pc, #52]	@ (8004180 <chSysUnlock.lto_priv.10+0x40>)
 800414c:	1ad3      	subs	r3, r2, r3
 800414e:	1e5a      	subs	r2, r3, #1
 8004150:	4193      	sbcs	r3, r2
 8004152:	b2db      	uxtb	r3, r3
 8004154:	2b00      	cmp	r3, #0
 8004156:	d00f      	beq.n	8004178 <chSysUnlock.lto_priv.10+0x38>
 8004158:	4b09      	ldr	r3, [pc, #36]	@ (8004180 <chSysUnlock.lto_priv.10+0x40>)
 800415a:	68db      	ldr	r3, [r3, #12]
 800415c:	689a      	ldr	r2, [r3, #8]
 800415e:	4b08      	ldr	r3, [pc, #32]	@ (8004180 <chSysUnlock.lto_priv.10+0x40>)
 8004160:	681b      	ldr	r3, [r3, #0]
 8004162:	689b      	ldr	r3, [r3, #8]
 8004164:	429a      	cmp	r2, r3
 8004166:	419b      	sbcs	r3, r3
 8004168:	425b      	negs	r3, r3
 800416a:	b2db      	uxtb	r3, r3
 800416c:	2b00      	cmp	r3, #0
 800416e:	d003      	beq.n	8004178 <chSysUnlock.lto_priv.10+0x38>
 8004170:	4b04      	ldr	r3, [pc, #16]	@ (8004184 <chSysUnlock.lto_priv.10+0x44>)
 8004172:	0018      	movs	r0, r3
 8004174:	f7fd ff7c 	bl	8002070 <chSysHalt>
  port_unlock();
 8004178:	f7ff ffd2 	bl	8004120 <port_unlock.lto_priv.15>
}
 800417c:	46c0      	nop			@ (mov r8, r8)
 800417e:	bd10      	pop	{r4, pc}
 8004180:	20000690 	.word	0x20000690
 8004184:	080052c4 	.word	0x080052c4
	...

08004190 <ch_sch_prio_insert.lto_priv.0>:
/*===========================================================================*/

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 8004190:	b084      	sub	sp, #16
 8004192:	9001      	str	r0, [sp, #4]
 8004194:	9100      	str	r1, [sp, #0]

  ch_queue_t *cp = qp;
 8004196:	9b01      	ldr	r3, [sp, #4]
 8004198:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->next;
 800419a:	9b03      	ldr	r3, [sp, #12]
 800419c:	681b      	ldr	r3, [r3, #0]
 800419e:	9303      	str	r3, [sp, #12]
  } while ((cp != qp) &&
 80041a0:	9a03      	ldr	r2, [sp, #12]
 80041a2:	9b01      	ldr	r3, [sp, #4]
 80041a4:	429a      	cmp	r2, r3
 80041a6:	d005      	beq.n	80041b4 <ch_sch_prio_insert.lto_priv.0+0x24>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 80041a8:	9b03      	ldr	r3, [sp, #12]
 80041aa:	689a      	ldr	r2, [r3, #8]
 80041ac:	9b00      	ldr	r3, [sp, #0]
 80041ae:	689b      	ldr	r3, [r3, #8]
  } while ((cp != qp) &&
 80041b0:	429a      	cmp	r2, r3
 80041b2:	d2f2      	bcs.n	800419a <ch_sch_prio_insert.lto_priv.0+0xa>
  tp->next       = cp;
 80041b4:	9b00      	ldr	r3, [sp, #0]
 80041b6:	9a03      	ldr	r2, [sp, #12]
 80041b8:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
 80041ba:	9b03      	ldr	r3, [sp, #12]
 80041bc:	685a      	ldr	r2, [r3, #4]
 80041be:	9b00      	ldr	r3, [sp, #0]
 80041c0:	605a      	str	r2, [r3, #4]
  tp->prev->next = tp;
 80041c2:	9b00      	ldr	r3, [sp, #0]
 80041c4:	685b      	ldr	r3, [r3, #4]
 80041c6:	9a00      	ldr	r2, [sp, #0]
 80041c8:	601a      	str	r2, [r3, #0]
  cp->prev       = tp;
 80041ca:	9b03      	ldr	r3, [sp, #12]
 80041cc:	9a00      	ldr	r2, [sp, #0]
 80041ce:	605a      	str	r2, [r3, #4]
}
 80041d0:	46c0      	nop			@ (mov r8, r8)
 80041d2:	b004      	add	sp, #16
 80041d4:	4770      	bx	lr
 80041d6:	46c0      	nop			@ (mov r8, r8)
	...

080041e0 <chThdGetSelfX.lto_priv.2>:
  return __sch_get_currthread();
 80041e0:	4b01      	ldr	r3, [pc, #4]	@ (80041e8 <chThdGetSelfX.lto_priv.2+0x8>)
 80041e2:	68db      	ldr	r3, [r3, #12]
}
 80041e4:	0018      	movs	r0, r3
 80041e6:	4770      	bx	lr
 80041e8:	20000690 	.word	0x20000690
 80041ec:	00000000 	.word	0x00000000

080041f0 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 80041f0:	b500      	push	{lr}
 80041f2:	b083      	sub	sp, #12
 80041f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 80041f6:	f7fe f8cb 	bl	8002390 <chDbgCheckClassS>

  return ch_queue_notempty(&mp->queue);
 80041fa:	9b01      	ldr	r3, [sp, #4]
 80041fc:	0018      	movs	r0, r3
 80041fe:	f7ff ff4f 	bl	80040a0 <ch_queue_notempty.lto_priv.2>
 8004202:	0003      	movs	r3, r0
}
 8004204:	0018      	movs	r0, r3
 8004206:	b003      	add	sp, #12
 8004208:	bd00      	pop	{pc}
 800420a:	46c0      	nop			@ (mov r8, r8)
 800420c:	0000      	movs	r0, r0
	...

08004210 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8004210:	b500      	push	{lr}
 8004212:	b083      	sub	sp, #12
 8004214:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8004216:	9b01      	ldr	r3, [sp, #4]
 8004218:	425a      	negs	r2, r3
 800421a:	4153      	adcs	r3, r2
 800421c:	b2db      	uxtb	r3, r3
 800421e:	2b00      	cmp	r3, #0
 8004220:	d003      	beq.n	800422a <chMtxObjectInit+0x1a>
 8004222:	4b07      	ldr	r3, [pc, #28]	@ (8004240 <chMtxObjectInit+0x30>)
 8004224:	0018      	movs	r0, r3
 8004226:	f7fd ff23 	bl	8002070 <chSysHalt>

  ch_queue_init(&mp->queue);
 800422a:	9b01      	ldr	r3, [sp, #4]
 800422c:	0018      	movs	r0, r3
 800422e:	f7ff ff27 	bl	8004080 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 8004232:	9b01      	ldr	r3, [sp, #4]
 8004234:	2200      	movs	r2, #0
 8004236:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8004238:	46c0      	nop			@ (mov r8, r8)
 800423a:	b003      	add	sp, #12
 800423c:	bd00      	pop	{pc}
 800423e:	46c0      	nop			@ (mov r8, r8)
 8004240:	080052b4 	.word	0x080052b4
	...

08004250 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8004250:	b500      	push	{lr}
 8004252:	b083      	sub	sp, #12
 8004254:	9001      	str	r0, [sp, #4]

  chSysLock();
 8004256:	f7ff ff6b 	bl	8004130 <chSysLock.lto_priv.10>
  chMtxLockS(mp);
 800425a:	9b01      	ldr	r3, [sp, #4]
 800425c:	0018      	movs	r0, r3
 800425e:	f000 f807 	bl	8004270 <chMtxLockS>
  chSysUnlock();
 8004262:	f7ff ff6d 	bl	8004140 <chSysUnlock.lto_priv.10>
}
 8004266:	46c0      	nop			@ (mov r8, r8)
 8004268:	b003      	add	sp, #12
 800426a:	bd00      	pop	{pc}
 800426c:	0000      	movs	r0, r0
	...

08004270 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8004270:	b510      	push	{r4, lr}
 8004272:	b084      	sub	sp, #16
 8004274:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004276:	f7ff ffb3 	bl	80041e0 <chThdGetSelfX.lto_priv.2>
 800427a:	0003      	movs	r3, r0
 800427c:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 800427e:	f7fe f887 	bl	8002390 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8004282:	9b01      	ldr	r3, [sp, #4]
 8004284:	425a      	negs	r2, r3
 8004286:	4153      	adcs	r3, r2
 8004288:	b2db      	uxtb	r3, r3
 800428a:	2b00      	cmp	r3, #0
 800428c:	d003      	beq.n	8004296 <chMtxLockS+0x26>
 800428e:	4b41      	ldr	r3, [pc, #260]	@ (8004394 <chMtxLockS+0x124>)
 8004290:	0018      	movs	r0, r3
 8004292:	f7fd feed 	bl	8002070 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8004296:	9b01      	ldr	r3, [sp, #4]
 8004298:	689b      	ldr	r3, [r3, #8]
 800429a:	2b00      	cmp	r3, #0
 800429c:	d100      	bne.n	80042a0 <chMtxLockS+0x30>
 800429e:	e06b      	b.n	8004378 <chMtxLockS+0x108>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 80042a0:	9b01      	ldr	r3, [sp, #4]
 80042a2:	689b      	ldr	r3, [r3, #8]
 80042a4:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 80042a6:	e03a      	b.n	800431e <chMtxLockS+0xae>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 80042a8:	9b02      	ldr	r3, [sp, #8]
 80042aa:	689a      	ldr	r2, [r3, #8]
 80042ac:	9b03      	ldr	r3, [sp, #12]
 80042ae:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80042b0:	9b03      	ldr	r3, [sp, #12]
 80042b2:	2224      	movs	r2, #36	@ 0x24
 80042b4:	5c9b      	ldrb	r3, [r3, r2]
 80042b6:	2b07      	cmp	r3, #7
 80042b8:	d015      	beq.n	80042e6 <chMtxLockS+0x76>
 80042ba:	dc2e      	bgt.n	800431a <chMtxLockS+0xaa>
 80042bc:	2b00      	cmp	r3, #0
 80042be:	d01f      	beq.n	8004300 <chMtxLockS+0x90>
 80042c0:	2b06      	cmp	r3, #6
 80042c2:	d12a      	bne.n	800431a <chMtxLockS+0xaa>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 80042c4:	9b03      	ldr	r3, [sp, #12]
 80042c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80042c8:	001c      	movs	r4, r3
 80042ca:	9b03      	ldr	r3, [sp, #12]
 80042cc:	0018      	movs	r0, r3
 80042ce:	f7ff ff0f 	bl	80040f0 <ch_queue_dequeue.lto_priv.2>
 80042d2:	0003      	movs	r3, r0
 80042d4:	0019      	movs	r1, r3
 80042d6:	0020      	movs	r0, r4
 80042d8:	f7ff ff5a 	bl	8004190 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          tp = tp->u.wtmtxp->owner;
 80042dc:	9b03      	ldr	r3, [sp, #12]
 80042de:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80042e0:	689b      	ldr	r3, [r3, #8]
 80042e2:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 80042e4:	e01b      	b.n	800431e <chMtxLockS+0xae>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 80042e6:	9b03      	ldr	r3, [sp, #12]
 80042e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80042ea:	001c      	movs	r4, r3
 80042ec:	9b03      	ldr	r3, [sp, #12]
 80042ee:	0018      	movs	r0, r3
 80042f0:	f7ff fefe 	bl	80040f0 <ch_queue_dequeue.lto_priv.2>
 80042f4:	0003      	movs	r3, r0
 80042f6:	0019      	movs	r1, r3
 80042f8:	0020      	movs	r0, r4
 80042fa:	f7ff ff49 	bl	8004190 <ch_sch_prio_insert.lto_priv.0>
                             ch_queue_dequeue(&tp->hdr.queue));
          break;
 80042fe:	e00d      	b.n	800431c <chMtxLockS+0xac>
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8004300:	9b03      	ldr	r3, [sp, #12]
 8004302:	2224      	movs	r2, #36	@ 0x24
 8004304:	2101      	movs	r1, #1
 8004306:	5499      	strb	r1, [r3, r2]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 8004308:	9b03      	ldr	r3, [sp, #12]
 800430a:	0018      	movs	r0, r3
 800430c:	f7ff fef0 	bl	80040f0 <ch_queue_dequeue.lto_priv.2>
 8004310:	0003      	movs	r3, r0
 8004312:	0018      	movs	r0, r3
 8004314:	f7fe ffb4 	bl	8003280 <chSchReadyI>
          break;
 8004318:	e000      	b.n	800431c <chMtxLockS+0xac>
        default:
          /* Nothing to do for other states.*/
          break;
 800431a:	46c0      	nop			@ (mov r8, r8)
        }
        break;
 800431c:	e005      	b.n	800432a <chMtxLockS+0xba>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 800431e:	9b03      	ldr	r3, [sp, #12]
 8004320:	689a      	ldr	r2, [r3, #8]
 8004322:	9b02      	ldr	r3, [sp, #8]
 8004324:	689b      	ldr	r3, [r3, #8]
 8004326:	429a      	cmp	r2, r3
 8004328:	d3be      	bcc.n	80042a8 <chMtxLockS+0x38>
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
 800432a:	9b01      	ldr	r3, [sp, #4]
 800432c:	9a02      	ldr	r2, [sp, #8]
 800432e:	0011      	movs	r1, r2
 8004330:	0018      	movs	r0, r3
 8004332:	f7ff ff2d 	bl	8004190 <ch_sch_prio_insert.lto_priv.0>
      currtp->u.wtmtxp = mp;
 8004336:	9b02      	ldr	r3, [sp, #8]
 8004338:	9a01      	ldr	r2, [sp, #4]
 800433a:	629a      	str	r2, [r3, #40]	@ 0x28
      chSchGoSleepS(CH_STATE_WTMTX);
 800433c:	2006      	movs	r0, #6
 800433e:	f7fe ffbf 	bl	80032c0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 8004342:	9b01      	ldr	r3, [sp, #4]
 8004344:	689b      	ldr	r3, [r3, #8]
 8004346:	9a02      	ldr	r2, [sp, #8]
 8004348:	1ad3      	subs	r3, r2, r3
 800434a:	1e5a      	subs	r2, r3, #1
 800434c:	4193      	sbcs	r3, r2
 800434e:	b2db      	uxtb	r3, r3
 8004350:	2b00      	cmp	r3, #0
 8004352:	d003      	beq.n	800435c <chMtxLockS+0xec>
 8004354:	4b0f      	ldr	r3, [pc, #60]	@ (8004394 <chMtxLockS+0x124>)
 8004356:	0018      	movs	r0, r3
 8004358:	f7fd fe8a 	bl	8002070 <chSysHalt>
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 800435c:	9b02      	ldr	r3, [sp, #8]
 800435e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8004360:	9a01      	ldr	r2, [sp, #4]
 8004362:	1ad3      	subs	r3, r2, r3
 8004364:	1e5a      	subs	r2, r3, #1
 8004366:	4193      	sbcs	r3, r2
 8004368:	b2db      	uxtb	r3, r3
 800436a:	2b00      	cmp	r3, #0
 800436c:	d00e      	beq.n	800438c <chMtxLockS+0x11c>
 800436e:	4b09      	ldr	r3, [pc, #36]	@ (8004394 <chMtxLockS+0x124>)
 8004370:	0018      	movs	r0, r3
 8004372:	f7fd fe7d 	bl	8002070 <chSysHalt>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 8004376:	e009      	b.n	800438c <chMtxLockS+0x11c>
    mp->owner = currtp;
 8004378:	9b01      	ldr	r3, [sp, #4]
 800437a:	9a02      	ldr	r2, [sp, #8]
 800437c:	609a      	str	r2, [r3, #8]
    mp->next = currtp->mtxlist;
 800437e:	9b02      	ldr	r3, [sp, #8]
 8004380:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8004382:	9b01      	ldr	r3, [sp, #4]
 8004384:	60da      	str	r2, [r3, #12]
    currtp->mtxlist = mp;
 8004386:	9b02      	ldr	r3, [sp, #8]
 8004388:	9a01      	ldr	r2, [sp, #4]
 800438a:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 800438c:	46c0      	nop			@ (mov r8, r8)
 800438e:	b004      	add	sp, #16
 8004390:	bd10      	pop	{r4, pc}
 8004392:	46c0      	nop			@ (mov r8, r8)
 8004394:	080052d0 	.word	0x080052d0
	...

080043a0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80043a0:	b500      	push	{lr}
 80043a2:	b087      	sub	sp, #28
 80043a4:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 80043a6:	f7ff ff1b 	bl	80041e0 <chThdGetSelfX.lto_priv.2>
 80043aa:	0003      	movs	r3, r0
 80043ac:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 80043ae:	9b01      	ldr	r3, [sp, #4]
 80043b0:	425a      	negs	r2, r3
 80043b2:	4153      	adcs	r3, r2
 80043b4:	b2db      	uxtb	r3, r3
 80043b6:	2b00      	cmp	r3, #0
 80043b8:	d003      	beq.n	80043c2 <chMtxUnlock+0x22>
 80043ba:	4b3a      	ldr	r3, [pc, #232]	@ (80044a4 <chMtxUnlock+0x104>)
 80043bc:	0018      	movs	r0, r3
 80043be:	f7fd fe57 	bl	8002070 <chSysHalt>

  chSysLock();
 80043c2:	f7ff feb5 	bl	8004130 <chSysLock.lto_priv.10>

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 80043c6:	9b03      	ldr	r3, [sp, #12]
 80043c8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80043ca:	425a      	negs	r2, r3
 80043cc:	4153      	adcs	r3, r2
 80043ce:	b2db      	uxtb	r3, r3
 80043d0:	2b00      	cmp	r3, #0
 80043d2:	d003      	beq.n	80043dc <chMtxUnlock+0x3c>
 80043d4:	4b33      	ldr	r3, [pc, #204]	@ (80044a4 <chMtxUnlock+0x104>)
 80043d6:	0018      	movs	r0, r3
 80043d8:	f7fd fe4a 	bl	8002070 <chSysHalt>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 80043dc:	9b03      	ldr	r3, [sp, #12]
 80043de:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80043e0:	689b      	ldr	r3, [r3, #8]
 80043e2:	9a03      	ldr	r2, [sp, #12]
 80043e4:	1ad3      	subs	r3, r2, r3
 80043e6:	1e5a      	subs	r2, r3, #1
 80043e8:	4193      	sbcs	r3, r2
 80043ea:	b2db      	uxtb	r3, r3
 80043ec:	2b00      	cmp	r3, #0
 80043ee:	d003      	beq.n	80043f8 <chMtxUnlock+0x58>
 80043f0:	4b2c      	ldr	r3, [pc, #176]	@ (80044a4 <chMtxUnlock+0x104>)
 80043f2:	0018      	movs	r0, r3
 80043f4:	f7fd fe3c 	bl	8002070 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 80043f8:	9b03      	ldr	r3, [sp, #12]
 80043fa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80043fc:	9a01      	ldr	r2, [sp, #4]
 80043fe:	1ad3      	subs	r3, r2, r3
 8004400:	1e5a      	subs	r2, r3, #1
 8004402:	4193      	sbcs	r3, r2
 8004404:	b2db      	uxtb	r3, r3
 8004406:	2b00      	cmp	r3, #0
 8004408:	d003      	beq.n	8004412 <chMtxUnlock+0x72>
 800440a:	4b26      	ldr	r3, [pc, #152]	@ (80044a4 <chMtxUnlock+0x104>)
 800440c:	0018      	movs	r0, r3
 800440e:	f7fd fe2f 	bl	8002070 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 8004412:	9b01      	ldr	r3, [sp, #4]
 8004414:	68da      	ldr	r2, [r3, #12]
 8004416:	9b03      	ldr	r3, [sp, #12]
 8004418:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800441a:	9b01      	ldr	r3, [sp, #4]
 800441c:	0018      	movs	r0, r3
 800441e:	f7ff fee7 	bl	80041f0 <chMtxQueueNotEmptyS>
 8004422:	1e03      	subs	r3, r0, #0
 8004424:	d036      	beq.n	8004494 <chMtxUnlock+0xf4>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 8004426:	9b03      	ldr	r3, [sp, #12]
 8004428:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800442a:	9304      	str	r3, [sp, #16]
      lmp = currtp->mtxlist;
 800442c:	9b03      	ldr	r3, [sp, #12]
 800442e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8004430:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8004432:	e012      	b.n	800445a <chMtxUnlock+0xba>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8004434:	9b05      	ldr	r3, [sp, #20]
 8004436:	0018      	movs	r0, r3
 8004438:	f7ff feda 	bl	80041f0 <chMtxQueueNotEmptyS>
 800443c:	1e03      	subs	r3, r0, #0
 800443e:	d009      	beq.n	8004454 <chMtxUnlock+0xb4>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 8004440:	9b05      	ldr	r3, [sp, #20]
 8004442:	681b      	ldr	r3, [r3, #0]
 8004444:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8004446:	9a04      	ldr	r2, [sp, #16]
 8004448:	429a      	cmp	r2, r3
 800444a:	d203      	bcs.n	8004454 <chMtxUnlock+0xb4>
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
 800444c:	9b05      	ldr	r3, [sp, #20]
 800444e:	681b      	ldr	r3, [r3, #0]
 8004450:	689b      	ldr	r3, [r3, #8]
 8004452:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 8004454:	9b05      	ldr	r3, [sp, #20]
 8004456:	68db      	ldr	r3, [r3, #12]
 8004458:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 800445a:	9b05      	ldr	r3, [sp, #20]
 800445c:	2b00      	cmp	r3, #0
 800445e:	d1e9      	bne.n	8004434 <chMtxUnlock+0x94>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 8004460:	9b03      	ldr	r3, [sp, #12]
 8004462:	9a04      	ldr	r2, [sp, #16]
 8004464:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
 8004466:	9b01      	ldr	r3, [sp, #4]
 8004468:	0018      	movs	r0, r3
 800446a:	f7ff fe29 	bl	80040c0 <ch_queue_fifo_remove.lto_priv.2>
 800446e:	0003      	movs	r3, r0
 8004470:	9302      	str	r3, [sp, #8]
      mp->owner = tp;
 8004472:	9b01      	ldr	r3, [sp, #4]
 8004474:	9a02      	ldr	r2, [sp, #8]
 8004476:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8004478:	9b02      	ldr	r3, [sp, #8]
 800447a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800447c:	9b01      	ldr	r3, [sp, #4]
 800447e:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8004480:	9b02      	ldr	r3, [sp, #8]
 8004482:	9a01      	ldr	r2, [sp, #4]
 8004484:	63da      	str	r2, [r3, #60]	@ 0x3c

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8004486:	9b02      	ldr	r3, [sp, #8]
 8004488:	0018      	movs	r0, r3
 800448a:	f7fe fef9 	bl	8003280 <chSchReadyI>
      chSchRescheduleS();
 800448e:	f7ff f817 	bl	80034c0 <chSchRescheduleS>
 8004492:	e002      	b.n	800449a <chMtxUnlock+0xfa>
    }
    else {
      mp->owner = NULL;
 8004494:	9b01      	ldr	r3, [sp, #4]
 8004496:	2200      	movs	r2, #0
 8004498:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 800449a:	f7ff fe51 	bl	8004140 <chSysUnlock.lto_priv.10>
}
 800449e:	46c0      	nop			@ (mov r8, r8)
 80044a0:	b007      	add	sp, #28
 80044a2:	bd00      	pop	{pc}
 80044a4:	080052dc 	.word	0x080052dc
	...

080044b0 <port_lock.lto_priv.21>:
  __ASM volatile ("cpsid i" : : : "memory");
 80044b0:	b672      	cpsid	i
}
 80044b2:	46c0      	nop			@ (mov r8, r8)
}
 80044b4:	46c0      	nop			@ (mov r8, r8)
 80044b6:	4770      	bx	lr
	...

080044c0 <port_unlock.lto_priv.21>:
  __ASM volatile ("cpsie i" : : : "memory");
 80044c0:	b662      	cpsie	i
}
 80044c2:	46c0      	nop			@ (mov r8, r8)
}
 80044c4:	46c0      	nop			@ (mov r8, r8)
 80044c6:	4770      	bx	lr
	...

080044d0 <chSysLock.lto_priv.16>:
static inline void chSysLock(void) {
 80044d0:	b510      	push	{r4, lr}
  port_lock();
 80044d2:	f7ff ffed 	bl	80044b0 <port_lock.lto_priv.21>
  __dbg_check_lock();
 80044d6:	f7fd fe3b 	bl	8002150 <__dbg_check_lock>
}
 80044da:	46c0      	nop			@ (mov r8, r8)
 80044dc:	bd10      	pop	{r4, pc}
 80044de:	46c0      	nop			@ (mov r8, r8)

080044e0 <chSysUnlock.lto_priv.16>:
static inline void chSysUnlock(void) {
 80044e0:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 80044e2:	f7fd fe5d 	bl	80021a0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80044e6:	4b0e      	ldr	r3, [pc, #56]	@ (8004520 <chSysUnlock.lto_priv.16+0x40>)
 80044e8:	681a      	ldr	r2, [r3, #0]
 80044ea:	4b0d      	ldr	r3, [pc, #52]	@ (8004520 <chSysUnlock.lto_priv.16+0x40>)
 80044ec:	1ad3      	subs	r3, r2, r3
 80044ee:	1e5a      	subs	r2, r3, #1
 80044f0:	4193      	sbcs	r3, r2
 80044f2:	b2db      	uxtb	r3, r3
 80044f4:	2b00      	cmp	r3, #0
 80044f6:	d00f      	beq.n	8004518 <chSysUnlock.lto_priv.16+0x38>
 80044f8:	4b09      	ldr	r3, [pc, #36]	@ (8004520 <chSysUnlock.lto_priv.16+0x40>)
 80044fa:	68db      	ldr	r3, [r3, #12]
 80044fc:	689a      	ldr	r2, [r3, #8]
 80044fe:	4b08      	ldr	r3, [pc, #32]	@ (8004520 <chSysUnlock.lto_priv.16+0x40>)
 8004500:	681b      	ldr	r3, [r3, #0]
 8004502:	689b      	ldr	r3, [r3, #8]
 8004504:	429a      	cmp	r2, r3
 8004506:	419b      	sbcs	r3, r3
 8004508:	425b      	negs	r3, r3
 800450a:	b2db      	uxtb	r3, r3
 800450c:	2b00      	cmp	r3, #0
 800450e:	d003      	beq.n	8004518 <chSysUnlock.lto_priv.16+0x38>
 8004510:	4b04      	ldr	r3, [pc, #16]	@ (8004524 <chSysUnlock.lto_priv.16+0x44>)
 8004512:	0018      	movs	r0, r3
 8004514:	f7fd fdac 	bl	8002070 <chSysHalt>
  port_unlock();
 8004518:	f7ff ffd2 	bl	80044c0 <port_unlock.lto_priv.21>
}
 800451c:	46c0      	nop			@ (mov r8, r8)
 800451e:	bd10      	pop	{r4, pc}
 8004520:	20000690 	.word	0x20000690
 8004524:	080052fc 	.word	0x080052fc
	...

08004530 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8004530:	4b03      	ldr	r3, [pc, #12]	@ (8004540 <__core_init+0x10>)
 8004532:	4a04      	ldr	r2, [pc, #16]	@ (8004544 <__core_init+0x14>)
 8004534:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 8004536:	4b02      	ldr	r3, [pc, #8]	@ (8004540 <__core_init+0x10>)
 8004538:	4a03      	ldr	r2, [pc, #12]	@ (8004548 <__core_init+0x18>)
 800453a:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 800453c:	46c0      	nop			@ (mov r8, r8)
 800453e:	4770      	bx	lr
 8004540:	20001008 	.word	0x20001008
 8004544:	200013d8 	.word	0x200013d8
 8004548:	20002000 	.word	0x20002000
 800454c:	00000000 	.word	0x00000000

08004550 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8004550:	b500      	push	{lr}
 8004552:	b087      	sub	sp, #28
 8004554:	9003      	str	r0, [sp, #12]
 8004556:	9102      	str	r1, [sp, #8]
 8004558:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 800455a:	f7fd fef9 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800455e:	9b02      	ldr	r3, [sp, #8]
 8004560:	425a      	negs	r2, r3
 8004562:	4153      	adcs	r3, r2
 8004564:	b2db      	uxtb	r3, r3
 8004566:	2b00      	cmp	r3, #0
 8004568:	d108      	bne.n	800457c <chCoreAllocFromTopI+0x2c>
 800456a:	9b02      	ldr	r3, [sp, #8]
 800456c:	3b01      	subs	r3, #1
 800456e:	9a02      	ldr	r2, [sp, #8]
 8004570:	4013      	ands	r3, r2
 8004572:	1e5a      	subs	r2, r3, #1
 8004574:	4193      	sbcs	r3, r2
 8004576:	b2db      	uxtb	r3, r3
 8004578:	2b00      	cmp	r3, #0
 800457a:	d003      	beq.n	8004584 <chCoreAllocFromTopI+0x34>
 800457c:	4b12      	ldr	r3, [pc, #72]	@ (80045c8 <chCoreAllocFromTopI+0x78>)
 800457e:	0018      	movs	r0, r3
 8004580:	f7fd fd76 	bl	8002070 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8004584:	4b11      	ldr	r3, [pc, #68]	@ (80045cc <chCoreAllocFromTopI+0x7c>)
 8004586:	685a      	ldr	r2, [r3, #4]
 8004588:	9b03      	ldr	r3, [sp, #12]
 800458a:	425b      	negs	r3, r3
 800458c:	18d3      	adds	r3, r2, r3
 800458e:	001a      	movs	r2, r3
 8004590:	9b02      	ldr	r3, [sp, #8]
 8004592:	425b      	negs	r3, r3
 8004594:	4013      	ands	r3, r2
 8004596:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 8004598:	9b01      	ldr	r3, [sp, #4]
 800459a:	425b      	negs	r3, r3
 800459c:	9a05      	ldr	r2, [sp, #20]
 800459e:	18d3      	adds	r3, r2, r3
 80045a0:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80045a2:	4b0a      	ldr	r3, [pc, #40]	@ (80045cc <chCoreAllocFromTopI+0x7c>)
 80045a4:	681b      	ldr	r3, [r3, #0]
 80045a6:	9a04      	ldr	r2, [sp, #16]
 80045a8:	429a      	cmp	r2, r3
 80045aa:	d304      	bcc.n	80045b6 <chCoreAllocFromTopI+0x66>
 80045ac:	4b07      	ldr	r3, [pc, #28]	@ (80045cc <chCoreAllocFromTopI+0x7c>)
 80045ae:	685b      	ldr	r3, [r3, #4]
 80045b0:	9a04      	ldr	r2, [sp, #16]
 80045b2:	429a      	cmp	r2, r3
 80045b4:	d901      	bls.n	80045ba <chCoreAllocFromTopI+0x6a>
    return NULL;
 80045b6:	2300      	movs	r3, #0
 80045b8:	e003      	b.n	80045c2 <chCoreAllocFromTopI+0x72>
  }

  ch_memcore.topmem = prev;
 80045ba:	4b04      	ldr	r3, [pc, #16]	@ (80045cc <chCoreAllocFromTopI+0x7c>)
 80045bc:	9a04      	ldr	r2, [sp, #16]
 80045be:	605a      	str	r2, [r3, #4]

  return p;
 80045c0:	9b05      	ldr	r3, [sp, #20]
}
 80045c2:	0018      	movs	r0, r3
 80045c4:	b007      	add	sp, #28
 80045c6:	bd00      	pop	{pc}
 80045c8:	080052e8 	.word	0x080052e8
 80045cc:	20001008 	.word	0x20001008

080045d0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 80045d0:	b500      	push	{lr}
 80045d2:	b087      	sub	sp, #28
 80045d4:	9003      	str	r0, [sp, #12]
 80045d6:	9102      	str	r1, [sp, #8]
 80045d8:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 80045da:	f7ff ff79 	bl	80044d0 <chSysLock.lto_priv.16>
  p = chCoreAllocFromTopI(size, align, offset);
 80045de:	9a01      	ldr	r2, [sp, #4]
 80045e0:	9902      	ldr	r1, [sp, #8]
 80045e2:	9b03      	ldr	r3, [sp, #12]
 80045e4:	0018      	movs	r0, r3
 80045e6:	f7ff ffb3 	bl	8004550 <chCoreAllocFromTopI>
 80045ea:	0003      	movs	r3, r0
 80045ec:	9305      	str	r3, [sp, #20]
  chSysUnlock();
 80045ee:	f7ff ff77 	bl	80044e0 <chSysUnlock.lto_priv.16>

  return p;
 80045f2:	9b05      	ldr	r3, [sp, #20]
}
 80045f4:	0018      	movs	r0, r3
 80045f6:	b007      	add	sp, #28
 80045f8:	bd00      	pop	{pc}
 80045fa:	46c0      	nop			@ (mov r8, r8)
 80045fc:	0000      	movs	r0, r0
	...

08004600 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 8004600:	b510      	push	{r4, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8004602:	4b07      	ldr	r3, [pc, #28]	@ (8004620 <__heap_init+0x20>)
 8004604:	4a07      	ldr	r2, [pc, #28]	@ (8004624 <__heap_init+0x24>)
 8004606:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8004608:	4b05      	ldr	r3, [pc, #20]	@ (8004620 <__heap_init+0x20>)
 800460a:	2200      	movs	r2, #0
 800460c:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 800460e:	4b04      	ldr	r3, [pc, #16]	@ (8004620 <__heap_init+0x20>)
 8004610:	2200      	movs	r2, #0
 8004612:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8004614:	4b04      	ldr	r3, [pc, #16]	@ (8004628 <__heap_init+0x28>)
 8004616:	0018      	movs	r0, r3
 8004618:	f7ff fdfa 	bl	8004210 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 800461c:	46c0      	nop			@ (mov r8, r8)
 800461e:	bd10      	pop	{r4, pc}
 8004620:	20001010 	.word	0x20001010
 8004624:	080045d1 	.word	0x080045d1
 8004628:	2000101c 	.word	0x2000101c
 800462c:	00000000 	.word	0x00000000

08004630 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8004630:	b500      	push	{lr}
 8004632:	b087      	sub	sp, #28
 8004634:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8004636:	9b01      	ldr	r3, [sp, #4]
 8004638:	425a      	negs	r2, r3
 800463a:	4153      	adcs	r3, r2
 800463c:	b2db      	uxtb	r3, r3
 800463e:	2b00      	cmp	r3, #0
 8004640:	d107      	bne.n	8004652 <chHeapFree+0x22>
 8004642:	9b01      	ldr	r3, [sp, #4]
 8004644:	2207      	movs	r2, #7
 8004646:	4013      	ands	r3, r2
 8004648:	1e5a      	subs	r2, r3, #1
 800464a:	4193      	sbcs	r3, r2
 800464c:	b2db      	uxtb	r3, r3
 800464e:	2b00      	cmp	r3, #0
 8004650:	d003      	beq.n	800465a <chHeapFree+0x2a>
 8004652:	4b42      	ldr	r3, [pc, #264]	@ (800475c <chHeapFree+0x12c>)
 8004654:	0018      	movs	r0, r3
 8004656:	f7fd fd0b 	bl	8002070 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 800465a:	9b01      	ldr	r3, [sp, #4]
 800465c:	3b08      	subs	r3, #8
 800465e:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8004660:	9b04      	ldr	r3, [sp, #16]
 8004662:	681b      	ldr	r3, [r3, #0]
 8004664:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 8004666:	9b03      	ldr	r3, [sp, #12]
 8004668:	3304      	adds	r3, #4
 800466a:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800466c:	9b04      	ldr	r3, [sp, #16]
 800466e:	685b      	ldr	r3, [r3, #4]
 8004670:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8004672:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8004674:	9b04      	ldr	r3, [sp, #16]
 8004676:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8004678:	9b03      	ldr	r3, [sp, #12]
 800467a:	330c      	adds	r3, #12
 800467c:	0018      	movs	r0, r3
 800467e:	f7ff fde7 	bl	8004250 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8004682:	9904      	ldr	r1, [sp, #16]
 8004684:	9a05      	ldr	r2, [sp, #20]
 8004686:	2300      	movs	r3, #0
 8004688:	4291      	cmp	r1, r2
 800468a:	415b      	adcs	r3, r3
 800468c:	b2db      	uxtb	r3, r3
 800468e:	2b00      	cmp	r3, #0
 8004690:	d010      	beq.n	80046b4 <chHeapFree+0x84>
 8004692:	9b05      	ldr	r3, [sp, #20]
 8004694:	685b      	ldr	r3, [r3, #4]
 8004696:	3301      	adds	r3, #1
 8004698:	00db      	lsls	r3, r3, #3
 800469a:	9a05      	ldr	r2, [sp, #20]
 800469c:	18d3      	adds	r3, r2, r3
 800469e:	9a04      	ldr	r2, [sp, #16]
 80046a0:	429a      	cmp	r2, r3
 80046a2:	419b      	sbcs	r3, r3
 80046a4:	425b      	negs	r3, r3
 80046a6:	b2db      	uxtb	r3, r3
 80046a8:	2b00      	cmp	r3, #0
 80046aa:	d003      	beq.n	80046b4 <chHeapFree+0x84>
 80046ac:	4b2b      	ldr	r3, [pc, #172]	@ (800475c <chHeapFree+0x12c>)
 80046ae:	0018      	movs	r0, r3
 80046b0:	f7fd fcde 	bl	8002070 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 80046b4:	9b03      	ldr	r3, [sp, #12]
 80046b6:	3304      	adds	r3, #4
 80046b8:	9a05      	ldr	r2, [sp, #20]
 80046ba:	429a      	cmp	r2, r3
 80046bc:	d003      	beq.n	80046c6 <chHeapFree+0x96>
 80046be:	9a04      	ldr	r2, [sp, #16]
 80046c0:	9b05      	ldr	r3, [sp, #20]
 80046c2:	429a      	cmp	r2, r3
 80046c4:	d93d      	bls.n	8004742 <chHeapFree+0x112>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80046c6:	9b05      	ldr	r3, [sp, #20]
 80046c8:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 80046ca:	2b00      	cmp	r3, #0
 80046cc:	d004      	beq.n	80046d8 <chHeapFree+0xa8>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80046ce:	9b05      	ldr	r3, [sp, #20]
 80046d0:	681b      	ldr	r3, [r3, #0]
 80046d2:	9a04      	ldr	r2, [sp, #16]
 80046d4:	429a      	cmp	r2, r3
 80046d6:	d234      	bcs.n	8004742 <chHeapFree+0x112>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80046d8:	9b05      	ldr	r3, [sp, #20]
 80046da:	681a      	ldr	r2, [r3, #0]
 80046dc:	9b04      	ldr	r3, [sp, #16]
 80046de:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 80046e0:	9b05      	ldr	r3, [sp, #20]
 80046e2:	9a04      	ldr	r2, [sp, #16]
 80046e4:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80046e6:	9b04      	ldr	r3, [sp, #16]
 80046e8:	685b      	ldr	r3, [r3, #4]
 80046ea:	3301      	adds	r3, #1
 80046ec:	00db      	lsls	r3, r3, #3
 80046ee:	9a04      	ldr	r2, [sp, #16]
 80046f0:	18d2      	adds	r2, r2, r3
 80046f2:	9b04      	ldr	r3, [sp, #16]
 80046f4:	681b      	ldr	r3, [r3, #0]
 80046f6:	429a      	cmp	r2, r3
 80046f8:	d10d      	bne.n	8004716 <chHeapFree+0xe6>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80046fa:	9b04      	ldr	r3, [sp, #16]
 80046fc:	685a      	ldr	r2, [r3, #4]
 80046fe:	9b04      	ldr	r3, [sp, #16]
 8004700:	681b      	ldr	r3, [r3, #0]
 8004702:	685b      	ldr	r3, [r3, #4]
 8004704:	18d3      	adds	r3, r2, r3
 8004706:	1c5a      	adds	r2, r3, #1
 8004708:	9b04      	ldr	r3, [sp, #16]
 800470a:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800470c:	9b04      	ldr	r3, [sp, #16]
 800470e:	681b      	ldr	r3, [r3, #0]
 8004710:	681a      	ldr	r2, [r3, #0]
 8004712:	9b04      	ldr	r3, [sp, #16]
 8004714:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8004716:	9b05      	ldr	r3, [sp, #20]
 8004718:	685b      	ldr	r3, [r3, #4]
 800471a:	3301      	adds	r3, #1
 800471c:	00db      	lsls	r3, r3, #3
 800471e:	9a05      	ldr	r2, [sp, #20]
 8004720:	18d3      	adds	r3, r2, r3
 8004722:	9a04      	ldr	r2, [sp, #16]
 8004724:	429a      	cmp	r2, r3
 8004726:	d110      	bne.n	800474a <chHeapFree+0x11a>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8004728:	9b05      	ldr	r3, [sp, #20]
 800472a:	685a      	ldr	r2, [r3, #4]
 800472c:	9b04      	ldr	r3, [sp, #16]
 800472e:	685b      	ldr	r3, [r3, #4]
 8004730:	18d3      	adds	r3, r2, r3
 8004732:	1c5a      	adds	r2, r3, #1
 8004734:	9b05      	ldr	r3, [sp, #20]
 8004736:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8004738:	9b04      	ldr	r3, [sp, #16]
 800473a:	681a      	ldr	r2, [r3, #0]
 800473c:	9b05      	ldr	r3, [sp, #20]
 800473e:	601a      	str	r2, [r3, #0]
      }
      break;
 8004740:	e003      	b.n	800474a <chHeapFree+0x11a>
    }
    qp = H_NEXT(qp);
 8004742:	9b05      	ldr	r3, [sp, #20]
 8004744:	681b      	ldr	r3, [r3, #0]
 8004746:	9305      	str	r3, [sp, #20]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8004748:	e79b      	b.n	8004682 <chHeapFree+0x52>
      break;
 800474a:	46c0      	nop			@ (mov r8, r8)
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800474c:	9b03      	ldr	r3, [sp, #12]
 800474e:	330c      	adds	r3, #12
 8004750:	0018      	movs	r0, r3
 8004752:	f7ff fe25 	bl	80043a0 <chMtxUnlock>

  return;
 8004756:	46c0      	nop			@ (mov r8, r8)
}
 8004758:	b007      	add	sp, #28
 800475a:	bd00      	pop	{pc}
 800475c:	08005308 	.word	0x08005308

08004760 <port_lock.lto_priv.22>:
  __ASM volatile ("cpsid i" : : : "memory");
 8004760:	b672      	cpsid	i
}
 8004762:	46c0      	nop			@ (mov r8, r8)
}
 8004764:	46c0      	nop			@ (mov r8, r8)
 8004766:	4770      	bx	lr
	...

08004770 <port_unlock.lto_priv.22>:
  __ASM volatile ("cpsie i" : : : "memory");
 8004770:	b662      	cpsie	i
}
 8004772:	46c0      	nop			@ (mov r8, r8)
}
 8004774:	46c0      	nop			@ (mov r8, r8)
 8004776:	4770      	bx	lr
	...

08004780 <chSysLock.lto_priv.17>:
static inline void chSysLock(void) {
 8004780:	b510      	push	{r4, lr}
  port_lock();
 8004782:	f7ff ffed 	bl	8004760 <port_lock.lto_priv.22>
  __dbg_check_lock();
 8004786:	f7fd fce3 	bl	8002150 <__dbg_check_lock>
}
 800478a:	46c0      	nop			@ (mov r8, r8)
 800478c:	bd10      	pop	{r4, pc}
 800478e:	46c0      	nop			@ (mov r8, r8)

08004790 <chSysUnlock.lto_priv.17>:
static inline void chSysUnlock(void) {
 8004790:	b510      	push	{r4, lr}
  __dbg_check_unlock();
 8004792:	f7fd fd05 	bl	80021a0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8004796:	4b0e      	ldr	r3, [pc, #56]	@ (80047d0 <chSysUnlock.lto_priv.17+0x40>)
 8004798:	681a      	ldr	r2, [r3, #0]
 800479a:	4b0d      	ldr	r3, [pc, #52]	@ (80047d0 <chSysUnlock.lto_priv.17+0x40>)
 800479c:	1ad3      	subs	r3, r2, r3
 800479e:	1e5a      	subs	r2, r3, #1
 80047a0:	4193      	sbcs	r3, r2
 80047a2:	b2db      	uxtb	r3, r3
 80047a4:	2b00      	cmp	r3, #0
 80047a6:	d00f      	beq.n	80047c8 <chSysUnlock.lto_priv.17+0x38>
 80047a8:	4b09      	ldr	r3, [pc, #36]	@ (80047d0 <chSysUnlock.lto_priv.17+0x40>)
 80047aa:	68db      	ldr	r3, [r3, #12]
 80047ac:	689a      	ldr	r2, [r3, #8]
 80047ae:	4b08      	ldr	r3, [pc, #32]	@ (80047d0 <chSysUnlock.lto_priv.17+0x40>)
 80047b0:	681b      	ldr	r3, [r3, #0]
 80047b2:	689b      	ldr	r3, [r3, #8]
 80047b4:	429a      	cmp	r2, r3
 80047b6:	419b      	sbcs	r3, r3
 80047b8:	425b      	negs	r3, r3
 80047ba:	b2db      	uxtb	r3, r3
 80047bc:	2b00      	cmp	r3, #0
 80047be:	d003      	beq.n	80047c8 <chSysUnlock.lto_priv.17+0x38>
 80047c0:	4b04      	ldr	r3, [pc, #16]	@ (80047d4 <chSysUnlock.lto_priv.17+0x44>)
 80047c2:	0018      	movs	r0, r3
 80047c4:	f7fd fc54 	bl	8002070 <chSysHalt>
  port_unlock();
 80047c8:	f7ff ffd2 	bl	8004770 <port_unlock.lto_priv.22>
}
 80047cc:	46c0      	nop			@ (mov r8, r8)
 80047ce:	bd10      	pop	{r4, pc}
 80047d0:	20000690 	.word	0x20000690
 80047d4:	0800532c 	.word	0x0800532c
	...

080047e0 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 80047e0:	b500      	push	{lr}
 80047e2:	b085      	sub	sp, #20
 80047e4:	9003      	str	r0, [sp, #12]
 80047e6:	9102      	str	r1, [sp, #8]
 80047e8:	9201      	str	r2, [sp, #4]
 80047ea:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 80047ec:	9b03      	ldr	r3, [sp, #12]
 80047ee:	425a      	negs	r2, r3
 80047f0:	4153      	adcs	r3, r2
 80047f2:	b2db      	uxtb	r3, r3
 80047f4:	2b00      	cmp	r3, #0
 80047f6:	d107      	bne.n	8004808 <chPoolObjectInitAligned+0x28>
 80047f8:	9a02      	ldr	r2, [sp, #8]
 80047fa:	2103      	movs	r1, #3
 80047fc:	2300      	movs	r3, #0
 80047fe:	4291      	cmp	r1, r2
 8004800:	415b      	adcs	r3, r3
 8004802:	b2db      	uxtb	r3, r3
 8004804:	2b00      	cmp	r3, #0
 8004806:	d001      	beq.n	800480c <chPoolObjectInitAligned+0x2c>
 8004808:	2301      	movs	r3, #1
 800480a:	e000      	b.n	800480e <chPoolObjectInitAligned+0x2e>
 800480c:	2300      	movs	r3, #0
 800480e:	2b00      	cmp	r3, #0
 8004810:	d107      	bne.n	8004822 <chPoolObjectInitAligned+0x42>
 8004812:	9a01      	ldr	r2, [sp, #4]
 8004814:	2103      	movs	r1, #3
 8004816:	2300      	movs	r3, #0
 8004818:	4291      	cmp	r1, r2
 800481a:	415b      	adcs	r3, r3
 800481c:	b2db      	uxtb	r3, r3
 800481e:	2b00      	cmp	r3, #0
 8004820:	d001      	beq.n	8004826 <chPoolObjectInitAligned+0x46>
 8004822:	2301      	movs	r3, #1
 8004824:	e000      	b.n	8004828 <chPoolObjectInitAligned+0x48>
 8004826:	2300      	movs	r3, #0
 8004828:	2b00      	cmp	r3, #0
 800482a:	d113      	bne.n	8004854 <chPoolObjectInitAligned+0x74>
 800482c:	9b01      	ldr	r3, [sp, #4]
 800482e:	425a      	negs	r2, r3
 8004830:	4153      	adcs	r3, r2
 8004832:	b2db      	uxtb	r3, r3
 8004834:	2b00      	cmp	r3, #0
 8004836:	d108      	bne.n	800484a <chPoolObjectInitAligned+0x6a>
 8004838:	9b01      	ldr	r3, [sp, #4]
 800483a:	3b01      	subs	r3, #1
 800483c:	9a01      	ldr	r2, [sp, #4]
 800483e:	4013      	ands	r3, r2
 8004840:	1e5a      	subs	r2, r3, #1
 8004842:	4193      	sbcs	r3, r2
 8004844:	b2db      	uxtb	r3, r3
 8004846:	2b00      	cmp	r3, #0
 8004848:	d001      	beq.n	800484e <chPoolObjectInitAligned+0x6e>
 800484a:	2301      	movs	r3, #1
 800484c:	e000      	b.n	8004850 <chPoolObjectInitAligned+0x70>
 800484e:	2300      	movs	r3, #0
 8004850:	2b00      	cmp	r3, #0
 8004852:	d003      	beq.n	800485c <chPoolObjectInitAligned+0x7c>
 8004854:	4b09      	ldr	r3, [pc, #36]	@ (800487c <chPoolObjectInitAligned+0x9c>)
 8004856:	0018      	movs	r0, r3
 8004858:	f7fd fc0a 	bl	8002070 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 800485c:	9b03      	ldr	r3, [sp, #12]
 800485e:	2200      	movs	r2, #0
 8004860:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8004862:	9b03      	ldr	r3, [sp, #12]
 8004864:	9a02      	ldr	r2, [sp, #8]
 8004866:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8004868:	9b03      	ldr	r3, [sp, #12]
 800486a:	9a01      	ldr	r2, [sp, #4]
 800486c:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 800486e:	9b03      	ldr	r3, [sp, #12]
 8004870:	9a00      	ldr	r2, [sp, #0]
 8004872:	60da      	str	r2, [r3, #12]
}
 8004874:	46c0      	nop			@ (mov r8, r8)
 8004876:	b005      	add	sp, #20
 8004878:	bd00      	pop	{pc}
 800487a:	46c0      	nop			@ (mov r8, r8)
 800487c:	08005314 	.word	0x08005314

08004880 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8004880:	b500      	push	{lr}
 8004882:	b085      	sub	sp, #20
 8004884:	9001      	str	r0, [sp, #4]
 8004886:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8004888:	9b00      	ldr	r3, [sp, #0]
 800488a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 800488c:	f7fd fd60 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8004890:	9b01      	ldr	r3, [sp, #4]
 8004892:	425a      	negs	r2, r3
 8004894:	4153      	adcs	r3, r2
 8004896:	b2db      	uxtb	r3, r3
 8004898:	2b00      	cmp	r3, #0
 800489a:	d105      	bne.n	80048a8 <chPoolFreeI+0x28>
 800489c:	9b00      	ldr	r3, [sp, #0]
 800489e:	425a      	negs	r2, r3
 80048a0:	4153      	adcs	r3, r2
 80048a2:	b2db      	uxtb	r3, r3
 80048a4:	2b00      	cmp	r3, #0
 80048a6:	d001      	beq.n	80048ac <chPoolFreeI+0x2c>
 80048a8:	2301      	movs	r3, #1
 80048aa:	e000      	b.n	80048ae <chPoolFreeI+0x2e>
 80048ac:	2300      	movs	r3, #0
 80048ae:	2b00      	cmp	r3, #0
 80048b0:	d109      	bne.n	80048c6 <chPoolFreeI+0x46>
 80048b2:	9b01      	ldr	r3, [sp, #4]
 80048b4:	689b      	ldr	r3, [r3, #8]
 80048b6:	3b01      	subs	r3, #1
 80048b8:	9a00      	ldr	r2, [sp, #0]
 80048ba:	4013      	ands	r3, r2
 80048bc:	1e5a      	subs	r2, r3, #1
 80048be:	4193      	sbcs	r3, r2
 80048c0:	b2db      	uxtb	r3, r3
 80048c2:	2b00      	cmp	r3, #0
 80048c4:	d003      	beq.n	80048ce <chPoolFreeI+0x4e>
 80048c6:	4b07      	ldr	r3, [pc, #28]	@ (80048e4 <chPoolFreeI+0x64>)
 80048c8:	0018      	movs	r0, r3
 80048ca:	f7fd fbd1 	bl	8002070 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80048ce:	9b01      	ldr	r3, [sp, #4]
 80048d0:	681a      	ldr	r2, [r3, #0]
 80048d2:	9b03      	ldr	r3, [sp, #12]
 80048d4:	601a      	str	r2, [r3, #0]
  mp->next = php;
 80048d6:	9b01      	ldr	r3, [sp, #4]
 80048d8:	9a03      	ldr	r2, [sp, #12]
 80048da:	601a      	str	r2, [r3, #0]
}
 80048dc:	46c0      	nop			@ (mov r8, r8)
 80048de:	b005      	add	sp, #20
 80048e0:	bd00      	pop	{pc}
 80048e2:	46c0      	nop			@ (mov r8, r8)
 80048e4:	08005338 	.word	0x08005338
	...

080048f0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 80048f0:	b500      	push	{lr}
 80048f2:	b083      	sub	sp, #12
 80048f4:	9001      	str	r0, [sp, #4]
 80048f6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80048f8:	f7ff ff42 	bl	8004780 <chSysLock.lto_priv.17>
  chPoolFreeI(mp, objp);
 80048fc:	9a00      	ldr	r2, [sp, #0]
 80048fe:	9b01      	ldr	r3, [sp, #4]
 8004900:	0011      	movs	r1, r2
 8004902:	0018      	movs	r0, r3
 8004904:	f7ff ffbc 	bl	8004880 <chPoolFreeI>
  chSysUnlock();
 8004908:	f7ff ff42 	bl	8004790 <chSysUnlock.lto_priv.17>
}
 800490c:	46c0      	nop			@ (mov r8, r8)
 800490e:	b003      	add	sp, #12
 8004910:	bd00      	pop	{pc}
 8004912:	46c0      	nop			@ (mov r8, r8)
	...

08004920 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8004920:	b500      	push	{lr}
 8004922:	b083      	sub	sp, #12
 8004924:	9001      	str	r0, [sp, #4]
 8004926:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8004928:	9900      	ldr	r1, [sp, #0]
 800492a:	9b01      	ldr	r3, [sp, #4]
 800492c:	2200      	movs	r2, #0
 800492e:	0018      	movs	r0, r3
 8004930:	f7ff fe0e 	bl	8004550 <chCoreAllocFromTopI>
 8004934:	0003      	movs	r3, r0
}
 8004936:	0018      	movs	r0, r3
 8004938:	b003      	add	sp, #12
 800493a:	bd00      	pop	{pc}
 800493c:	0000      	movs	r0, r0
	...

08004940 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8004940:	b500      	push	{lr}
 8004942:	b085      	sub	sp, #20
 8004944:	9003      	str	r0, [sp, #12]
 8004946:	9102      	str	r1, [sp, #8]
 8004948:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 800494a:	9b01      	ldr	r3, [sp, #4]
 800494c:	9902      	ldr	r1, [sp, #8]
 800494e:	9803      	ldr	r0, [sp, #12]
 8004950:	2204      	movs	r2, #4
 8004952:	f7ff ff45 	bl	80047e0 <chPoolObjectInitAligned>
}
 8004956:	46c0      	nop			@ (mov r8, r8)
 8004958:	b005      	add	sp, #20
 800495a:	bd00      	pop	{pc}
 800495c:	0000      	movs	r0, r0
	...

08004960 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8004960:	b082      	sub	sp, #8
 8004962:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8004964:	9b01      	ldr	r3, [sp, #4]
 8004966:	9a01      	ldr	r2, [sp, #4]
 8004968:	601a      	str	r2, [r3, #0]
}
 800496a:	46c0      	nop			@ (mov r8, r8)
 800496c:	b002      	add	sp, #8
 800496e:	4770      	bx	lr

08004970 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8004970:	b510      	push	{r4, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8004972:	4b15      	ldr	r3, [pc, #84]	@ (80049c8 <__factory_init+0x58>)
 8004974:	0018      	movs	r0, r3
 8004976:	f7ff fc4b 	bl	8004210 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 800497a:	4b14      	ldr	r3, [pc, #80]	@ (80049cc <__factory_init+0x5c>)
 800497c:	0018      	movs	r0, r3
 800497e:	f7ff ffef 	bl	8004960 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8004982:	4a13      	ldr	r2, [pc, #76]	@ (80049d0 <__factory_init+0x60>)
 8004984:	4b13      	ldr	r3, [pc, #76]	@ (80049d4 <__factory_init+0x64>)
 8004986:	2114      	movs	r1, #20
 8004988:	0018      	movs	r0, r3
 800498a:	f7ff ffd9 	bl	8004940 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 800498e:	4b12      	ldr	r3, [pc, #72]	@ (80049d8 <__factory_init+0x68>)
 8004990:	0018      	movs	r0, r3
 8004992:	f7ff ffe5 	bl	8004960 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8004996:	4b11      	ldr	r3, [pc, #68]	@ (80049dc <__factory_init+0x6c>)
 8004998:	0018      	movs	r0, r3
 800499a:	f7ff ffe1 	bl	8004960 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 800499e:	4a0c      	ldr	r2, [pc, #48]	@ (80049d0 <__factory_init+0x60>)
 80049a0:	4b0f      	ldr	r3, [pc, #60]	@ (80049e0 <__factory_init+0x70>)
 80049a2:	211c      	movs	r1, #28
 80049a4:	0018      	movs	r0, r3
 80049a6:	f7ff ffcb 	bl	8004940 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 80049aa:	4b0e      	ldr	r3, [pc, #56]	@ (80049e4 <__factory_init+0x74>)
 80049ac:	0018      	movs	r0, r3
 80049ae:	f7ff ffd7 	bl	8004960 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 80049b2:	4b0d      	ldr	r3, [pc, #52]	@ (80049e8 <__factory_init+0x78>)
 80049b4:	0018      	movs	r0, r3
 80049b6:	f7ff ffd3 	bl	8004960 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 80049ba:	4b0c      	ldr	r3, [pc, #48]	@ (80049ec <__factory_init+0x7c>)
 80049bc:	0018      	movs	r0, r3
 80049be:	f7ff ffcf 	bl	8004960 <dyn_list_init>
#endif
}
 80049c2:	46c0      	nop			@ (mov r8, r8)
 80049c4:	bd10      	pop	{r4, pc}
 80049c6:	46c0      	nop			@ (mov r8, r8)
 80049c8:	2000102c 	.word	0x2000102c
 80049cc:	2000103c 	.word	0x2000103c
 80049d0:	08004921 	.word	0x08004921
 80049d4:	20001040 	.word	0x20001040
 80049d8:	20001050 	.word	0x20001050
 80049dc:	20001054 	.word	0x20001054
 80049e0:	20001058 	.word	0x20001058
 80049e4:	20001068 	.word	0x20001068
 80049e8:	2000106c 	.word	0x2000106c
 80049ec:	20001070 	.word	0x20001070

080049f0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80049f0:	b510      	push	{r4, lr}
 80049f2:	b082      	sub	sp, #8
 80049f4:	0002      	movs	r2, r0
 80049f6:	9100      	str	r1, [sp, #0]
 80049f8:	466b      	mov	r3, sp
 80049fa:	3307      	adds	r3, #7
 80049fc:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 80049fe:	466b      	mov	r3, sp
 8004a00:	3307      	adds	r3, #7
 8004a02:	781b      	ldrb	r3, [r3, #0]
 8004a04:	2b7f      	cmp	r3, #127	@ 0x7f
 8004a06:	d82c      	bhi.n	8004a62 <__NVIC_SetPriority+0x72>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004a08:	4a32      	ldr	r2, [pc, #200]	@ (8004ad4 <__NVIC_SetPriority+0xe4>)
 8004a0a:	466b      	mov	r3, sp
 8004a0c:	3307      	adds	r3, #7
 8004a0e:	781b      	ldrb	r3, [r3, #0]
 8004a10:	b25b      	sxtb	r3, r3
 8004a12:	089b      	lsrs	r3, r3, #2
 8004a14:	33c0      	adds	r3, #192	@ 0xc0
 8004a16:	009b      	lsls	r3, r3, #2
 8004a18:	589b      	ldr	r3, [r3, r2]
 8004a1a:	466a      	mov	r2, sp
 8004a1c:	3207      	adds	r2, #7
 8004a1e:	7812      	ldrb	r2, [r2, #0]
 8004a20:	0011      	movs	r1, r2
 8004a22:	2203      	movs	r2, #3
 8004a24:	400a      	ands	r2, r1
 8004a26:	00d2      	lsls	r2, r2, #3
 8004a28:	21ff      	movs	r1, #255	@ 0xff
 8004a2a:	4091      	lsls	r1, r2
 8004a2c:	000a      	movs	r2, r1
 8004a2e:	43d2      	mvns	r2, r2
 8004a30:	401a      	ands	r2, r3
 8004a32:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8004a34:	9b00      	ldr	r3, [sp, #0]
 8004a36:	019b      	lsls	r3, r3, #6
 8004a38:	22ff      	movs	r2, #255	@ 0xff
 8004a3a:	401a      	ands	r2, r3
 8004a3c:	466b      	mov	r3, sp
 8004a3e:	3307      	adds	r3, #7
 8004a40:	781b      	ldrb	r3, [r3, #0]
 8004a42:	0018      	movs	r0, r3
 8004a44:	2303      	movs	r3, #3
 8004a46:	4003      	ands	r3, r0
 8004a48:	00db      	lsls	r3, r3, #3
 8004a4a:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004a4c:	4821      	ldr	r0, [pc, #132]	@ (8004ad4 <__NVIC_SetPriority+0xe4>)
 8004a4e:	466b      	mov	r3, sp
 8004a50:	3307      	adds	r3, #7
 8004a52:	781b      	ldrb	r3, [r3, #0]
 8004a54:	b25b      	sxtb	r3, r3
 8004a56:	089b      	lsrs	r3, r3, #2
 8004a58:	430a      	orrs	r2, r1
 8004a5a:	33c0      	adds	r3, #192	@ 0xc0
 8004a5c:	009b      	lsls	r3, r3, #2
 8004a5e:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8004a60:	e035      	b.n	8004ace <__NVIC_SetPriority+0xde>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004a62:	4a1d      	ldr	r2, [pc, #116]	@ (8004ad8 <__NVIC_SetPriority+0xe8>)
 8004a64:	466b      	mov	r3, sp
 8004a66:	3307      	adds	r3, #7
 8004a68:	781b      	ldrb	r3, [r3, #0]
 8004a6a:	0019      	movs	r1, r3
 8004a6c:	230f      	movs	r3, #15
 8004a6e:	400b      	ands	r3, r1
 8004a70:	3b08      	subs	r3, #8
 8004a72:	089b      	lsrs	r3, r3, #2
 8004a74:	3306      	adds	r3, #6
 8004a76:	009b      	lsls	r3, r3, #2
 8004a78:	18d3      	adds	r3, r2, r3
 8004a7a:	3304      	adds	r3, #4
 8004a7c:	681b      	ldr	r3, [r3, #0]
 8004a7e:	466a      	mov	r2, sp
 8004a80:	3207      	adds	r2, #7
 8004a82:	7812      	ldrb	r2, [r2, #0]
 8004a84:	0011      	movs	r1, r2
 8004a86:	2203      	movs	r2, #3
 8004a88:	400a      	ands	r2, r1
 8004a8a:	00d2      	lsls	r2, r2, #3
 8004a8c:	21ff      	movs	r1, #255	@ 0xff
 8004a8e:	4091      	lsls	r1, r2
 8004a90:	000a      	movs	r2, r1
 8004a92:	43d2      	mvns	r2, r2
 8004a94:	401a      	ands	r2, r3
 8004a96:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8004a98:	9b00      	ldr	r3, [sp, #0]
 8004a9a:	019b      	lsls	r3, r3, #6
 8004a9c:	22ff      	movs	r2, #255	@ 0xff
 8004a9e:	401a      	ands	r2, r3
 8004aa0:	466b      	mov	r3, sp
 8004aa2:	3307      	adds	r3, #7
 8004aa4:	781b      	ldrb	r3, [r3, #0]
 8004aa6:	0018      	movs	r0, r3
 8004aa8:	2303      	movs	r3, #3
 8004aaa:	4003      	ands	r3, r0
 8004aac:	00db      	lsls	r3, r3, #3
 8004aae:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004ab0:	4809      	ldr	r0, [pc, #36]	@ (8004ad8 <__NVIC_SetPriority+0xe8>)
 8004ab2:	466b      	mov	r3, sp
 8004ab4:	3307      	adds	r3, #7
 8004ab6:	781b      	ldrb	r3, [r3, #0]
 8004ab8:	001c      	movs	r4, r3
 8004aba:	230f      	movs	r3, #15
 8004abc:	4023      	ands	r3, r4
 8004abe:	3b08      	subs	r3, #8
 8004ac0:	089b      	lsrs	r3, r3, #2
 8004ac2:	430a      	orrs	r2, r1
 8004ac4:	3306      	adds	r3, #6
 8004ac6:	009b      	lsls	r3, r3, #2
 8004ac8:	18c3      	adds	r3, r0, r3
 8004aca:	3304      	adds	r3, #4
 8004acc:	601a      	str	r2, [r3, #0]
}
 8004ace:	46c0      	nop			@ (mov r8, r8)
 8004ad0:	b002      	add	sp, #8
 8004ad2:	bd10      	pop	{r4, pc}
 8004ad4:	e000e100 	.word	0xe000e100
 8004ad8:	e000ed00 	.word	0xe000ed00
 8004adc:	00000000 	.word	0x00000000

08004ae0 <port_lock.lto_priv.26>:
  __ASM volatile ("cpsid i" : : : "memory");
 8004ae0:	b672      	cpsid	i
}
 8004ae2:	46c0      	nop			@ (mov r8, r8)
}
 8004ae4:	46c0      	nop			@ (mov r8, r8)
 8004ae6:	4770      	bx	lr
	...

08004af0 <port_unlock.lto_priv.26>:
  __ASM volatile ("cpsie i" : : : "memory");
 8004af0:	b662      	cpsie	i
}
 8004af2:	46c0      	nop			@ (mov r8, r8)
}
 8004af4:	46c0      	nop			@ (mov r8, r8)
 8004af6:	4770      	bx	lr
	...

08004b00 <port_lock_from_isr.lto_priv.7>:
static inline void port_lock_from_isr(void) {
 8004b00:	b510      	push	{r4, lr}
  port_lock();
 8004b02:	f7ff ffed 	bl	8004ae0 <port_lock.lto_priv.26>
}
 8004b06:	46c0      	nop			@ (mov r8, r8)
 8004b08:	bd10      	pop	{r4, pc}
 8004b0a:	46c0      	nop			@ (mov r8, r8)
 8004b0c:	0000      	movs	r0, r0
	...

08004b10 <port_unlock_from_isr.lto_priv.7>:
static inline void port_unlock_from_isr(void) {
 8004b10:	b510      	push	{r4, lr}
  port_unlock();
 8004b12:	f7ff ffed 	bl	8004af0 <port_unlock.lto_priv.26>
}
 8004b16:	46c0      	nop			@ (mov r8, r8)
 8004b18:	bd10      	pop	{r4, pc}
 8004b1a:	46c0      	nop			@ (mov r8, r8)
 8004b1c:	0000      	movs	r0, r0
	...

08004b20 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8004b20:	b500      	push	{lr}
 8004b22:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004b24:	f3ef 8309 	mrs	r3, PSP
 8004b28:	9301      	str	r3, [sp, #4]
  return(result);
 8004b2a:	9b01      	ldr	r3, [sp, #4]
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 8004b2c:	9303      	str	r3, [sp, #12]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8004b2e:	9b03      	ldr	r3, [sp, #12]
 8004b30:	3320      	adds	r3, #32
 8004b32:	9303      	str	r3, [sp, #12]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8004b34:	9b03      	ldr	r3, [sp, #12]
 8004b36:	9302      	str	r3, [sp, #8]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004b38:	9b02      	ldr	r3, [sp, #8]
 8004b3a:	f383 8809 	msr	PSP, r3
}
 8004b3e:	46c0      	nop			@ (mov r8, r8)

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8004b40:	f7ff ffe6 	bl	8004b10 <port_unlock_from_isr.lto_priv.7>
}
 8004b44:	46c0      	nop			@ (mov r8, r8)
 8004b46:	b005      	add	sp, #20
 8004b48:	bd00      	pop	{pc}
 8004b4a:	46c0      	nop			@ (mov r8, r8)
 8004b4c:	0000      	movs	r0, r0
	...

08004b50 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004b50:	b500      	push	{lr}
 8004b52:	b083      	sub	sp, #12
 8004b54:	9001      	str	r0, [sp, #4]

  (void)oip;

  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004b56:	2302      	movs	r3, #2
 8004b58:	425b      	negs	r3, r3
 8004b5a:	2100      	movs	r1, #0
 8004b5c:	0018      	movs	r0, r3
 8004b5e:	f7ff ff47 	bl	80049f0 <__NVIC_SetPriority>
}
 8004b62:	46c0      	nop			@ (mov r8, r8)
 8004b64:	b003      	add	sp, #12
 8004b66:	bd00      	pop	{pc}
	...

08004b70 <__port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void __port_irq_epilogue(uint32_t lr) {
 8004b70:	b500      	push	{lr}
 8004b72:	b087      	sub	sp, #28
 8004b74:	9001      	str	r0, [sp, #4]

  if (lr != 0xFFFFFFF1U) {
 8004b76:	9b01      	ldr	r3, [sp, #4]
 8004b78:	330f      	adds	r3, #15
 8004b7a:	d01e      	beq.n	8004bba <__port_irq_epilogue+0x4a>
    struct port_extctx *ectxp;

    port_lock_from_isr();
 8004b7c:	f7ff ffc0 	bl	8004b00 <port_lock_from_isr.lto_priv.7>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004b80:	f3ef 8309 	mrs	r3, PSP
 8004b84:	9303      	str	r3, [sp, #12]
  return(result);
 8004b86:	9b03      	ldr	r3, [sp, #12]

    /* The extctx structure is pointed by the PSP register.*/
    ectxp = (struct port_extctx *)__get_PSP();
 8004b88:	9305      	str	r3, [sp, #20]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ectxp--;
 8004b8a:	9b05      	ldr	r3, [sp, #20]
 8004b8c:	3b20      	subs	r3, #32
 8004b8e:	9305      	str	r3, [sp, #20]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ectxp);
 8004b90:	9b05      	ldr	r3, [sp, #20]
 8004b92:	9304      	str	r3, [sp, #16]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004b94:	9b04      	ldr	r3, [sp, #16]
 8004b96:	f383 8809 	msr	PSP, r3
}
 8004b9a:	46c0      	nop			@ (mov r8, r8)

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8004b9c:	9b05      	ldr	r3, [sp, #20]
 8004b9e:	2280      	movs	r2, #128	@ 0x80
 8004ba0:	0452      	lsls	r2, r2, #17
 8004ba2:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004ba4:	f7fe fcac 	bl	8003500 <chSchIsPreemptionRequired>
 8004ba8:	1e03      	subs	r3, r0, #0
 8004baa:	d003      	beq.n	8004bb4 <__port_irq_epilogue+0x44>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8004bac:	4a04      	ldr	r2, [pc, #16]	@ (8004bc0 <__port_irq_epilogue+0x50>)
 8004bae:	9b05      	ldr	r3, [sp, #20]
 8004bb0:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8004bb2:	e002      	b.n	8004bba <__port_irq_epilogue+0x4a>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8004bb4:	4a03      	ldr	r2, [pc, #12]	@ (8004bc4 <__port_irq_epilogue+0x54>)
 8004bb6:	9b05      	ldr	r3, [sp, #20]
 8004bb8:	619a      	str	r2, [r3, #24]
}
 8004bba:	46c0      	nop			@ (mov r8, r8)
 8004bbc:	b007      	add	sp, #28
 8004bbe:	bd00      	pop	{pc}
 8004bc0:	080001cb 	.word	0x080001cb
 8004bc4:	080001d6 	.word	0x080001d6
	...

08004bd0 <portab_setup>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

void portab_setup(void) {
 8004bd0:	b510      	push	{r4, lr}

  /* ADC inputs.*/
  palSetGroupMode(GPIOC, PAL_PORT_BIT(0) | PAL_PORT_BIT(1),
 8004bd2:	4b04      	ldr	r3, [pc, #16]	@ (8004be4 <portab_setup+0x14>)
 8004bd4:	2203      	movs	r2, #3
 8004bd6:	2103      	movs	r1, #3
 8004bd8:	0018      	movs	r0, r3
 8004bda:	f7fc fee1 	bl	80019a0 <_pal_lld_setgroupmode>
                  0, PAL_MODE_INPUT_ANALOG);
}
 8004bde:	46c0      	nop			@ (mov r8, r8)
 8004be0:	bd10      	pop	{r4, pc}
 8004be2:	46c0      	nop			@ (mov r8, r8)
 8004be4:	50000800 	.word	0x50000800
	...

08004bf0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8004bf0:	b082      	sub	sp, #8
 8004bf2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8004bf4:	4b03      	ldr	r3, [pc, #12]	@ (8004c04 <chRegSetThreadName+0x14>)
 8004bf6:	68db      	ldr	r3, [r3, #12]
 8004bf8:	9a01      	ldr	r2, [sp, #4]
 8004bfa:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 8004bfc:	46c0      	nop			@ (mov r8, r8)
 8004bfe:	b002      	add	sp, #8
 8004c00:	4770      	bx	lr
 8004c02:	46c0      	nop			@ (mov r8, r8)
 8004c04:	20000690 	.word	0x20000690
	...

08004c10 <adccallback>:

/*
 * ADC streaming callback.
 */
size_t n= 0, nx = 0, ny = 0;
void adccallback(ADCDriver *adcp) {
 8004c10:	b500      	push	{lr}
 8004c12:	b083      	sub	sp, #12
 8004c14:	9001      	str	r0, [sp, #4]

  /* Updating counters.*/
  n++;
 8004c16:	4b0e      	ldr	r3, [pc, #56]	@ (8004c50 <adccallback+0x40>)
 8004c18:	681b      	ldr	r3, [r3, #0]
 8004c1a:	1c5a      	adds	r2, r3, #1
 8004c1c:	4b0c      	ldr	r3, [pc, #48]	@ (8004c50 <adccallback+0x40>)
 8004c1e:	601a      	str	r2, [r3, #0]
  if (adcIsBufferComplete(adcp)) {
 8004c20:	9b01      	ldr	r3, [sp, #4]
 8004c22:	781b      	ldrb	r3, [r3, #0]
 8004c24:	2b04      	cmp	r3, #4
 8004c26:	d105      	bne.n	8004c34 <adccallback+0x24>
    nx += 1;
 8004c28:	4b0a      	ldr	r3, [pc, #40]	@ (8004c54 <adccallback+0x44>)
 8004c2a:	681b      	ldr	r3, [r3, #0]
 8004c2c:	1c5a      	adds	r2, r3, #1
 8004c2e:	4b09      	ldr	r3, [pc, #36]	@ (8004c54 <adccallback+0x44>)
 8004c30:	601a      	str	r2, [r3, #0]
 8004c32:	e004      	b.n	8004c3e <adccallback+0x2e>
  }
  else {
    ny += 1;
 8004c34:	4b08      	ldr	r3, [pc, #32]	@ (8004c58 <adccallback+0x48>)
 8004c36:	681b      	ldr	r3, [r3, #0]
 8004c38:	1c5a      	adds	r2, r3, #1
 8004c3a:	4b07      	ldr	r3, [pc, #28]	@ (8004c58 <adccallback+0x48>)
 8004c3c:	601a      	str	r2, [r3, #0]
  }

  if ((n % 200) == 0U) {
 8004c3e:	4b04      	ldr	r3, [pc, #16]	@ (8004c50 <adccallback+0x40>)
 8004c40:	681b      	ldr	r3, [r3, #0]
 8004c42:	21c8      	movs	r1, #200	@ 0xc8
 8004c44:	0018      	movs	r0, r3
 8004c46:	f7fb fb0b 	bl	8000260 <__aeabi_uidivmod>
#if defined(PORTAB_LINE_LED2)
    palToggleLine(PORTAB_LINE_LED2);
#endif
  }
}
 8004c4a:	46c0      	nop			@ (mov r8, r8)
 8004c4c:	b003      	add	sp, #12
 8004c4e:	bd00      	pop	{pc}
 8004c50:	20001278 	.word	0x20001278
 8004c54:	2000127c 	.word	0x2000127c
 8004c58:	20001280 	.word	0x20001280
 8004c5c:	00000000 	.word	0x00000000

08004c60 <adcerrorcallback>:

/*
 * ADC errors callback, should never happen.
 */
void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8004c60:	b500      	push	{lr}
 8004c62:	b083      	sub	sp, #12
 8004c64:	9001      	str	r0, [sp, #4]
 8004c66:	9100      	str	r1, [sp, #0]

  (void)adcp;
  (void)err;

  chSysHalt("it happened");
 8004c68:	4b03      	ldr	r3, [pc, #12]	@ (8004c78 <adcerrorcallback+0x18>)
 8004c6a:	0018      	movs	r0, r3
 8004c6c:	f7fd fa00 	bl	8002070 <chSysHalt>
}
 8004c70:	46c0      	nop			@ (mov r8, r8)
 8004c72:	b003      	add	sp, #12
 8004c74:	bd00      	pop	{pc}
 8004c76:	46c0      	nop			@ (mov r8, r8)
 8004c78:	080050a8 	.word	0x080050a8
 8004c7c:	00000000 	.word	0x00000000

08004c80 <Thread1>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED attached to TP1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8004c80:	b500      	push	{lr}
 8004c82:	b083      	sub	sp, #12
 8004c84:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 8004c86:	4b0c      	ldr	r3, [pc, #48]	@ (8004cb8 <Thread1+0x38>)
 8004c88:	0018      	movs	r0, r3
 8004c8a:	f7ff ffb1 	bl	8004bf0 <chRegSetThreadName>
  while (true) {
    palSetLine(PORTAB_LINE_LED1);
 8004c8e:	23a0      	movs	r3, #160	@ 0xa0
 8004c90:	05db      	lsls	r3, r3, #23
 8004c92:	2220      	movs	r2, #32
 8004c94:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8004c96:	23fa      	movs	r3, #250	@ 0xfa
 8004c98:	005b      	lsls	r3, r3, #1
 8004c9a:	0018      	movs	r0, r3
 8004c9c:	f7ff f8a0 	bl	8003de0 <chThdSleep>
    palClearLine(PORTAB_LINE_LED1);
 8004ca0:	23a0      	movs	r3, #160	@ 0xa0
 8004ca2:	05db      	lsls	r3, r3, #23
 8004ca4:	2220      	movs	r2, #32
 8004ca6:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8004ca8:	23fa      	movs	r3, #250	@ 0xfa
 8004caa:	005b      	lsls	r3, r3, #1
 8004cac:	0018      	movs	r0, r3
 8004cae:	f7ff f897 	bl	8003de0 <chThdSleep>
    palSetLine(PORTAB_LINE_LED1);
 8004cb2:	46c0      	nop			@ (mov r8, r8)
 8004cb4:	e7eb      	b.n	8004c8e <Thread1+0xe>
 8004cb6:	46c0      	nop			@ (mov r8, r8)
 8004cb8:	080050b4 	.word	0x080050b4
 8004cbc:	00000000 	.word	0x00000000

08004cc0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8004cc0:	b500      	push	{lr}
 8004cc2:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8004cc4:	f7fb fb34 	bl	8000330 <halInit>
  chSysInit();
 8004cc8:	f7fd f9a2 	bl	8002010 <chSysInit>

  /* Board-dependent GPIO setup code.*/
  portab_setup();
 8004ccc:	f7ff ff80 	bl	8004bd0 <portab_setup>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8004cd0:	4b20      	ldr	r3, [pc, #128]	@ (8004d54 <main+0x94>)
 8004cd2:	22a8      	movs	r2, #168	@ 0xa8
 8004cd4:	0051      	lsls	r1, r2, #1
 8004cd6:	4820      	ldr	r0, [pc, #128]	@ (8004d58 <main+0x98>)
 8004cd8:	2200      	movs	r2, #0
 8004cda:	9200      	str	r2, [sp, #0]
 8004cdc:	2280      	movs	r2, #128	@ 0x80
 8004cde:	f7fe ff3f 	bl	8003b60 <chThdCreateStatic>

  /*
   * Starting PORTAB_ADC1 driver and the temperature sensor.
   */
  adcStart(&PORTAB_ADC1, &portab_adccfg1);
 8004ce2:	4a1e      	ldr	r2, [pc, #120]	@ (8004d5c <main+0x9c>)
 8004ce4:	4b1e      	ldr	r3, [pc, #120]	@ (8004d60 <main+0xa0>)
 8004ce6:	0011      	movs	r1, r2
 8004ce8:	0018      	movs	r0, r3
 8004cea:	f7fb fc89 	bl	8000600 <adcStart>
  adcSTM32EnableVREF(&PORTAB_ADC1);
 8004cee:	4b1c      	ldr	r3, [pc, #112]	@ (8004d60 <main+0xa0>)
 8004cf0:	0018      	movs	r0, r3
 8004cf2:	f7fc fd0d 	bl	8001710 <adcSTM32EnableVREF>
  adcSTM32EnableTS(&PORTAB_ADC1);
 8004cf6:	4b1a      	ldr	r3, [pc, #104]	@ (8004d60 <main+0xa0>)
 8004cf8:	0018      	movs	r0, r3
 8004cfa:	f7fc fd19 	bl	8001730 <adcSTM32EnableTS>

  /* Performing a one-shot conversion on two channels.*/
  adcConvert(&PORTAB_ADC1, &portab_adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
 8004cfe:	4a19      	ldr	r2, [pc, #100]	@ (8004d64 <main+0xa4>)
 8004d00:	4919      	ldr	r1, [pc, #100]	@ (8004d68 <main+0xa8>)
 8004d02:	4817      	ldr	r0, [pc, #92]	@ (8004d60 <main+0xa0>)
 8004d04:	2302      	movs	r3, #2
 8004d06:	f7fb fd83 	bl	8000810 <adcConvert>
  cacheBufferInvalidate(samples1, sizeof (samples1) / sizeof (adcsample_t));

  /*
   * Starting PORTAB_GPT1 driver, it is used for triggering the ADC.
   */
  gptStart(&PORTAB_GPT1, &portab_gptcfg1);
 8004d0a:	4a18      	ldr	r2, [pc, #96]	@ (8004d6c <main+0xac>)
 8004d0c:	4b18      	ldr	r3, [pc, #96]	@ (8004d70 <main+0xb0>)
 8004d0e:	0011      	movs	r1, r2
 8004d10:	0018      	movs	r0, r3
 8004d12:	f7fb fe0d 	bl	8000930 <gptStart>

  /*
   * Starting an ADC continuous conversion triggered with a period of
   * 1/10000 second.
   */
  adcStartConversion(&PORTAB_ADC1, &portab_adcgrpcfg2,
 8004d16:	4a17      	ldr	r2, [pc, #92]	@ (8004d74 <main+0xb4>)
 8004d18:	4917      	ldr	r1, [pc, #92]	@ (8004d78 <main+0xb8>)
 8004d1a:	4811      	ldr	r0, [pc, #68]	@ (8004d60 <main+0xa0>)
 8004d1c:	2340      	movs	r3, #64	@ 0x40
 8004d1e:	f7fb fcaf 	bl	8000680 <adcStartConversion>
                     samples2, ADC_GRP2_BUF_DEPTH);
  gptStartContinuous(&PORTAB_GPT1, 100U);
 8004d22:	4b13      	ldr	r3, [pc, #76]	@ (8004d70 <main+0xb0>)
 8004d24:	2164      	movs	r1, #100	@ 0x64
 8004d26:	0018      	movs	r0, r3
 8004d28:	f7fb fe4a 	bl	80009c0 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the
   * conversion is stopped.
   */
  while (true) {
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8004d2c:	4b13      	ldr	r3, [pc, #76]	@ (8004d7c <main+0xbc>)
 8004d2e:	691a      	ldr	r2, [r3, #16]
 8004d30:	2380      	movs	r3, #128	@ 0x80
 8004d32:	019b      	lsls	r3, r3, #6
 8004d34:	4013      	ands	r3, r2
 8004d36:	d107      	bne.n	8004d48 <main+0x88>
      gptStopTimer(&PORTAB_GPT1);
 8004d38:	4b0d      	ldr	r3, [pc, #52]	@ (8004d70 <main+0xb0>)
 8004d3a:	0018      	movs	r0, r3
 8004d3c:	f7fb fe88 	bl	8000a50 <gptStopTimer>
      adcStopConversion(&PORTAB_ADC1);
 8004d40:	4b07      	ldr	r3, [pc, #28]	@ (8004d60 <main+0xa0>)
 8004d42:	0018      	movs	r0, r3
 8004d44:	f7fb fd24 	bl	8000790 <adcStopConversion>
    }
    chThdSleepMilliseconds(500);
 8004d48:	23fa      	movs	r3, #250	@ 0xfa
 8004d4a:	005b      	lsls	r3, r3, #1
 8004d4c:	0018      	movs	r0, r3
 8004d4e:	f7ff f847 	bl	8003de0 <chThdSleep>
    if (palReadLine(PORTAB_LINE_BUTTON) == PORTAB_BUTTON_PRESSED) {
 8004d52:	e7eb      	b.n	8004d2c <main+0x6c>
 8004d54:	08004c81 	.word	0x08004c81
 8004d58:	20001288 	.word	0x20001288
 8004d5c:	08005354 	.word	0x08005354
 8004d60:	20000600 	.word	0x20000600
 8004d64:	20001074 	.word	0x20001074
 8004d68:	08005358 	.word	0x08005358
 8004d6c:	08005344 	.word	0x08005344
 8004d70:	20000674 	.word	0x20000674
 8004d74:	20001078 	.word	0x20001078
 8004d78:	08005374 	.word	0x08005374
 8004d7c:	50000800 	.word	0x50000800
